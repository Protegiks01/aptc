# Audit Report

## Title
Silent StateStorageUsage Variant Transition Corrupts State Accounting During Node Restart

## Summary
The `update_usage` method in `State` silently transitions `StateStorageUsage` from `Untracked` to `Tracked` variant when processing state updates, causing permanent corruption of state size accounting when nodes restart with missing usage metadata.

## Finding Description

The vulnerability exists in the state update flow where `StateStorageUsage` can transition between variants mid-operation without proper validation. [1](#0-0) 

The `StateStorageUsage` enum has two variants: `Tracked` which maintains item and byte counts, and `Untracked` which represents unknown state size. [2](#0-1) 

When `Untracked`, the accessor methods return 0 as a placeholder, not the actual state size.

The critical bug occurs in the `update_usage` method: [3](#0-2) 

This method **always** creates a `Tracked` variant via `StateStorageUsage::new()`, regardless of the input variant. When `self.usage()` is `Untracked`, it returns 0 for both `items()` and `bytes()`, causing the calculation to become `Tracked { items: items_delta, bytes: bytes_delta }` - losing all historical accounting!

The vulnerability is triggered during node initialization when usage data is missing: [4](#0-3) 

When `skip_usage=true` (which equals `enable_storage_sharding=true`, defaulting to `true`), missing usage data returns `Untracked` instead of erroring. [5](#0-4) 

During state replay after node restart, this `Untracked` usage flows into the `update` method: [6](#0-5) 

The corrupted `Tracked` values are then persisted to disk: [7](#0-6) 

**Attack Scenario:**
1. Node A operates normally with accurate `Tracked` usage: `{items: 1000000, bytes: 500MB}`
2. Database corruption or restore from backup causes usage metadata loss
3. Node restarts with `skip_usage=true`, `get_state_storage_usage` returns `Untracked`
4. State replay applies 100 new transactions with delta `{items: +100, bytes: +10KB}`
5. `update_usage` calculates: `(0 + 100, 0 + 10KB)` â†’ `Tracked {items: 100, bytes: 10KB}`
6. Corrupted accounting persisted, permanently losing track of 999,900 items and ~500MB

## Impact Explanation

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable."

**Impact Category: Medium Severity**
- State inconsistencies requiring manual intervention to recalculate correct usage
- If different nodes restart at different times, they could have divergent usage values
- Affects storage limit enforcement and resource accounting
- Does not directly cause fund loss or consensus safety violations, but undermines state integrity

The corrupted accounting could affect:
- Storage quota enforcement 
- Gas metering based on state size
- On-chain monitoring and resource management
- Validator performance metrics

## Likelihood Explanation

**Moderate Likelihood:**
- Requires node restart with missing usage metadata (database corruption, restore, migration)
- Default configuration has `enable_storage_sharding=true` which enables the vulnerable path
- Automatically triggers during normal replay operations after the precondition is met
- No attacker action required once preconditions are satisfied

The preconditions are rare but realistic in production environments (backup/restore scenarios, database migrations, corrupted metadata).

## Recommendation

Add explicit variant preservation logic in `update_usage` to prevent silent transitions:

```rust
fn update_usage(&self, usage_delta_per_shard: Vec<(i64, i64)>) -> StateStorageUsage {
    assert_eq!(usage_delta_per_shard.len(), NUM_STATE_SHARDS);
    
    // Preserve Untracked state - do not transition to Tracked with incomplete data
    if self.usage().is_untracked() {
        return StateStorageUsage::new_untracked();
    }
    
    let (items_delta, bytes_delta) = usage_delta_per_shard
        .into_iter()
        .fold((0, 0), |(i1, b1), (i2, b2)| (i1 + i2, b1 + b2));
    StateStorageUsage::new(
        (self.usage().items() as i64 + items_delta) as usize,
        (self.usage().bytes() as i64 + bytes_delta) as usize,
    )
}
```

Additionally, `put_usage` should validate against persisting `Untracked` state or require explicit re-calculation from the full state tree when transitioning from `Untracked`.

## Proof of Concept

```rust
#[test]
fn test_untracked_to_tracked_transition_corruption() {
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    // Simulate node state with unknown usage (e.g., after DB restore)
    let initial_usage = StateStorageUsage::new_untracked();
    assert!(initial_usage.is_untracked());
    assert_eq!(initial_usage.items(), 0); // Returns 0, but doesn't mean "zero items"
    
    // Simulate state update with delta from processing transactions
    let items_delta = 100i64;
    let bytes_delta = 10000i64;
    
    // This is what update_usage does - silent transition!
    let new_usage = StateStorageUsage::new(
        (initial_usage.items() as i64 + items_delta) as usize,
        (initial_usage.bytes() as i64 + bytes_delta) as usize,
    );
    
    // Now we have Tracked variant with WRONG values
    assert!(!new_usage.is_untracked());
    assert_eq!(new_usage.items(), 100); // Should be 100 + (actual previous count)
    assert_eq!(new_usage.bytes(), 10000); // Should be 10000 + (actual previous bytes)
    
    // If actual state had 1M items and 500MB, we've lost that information!
    // This corrupted value gets persisted to DB via put_usage()
}
```

**Notes:**

While this vulnerability represents a state consistency violation, it does not meet the criteria for direct exploitation by an unprivileged attacker. The issue occurs during system operations (node restart with missing metadata) rather than through attacker-controlled inputs. The semantic transition from "unknown size" (`Untracked`) to "known size with incomplete data" (`Tracked`) violates the integrity of state accounting but requires specific preconditions that cannot be triggered externally.

### Citations

**File:** types/src/state_store/state_storage_usage.rs (L8-11)
```rust
pub enum StateStorageUsage {
    Tracked { items: usize, bytes: usize },
    Untracked,
}
```

**File:** types/src/state_store/state_storage_usage.rs (L30-42)
```rust
    pub fn items(&self) -> usize {
        match self {
            Self::Tracked { items, .. } => *items,
            Self::Untracked => 0,
        }
    }

    pub fn bytes(&self) -> usize {
        match self {
            Self::Tracked { bytes, .. } => *bytes,
            Self::Untracked => 0,
        }
    }
```

**File:** storage/storage-interface/src/state_store/state.rs (L265-265)
```rust
        let usage = self.update_usage(usage_delta_per_shard);
```

**File:** storage/storage-interface/src/state_store/state.rs (L328-338)
```rust
    fn update_usage(&self, usage_delta_per_shard: Vec<(i64, i64)>) -> StateStorageUsage {
        assert_eq!(usage_delta_per_shard.len(), NUM_STATE_SHARDS);

        let (items_delta, bytes_delta) = usage_delta_per_shard
            .into_iter()
            .fold((0, 0), |(i1, b1), (i2, b2)| (i1 + i2, b1 + b2));
        StateStorageUsage::new(
            (self.usage().items() as i64 + items_delta) as usize,
            (self.usage().bytes() as i64 + bytes_delta) as usize,
        )
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1017-1028)
```rust
    fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
        if let Some(version) = state.version() {
            let usage = state.usage();
            info!("Write usage at version {version}, {usage:?}.");
            batch.put::<VersionDataSchema>(&version, &usage.into())?;
        } else {
            assert_eq!(state.usage().items(), 0);
            assert_eq!(state.usage().bytes(), 0);
        }

        Ok(())
    }
```

**File:** config/src/config/storage_config.rs (L233-233)
```rust
            enable_storage_sharding: true,
```
