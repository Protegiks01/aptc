# Audit Report

## Title
Byzantine Peers Can Force Selection of Unverified Ledger Info Through Highest Version Manipulation

## Summary
The state sync system accepts peer-advertised `synced_ledger_info` values without signature verification and resolves conflicts by selecting the ledger info with the highest version number. Byzantine peers can advertise fake `LedgerInfoWithSignatures` with arbitrarily high versions, causing incorrect state sync decisions, resource exhaustion, and node bootstrapping failures.

## Finding Description

The vulnerability exists in the state synchronization protocol's handling of advertised ledger information from peers. When multiple peers advertise different `synced_ledger_info` values, the system collects these without verification and selects the one with the highest version number.

**Attack Flow:**

1. **Unverified Collection** - Peers advertise their storage summaries containing `synced_ledger_info`. These are collected without cryptographic verification: [1](#0-0) 

2. **Naive Conflict Resolution** - The highest version is selected without signature validation: [2](#0-1) 

3. **No Verification on Update** - Storage summaries are stored directly without verification: [3](#0-2) [4](#0-3) 

**Exploitation:**

A Byzantine peer crafts a `StorageServerSummary` with a fake `synced_ledger_info` containing an arbitrarily high version (e.g., version 999,999,999) but invalid or missing signatures. The data client accepts this and includes it in the global data summary. Since conflict resolution only compares version numbers, the fake ledger info is selected as the "highest synced ledger info."

**Critical Usage Points:**

1. **Waypoint Satisfiability**: Used to determine if the network can satisfy the node's waypoint, potentially bypassing safety checks: [5](#0-4) 

2. **Subscription Stream Lag Detection**: Used to determine if subscription streams are lagging, causing false stream failures: [6](#0-5) 

3. **Stream Target Selection**: Selected as the target for continuous transaction streams when no explicit target is provided: [7](#0-6) 

**Broken Invariant:** The state sync protocol assumes that advertised ledger information from peers is trustworthy for making synchronization decisions, violating the "untrusted network peers" security model.

## Impact Explanation

**Severity: High** (per "Validator node slowdowns" category)

This vulnerability enables Byzantine peers to:

1. **Resource Exhaustion**: Force honest nodes to waste CPU, network bandwidth, and time attempting to fetch non-existent data from advertised but fake high versions

2. **Bootstrapping Disruption**: Cause new nodes or nodes recovering from downtime to fail bootstrapping by making the waypoint appear satisfiable when it isn't, leading to repeated fetch attempts and failures

3. **Stream Failures**: Cause continuous transaction and output subscription streams to be marked as "lagging" and fail, requiring constant stream resets and degrading sync performance

4. **Peer Selection Manipulation**: Dominate peer selection for data requests since peers advertising higher versions are preferred, causing requests to be routed to malicious peers

While actual data verification occurs when fetched (preventing consensus violations), the attack causes significant operational degradation:
- Validator nodes experience slowdowns due to failed requests and stream resets
- Network bandwidth is wasted on requests to Byzantine peers
- New nodes cannot bootstrap efficiently
- Continuous sync operations are disrupted

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable:
- Any network peer can advertise a storage summary with fake `synced_ledger_info`
- No authentication or authorization is required beyond network connectivity
- The attack is passive (no need to respond to requests, just advertise)
- Multiple Byzantine peers can collude to amplify the effect
- Detection is difficult because the fake ledger info appears valid structurally

The only mitigating factor is the peer scoring system, which eventually penalizes peers that fail to deliver data. However:
- The damage occurs before scoring takes effect
- Peers can be rotated to avoid score-based ignoring
- The threshold for ignoring is high (score <= 25 out of 100) [8](#0-7) 

## Recommendation

Implement cryptographic verification of `synced_ledger_info` before using it for any synchronization decisions:

```rust
// In peer_states.rs, update_summary should verify signatures
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Verify synced_ledger_info signatures before accepting
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        // Fetch the epoch state for this ledger info's epoch
        // Verify signatures against the validator set
        // Only accept if verification passes
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

Additionally:

1. **Add Epoch State Context**: Maintain a cache of recent epoch states to verify ledger info signatures
2. **Implement Sanity Bounds**: Reject ledger infos with versions unreasonably far ahead of the local version (e.g., > 10,000 versions ahead)
3. **Enhanced Peer Scoring**: Immediately penalize peers advertising unverifiable ledger infos as malicious
4. **Use Majority Consensus**: Instead of selecting the highest version, use the median or require multiple peers to agree on similar versions

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_byzantine_ledger_info_selection() {
    use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
    use aptos_storage_service_types::responses::{DataSummary, StorageServerSummary};
    
    // Setup: Create a data client with peer states
    let config = AptosDataClientConfig::default();
    let peer_states = PeerStates::new(Arc::new(config));
    
    // Honest peer advertises version 100
    let honest_peer = PeerNetworkId::random();
    let honest_ledger_info = create_ledger_info_with_sigs(100, true); // valid sigs
    let honest_summary = create_storage_summary(honest_ledger_info);
    peer_states.update_summary(honest_peer, honest_summary);
    
    // Byzantine peer advertises version 999999 with fake/missing signatures
    let byzantine_peer = PeerNetworkId::random();
    let fake_ledger_info = create_ledger_info_with_sigs(999999, false); // invalid sigs
    let byzantine_summary = create_storage_summary(fake_ledger_info);
    peer_states.update_summary(byzantine_peer, byzantine_summary);
    
    // Calculate global summary
    let global_summary = peer_states.calculate_global_data_summary();
    
    // VULNERABILITY: The fake ledger info with version 999999 is selected!
    let highest = global_summary.advertised_data.highest_synced_ledger_info().unwrap();
    assert_eq!(highest.ledger_info().version(), 999999);
    
    // This fake ledger info is now used for:
    // - Waypoint satisfiability checks
    // - Stream lag detection
    // - Stream target selection
    // Without ever verifying the signatures!
}
```

## Notes

While the actual data fetched from streams undergoes verification (preventing consensus violations), the unverified advertised data is used for critical synchronization decisions. This creates a vector for Byzantine peers to disrupt state sync operations, cause resource exhaustion, and prevent efficient bootstrapping, qualifying as a "Validator node slowdowns" issue at High severity.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L151-160)
```rust
    /// Returns true iff the peer is currently ignored
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L177-179)
```rust
    fn update_storage_summary(&mut self, storage_summary: StorageServerSummary) {
        self.storage_summary = Some(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L325-330)
```rust
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L894-902)
```rust
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L587-607)
```rust
        let highest_advertised_version = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .map(|ledger_info| ledger_info.ledger_info().version())
            .ok_or_else(|| {
                aptos_data_client::error::Error::UnexpectedErrorEncountered(
                    "The highest synced ledger info is missing from the global data summary!"
                        .into(),
                )
            })?;

        // If the stream is not lagging behind, reset the lag and return
        if highest_response_version >= highest_advertised_version {
            self.reset_subscription_stream_lag();
            return Ok(());
        }

        // Otherwise, the stream is lagging behind the advertised version.
        // Check if the stream is beyond recovery (i.e., has failed).
        let current_stream_lag =
            highest_advertised_version.saturating_sub(highest_response_version);
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L523-529)
```rust
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
            }
```
