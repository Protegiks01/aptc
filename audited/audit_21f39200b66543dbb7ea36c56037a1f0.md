# Audit Report

## Title
Cryptographic Proof Verification Bypass in DbStateView Due to Silent Error Handling

## Summary
The `DbStateView::get()` function in `db_state_view.rs` silently swallows errors from `get_state_value_with_proof_by_version`, allowing it to return unverified state values when proof generation fails. This creates a critical window where state merkle tree pruning (default: 1M versions) occurs much earlier than state KV data pruning (default: 90M versions), enabling proof verification bypass for 89 million versions of historical state.

## Finding Description

The vulnerability exists in the `get()` function's error handling logic: [1](#0-0) 

When `maybe_verify_against_state_root_hash` is set (indicating verified mode), the code attempts proof verification but uses `if let Ok((value, proof)) = ...` which silently discards any errors. When `get_state_value_with_proof_by_version` fails, no verification occurs, yet the function proceeds to return a value from `get_state_value_with_version_by_version`.

**Attack Scenario:**

The `get_state_value_with_proof_by_version` call fails with a "state merkle pruned" error when the merkle tree has been pruned: [2](#0-1) 

This check delegates to: [3](#0-2) 

**Critical Configuration Gap:**

State merkle pruner default window: 1,000,000 versions [4](#0-3) 

State KV pruner default window: 90,000,000 versions (uses LedgerPrunerConfig) [5](#0-4) 

State KV pruner is initialized with ledger_pruner_config: [6](#0-5) 

This creates an **89-million-version window** where merkle proofs cannot be generated but state values still exist, allowing unverified state reads.

**Regarding the Original Question:**

When value is `None`, proof verification DOES occur if the call succeeds. The `SparseMerkleProof::verify` implementation properly handles non-inclusion proofs: [7](#0-6) [8](#0-7) 

However, the real vulnerability is not with null/None values specifically—it's that **any error** in proof generation bypasses verification entirely.

## Impact Explanation

**Severity: Medium**

This vulnerability violates the **State Consistency** invariant (#4): "State transitions must be atomic and verifiable via Merkle proofs."

Impact:
- Bypasses cryptographic proof verification for state reads in the 89M-version pruning window
- Returns state values that cannot be cryptographically proven against committed state roots
- Could allow serving incorrect state if the KV database becomes corrupted while merkle DB remains intact
- Affects any code using `verified_state_view_at_version` which is intended to provide cryptographic guarantees [9](#0-8) 

This is Medium severity rather than Critical because:
1. It's a read-only operation (no direct consensus violation)
2. Requires specific conditions (pruned merkle tree but unpruned KV data)
3. Does not directly enable fund theft or consensus breaks
4. Requires database inconsistency to cause actual harm

However, it represents a significant violation of the "verified" state view guarantee.

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers automatically in normal operations:
- Default configuration creates the 89M-version gap
- Any query for state at versions older than 1M from current tip will trigger this
- State sync, historical queries, and archival node operations regularly access old state
- No attacker action required—the vulnerability exists in the design

The vulnerability is **currently active** on all nodes running with default pruning configuration.

## Recommendation

**Fix 1: Fail-Fast on Verification Errors (Recommended)**

Change the error handling to propagate errors instead of silently swallowing them:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // Verification is required - any error must fail the entire operation
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            Ok(value.map(|v| (version, v)))
        } else {
            Ok(self.db.get_state_value_with_version_by_version(key, version)?)
        }
    } else {
        Ok(None)
    }
}
```

This ensures that when verification is requested, it either succeeds or the entire operation fails—no silent bypasses.

**Fix 2: Align Pruning Windows**

Ensure state merkle pruning window is at least as large as state KV pruning window to eliminate the gap:

```rust
impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // Align with ledger pruner to ensure proofs are always available
            prune_window: 90_000_000,  // Changed from 1_000_000
            batch_size: 1_000,
        }
    }
}
```

**Fix 3: Return the Verified Value**

The current code verifies one value but returns a different one from a separate DB call (TOCTOU issue). Return the verified value instead:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            let (value, proof) = self.db.get_state_value_with_proof_by_version(key, version)?;
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
            // Return the verified value directly
            Ok(value.map(|v| (version, v)))
        } else {
            Ok(self.db.get_state_value_with_version_by_version(key, version)?)
        }
    } else {
        Ok(None)
    }
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_proof_verification_bypass() {
    use aptos_types::state_store::state_key::StateKey;
    use storage_interface::{DbReader, VerifiedStateViewAtVersion};
    
    // Setup: Create a DB with pruned merkle tree but unpruned KV data
    let db = setup_test_db_with_pruned_merkle(); // Helper function
    
    // Create a state key to query
    let state_key = StateKey::raw(b"test_key");
    
    // Set the version to be in the pruning gap (merkle pruned, KV not pruned)
    let pruned_version = 500_000; // Within 1M merkle prune window
    
    // Get the latest ledger info for verification
    let ledger_info = db.get_latest_ledger_info().unwrap();
    
    // Create a "verified" state view at the pruned version
    let verified_view = db
        .verified_state_view_at_version(Some(pruned_version), &ledger_info)
        .unwrap();
    
    // This should fail because merkle tree is pruned and proofs cannot be generated
    // But due to the bug, it returns an unverified value
    let result = verified_view.get_state_slot(&state_key);
    
    // The call succeeds even though no proof verification occurred
    assert!(result.is_ok());
    
    // This violates the security guarantee of "verified" state views
    // The value returned was NOT cryptographically verified
}
```

The vulnerability can also be demonstrated by:
1. Running a node with default configuration
2. Waiting for state to age beyond 1M versions
3. Querying state at version `current - 2M` using `verified_state_view_at_version`
4. Observing that the query succeeds despite merkle tree being pruned
5. Confirming no proof verification occurred (can be logged)

## Notes

This vulnerability specifically answers the original security question: "When value is None, does proof verification still occur?" The answer is YES, when the proof generation succeeds—but the real vulnerability is that when proof generation FAILS for any reason (including for None values), verification is silently bypassed. The issue affects all values (Some and None) equally when the merkle tree is pruned.

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L107-147)
```rust
pub trait VerifiedStateViewAtVersion {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView>;
}

impl VerifiedStateViewAtVersion for Arc<dyn DbReader> {
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
        } else {
            Ok(DbStateView {
                db,
                version: None,
                maybe_verify_against_state_root_hash: None,
            })
        }
    }
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L677-694)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        gauged_api("get_state_value_with_proof_by_version_ext", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;

            self.state_store.get_state_value_with_proof_by_version_ext(
                key_hash,
                version,
                root_depth,
                use_hot_state,
            )
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L60-80)
```rust
        let state_merkle_pruner = StateMerklePrunerManager::new(
            Arc::clone(&state_merkle_db),
            pruner_config.state_merkle_pruner_config,
        );
        let epoch_snapshot_pruner = StateMerklePrunerManager::new(
            Arc::clone(&state_merkle_db),
            pruner_config.epoch_snapshot_pruner_config.into(),
        );
        let state_kv_pruner =
            StateKvPrunerManager::new(Arc::clone(&state_kv_db), pruner_config.ledger_pruner_config);
        let state_store = Arc::new(StateStore::new(
            Arc::clone(&ledger_db),
            hot_state_merkle_db,
            Arc::clone(&state_merkle_db),
            Arc::clone(&state_kv_db),
            state_merkle_pruner,
            epoch_snapshot_pruner,
            state_kv_pruner,
            buffered_state_target_items,
            hack_for_tests,
            empty_buffered_state_for_restore,
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-300)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
```

**File:** config/src/config/storage_config.rs (L387-395)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
```

**File:** config/src/config/storage_config.rs (L398-412)
```rust
impl Default for StateMerklePrunerConfig {
    fn default() -> Self {
        StateMerklePrunerConfig {
            enable: true,
            // This allows a block / chunk being executed to have access to a non-latest state tree.
            // It needs to be greater than the number of versions the state committing thread is
            // able to commit during the execution of the block / chunk. If the bad case indeed
            // happens due to this being too small, a node restart should recover it.
            // Still, defaulting to 1M to be super safe.
            prune_window: 1_000_000,
            // A 10k transaction block (touching 60k state values, in the case of the account
            // creation benchmark) on a 4B items DB (or 1.33B accounts) yields 300k JMT nodes
            batch_size: 1_000,
        }
    }
```

**File:** types/src/proof/definition.rs (L302-313)
```rust
    pub fn verify<V: CryptoHash>(
        &self,
        expected_root_hash: HashValue,
        element_key: HashValue,
        element_value: Option<&V>,
    ) -> Result<()> {
        self.verify_by_hash(
            expected_root_hash,
            element_key,
            element_value.map(|v| v.hash()),
        )
    }
```

**File:** types/src/proof/definition.rs (L394-398)
```rust
            (None, None) => {
                // This is a non-inclusion proof. The proof intends to show that if a leaf node
                // representing `element_key` is inserted, it will show up at a currently empty
                // position. `sibling` should prove the route from this empty position to the root.
            },
```
