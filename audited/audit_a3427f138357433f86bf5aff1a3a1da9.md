# Audit Report

## Title
Type Depth Mismatch Between Bytecode Verification and Event Serialization Enables Transaction DoS

## Summary
A mismatch between the bytecode verifier's type depth limit (20) and the BCS type tag serialization limit (8) allows modules to be published with event types that pass verification but fail at runtime during event emission, causing transaction failures and potential contract DoS.

## Finding Description

The Aptos Move VM has multiple layers of type depth checking with inconsistent limits:

1. **Bytecode verification** enforces `max_type_depth = 20` when function values are enabled [1](#0-0) 

2. **Type tag serialization** enforces `MAX_TYPE_TAG_NESTING = 8` via thread-local depth tracking [2](#0-1) 

3. **Event validation** checks that event structs have the `#[event]` attribute but does NOT validate the depth of generic type parameters [3](#0-2) 

The vulnerability occurs when:
- A module is published with an event struct using generic types with nesting depth between 9-20
- The module passes bytecode verification (depth â‰¤ 20)
- At runtime, when emitting the event, `ContractEvent::new_v2()` attempts to calculate the event size
- This calls `bcs::serialized_size(&self.type_tag)` which uses `type_tag_recursive_serialize` [4](#0-3) 

- BCS serialization enforces the stricter limit of 8, causing "type tag nesting exceeded during serialization" error [5](#0-4) 

- The transaction aborts

**Attack Path:**
1. Attacker publishes a Move module with nested generic wrapper structs (e.g., `Wrapper<T>`)
2. Defines an event struct with generic parameter: `#[event] struct MyEvent<T> { data: T }`
3. Creates a function that emits the event with type depth 9: `event::emit(MyEvent<Wrapper<Wrapper<Wrapper<Wrapper<Wrapper<Wrapper<Wrapper<Wrapper<Wrapper<u64>>>>>>>>> { ... })`
4. Module passes all verification checks since depth (9) < max_type_depth (20)
5. Any transaction calling this function will fail at runtime with serialization error
6. If this is in a critical contract path (DeFi protocol, governance), it causes DoS

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Contracts with such events cannot function properly and require module upgrades
- **Limited DoS**: Specific functions become uncallable, potentially bricking smart contracts
- Not Critical because: No fund loss, no consensus violation, no network-wide impact
- Not Low because: Real operational impact, requires intervention to fix

The impact depends on where the vulnerable event emission occurs:
- In a critical DeFi protocol: High operational impact
- In governance modules: Could prevent voting/proposals
- In standard user contracts: Limited impact

## Likelihood Explanation

**Likelihood: Medium-Low**

Factors increasing likelihood:
- Easy to trigger accidentally by developers using deeply nested generic types
- No warning during module publication
- The mismatch is non-obvious (limits are in different subsystems)

Factors decreasing likelihood:
- Requires publishing a module with specific type structure
- Depth 9+ generic nesting is uncommon in practice
- Most developers use shallow type hierarchies
- Can be caught during testing if event emission is tested

## Recommendation

Add type depth validation to event validation that matches or is stricter than the BCS serialization limit:

**In `aptos-move/aptos-vm/src/verifier/event_validation.rs`:**

Add a function to check type depth before module publication:

```rust
fn check_event_type_depth(
    module: &CompiledModule,
    type_param: &SignatureToken
) -> VMResult<()> {
    const MAX_EVENT_TYPE_DEPTH: usize = 8; // Match MAX_TYPE_TAG_NESTING
    
    fn compute_depth(ty: &SignatureToken, module: &CompiledModule) -> usize {
        use SignatureToken::*;
        match ty {
            Vector(inner) | Reference(inner) | MutableReference(inner) => {
                1 + compute_depth(inner, module)
            },
            StructInstantiation(_, type_args) => {
                1 + type_args.iter()
                    .map(|arg| compute_depth(arg, module))
                    .max()
                    .unwrap_or(0)
            },
            Struct(_) => 1,
            _ => 0,
        }
    }
    
    let depth = compute_depth(type_param, module);
    if depth > MAX_EVENT_TYPE_DEPTH {
        return metadata_validation_err(
            &format!(
                "Event type exceeds maximum depth of {}. Found depth: {}",
                MAX_EVENT_TYPE_DEPTH, depth
            )
        );
    }
    Ok(())
}
```

Then call this in `validate_emit_calls` after identifying the event struct type parameter.

Alternatively, align the limits by:
1. Increasing `MAX_TYPE_TAG_NESTING` to match `max_type_depth` (20), OR
2. Decreasing `max_type_depth` to match `MAX_TYPE_TAG_NESTING` (8)

Option 2 is safer but may break existing contracts. Option 1 may have performance implications.

## Proof of Concept

```move
module 0xCAFE::vulnerable_events {
    use std::event;

    // Define wrapper structs for creating nested types
    struct W1<T> { v: T }
    struct W2<T> { v: T }
    struct W3<T> { v: T }
    struct W4<T> { v: T }
    struct W5<T> { v: T }
    struct W6<T> { v: T }
    struct W7<T> { v: T }
    struct W8<T> { v: T }
    struct W9<T> { v: T }

    #[event]
    struct DeepEvent<T> { data: T }

    /// This function will pass module verification but fail at runtime
    /// Type depth: DeepEvent(1) -> W1(2) -> W2(3) -> W3(4) -> W4(5) -> W5(6) -> W6(7) -> W7(8) -> W8(9) -> W9(10) -> u64
    /// Depth = 10, which exceeds MAX_TYPE_TAG_NESTING = 8
    public entry fun emit_deep_event() {
        let data = W1 { 
            v: W2 { 
                v: W3 { 
                    v: W4 { 
                        v: W5 { 
                            v: W6 { 
                                v: W7 { 
                                    v: W8 { 
                                        v: W9 { 
                                            v: 42u64 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        
        // This will fail at runtime with:
        // "type tag nesting exceeded during serialization"
        event::emit(DeepEvent { data });
    }
}
```

**Steps to reproduce:**
1. Compile the above module - it will pass all verification checks
2. Publish the module to the blockchain - succeeds
3. Call `emit_deep_event()` - transaction fails with serialization error
4. The function becomes permanently uncallable without module upgrade

**Notes**
This vulnerability represents a verification gap where publish-time checks are insufficient to prevent runtime failures. The inconsistent depth limits across different subsystems (bytecode verifier vs BCS serialization) create an exploitable mismatch. While the immediate impact is DoS rather than fund loss, it violates the invariant that valid bytecode should execute successfully, and can brick critical smart contract functionality requiring costly interventions.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L17-44)
```rust
pub(crate) fn type_tag_recursive_serialize<S, T>(t: &T, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
    T: Serialize,
{
    use serde::ser::Error;

    // For testability, we allow to serialize one more level than deserialize.
    const MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING: u8 =
        MAX_TYPE_TAG_NESTING + if cfg!(test) { 1 } else { 0 };

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING {
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = t.serialize(s);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L126-137)
```rust
                        match param {
                            StructInstantiation(index, _) | Struct(index) => {
                                let struct_handle = &module.struct_handle_at(*index);
                                let struct_name = module.identifier_at(struct_handle.name);
                                if struct_handle.module != module.self_handle_idx() {
                                    metadata_validation_err(format!("{} passed to 0x1::event::emit function is not defined in the same module", struct_name).as_str())
                                } else if !event_structs.contains(struct_name.as_str()) {
                                    metadata_validation_err(format!("Missing #[event] attribute on {}. The #[event] attribute is required for all structs passed into 0x1::event::emit.", struct_name).as_str())
                                } else {
                                    Ok(())
                                }
                            },
```

**File:** types/src/contract_event.rs (L268-271)
```rust
    pub fn size(&self) -> anyhow::Result<usize> {
        let size = bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
    }
```
