# Audit Report

## Title
Event Sequence Number Cache-Database Desynchronization Causing API Crashes and Data Inconsistency

## Summary
The `get_next_sequence_number()` function in the Event V2 translation engine prioritizes in-memory cache over database values when determining event sequence numbers. When the database is restored from backup while the cache is stale or empty, this creates sequence number collisions and gaps that violate the critical event uniqueness invariant, causing API crashes and cross-node inconsistencies.

## Finding Description

The vulnerability exists in the event sequence number management system for translating V2 events to V1 format. The core issue is in `get_next_sequence_number()`: [1](#0-0) 

**Precedence Order:** Cache > Database > On-Chain Default

When the cache is empty (e.g., after node restart), the function reads from the database. If the database has been restored from an old backup, it will contain stale sequence numbers that are lower than the actual on-chain state.

**Critical Design Flaw:** The cache is never loaded from the database on startup: [2](#0-1) 

The function `load_cache_from_db()` exists but is never called during initialization, as confirmed by searching the codebase.

**Attack Scenario:**

1. **Normal Operation:** Node processes transactions up to version 1000. EventKey X reaches sequence number 100 in both cache and database.

2. **Database Restore:** The internal indexer database is restored from a backup taken at version 500, where EventKey X had sequence number 50.

3. **Node Restart:** Cache is cleared (empty DashMap initialization).

4. **Next Event Processing:** 
   - `get_next_sequence_number(EventKey X, default=100)` is called
   - Cache is empty, so line 191 returns None
   - Database returns 50 (stale backup value)
   - Function returns 50+1=51, **ignoring the on-chain default of 100**
   - Event is assigned sequence number 51

5. **Consequence:** Sequence number 51 was already used before the backup. This creates a **duplicate sequence number** that violates the critical event uniqueness invariant.

**Event Uniqueness Invariant:** [3](#0-2) 

This is a **Critical** high-level requirement that two events cannot have the same GUID and sequence number.

**System Detection and Failure:**

The indexer validates sequence number continuity: [4](#0-3) 

When the system detects non-continuous sequence numbers, it treats this as "DB corruption" and **fails with a bail error**, causing API queries to crash.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

1. **API Crashes:** When clients query events with discontinuous sequence numbers, the indexer fails with "DB corruption" error, causing API unavailability.

2. **Significant Protocol Violation:** Breaks the Critical event uniqueness invariant (High-level Requirement #2 in event.md). Events are fundamental to Aptos's observable state, and their integrity is critical.

3. **Cross-Node Inconsistency:** Different nodes with different database restore states will assign different sequence numbers to the same V2 events, breaking API determinism. Clients querying different nodes see contradictory event sequences.

4. **Data Integrity Loss:** Once sequence numbers are corrupted, manual intervention is required to rebuild the entire indexer database. There is no automatic recovery mechanism.

5. **Operational Impact:** Database restores are routine maintenance operations (disaster recovery, fast sync, node migration). This vulnerability makes these operations dangerous and error-prone.

The impact meets **High Severity** criteria: "API crashes" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is triggered by common, routine operational scenarios:

1. **Database Restore Operations:** Standard practice for disaster recovery, node migration, or fast sync. Any restore from a backup older than the current ledger state triggers the issue.

2. **Node Restarts:** Every node restart clears the cache, exposing reliance on potentially stale database values.

3. **No Special Privileges Required:** This is not an attack requiring validator access or special permissions. It occurs naturally during normal node operations.

4. **Affects All Nodes:** Every node that enables event V2 translation (`enable_event_v2_translation` config) is vulnerable.

5. **No Automatic Detection:** The comment in the code explicitly acknowledges this scenario but provides no mitigation: [5](#0-4) 

The developers are aware of the issue ("In the future, we decide to backup and restore...") but have not implemented a solution.

## Recommendation

**Immediate Fix:** Call `load_cache_from_db()` during `EventV2TranslationEngine` initialization:

```rust
impl DBIndexer {
    pub fn new(indexer_db: InternalIndexerDB, db_reader: Arc<dyn DbReader>) -> Self {
        let (sender, reciver) = mpsc::channel();
        let db = indexer_db.get_inner_db_ref().to_owned();
        let internal_indexer_db = db.clone();
        let committer_handle = thread::spawn(move || {
            let committer = DBCommitter::new(db, reciver);
            committer.run();
        });

        let mut engine = EventV2TranslationEngine::new(
            db_reader.clone(),
            internal_indexer_db,
        );
        
        // CRITICAL FIX: Load cache from database on startup
        engine.load_cache_from_db()
            .expect("Failed to load event sequence number cache from database");

        Self {
            indexer_db,
            main_db_reader: db_reader.clone(),
            sender,
            committer_handle: Some(committer_handle),
            event_v2_translation_engine: engine,
        }
    }
}
```

**Additional Safeguard:** Add validation to detect and warn when database value is significantly lower than on-chain default:

```rust
pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
    if let Some(seq) = self.get_cached_sequence_number(event_key) {
        Ok(seq + 1)
    } else {
        let db_seq = self.internal_indexer_db.get::<EventSequenceNumberSchema>(event_key)?;
        match db_seq {
            Some(seq) => {
                // Warn if DB value is significantly behind on-chain state
                if seq + 10 < default {
                    warn!(
                        "Event sequence number DB value ({}) significantly behind on-chain default ({}) for key {:?}",
                        seq, default, event_key
                    );
                }
                Ok(seq + 1)
            },
            None => Ok(default + 1),
        }
    }
}
```

## Proof of Concept

**Reproduction Steps:**

1. **Setup:** Start a node with event V2 translation enabled and process transactions that emit events.

2. **Create Checkpoint:** Let EventKey X reach sequence number 100. Back up the internal indexer database.

3. **Continue Processing:** Process more transactions, advancing EventKey X to sequence number 200.

4. **Restore Old Backup:** Replace the internal indexer database with the backup where EventKey X was at 100.

5. **Restart Node:** Clear the cache by restarting the node.

6. **Process New Event:** Submit a transaction that emits an event for EventKey X.
   - Expected behavior: Should use on-chain resource count (200) as default
   - Actual behavior: Uses stale DB value (100), assigns sequence 101
   - Result: Sequence number 101 is **reused**, creating a duplicate

7. **Query Events:** Call the API to retrieve events for EventKey X:
   ```rust
   indexer.get_events_by_event_key(&event_key, 100, Order::Ascending, 10, ledger_version)
   ```
   - Result: **Fails with "DB corruption: Sequence number not continuous"** error when it encounters the duplicate/gap

**Expected Error:** [4](#0-3) 

The system will bail with the message: `"DB corruption: Sequence number not continuous. expected: X, actual: Y"`

This demonstrates that the vulnerability causes **API crashes** and violates the **event uniqueness invariant**, confirming HIGH severity impact.

---

**Notes:**

This vulnerability is particularly insidious because:
- It occurs during routine maintenance operations (database restore/migration)
- The `load_cache_from_db()` function exists but is never used, suggesting incomplete implementation
- Different nodes can have permanently inconsistent event sequences, breaking API determinism
- Recovery requires rebuilding the entire indexer database from scratch
- The codebase comment acknowledges the issue but provides no solution or workaround

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L163-177)
```rust
    // When the node starts with a non-empty EventSequenceNumberSchema table, the in-memory cache
    // `event_sequence_number_cache` is empty. In the future, we decide to backup and restore the
    // event sequence number data to support fast sync, we may need to load the cache from the DB
    // when the node starts using this function `load_cache_from_db`.
    pub fn load_cache_from_db(&self) -> Result<()> {
        let mut iter = self
            .internal_indexer_db
            .iter::<EventSequenceNumberSchema>()?;
        iter.seek_to_first();
        while let Some((event_key, sequence_number)) = iter.next().transpose()? {
            self.event_sequence_number_cache
                .insert(event_key, sequence_number);
        }
        Ok(())
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/doc/event.md (L327-332)
```markdown
<td>2</td>
<td>Unable to publish two events with the same GUID & sequence number.</td>
<td>Critical</td>
<td>Two events may either have the same GUID with a different counter or the same counter with a different GUID.</td>
<td>This is implied by <a href="#high-level-req">high-level requirement 1</a>.</td>
</tr>
```

**File:** storage/indexer/src/db_indexer.rs (L232-238)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```
