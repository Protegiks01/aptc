# Audit Report

## Title
Missing Usage Data for Intermediate State Checkpoints in Multi-Checkpoint Batches

## Summary
When a single `ChunkToCommit` spans multiple state checkpoint boundaries, the system only writes usage metadata (`VersionData`) for the last checkpoint, causing intermediate checkpoints to lack required usage data. This creates state inconsistencies that require manual intervention during database management operations.

## Finding Description

The Aptos storage layer supports batches that can span multiple state checkpoint boundaries. The codebase explicitly tests scenarios where chunks contain multiple checkpoints at different indices. [1](#0-0) 

The `StateUpdateRefs` structure tracks all checkpoint versions within a chunk via the `all_checkpoint_versions` field, which can contain multiple entries: [2](#0-1) 

However, when committing state updates, the `put_stats_and_indices` function only writes usage data for the **last checkpoint** in the chunk: [3](#0-2) 

This function writes `VersionData` only for `latest_state.last_checkpoint()` (the final checkpoint) and `latest_state` (if not itself a checkpoint), completely ignoring any intermediate checkpoints tracked in `all_checkpoint_versions`.

When usage data is queried for a version without `VersionData`, the system errors if `skip_usage` is false: [4](#0-3) 

Database truncation operations check for `VersionData` and must fall back to an alternative version when it's missing: [5](#0-4) 

## Impact Explanation

This constitutes a **Medium Severity** issue per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention."

The missing usage data for intermediate checkpoints causes:
1. Database truncation operations to fall back to different versions when targeting intermediate checkpoints
2. API queries for `get_state_storage_usage()` at intermediate checkpoint versions to fail (when `skip_usage=false`)
3. Operational complexity requiring manual intervention to work around missing metadata

While this does not directly cause fund loss or consensus violations, it creates state inconsistencies where database management operations must implement fallback mechanisms or fail unexpectedly, requiring manual intervention.

## Likelihood Explanation

This issue occurs during normal operations when the system processes chunks containing multiple checkpoints. Multi-checkpoint chunks are explicitly supported by the codebase and occur in several operational scenarios:

1. State sync operations that batch multiple blocks together for catch-up
2. Database replay operations after node restart
3. Fast sync operations processing historical state

The tests demonstrate that checkpoints can occur at close intervals within a single chunk, making this a realistic operational scenario rather than an edge case. [1](#0-0) 

## Recommendation

Modify `put_stats_and_indices` to iterate over all checkpoint versions in `state_update_refs.all_checkpoint_versions()` and write `VersionData` for each intermediate checkpoint, not just the last one:

```rust
// Write usage for ALL checkpoints in the chunk
for checkpoint_version in state_update_refs.all_checkpoint_versions() {
    if *checkpoint_version >= current_state.next_version() {
        let checkpoint_state = /* retrieve state at checkpoint_version */;
        Self::put_usage(checkpoint_state, batch)?;
    }
}

// Write usage for latest if not a checkpoint
if !latest_state.is_checkpoint() {
    Self::put_usage(latest_state, batch)?;
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a chunk with multiple checkpoints (e.g., at versions 100, 200, 300)
2. Committing the chunk through the normal `put_stats_and_indices` flow
3. Querying `get_state_storage_usage(200)` - this will error with "VersionData at 200 is missing"
4. Only version 300 (the last checkpoint) will have `VersionData` written

The test infrastructure already demonstrates multi-checkpoint chunks are supported: [1](#0-0) 

## Notes

While the system includes fallback mechanisms (e.g., `get_usage_before_or_at` in truncation operations) indicating some awareness that not all versions have `VersionData`, the absence of usage data for intermediate checkpoints in multi-checkpoint batches represents an architectural inconsistency. The `all_checkpoint_versions` field explicitly tracks these checkpoints, but the commit logic does not persist usage metadata for all of them, creating operational complexity and potential failure points in database management workflows.

### Citations

**File:** execution/executor-types/src/transactions_with_output.rs (L368-396)
```rust
    fn test_chunk_with_ckpts_no_reconfig() {
        let txns = vec![
            dummy_txn(),
            ckpt_txn(),
            dummy_txn(),
            ckpt_txn(),
            dummy_txn(),
        ];
        let outputs = vec![
            default_output(),
            default_output(),
            default_output(),
            default_output(),
            default_output(),
        ];
        let aux_infos = vec![
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
        ];
        let txn_with_outputs = TransactionsWithOutput::new(txns, outputs, aux_infos);

        let (all_ckpt_indices, is_reconfig) =
            TransactionsToKeep::get_all_checkpoint_indices(&txn_with_outputs, false);
        assert_eq!(all_ckpt_indices, vec![1, 3]);
        assert!(!is_reconfig);
    }
```

**File:** storage/storage-interface/src/state_store/state_update_refs.rs (L120-134)
```rust
#[derive(Debug)]
pub struct StateUpdateRefs<'kv> {
    pub per_version: PerVersionStateUpdateRefs<'kv>,
    all_checkpoint_versions: Vec<Version>,
    /// Updates from the beginning of the block/chunk to the last checkpoint (if it exists).
    for_last_checkpoint: Option<(PerVersionStateUpdateRefs<'kv>, BatchedStateUpdateRefs<'kv>)>,
    /// Updates from the version after last checkpoint to last version (`None` if the last version
    /// is a checkpoint, e.g. in a regular block).
    for_latest: Option<(PerVersionStateUpdateRefs<'kv>, BatchedStateUpdateRefs<'kv>)>,
}

impl<'kv> StateUpdateRefs<'kv> {
    pub(crate) fn all_checkpoint_versions(&self) -> &[Version] {
        &self.all_checkpoint_versions
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L879-891)
```rust
        {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["put_stats_and_indices__put_usage"]);
            if latest_state.last_checkpoint().next_version() > current_state.next_version() {
                // has a checkpoint in the chunk
                Self::put_usage(latest_state.last_checkpoint(), batch)?;
            }
            if !latest_state.is_checkpoint() {
                // latest state isn't a checkpoint
                Self::put_usage(latest_state, batch)?;
            }
            STATE_ITEMS.set(latest_state.usage().items() as i64);
            TOTAL_STATE_BYTES.set(latest_state.usage().bytes() as i64);
        }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L114-127)
```rust
        if ledger_db.metadata_db().get_usage(target_version).is_err() {
            println!(
                "Unable to truncate to version {}, since there is no VersionData on that version.",
                target_version
            );
            println!(
                "Trying to fallback to the largest valid version before version {}.",
                target_version,
            );
            target_version = ledger_db
                .metadata_db()
                .get_usage_before_or_at(target_version)?
                .0;
        }
```
