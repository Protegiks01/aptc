# Audit Report

## Title
Position Invariant Violation Enables Denial of Service via Malicious Merkle Proof Verification

## Summary
The `Position` struct in `types/src/proof/position/mod.rs` has an invariant that `Position.0 < u64::MAX - 1`, but the `from_inorder_index()` constructor accepts any u64 without validation. An attacker can craft a malicious `AccumulatorRangeProof` with an extremely large `first_leaf_index` value (â‰¥ 2^63 - 1) that creates a Position violating this invariant. When proof verification calls methods like `is_right_child()`, `parent()`, or `sibling()`, the invariant assertion fails, causing the node to panic and crash.

## Finding Description

The Position struct maintains a critical invariant documented at line 35: [1](#0-0) 

However, the `from_inorder_index()` constructor provides no validation: [2](#0-1) 

Multiple Position methods assert this invariant, including `is_left_child()`: [3](#0-2) 

And `is_right_child()` calls `is_left_child()`: [4](#0-3) 

The vulnerability is exploitable through `AccumulatorRangeProof::verify()`. When verifying a range proof, a Position is created from the first_leaf_index without validation: [5](#0-4) 

Shortly after, `is_right_child()` is called on this Position: [6](#0-5) 

Since `Position::from_leaf_index(leaf_index)` internally calls `from_level_and_pos(0, leaf_index)` which computes `Position(leaf_index << 1)`, an attacker providing `first_leaf_index >= 2^63 - 1` creates a Position where `Position.0 >= u64::MAX - 1`, violating the invariant.

**Attack Path:**
1. Attacker crafts a `TransactionListWithProof` with `first_transaction_version = Some(2^63 - 1)` or higher
2. Includes fake transactions, transaction_infos, and AccumulatorRangeProof with fabricated siblings
3. Sends this proof to a victim node (via state sync, storage service, or API)
4. Victim calls `TransactionListWithProof::verify()` which delegates to `AccumulatorRangeProof::verify()`: [7](#0-6) 

5. At line 656, `Position::from_leaf_index(2^63 - 1)` creates `Position(u64::MAX - 1)`
6. At line 672, `first_pos.is_right_child()` triggers the assert
7. Node panics with "assertion failed: self.0 < u64::MAX - 1"

The panic occurs **before** the final root hash verification, so the node crashes before detecting the proof is invalid: [8](#0-7) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Crashes**: Any validator receiving this malicious proof during state sync will panic and crash, causing temporary unavailability
2. **API Server Denial of Service**: Full nodes and API servers that verify proofs from untrusted sources will crash when processing the malicious proof
3. **State Sync Disruption**: Nodes attempting to sync state by verifying transaction lists will repeatedly crash if served malicious proofs
4. **No Authentication Required**: Any network peer can send these proofs without special permissions

The attack does NOT cause:
- Consensus safety violations (nodes crash before committing invalid state)
- Permanent data corruption (it's a panic, not silent corruption)
- Fund theft (no state changes occur)

This maps to "Validator node slowdowns" and "API crashes" in the High Severity category. Repeated attacks could cause "significant protocol violations" by preventing nodes from syncing.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: None. Any network peer can craft and send malicious proofs
- **Complexity**: Low. Simply construct a TransactionListWithProof with `first_transaction_version = 2^63 - 1`
- **Detection**: Difficult. The panic occurs during normal proof verification, and the astronomically large version number might be overlooked
- **Reproducibility**: 100%. The panic is deterministic given the malicious input

While the value `2^63 - 1` would never occur naturally in a real blockchain, there is **no validation** preventing an attacker from using it in a crafted proof. The code assumes all inputs are honest, which is unsafe when processing data from untrusted peers.

## Recommendation

Add validation in `from_inorder_index()` to enforce the invariant:

```rust
pub fn from_inorder_index(index: u64) -> Result<Self> {
    ensure!(
        index < u64::MAX - 1,
        "Position index {} violates invariant Position.0 < u64::MAX - 1",
        index
    );
    Ok(Position(index))
}
```

Alternatively, add validation in `from_leaf_index()` since leaf indices are user-controlled:

```rust
pub fn from_leaf_index(leaf_index: u64) -> Result<Self> {
    ensure!(
        leaf_index < (u64::MAX - 1) / 2,
        "Leaf index {} would violate Position invariant after conversion",
        leaf_index
    );
    Self::from_level_and_pos(0, leaf_index)
}
```

Additionally, add validation in `AccumulatorRangeProof::verify()` before creating the Position:

```rust
pub fn verify(
    &self,
    expected_root_hash: HashValue,
    first_leaf_index: Option<u64>,
    leaf_hashes: &[HashValue],
) -> Result<()> {
    // ... existing checks ...
    
    let first_leaf_index = first_leaf_index.expect("first_leaf_index should not be None.");
    
    // Validate first_leaf_index is reasonable
    ensure!(
        first_leaf_index < (u64::MAX - 1) / 2,
        "first_leaf_index {} is too large for Position conversion",
        first_leaf_index
    );
    
    let mut first_pos = Position::from_leaf_index(first_leaf_index);
    // ... rest of verification ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod position_invariant_exploit {
    use aptos_types::proof::{
        position::Position,
        definition::{AccumulatorRangeProof, TransactionAccumulatorRangeProof},
    };
    use aptos_crypto::{hash::HashValue, hash::TransactionAccumulatorHasher};

    #[test]
    #[should_panic(expected = "assertion failed: self.0 < u64::MAX - 1")]
    fn test_malicious_first_leaf_index_causes_panic() {
        // Attacker crafts a proof with first_leaf_index that violates invariant
        let malicious_first_leaf_index = (1u64 << 63) - 1; // 2^63 - 1
        
        // Create malicious proof with fake siblings
        let fake_left_siblings = vec![HashValue::zero()];
        let fake_right_siblings = vec![HashValue::zero()];
        let proof: TransactionAccumulatorRangeProof = 
            AccumulatorRangeProof::new(fake_left_siblings, fake_right_siblings);
        
        // Provide fake leaf hashes
        let fake_leaf_hashes = vec![HashValue::zero()];
        
        // Expected root hash (attacker can't forge valid proof, but panic happens first)
        let expected_root = HashValue::zero();
        
        // This will panic at line 672 when is_right_child() is called
        // The panic occurs BEFORE the final root hash check, so node crashes
        // before detecting the proof is invalid
        proof.verify(
            expected_root,
            Some(malicious_first_leaf_index),
            &fake_leaf_hashes
        ).unwrap();
    }
    
    #[test]
    fn test_position_from_leaf_index_creates_invalid_position() {
        // Demonstrates that from_leaf_index with large value creates invalid Position
        let large_leaf_index = (1u64 << 63) - 1;
        let pos = Position::from_leaf_index(large_leaf_index);
        
        // Position.0 = large_leaf_index << 1 = u64::MAX - 1
        assert_eq!(pos.to_inorder_index(), u64::MAX - 1);
        
        // This violates the invariant Position.0 < u64::MAX - 1
        // Any method call will panic
    }
}
```

## Notes

The vulnerability affects all nodes that verify AccumulatorRangeProofs from untrusted sources, including:
- State sync clients receiving transaction lists from peers
- Storage service endpoints serving proof requests
- API servers processing transaction list verifications

The FrozenSubtreeSiblingIterator path mentioned in the original question is less exploitable because:
1. It requires accumulator sizes approaching 2^63 leaves, which is unrealistic
2. The Positions it generates are only passed to `HashReader::get()` for database lookups
3. No Position methods are called that would trigger the assert in normal operation

The primary exploit vector is through `AccumulatorRangeProof::verify()` with attacker-controlled `first_leaf_index` values.

### Citations

**File:** types/src/proof/position/mod.rs (L33-35)
```rust
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub struct Position(u64);
// invariant Position.0 < u64::MAX - 1
```

**File:** types/src/proof/position/mod.rs (L70-72)
```rust
    pub fn from_inorder_index(index: u64) -> Self {
        Position(index)
    }
```

**File:** types/src/proof/position/mod.rs (L126-129)
```rust
    pub fn is_left_child(self) -> bool {
        assert!(self.0 < u64::MAX - 1); // invariant
        self.0 & (isolate_rightmost_zero_bit(self.0) << 1) == 0
    }
```

**File:** types/src/proof/position/mod.rs (L131-133)
```rust
    pub fn is_right_child(self) -> bool {
        !self.is_left_child()
    }
```

**File:** types/src/proof/definition.rs (L656-658)
```rust
        let mut first_pos = Position::from_leaf_index(
            first_leaf_index.expect("first_leaf_index should not be None."),
        );
```

**File:** types/src/proof/definition.rs (L672-672)
```rust
            if first_pos.is_right_child() {
```

**File:** types/src/proof/definition.rs (L705-711)
```rust
        ensure!(
            current_hashes[0] == expected_root_hash,
            "{}: Root hashes do not match. Actual root hash: {:x}. Expected root hash: {:x}.",
            type_name::<Self>(),
            current_hashes[0],
            expected_root_hash,
        );
```

**File:** types/src/proof/definition.rs (L2335-2336)
```rust

```
