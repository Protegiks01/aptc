# Audit Report

## Title
Script Cache Lacks Version Tracking, Enabling Stale Verification Bypass Across Module Upgrades

## Summary
The `ScriptCache` implementations (both `UnsyncScriptCache` and `SyncScriptCache`) do not track module versions that scripts were verified against, unlike `ModuleCache` which maintains version information. In parallel block execution, this allows a script verified against old module versions to be retrieved from cache and executed with upgraded modules without re-verification, potentially bypassing type safety checks.

## Finding Description

**Core Issue**: Scripts lack version tracking for their module dependencies, creating a verification gap when modules are upgraded. [1](#0-0) 

The `ScriptCache` trait stores scripts by hash with no version metadata, while `ModuleCache` explicitly tracks versions: [2](#0-1) 

**Attack Flow in Parallel Execution**:

1. In `MVHashMap` used by parallel block executor, both `module_cache` and `script_cache` are shared across all transactions in a block: [3](#0-2) 

2. Transaction T1 (index 10) verifies and caches Script S against Module M at version v1 (e.g., transaction index 5)

3. Transaction T2 (index 20) publishes Module M v2 with incompatible changes (allowed under arbitrary upgrade policy): [4](#0-3) 

4. Transaction T3 (index 30) retrieves Script S from cache. In the lazy loader, when a verified script is found: [5](#0-4) 

The `charge_module` function only verifies module SIZE exists, not that the version matches what the script was verified against: [6](#0-5) 

5. In the eager loader, the situation is worse - no checks occur at all: [7](#0-6) 

6. The script executes against Module M v2 even though it was only verified against M v1. Module read validation checks that T3's module reads are current, but doesn't validate that the cached script was verified against the current versions: [8](#0-7) 

**Invariant Broken**: "Move VM Safety: Bytecode execution must respect verification constraints" - the script executes without being verified against its actual dependencies.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability can cause:
- **Type Safety Violations**: If module struct layouts changed, the script may access wrong memory offsets
- **Function Signature Mismatches**: Calling functions with incompatible signatures
- **Consensus Divergence**: Different validators with different cache states may execute transactions differently
- **Deterministic Execution Violation**: Validators may produce different state roots for identical blocks

The impact is limited by:
- Requires parallel execution context
- Requires modules with arbitrary upgrade policy
- Requires specific transaction ordering
- Most production modules use compatibility policies preventing breaking changes

This qualifies as **High severity** due to potential consensus violations and deterministic execution breaks, though not Critical because it requires specific conditions and doesn't guarantee fund loss.

## Likelihood Explanation

**Likelihood: MEDIUM**

Required conditions:
1. Parallel block execution enabled (standard in production)
2. Module published with arbitrary upgrade policy (less common but possible)
3. Script executed and cached in one transaction
4. Module upgraded with breaking changes in subsequent transaction
5. Script re-executed from cache in later transaction

The attack complexity is moderate - an attacker controlling a module with arbitrary upgrade policy could deliberately trigger this by:
- Publishing a script that uses their module
- Upgrading the module with incompatible changes
- Submitting transactions that re-use the cached script

## Recommendation

**Solution**: Add version tracking to the script cache, similar to module cache versioning.

1. Modify `ScriptCache` trait to track module dependency versions:
   - Store tuple of (Script, HashMap<ModuleId, TxnIndex>) 
   - Record all immediate dependency versions when caching verified scripts

2. When retrieving cached scripts, validate that all dependency versions match current module cache versions

3. If version mismatch detected, invalidate cached script and re-verify

4. Alternative simpler fix: Clear script cache whenever any module is published/upgraded within a block

**Recommended Implementation** (in `script_cache.rs`):
```rust
pub trait ScriptCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;
    type Version; // Add version tracking

    fn insert_verified_script(
        &self,
        key: Self::Key,
        verified_script: Self::Verified,
        dependency_versions: HashMap<ModuleId, Self::Version>, // Track dep versions
    ) -> Arc<Self::Verified>;

    fn get_script(
        &self, 
        key: &Self::Key,
        current_versions: &impl Fn(&ModuleId) -> Option<Self::Version>, // Validate versions
    ) -> Option<Code<Self::Deserialized, Self::Verified>>;
}
```

## Proof of Concept

Due to the complexity of setting up parallel block execution environment, here's a conceptual test outline:

```rust
// Conceptual PoC - would need full block executor setup to run
#[test]
fn test_script_cache_stale_verification() {
    // 1. Setup parallel block executor with MVHashMap
    let mvhashmap = MVHashMap::new();
    
    // 2. Execute T1: Script S calls Module M v1 function with signature f(u64)
    //    - Script S gets verified and cached
    //    - Module M v1 cached at version 5
    
    // 3. Execute T2: Upgrade Module M to v2 with incompatible change
    //    - Function f now has signature f(u128) 
    //    - Module M v2 cached at version 20
    
    // 4. Execute T3: Re-execute Script S
    //    - Script S retrieved from cache (verified against M v1)
    //    - Calls f() expecting u64 parameter
    //    - But M v2 expects u128 parameter
    //    - Type mismatch not caught, potential undefined behavior
    
    // Expected: Transaction should fail with verification error
    // Actual: Transaction executes with stale verification
}
```

A full working PoC would require:
- Complete BlockSTM executor setup
- Move module with arbitrary upgrade policy  
- Move script depending on the module
- Module upgrade transaction
- Demonstration that cached script executes without re-verification

**Notes**: This vulnerability is mitigated in practice by Aptos's default use of compatibility-checked module upgrades, but remains exploitable for modules with arbitrary upgrade policies. The lack of script version tracking is a architectural weakness that should be addressed to ensure Move VM safety guarantees hold under all upgrade scenarios.

### Citations

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L11-41)
```rust
/// Interface used by any script cache implementation.
#[delegatable_trait]
pub trait ScriptCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// Otherwise, there is no insertion and the copy of existing entry is returned.
    fn insert_deserialized_script(
        &self,
        key: Self::Key,
        deserialized_script: Self::Deserialized,
    ) -> Arc<Self::Deserialized>;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// If the entry associated with the key is occupied, but the entry is not verified, inserts
    /// the script returning the copy. Otherwise, there is no insertion and the copy of existing
    /// (verified) entry is returned.
    fn insert_verified_script(
        &self,
        key: Self::Key,
        verified_script: Self::Verified,
    ) -> Arc<Self::Verified>;

    /// Returns the script if it has been cached before, or [None] otherwise.
    fn get_script(&self, key: &Self::Key) -> Option<Code<Self::Deserialized, Self::Verified>>;

    /// Returns the number of scripts stored in cache.
    fn num_scripts(&self) -> usize;
}
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L82-140)
```rust
#[delegatable_trait]
pub trait ModuleCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;
    type Extension;
    type Version: Clone + Default + Ord;

    /// Stores deserialized code at specified version to the module cache if there was no entry
    /// associated with this key before. If module cache already contains an entry, then:
    ///   1. returns an error if the version of existing entry is higher,
    ///   2. does not perform the insertion if the version is the same,
    ///   3. inserts the new code if the new version is higher.
    /// Returns the newly inserted (or existing) module at the specified key.
    fn insert_deserialized_module(
        &self,
        key: Self::Key,
        deserialized_code: Self::Deserialized,
        extension: Arc<Self::Extension>,
        version: Self::Version,
    ) -> VMResult<Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>>;

    /// Stores verified code at specified version to the module cache if there was no entry
    /// associated with this key before. If module cache already contains an entry, then:
    ///   1. returns an error if the version of existing entry is higher,
    ///   2. does not perform the insertion if the version is the same and the entry is verified,
    ///   3. inserts the new code if the new version is higher, or if the version is the same but
    ///      the code is not verified.
    /// Returns the newly inserted (or existing) module at the specified key.
    fn insert_verified_module(
        &self,
        key: Self::Key,
        verified_code: Self::Verified,
        extension: Arc<Self::Extension>,
        version: Self::Version,
    ) -> VMResult<Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>>;

    /// Ensures that the entry in the module cache is initialized using the provided initializer,
    /// if it was not stored before. Returns the stored module, or [None] if it does not exist. If
    /// initialization fails, returns the error.
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    >;

    /// Returns the number of modules in cache.
    fn num_modules(&self) -> usize;
}
```

**File:** aptos-move/mvhashmap/src/lib.rs (L41-68)
```rust
pub struct MVHashMap<K, T, V: TransactionWrite, I: Clone> {
    data: VersionedData<K, V>,
    group_data: VersionedGroupData<K, T, V>,
    delayed_fields: VersionedDelayedFields<I>,

    module_cache:
        SyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, Option<TxnIndex>>,
    script_cache: SyncScriptCache<[u8; 32], CompiledScript, Script>,
}

impl<K, T, V, I> MVHashMap<K, T, V, I>
where
    K: ModulePath + Hash + Clone + Eq + Debug,
    T: Hash + Clone + Eq + Debug + Serialize,
    V: TransactionWrite + PartialEq,
    I: Copy + Clone + Eq + Hash + Debug,
{
    #[allow(clippy::new_without_default)]
    pub fn new() -> MVHashMap<K, T, V, I> {
        #[allow(deprecated)]
        MVHashMap {
            data: VersionedData::empty(),
            group_data: VersionedGroupData::empty(),
            delayed_fields: VersionedDelayedFields::empty(),

            module_cache: SyncModuleCache::empty(),
            script_cache: SyncScriptCache::empty(),
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L173-194)
```rust
            // All modules can be republished, as long as the new module is compatible
            // with the old module.
            if compatibility.need_check_compat() {
                // INVARIANT:
                //   Old module must be metered at the caller side.
                if let Some(old_module_ref) =
                    existing_module_storage.unmetered_get_deserialized_module(addr, name)?
                {
                    if !is_framework_for_option_enabled
                        && is_enum_option_enabled
                        && old_module_ref.self_id().is_option()
                        && old_module_ref.self_id() == compiled_module.self_id()
                    {
                        // skip check for option module during publishing
                    } else {
                        let old_module = old_module_ref.as_ref();
                        compatibility
                            .check(old_module, &compiled_module)
                            .map_err(|e| e.finish(Location::Undefined))?;
                    }
                }
            }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L129-138)
```rust
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => {
                // Before returning early, meter modules because script might have been cached by
                // other thread.
                for (addr, name) in script.immediate_dependencies_iter() {
                    let module_id = ModuleId::new(*addr, name.to_owned());
                    self.charge_module(gas_meter, traversal_context, &module_id)
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                return Ok(script);
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L70-77)
```rust
    fn unmetered_get_existing_module_size(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<usize> {
        self.unmetered_get_module_size(address, module_name)?
            .ok_or_else(|| module_linker_error!(address, module_name))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L106-111)
```rust
    fn unmetered_verify_and_cache_script(&self, serialized_script: &[u8]) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => return Ok(script),
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1050-1089)
```rust
    pub(crate) fn validate_module_reads(
        &self,
        global_module_cache: &GlobalModuleCache<K, DC, VC, S>,
        per_block_module_cache: &SyncModuleCache<K, DC, VC, S, Option<TxnIndex>>,
        maybe_updated_module_keys: Option<&BTreeSet<K>>,
    ) -> bool {
        if self.non_delayed_field_speculative_failure {
            return false;
        }

        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };

        match maybe_updated_module_keys {
            Some(updated_module_keys) if updated_module_keys.len() <= self.module_reads.len() => {
                // When updated_module_keys is smaller, iterate over it and lookup in module_reads
                updated_module_keys
                    .iter()
                    .filter(|&k| self.module_reads.contains_key(k))
                    .all(|key| validate(key, self.module_reads.get(key).unwrap()))
            },
            Some(updated_module_keys) => {
                // When module_reads is smaller, iterate over it and filter by updated_module_keys
                self.module_reads
                    .iter()
                    .filter(|(k, _)| updated_module_keys.contains(k))
                    .all(|(key, read)| validate(key, read))
            },
            None => self
                .module_reads
                .iter()
                .all(|(key, read)| validate(key, read)),
        }
    }
```
