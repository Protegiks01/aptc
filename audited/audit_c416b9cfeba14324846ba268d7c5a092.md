# Audit Report

## Title
Protocol Version Skew in Remote Executor Communication Causes Shard Crashes and Execution Failures

## Summary
The remote executor system lacks version negotiation between coordinator and shards, causing BCS deserialization failures and shard crashes when protocol versions mismatch during rolling upgrades. The unsafe error handling using `.unwrap()` on deserialization results in panic-based availability failures.

## Finding Description

The remote executor architecture uses a coordinator-shard model where the `RemoteExecutorClient` (coordinator) distributes execution work to multiple `ExecutorService` shards via network communication. Messages are serialized using BCS (Binary Canonical Serialization) without any protocol version checking. [1](#0-0) 

The critical vulnerability occurs in two deserialization points:

**Shard-side deserialization (receiving commands from coordinator):** [2](#0-1) 

**Coordinator-side deserialization (receiving results from shards):** [3](#0-2) 

Both use `.unwrap()` which panics on BCS deserialization failure.

The serialized types contain complex structures that can change between versions: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
During a rolling upgrade where the coordinator is upgraded to version N+1 but some shards remain on version N, any change to `BlockExecutorConfigFromOnchain`, `BlockGasLimitType` enum variants, or `AnalyzedTransaction` structure causes BCS deserialization to fail on version N shards, triggering a panic that crashes the shard's execution thread.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations":

1. **Availability Impact**: Shard crashes prevent block execution, causing the validator to fail its duties and potentially miss blocks, leading to slashing
2. **Consensus Impact**: If different shards have different versions and some succeed while others fail, this violates the "Deterministic Execution" invariant where all validators must produce identical results
3. **Liveness Impact**: Failed sharded execution prevents the validator from participating in consensus

The lack of version negotiation means there's no protection mechanism - any struct change in critical execution configuration types immediately breaks compatibility.

## Likelihood Explanation

**Medium Likelihood** - This occurs during:
- Rolling upgrades of multi-shard validator deployments
- Any code change affecting serialized message structures
- Operational misconfigurations where coordinator and shards run different binary versions

While not requiring external attack, this represents a critical reliability and safety issue in production deployments. The distributed nature of sharded execution makes version consistency challenging to maintain during upgrades.

## Recommendation

Implement protocol version negotiation similar to the network handshake pattern: [6](#0-5) 

**Recommended fix:**

1. Add version field to `RemoteExecutionRequest` and `RemoteExecutionResult`:
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionRequest {
    pub protocol_version: u32,
    pub payload: RemoteExecutionRequestPayload,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum RemoteExecutionRequestPayload {
    ExecuteBlock(ExecuteBlockCommand),
}
```

2. Implement version checking before deserialization:
```rust
fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
    match self.command_rx.recv() {
        Ok(message) => {
            let request: RemoteExecutionRequest = 
                bcs::from_bytes(&message.data)
                .expect("Failed to deserialize request");
            
            if request.protocol_version != EXECUTOR_PROTOCOL_VERSION {
                error!("Protocol version mismatch: got {}, expected {}", 
                       request.protocol_version, EXECUTOR_PROTOCOL_VERSION);
                return ExecutorShardCommand::Stop;
            }
            // Continue processing...
        }
    }
}
```

3. Replace `.unwrap()` with proper error handling that doesn't panic

## Proof of Concept

```rust
// Reproduction test showing panic on version mismatch
#[test]
fn test_version_mismatch_causes_panic() {
    // Simulate V1 message structure
    #[derive(Serialize)]
    struct ExecuteBlockCommandV1 {
        sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
        concurrency_level: usize,
    }
    
    // V2 adds new field
    #[derive(Deserialize)]
    struct ExecuteBlockCommandV2 {
        sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
        concurrency_level: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    }
    
    let v1_command = ExecuteBlockCommandV1 {
        sub_blocks: create_test_subblocks(),
        concurrency_level: 4,
    };
    
    let serialized = bcs::to_bytes(&v1_command).unwrap();
    
    // This panics when V2 shard tries to deserialize V1 message
    let result = std::panic::catch_unwind(|| {
        let _v2_command: ExecuteBlockCommandV2 = 
            bcs::from_bytes(&serialized).unwrap();
    });
    
    assert!(result.is_err(), "Should panic on version mismatch");
}
```

**Notes:**
- The gRPC protobuf layer (`aptos.remote_executor.v1.tonic.rs`) is just transport - the real issue is in BCS-serialized Rust types
- No version checking exists in the current implementation
- The `.unwrap()` pattern ensures crashes rather than graceful degradation
- This affects any distributed deployment using sharded execution

### Citations

**File:** execution/executor-service/src/lib.rs (L32-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-109)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** types/src/block_executor/config.rs (L84-90)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlockExecutorConfigFromOnchain {
    pub block_gas_limit_type: BlockGasLimitType,
    enable_per_block_gas_limit: bool,
    per_block_gas_limit: Option<u64>,
    gas_price_to_burn: Option<u64>,
}
```

**File:** types/src/on_chain_config/execution_config.rs (L274-313)
```rust
pub enum BlockGasLimitType {
    NoLimit,
    Limit(u64),
    /// Provides two separate block limits:
    /// 1. effective_block_gas_limit
    /// 2. block_output_limit
    ComplexLimitV1 {
        /// Formula for effective block gas limit:
        /// effective_block_gas_limit <
        /// (execution_gas_effective_multiplier * execution_gas_used +
        ///  io_gas_effective_multiplier * io_gas_used
        /// ) * (1 + num conflicts in conflict_penalty_window)
        effective_block_gas_limit: u64,
        execution_gas_effective_multiplier: u64,
        io_gas_effective_multiplier: u64,
        conflict_penalty_window: u32,

        /// If true we look at granular resource group conflicts (i.e. if same Tag
        /// within a resource group has a conflict)
        /// If false, we treat any conclicts inside of resource groups (even across
        /// non-overlapping tags) as conflicts).
        use_granular_resource_group_conflicts: bool,
        /// Module publishing today fallbacks to sequential execution,
        /// even though there is no read-write conflict.
        /// When enabled, this flag allows us to account for that conflict.
        /// NOTE: Currently not supported.
        use_module_publishing_block_conflict: bool,

        /// Block limit on the total (approximate) txn output size in bytes.
        block_output_limit: Option<u64>,
        /// When set, we include the user txn size in the approximate computation
        /// of block output size, which is compared against the block_output_limit above.
        include_user_txn_size_in_block_output: bool,

        /// When set, we create BlockEpilogue (instead of StateCheckpint) transaction,
        /// which contains BlockEndInfo
        /// NOTE: Currently not supported.
        add_block_limit_outcome_onchain: bool,
    },
}
```

**File:** network/framework/src/transport/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    logging::NetworkSchema,
    noise::{stream::NoiseStream, AntiReplayTimestamps, HandshakeAuthMode, NoiseUpgrader},
    protocols::{
        identity::exchange_handshake,
        wire::handshake::v1::{HandshakeMsg, MessagingProtocolVersion, ProtocolIdSet},
    },
};
use aptos_config::{
    config::{PeerRole, HANDSHAKE_VERSION},
    network_id::{NetworkContext, NetworkId},
};
use aptos_crypto::x25519;
use aptos_id_generator::{IdGenerator, U32IdGenerator};
use aptos_logger::prelude::*;
// Re-exposed for aptos-network-checker
pub use aptos_netcore::transport::tcp::{resolve_and_connect, TCPBufferCfg, TcpSocket};
use aptos_netcore::transport::{proxy_protocol, tcp, ConnectionOrigin, Transport};
use aptos_short_hex_str::AsShortHexStr;
use aptos_time_service::{timeout, TimeService, TimeServiceTrait};
use aptos_types::{
    chain_id::ChainId,
    network_address::{parse_dns_tcp, parse_ip_tcp, parse_memory, NetworkAddress},
    PeerId,
};
use futures::{
    future::{Future, FutureExt},
    io::{AsyncRead, AsyncWrite},
    stream::{Stream, StreamExt, TryStreamExt},
};
use serde::{Deserialize, Serialize};
use std::{collections::BTreeMap, convert::TryFrom, fmt, io, pin::Pin, sync::Arc, time::Duration};

#[cfg(test)]
mod test;

/// A timeout for the connection to open and complete all of the upgrade steps.
pub const TRANSPORT_TIMEOUT: Duration = Duration::from_secs(30);

/// Currently supported messaging protocol version.
/// TODO: Add ability to support more than one messaging protocol.
pub const SUPPORTED_MESSAGING_PROTOCOL: MessagingProtocolVersion = MessagingProtocolVersion::V1;

/// Global connection-id generator.
static CONNECTION_ID_GENERATOR: ConnectionIdGenerator = ConnectionIdGenerator::new();

/// tcp::Transport with Aptos-specific configuration applied.
```
