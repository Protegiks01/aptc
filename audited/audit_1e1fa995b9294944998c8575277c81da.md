# Audit Report

## Title
X25519 Network Private Key Exposure Through Production Logging at Node Startup

## Summary
The `to_bytes()` method on `x25519::PrivateKey` provides unrestricted access to raw key bytes, which when combined with the `SerializeKey` derive macro and JSON serialization, causes network private keys to be logged in plaintext (hex-encoded) during production validator node startup. This enables key exfiltration through log files or log aggregation systems.

## Finding Description
The Aptos node startup process logs the complete node configuration, including network private keys, violating cryptographic material protection invariants. The vulnerability exists in a multi-component chain:

**Component 1: Direct Key Access** [1](#0-0) 

The `to_bytes()` method directly exposes the 32-byte private key without any access controls, despite `x25519::PrivateKey` having `SilentDebug` and `SilentDisplay` protections.

**Component 2: JSON Serialization Bypass** [2](#0-1) 

When serializing to human-readable formats (JSON), the `SerializeKey` macro calls `to_encoded_string()` which internally calls `to_bytes()` and hex-encodes the raw key bytes.

**Component 3: Production Logging** [3](#0-2) 

The `log_all_configs()` method serializes the entire `NodeConfig` (including network identity keys) to JSON and logs each configuration section using the `info!()` macro.

**Component 4: Node Startup Invocation** [4](#0-3) 

Every validator and fullnode calls `log_all_configs()` during startup, making this vulnerability trigger automatically in production environments.

**Component 5: Identity Storage** [5](#0-4) 

The network identity contains `ConfigKey<x25519::PrivateKey>` which gets serialized as part of the configuration logging process.

## Impact Explanation
This is a **HIGH severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Network Security Compromise**: The x25519 private key is used for Noise protocol encryption in peer-to-peer networking. Exposure allows attackers to:
   - Impersonate validator nodes in the network
   - Decrypt past and future network communications (if ephemeral keys are compromised)
   - Perform man-in-the-middle attacks on validator connections

2. **Log Aggregation Risk**: Production deployments typically use centralized logging (CloudWatch, Datadog, Splunk, etc.). Exposed keys in logs propagate to these systems, expanding the attack surface.

3. **Persistence**: Keys remain in log files indefinitely unless actively rotated and logs purged, creating a long-lived vulnerability.

4. **Automatic Triggering**: Unlike many vulnerabilities requiring specific exploitation steps, this occurs automatically on every node restart.

While this doesn't directly cause consensus violations or fund loss, it significantly degrades network security and could enable follow-on attacks. This aligns with **High Severity** ("Significant protocol violations").

## Likelihood Explanation
**Likelihood: CERTAIN (100%)**

This vulnerability triggers automatically on every validator and fullnode startup. The exploitation requirements are minimal:

- **Attacker Access Requirements**: Read access to node logs (systemd journals, Docker logs, log files, or log aggregation systems)
- **Exploitation Complexity**: None - keys are already present in plaintext hex format
- **Detection**: Difficult - legitimate log access appears normal
- **Frequency**: Every node restart, configuration reload, or initialization

Given that log access is often less restricted than key storage systems, and that logs may be accessible to operations teams, monitoring systems, or external log processors, the exposure risk is substantial.

## Recommendation
Implement multi-layered protection:

**1. Remove Private Keys from Serialization**
Mark the `key` field in `ConfigKey` with `#[serde(skip_serializing)]` or implement a custom `Serialize` that only serializes the public key:

```rust
impl<T: PrivateKey + Serialize> Serialize for ConfigKey<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Only serialize public key, never private key
        self.public_key().serialize(serializer)
    }
}
```

**2. Add Runtime Key Detection in Logging**
Modify `log_all_configs()` to redact sensitive fields before logging:

```rust
pub fn log_all_configs(&self) {
    let mut config_value = serde_json::to_value(self)
        .expect("Failed to serialize the node config!");
    
    // Redact sensitive paths
    redact_sensitive_fields(&mut config_value, &[
        "validator_network.identity.key",
        "full_node_networks.*.identity.key",
    ]);
    
    // ... rest of logging
}
```

**3. Restrict to_encoded_string() Usage**
Add compile-time guards to prevent `to_encoded_string()` usage on private keys outside of explicit key management contexts:

```rust
impl ValidCryptoMaterialStringExt for PrivateKey {
    #[deprecated(note = "Direct string encoding of private keys is dangerous")]
    fn to_encoded_string(&self) -> Result<String> {
        // Only allow in #[cfg(test)] or explicit key management crates
        compile_error!("to_encoded_string on PrivateKey requires explicit opt-in");
    }
}
```

## Proof of Concept

```rust
// File: config/src/config/test_key_exposure.rs
#[cfg(test)]
mod key_exposure_test {
    use crate::config::{Identity, NetworkConfig, NodeConfig};
    use aptos_crypto::{x25519, Uniform};
    use rand::SeedableRng;

    #[test]
    fn test_private_key_exposed_in_json_serialization() {
        // Generate a test x25519 private key
        let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
        let private_key = x25519::PrivateKey::generate(&mut rng);
        let peer_id = aptos_types::account_address::from_identity_public_key(
            private_key.public_key()
        );

        // Create identity with the private key
        let identity = Identity::from_config(private_key, peer_id);

        // Create a network config containing the identity
        let mut network_config = NetworkConfig::default();
        network_config.identity = identity;

        // Create a minimal node config
        let mut node_config = NodeConfig::default();
        node_config.validator_network = Some(network_config);

        // Serialize to JSON (human-readable format like log_all_configs does)
        let json_value = serde_json::to_value(&node_config)
            .expect("Failed to serialize");
        let json_string = serde_json::to_string(&json_value)
            .expect("Failed to stringify");

        // VULNERABILITY: The private key is present in the JSON output
        assert!(json_string.contains("0x"), 
            "Private key hex encoding should be present");
        
        // Extract and verify we can read the actual key bytes
        if let Some(validator_net) = json_value.get("validator_network") {
            if let Some(identity) = validator_net.get("identity") {
                if let Some(key_obj) = identity.get("key") {
                    let key_str = key_obj.as_str()
                        .expect("Key should be serialized as string");
                    
                    // This demonstrates the key is fully exposed
                    println!("EXPOSED PRIVATE KEY: {}", key_str);
                    panic!("Private key is exposed in JSON serialization!");
                }
            }
        }
    }
}
```

This test demonstrates that x25519 private keys are serialized as hex strings in JSON format, exactly as they would appear in production logs during node startup.

## Notes
The protection mechanisms (`SilentDebug`, `SilentDisplay`) on `x25519::PrivateKey` are bypassed by the serialization path. The `to_bytes()` method itself is legitimate for cryptographic operations, but its exposure through the serialization chain to production logging creates the vulnerability. The fix must address the serialization layer, not the `to_bytes()` method itself, to avoid breaking legitimate cryptographic usage while preventing key exposure in logs.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L189-191)
```rust
    fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes().to_vec()
    }
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L196-199)
```rust
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
```

**File:** config/src/config/node_config.rs (L97-110)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
```

**File:** aptos-node/src/lib.rs (L697-698)
```rust
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** config/src/config/identity_config.rs (L132-134)
```rust
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
```
