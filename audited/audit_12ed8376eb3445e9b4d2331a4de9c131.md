# Audit Report

## Title
Missing Type Range Validation in TokenObjectPropertyMap Deserialization Allows Indexer Data Corruption

## Summary
The `TokenObjectPropertyMap::from_bcs_encode_str` function casts a u64 type value to u8 without validating it is in the valid range of 0-9 before passing to `create_token_object_property_value()`. This allows invalid type values to bypass BCS decoding or cause type confusion through integer truncation. [1](#0-0) 

## Finding Description
The vulnerability exists in the property map deserialization flow used by the Aptos indexer. When processing Token V2 (token objects) property maps from JSON:

1. The type field is read as a u64 from JSON
2. It is immediately cast to u8 using `typ as u8`  
3. No validation ensures the value is in the valid range 0-9
4. The value is passed to `convert_bcs_hex_new()` which expects types 0-9 [2](#0-1) 

The on-chain Move implementation correctly validates that property types must be 0-9: [3](#0-2) [4](#0-3) 

However, the Rust indexer code lacks this validation, creating two failure modes:

**Failure Mode 1 - Type Confusion (typ > 255):**
If JSON contains type values > 255, the u8 cast silently truncates (e.g., 256→0, 257→1, 510→254). This causes type confusion where a value encoded for one type is decoded as another.

**Failure Mode 2 - Bypass BCS Decoding (typ = 10-255):**
For type values 10-255, the match statement hits the default case which returns the raw hex value without BCS decoding, storing corrupted data. [5](#0-4) 

## Impact Explanation
This is a **Medium severity** issue under the Aptos bug bounty program category "State inconsistencies requiring intervention."

**Impact Scope:**
- **Indexer Database Corruption**: Invalid property values stored in the indexer database
- **Downstream Application Impact**: Applications querying the indexer receive incorrect token metadata (names, descriptions, attributes)
- **User Experience Degradation**: NFTs and tokens display wrong properties
- **Data Integrity Violation**: The indexer, which serves as the primary query interface for blockchain data, contains incorrect information

**Important Limitation:**
This vulnerability does NOT affect:
- On-chain state (which remains correctly validated)
- Consensus or validator operations  
- Blockchain security or funds

The indexer is auxiliary infrastructure, but it's critical for ecosystem applications that rely on it for token metadata queries.

## Likelihood Explanation
**Likelihood: Low to Medium**

The attack requires one of these conditions:
1. **Malicious Fullnode**: The indexer connects to a compromised fullnode that serves malformed JSON
2. **Fullnode API Bug**: A bug in the fullnode's JSON serialization incorrectly serializes u8 values
3. **Data Corruption**: Database corruption results in malformed state data
4. **Version Mismatch**: Protocol version mismatch causes type field serialization issues

While on-chain validation ensures blockchain state is correct, the indexer should implement defense-in-depth and not blindly trust its data sources.

## Recommendation
Add explicit validation after reading the type value to ensure it's in the valid range 0-9:

```rust
let typ = entry.get("value")?.get("type")?.as_u64()?;
// Validate type is in valid range 0-9
if typ > 9 {
    return None; // Invalid type, skip this property
}
let pv = create_token_object_property_value(typ as u8, val.to_string()).ok()?;
```

Alternatively, add validation in `convert_bcs_hex_new`:

```rust
pub fn convert_bcs_hex_new(typ: u8, value: String) -> Option<String> {
    let decoded = hex::decode(value.strip_prefix("0x").unwrap_or(&*value)).ok()?;
    
    match typ {
        0 /* bool */ => bcs::from_bytes::<bool>(decoded.as_slice()).map(|e| e.to_string()),
        // ... cases 1-9 ...
        9 /* string */ => bcs::from_bytes::<String>(decoded.as_slice()),
        _ => None, // Return None for invalid types instead of Ok(value)
    }
    .ok()
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_invalid_types {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_type_greater_than_255_causes_truncation() {
        // Type 256 should wrap to 0 (bool), but actually represents an invalid type
        let malformed_json = json!({
            "data": [{
                "key": "test_property",
                "value": {
                    "type": 256, // Invalid: > 255, wraps to 0
                    "value": "0x0642726f6e7a65" // String "Bronze" encoded as bytes
                }
            }]
        });
        
        // This will incorrectly try to decode as bool (type 0) instead of rejecting
        let result = TokenObjectPropertyMap::from_bcs_encode_str(malformed_json);
        
        // The property will either be decoded incorrectly or skipped
        // Expected: Should return None or validate type range
        // Actual: Attempts to decode string bytes as bool
    }
    
    #[test]
    fn test_type_10_to_255_bypasses_decoding() {
        // Type 10-255 hits default case and returns raw hex
        let malformed_json = json!({
            "data": [{
                "key": "test_property",
                "value": {
                    "type": 100, // Invalid: not in 0-9 range
                    "value": "0x0642726f6e7a65"
                }
            }]
        });
        
        let result = TokenObjectPropertyMap::from_bcs_encode_str(malformed_json);
        
        // Expected: Should validate and reject invalid type
        // Actual: Returns raw hex "0x0642726f6e7a65" without BCS decoding
        if let Some(result) = result {
            // The value will be the raw hex string instead of decoded "Bronze"
            assert_eq!(result["test_property"], "0x0642726f6e7a65");
        }
    }
}
```

## Notes

**Critical Context:**
While this is a legitimate issue in the indexer code, its security impact is limited because:

1. The indexer is not part of consensus or on-chain execution
2. On-chain PropertyMap validation ensures blockchain state is always correct  
3. The vulnerability requires either a compromised data source or API bugs
4. Applications can verify data against on-chain state if needed

This represents a **defense-in-depth** failure rather than a direct consensus or fund security issue. The fix should be implemented to ensure indexer robustness, but the blockchain itself remains secure.

### Citations

**File:** crates/indexer/src/models/property_map.rs (L87-88)
```rust
            let typ = entry.get("value")?.get("type")?.as_u64()?;
            let pv = create_token_object_property_value(typ as u8, val.to_string()).ok()?;
```

**File:** crates/indexer/src/util.rs (L161-180)
```rust
pub fn convert_bcs_hex_new(typ: u8, value: String) -> Option<String> {
    let decoded = hex::decode(value.strip_prefix("0x").unwrap_or(&*value)).ok()?;

    // Signed integers are not supported in token v2 property maps right now:
    // https://github.com/aptos-labs/aptos-core/blob/5f5d138562dd0732e14c3e4265d3aa1218144145/aptos-move/framework/aptos-token-objects/sources/property_map.move#L37
    match typ {
        0 /* bool */ => bcs::from_bytes::<bool>(decoded.as_slice()).map(|e| e.to_string()),
        1 /* u8 */ => bcs::from_bytes::<u8>(decoded.as_slice()).map(|e| e.to_string()),
        2 /* u16 */ => bcs::from_bytes::<u16>(decoded.as_slice()).map(|e| e.to_string()),
        3 /* u32 */ => bcs::from_bytes::<u32>(decoded.as_slice()).map(|e| e.to_string()),
        4 /* u64 */ => bcs::from_bytes::<u64>(decoded.as_slice()).map(|e| e.to_string()),
        5 /* u128 */ => bcs::from_bytes::<u128>(decoded.as_slice()).map(|e| e.to_string()),
        6 /* u256 */ => bcs::from_bytes::<BigDecimal>(decoded.as_slice()).map(|e| e.to_string()),
        7 /* address */ => bcs::from_bytes::<Address>(decoded.as_slice()).map(|e| e.to_string()),
        8 /* byte_vector */ => bcs::from_bytes::<Vec<u8>>(decoded.as_slice()).map(|e| format!("0x{}", hex::encode(e))),
        9 /* string */ => bcs::from_bytes::<String>(decoded.as_slice()),
        _ => Ok(value),
    }
        .ok()
}
```

**File:** aptos-move/framework/aptos-token-objects/sources/property_map.move (L38-47)
```text
    const BOOL: u8 = 0;
    const U8: u8 = 1;
    const U16: u8 = 2;
    const U32: u8 = 3;
    const U64: u8 = 4;
    const U128: u8 = 5;
    const U256: u8 = 6;
    const ADDRESS: u8 = 7;
    const BYTE_VECTOR: u8 = 8;
    const STRING: u8 = 9;
```

**File:** aptos-move/framework/aptos-token-objects/sources/property_map.move (L175-199)
```text
    inline fun validate_type(type: u8, value: vector<u8>) {
        if (type == BOOL) {
            from_bcs::to_bool(value);
        } else if (type == U8) {
            from_bcs::to_u8(value);
        } else if (type == U16) {
            from_bcs::to_u16(value);
        } else if (type == U32) {
            from_bcs::to_u32(value);
        } else if (type == U64) {
            from_bcs::to_u64(value);
        } else if (type == U128) {
            from_bcs::to_u128(value);
        } else if (type == U256) {
            from_bcs::to_u256(value);
        } else if (type == ADDRESS) {
            from_bcs::to_address(value);
        } else if (type == BYTE_VECTOR) {
            // nothing to validate...
        } else if (type == STRING) {
            from_bcs::to_string(value);
        } else {
            abort (error::invalid_argument(ETYPE_MISMATCH))
        };
    }
```
