After thorough validation against the Aptos security framework, I have confirmed this is a **VALID VULNERABILITY**. Here is my assessment:

# Audit Report

## Title
Missing BCS Stream Validation Allows Padding Injection in Derivable Account Abstract Public Keys

## Summary
The `ethereum_derivable_account.move` and `solana_derivable_account.move` modules fail to validate that all bytes are consumed during BCS deserialization of `abstract_public_key`, allowing attackers to inject arbitrary padding that affects address derivation but is ignored during authentication, breaking the 1:1 mapping between external identities and Aptos addresses.

## Finding Description

The derivable account abstraction system derives Aptos addresses by hashing the BCS-serialized `abstract_public_key` along with function info and a scheme byte. [1](#0-0) 

However, the Ethereum implementation deserializes `abstract_public_key` without validating that all bytes were consumed from the BCS stream. [2](#0-1) 

Similarly, the Solana implementation lacks this validation. [3](#0-2) 

In contrast, the Sui implementation correctly validates that all bytes were consumed. [4](#0-3) 

**Attack Scenario:**

1. Attacker creates `pk_padded = BCS(ethereum_address, domain) || [0xDE, 0xAD, 0xBE, 0xEF]`
2. Address derivation at line 115 includes the entire byte vector (with padding) when computing `bcs::to_bytes(abstract_public_key)`, producing a different hash than the unpadded version
3. During authentication, deserialization only reads `ethereum_address` and `domain`, leaving the padding bytes unconsumed but unvalidated
4. Both padded and unpadded versions authenticate with the same Ethereum signature but derive different addresses

This breaks the invariant that one external identity deterministically maps to exactly one Aptos address.

## Impact Explanation

This is a **MEDIUM to HIGH severity** vulnerability representing a significant protocol invariant violation:

1. **Protocol Invariant Violation**: Breaks the fundamental assumption that derivable account abstraction provides deterministic 1:1 mapping between external identities and Aptos addresses.

2. **Account Squatting/Griefing**: Attackers can pre-register multiple addresses derived from their external identity, creating namespace confusion.

3. **Application-Level Exploits**: Smart contracts and dApps assuming address uniqueness per identity could be exploited for airdrops, voting systems, or access control mechanisms.

4. **State Consistency**: While deterministic execution is maintained across validators (no consensus split), the protocol semantics are violated at the application layer.

The vulnerability does NOT cause: direct fund theft from the protocol, consensus splits, network partitions, or loss of liveness. Therefore, it falls into the **MEDIUM severity** category ("Limited Protocol Violations") per Aptos bug bounty criteria, though it could be argued as HIGH due to breaking a fundamental system invariant.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Trivial - attacker only needs to append arbitrary bytes to a valid BCS-serialized `abstract_public_key`
- **Attacker Requirements**: None - any user can submit transactions with padded keys
- **Detection Difficulty**: Low - the malformed keys are accepted without error
- **Affected Scope**: All users of Ethereum and Solana derivable account abstractions

The vulnerability is exploitable if derivable account abstraction features are enabled on the network.

## Recommendation

Add BCS stream validation to both `ethereum_derivable_account.move` and `solana_derivable_account.move`, following the Sui implementation pattern:

```move
fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SIWEAbstractPublicKey {
    let stream = bcs_stream::new(*abstract_public_key);
    let ethereum_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
    let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
    assert!(!bcs_stream::has_remaining(&mut stream), EMALFORMED_DATA);  // Add this line
    SIWEAbstractPublicKey { ethereum_address, domain }
}
```

Similarly for `deserialize_abstract_signature` in both modules. [5](#0-4) 

## Proof of Concept

The Sui module includes test cases demonstrating this exact vulnerability scenario. [6](#0-5) 

A similar test can be constructed for Ethereum/Solana modules to demonstrate that appending padding bytes to a valid `abstract_public_key` results in different derived addresses while still passing authentication checks.

## Notes

- The Sui implementation already contains the proper fix, indicating this vulnerability was likely discovered during that module's development
- The fix is minimal: a single assertion to validate stream consumption
- Both signature and public key deserialization functions need the fix in Ethereum and Solana modules
- The vulnerability maintains consensus (deterministic execution) but violates protocol semantics

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L110-118)
```text
    public fun derive_account_address(derivable_func_info: FunctionInfo, abstract_public_key: &vector<u8>): address {
        // using bcs serialized structs here - this allows for no need for separators.
        // Alternative would've been to create unique string, we would need to convert derivable_func_info into string,
        // then authentication_key to hex, and then we need separators as well - like ::
        let bytes = bcs::to_bytes(&derivable_func_info);
        bytes.append(bcs::to_bytes(abstract_public_key));
        bytes.push_back(DERIVABLE_ABSTRACTION_DERIVED_SCHEME);
        from_bcs::to_address(hash::sha3_256(bytes))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L75-80)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SIWEAbstractPublicKey {
        let stream = bcs_stream::new(*abstract_public_key);
        let ethereum_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        SIWEAbstractPublicKey { ethereum_address, domain }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/solana_derivable_account.move (L60-66)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>):
    (vector<u8>, vector<u8>) {
        let stream = bcs_stream::new(*abstract_public_key);
        let base58_public_key = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        (base58_public_key, domain)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/sui_derivable_account.move (L113-119)
```text
    fun deserialize_abstract_public_key(abstract_public_key: &vector<u8>): SuiAbstractPublicKey {
        let stream = bcs_stream::new(*abstract_public_key);
        let sui_account_address = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        let domain = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
        assert!(!bcs_stream::has_remaining(&mut stream), EMALFORMED_DATA);
        SuiAbstractPublicKey { sui_account_address, domain }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/sui_derivable_account.move (L122-132)
```text
    fun deserialize_abstract_signature(abstract_signature: &vector<u8>): SuiAbstractSignature {
        let stream = bcs_stream::new(*abstract_signature);
        let signature_type = bcs_stream::deserialize_u8(&mut stream);
        if (signature_type == 0x00) {
            let signature = bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x));
            assert!(!bcs_stream::has_remaining(&mut stream), EMALFORMED_DATA);
            SuiAbstractSignature::MessageV1 { signature }
        } else {
            abort(EINVALID_SIGNATURE_TYPE)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/sui_derivable_account.move (L410-436)
```text
    #[expected_failure(abort_code = EMALFORMED_DATA)]
    fun test_deserialize_abstract_signature_with_trailing_bytes() {
        let signature_bytes = vector[0, 151, 47, 171, 144, 115, 16, 129, 17, 202, 212, 180, 155, 213, 223, 249, 203, 195, 0, 84, 142, 121, 167, 29, 113, 159, 33, 177, 108, 137, 113, 160, 118, 41, 246, 199, 202, 79, 151, 27, 86, 235, 219, 123, 168, 152, 38, 124, 147, 146, 118, 101, 37, 187, 223, 206, 120, 101, 148, 33, 141, 80, 60, 155, 13, 25, 200, 235, 92, 139, 72, 175, 189, 40, 0, 65, 76, 215, 148, 94, 194, 78, 134, 60, 189, 212, 116, 40, 134, 179, 104, 31, 249, 222, 84, 104, 202];
        let abstract_signature = create_raw_signature(signature_bytes);
        // Append trailing bytes to simulate griefing attack
        abstract_signature.push_back(0xDE);
        abstract_signature.push_back(0xAD);
        abstract_signature.push_back(0xBE);
        abstract_signature.push_back(0xEF);
        // This should fail with EMALFORMED_DATA due to trailing bytes
        deserialize_abstract_signature(&abstract_signature);
    }

    #[test]
    #[expected_failure(abort_code = EMALFORMED_DATA)]
    fun test_deserialize_abstract_public_key_with_trailing_bytes() {
        let sui_account_address = b"0x8d6ce7a3c13617b29aaf7ec58bee5a611606a89c62c5efbea32e06d8d167bd49";
        let domain = b"localhost:3001";
        let abstract_public_key = create_abstract_public_key(sui_account_address, domain);
        // Append trailing bytes to simulate griefing attack
        abstract_public_key.push_back(0xDE);
        abstract_public_key.push_back(0xAD);
        abstract_public_key.push_back(0xBE);
        abstract_public_key.push_back(0xEF);
        // This should fail with EMALFORMED_DATA due to trailing bytes
        deserialize_abstract_public_key(&abstract_public_key);
    }
```
