# Audit Report

## Title
Critical Safety Field Loss During SafetyData Schema Upgrade Enables Consensus Safety Violations

## Summary
When upgrading from an older Aptos version to a newer version with expanded SafetyData schema, critical consensus safety fields (`highest_timeout_round` and `one_chain_round`) are deserialized with default value 0 instead of being properly migrated. This allows validators to violate safety rules in the 2-chain consensus protocol, potentially enabling equivocation and consensus safety violations.

## Finding Description

The `SafetyData` struct in the consensus safety rules system tracks critical state needed to enforce consensus safety invariants. Two fields use the `#[serde(default)]` attribute to support backward compatibility: [1](#0-0) 

During schema upgrades, when a validator deserializes old SafetyData that lacks these fields, they default to 0. This breaks two critical safety checks in the 2-chain consensus protocol:

**Safety Check 1: Order Vote Restriction** [2](#0-1) 

This check enforces that after signing a timeout for round R, a validator cannot sign order votes for rounds ≤ R. If `highest_timeout_round` is reset to 0 during upgrade, the check becomes trivial (any round > 0 passes), allowing the validator to sign order votes for rounds it should be forbidden from ordering.

**Safety Check 2: Timeout Certificate Validation** [3](#0-2) 

This check ensures timeouts only occur when the QC is at least as high as the known 1-chain round. If `one_chain_round` is reset to 0, the check becomes trivial (any qc_round ≥ 0 passes).

**Exploitation Scenario:**

1. Validator runs version V1 and signs a timeout for round 95 at block height 1000
2. Validator upgrades to version V2 mid-epoch (common during software updates)
3. SafetyData on disk has old schema without `highest_timeout_round` field
4. During restart, deserialization occurs: [4](#0-3) 

5. The `highest_timeout_round` field defaults to 0
6. Validator receives OrderVoteProposal for round 90
7. The `safe_for_order_vote` check evaluates: `90 > 0` ✓ (incorrectly passes)
8. Validator signs order vote for round 90, violating the consensus invariant that it should not order blocks for rounds ≤ 95 after signing a timeout

The `test_safety_data_upgrade` test verifies backward compatibility exists but does not validate safety property preservation: [5](#0-4) 

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation)

This vulnerability breaks a fundamental consensus safety invariant in the 2-chain AptosBFT protocol. The impact includes:

1. **Equivocation Risk**: A validator that signed a timeout for round R can subsequently sign order votes for rounds ≤ R, creating conflicting messages in the consensus protocol
2. **Consensus Safety Violation**: Different validators may make inconsistent ordering decisions if some have correct timeout history and others have reset state
3. **Silent Failure**: The vulnerability manifests automatically during normal operations (software upgrades) without any error indication
4. **Epoch-Long Exposure**: The incorrect state persists until the next epoch boundary, which could be hours or days

Per Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations." It could escalate to **Critical** if it leads to actual consensus splits or chain forks affecting network safety under Byzantine conditions.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has high likelihood because:

1. **Common Trigger**: Software upgrades are routine operational procedures for validators
2. **Automatic Exploitation**: No malicious action required—the vulnerability manifests automatically during normal upgrade process
3. **Mid-Epoch Upgrades**: Validators may restart mid-epoch for various reasons (crashes, maintenance, upgrades)
4. **No Mitigation**: The codebase contains no validation or migration logic to handle this scenario [6](#0-5) 

The only natural mitigation is epoch transitions, which explicitly reset SafetyData: [7](#0-6) 

However, this doesn't prevent the vulnerability from occurring and persisting throughout the epoch duration.

## Recommendation

Implement proper schema migration with validation when deserializing SafetyData:

```rust
// In consensus/consensus-types/src/safety_data.rs
impl SafetyData {
    pub fn validate_after_deserialization(&self) -> Result<(), String> {
        // If we're in an active epoch with vote history but safety fields are 0,
        // this indicates a schema upgrade without proper migration
        if self.last_voted_round > 0 && 
           (self.one_chain_round == 0 || 
            (self.highest_timeout_round == 0 && self.last_vote.is_some())) {
            return Err(format!(
                "Potentially invalid SafetyData after upgrade: \
                 last_voted_round={} but one_chain_round={}, highest_timeout_round={}",
                self.last_voted_round, self.one_chain_round, self.highest_timeout_round
            ));
        }
        Ok(())
    }
}

// In consensus/safety-rules/src/persistent_safety_storage.rs
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    let safety_data = if !self.enable_cached_safety_data {
        self.internal_store.get(SAFETY_DATA).map(|v| v.value)?
    } else {
        // ... existing cached logic
    };
    
    // Validate after deserialization
    safety_data.validate_after_deserialization()
        .map_err(|e| Error::InternalError(e))?;
    
    Ok(safety_data)
}
```

Additionally, implement explicit schema versioning:

```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone)]
pub struct SafetyData {
    #[serde(default = "default_schema_version")]
    pub schema_version: u32,
    pub epoch: u64,
    pub last_voted_round: u64,
    pub preferred_round: u64,
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}

fn default_schema_version() -> u32 { 1 }

const CURRENT_SCHEMA_VERSION: u32 = 2;
```

This allows explicit migration paths and prevents silent safety violations during upgrades.

## Proof of Concept

```rust
#[test]
fn test_safety_data_upgrade_violates_timeout_safety() {
    use serde::{Deserialize, Serialize};
    
    // Simulate old SafetyData format without new safety fields
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    
    // Validator in old version signs timeout at round 95 (not tracked)
    // and has progressed to round 100
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 100,
        preferred_round: 99,
        last_vote: None,
    };
    
    // Serialize old format
    let serialized = serde_json::to_value(old_data).unwrap();
    
    // Deserialize with new SafetyData struct
    let new_data: SafetyData = serde_json::from_value(serialized).unwrap();
    
    // Critical safety fields are now 0!
    assert_eq!(new_data.highest_timeout_round, 0);
    assert_eq!(new_data.one_chain_round, 0);
    
    // This allows invalid order votes:
    // If validator signed timeout at round 95, it should NOT be able to 
    // sign order votes for round 90. But the check passes:
    let order_vote_round = 90;
    let would_pass = order_vote_round > new_data.highest_timeout_round; // 90 > 0 = true
    
    assert!(would_pass, "Safety check incorrectly passes after upgrade!");
    
    // Expected behavior: should fail because 90 <= 95 (timeout round)
    // Actual behavior: passes because highest_timeout_round was reset to 0
}
```

This test demonstrates that the deserialization succeeds but creates a SafetyData state that allows consensus safety violations. A validator that signed a timeout at round 95 can now sign order votes for round 90, which should be forbidden by the `safe_for_order_vote` safety rule.

## Notes

This vulnerability specifically affects the upgrade path between versions that added the `one_chain_round` and `highest_timeout_round` fields to SafetyData. While the `#[serde(default)]` attribute enables backward compatibility for deserialization, it does not preserve the semantic safety properties that these fields represent. The test `test_safety_data_upgrade` only validates that deserialization doesn't crash, not that consensus safety invariants are maintained post-upgrade.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L16-20)
```rust
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
```

**File:** consensus/consensus-types/src/safety_data.rs (L53-70)
```rust
#[test]
fn test_safety_data_upgrade() {
    #[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
    struct OldSafetyData {
        pub epoch: u64,
        pub last_voted_round: u64,
        pub preferred_round: u64,
        pub last_vote: Option<Vote>,
    }
    let old_data = OldSafetyData {
        epoch: 1,
        last_voted_round: 10,
        preferred_round: 100,
        last_vote: None,
    };
    let value = serde_json::to_value(old_data).unwrap();
    let _: SafetyData = serde_json::from_value(value).unwrap();
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L294-303)
```rust
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;
```
