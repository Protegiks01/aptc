# Audit Report

## Title
Backward Incompatibility Vulnerability in PatchUpsertJWK Deserialization Causing Validator Transaction Failures

## Summary
The `PatchUpsertJWK` struct lacks versioning and is stored on-chain via BCS serialization. If the struct definition changes during an Aptos code upgrade, previously serialized instances will fail to deserialize, causing all validator nodes to fail when processing JWK update transactions, potentially leading to block execution failures.

## Finding Description

The vulnerability exists in the serialization/deserialization flow of `PatchUpsertJWK` instances stored in the on-chain `Patches` resource.

**The Core Issue:**

The Rust struct `PatchUpsertJWK` is defined without any version field: [1](#0-0) 

This struct is serialized using BCS and stored on-chain in the Move `Patches` resource: [2](#0-1) 

The Move struct `PatchUpsertJWK` has `copy, drop, store` abilities but NOT `key`: [3](#0-2) 

This means the struct definition CAN be changed during module upgrades, unlike resources with the `key` ability which are protected.

**The Failure Path:**

When validators process JWK updates, the code calls `regenerate_patched_jwks()` which iterates through all patches: [4](#0-3) 

The `apply_patch` function attempts to deserialize `PatchUpsertJWK` using `copyable_any::unpack`: [5](#0-4) 

The `unpack` function uses the native `from_bytes<T>` which will abort if the serialized bytes don't match the current struct layout: [6](#0-5) 

**Propagation to Consensus:**

When this abort occurs during validator transaction processing, it propagates through the error handling chain:

1. The error is mapped to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`: [7](#0-6) 

2. This causes the JWK validator transaction to return an unexpected failure: [8](#0-7) 

3. In the block executor, this becomes an `ExecutionStatus::Abort`: [9](#0-8) 

4. During sequential execution, this results in a `FatalVMError`: [10](#0-9) 

**Invariant Violation:**

This breaks the **Deterministic Execution** invariant. If validators are running different code versions during an upgrade window, they will have different struct definitions and thus different deserialization outcomes, potentially causing consensus divergence.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty criteria)

This vulnerability causes:

1. **Validator Node Failures**: All validators attempting to process JWK update transactions will encounter `FatalVMError`, causing block execution to fail.

2. **Consensus Disruption**: If JWK consensus is enabled (via `OnChainJWKConsensusConfig`), validator transactions containing JWK updates become expected in blocks. Failures in processing these transactions can disrupt normal block progression.

3. **Requires Coordinated Intervention**: Recovery requires either:
   - Emergency governance proposal to clear the `Patches` resource
   - Coordinated hardfork to fix the incompatibility
   - Rolling back the upgrade

4. **Non-Deterministic Behavior During Upgrades**: During the upgrade window when different validators may be running different code versions, deserialization outcomes will differ, violating the deterministic execution guarantee.

The impact qualifies as "Validator node slowdowns" and "Significant protocol violations" under the HIGH severity category.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability will trigger if ALL of the following conditions are met:

1. **JWK Consensus Enabled**: `OnChainJWKConsensusConfig.jwk_consensus_enabled()` returns true
2. **Non-Empty Patches**: The on-chain `Patches` resource contains at least one `PatchUpsertJWK` entry
3. **Struct Definition Changed**: A code upgrade modifies the `PatchUpsertJWK` struct (adding/removing/reordering fields)
4. **Validator Transaction Processed**: A validator attempts to execute an `ObservedJWKUpdate` transaction

While not every upgrade will change this struct, the lack of protective versioning means any future change is a ticking time bomb. The Move struct lacks the `key` ability, so it can be legally modified in upgrades without Move's normal compatibility checks.

## Recommendation

**Implement version-aware serialization for PatchUpsertJWK:**

1. **Add a version field to both Rust and Move structs:**

```rust
// types/src/jwks/patch/mod.rs
#[derive(Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PatchUpsertJWK {
    pub version: u64,  // Add this
    pub issuer: String,
    pub jwk: JWKMoveStruct,
}
```

```move
// aptos-move/framework/aptos-framework/sources/jwks.move
struct PatchUpsertJWK has copy, drop, store {
    version: u64,  // Add this
    issuer: vector<u8>,
    jwk: JWK,
}
```

2. **Implement migration logic in `apply_patch`:**

```move
// In apply_patch function
else if (variant_type_name == b"0x1::jwks::PatchUpsertJWK") {
    let cmd = copyable_any::unpack<PatchUpsertJWK>(patch.variant);
    // Add version check and handle old versions gracefully
    assert!(cmd.version <= CURRENT_PATCH_VERSION, EUNSUPPORTED_PATCH_VERSION);
    // ... rest of logic
}
```

3. **Add upgrade migration script:**

Before deploying any upgrade that changes `PatchUpsertJWK`, execute a governance proposal that:
- Reads all existing patches
- Re-serializes them with the new version
- Updates the `Patches` resource

4. **Alternative: Use `Any` wrapper with explicit type checking:**

Instead of directly unpacking, check the serialized data length and version before attempting deserialization, providing fallback logic for old formats.

## Proof of Concept

**Scenario Setup:**

1. Initial state: Chain has JWK consensus enabled with patches containing `PatchUpsertJWK` entries
2. Upgrade deploys new code where `PatchUpsertJWK` has an additional field
3. Validator proposes a block containing an `ObservedJWKUpdate` transaction

**Reproduction Steps:**

```rust
// Test demonstrating deserialization failure
#[test]
fn test_patch_upsert_jwk_backward_incompatibility() {
    // 1. Serialize PatchUpsertJWK with OLD struct definition
    #[derive(Serialize, Deserialize)]
    struct OldPatchUpsertJWK {
        issuer: String,
        jwk: JWKMoveStruct,
    }
    
    let old_patch = OldPatchUpsertJWK {
        issuer: "https://accounts.google.com".to_string(),
        jwk: create_test_jwk(),
    };
    let serialized = bcs::to_bytes(&old_patch).unwrap();
    
    // 2. Try to deserialize with NEW struct definition (with additional field)
    #[derive(Serialize, Deserialize)]
    struct NewPatchUpsertJWK {
        issuer: String,
        jwk: JWKMoveStruct,
        new_field: u64,  // New field added in upgrade
    }
    
    // This will fail with BCS deserialization error
    let result = bcs::from_bytes::<NewPatchUpsertJWK>(&serialized);
    assert!(result.is_err());  // Proves incompatibility
}
```

**Move Test:**

```move
#[test(fx = @aptos_framework)]
fun test_patch_deserialization_failure_on_upgrade(fx: &signer) {
    // 1. Initialize and set patches with current struct
    jwks::initialize(fx);
    let patch = jwks::new_patch_upsert_jwk(b"issuer", create_test_jwk());
    jwks::set_patches(fx, vector[patch]);
    
    // 2. Simulate upgrade by attempting to apply patches
    // If struct definition changed, regenerate_patched_jwks() would abort
    // In real scenario, this abort would cause FatalVMError
    jwks::upsert_into_observed_jwks(fx, vector[]);  // Triggers regenerate_patched_jwks
}
```

The PoC demonstrates that any modification to `PatchUpsertJWK` struct layout will cause previously serialized instances to fail BCS deserialization, triggering the failure cascade described above.

## Notes

This vulnerability is particularly insidious because:

1. **Silent Until Triggered**: The incompatibility only manifests when validators process JWK updates after an upgrade, not immediately upon deployment.

2. **Affects All Validators Uniformly**: Since all validators run the same code (eventually), all will fail at the same serialized patch, making this a network-wide issue rather than isolated failures.

3. **Move's Type Safety Doesn't Help**: While Move prevents changing structs with `key` ability, `PatchUpsertJWK` only has `copy, drop, store`, so Move allows modifications during upgrades.

4. **No Warning System**: There's no compile-time or runtime check that alerts developers when modifying this struct would break backward compatibility with on-chain data.

The fix requires careful coordination between Rust and Move code, plus establishing a migration pattern for future upgrades.

### Citations

**File:** types/src/jwks/patch/mod.rs (L30-34)
```rust
#[derive(Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PatchUpsertJWK {
    pub issuer: String,
    pub jwk: JWKMoveStruct,
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L152-155)
```text
    struct PatchUpsertJWK has copy, drop, store {
        issuer: vector<u8>,
        jwk: JWK,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L160-162)
```text
    struct Patches has key {
        patches: vector<Patch>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L691-692)
```text
        } else if (variant_type_name == b"0x1::jwks::PatchUpsertJWK") {
            let cmd = copyable_any::unpack<PatchUpsertJWK>(patch.variant);
```

**File:** aptos-move/framework/aptos-stdlib/sources/copyable_any.move (L27-30)
```text
    public fun unpack<T>(self: Any): T {
        assert!(type_info::type_name<T>() == self.type_name, error::invalid_argument(ETYPE_MISMATCH));
        from_bytes<T>(self.data)
    }
```

**File:** aptos-move/aptos-vm/src/errors.rs (L275-305)
```rust
pub fn expect_only_successful_execution(
    error: VMError,
    function_name: &str,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let status = error.into_vm_status();
    Err(match status {
        VMStatus::Executed => VMStatus::Executed,
        // Speculative errors are returned for caller to handle.
        e @ VMStatus::Error {
            status_code:
                StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
                | StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
            ..
        } => e,
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
    })
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L163-166)
```rust
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L99-115)
```rust
            // execute_single_transaction only returns an error when transactions that should never fail
            // (BlockMetadataTransaction and GenesisTransaction) return an error themselves.
            Err(err) => {
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
            },
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```
