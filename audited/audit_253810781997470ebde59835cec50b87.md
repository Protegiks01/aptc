# Audit Report

## Title
Storage Refund Farming via Governance Fee Reductions Allows Value Extraction from Protocol

## Summary
The V2 storage refund mechanism refunds the full historical deposit amount on deletion without adjusting for subsequent gas schedule changes. When governance reduces `storage_fee_per_state_byte` or `storage_fee_per_state_slot` parameters, attackers can extract net positive value by creating storage at high fees and deleting at low fees, with excess refunds minted as new coins.

## Finding Description
The storage pricing system in Aptos V2 stores deposit amounts in `StateValueMetadata` when state is created. These deposits consist of a slot fee and a per-byte fee calculated using current gas schedule parameters. [1](#0-0) 

When state is deleted, the system refunds the entire stored deposit without adjusting for current prices: [2](#0-1) 

The gas schedule parameters can be updated by governance through proposals: [3](#0-2) 

In the transaction epilogue, when the storage refund exceeds the transaction fee, the difference is minted as new coins: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker monitors governance proposals for storage fee reductions
2. Before reduction: Creates large storage items (e.g., 1000 bytes) when `storage_fee_per_state_byte = 100`
   - Pays deposit: 40,000 (slot) + 100,000 (bytes) = 140,000 octas per item
3. Governance reduces fees to `storage_fee_per_state_byte = 10` (90% reduction)
4. After reduction: Deletes all storage items
   - Receives refund: 140,000 octas per item (from stored metadata)
   - Current value: 40,000 + 10,000 = 50,000 octas per item
   - Net profit: 90,000 octas per item (minus minimal transaction costs)
5. For 10,000 items: Extracts 900,000,000 octas = 9 APT from protocol

The test suite confirms this behavior - deposits are not adjusted on deletion even when prices change: [6](#0-5) 

The test shows refund of 1054 octas when current prices would only charge 1050 octas - a 4 octa extraction per deletion.

## Impact Explanation
**Severity: Medium** - Limited funds loss through economic manipulation.

This meets the Medium severity criteria ("Limited funds loss or manipulation") because:
- Attackers can extract value from the protocol when governance reduces storage fees
- The protocol mints new coins to cover excess refunds, effectively inflating supply
- Scale is limited by attacker capital (must pre-fund deposits) and governance action frequency
- Does not directly steal user funds or break consensus
- Requires significant capital (14 APT to potentially extract 9 APT in the example)
- Profit scales with magnitude of fee reduction and number of storage items

The economic invariant is broken: deposits should represent the current value of storage, but instead represent historical value, creating arbitrage opportunities during fee reductions.

## Likelihood Explanation
**Likelihood: Medium-High**

Factors increasing likelihood:
- Gas schedule updates are a normal governance activity (documented process)
- Storage fee reductions are plausible (e.g., due to improved efficiency, reduced storage costs)
- Attack is deterministic - no timing precision required beyond governance proposal monitoring
- No technical barriers - any user can create and delete storage
- Profitable at scale with sufficient capital

Factors decreasing likelihood:
- Requires governance to actually reduce fees (not guaranteed)
- Requires capital to pre-fund deposits
- Governance may be aware and avoid large fee reductions
- Attack is transparent (large storage creation patterns visible on-chain)

## Recommendation
Implement a price adjustment mechanism for deletion refunds to cap refunds at current market rates:

```rust
Deletion => {
    let current_value = u64::from(params.storage_fee_per_state_slot) 
        + (key_size + op.prev_size) * u64::from(params.storage_fee_per_state_byte);
    let actual_refund = std::cmp::min(
        op.metadata_mut.total_deposit(),
        current_value
    );
    ChargeAndRefund {
        charge: 0.into(),
        refund: actual_refund.into(),
    }
}
```

This ensures refunds never exceed the current cost to recreate the same storage, preventing value extraction while maintaining incentives for deletion.

Alternative: Implement a grace period after fee changes where refunds are gradually adjusted, or track the gas schedule version in metadata and apply version-specific refund rules.

## Proof of Concept
```rust
#[test]
fn test_storage_refund_farming() {
    let pricing = DiskSpacePricing::V2;
    let mut params = TransactionGasParameters::random();
    
    // High fee period
    params.storage_fee_per_state_byte = 100.into();
    params.storage_fee_per_state_slot = 40_000.into();
    
    let key = StateKey::raw(&[1, 2, 3]); // 3 bytes
    let ts = CurrentTimeMicroseconds { microseconds: 0 };
    let mut meta = StateValueMetadata::new(0, 0, &ts);
    
    // Create storage at high fees
    let ChargeAndRefund { charge: create_charge, refund: _ } =
        pricing.charge_refund_write_op(&params, WriteOpInfo {
            key: &key,
            op_size: WriteOpSize::Creation { write_len: 1000 },
            prev_size: 0,
            metadata_mut: &mut meta,
        });
    
    // Deposit = 40,000 + (3 + 1000) * 100 = 140,300 octas
    assert_eq!(u64::from(create_charge), 140_300);
    
    // Governance reduces fees by 90%
    params.storage_fee_per_state_byte = 10.into();
    
    // Delete storage at low fees
    let ChargeAndRefund { charge: _, refund: delete_refund } =
        pricing.charge_refund_write_op(&params, WriteOpInfo {
            key: &key,
            op_size: WriteOpSize::Deletion,
            prev_size: 1000,
            metadata_mut: &mut meta,
        });
    
    // Refund = 140,300 octas (full stored deposit)
    assert_eq!(u64::from(delete_refund), 140_300);
    
    // Current value = 40,000 + (3 + 1000) * 10 = 50,030 octas
    let current_value = 40_000 + 1003 * 10;
    assert_eq!(current_value, 50_030);
    
    // Net extraction = 140,300 - 50,030 = 90,270 octas per item
    let profit = u64::from(delete_refund) - current_value;
    assert_eq!(profit, 90_270);
    
    // With 10,000 items: 902,700,000 octas â‰ˆ 9 APT extracted
}
```

## Notes
- The vulnerability is in the core storage pricing logic, not a peripheral component
- The test suite in `space_pricing.rs` demonstrates awareness of price changes but only implements caps on modifications, not deletions
- The economic impact scales with both the magnitude of fee reductions and the number of storage items
- Mitigation requires careful balancing of deletion incentives versus economic attack prevention
- Current design favors users over protocol solvency during fee reductions

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L174-185)
```rust
            Creation { .. } => {
                // permanent storage fee
                let slot_deposit = u64::from(params.storage_fee_per_state_slot);

                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);

                ChargeAndRefund {
                    charge: (slot_deposit + target_bytes_deposit).into(),
                    refund: 0.into(),
                }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L208-211)
```rust
            Deletion => ChargeAndRefund {
                charge: 0.into(),
                refund: op.metadata_mut.total_deposit().into(),
            },
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L363-376)
```rust
        // refund all on deletion
        let ChargeAndRefund { charge, refund } =
            pricing.charge_refund_write_op(&params, WriteOpInfo {
                key: &key,
                op_size: WriteOpSize::Deletion,
                prev_size: 2,
                metadata_mut: &mut meta,
            });
        assert_eq!(charge, 0.into());
        assert_eq!(refund, 1054.into());
        // no need to clear up the metadata for deletions
        assert_eq!(meta.slot_deposit(), 1000);
        assert_eq!(meta.bytes_deposit(), 54);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L195-199)
```rust
            storage_fee_per_state_byte: FeePerByte,
            { 14.. => "storage_fee_per_state_byte" },
            // 0.8 million APT for 2 TB state bytes
            40,
        ],
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L620-626)
```text
            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer, burn_amount);
            } else if (transaction_fee_amount < storage_fee_refunded) {
                let mint_amount = storage_fee_refunded - transaction_fee_amount;
                transaction_fee::mint_and_refund(gas_payer, mint_amount);
            };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_fee.move (L100-106)
```text
    public(friend) fun mint_and_refund(
        account: address, refund: u64
    ) acquires AptosCoinMintCapability {
        let mint_cap = &borrow_global<AptosCoinMintCapability>(@aptos_framework).mint_cap;
        let refund_coin = coin::mint(refund, mint_cap);
        coin::deposit_for_gas_fee(account, refund_coin);
    }
```
