# Audit Report

## Title
Predictable Proposer Selection in LeaderReputation V1 Enables Strategic Validator Behavior Optimization

## Summary
The ProposerAndVoter V1 proposer election mechanism uses a fully predictable seed (`[epoch, round]`) that allows validators to compute the entire epoch's proposer sequence in advance. This predictability enables rational validators to optimize their behavior strategically, deviating from honest consistent participation to maximize rewards while minimizing operational costs.

## Finding Description

The LeaderReputation system implements reputation-based proposer selection where validators are chosen based on historical performance weighted by stake. In the V1 implementation (ProposerAndVoter), the selection seed is deterministic and predictable. [1](#0-0) 

The seed construction uses only epoch and round numbers when `use_root_hash` is false (V1 configuration): [2](#0-1) 

The code explicitly documents V1 as having a "simple (predictable) seed" while V2 uses an "unpredictable seed, based on root hash." [3](#0-2) 

**The Game-Theoretic Issue:**

Validator rewards are calculated proportionally to successful proposals: [4](#0-3) 

The formula `rewards = (stake * rate * num_successful_proposals) / (rate_denominator * num_total_proposals)` means validators who propose more blocks have more opportunities for rewards.

**Strategic Behavior Enabled:**

1. **Predictable Computation**: With seed = `[epoch, round]`, validators can compute `choose_index(weights, seed)` for all future rounds in the epoch before they occur.

2. **Resource Optimization**: Knowing when they will/won't be selected, validators can:
   - Run high-performance infrastructure only during their selection rounds
   - Reduce operational costs during rounds where they're unlikely to be selected
   - Maintain "active" status selectively to stay in the high-weight category (100) vs inactive (10)

3. **Coordination Potential**: Multiple validators can coordinate their behavior patterns since all can predict the same sequence. [5](#0-4) 

The deterministic selection algorithm combined with predictable seed allows sophisticated validators to maximize their proposal frequency relative to operational investment.

## Impact Explanation

This finding represents a **High severity** game-theoretic vulnerability under the category of "Significant protocol violations." While it doesn't directly enable fund theft or consensus safety breaks, it violates the principle of fair, unpredictable proposer selection and creates exploitable strategic advantages.

**Impacts:**
- **Network Reliability**: Validators optimizing for specific rounds reduces overall network resilience
- **Fairness**: Sophisticated validators gain unfair advantages over honest validators who maintain consistent performance
- **Centralization Risk**: Validators with resources to optimize strategically gain disproportionate rewards
- **Liveness Concerns**: Strategic participation timing could impact chain progress

The Aptos team's creation of V2 specifically to address "predictable seed" demonstrates they considered this significant enough to warrant a protocol change.

## Likelihood Explanation

**Likelihood: HIGH**

This is highly likely to occur because:
1. **Zero Barrier**: Any validator can compute future proposers with simple arithmetic
2. **Rational Incentive**: Validators are economically incentivized to optimize costs while maximizing rewards
3. **No Detection**: Strategic resource optimization is indistinguishable from normal operational variance
4. **No Punishment**: The protocol has no mechanism to penalize this behavior

Validators operating under V1 configuration have both the means and motive to deviate from consistent honest behavior.

## Recommendation

**The fix has already been implemented in V2 (ProposerAndVoterV2)** which uses the root hash in the seed: [1](#0-0) 

When `use_root_hash` is true, the seed becomes `[root_hash, epoch, round]`, where `root_hash` depends on committed blocks and cannot be predicted in advance.

**Recommended Actions:**
1. **Deprecate V1**: Ensure all networks migrate to V2 configuration
2. **Governance Parameter**: Make V1 unavailable through on-chain configuration
3. **Documentation**: Clearly document the game-theoretic risks of predictable selection
4. **Monitoring**: Track validator performance variance to detect strategic behavior patterns

## Proof of Concept

```rust
// Conceptual PoC showing predictability exploitation
// File: validator_strategic_behavior_poc.rs

use aptos_crypto::HashValue;

fn compute_proposer_for_round(epoch: u64, round: u64, weights: Vec<u128>) -> usize {
    // V1 seed is entirely predictable
    let state = [
        epoch.to_le_bytes().to_vec(),
        round.to_le_bytes().to_vec(),
    ]
    .concat();
    
    // Validator can call this for all future rounds
    choose_index(weights.clone(), state)
}

fn strategic_validator_behavior() {
    let epoch = 100;
    let my_stake_weight = 1000u128;
    let weights = vec![500, my_stake_weight, 800, 1200]; // Example weights
    
    // Predict entire epoch in advance
    let mut my_selected_rounds = vec![];
    for round in 0..10000 {
        let selected_idx = compute_proposer_for_round(epoch, round, weights.clone());
        if selected_idx == 1 { // my index
            my_selected_rounds.push(round);
        }
    }
    
    println!("I will be selected in rounds: {:?}", my_selected_rounds);
    println!("I can now optimize resources for only these {} rounds", my_selected_rounds.len());
    
    // Strategic behavior:
    // - Run high-performance nodes only during my_selected_rounds
    // - Reduce costs during other rounds
    // - Maintain just enough participation to stay "active" (weight=100 not 10)
}
```

**Demonstration in Real Network:**
1. Validator queries current epoch and validator set
2. Retrieves historical reputation weights from block metadata
3. Computes proposer sequence for entire epoch using V1 formula
4. Adjusts infrastructure scaling based on predicted selection frequency
5. Achieves same rewards with lower operational costs than honest validators

## Notes

This vulnerability specifically affects deployments using **ProposerAndVoter V1 configuration**. The issue has been addressed in **ProposerAndVoterV2** which uses unpredictable seeds based on block root hashes. However, V1 remains in the codebase and could still be configured for use: [6](#0-5) 

Networks should ensure they are configured to use V2 to prevent this game-theoretic exploitation. The vulnerability enables rational but dishonest behavior rather than catastrophic security failures, placing it in the "High" category for protocol violations that undermine network fairness and reliability.

### Citations

**File:** consensus/src/liveness/leader_reputation.rs (L717-730)
```rust
        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };
```

**File:** types/src/on_chain_config/consensus_config.rs (L530-537)
```rust
    // Version 1:
    // * use reputation window from stale end
    // * simple (predictable) seed
    ProposerAndVoter(ProposerAndVoterConfig),
    // Version 2:
    // * use reputation window from recent end
    // * unpredictable seed, based on root hash
    ProposerAndVoterV2(ProposerAndVoterConfig),
```

**File:** types/src/on_chain_config/consensus_config.rs (L540-544)
```rust
impl LeaderReputationType {
    pub fn use_root_hash_for_seed(&self) -> bool {
        // all versions after V1 should use root hash
        !matches!(self, Self::ProposerAndVoter(_))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1761-1784)
```text
    fun calculate_rewards_amount(
        stake_amount: u64,
        num_successful_proposals: u64,
        num_total_proposals: u64,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
    ): u64 {
        spec {
            // The following condition must hold because
            // (1) num_successful_proposals <= num_total_proposals, and
            // (2) `num_total_proposals` cannot be larger than 86400, the maximum number of proposals
            //     in a day (1 proposal per second), and `num_total_proposals` is reset to 0 every epoch.
            assume num_successful_proposals * MAX_REWARDS_RATE <= MAX_U64;
        };
        // The rewards amount is equal to (stake amount * rewards rate * performance multiplier).
        // We do multiplication in u128 before division to avoid the overflow and minimize the rounding error.
        let rewards_numerator = (stake_amount as u128) * (rewards_rate as u128) * (num_successful_proposals as u128);
        let rewards_denominator = (rewards_rate_denominator as u128) * (num_total_proposals as u128);
        if (rewards_denominator > 0) {
            ((rewards_numerator / rewards_denominator) as u64)
        } else {
            0
        }
    }
```

**File:** consensus/src/liveness/proposer_election.rs (L48-69)
```rust
// chose index randomly, with given weight distribution
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** consensus/src/epoch_manager.rs (L312-328)
```rust
                    LeaderReputationType::ProposerAndVoter(proposer_and_voter_config)
                    | LeaderReputationType::ProposerAndVoterV2(proposer_and_voter_config) => {
                        let proposer_window_size = proposers.len()
                            * proposer_and_voter_config.proposer_window_num_validators_multiplier;
                        let voter_window_size = proposers.len()
                            * proposer_and_voter_config.voter_window_num_validators_multiplier;
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```
