> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5)

### Citations

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs (L159-160)
```rust
        &self.text[self.cur_start..self.cur_end]
    }
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs (L415-436)
```rust
fn get_decimal_number(text: &str) -> (Tok, usize) {
    let len = text
        .chars()
        .position(|c| !matches!(c, '0'..='9' | '_'))
        .unwrap_or(text.len());
    let rest = &text[len..];
    if rest.starts_with("u8") {
        (Tok::U8Value, len + 2)
    } else if rest.starts_with("u16") {
        (Tok::U16Value, len + 3)
    } else if rest.starts_with("u32") {
        (Tok::U32Value, len + 3)
    } else if rest.starts_with("u64") {
        (Tok::U64Value, len + 3)
    } else if rest.starts_with("u128") {
        (Tok::U128Value, len + 4)
    } else if rest.starts_with("u256") {
        (Tok::U256Value, len + 4)
    } else {
        (Tok::U64Value, len)
    }
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs (L439-443)
```rust
fn get_hex_digits_len(text: &str) -> usize {
    text.chars()
        .position(|c| !matches!(c, 'a'..='f' | 'A'..='F' | '0'..='9' | '_'))
        .unwrap_or(text.len())
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/syntax.rs (L183-199)
```rust
    if tokens.peek() != Tok::AccountAddressValue {
        return Err(ParseError::InvalidToken {
            location: current_token_loc(tokens),
            message: "expected Tok::AccountAddressValue".to_string(),
        });
    }
    let addr = AccountAddress::from_hex_literal(tokens.content())
        .with_context(|| {
            format!(
                "The address {:?} is of invalid length. Addresses are at most 32-bytes long",
                tokens.content()
            )
        })
        .unwrap();
    tokens.advance()?;
    Ok(addr)
}
```

**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/syntax.rs (L259-343)
```rust
        Tok::AccountAddressValue => {
            let addr = parse_account_address(tokens)?;
            CopyableVal_::Address(addr)
        },
        Tok::True => {
            tokens.advance()?;
            CopyableVal_::Bool(true)
        },
        Tok::False => {
            tokens.advance()?;
            CopyableVal_::Bool(false)
        },
        Tok::U8Value => {
            let mut s = tokens.content();
            if s.ends_with("u8") {
                s = &s[..s.len() - 2]
            }
            let i = u8::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U8(i)
        },
        Tok::U16Value => {
            let mut s = tokens.content();
            if s.ends_with("u16") {
                s = &s[..s.len() - 3]
            }
            let i = u16::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U16(i)
        },
        Tok::U32Value => {
            let mut s = tokens.content();
            if s.ends_with("u32") {
                s = &s[..s.len() - 3]
            }
            let i = u32::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U32(i)
        },
        Tok::U64Value => {
            let mut s = tokens.content();
            if s.ends_with("u64") {
                s = &s[..s.len() - 3]
            }
            let i = u64::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U64(i)
        },
        Tok::U128Value => {
            let mut s = tokens.content();
            if s.ends_with("u128") {
                s = &s[..s.len() - 4]
            }
            let i = u128::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U128(i)
        },
        Tok::U256Value => {
            let mut s = tokens.content();
            if s.ends_with("256") {
                s = &s[..s.len() - 4]
            }
            let i = int256::U256::from_str(s).unwrap();
            tokens.advance()?;
            CopyableVal_::U256(i)
        },
        Tok::ByteArrayValue => {
            let s = tokens.content();
            let buf = hex::decode(&s[2..s.len() - 1]).unwrap_or_else(|_| {
                // The lexer guarantees this, but tracking this knowledge all the way to here is tedious
                unreachable!("The string {:?} is not a valid hex-encoded byte array", s)
            });
            tokens.advance()?;
            CopyableVal_::ByteArray(buf)
        },
        t => {
            return Err(ParseError::InvalidToken {
                location: current_token_loc(tokens),
                message: format!("unrecognized token kind {:?}", t),
            })
        },
    };
    let end_loc = tokens.previous_end_loc();
    Ok(spanned(tokens.file_hash(), start_loc, end_loc, val))
}
```

**File:** third_party/move/move-core/types/src/account_address.rs (L160-178)
```rust
    pub fn from_hex_literal(literal: &str) -> Result<Self, AccountAddressParseError> {
        if !literal.starts_with("0x") {
            return Err(AccountAddressParseError::LeadingZeroXRequired);
        }

        let hex_len = literal.len() - 2;

        // If the string is too short, pad it
        if hex_len < Self::LENGTH * 2 {
            let mut hex_str = String::with_capacity(Self::LENGTH * 2);
            for _ in 0..Self::LENGTH * 2 - hex_len {
                hex_str.push('0');
            }
            hex_str.push_str(&literal[2..]);
            AccountAddress::from_hex(hex_str)
        } else {
            AccountAddress::from_hex(&literal[2..])
        }
    }
```
