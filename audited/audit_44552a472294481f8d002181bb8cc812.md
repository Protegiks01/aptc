# Audit Report

## Title
Script Complexity Budget Check Bypass Allows Resource Exhaustion Attacks

## Summary
The `check_script_complexity` function exists but is never invoked during script execution, allowing attackers to submit scripts with unbounded complexity that bypass the budget-based complexity metering applied to modules. This asymmetry enables resource exhaustion attacks against validator nodes.

## Finding Description

The Aptos VM implements a complexity budget system in `check_complexity.rs` to prevent overly complex bytecode from consuming excessive resources during deserialization, verification, and loading. This system charges costs for type nodes, identifier bytes, signatures, instantiations, and other bytecode elements against a configurable budget, returning `PROGRAM_TOO_COMPLEX` when the budget is exhausted.

**For modules**, this check is correctly applied: [1](#0-0) 

The error properly propagates through all call chains using the `?` operator.

**For scripts**, however, the corresponding `check_script_complexity` function exists but is never called: [2](#0-1) 

Scripts are executed through `validate_and_execute_script` which loads and verifies scripts: [3](#0-2) 

The script verification path includes `LimitsVerifier` but NOT the complexity budget check: [4](#0-3) 

The `LimitsVerifier` only checks hard limits (max_type_nodes, max_type_depth, etc.) if configured, but does not implement the same budget-based charging mechanism that meters ALL signatures, instantiations, handles, and code units comprehensively.

**Attack scenario:**
1. Attacker crafts a script with extremely complex type signatures (deeply nested generics, many struct instantiations)
2. Script passes `LimitsVerifier` because individual hard limits may not be tight enough
3. Script bypasses complexity budget check (which would return `PROGRAM_TOO_COMPLEX` for modules)
4. During script loading, deserialization and verification consume excessive memory/CPU
5. Multiple such scripts submitted concurrently can slow down or crash validator nodes

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria due to **validator node slowdowns**. The vulnerability enables:

- **Resource exhaustion attacks**: Scripts with unbounded complexity can consume excessive CPU and memory during loading, verification, and execution
- **DoS vector**: Multiple complex scripts can overwhelm validator nodes, degrading network performance
- **Consensus impact**: If validators slow down processing scripts, block production and consensus rounds may be delayed
- **Asymmetric security control**: The inconsistency between module and script checking indicates a clear security gap in the implementation

While not causing direct loss of funds or consensus safety violations, this breaks the "Resource Limits" invariant and enables attacks on network availability.

## Likelihood Explanation

**Likelihood: HIGH**

- Scripts are fully supported in Aptos (not deprecated or disabled)
- Any user can submit script transactions without special privileges
- The attack requires only crafting a script with complex type signatures, which is straightforward
- No validator collusion or special access is required
- The vulnerability is deterministic - scripts always bypass the complexity check
- The code path is clear: script execution never calls `check_script_complexity`

## Recommendation

Add complexity budget checking for scripts in the `validate_and_execute_script` function, mirroring the module checking implementation:

```rust
fn validate_and_execute_script<'a>(
    &self,
    session: &mut SessionExt<impl AptosMoveResolver>,
    serialized_signers: &SerializedSigners,
    code_storage: &impl AptosCodeStorage,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext<'a>,
    serialized_script: &'a Script,
    trace_recorder: &mut impl TraceRecorder,
) -> Result<(), VMStatus> {
    // Existing feature flag checks...
    
    dispatch_loader!(code_storage, loader, {
        // NEW: Add complexity check for scripts
        let budget = 2048 + serialized_script.code().len() as u64 * 20;
        let compiled_script = CompiledScript::deserialize_with_config(
            serialized_script.code(),
            &loader.vm_config().deserializer_config,
        )?;
        move_binary_format::check_complexity::check_script_complexity(&compiled_script, budget)
            .map_err(|err| err.finish(Location::Script))?;
        
        // Continue with existing script loading...
        let func = loader.load_script(
            &legacy_loader_config,
            gas_meter,
            traversal_context,
            serialized_script.code(),
            serialized_script.ty_args(),
        )?;
        // ... rest of the function
    })
}
```

This ensures scripts undergo the same complexity validation as modules before execution.

## Proof of Concept

```rust
// File: script_complexity_bypass_test.rs
use move_binary_format::{
    file_format::{
        Bytecode, CodeUnit, CompiledScript, FunctionHandle, FunctionHandleIndex,
        IdentifierIndex, ModuleHandle, ModuleHandleIndex, Signature, SignatureIndex,
        SignatureToken, Visibility,
    },
    CompiledModule,
};
use move_binary_format::check_complexity::{check_script_complexity, check_module_complexity};

#[test]
fn test_script_complexity_not_enforced() {
    // Create a script with deeply nested type signatures that would exceed budget
    let mut script = CompiledScript {
        version: 6,
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        self_module_handle_idx: ModuleHandleIndex(0),
        identifiers: vec![
            Identifier::new("test").unwrap(),
            Identifier::new("main").unwrap(),
        ],
        address_identifiers: vec![AccountAddress::ZERO],
        function_handles: vec![FunctionHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),
            parameters: SignatureIndex(0),
            return_: SignatureIndex(1),
            type_parameters: vec![],
            access_specifiers: None,
        }],
        signatures: vec![
            Signature(vec![]), // empty params
            Signature(vec![]), // empty return
            // Create extremely complex nested type signature
            Signature(vec![create_deeply_nested_type(50)]), // 50 levels deep
        ],
        constant_pool: vec![],
        metadata: vec![],
        code: CodeUnit {
            locals: SignatureIndex(2), // Use complex signature for locals
            code: vec![Bytecode::Ret],
        },
        type_parameters: vec![],
        parameters: SignatureIndex(0),
    };

    // Test that module would be rejected
    let module_budget = 2048 + 100 * 20; // Similar budget
    // This would fail for a module with check_module_complexity
    
    // But scripts are never checked, so this passes silently in production
    // The vulnerability: check_script_complexity is never called!
}

fn create_deeply_nested_type(depth: usize) -> SignatureToken {
    let mut ty = SignatureToken::Bool;
    for _ in 0..depth {
        ty = SignatureToken::Vector(Box::new(ty));
    }
    ty
}
```

This PoC demonstrates that scripts with arbitrarily complex type signatures can be constructed and would bypass complexity checking, while equivalent modules would be rejected.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L909-920)
```rust
            let func = loader.load_script(
                &legacy_loader_config,
                gas_meter,
                traversal_context,
                serialized_script.code(),
                serialized_script.ty_args(),
            )?;

            // Check that unstable bytecode cannot be executed on mainnet and verify events.
            let script = func.owner_as_script()?;
            self.reject_unstable_bytecode_for_script(script)?;
            event_validation::verify_no_event_emission_in_compiled_script(script)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L422-438)
```rust
pub fn check_script_complexity(script: &CompiledScript, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Script(script),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_code(&script.code)?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L189-211)
```rust
pub fn verify_script_with_config(config: &VerifierConfig, script: &CompiledScript) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_script(script).map_err(|e| {
            // We can't point the error at the script, because if bounds-checking
            // failed, we cannot safely index into script
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_script(config, script)?;
        LimitsVerifier::verify_script(config, script)?;
        DuplicationChecker::verify_script(script)?;

        signature_v2::verify_script(config, script)?;

        InstructionConsistency::verify_script(script)?;
        constants::verify_script(script)?;
        CodeUnitVerifier::verify_script(config, script)?;
        script_signature::verify_script(script, no_additional_script_signature_checks)
    })
```
