# Audit Report

## Title
Missing Audit Logging for Private Key Export Operations Enables Silent Key Exfiltration

## Summary
The `export_private_key()` and `export_private_key_for_version()` functions in Aptos secure storage implementations lack audit logging, allowing attackers with storage access to silently exfiltrate cryptographic keys without creating a detectable audit trail.

## Finding Description
The secure storage system in Aptos manages critical cryptographic keys including validator consensus keys, network identity keys, and other sensitive key material. The `CryptoStorage` trait provides an `export_private_key()` interface to retrieve private keys from secure storage.

**Vulnerable Code Locations:**

1. **VaultStorage implementation** - No logging before or after key export: [1](#0-0) 

2. **Vault client implementation** - Makes HTTP request to export endpoint without logging: [2](#0-1) 

3. **CryptoKVStorage implementation** - Generic key-value storage with no export logging: [3](#0-2) 

4. **SecurityEvent enum** - No event defined for private key operations: [4](#0-3) 

**Attack Scenario:**

An attacker who gains access to a validator node process (through supply chain attack, insider threat, or compromised dependency) can call `storage.export_private_key(key_name)` to retrieve validator keys without generating any audit trail in the Aptos application logs. The keys can then be exfiltrated for use in:
- Consensus message forgery
- Network identity impersonation  
- Unauthorized transaction signing

**Production Usage:** [5](#0-4) 

This shows legitimate usage during node initialization, but any compromised component with storage access could similarly export keys without detection.

## Impact Explanation
This qualifies as **Medium severity** per the Aptos bug bounty criteria for the following reasons:

1. **Limited Detection Capability**: Without audit logs, operators cannot detect when keys are being accessed inappropriately, making incident response and forensic analysis difficult.

2. **State Inconsistencies**: While not directly causing state corruption, undetected key compromise can lead to Byzantine validator behavior that requires manual intervention to resolve.

3. **Defense-in-Depth Failure**: This represents a gap in security monitoring that violates security best practices for sensitive cryptographic material handling.

Note: While HashiCorp Vault provides server-side audit logging capabilities, this is:
- Not enforced or verified by Aptos code
- Not documented as a required configuration
- Not available for InMemory/OnDisk backends used in some deployments

## Likelihood Explanation
**Likelihood: Medium**

This issue can be exploited when:
- An attacker compromises a process with storage access (e.g., validator node, key management service)
- A malicious insider has legitimate access to storage APIs
- A supply chain attack introduces malicious code with storage access
- A configuration error grants excessive permissions to a vulnerable component

The lack of logging makes such attacks undetectable through normal monitoring channels, increasing the likelihood that a compromise could persist unnoticed.

## Recommendation

Add comprehensive audit logging for all private key export operations:

```rust
// In secure/storage/src/vault.rs
fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
    use aptos_logger::prelude::*;
    
    // Log the export attempt
    security_log!(
        SecurityEvent::PrivateKeyExport,
        key_name = name,
        timestamp = chrono::Utc::now().to_rfc3339()
    );
    
    let name = self.crypto_name(name);
    let result = self.client().export_ed25519_key(&name, None);
    
    // Log the result
    match &result {
        Ok(_) => info!("Private key exported successfully: {}", name),
        Err(e) => error!("Private key export failed: {} - {:?}", name, e),
    }
    
    result
}
```

**Additional Recommendations:**

1. Add `PrivateKeyExport` and `PrivateKeyExportFailed` to the SecurityEvent enum
2. Implement similar logging for `export_private_key_for_version()`
3. Add metrics/counters for key export operations
4. Document requirement for Vault audit logging in deployment guides
5. Consider rate limiting or additional authentication for export operations
6. Add alerting on unexpected key export patterns

## Proof of Concept

```rust
// Reproduction: Demonstrates silent key export without audit logs
use aptos_secure_storage::{Storage, CryptoStorage, InMemoryStorage};
use aptos_crypto::ed25519::Ed25519PrivateKey;

#[test]
fn test_unlogged_key_export() {
    // Initialize storage
    let mut storage = Storage::from(InMemoryStorage::new());
    
    // Create a key (this simulates a validator key)
    let key_name = "consensus_key";
    storage.create_key(key_name).unwrap();
    
    // Export the private key - NO AUDIT LOG IS GENERATED
    let exported_key: Ed25519PrivateKey = storage.export_private_key(key_name).unwrap();
    
    // An attacker could now exfiltrate this key
    println!("Silently exported key: {:?}", exported_key);
    
    // Search application logs - no export event will be found
    // This demonstrates the lack of audit trail
}
```

**To observe the vulnerability:**
1. Run any component that uses secure storage
2. Call `export_private_key()` through any code path
3. Search application logs for key export events
4. Observe: No security event or audit log entry exists

This confirms private keys can be exported without creating a detectable audit trail, violating security monitoring best practices for sensitive cryptographic material.

### Citations

**File:** secure/storage/src/vault.rs (L206-209)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        let name = self.crypto_name(name);
        Ok(self.client().export_ed25519_key(&name, None)?)
    }
```

**File:** secure/storage/vault/src/lib.rs (L293-305)
```rust
    pub fn export_ed25519_key(
        &self,
        name: &str,
        version: Option<u32>,
    ) -> Result<Ed25519PrivateKey, Error> {
        let request = self.agent.get(&format!(
            "{}/v1/transit/export/signing-key/{}",
            self.host, name
        ));
        let resp = self.upgrade_request(request).call();

        process_transit_export_response(name, version, resp)
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L26-28)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        self.get(name).map(|v| v.value)
    }
```

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```

**File:** config/src/config/network_config.rs (L187-206)
```rust
    pub fn identity_key(&self) -> x25519::PrivateKey {
        let key = match &self.identity {
            Identity::FromConfig(config) => Some(config.key.private_key()),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let key = storage
                    .export_private_key(&config.key_name)
                    .expect("Unable to read key");
                let key = x25519::PrivateKey::from_ed25519_private_bytes(&key.to_bytes())
                    .expect("Unable to convert key");
                Some(key)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();
                Some(identity_blob.network_private_key)
            },
            Identity::None => None,
        };
        key.expect("identity key should be present")
    }
```
