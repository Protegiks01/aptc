# Audit Report

## Title
Unbounded Memory Growth in ConsensusNotificationListener Due to Missing Backpressure Mechanism

## Summary
The `ConsensusNotificationListener` uses an unbounded mpsc channel to receive consensus notifications, allowing unlimited memory growth if the listener stops being polled while consensus continues sending notifications. This design flaw violates the Resource Limits invariant and reduces validator node resilience.

## Finding Description

The consensus notification system uses an unbounded channel that lacks backpressure mechanisms, creating a critical resource exhaustion vulnerability. [1](#0-0) 

The channel is created as unbounded with no capacity limits: [2](#0-1) 

Each notification can contain large data structures - vectors of transactions and events from entire committed blocks: [3](#0-2) 

The listener is polled in the state sync driver's event loop: [4](#0-3) 

**The vulnerability manifests when:**
1. The state sync driver hangs, deadlocks, or encounters a blocking operation in any branch of the futures::select! loop
2. Consensus continues committing blocks (operating independently)
3. Each block generates a `ConsensusCommitNotification` sent via the unbounded channel
4. Notifications accumulate indefinitely with no backpressure or capacity limit
5. Memory grows linearly with block commits until OOM crash

**Critical design inconsistency:** The mempool notification system correctly uses a **bounded** channel: [5](#0-4) 

The configuration includes `max_pending_mempool_notifications` (default 100): [6](#0-5) 

However, **no equivalent bound exists for consensus notifications**, demonstrating that bounded channels are the expected pattern but were not applied consistently.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Crashes**: At Aptos's high throughput (~300 blocks/minute with 0.2s block time), each block notification containing thousands of transactions can consume megabytes of memory. If the driver hangs for even a few minutes, hundreds of MB to GB accumulate, leading to OOM crashes.

2. **Resource Limits Invariant Violation**: Breaks Invariant #9: "All operations must respect gas, storage, and computational limits." The unbounded channel violates memory resource limits.

3. **Reduced System Resilience**: Converts any transient driver issue (deadlock, temporary hang, long-running operation) into a permanent validator failure requiring manual intervention and restart.

4. **Availability Impact**: Validator crashes reduce network liveness and consensus participation, though not catastrophically (requires >1/3 validators affected).

This is not Critical severity because it requires a secondary condition (driver hang) to trigger, and does not directly cause fund loss or consensus safety violations.

## Likelihood Explanation

**Moderate likelihood** for the following reasons:

1. **Trigger Conditions**: Requires the state sync driver to stop polling while consensus continues. This can occur through:
   - Deadlocks in storage access paths
   - Blocking operations in other event handlers
   - Panics in concurrent tasks that block the event loop
   - Resource exhaustion in storage subsystem

2. **High Transaction Volume**: Aptos's high throughput (5,000+ TPS) means each block contains substantial data, accelerating memory growth when the vulnerability triggers.

3. **Production Occurrences**: Any production bug causing driver hangs will be amplified into node crashes by this design flaw.

4. **No Monitoring**: The unbounded channel provides no metrics or alerts for queue depth, making detection difficult until OOM occurs.

## Recommendation

Replace the unbounded channel with a bounded channel and implement proper backpressure handling, consistent with the mempool notification pattern:

**Configuration Change** - Add to `StateSyncDriverConfig`: [7](#0-6) 

Add a new field:
```rust
/// The maximum number of pending consensus commit notifications
pub max_pending_consensus_notifications: u64,
```

With default value in the impl:
```rust
max_pending_consensus_notifications: 100, // Same as mempool
```

**Code Change** - Modify channel creation: [8](#0-7) 

Replace with:
```rust
pub fn new_consensus_notifier_listener_pair(
    max_pending_notifications: u64,
    timeout_ms: u64,
) -> (ConsensusNotifier, ConsensusNotificationListener) {
    let (notification_sender, notification_receiver) = 
        mpsc::channel(max_pending_notifications as usize);
    
    let consensus_notifier = ConsensusNotifier::new(notification_sender, timeout_ms);
    let consensus_listener = ConsensusNotificationListener::new(notification_receiver);
    
    (consensus_notifier, consensus_listener)
}
```

**Sender Type Change**: [9](#0-8) 

Change `mpsc::UnboundedSender` to `mpsc::Sender` and handle backpressure in send operations.

## Proof of Concept

```rust
use futures::channel::mpsc;
use futures::StreamExt;
use std::time::Duration;
use tokio::time::sleep;

#[tokio::test]
async fn test_unbounded_consensus_notification_memory_leak() {
    // Simulate the current unbounded channel design
    let (mut sender, mut receiver) = mpsc::unbounded::<Vec<u8>>();
    
    // Simulate state sync driver that stops polling (never polls receiver)
    let sender_task = tokio::spawn(async move {
        // Simulate consensus sending 1000 block notifications
        for i in 0..1000 {
            // Each "block" is 1MB of transaction data
            let large_notification = vec![0u8; 1024 * 1024];
            sender.send(large_notification).await.unwrap();
            
            if i % 100 == 0 {
                println!("Sent {} notifications, memory growing unbounded", i);
            }
            sleep(Duration::from_millis(1)).await;
        }
    });
    
    // Driver never polls - simulating a hang/deadlock
    sleep(Duration::from_secs(5)).await;
    
    // At this point, ~1GB is queued in memory with no bound
    // In production, this continues until OOM
    
    sender_task.await.unwrap();
    
    // The receiver still holds all 1000 notifications
    let mut count = 0;
    while receiver.next().await.is_some() {
        count += 1;
    }
    assert_eq!(count, 1000, "All notifications accumulated in memory");
}
```

**Notes**

This vulnerability demonstrates a critical system design flaw where unbounded channels create fragility. While the immediate trigger requires a secondary condition (driver hang), the root cause is the **absence of resource limits** on a critical communication channel. The fix is straightforward: apply the same bounded channel pattern already used successfully for mempool notifications. This change would transform potential node crashes into graceful backpressure and error handling, significantly improving validator resilience.

### Citations

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L57-68)
```rust
/// This method returns a (ConsensusNotifier, ConsensusNotificationListener) pair that
/// can be used to allow consensus, or consensus observer, to communicate with state sync.
pub fn new_consensus_notifier_listener_pair(
    timeout_ms: u64,
) -> (ConsensusNotifier, ConsensusNotificationListener) {
    let (notification_sender, notification_receiver) = mpsc::unbounded();

    let consensus_notifier = ConsensusNotifier::new(notification_sender, timeout_ms);
    let consensus_listener = ConsensusNotificationListener::new(notification_receiver);

    (consensus_notifier, consensus_listener)
}
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L71-77)
```rust
#[derive(Clone, Debug)]
pub struct ConsensusNotifier {
    notification_sender: mpsc::UnboundedSender<ConsensusNotification>,

    /// Timeout for state sync to respond when handling a commit notification
    commit_timeout_ms: u64,
}
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L211-221)
```rust
#[derive(Debug)]
pub struct ConsensusNotificationListener {
    notification_receiver: mpsc::UnboundedReceiver<ConsensusNotification>,
}

impl ConsensusNotificationListener {
    fn new(notification_receiver: mpsc::UnboundedReceiver<ConsensusNotification>) -> Self {
        ConsensusNotificationListener {
            notification_receiver,
        }
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L293-324)
```rust
#[derive(Debug)]
pub struct ConsensusCommitNotification {
    transactions: Vec<Transaction>,
    subscribable_events: Vec<ContractEvent>,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}

impl ConsensusCommitNotification {
    pub fn new(
        transactions: Vec<Transaction>,
        subscribable_events: Vec<ContractEvent>,
    ) -> (Self, oneshot::Receiver<ConsensusNotificationResponse>) {
        let (callback, callback_receiver) = oneshot::channel();
        let commit_notification = ConsensusCommitNotification {
            transactions,
            subscribable_events,
            callback,
        };

        (commit_notification, callback_receiver)
    }

    /// Returns a reference to the transactions
    pub fn get_transactions(&self) -> &Vec<Transaction> {
        &self.transactions
    }

    /// Returns a reference to the subscribable events
    pub fn get_subscribable_events(&self) -> &Vec<ContractEvent> {
        &self.subscribable_events
    }
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L222-239)
```rust
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L49-59)
```rust
pub fn new_mempool_notifier_listener_pair(
    max_pending_mempool_notifications: u64,
) -> (MempoolNotifier, MempoolNotificationListener) {
    let (notification_sender, notification_receiver) =
        mpsc::channel(max_pending_mempool_notifications as usize);

    let mempool_notifier = MempoolNotifier::new(notification_sender);
    let mempool_listener = MempoolNotificationListener::new(notification_receiver);

    (mempool_notifier, mempool_listener)
}
```

**File:** config/src/config/state_sync_config.rs (L103-147)
```rust
pub struct StateSyncDriverConfig {
    /// The mode by which to bootstrap
    pub bootstrapping_mode: BootstrappingMode,
    /// The maximum time taken to process a commit notification
    pub commit_notification_timeout_ms: u64,
    /// The mode by which to sync after bootstrapping
    pub continuous_syncing_mode: ContinuousSyncingMode,
    /// Enable auto-bootstrapping if no peers are found after `max_connection_deadline_secs`
    pub enable_auto_bootstrapping: bool,
    /// The interval (ms) to refresh the storage summary
    pub fallback_to_output_syncing_secs: u64,
    /// The interval (ms) at which to check state sync progress
    pub progress_check_interval_ms: u64,
    /// The maximum time (secs) to wait for connections from peers before auto-bootstrapping
    pub max_connection_deadline_secs: u64,
    /// The maximum number of notifications to process per driver loop
    pub max_consecutive_stream_notifications: u64,
    /// The maximum number of stream timeouts allowed before termination
    pub max_num_stream_timeouts: u64,
    /// The maximum number of data chunks pending execution or commit
    pub max_pending_data_chunks: u64,
    /// The maximum number of pending mempool commit notifications
    pub max_pending_mempool_notifications: u64,
    /// The maximum time (ms) to wait for a data stream notification
    pub max_stream_wait_time_ms: u64,
    /// The version lag we'll tolerate before snapshot syncing
    pub num_versions_to_skip_snapshot_sync: u64,
}

/// The default state sync driver config will be the one that gets (and keeps)
/// the node up-to-date as quickly and cheaply as possible.
impl Default for StateSyncDriverConfig {
    fn default() -> Self {
        Self {
            bootstrapping_mode: BootstrappingMode::ExecuteOrApplyFromGenesis,
            commit_notification_timeout_ms: 5000,
            continuous_syncing_mode: ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs,
            enable_auto_bootstrapping: false,
            fallback_to_output_syncing_secs: 180, // 3 minutes
            progress_check_interval_ms: 100,
            max_connection_deadline_secs: 10,
            max_consecutive_stream_notifications: 10,
            max_num_stream_timeouts: 12,
            max_pending_data_chunks: 50,
            max_pending_mempool_notifications: 100,
```
