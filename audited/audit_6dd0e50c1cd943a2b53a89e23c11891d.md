# Audit Report

## Title
OR Logic Filter Bypass in TransactionMatcher::AccountAddress Due to Overly Broad Address Matching

## Summary
The `TransactionMatcher::AccountAddress` implementation uses OR logic across five different address checks, allowing attackers to bypass operator-intended access controls by embedding a target address in unexpected transaction fields (script arguments, authenticators, or fee payer fields) rather than as the transaction sender.

## Finding Description

The transaction filtering system in the Aptos mempool allows node operators to create allowlists and denylists for transaction acceptance. The `TransactionMatcher::AccountAddress` variant is designed to match transactions involving a specific address. [1](#0-0) 

The implementation uses OR logic across five distinct checks:
1. **Sender address** - The transaction originator
2. **Entry function module address** - Module being called
3. **Multisig address** - Multisig account involved
4. **Script argument address** - Address passed as script parameter
5. **Transaction authenticator address** - Addresses in signatures (secondary signers, fee payer, FederatedKeyless jwk_addr)

This creates an exploitable bypass when operators intend to create sender-based allowlists but use `AccountAddress` matcher. An attacker can bypass the filter by embedding the whitelisted address in a controllable field like script arguments.

**Attack Scenario:**
1. Operator configures filter: `Allow(AccountAddress(0xWHITELISTED))`, `Deny(All)`
   - **Intended behavior**: Only allow transactions FROM address 0xWHITELISTED
   - **Operator's mistake**: Using `AccountAddress` instead of `Sender` matcher

2. Attacker from 0xATTACKER crafts a Script transaction with:
   ```
   sender = 0xATTACKER
   script_args = [TransactionArgument::Address(0xWHITELISTED)]
   ```

3. Filter evaluation in mempool: [2](#0-1) 
   
   The `matches_script_argument_address` check returns true [3](#0-2) , causing the entire OR expression to match.

4. Transaction is allowed into mempool despite being from unauthorized sender.

**Additional Attack Vectors:**

- **Fee Payer Bypass**: Attacker uses whitelisted address as fee payer while sending transaction from unauthorized account [4](#0-3) 

- **FederatedKeyless Spoofing**: Attacker crafts authenticator with `jwk_addr = 0xWHITELISTED` [5](#0-4)  (transaction will fail validation later, but filter bypass occurs first)

## Impact Explanation

**Severity: Medium**

This vulnerability allows unauthorized transactions to bypass node-level mempool filters, but has limited protocol-wide impact:

1. **Node-Level Impact**: Attackers can submit unauthorized transactions to nodes with misconfigured filters, potentially:
   - Consuming mempool resources on filtered nodes
   - Bypassing rate limits or access controls implemented via filters
   - Accessing premium/restricted node services without authorization

2. **No Consensus Impact**: The filter operates pre-consensus [6](#0-5) . Filtered transactions can still reach consensus via other nodes, so there's no protocol-level security breach.

3. **Configuration-Dependent**: Requires operators to use `AccountAddress` matcher when they intended sender-specific filtering. Operators who correctly use `Sender` matcher are unaffected.

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" - operators must reconfigure filters and potentially clear mempool to restore intended access controls.

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Attack Complexity**: Low - attacker only needs to craft a transaction with the target address in a controllable field (script args, fee payer, etc.)

2. **Operator Misconfiguration**: Moderately likely - the `AccountAddress` matcher's broad behavior is subtle. Operators wanting sender-based filtering might intuitively use `AccountAddress(sender)` without realizing it matches the address in any position.

3. **Documentation Gap**: The comment "Matches any transaction that involves a specific account address" [7](#0-6)  doesn't clearly warn about the OR logic bypass risk.

## Recommendation

**Solution 1: Documentation Enhancement** (Immediate)
Add clear warnings in comments and documentation that `AccountAddress` uses broad OR matching. Recommend operators use specific matchers:
- `Sender` for sender-only matching
- `ModuleAddress` for module-only matching
- Multiple matchers in a rule for AND logic

**Solution 2: Add Strict Matchers** (Preferred)
Introduce new matcher variants that only check specific positions:
```rust
pub enum TransactionMatcher {
    // ... existing variants ...
    
    /// Matches ONLY if the address is the transaction sender (strict)
    SenderOnly(AccountAddress),
    
    /// Matches ONLY if the address is in script arguments (strict)
    ScriptArgumentOnly(AccountAddress),
    
    /// Keep AccountAddress for backward compatibility but deprecate
    #[deprecated(note = "Use specific matchers like SenderOnly, ModuleAddressOnly for precise filtering")]
    AccountAddress(AccountAddress),
}
```

**Solution 3: Filter Validation Tool**
Provide a configuration validator that warns when `AccountAddress` is used in allowlist patterns that likely intend sender-specific matching.

## Proof of Concept

```rust
#[cfg(test)]
mod test_filter_bypass {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey};
    use aptos_types::{
        chain_id::ChainId,
        transaction::{RawTransaction, Script, SignedTransaction, TransactionPayload},
    };
    use move_core_types::{account_address::AccountAddress, transaction_argument::TransactionArgument};

    #[test]
    fn test_accountaddress_bypass_via_script_argument() {
        // Setup: Operator wants to allow only transactions FROM whitelisted address
        let whitelisted_address = AccountAddress::from_hex_literal("0xCAFE").unwrap();
        let attacker_address = AccountAddress::from_hex_literal("0xBAD").unwrap();
        
        // Operator mistakenly uses AccountAddress instead of Sender matcher
        let filter = TransactionFilter::new(vec![])
            .add_multiple_matchers_filter(true, vec![
                TransactionMatcher::AccountAddress(whitelisted_address)
            ])
            .add_all_filter(false); // Deny everything else
        
        // Attacker crafts transaction with whitelisted address in script args
        let script = Script::new(
            vec![],
            vec![],
            vec![TransactionArgument::Address(whitelisted_address)], // Embed whitelisted address
        );
        
        let raw_txn = RawTransaction::new(
            attacker_address, // Attacker is the sender
            0,
            TransactionPayload::Script(script),
            100000,
            1,
            10000,
            ChainId::test(),
        );
        
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let signed_txn = SignedTransaction::new(
            raw_txn.clone(),
            private_key.public_key(),
            private_key.sign(&raw_txn).unwrap(),
        );
        
        // VULNERABILITY: Transaction from ATTACKER is allowed because whitelisted 
        // address appears in script arguments
        assert!(filter.allows_transaction(&signed_txn), 
            "Filter bypass: Attacker transaction allowed despite being from unauthorized sender");
        
        // What operator SHOULD have done: Use Sender matcher
        let correct_filter = TransactionFilter::new(vec![])
            .add_sender_filter(true, whitelisted_address)
            .add_all_filter(false);
        
        assert!(!correct_filter.allows_transaction(&signed_txn),
            "Correct filter: Attacker transaction properly blocked");
    }
}
```

## Notes

While this is primarily a **configuration vulnerability** where operators misuse the `AccountAddress` matcher, the implementation's design creates a significant security pitfall. The broad OR logic contradicts the principle of least surprise - operators naturally expect address-based filtering to check the sender by default, not arbitrary address occurrences throughout the transaction structure.

The vulnerability has limited protocol impact since mempool filters are node-local and don't affect consensus. However, nodes relying on filters for access control, rate limiting, or service tiering are at risk of unauthorized access.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L177-177)
```rust
    AccountAddress(AccountAddress), // Matches any transaction that involves a specific account address
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L197-203)
```rust
            TransactionMatcher::AccountAddress(address) => {
                matches_sender_address(signed_transaction, address)
                    || matches_entry_function_module_address(signed_transaction, address)
                    || matches_multisig_address(signed_transaction, address)
                    || matches_script_argument_address(signed_transaction, address)
                    || matches_transaction_authenticator_address(signed_transaction, address)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L320-323)
```rust
        AnyPublicKey::FederatedKeyless { public_key } => {
            // Check if the public key's JWK address matches the given address
            public_key.jwk_addr == *address
        },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L450-485)
```rust
/// Returns true iff a script argument matches the given account address
fn matches_script_argument_address(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::EntryFunction(_)
        | TransactionPayload::Multisig(_)
        | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Script(script) => compare_script_argument_address(script, address),
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::EntryFunction(_) | TransactionExecutableRef::Empty => {
                    false
                },
                TransactionExecutableRef::Script(script) => {
                    compare_script_argument_address(script, address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::EntryFunction(_)
                    | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::Script(script) => {
                        compare_script_argument_address(script, address)
                    },
                }
            } else {
                false
            }
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L512-526)
```rust
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address,
            fee_payer_signer,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
                || fee_payer_address == address
                || matches_account_authenticator_address(fee_payer_signer, address)
        },
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```
