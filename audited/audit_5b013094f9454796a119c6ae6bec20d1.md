# Audit Report

## Title
Non-Deterministic JSON Serialization in UnsupportedJWK Causes JWK Consensus Failures

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization via `to_string()`, which can produce different byte representations when OIDC providers return JSON with varying key orderings. This causes different validators to compute different hashes for the same JWK, breaking multi-signature verification and preventing JWK updates from reaching consensus.

## Finding Description
When validators fetch JWKs from OIDC providers through the JWK consensus protocol, non-RSA keys are converted to `UnsupportedJWK` structures. The conversion process re-serializes the parsed JSON using `json_value.to_string()`: [1](#0-0) 

This implementation has a critical flaw: HTTP servers commonly use HashMaps internally and may return JSON object keys in non-deterministic order across different requests. When validators fetch JWKs at different times, they may receive identical semantic content but with different key orderings. After parsing with `serde_json`, the `to_string()` call preserves these different orderings, resulting in different `payload` byte arrays and different SHA3-256 hashes for the `id` field.

These `UnsupportedJWK` structures are embedded in `JWKMoveStruct` via the `Any` type's `data` field, which then get included in `ProviderJWKs` structures that validators must sign for consensus: [2](#0-1) 

The signing process uses BCS serialization with cryptographic hashing, which is deterministic only if the input data is identical: [3](#0-2) 

When validators sign `ProviderJWKs` containing `UnsupportedJWK` instances with different payloads, they produce signatures over different message hashes. During multi-signature verification in the validator transaction processing: [4](#0-3) 

The verification fails because validators signed different messages, preventing the JWK update from being applied on-chain.

**Attack Path:**
1. OIDC provider serves non-RSA JWKs (e.g., EC keys) or malformed RSA keys
2. Provider's HTTP server returns JSON with non-deterministic key ordering (common behavior)
3. Validator A fetches JWK, receives: `{"kty":"EC","kid":"key1","crv":"P-256",...}`
4. Validator B fetches JWK, receives: `{"kid":"key1","kty":"EC","crv":"P-256",...}`
5. Both parse and convert to `UnsupportedJWK` with different `payload` bytes
6. Both compute different SHA3-256 hashes for the `id` field
7. Both create `ProviderJWKs` with different serialized content
8. Multi-signature verification fails, update rejected

## Impact Explanation
This vulnerability breaks the **Deterministic Execution** invariant specifically for the JWK consensus subsystem. While it doesn't directly compromise blockchain consensus or fund safety, it prevents critical keyless account infrastructure from functioning correctly.

**Impact Classification: Medium Severity**

The vulnerability causes state inconsistencies requiring intervention:
- JWK updates for affected OIDC providers cannot reach consensus
- Keyless accounts depending on those providers may become inaccessible
- Users cannot authenticate or sign transactions with affected keyless accounts
- Manual intervention or provider reconfiguration required to restore functionality

This does not meet Critical severity because:
- Core blockchain consensus remains unaffected
- No direct fund theft or loss occurs
- Network remains available for non-keyless transactions

It exceeds Low severity because:
- Affects user access to funds through keyless accounts
- Requires operational intervention to resolve
- Impacts production keyless account functionality

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability can manifest without malicious intent:

1. **Common Server Behavior**: Many HTTP servers and JSON libraries use HashMaps that don't guarantee consistent key ordering across requests (e.g., Go's `encoding/json`, some Python JSON libraries)

2. **Legitimate OIDC Providers**: Major providers may rotate between EC and RSA keys, or use non-RSA algorithms like ES256 (ECDSA with P-256), triggering the `UnsupportedJWK` path

3. **No Attack Required**: Natural server behavior causes the issue - no attacker action needed

4. **Evidence in Code**: The TODO comment acknowledges this is a known limitation requiring canonical serialization

Factors reducing immediate likelihood:
- Most major OIDC providers (Google, Facebook) currently use RSA keys
- Issue only affects non-RSA or malformed keys
- Developers aware of the issue (TODO comment present)

## Recommendation
Implement canonical JSON serialization for `UnsupportedJWK` payloads. The fix should serialize JSON in a deterministic format with sorted keys and no whitespace:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Canonicalize by sorting keys and using compact representation
        let canonical_payload = canonicalize_json(&json_value);
        Self {
            id: HashValue::sha3_256_of(canonical_payload.as_slice()).to_vec(),
            payload: canonical_payload,
        }
    }
}

fn canonicalize_json(value: &serde_json::Value) -> Vec<u8> {
    // Serialize with sorted keys for determinism
    match value {
        serde_json::Value::Object(map) => {
            // Sort keys and recursively canonicalize values
            let mut sorted_keys: Vec<_> = map.keys().collect();
            sorted_keys.sort();
            let mut result = b"{".to_vec();
            for (i, key) in sorted_keys.iter().enumerate() {
                if i > 0 {
                    result.push(b',');
                }
                result.extend_from_slice(&serde_json::to_vec(key).unwrap());
                result.push(b':');
                result.extend_from_slice(&canonicalize_json(&map[*key]));
            }
            result.push(b'}');
            result
        }
        _ => serde_json::to_vec(value).unwrap(), // Primitives are already canonical
    }
}
```

Alternatively, use a canonical JSON library like `jcs` (JSON Canonicalization Scheme, RFC 8785) for standardized canonicalization.

## Proof of Concept
```rust
#[test]
fn test_unsupported_jwk_non_deterministic() {
    use serde_json::json;
    use aptos_types::jwks::unsupported::UnsupportedJWK;
    
    // Same semantic content, different key orderings
    let json1 = json!({
        "kty": "EC",
        "kid": "test-key",
        "crv": "P-256",
        "x": "xbase64data",
        "y": "ybase64data"
    });
    
    let json2 = json!({
        "kid": "test-key",
        "kty": "EC",
        "x": "xbase64data",
        "crv": "P-256",
        "y": "ybase64data"
    });
    
    let jwk1 = UnsupportedJWK::from(json1);
    let jwk2 = UnsupportedJWK::from(json2);
    
    // These should be equal but aren't due to different serialization
    assert_ne!(jwk1.payload, jwk2.payload, "Payloads differ due to key ordering");
    assert_ne!(jwk1.id, jwk2.id, "IDs differ due to different payload hashes");
    
    // This breaks consensus when validators get different orderings
    println!("JWK1 payload: {}", String::from_utf8_lossy(&jwk1.payload));
    println!("JWK2 payload: {}", String::from_utf8_lossy(&jwk2.payload));
}
```

**Notes:**
- The vulnerability is explicitly acknowledged in the code via the TODO comment but remains unaddressed
- Impact is limited to JWK consensus subsystem, not core blockchain consensus  
- Affects keyless account functionality which is critical for user experience
- Fix is straightforward: implement canonical JSON serialization with sorted keys

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
