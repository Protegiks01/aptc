# Audit Report

## Title
Attribute Typo Bypass: Test-Only Functions With Privileged Operations Can Be Included in Production Code

## Summary
The `SKIP_ATTRIBUTE_CHECKS` flag, when enabled during compilation, suppresses warnings about unknown attributes. This creates a scenario where developers who typo the `#[test_only]` attribute receive no warning, causing test functions with privileged operations (like mint capabilities) to be incorrectly included in production modules.

## Finding Description

The vulnerability exists in the interaction between attribute validation and test function filtering: [1](#0-0) 

The `skip_attribute_checks` field controls whether the compiler validates attributes during the expansion phase: [2](#0-1) 

When `skip_attribute_checks` is enabled, unknown attributes are silently marked as `Unknown` without warnings. The critical issue arises during test function filtering: [3](#0-2) 

The filtering logic uses `KnownAttribute::resolve()` to identify test attributes. If a developer typos `#[test_only]` as `#[test_onlyy]`, the attribute isn't recognized and the function is NOT filtered out.

**Attack Scenario:**
1. Developer compiles with `--skip-attribute-checks` enabled
2. Developer typos `#[test_only]` attribute (e.g., `#[test_onlyy]`, `#[tset_only]`)
3. Compiler doesn't warn about unknown attribute
4. Test filtering doesn't recognize typo'd attribute as test-only
5. Function remains in production code
6. Module is deployed with privileged test functions

Aptos Framework contains numerous test-only functions with privileged operations: [4](#0-3) 

These functions return mint/burn capabilities or perform privileged initialization that should NEVER exist in production.

## Impact Explanation

**Critical Severity** - This vulnerability can lead to:

1. **Unauthorized Minting**: Test-only functions that return `MintCapability` could allow arbitrary coin minting in production
2. **Access Control Bypass**: Test initialization functions that create system resources without proper authorization
3. **Invariant Violation**: Breaks the "Access Control: System addresses (@aptos_framework, @core_resources) must be protected" invariant

If exploited, an attacker who discovers a deployed module with exposed test-only mint functions could mint unlimited coins, causing:
- Direct theft of funds through inflation
- Destruction of the economic model
- Loss of user confidence

The protection mechanism (poison function) is only injected during test mode compilation: [5](#0-4) 

When compiling in normal mode with a typo'd attribute, no poison function is injected, allowing the module to deploy successfully.

## Likelihood Explanation

**Medium-Low Likelihood** due to required conditions:

1. Developer must explicitly enable `--skip-attribute-checks` (default is `false`)
2. Developer must make a typo in `#[test_only]` attribute
3. Developer must not notice the test function in production during code review
4. Module must pass all other validation checks

However, the severity of impact (unlimited minting) elevates this to a reportable vulnerability. The exposure of the `SKIP_ATTRIBUTE_CHECKS` constant actively encourages developers to disable safety checks, increasing the likelihood of this occurring.

## Recommendation

**Immediate Fix:**
1. Make `SKIP_ATTRIBUTE_CHECKS` a private/internal compiler flag, not exposed to package build configurations
2. Add explicit validation that fails compilation (not just warns) when test-only attributes are malformed in non-test mode
3. Enhance the filtering logic to detect near-matches to known attributes and error on them

**Code Fix for Attribute Validation:**

In `filter_test_members.rs`, add strict validation:

```rust
fn validate_test_attributes(attrs: &[P::Attributes]) -> Result<(), Diagnostic> {
    for attr in attrs.iter().flat_map(|a| &a.value) {
        let attr_name = attr.value.attribute_name().value;
        // Check for typos in test-only related attributes
        if is_similar_to_test_attribute(attr_name) 
           && KnownAttribute::resolve(attr_name).is_none() {
            return Err(diag!(
                Attributes::InvalidTest,
                (attr.loc, format!(
                    "Attribute '{}' looks like a typo of 'test_only' or 'test'. \
                     Test attributes must be spelled exactly correctly.",
                    attr_name
                ))
            ));
        }
    }
    Ok(())
}
```

**Long-term Fix:**
Remove `skip_attribute_checks` from user-facing build options entirely. It should only be available as an internal compiler development flag.

## Proof of Concept

Create a Move module with typo'd test_only attribute:

```move
module 0x1::vulnerable_coin {
    use std::signer;
    use aptos_framework::coin::{Self, MintCapability, BurnCapability};
    
    struct VulnerableCoin {}
    
    // Typo: should be #[test_only] but developer typed #[test_onlyy]
    #[test_onlyy]  
    public fun get_mint_capability_for_test(): MintCapability<VulnerableCoin> {
        let (burn_cap, mint_cap) = coin::initialize<VulnerableCoin>(
            &account::create_signer_for_test(@0x1),
            b"Vulnerable",
            b"VUL",
            8,
            false,
        );
        coin::destroy_burn_cap(burn_cap);
        mint_cap  // Returns mint capability in production!
    }
    
    public fun exploit(attacker: &signer) {
        // Attacker can call the test function in production
        let mint_cap = get_mint_capability_for_test();
        let coins = coin::mint(1000000000, &mint_cap);
        coin::deposit(signer::address_of(attacker), coins);
        coin::destroy_mint_cap(mint_cap);
    }
}
```

Compile with:
```bash
aptos move compile --skip-attribute-checks
```

The module will compile successfully with `get_mint_capability_for_test()` included, allowing `exploit()` to mint unlimited coins in production.

**Notes**

This vulnerability demonstrates that exposing `SKIP_ATTRIBUTE_CHECKS` as a user-facing option creates a dangerous footgun. While extended security checks (randomness validation, view function checks) still run regardless of this flag, the test-only filtering mechanism silently fails on typo'd attributes when warnings are suppressed. The combination of (1) exposed flag, (2) silent failure mode, and (3) critical privileged operations in test-only functions creates an unacceptable risk for production deployments.

### Citations

**File:** third_party/move/tools/move-package/src/lib.rs (L109-110)
```rust
    #[clap(long = SKIP_ATTRIBUTE_CHECKS, default_value = "false")]
    pub skip_attribute_checks: bool,
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs (L740-760)
```rust
            None => {
                let flags = &context.env.flags();
                if !flags.skip_attribute_checks() {
                    let known_attributes = &context.env.get_known_attributes();
                    if !is_nested && !known_attributes.contains(sym.as_str()) {
                        let msg = format!("Attribute name '{}' is unknown (use --{} CLI option to ignore); known attributes are '{:?}'.",
					                      sym.as_str(),
					                      SKIP_ATTRIBUTE_CHECKS, known_attributes);
                        context
                            .env
                            .add_diag(diag!(Declarations::UnknownAttribute, (nloc, msg)));
                    } else if is_nested && known_attributes.contains(sym.as_str()) {
                        let msg = format!(
                            "Attribute '{}' is not expected in a nested attribute position.",
                            sym.as_str()
                        );
                        context
                            .env
                            .add_diag(diag!(Declarations::InvalidAttribute, (nloc, msg)));
                    };
                }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L47-54)
```rust
        // instrument the test poison
        if !self.env.flags().is_testing() {
            return Some(module_def);
        }

        let poison_function = create_test_poison(module_def.loc);
        module_def.members.push(poison_function);
        Some(module_def)
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L237-249)
```rust
fn test_attributes(attrs: &P::Attributes) -> Vec<(Loc, known_attributes::TestingAttribute)> {
    use known_attributes::KnownAttribute;
    attrs
        .value
        .iter()
        .filter_map(
            |attr| match KnownAttribute::resolve(attr.value.attribute_name().value)? {
                KnownAttribute::Testing(test_attr) => Some((attr.loc, test_attr)),
                _ => None,
            },
        )
        .collect()
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L159-168)
```text
    #[test_only]
    public fun mint_apt_fa_for_test(amount: u64): FungibleAsset acquires MintCapStore {
        ensure_initialized_with_apt_fa_metadata_for_test();
        coin::coin_to_fungible_asset(
            coin::mint(
                amount,
                &borrow_global<MintCapStore>(@aptos_framework).mint_cap
            )
        )
    }
```
