# Audit Report

## Title
Rosetta API HTTP Status Code Specification Non-Compliance

## Summary
The Aptos Rosetta implementation returns HTTP 500 (INTERNAL_SERVER_ERROR) for all error responses instead of HTTP 200 as required by the Rosetta API specification, potentially causing client compatibility and operational issues.

## Finding Description

The `handle_request()` function violates the Rosetta API specification by returning HTTP 500 status codes for errors instead of HTTP 200. [1](#0-0) 

The error handler retrieves the status code from `ApiError::status_code()`, which always returns `INTERNAL_SERVER_ERROR`: [2](#0-1) 

According to the Rosetta API specification (referenced in the codebase): [3](#0-2) 

The specification requires that **all responses (both success and error) return HTTP 200**, with errors differentiated by the presence of an "error" field in the JSON response body, not by HTTP status codes.

The README acknowledges this non-standard behavior: [4](#0-3) 

## Impact Explanation

This specification violation has **Low severity** operational impacts:

1. **Client Compatibility**: Rosetta clients strictly following the specification expect HTTP 200 for all responses and may fail to properly handle HTTP 500 responses
2. **Infrastructure Issues**: Load balancers and proxies may treat HTTP 500 as backend health failures, potentially removing nodes from rotation or triggering circuit breakers
3. **Monitoring Systems**: HTTP 500 errors typically trigger critical alerts, causing false positives and alert fatigue
4. **Rosetta CLI Integration**: The official Rosetta CLI testing tool may not function correctly with non-compliant implementations
5. **Retry Behavior**: HTTP clients with automatic retry logic for 5xx errors may unnecessarily retry non-retriable errors

However, this does NOT constitute a security vulnerability affecting funds, consensus, or system integrity per the Aptos bug bounty criteria.

## Likelihood Explanation

This issue occurs on **every error response** from the Rosetta API. Any client interacting with the API will encounter HTTP 500 responses when errors occur, rather than the HTTP 200 responses mandated by the specification.

## Recommendation

Modify the `handle_request()` function to always return HTTP 200, following the Rosetta specification: [5](#0-4) 

**Fix**: Change line 88-91 to return `StatusCode::OK` instead of the error's status code. The `ApiError::status_code()` method can be removed or marked as deprecated since it should not be used for HTTP responses.

## Proof of Concept

This can be verified by making any request to a Rosetta endpoint that triggers an error (e.g., invalid network identifier):

```bash
curl -i -X POST http://localhost:8082/network/status \
  -H "Content-Type: application/json" \
  -d '{"network_identifier":{"blockchain":"invalid","network":"test"}}'
```

Expected (per Rosetta spec): `HTTP/1.1 200 OK` with error object in body  
Actual: `HTTP/1.1 500 Internal Server Error` with error object in body

---

## Notes

While this is a legitimate **specification compliance issue**, it does NOT meet the validation criteria for a security vulnerability because:
- It cannot be exploited by an attacker to compromise funds, consensus, or system integrity
- It does not break any Aptos Core security invariants
- It is a deliberate design choice documented in the README
- The impact is limited to client compatibility and operational concerns

This finding is reported as a Low severity protocol compliance issue affecting Rosetta ecosystem interoperability, not as an exploitable security vulnerability.

### Citations

**File:** crates/aptos-rosetta/src/common.rs (L76-98)
```rust
    move |request, options| {
        let fut = async move {
            match handler(request, options).await {
                Ok(response) => {
                    debug!("Response: {:?}", serde_json::to_string_pretty(&response));
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        warp::http::StatusCode::OK,
                    ))
                },
                Err(api_error) => {
                    debug!("Error: {:?}", api_error);
                    let status = api_error.status_code();
                    Ok(warp::reply::with_status(
                        warp::reply::json(&api_error.into_error()),
                        status,
                    ))
                },
            }
        };
        Box::pin(fut)
    }
}
```

**File:** crates/aptos-rosetta/src/error.rs (L164-167)
```rust
    /// All Rosetta errors must be 500s (and retriable tells you if it's actually retriable)
    pub fn status_code(&self) -> StatusCode {
        StatusCode::INTERNAL_SERVER_ERROR
    }
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L28-32)
```rust
/// Errors that can be returned by the API
///
/// Internally [`ApiError`] is used, but it is converted to this for on wire representation
///
/// [API Spec](https://www.rosetta-api.org/docs/models/Error.html)
```

**File:** crates/aptos-rosetta/README.md (L84-88)
```markdown
## Errors

All errors are 500s and have error codes that are static and must not change.  To add more errors,
add new codes and associated data.  The error details must not show in the network options call and
are all provided as Option<String> for that reason.
```
