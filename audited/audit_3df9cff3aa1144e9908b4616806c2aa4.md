# Audit Report

## Title
Integer Overflow in VMControlFlowGraph::num_blocks() Causes Verifier Panic via Out-of-Bounds Access in LoopSummary::new()

## Summary
A u16 integer overflow vulnerability exists in the Move bytecode verifier's control flow graph implementation. When bytecode contains exactly 65,536 basic blocks, `VMControlFlowGraph::num_blocks()` overflows from 65,536 to 0, causing `LoopSummary::new()` to allocate zero-sized vectors. Subsequent indexing operations trigger out-of-bounds panics, enabling a denial-of-service attack against validator nodes during bytecode verification.

## Finding Description

The vulnerability stems from an unsafe type cast in the control flow graph's block counting logic combined with the verification ordering. The attack path is:

**Step 1: Type System Weakness**

`BlockId` is defined as `CodeOffset`, which is a `u16`. This means instruction offsets range from 0 to 65,535: [1](#0-0) 

**Step 2: Overflow in num_blocks()**

The `VMControlFlowGraph::num_blocks()` function performs an unchecked cast from `usize` to `u16`: [2](#0-1) 

When the CFG contains exactly 65,536 blocks, `self.blocks.len()` equals 65,536, but casting to `u16` produces 0 due to wraparound (65,536 mod 65,536 = 0).

**Step 3: Zero-Sized Vector Allocation**

In `LoopSummary::new()`, this overflowed value is used to size internal vectors: [3](#0-2) 

With `num_blocks = 0`, all four vectors have zero capacity.

**Step 4: Immediate Panic on First Access**

The very next operations attempt to write to these zero-sized vectors: [4](#0-3) 

Accessing `blocks[usize::from(root_node)]` where `root_node = NodeId(0)` causes an immediate index-out-of-bounds panic on the zero-length vector.

**Step 5: Verification Ordering Bypass**

Critically, this panic occurs **before** the `max_basic_blocks` limit check: [5](#0-4) 

The call chain is:
1. `control_flow::verify_function()` (line 138) → creates FunctionView and calls `verify_reducibility()`
2. `verify_reducibility()` → calls `LoopSummary::new()` (panic occurs here)
3. `max_basic_blocks` check (line 147) → never reached [6](#0-5) 

**Attack Scenario:**

An attacker crafts malicious bytecode with 65,536 basic blocks (achievable by having 65,536 instructions where each one is either a branch or immediately follows a branch target). When submitted to the blockchain:

1. Bounds checking passes (all offsets < 65,536 are valid)
2. CFG construction succeeds, creating 65,536 blocks
3. `num_blocks()` overflows to 0
4. `LoopSummary::new()` panics on line 88
5. Validator node crashes during transaction verification
6. Block production halts if enough validators crash

This breaks the **Deterministic Execution** and **Resource Limits** invariants.

## Impact Explanation

**Severity: High** (meets "Validator node slowdowns" and "Significant protocol violations")

This vulnerability enables:

1. **Validator DoS**: Malicious actors can crash validator nodes by submitting specially crafted bytecode, causing verification panics
2. **Consensus Disruption**: If multiple validators crash simultaneously, block production may halt temporarily
3. **Non-Deterministic Behavior**: Different verifier configurations (e.g., `max_basic_blocks = None` vs `Some(1024)`) could cause some nodes to crash while others reject the transaction gracefully, creating network inconsistencies

While not meeting Critical severity (no fund loss, recoverable via restart), this constitutes a significant protocol violation and validator availability attack.

## Likelihood Explanation

**Likelihood: Medium-High**

Factors increasing likelihood:
- Overflow requires exactly 65,536 blocks (very specific but achievable)
- Bounds checker validates all branch targets, so carefully crafted bytecode passes initial validation
- Attack requires no privileged access—any transaction sender can submit malicious bytecode
- Production config sets `max_basic_blocks = Some(1024)`, but panic occurs **before** this check [7](#0-6) 

Factors decreasing likelihood:
- Crafting 65,536-block bytecode requires sophisticated tooling
- Module size limits may prevent such large bytecode in practice

## Recommendation

**Fix 1: Add Overflow Check in num_blocks()**

```rust
fn num_blocks(&self) -> u16 {
    let len = self.blocks.len();
    if len > u16::MAX as usize {
        panic!("Control flow graph has too many blocks: {}", len);
    }
    len as u16
}
```

**Fix 2: Check Limit Before CFG Construction**

Move the `max_basic_blocks` check earlier in the verification pipeline, immediately after CFG construction but before `verify_reducibility()`:

```rust
pub fn verify_function<'a>(...) -> PartialVMResult<FunctionView<'a>> {
    // ... existing code ...
    let function_view = FunctionView::function(module, index, code, function_handle);
    
    // Check max_basic_blocks BEFORE verify_reducibility
    if let Some(limit) = verifier_config.max_basic_blocks {
        if function_view.cfg().blocks().len() > limit {
            return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS)
                .at_code_offset(index, 0));
        }
    }
    
    verify_reducibility(verifier_config, &function_view)?;
    Ok(function_view)
}
```

**Fix 3: Use Checked Cast in LoopSummary**

```rust
let num_blocks = cfg.num_blocks() as usize;
// Add validation
if cfg.blocks().len() != num_blocks {
    return Err(PartialVMError::new(StatusCode::VERIFICATION_ERROR)
        .with_message("Block count overflow detected"));
}
```

## Proof of Concept

```rust
// Rust unit test demonstrating the vulnerability
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_loop_summary_overflow() {
    use move_binary_format::file_format::{Bytecode, CodeUnit};
    use move_binary_format::control_flow_graph::VMControlFlowGraph;
    use move_bytecode_verifier::loop_summary::LoopSummary;
    
    // Create bytecode with 65,536 instructions, each ending a basic block
    // Pattern: Branch(i+1) at each offset i, causing every instruction to end a block
    let mut code = Vec::new();
    for i in 0..65535 {
        code.push(Bytecode::Branch((i + 1) as u16));
    }
    code.push(Bytecode::Ret); // Final return
    
    // Build CFG - this will create 65,536 blocks
    let cfg = VMControlFlowGraph::new(&code);
    
    // Verify overflow: blocks.len() = 65536, but num_blocks() = 0
    assert_eq!(cfg.blocks().len(), 65536);
    assert_eq!(cfg.num_blocks(), 0); // Overflow!
    
    // This call will panic due to zero-sized vectors
    let _ = LoopSummary::new(&cfg); // PANIC: index 0 out of bounds for slice of length 0
}
```

## Notes

This vulnerability demonstrates a classic integer overflow pattern where narrowing casts (`usize → u16`) occur without validation. The issue is exacerbated by the verification ordering, where safety checks execute after the vulnerable code path. While production configurations provide partial mitigation through `max_basic_blocks`, the fundamental overflow remains exploitable under specific conditions and represents a critical code quality issue that should be addressed.

### Citations

**File:** third_party/move/move-binary-format/src/file_format.rs (L199-199)
```rust
pub type CodeOffset = u16;
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L324-326)
```rust
    fn num_blocks(&self) -> u16 {
        self.blocks.len() as u16
    }
```

**File:** third_party/move/move-bytecode-verifier/src/loop_summary.rs (L74-80)
```rust
        let num_blocks = cfg.num_blocks() as usize;

        // Fields in LoopSummary that are filled via a depth-first traversal of `cfg`.
        let mut blocks = vec![0; num_blocks];
        let mut descs = vec![0; num_blocks];
        let mut backs = vec![vec![]; num_blocks];
        let mut preds = vec![vec![]; num_blocks];
```

**File:** third_party/move/move-bytecode-verifier/src/loop_summary.rs (L85-88)
```rust
        let root_node = next_node.bump();

        let mut exploration = BTreeMap::new();
        blocks[usize::from(root_node)] = root_block;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L138-152)
```rust
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;

        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L126-127)
```rust
    let summary = LoopSummary::new(function_view.cfg());
    let mut partition = LoopPartition::new(&summary);
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L292-292)
```rust
            max_basic_blocks: Some(1024),
```
