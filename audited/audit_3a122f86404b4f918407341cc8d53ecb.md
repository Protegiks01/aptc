# Audit Report

## Title
Missing Configuration Validation Allows Zero Values in Indexer-gRPC Batch Parameters Causing Service Crash

## Summary
The `IndexerGrpcConfig` lacks validation for `processor_batch_size`, `output_batch_size`, and `processor_task_count` parameters, allowing zero values to be set in the configuration. When `output_batch_size` is set to zero, the indexer-grpc service crashes with a panic when attempting to chunk transactions. This violates defensive programming principles and causes API service unavailability.

## Finding Description

The indexer-grpc fullnode service reads batch size configuration parameters without validation. The `ServiceContext` struct accepts these values directly from the node configuration: [1](#0-0) 

The configuration is loaded in the runtime bootstrap function with no validation: [2](#0-1) 

The `IndexerGrpcConfig` struct defines default values but provides no validation in its `ConfigSanitizer` or `ConfigOptimizer` implementations: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

**Critical Code Path - The Panic:**

When `output_batch_size` is zero, the `process_next_batch` function in `IndexerStreamCoordinator` will panic when calling `.chunks(0)` on a slice: [7](#0-6) 

Rust's slice `.chunks()` method panics when called with a zero chunk size, causing the entire indexer-grpc service to crash.

**Additional Issues:**

When `processor_batch_size` is zero, the `get_batches` function creates batches that never advance the starting version, leading to resource waste: [8](#0-7) 

**Comparison with Similar Code:**

Other configuration modules in the codebase properly validate against zero values using a `default_if_zero` helper function: [9](#0-8) [10](#0-9) 

The `IndexerGrpcConfig` does not follow this defensive pattern.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: **"API crashes"**.

The indexer-grpc service provides critical infrastructure for:
- Block explorers and analytics platforms
- External indexing services
- Real-time transaction monitoring systems
- Developer tools and applications

A crash in this service disrupts the entire ecosystem's ability to query historical and real-time blockchain data. While this does not directly affect consensus or validator operations, it severely impacts the usability and observability of the Aptos network.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can manifest through:

1. **Configuration Errors**: Node operators may accidentally set zero values when modifying configurations
2. **Automated Deployments**: CI/CD pipelines or infrastructure-as-code tools could deploy invalid configurations
3. **Default Override Mistakes**: Users overriding defaults might not realize zero is invalid
4. **Malicious Configuration**: An attacker with configuration access could deliberately crash the service

The lack of validation means there is no safety net to catch these errors before runtime, and the failure mode (panic) is catastrophic rather than graceful.

## Recommendation

Implement validation for all batch size parameters in the `ConfigOptimizer` implementation, following the pattern established by `IndexerConfig`:

**Add validation in `config/src/config/indexer_grpc_config.rs`:**

```rust
impl ConfigOptimizer for IndexerGrpcConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let indexer_config = &mut node_config.indexer_grpc;
        // If the indexer is not enabled, there's nothing to do
        if !indexer_config.enabled {
            return Ok(false);
        }

        // Validate and set defaults for zero values
        if indexer_config.processor_batch_size == 0 {
            indexer_config.processor_batch_size = DEFAULT_PROCESSOR_BATCH_SIZE;
        }
        
        if indexer_config.output_batch_size == 0 {
            indexer_config.output_batch_size = DEFAULT_OUTPUT_BATCH_SIZE;
        }
        
        if let Some(task_count) = indexer_config.processor_task_count {
            if task_count == 0 {
                indexer_config.processor_task_count = Some(
                    get_default_processor_task_count(indexer_config.use_data_service_interface)
                );
            }
        }

        Ok(true)
    }
}
```

Alternatively, add validation in the `ConfigSanitizer` to fail fast with a clear error message:

```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        // Validate batch sizes are non-zero
        if node_config.indexer_grpc.processor_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_grpc.processor_batch_size must be greater than 0".to_string(),
            ));
        }
        
        if node_config.indexer_grpc.output_batch_size == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "indexer_grpc.output_batch_size must be greater than 0".to_string(),
            ));
        }

        // Existing validation...
        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
}
```

## Proof of Concept

**Minimal Reproduction:**

1. Create a node configuration file with `output_batch_size` set to 0:

```yaml
indexer_grpc:
  enabled: true
  processor_batch_size: 1000
  output_batch_size: 0  # Invalid value
  processor_task_count: 20
```

2. Start the indexer-grpc fullnode service with this configuration

3. When a client requests transactions via the gRPC stream API, the service will crash with:

```
thread 'tokio-runtime-worker' panicked at 'chunk size must be non-zero'
```

**Unit Test to Verify Fix:**

```rust
#[test]
fn test_sanitize_zero_batch_sizes() {
    // Test processor_batch_size = 0
    let mut node_config = NodeConfig {
        indexer_grpc: IndexerGrpcConfig {
            enabled: true,
            processor_batch_size: 0,
            ..Default::default()
        },
        storage: StorageConfig {
            enable_indexer: true,
            ..Default::default()
        },
        ..Default::default()
    };

    let error = IndexerGrpcConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    )
    .unwrap_err();
    assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

    // Test output_batch_size = 0
    node_config.indexer_grpc.processor_batch_size = DEFAULT_PROCESSOR_BATCH_SIZE;
    node_config.indexer_grpc.output_batch_size = 0;

    let error = IndexerGrpcConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    )
    .unwrap_err();
    assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
}
```

## Notes

While the indexer-grpc service is not part of the core consensus layer, it represents critical infrastructure for the Aptos ecosystem. The vulnerability demonstrates a defensive programming failure where invalid configurations are not caught during the sanitization or optimization phase, leading to runtime panics. The fix is straightforward and follows established patterns in the codebase for similar configuration validation.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/lib.rs (L14-22)
```rust
#[derive(Clone, Debug)]
pub struct ServiceContext {
    pub context: Arc<Context>,
    pub processor_task_count: u16,
    pub processor_batch_size: u16,
    pub output_batch_size: u16,
    pub transaction_channel_size: usize,
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L54-79)
```rust
    let processor_task_count = node_config
        .indexer_grpc
        .processor_task_count
        .unwrap_or_else(|| get_default_processor_task_count(use_data_service_interface));
    let processor_batch_size = node_config.indexer_grpc.processor_batch_size;
    let output_batch_size = node_config.indexer_grpc.output_batch_size;
    let transaction_channel_size = node_config.indexer_grpc.transaction_channel_size;
    let max_transaction_filter_size_bytes =
        node_config.indexer_grpc.max_transaction_filter_size_bytes;

    runtime.spawn(async move {
        let context = Arc::new(Context::new(
            chain_id,
            db,
            mp_sender,
            node_config,
            indexer_reader,
        ));
        let service_context = ServiceContext {
            context: context.clone(),
            processor_task_count,
            processor_batch_size,
            output_batch_size,
            transaction_channel_size,
            max_transaction_filter_size_bytes,
        };
```

**File:** config/src/config/indexer_grpc_config.rs (L31-59)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** config/src/config/indexer_grpc_config.rs (L85-101)
```rust
impl Default for IndexerGrpcConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            use_data_service_interface: false,
            address: SocketAddr::V4(SocketAddrV4::new(
                Ipv4Addr::new(0, 0, 0, 0),
                DEFAULT_GRPC_STREAM_PORT,
            )),
            processor_task_count: None,
            processor_batch_size: DEFAULT_PROCESSOR_BATCH_SIZE,
            output_batch_size: DEFAULT_OUTPUT_BATCH_SIZE,
            transaction_channel_size: DEFAULT_TRANSACTION_CHANNEL_SIZE,
            max_transaction_filter_size_bytes: DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES,
        }
    }
}
```

**File:** config/src/config/indexer_grpc_config.rs (L103-128)
```rust
impl ConfigSanitizer for IndexerGrpcConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if !node_config.indexer_grpc.enabled {
            return Ok(());
        }

        if !node_config.storage.enable_indexer
            && !node_config
                .indexer_table_info
                .table_info_service_mode
                .is_enabled()
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "storage.enable_indexer must be true or indexer_table_info.table_info_service_mode must be IndexingOnly if indexer_grpc.enabled is true".to_string(),
            ));
        }
        Ok(())
    }
}
```

**File:** config/src/config/indexer_grpc_config.rs (L130-145)
```rust
impl ConfigOptimizer for IndexerGrpcConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let indexer_config = &mut node_config.indexer_grpc;
        // If the indexer is not enabled, there's nothing to do
        if !indexer_config.enabled {
            return Ok(false);
        }

        Ok(true)
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L163-186)
```rust
        let output_batch_size = self.output_batch_size;
        let ledger_chain_id = self.context.chain_id().id();
        let filter = self.filter.clone();
        let mut tasks = vec![];
        for batch in task_batches {
            let context = self.context.clone();
            let filter = filter.clone();
            let task = tokio::task::spawn_blocking(move || {
                let raw_txns = batch;
                let api_txns = Self::convert_to_api_txns(context, raw_txns);
                let pb_txns = Self::convert_to_pb_txns(api_txns);
                // Apply filter if present.
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
                let mut responses = vec![];
                // Wrap in stream response object and send to channel
                for chunk in pb_txns.chunks(output_batch_size as usize) {
                    for chunk in chunk_transactions(chunk.to_vec(), MESSAGE_SIZE_LIMIT) {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L293-318)
```rust
    async fn get_batches(&mut self) -> Vec<TransactionBatchInfo> {
        if !self.ensure_highest_known_version().await {
            return vec![];
        }

        let mut starting_version = self.current_version;
        let mut num_fetches = 0;
        let mut batches = vec![];
        let end_version = std::cmp::min(self.end_version, self.highest_known_version + 1);

        while num_fetches < self.processor_task_count && starting_version < end_version {
            let num_transactions_to_fetch = std::cmp::min(
                self.processor_batch_size as u64,
                end_version - starting_version,
            ) as u16;

            batches.push(TransactionBatchInfo {
                start_version: starting_version,
                head_version: self.highest_known_version,
                num_transactions_to_fetch,
            });
            starting_version += num_transactions_to_fetch as u64;
            num_fetches += 1;
        }
        batches
    }
```

**File:** config/src/config/indexer_config.rs (L176-190)
```rust
        indexer_config.batch_size = default_if_zero(
            indexer_config.batch_size.map(|v| v as u64),
            DEFAULT_BATCH_SIZE as u64,
        )
        .map(|v| v as u16);
        indexer_config.fetch_tasks = default_if_zero(
            indexer_config.fetch_tasks.map(|v| v as u64),
            DEFAULT_FETCH_TASKS as u64,
        )
        .map(|v| v as u8);
        indexer_config.processor_tasks = default_if_zero(
            indexer_config.processor_tasks.map(|v| v as u64),
            DEFAULT_PROCESSOR_TASKS as u64,
        )
        .map(|value| value as u8);
```

**File:** config/src/config/indexer_config.rs (L202-209)
```rust
/// Returns the default if the value is 0, otherwise returns the value
fn default_if_zero(value: Option<u64>, default: u64) -> Option<u64> {
    match value {
        None => Some(default),
        Some(0) => Some(default),
        Some(value) => Some(value),
    }
}
```
