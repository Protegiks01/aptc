# Audit Report

## Title
Account Abstraction Authentication Bypass via State Modification in Prologue

## Summary
The `SystemSessionChangeSet` returned at line 78 of `prologue.rs` contains state changes from user-defined authentication functions that execute during prologue. These changes are committed even when transactions fail, allowing attackers to bypass authentication intent by embedding unauthorized state modifications within authentication logic, violating the invariant that authentication should only verify credentials, not modify blockchain state.

## Finding Description

When account abstraction is enabled, user-defined authentication functions execute during the transaction prologue phase. The critical vulnerability lies in the fact that these functions receive account signers and can make arbitrary state modifications, which are then persisted even when the main transaction fails.

**Attack Flow:**

1. **Authentication Function Registration**: Attacker registers a malicious authentication function for their account that performs both authentication AND unauthorized state modifications. [1](#0-0) 

2. **Prologue Execution**: During transaction validation, `validate_signed_transaction` calls `dispatchable_authenticate`, which executes the user-defined authentication function via `execute_function_bypass_visibility`. [2](#0-1) [3](#0-2) 

3. **State Changes During Authentication**: The authentication function receives a signer and can execute arbitrary Move code, making state modifications such as minting tokens, modifying balances, or altering permissions. [4](#0-3) 

4. **Change Set Extraction**: After prologue completes, `into_user_session()` finishes the prologue session and wraps all state changes (including malicious ones from authentication) into a `SystemSessionChangeSet`. [5](#0-4) 

5. **Transaction Failure Path**: Attacker crafts the transaction payload to fail during execution. When this occurs, `on_user_transaction_execution_failure` is called with the prologue change set. [6](#0-5) 

6. **State Commitment**: `finish_aborted_transaction` creates an `EpilogueSession` initialized with the prologue changes, which are then committed to the blockchain in the final `VMOutput`. [7](#0-6) [8](#0-7) 

The vulnerability exists because the prologue changes are passed through the entire failure path and respawned into the epilogue session, where they are squashed with epilogue changes and committed. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest severity tier under the Aptos Bug Bounty program because it enables:

1. **Loss of Funds (Theft/Minting)**: Attackers can mint tokens, transfer funds, or manipulate account balances through malicious authentication functions. The changes are committed even when the transaction "fails," allowing repeated exploitation.

2. **Consensus/Safety Violations**: If different validators have different gas feature versions or handle the prologue change sets differently, this could lead to state divergence and consensus failures, as validators would commit different state roots for the same transaction.

3. **Access Control Bypass**: The authentication mechanism is fundamentally compromised. Functions intended purely for credential verification can execute as system operations with full account privileges, violating the principle that authentication should be read-only verification.

This breaks **Critical Invariant #7** (Transaction Validation: Prologue/epilogue checks must enforce all invariants) and **Invariant #8** (Access Control: System addresses must be protected), as authentication functions can modify state indiscriminately.

## Likelihood Explanation

**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Low Technical Barrier**: Any user can register a malicious authentication function by calling the public entry function `add_authentication_function`. No special privileges are required.

2. **Account Abstraction Feature Enabled**: When account abstraction is active on the network, this attack vector becomes immediately available to all users. [11](#0-10) 

3. **Deterministic Exploitation**: The attack is deterministic - once the malicious authentication function is registered, any transaction using it will commit the prologue changes when the transaction fails.

4. **Gas-Metered but Exploitable**: While gas is metered for authentication functions, attackers can allocate sufficient gas budget to make substantial state changes while ensuring the main transaction still fails.

5. **No Runtime Detection**: There are no checks to verify that authentication functions only perform verification without state modifications.

## Recommendation

Implement strict isolation for authentication functions to prevent state modifications during prologue:

**Solution 1: Read-Only Authentication Context**
Create a read-only session for authentication functions that prevents any state writes:

```rust
// In aptos_vm.rs, modify dispatchable_authenticate
fn dispatchable_authenticate(
    session: &mut SessionExt<impl AptosMoveResolver>,
    gas_meter: &mut impl GasMeter,
    account: AccountAddress,
    function_info: FunctionInfo,
    auth_data: &AbstractAuthenticationData,
    traversal_context: &mut TraversalContext,
    module_storage: &impl ModuleStorage,
) -> VMResult<Vec<u8>> {
    // Create a temporary read-only session for authentication
    let temp_resolver = ReadOnlyResolver::new(session.resolver);
    let mut temp_session = SessionExt::new(&temp_resolver, ...);
    
    // Execute authentication in isolated session
    let result = temp_session.execute_function_bypass_visibility(...)?;
    
    // Verify no state changes occurred
    let change_set = temp_session.finish(...)?;
    if !change_set.is_empty() {
        return Err(VMError::new("Authentication functions must not modify state"));
    }
    
    Ok(result)
}
```

**Solution 2: Prologue Change Set Validation**
Add validation in `into_user_session` to reject any non-gas-related state changes from authentication:

```rust
// In prologue.rs, modify into_user_session
pub fn into_user_session(
    self,
    vm: &AptosVM,
    txn_meta: &TransactionMetadata,
    resolver: &'r impl AptosMoveResolver,
    change_set_configs: &ChangeSetConfigs,
    module_storage: &impl AptosModuleStorage,
) -> Result<(SystemSessionChangeSet, UserSession<'r>), VMStatus> {
    let change_set = session.finish_with_squashed_change_set(
        change_set_configs,
        module_storage,
        false,
    )?;
    
    // Validate that only gas-related changes exist
    if contains_non_gas_changes(&change_set) {
        return Err(VMStatus::error(
            StatusCode::INVALID_AUTH_FUNCTION_STATE_CHANGE,
            Some("Authentication functions must not modify account state".to_string())
        ));
    }
    
    // ... rest of function
}
```

**Solution 3: Separate Authentication-Only Gas Accounting**
Track authentication-related state changes separately and discard them in the failure path, only preserving gas accounting changes.

## Proof of Concept

```move
// Malicious authentication function (deployed by attacker)
module attacker::malicious_auth {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    // This function authenticates AND steals funds
    public fun authenticate(
        account: signer,
        _auth_data: vector<u8>
    ): signer {
        let account_addr = signer::address_of(&account);
        
        // Perform authentication (simplified)
        // ... authentication logic here ...
        
        // MALICIOUS: Mint coins or transfer to attacker
        // This executes during prologue with full signer privileges
        let attacker_addr = @attacker;
        coin::transfer<AptosCoin>(&account, attacker_addr, 1000000);
        
        // Return the signer to pass validation
        account
    }
}

// Attack transaction (Rust pseudo-code)
// 1. Register malicious_auth::authenticate for victim account
// 2. Submit transaction with abstract authentication using malicious_auth::authenticate  
// 3. Transaction payload: call a function that will abort
// 4. Prologue succeeds: authenticate() runs and transfers coins
// 5. Main execution fails: payload aborts as planned
// 6. System commits prologue changes including the coin transfer
// 7. Attacker receives stolen coins despite "failed" transaction
```

**Exploitation Steps:**
1. Attacker calls `account_abstraction::add_authentication_function` to register `malicious_auth::authenticate`
2. Attacker submits a transaction with `AbstractAuthenticationData` pointing to the malicious function
3. Transaction payload is crafted to fail (e.g., calls a function that aborts with a known error)
4. During prologue, `malicious_auth::authenticate` executes and makes unauthorized state changes
5. Main execution fails as planned
6. `finish_aborted_transaction` commits the prologue changes
7. Malicious state modifications are permanently recorded on-chain despite the "failed" transaction
8. Attacker can repeat this attack unlimited times until funds are drained

This vulnerability fundamentally breaks the trust model of account abstraction, as authentication functions are granted unrestricted state modification capabilities during a privileged execution phase whose changes persist even through transaction failures.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L122-135)
```text
    entry fun add_authentication_function(
        account: &signer,
        module_address: address,
        module_name: String,
        function_name: String,
    ) acquires DispatchableAuthenticator {
        assert!(features::is_account_abstraction_enabled(), error::invalid_state(EACCOUNT_ABSTRACTION_NOT_ENABLED));
        assert!(!is_permissioned_signer(account), error::permission_denied(ENOT_MASTER_SIGNER));
        update_dispatchable_authenticator_impl(
            account,
            function_info::new_function_info_from_address(module_address, module_name, function_name),
            true
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L274-302)
```text
    fun authenticate(
        account: signer,
        func_info: FunctionInfo,
        signing_data: AbstractionAuthData,
    ): signer acquires DispatchableAuthenticator, DerivableDispatchableAuthenticator {
        let master_signer_addr = signer::address_of(&account);

        if (signing_data.is_derivable()) {
            assert!(features::is_derivable_account_abstraction_enabled(), error::invalid_state(EDERIVABLE_ACCOUNT_ABSTRACTION_NOT_ENABLED));
            assert!(master_signer_addr == derive_account_address(func_info, signing_data.derivable_abstract_public_key()), error::invalid_state(EINCONSISTENT_SIGNER_ADDRESS));

            let func_infos = dispatchable_derivable_authenticator_internal();
            assert!(func_infos.contains(&func_info), error::not_found(EFUNCTION_INFO_EXISTENCE));
        } else {
            assert!(features::is_account_abstraction_enabled(), error::invalid_state(EACCOUNT_ABSTRACTION_NOT_ENABLED));

            let func_infos = dispatchable_authenticator_internal(master_signer_addr);
            assert!(func_infos.contains(&func_info), error::not_found(EFUNCTION_INFO_EXISTENCE));
        };

        function_info::load_module_from_function(&func_info);
        let returned_signer = dispatchable_authenticate(account, signing_data, &func_info);
        // Returned signer MUST represent the same account address. Otherwise, it may break the invariant of Aptos blockchain!
        assert!(
            master_signer_addr == signer::address_of(&returned_signer),
            error::invalid_state(EINCONSISTENT_SIGNER_ADDRESS)
        );
        returned_signer
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L790-798)
```rust
            (prologue_session_change_set, fee_statement)
        };

        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1844-1863)
```rust
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2105-2117)
```rust
        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3400-3424)
```rust
fn dispatchable_authenticate(
    session: &mut SessionExt<impl AptosMoveResolver>,
    gas_meter: &mut impl GasMeter,
    account: AccountAddress,
    function_info: FunctionInfo,
    auth_data: &AbstractAuthenticationData,
    traversal_context: &mut TraversalContext,
    module_storage: &impl ModuleStorage,
) -> VMResult<Vec<u8>> {
    let auth_data = bcs::to_bytes(auth_data).expect("from rust succeeds");
    let mut params = serialize_values(&vec![
        MoveValue::Signer(account),
        function_info.as_move_value(),
    ]);
    params.push(auth_data);
    session
        .execute_function_bypass_visibility(
            &ACCOUNT_ABSTRACTION_MODULE,
            AUTHENTICATE,
            vec![],
            params,
            gas_meter,
            traversal_context,
            module_storage,
        )
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L68-78)
```rust
            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

            resolver.release_resource_group_cache();
            Ok((
                prologue_session_change_set,
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L58-72)
```rust
    pub fn on_user_session_failure(
        vm: &AptosVM,
        txn_meta: &TransactionMetadata,
        resolver: &'r impl AptosMoveResolver,
        previous_session_change_set: SystemSessionChangeSet,
    ) -> Self {
        Self::new(
            vm,
            txn_meta,
            resolver,
            previous_session_change_set.unpack(),
            ModuleWriteSet::empty(),
            0.into(),
        )
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L38-59)
```rust
    pub fn spawn(
        vm: &AptosVM,
        session_id: SessionId,
        base: &'r impl AptosMoveResolver,
        previous_session_change_set: VMChangeSet,
        user_transaction_context_opt: Option<UserTransactionContext>,
    ) -> RespawnedSession<'r> {
        let executor_view = ExecutorViewWithChangeSet::new(
            base.as_executor_view(),
            base.as_resource_group_view(),
            previous_session_change_set,
        );

        RespawnedSessionBuilder {
            executor_view,
            resolver_builder: |executor_view| vm.as_move_resolver_with_group_view(executor_view),
            session_builder: |resolver| {
                Some(vm.new_session(resolver, session_id, user_transaction_context_opt))
            },
        }
        .build()
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L99-108)
```rust
        let mut change_set = self.into_heads().executor_view.change_set;
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
        Ok(change_set)
```
