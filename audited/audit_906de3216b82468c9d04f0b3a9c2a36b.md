# Audit Report

## Title
Unbounded Collection Description Field Enables Database Bloat DoS Attack on Indexer Infrastructure

## Summary
The Token v1 (`0x3::token`) Move module lacks validation for collection description length in both `create_collection` and `mutate_collection_description` functions, while name and URI fields are properly bounded. This inconsistency allows attackers to submit transactions with descriptions up to ~64 KB each, causing unbounded database growth in the indexer's `collection_datas` table and leading to query timeouts and API unavailability.

## Finding Description

The vulnerability exists across three layers of the system:

**Layer 1 - Move Contract (On-Chain):**
The `create_collection` function validates collection name and URI lengths but omits description validation: [1](#0-0) 

While constants exist for name (128 chars) and URI (512 chars): [2](#0-1) 

No `MAX_DESCRIPTION_LENGTH` constant exists, and the description is stored without validation: [3](#0-2) 

**Layer 2 - Mutation Function Inconsistency:**
The `mutate_collection_uri` function validates length: [4](#0-3) 

But `mutate_collection_description` lacks any validation: [5](#0-4) 

**Layer 3 - Indexer Storage:**
The indexer stores descriptions without truncation, unlike name and URI which are truncated: [6](#0-5) 

The database schema uses unbounded TEXT type: [7](#0-6) 

**Attack Scenario:**
1. Attacker creates a collection with `description_mutable: true` and maximum-size description (~64 KB, limited by transaction size) [8](#0-7) 

2. Attacker repeatedly calls `mutate_collection_description` with large descriptions
3. Each mutation creates a new row in `collection_datas` table with composite primary key `(collection_data_id_hash, transaction_version)` [9](#0-8) 

4. The indexer performs upsert operations without limiting row count or total size: [10](#0-9) 

5. Over 17,000 transactions, attacker accumulates 1 GB of description data
6. Database queries timeout, API responses fail, collection metadata becomes inaccessible

## Impact Explanation

**Severity: Medium** per Aptos Bug Bounty criteria

This vulnerability causes **API crashes and indexer unavailability**, which falls under High/Medium severity boundaries. Specifically:
- Indexer database bloat leads to degraded query performance and timeouts
- Collection metadata queries fail, breaking NFT marketplace functionality
- Operational burden requiring manual database intervention and cleanup
- Does NOT affect consensus, validator nodes, or on-chain state directly
- Economic cost barrier exists (attacker must pay gas for each transaction)

The impact is classified as **Medium** rather than High because:
- It affects off-chain indexer infrastructure, not core blockchain consensus
- Validator nodes continue operating normally
- On-chain state remains valid and accessible
- Requires sustained attack with gas costs (~17,000 transactions for 1 GB)
- Indexer operators can mitigate by pruning historical data

## Likelihood Explanation

**Likelihood: High**

The attack is easily executable by any user:
- No special privileges required beyond paying transaction gas fees
- Attack can be automated via scripts
- Multiple attack vectors: create many collections OR repeatedly mutate one collection
- No rate limiting or size checks at protocol level
- Transaction size limit (64 KB) provides ample space for malicious descriptions
- Collection mutability is a common feature for legitimate use cases

The only barrier is economic (gas costs), but for a determined attacker targeting specific indexer infrastructure, the cost is relatively modest compared to the operational disruption caused.

## Recommendation

**Fix 1 - Add Move Contract Validation:**

Add `MAX_DESCRIPTION_LENGTH` constant and validation in `create_collection`: [2](#0-1) 

Add after line 34:
```move
const MAX_DESCRIPTION_LENGTH: u64 = 2048;  // Align with Token v2 limit
```

Add validation in `create_collection` after line 1170:
```move
assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG));
```

**Fix 2 - Add Validation in Mutate Function:**

Add validation in `mutate_collection_description`: [11](#0-10) 

Add after line 766:
```move
assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::invalid_argument(EDESCRIPTION_TOO_LONG));
```

**Fix 3 - Add Indexer-Level Truncation:**

Add truncation in indexer model: [12](#0-11) 

Replace line 133 with:
```rust
description: truncate_str(&collection_data.description, 2048),
```

## Proof of Concept

```move
#[test(creator = @0xCAFE)]
fun test_description_dos_attack(creator: &signer) acquires Collections {
    use std::string;
    use aptos_framework::account;
    
    let creator_addr = signer::address_of(creator);
    account::create_account_for_test(creator_addr);
    
    // Create a 60KB description string (below 64KB transaction limit)
    let large_desc = string::utf8(vector::empty<u8>());
    let i = 0;
    while (i < 60000) {
        string::append(&mut large_desc, string::utf8(b"A"));
        i = i + 1;
    };
    
    // Create collection with large description - should fail with proper validation
    create_collection(
        creator,
        string::utf8(b"Test Collection"),
        large_desc,
        string::utf8(b"https://example.com"),
        100,
        vector<bool>[true, false, false]  // description_mutable = true
    );
    
    // Mutate description multiple times to create historical entries
    let mutation_count = 0;
    while (mutation_count < 100) {
        mutate_collection_description(
            creator,
            string::utf8(b"Test Collection"),
            large_desc
        );
        mutation_count = mutation_count + 1;
    };
    
    // This creates 100 * 60KB = 6MB of indexer database bloat from single collection
}
```

**Expected Behavior:** Transaction should abort with `EDESCRIPTION_TOO_LONG` error after adding proper validation.

**Current Behavior:** Transaction succeeds, creating massive database bloat in indexer.

## Notes

The vulnerability demonstrates a critical inconsistency in the Token v1 implementation where collection descriptions lack the same validation applied to names and URIs. This breaks the **Resource Limits invariant** (#9 in the security framework) which states "All operations must respect gas, storage, and computational limits."

While Token v2 (`0x4::collection`) implements proper description validation with `MAX_DESCRIPTION_LENGTH = 2048`, Token v1 remains vulnerable and is still actively used in production NFT marketplaces. The fix should be deployed via governance upgrade to the Token v1 module at address `0x3`.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L32-34)
```text
    const MAX_COLLECTION_NAME_LENGTH: u64 = 128;
    const MAX_NFT_NAME_LENGTH: u64 = 128;
    const MAX_URI_LENGTH: u64 = 512;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L766-775)
```text
    public fun mutate_collection_description(creator: &signer, collection_name: String, description: String) acquires Collections {
        let creator_address = signer::address_of(creator);
        assert_collection_exists(creator_address, collection_name);
        let collection_data = Collections[creator_address].collection_data.borrow_mut(
            collection_name
        );
        assert!(collection_data.mutability_config.description, error::permission_denied(EFIELD_NOT_MUTABLE));
        token_event_store::emit_collection_description_mutate_event(creator, collection_name, collection_data.description, description);
        collection_data.description = description;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L778-778)
```text
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1169-1170)
```text
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1193-1200)
```text
        let collection = CollectionData {
            description,
            name,
            uri,
            supply: 0,
            maximum,
            mutability_config
        };
```

**File:** crates/indexer/src/models/token_models/collection_datas.rs (L125-133)
```rust
            let collection_name = collection_data.get_name_trunc();
            let metadata_uri = collection_data.get_uri_trunc();

            Ok(Some((
                Self {
                    collection_data_id_hash: collection_data_id_hash.clone(),
                    collection_name: collection_name.clone(),
                    creator_address: collection_data_id.creator.clone(),
                    description: collection_data.description.clone(),
```

**File:** crates/indexer/src/schema.rs (L109-109)
```rust
    collection_datas (collection_data_id_hash, transaction_version) {
```

**File:** crates/indexer/src/schema.rs (L117-117)
```rust
        description -> Text,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** crates/indexer/src/processors/token_processor.rs (L370-373)
```rust
            diesel::insert_into(schema::collection_datas::table)
                .values(&collection_datas_to_insert[start_ind..end_ind])
                .on_conflict((collection_data_id_hash, transaction_version))
                .do_nothing(),
```
