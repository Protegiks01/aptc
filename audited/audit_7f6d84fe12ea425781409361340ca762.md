# Audit Report

## Title
Off-By-One Error in State Value Pruning Causes Deletion of Current State at min_readable_version Boundary

## Summary
The state value pruner contains an off-by-one error that causes deletion tombstones at the `min_readable_version` boundary to be incorrectly pruned, violating the guarantee that all versions >= `min_readable_version` remain readable. This breaks state consistency invariants and can cause state synchronization failures.

## Finding Description

The vulnerability exists in the pruning logic for `StateValueByKeyHashSchema`. When state values are deleted, the tombstone (None value) is marked as stale with `stale_since_version` equal to the deletion version. However, the pruner uses an inclusive comparison (`<=`) that incorrectly prunes state values at the `min_readable_version` boundary.

**The Bug Flow:**

1. **Deletion Marking**: When a state key is deleted at version V, the tombstone is marked as stale: [1](#0-0) 
   
   The tombstone at version V is marked with `stale_since_version = V`.

2. **Target Version Calculation**: The pruner calculates `min_readable_version` as: [2](#0-1) 
   
   So `target_version = latest_version - prune_window`, representing the minimum version that should remain readable.

3. **Pruning Logic**: The pruner deletes all stale entries where `stale_since_version <= target_version`: [3](#0-2) 
   
   This **inclusive** comparison causes deletions at the boundary to be pruned.

4. **The same bug exists in the metadata pruner**: [4](#0-3) 

**Attack Scenario:**
- Blockchain at version 1000, prune_window = 100
- State key "account/0x1" is deleted at version 900
- Pruner calculates `min_readable_version = 1000 - 100 = 900`
- Since the deletion has `stale_since_version = 900 <= target_version = 900`, it gets pruned
- **Version 900 is now missing from the database**, violating the contract that `min_readable_version` and above should be readable

**Invariant Violations:**

1. **State Consistency**: The promise that `min_readable_version` defines the first readable version is broken. State queries and Merkle proof verification for version 900 will fail.

2. **Deterministic Execution**: If nodes prune at slightly different times or have different `latest_version` values, they may have different pruning boundaries, leading to inconsistent state availability.

3. **State Sync Integrity**: When a new node syncs from version 900, it cannot retrieve the complete state because the deletion at version 900 has been pruned: [5](#0-4) 
   
   The function `get_first_txn_version()` returns `min_readable_version`, implying all versions >= this should be available.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical severity criteria:

1. **State Consistency Violation**: Breaks the fundamental guarantee that state at `min_readable_version` is preserved and verifiable via Merkle proofs, violating the "State Consistency" invariant.

2. **State Sync Failures**: New nodes attempting to sync from `min_readable_version` will fail when encountering missing deletions, potentially causing non-recoverable synchronization issues.

3. **Potential Consensus Split**: If validators prune at different times or have different pruning configurations, they may have inconsistent views of historical state, which could lead to divergent state roots during catchup or recovery scenarios.

4. **Merkle Tree Corruption Risk**: The Jellyfish Merkle tree at the boundary version was computed including the deletion. After pruning removes it, the Merkle root cannot be reconstructed or verified.

This qualifies as **Critical** under the "Non-recoverable network partition" and "State Consistency" categories, as it fundamentally breaks the storage layer's correctness guarantees.

## Likelihood Explanation

**High Likelihood** - This bug triggers automatically under normal operation:

1. **Automatic Occurrence**: Any deletion that occurs at a version that later becomes `min_readable_version` will be incorrectly pruned. With continuous blockchain operation and pruning, this is statistically certain to occur.

2. **No Special Privileges Required**: Any transaction that deletes state (account deletion, resource cleanup, etc.) can trigger this condition.

3. **Pruning is Standard Operation**: All nodes with pruning enabled (the default configuration) will exhibit this bug.

4. **Boundary Condition**: The bug occurs at every pruning cycle's boundary version, making it a recurring issue rather than a rare edge case.

## Recommendation

The fix requires changing how deletion tombstones are marked as stale. Instead of marking them with `stale_since_version = version`, they should be marked with `stale_since_version = version + 1` to ensure they're only pruned when the version is fully outside the readable window.

**Fix for `storage/aptosdb/src/state_store/mod.rs`:**

Change line 950 from:
```rust
Self::put_state_kv_index(batch, enable_sharding, version, version, key);
```

To:
```rust
Self::put_state_kv_index(batch, enable_sharding, version + 1, version, key);
```

This ensures:
- A deletion at version V is marked with `stale_since_version = V + 1`
- When `min_readable_version = V`, the deletion is NOT pruned (since V + 1 > V)
- When `min_readable_version = V + 1`, the deletion IS pruned (since V + 1 <= V + 1)
- This correctly implements the semantic that "versions >= min_readable_version are preserved"

**Alternative comment clarification**: The comment at line 948-949 should be updated to reflect the correct semantics:
```rust
// This is a tombstone, can be pruned once this `version + 1` goes out of
// the pruning window (i.e., when min_readable_version > version).
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_pruning_boundary_bug {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_types::{
        state_store::{state_key::StateKey, state_value::StateValue},
        transaction::Version,
    };

    #[test]
    fn test_deletion_at_min_readable_version_is_pruned() {
        // Setup: Create a test database with pruning enabled
        let tmpdir = TempPath::new();
        let config = RocksdbConfig::default();
        let prune_window = 100;
        
        let db = AptosDB::open(
            &tmpdir,
            false,
            NO_OP_STORAGE_PRUNER_CONFIG,
            config,
            false,
            10_000,
            10_000,
        ).unwrap();

        // Step 1: Write initial state at version 800
        let state_key = StateKey::raw(b"test_account");
        let initial_value = StateValue::new_legacy(b"balance: 1000".to_vec());
        
        // Write state at version 800
        db.state_store.put_state_values(
            800,
            &vec![(state_key.clone(), Some(initial_value))],
            false,
        ).unwrap();

        // Step 2: Delete the state at version 900
        // This creates a tombstone (None value) and marks it as stale with stale_since_version=900
        db.state_store.put_state_values(
            900,
            &vec![(state_key.clone(), None)],
            false,
        ).unwrap();

        // Step 3: Advance to version 1000 and trigger pruning
        // min_readable_version = 1000 - 100 = 900
        // Expected: version 900 should be preserved
        // Actual: version 900 gets pruned due to off-by-one error
        
        db.state_kv_pruner.set_target_version(900);
        db.state_kv_pruner.prune(1000).unwrap();

        // Step 4: Try to query state at version 900
        // This should return the deletion (None), but will fail because it was pruned
        let result = db.state_store.get_state_value_by_version(
            &state_key,
            900,
        ).unwrap();

        // BUG: The deletion at version 900 is missing!
        // Expected: Some((900, None)) indicating deletion
        // Actual: None, indicating no record exists
        assert!(result.is_none(), "BUG CONFIRMED: Deletion at min_readable_version was pruned!");

        // Verify the invariant violation
        let min_readable = db.state_kv_pruner_manager.get_min_readable_version();
        assert_eq!(min_readable, 900);
        
        // Version 900 should be readable, but the deletion is missing
        println!("CRITICAL BUG: State at min_readable_version {} was pruned!", min_readable);
    }
}
```

## Notes

This vulnerability demonstrates a subtle but critical bug in the pruning boundary logic. The inclusive comparison (`stale_since_version <= target_version`) is correct for pruning old versions of updated state, but incorrect for deletion tombstones. The fix requires special handling of deletions to mark them with `stale_since_version = version + 1`, ensuring they're preserved when at the `min_readable_version` boundary.

The impact extends beyond simple data loss: it breaks fundamental storage layer guarantees that consensus, state sync, and Merkle tree verification depend upon. Any system component that relies on `min_readable_version` being truly readable will encounter failures.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L947-950)
```rust
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L128-141)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L58-65)
```rust
        for item in iter {
            let (index, _) = item?;
            if index.stale_since_version > target_version {
                break;
            }
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(index.state_key_hash, index.version))?;
        }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L57-64)
```rust
            for item in iter {
                let (index, _) = item?;
                if index.stale_since_version > target_version {
                    break;
                }
                batch.delete::<StaleStateValueIndexSchema>(&index)?;
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
            }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L328-333)
```rust
    /// Get the first version that txn starts existent.
    fn get_first_txn_version(&self) -> Result<Option<Version>> {
        gauged_api("get_first_txn_version", || {
            Ok(Some(self.ledger_pruner.get_min_readable_version()))
        })
    }
```
