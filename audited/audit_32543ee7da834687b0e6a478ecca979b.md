# Audit Report

## Title
Critical Consensus Configuration Vulnerability: Unchecked `dag_ordering_causal_history_window` Enables DAG Ordering Corruption and Resource Exhaustion

## Summary
The `dag_ordering_causal_history_window` configuration parameter lacks input validation, allowing extreme values (0 or usize::MAX) to be set via governance. Setting it to 0 breaks causal history tracking in DAG ordering, causing nodes from previous rounds to be skipped during ordering and violating consensus safety. Setting it to usize::MAX causes unbounded DAG traversal, leading to memory and CPU exhaustion.

## Finding Description

The `dag_ordering_causal_history_window` field in `DagConsensusConfigV1` controls how far back the DAG ordering algorithm traverses when marking nodes as ordered. This parameter has no validation anywhere in the codebase. [1](#0-0) 

When governance sets this configuration via the Move module, only the byte length is checked, not the actual value: [2](#0-1) 

The vulnerability manifests in the `OrderRule::finalize_order` method where the window determines the traversal depth: [3](#0-2) 

**Attack Scenario 1: Window = 0**

When `dag_ordering_causal_history_window` is set to 0:
1. `lowest_round_to_reach = anchor.round().saturating_sub(0) = anchor.round()`
2. `reachable_mut(&anchor, Some(anchor.round()))` is called
3. In the `reachable_mut` implementation, the range becomes `anchor.round()..=anchor.round()`: [4](#0-3) 

This means only nodes at the anchor's own round are traversed and marked as ordered. **Parent nodes from previous rounds are completely skipped**, accumulating as unordered nodes indefinitely. This breaks the fundamental DAG ordering invariant that all causally dependent nodes must be ordered before their descendants, potentially leading to different validators having inconsistent views of transaction ordering.

**Attack Scenario 2: Window = usize::MAX**

When `dag_ordering_causal_history_window` is set to usize::MAX:
1. `lowest_round_to_reach = anchor.round().saturating_sub(usize::MAX)` saturates to 0
2. The range becomes `0..=anchor.round()`, traversing the entire DAG history from genesis
3. The `reachable_filter` maintains a HashSet that grows unboundedly as it accumulates all node digests: [5](#0-4) 

On a long-running chain with millions of rounds, this causes memory exhaustion from the HashSet and CPU exhaustion from iterating through all historical nodes.

The configuration is loaded without validation in the epoch manager: [6](#0-5) 

And used directly in bootstrap without bounds checking: [7](#0-6) 

## Impact Explanation

**For window = 0:** This is a **High Severity** issue qualifying as "Significant protocol violations" per the bug bounty categories. It breaks the consensus ordering invariant by skipping causal history, potentially causing validators to disagree on transaction ordering. While it doesn't immediately cause a chain split, it creates the conditions for consensus divergence.

**For window = usize::MAX:** This is a **High Severity** issue qualifying as "Validator node slowdowns" per the bug bounty categories. It causes resource exhaustion that degrades or crashes validator nodes, impacting network liveness and availability.

Both scenarios break critical consensus invariants:
- **Deterministic Execution**: Validators may process different sets of ordered nodes
- **Consensus Safety**: The DAG ordering mechanism's correctness is compromised
- **Resource Limits**: Operations don't respect computational limits (for usize::MAX)

## Likelihood Explanation

**Likelihood: Medium**

While this requires a governance proposal to exploit, the vulnerability is realistic because:

1. **No validation exists** at any layer (Move or Rust) to catch configuration errors
2. **Governance proposals can contain bugs** - even trusted actors make mistakes in complex configurations
3. **Tests use window = 5**, showing the intended value is small: [8](#0-7) 

4. **Defense-in-depth principle**: Critical consensus parameters should be validated even when set by trusted actors
5. **The consequences are severe and non-obvious** - a typo or miscalculation in a governance proposal could accidentally set 0 or an extremely large value

## Recommendation

Implement input validation for `dag_ordering_causal_history_window` at multiple layers:

**1. Add validation in the Move module:**

```move
// In consensus_config.move
const EDAG_WINDOW_OUT_OF_BOUNDS: u64 = 2;
const MIN_DAG_WINDOW: u64 = 1;
const MAX_DAG_WINDOW: u64 = 1000;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Add validation for DAG config parameters
    validate_consensus_config(&config);
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_consensus_config(config_bytes: &vector<u8>);
```

**2. Add Rust-side validation when deserializing:**

```rust
// In types/src/on_chain_config/consensus_config.rs
impl DagConsensusConfigV1 {
    const MIN_WINDOW: usize = 1;
    const MAX_WINDOW: usize = 1000;
    
    pub fn validate(&self) -> Result<()> {
        ensure!(
            self.dag_ordering_causal_history_window >= Self::MIN_WINDOW,
            "dag_ordering_causal_history_window must be at least {}",
            Self::MIN_WINDOW
        );
        ensure!(
            self.dag_ordering_causal_history_window <= Self::MAX_WINDOW,
            "dag_ordering_causal_history_window must not exceed {}",
            Self::MAX_WINDOW
        );
        Ok(())
    }
}
```

**3. Add validation when the config is loaded:**

```rust
// In consensus/src/epoch_manager.rs
let onchain_dag_consensus_config = onchain_consensus_config.unwrap_dag_config_v1();
onchain_dag_consensus_config.validate()
    .expect("Invalid DAG consensus configuration");
```

The specific bounds (MIN=1, MAX=1000) should be determined based on expected network parameters and testing.

## Proof of Concept

**Scenario 1: Window = 0 breaks ordering**

```rust
// This would be added to consensus/src/dag/tests/order_rule_tests.rs
#[test]
fn test_zero_window_skips_parent_rounds() {
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let epoch_state = Arc::new(EpochState {
        epoch: 1,
        verifier: validator_verifier,
    });
    
    // Create DAG with window = 0 (vulnerable config)
    let storage = Arc::new(MockStorage::new());
    let dag = Arc::new(DagStore::new(
        epoch_state.clone(),
        storage,
        Arc::new(MockPayloadManager {}),
        1,
        0, // ZERO WINDOW - VULNERABLE
    ));
    
    // Generate nodes across multiple rounds with proper parent relationships
    // Round 1: Create base nodes
    // Round 2: Create nodes linking to round 1
    // Round 3: Create anchor node linking to round 2
    
    let (mut order_rule, _rx) = create_order_rule(epoch_state.clone(), dag.clone());
    
    // Process anchor from round 3
    // Expected: All nodes from rounds 1, 2, 3 should be ordered
    // Actual with window=0: Only round 3 nodes are ordered
    // Rounds 1 and 2 nodes remain UNORDERED (BUG!)
    
    // Assert that nodes from previous rounds are NOT ordered (demonstrates bug)
    let dag_reader = dag.read();
    assert!(matches!(
        dag_reader.get_node_by_round_author(1, &round_1_authors[0]),
        Some(NodeStatus::Unordered { .. })
    )); // BUG: Should be Ordered but remains Unordered
}
```

**Scenario 2: Window = usize::MAX causes resource exhaustion**

```rust
#[test]
#[should_panic(expected = "memory exhausted")] // or timeout
fn test_max_window_causes_exhaustion() {
    // Create DAG with many rounds (simulate long-running chain)
    let dag = create_dag_with_many_rounds(10000); // 10k rounds
    
    // Set window to usize::MAX
    let order_rule = OrderRule::new(
        epoch_state,
        1,
        dag,
        anchor_election,
        notifier,
        usize::MAX as u64, // VULNERABLE CONFIG
        None,
    );
    
    // Attempt to order an anchor
    // This will traverse ALL 10k rounds, exhausting memory and CPU
    order_rule.process_all(); // Will hang or crash
}
```

## Notes

The default window size is 10 rounds, and tests use a window of 5 rounds, indicating the intended range is small positive integers. The lack of validation at any layer represents a defense-in-depth failure. While governance is a trusted entity, configuration errors can occur, and critical consensus parameters should have bounds checking to prevent catastrophic failures from misconfigurations.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L584-608)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct DagConsensusConfigV1 {
    pub dag_ordering_causal_history_window: usize,
    pub anchor_election_mode: AnchorElectionMode,
}

impl Default for DagConsensusConfigV1 {
    /// It is primarily used as `default_if_missing()`.
    fn default() -> Self {
        Self {
            dag_ordering_causal_history_window: 10,
            anchor_election_mode: AnchorElectionMode::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10,
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/dag/order_rule.rs (L161-198)
```rust
    fn finalize_order(&mut self, anchor: Arc<CertifiedNode>) {
        // Check we're in the expected instance
        assert!(Self::check_parity(
            self.lowest_unordered_anchor_round,
            anchor.round(),
        ));
        let lowest_round_to_reach = anchor.round().saturating_sub(self.dag_window_size_config);

        // Ceil it to the closest unordered anchor round
        let lowest_anchor_round = std::cmp::max(
            self.lowest_unordered_anchor_round,
            lowest_round_to_reach
                + !Self::check_parity(lowest_round_to_reach, anchor.round()) as u64,
        );
        assert!(Self::check_parity(lowest_anchor_round, anchor.round()));

        let failed_authors_and_rounds: Vec<_> = (lowest_anchor_round..anchor.round())
            .step_by(2)
            .map(|failed_round| (failed_round, self.anchor_election.get_anchor(failed_round)))
            .collect();
        let parents = anchor
            .parents()
            .iter()
            .map(|cert| *cert.metadata().author())
            .collect();
        let event = CommitEvent::new(
            anchor.id(),
            parents,
            failed_authors_and_rounds
                .iter()
                .map(|(_, author)| *author)
                .collect(),
        );
        self.anchor_election.update_reputation(event);

        let mut dag_writer = self.dag.write();
        let mut ordered_nodes: Vec<_> = dag_writer
            .reachable_mut(&anchor, Some(lowest_round_to_reach))
```

**File:** consensus/src/dag/dag_store.rs (L288-300)
```rust
    fn reachable_filter(start: Vec<HashValue>) -> impl FnMut(&Arc<CertifiedNode>) -> bool {
        let mut reachable: HashSet<HashValue> = HashSet::from_iter(start);
        move |node| {
            if reachable.contains(&node.digest()) {
                for parent in node.parents() {
                    reachable.insert(*parent.metadata().digest());
                }
                true
            } else {
                false
            }
        }
    }
```

**File:** consensus/src/dag/dag_store.rs (L302-318)
```rust
    pub fn reachable_mut(
        &mut self,
        from: &Arc<CertifiedNode>,
        until: Option<Round>,
    ) -> impl Iterator<Item = &mut NodeStatus> + use<'_> {
        let until = until.unwrap_or(self.lowest_round());
        let mut reachable_filter = Self::reachable_filter(vec![from.digest()]);
        self.nodes_by_round
            .range_mut(until..=from.round())
            .rev()
            .flat_map(|(_, round_ref)| round_ref.iter_mut())
            .flatten()
            .filter(move |node_status| {
                matches!(node_status, NodeStatus::Unordered { .. })
                    && reachable_filter(node_status.as_node())
            })
    }
```

**File:** consensus/src/epoch_manager.rs (L1472-1478)
```rust
        let onchain_dag_consensus_config = onchain_consensus_config.unwrap_dag_config_v1();
        let epoch_to_validators = self.extract_epoch_proposers(
            &epoch_state,
            onchain_dag_consensus_config.dag_ordering_causal_history_window as u32,
            epoch_state.verifier.get_ordered_account_addresses(),
            onchain_dag_consensus_config.dag_ordering_causal_history_window as u64,
        );
```

**File:** consensus/src/dag/bootstrap.rs (L542-550)
```rust
        let order_rule = Arc::new(Mutex::new(OrderRule::new(
            self.epoch_state.clone(),
            commit_round + 1,
            dag.clone(),
            anchor_election.clone(),
            ordered_notifier.clone(),
            self.onchain_config.dag_ordering_causal_history_window as Round,
            commit_events,
        )));
```

**File:** consensus/src/dag/tests/helpers.rs (L21-21)
```rust
pub(super) const TEST_DAG_WINDOW: u64 = 5;
```
