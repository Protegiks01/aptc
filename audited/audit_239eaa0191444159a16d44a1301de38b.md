# Audit Report

## Title
Unmetered Resource Group Deserialization in Write Operation Converter Enables Validator Node DoS

## Summary
The `convert_resource_group_v1` function in `write_op_converter.rs` performs expensive storage reads and BCS deserialization of entire resource groups without charging gas, after the resource group cache has been cleared. This allows attackers to force validator nodes to perform unbounded computational work during transaction processing, leading to node slowdowns and potential denial of service.

## Finding Description

The vulnerability exists in the transaction finalization flow where resource group changes are converted into write operations. The critical issue is a timing problem between cache invalidation and converter function execution:

**Step 1: Cache Population During Execution**
When a transaction executes and modifies a resource in a resource group, the Move VM loads the resource via `load_resource_mut()`, which triggers `get_any_resource_with_layout()`. This loads the entire resource group from storage into the `ResourceGroupAdapter` cache and charges gas based on the group size. [1](#0-0) 

**Step 2: Cache Cleared Before Conversion**
In the `finish()` method of `SessionExt`, after transaction execution completes, `split_and_merge_resource_groups()` is called, which invokes `release_resource_group_cache()`. [2](#0-1) [3](#0-2) 

When `group_size_kind == GroupSizeKind::AsSum` (the current production mode), this **clears the entire cache**: [4](#0-3) 

**Step 3: Unmetered Re-reads During Conversion**
After the cache is cleared, `WriteOpConverter` is created and `convert_resource_group_v1()` is called. This function attempts to read the resource group size and individual resource sizes: [5](#0-4) 

The comment at lines 165-166 assumes these will be cached reads, but the cache was just cleared. When `resource_group_size()` is called with an empty cache, it triggers `load_to_cache()`: [6](#0-5) 

This performs:
1. **Unmetered storage read** via `get_resource_bytes()` (line 170)
2. **Unmetered BCS deserialization** of the entire resource group (line 174)
3. **Unmetered size calculation** via `group_size_as_sum()` (line 190)

None of these operations charge gas because they occur during the conversion phase, after gas metering has concluded for the transaction.

**Exploitation Path:**
1. Attacker creates resource groups containing many large resources (limited only by u64 overflow)
2. Attacker sends transactions that modify a single resource in these groups
3. Each transaction forces the validator to deserialize the entire resource group during conversion
4. The deserialization cost is proportional to group size but is completely unmetered
5. Attacker can repeat this with minimal cost (just transaction fees) while imposing high CPU costs on validators

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty program criteria:

- **Validator node slowdowns**: Attackers can force validators to perform expensive BCS deserialization operations without paying gas for them, degrading node performance
- **Significant protocol violations**: The system violates its core invariant that all operations must respect computational limits through gas metering

The impact is amplified because:
1. Resource groups have no maximum size limit (only u64 overflow protection)
2. BCS deserialization is CPU-intensive, especially for large nested structures
3. The cost is incurred on **every** transaction that modifies any resource in the group
4. Multiple attackers can simultaneously exploit different resource groups
5. The attack affects all validators processing the block, not just one node

While this doesn't directly cause fund loss or consensus violations, it can degrade network performance to the point of effective denial of service, impacting availability.

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger automatically for any transaction that modifies a resource group when `GroupSizeKind::AsSum` is enabled (current production configuration): [7](#0-6) 

The attack requires:
- **No special privileges**: Any transaction sender can exploit this
- **Minimal setup**: Just create resource groups with many resources (standard Move operations)
- **Low cost**: Only normal transaction fees to trigger repeated deserializations
- **Guaranteed trigger**: The cache clearing and re-read happen automatically in the code path

The only requirement is the ability to submit transactions, making this trivially exploitable.

## Recommendation

**Short-term fix**: Do not clear the cache before conversion. Modify `release_resource_group_cache()` to preserve the cache for read operations during conversion, or defer cache clearing until after conversion completes.

**Recommended implementation**:

```rust
// In session/mod.rs finish() method, move cache release AFTER conversion:
let woc = WriteOpConverter::new(resolver, is_storage_slot_metadata_enabled);

let change_set = Self::convert_change_set(
    &woc,
    change_set,
    resource_group_change_set,
    events,
    table_change_set,
    aggregator_change_set,
    configs.legacy_resource_creation_as_modification(),
)?;

// Release cache only after conversion is complete
let _ = resolver.release_resource_group_cache();

Ok(change_set)
```

**Long-term fix**: Add gas metering to the converter functions themselves, or establish explicit size limits for resource groups to bound deserialization costs.

## Proof of Concept

```move
// attacker_module.move
module attacker::exploit {
    use std::signer;
    
    // Define resource group with many large resources
    #[resource_group(scope = global)]
    struct LargeGroup has key {}
    
    #[resource_group_member(group = attacker::exploit::LargeGroup)]
    struct LargeResource1 has key { data: vector<u8> }
    
    #[resource_group_member(group = attacker::exploit::LargeGroup)]
    struct LargeResource2 has key { data: vector<u8> }
    
    // ... define up to 100 resource types ...
    
    public entry fun setup_attack(account: &signer) {
        // Create large resource group
        let large_data = vector::empty<u8>();
        let i = 0;
        while (i < 10000) {  // 10KB per resource
            vector::push_back(&mut large_data, 255);
            i = i + 1;
        };
        
        // Add 100 resources to the group (1MB total)
        move_to(account, LargeResource1 { data: large_data });
        move_to(account, LargeResource2 { data: large_data });
        // ... move_to for all 100 resources ...
    }
    
    public entry fun trigger_exploit(account: &signer) acquires LargeResource1 {
        // Modify just one resource - forces full group deserialization
        let res = borrow_global_mut<LargeResource1>(signer::address_of(account));
        vector::push_back(&mut res.data, 1);
        
        // Gas was charged for reading the group during execution
        // But no gas charged for re-deserialization during conversion!
    }
}
```

**Execution steps**:
1. Deploy the module and call `setup_attack()` once to create a 1MB resource group
2. Repeatedly call `trigger_exploit()` in transactions
3. Each transaction forces validators to deserialize 1MB without gas charges during conversion
4. Monitor validator CPU usage - it will spike disproportionately to the gas charged

**Expected result**: Validator nodes experience high CPU usage during block processing, with deserialization costs not reflected in gas metering, allowing an attacker to degrade network performance at minimal cost.

### Citations

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L216-218)
```rust
        let (change_set, resource_group_change_set) =
            Self::split_and_merge_resource_groups(resolver, module_storage, change_set)
                .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L347-351)
```rust
        let mut maybe_resource_group_cache = resolver.release_resource_group_cache().map(|v| {
            v.into_iter()
                .map(|(k, v)| (k, v.into_iter().collect::<BTreeMap<_, _>>()))
                .collect::<BTreeMap<_, _>>()
        });
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L31-45)
```rust
impl GroupSizeKind {
    pub fn from_gas_feature_version(
        gas_feature_version: u64,
        resource_groups_split_in_vm_change_set_enabled: bool,
    ) -> Self {
        if resource_groups_split_in_vm_change_set_enabled {
            GroupSizeKind::AsSum
        } else if gas_feature_version >= 9 {
            // Keep old caching behavior for replay.
            GroupSizeKind::AsBlob
        } else {
            GroupSizeKind::None
        }
    }
}
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L164-197)
```rust
    fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
        let already_cached = self.group_cache.borrow().contains_key(group_key);
        if already_cached {
            return Ok(true);
        }

        let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
        let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
            || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
            |group_data_blob| {
                let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                    PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                        format!(
                            "Failed to deserialize the resource group at {:? }: {:?}",
                            group_key, e
                        ),
                    )
                })?;
                Ok((group_data, group_data_blob.len() as u64))
            },
        )?;

        let group_size = match self.group_size_kind {
            GroupSizeKind::None => ResourceGroupSize::Concrete(0),
            GroupSizeKind::AsBlob => ResourceGroupSize::Concrete(blob_len),
            GroupSizeKind::AsSum => {
                group_size_as_sum(group_data.iter().map(|(t, v)| (t, v.len())))?
            },
        };
        self.group_cache
            .borrow_mut()
            .insert(group_key.clone(), (group_data, group_size));
        Ok(false)
    }
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L289-308)
```rust
    fn release_group_cache(
        &self,
    ) -> Option<HashMap<Self::GroupKey, BTreeMap<Self::ResourceTag, Bytes>>> {
        if self.group_size_kind == GroupSizeKind::AsSum {
            // Clear the cache, but do not return the contents to the caller. This leads to
            // the VMChangeSet prepared in a new, granular format that the block executor
            // can handle (combined as a group update at the end).
            self.group_cache.borrow_mut().clear();
            None
        } else {
            // Returning the contents to the caller leads to preparing the VMChangeSet in the
            // backwards compatible way (containing the whole group update).
            Some(
                self.group_cache
                    .borrow_mut()
                    .drain()
                    .map(|(k, v)| (k, v.0))
                    .collect(),
            )
        }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L154-185)
```rust
    pub(crate) fn convert_resource_group_v1(
        &self,
        state_key: &StateKey,
        group_changes: BTreeMap<StructTag, MoveStorageOp<BytesWithResourceLayout>>,
    ) -> PartialVMResult<GroupWrite> {
        // Resource group metadata is stored at the group StateKey, and can be obtained via the
        // same interfaces at for a resource at a given StateKey.
        let state_value_metadata = self
            .remote
            .as_executor_view()
            .get_resource_state_value_metadata(state_key)?;
        // Currently, due to read-before-write and a gas charge on the first read that is based
        // on the group size, this should simply re-read a cached (speculative) group size.
        let pre_group_size = self.remote.resource_group_size(state_key)?;
        check_size_and_existence_match(&pre_group_size, state_value_metadata.is_some(), state_key)?;

        let mut inner_ops = BTreeMap::new();
        let mut post_group_size = pre_group_size;

        for (tag, current_op) in group_changes {
            // We take speculative group size prior to the transaction, and update it based on the change-set.
            // For each tagged resource in the change set, we subtract the previous size tagged resource size,
            // and then add new tagged resource size.
            //
            // The reason we do not instead get and add the sizes of the resources in the group,
            // but not in the change-set, is to avoid creating unnecessary R/W conflicts (the resources
            // in the change-set are already read, but the other resources are not).
            if !matches!(current_op, MoveStorageOp::New(_)) {
                let old_tagged_value_size = self.remote.resource_size_in_group(state_key, &tag)?;
                let old_size = group_tagged_resource_size(&tag, old_tagged_value_size)?;
                decrement_size_for_remove_tag(&mut post_group_size, old_size)?;
            }
```
