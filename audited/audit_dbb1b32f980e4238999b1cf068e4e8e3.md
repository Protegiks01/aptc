# Audit Report

## Title
Transaction Version Gap Vulnerability in Backup Restore Process Causes Node-Wide Failures

## Summary
The transaction restore process in AptosDB fails to validate that restored transactions start at the database's next expected version. This allows an attacker to restore transactions with version gaps (e.g., versions 0-99 exist, but restore starts at version 105), violating the fundamental assumption of sequential version numbers throughout the codebase and causing catastrophic node failures.

## Finding Description

The Aptos blockchain maintains a critical invariant that transaction versions are strictly sequential starting from 0 with no gaps. This assumption is deeply embedded throughout the codebase, particularly in iterators, indexers, and state sync components.

The vulnerability exists in the backup/restore pipeline where multiple validation failures combine to allow version gaps:

**Missing Validation in restore_utils.rs:**
The `save_transactions` function writes transactions directly to the database without validating that `first_version` matches the database's next expected version. [1](#0-0) 

This function bypasses the normal commit validation that occurs in `pre_commit_validation`: [2](#0-1) 

**Weak Validation in Restore Coordinator:**
The restore coordinator only validates that backup chunks are less than or equal to `db_next_version`, not equal: [3](#0-2) 

**Chunk Consecutive Check Limitation:**
The consecutive chunk validation only ensures chunks within a backup are consecutive, not that they start from the database's current version: [4](#0-3) 

**Attack Path:**
1. Database contains transactions 0-99 (next expected version = 100)
2. Attacker creates backup chunks starting at version 105 (e.g., [105-199])
3. During restore, the filtering logic includes chunks [105-199]
4. The consecutive check validates chunks are internally consecutive (passes)
5. `save_transactions` is called with `first_version=105` without validation
6. Transactions 105-199 are written, creating gap at versions 100-104

**System-Wide Impact:**
Once a gap exists, multiple critical components fail:

1. **ContinuousVersionIter fails on any range touching the gap:** [5](#0-4) 

2. **Transaction iterators used throughout the codebase fail:** [6](#0-5) 

3. **Indexer service panics when detecting gaps:** [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns/failures**: Any node that reads transaction ranges spanning the gap will fail with iterator errors, causing API crashes and node unavailability
- **API crashes**: All transaction retrieval APIs (`get_transactions`, `get_transaction_iter`) will fail for ranges touching the gap
- **Significant protocol violations**: Violates the fundamental invariant that transaction versions are sequential
- **Indexer crashes**: The indexer service explicitly panics when gaps are detected, causing service unavailability
- **State sync failures**: State synchronization depends on sequential transaction reads and will fail

The database enters an unrecoverable state where:
- Normal operations cannot read past the gap
- No standard recovery mechanism exists (would require manual database surgery or resync from genesis)
- Multiple nodes restoring from the same malicious backup would experience synchronized failures

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Ability to provide a backup file for restore (low barrier - backups are often sourced from external storage or shared repositories)
- No privileged access required
- No validator collusion needed

**Feasibility:**
- Creating a malicious backup is straightforward - simply exclude transaction chunks
- The backup verification only checks internal consistency, not alignment with target database
- Attack succeeds on first attempt if backup is properly crafted

**Exploitation Scenarios:**
1. Compromised backup storage serving malicious backups
2. Malicious operator providing intentionally corrupted backups
3. Accidental corruption during backup creation/transfer that isn't caught by validation

The attack is realistic because:
- Backup/restore is a common operational procedure
- Operators regularly restore nodes from backups during setup or recovery
- The validation gaps make detection unlikely until after restore completes

## Recommendation

**Immediate Fix:**
Add validation in `save_transactions` to ensure `first_version` matches the database's next expected version:

```rust
pub(crate) fn save_transactions(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    // ... other params
) -> Result<()> {
    // ADD THIS VALIDATION
    let next_expected = ledger_db.metadata_db().get_synced_version()?
        .map_or(0, |v| v + 1);
    ensure!(
        first_version == next_expected,
        "Cannot restore transactions starting at version {} when database expects version {}. \
         This would create a version gap and corrupt the database.",
        first_version,
        next_expected
    );
    
    // ... existing save logic
}
```

**Additional Hardening:**
1. Add explicit validation in `TransactionRestoreBatchController` before starting restore:
```rust
// After line 152 in restore.rs
let db_next_version = self.global_opt.run_mode
    .get_next_expected_transaction_version()?;
let first_chunk_version = transaction_backups
    .first()
    .map(|b| b.first_version)
    .unwrap_or(0);
ensure!(
    db_next_version == 0 || first_chunk_version <= db_next_version,
    "Backup starts at version {} but database expects version {}. \
     Cannot restore with version gap.",
    first_chunk_version,
    db_next_version
);
```

2. Strengthen the restore coordinator assertion to require equality instead of inequality
3. Add integration tests that verify version continuity validation during restore

## Proof of Concept

```rust
// Add to storage/aptosdb/src/backup/restore_handler_test.rs

#[tokio::test]
async fn test_restore_with_version_gap_fails() {
    use crate::backup::restore_handler::RestoreHandler;
    use aptos_types::transaction::{Transaction, TransactionInfo, PersistedAuxiliaryInfo};
    use aptos_types::contract_event::ContractEvent;
    use aptos_types::write_set::WriteSet;
    
    // Setup: Create AptosDB with transactions 0-99
    let tmpdir = aptos_temppath::TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    let restore_handler = db.get_restore_handler();
    
    // Populate database with transactions 0-99
    let mut txns = vec![];
    let mut txn_infos = vec![];
    let mut events = vec![];
    let mut write_sets = vec![];
    let mut aux_infos = vec![];
    
    for i in 0..100 {
        txns.push(Transaction::StateCheckpoint(HashValue::random()));
        txn_infos.push(TransactionInfo::new(
            HashValue::random(),
            HashValue::random(),
            HashValue::random(),
            None,
            0,
            aptos_types::transaction::ExecutionStatus::Success,
        ));
        events.push(vec![]);
        write_sets.push(WriteSet::default());
        aux_infos.push(PersistedAuxiliaryInfo::None);
    }
    
    restore_handler.save_transactions(
        0,
        &txns,
        &aux_infos,
        &txn_infos,
        &events,
        write_sets.clone(),
    ).unwrap();
    
    // Attack: Try to restore transactions starting at version 105 (gap at 100-104)
    let mut gap_txns = vec![];
    let mut gap_txn_infos = vec![];
    let mut gap_events = vec![];
    let mut gap_write_sets = vec![];
    let mut gap_aux_infos = vec![];
    
    for i in 105..110 {
        gap_txns.push(Transaction::StateCheckpoint(HashValue::random()));
        gap_txn_infos.push(TransactionInfo::new(
            HashValue::random(),
            HashValue::random(),
            HashValue::random(),
            None,
            0,
            aptos_types::transaction::ExecutionStatus::Success,
        ));
        gap_events.push(vec![]);
        gap_write_sets.push(WriteSet::default());
        gap_aux_infos.push(PersistedAuxiliaryInfo::None);
    }
    
    // This should FAIL with version gap error (but currently doesn't!)
    let result = restore_handler.save_transactions(
        105,  // Gap: database expects 100, we're giving 105
        &gap_txns,
        &gap_aux_infos,
        &gap_txn_infos,
        &gap_events,
        gap_write_sets,
    );
    
    // VULNERABILITY: This currently succeeds when it should fail
    assert!(result.is_err(), "Should reject transactions with version gap");
    
    // Verify iterator fails when trying to read across gap
    let iter_result = db.ledger_db.transaction_db()
        .get_transaction_iter(100, 10);
    
    if let Ok(mut iter) = iter_result {
        // Iterator should fail when it hits the gap
        let mut count = 0;
        for item in iter {
            match item {
                Ok(_) if count < 5 => count += 1, // Should work for non-existent versions
                Err(_) => {
                    // Expected: iterator detects gap
                    return;
                }
                Ok(_) => panic!("Iterator should have failed at the gap"),
            }
        }
    }
    
    panic!("Version gap was not detected - vulnerability confirmed!");
}
```

**Notes:**
- The vulnerability affects any node performing backup restore operations
- The database state becomes permanently corrupted once transactions are written with gaps
- Recovery requires complete database reconstruction from genesis or a valid backup
- The issue demonstrates a critical validation gap in the separation between normal commit paths (which validate) and restore paths (which don't)
- This represents a fundamental design flaw where trusted operations (restore) bypass safety checks that untrusted operations (normal commits) must pass

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L115-176)
```rust
pub(crate) fn save_transactions(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    persisted_aux_info: &[PersistedAuxiliaryInfo],
    txn_infos: &[TransactionInfo],
    events: &[Vec<ContractEvent>],
    write_sets: Vec<WriteSet>,
    existing_batch: Option<(
        &mut LedgerDbSchemaBatches,
        &mut ShardedStateKvSchemaBatch,
        &mut SchemaBatch,
    )>,
    kv_replay: bool,
) -> Result<()> {
    if let Some((ledger_db_batch, state_kv_batches, _state_kv_metadata_batch)) = existing_batch {
        save_transactions_impl(
            state_store,
            ledger_db,
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            ledger_db_batch,
            state_kv_batches,
            kv_replay,
        )?;
    } else {
        let mut ledger_db_batch = LedgerDbSchemaBatches::new();
        let mut sharded_kv_schema_batch = state_store
            .state_db
            .state_kv_db
            .new_sharded_native_batches();
        save_transactions_impl(
            Arc::clone(&state_store),
            Arc::clone(&ledger_db),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets.as_ref(),
            &mut ledger_db_batch,
            &mut sharded_kv_schema_batch,
            kv_replay,
        )?;
        // get the last version and commit to the state kv db
        // commit the state kv before ledger in case of failure happens
        let last_version = first_version + txns.len() as u64 - 1;
        state_store
            .state_db
            .state_kv_db
            .commit(last_version, None, sharded_kv_schema_batch)?;

        ledger_db.write_schemas(ledger_db_batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L245-261)
```rust
    fn pre_commit_validation(&self, chunk: &ChunkToCommit) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions_validation"]);

        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");

        let next_version = self.state_store.current_state_locked().next_version();
        // Ensure the incoming committing requests are always consecutive and the version in
        // buffered state is consistent with that in db.
        ensure!(
            chunk.first_version == next_version,
            "The first version passed in ({}), and the next version expected by db ({}) are inconsistent.",
            chunk.first_version,
            next_version,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L270-277)
```rust
            assert!(
                db_next_version == 0
                    || transaction_backups.first().map_or(0, |t| t.first_version)
                        <= db_next_version,
                "Inconsistent state: first txn version {} is larger than db_next_version {}",
                transaction_backups.first().map_or(0, |t| t.first_version),
                db_next_version
            );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L363-382)
```rust
            .scan(0, |last_chunk_last_version, chunk_res| {
                let res = match &chunk_res {
                    Ok(chunk) => {
                        if *last_chunk_last_version != 0
                            && chunk.first_version != *last_chunk_last_version + 1
                        {
                            Some(Err(anyhow!(
                                "Chunk range not consecutive. expecting {}, got {}",
                                *last_chunk_last_version + 1,
                                chunk.first_version
                            )))
                        } else {
                            *last_chunk_last_version = chunk.last_version;
                            Some(chunk_res)
                        }
                    },
                    Err(_) => Some(chunk_res),
                };
                future::ready(res)
            });
```

**File:** storage/aptosdb/src/utils/iterators.rs (L40-62)
```rust
    fn next_impl(&mut self) -> Result<Option<T>> {
        if self.expected_next_version >= self.end_version {
            return Ok(None);
        }

        let ret = match self.inner.next().transpose()? {
            Some((version, transaction)) => {
                ensure!(
                    version == self.expected_next_version,
                    "{} iterator: first version {}, expecting version {}, got {} from underlying iterator.",
                    std::any::type_name::<T>(),
                    self.first_version,
                    self.expected_next_version,
                    version,
                );
                self.expected_next_version += 1;
                Some(transaction)
            },
            None => None,
        };

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L62-71)
```rust
    /// Returns an iterator that yields at most `num_transactions` transactions starting from `start_version`.
    pub(crate) fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<impl Iterator<Item = Result<Transaction>> + '_> {
        let mut iter = self.db.iter::<TransactionSchema>()?;
        iter.seek(&start_version)?;
        iter.expect_continuous_versions(start_version, num_transactions)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L636-659)
```rust
            // Otherwise there is a gap
            if prev_end + 1 != start_version {
                NUM_MULTI_FETCH_OVERLAPPED_VERSIONS
                    .with_label_values(&[SERVICE_TYPE, "gap"])
                    .inc_by(prev_end - start_version + 1);

                tracing::error!(
                    batch_first_version = first_version,
                    batch_last_version = last_version,
                    start_version = start_version,
                    end_version = end_version,
                    prev_start = ?prev_start,
                    prev_end = prev_end,
                    "[Filestore] Gaps or dupes in processing version data"
                );
                panic!("[Filestore] Gaps in processing data batch_first_version: {}, batch_last_version: {}, start_version: {}, end_version: {}, prev_start: {:?}, prev_end: {:?}",
                       first_version,
                       last_version,
                       start_version,
                       end_version,
                       prev_start,
                       prev_end,
                );
            }
```
