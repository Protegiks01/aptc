# Audit Report

## Title
Imperative Construct Detection Bypass in Spec Rewriter via Pre-Descent IfElse Simplification

## Summary
The Move Compiler v2 spec rewriter contains a critical flaw where imperative constructs (Loop, LoopCont, Assign, Mutate, Return) can be missed during lambda-to-spec-function conversion. A pre-descent expression simplification eliminates assert-like IfElse patterns before their conditions are analyzed, allowing imperative constructs in those conditions to escape detection. This breaks verification soundness, potentially allowing buggy Move code to pass verification and be deployed on-chain.

## Finding Description

The vulnerability exists in the `rewrite_exp()` function's pre-descent simplification logic. [1](#0-0) 

When processing expressions in specification mode, the function performs pattern matching to simplify assert-like patterns `if (c) () else abort` into unit values `()`. However, this simplification occurs **before** calling `rewrite_exp_descent()`, which means the condition `c` is never descended into or analyzed. [2](#0-1) 

The imperative construct detection only happens in the post-descent pattern matching. [3](#0-2) 

**Attack Path:**

1. A Move function containing a lambda expression is lifted during inlining via `run_spec_rewriter_inline()` [4](#0-3) 

2. The lambda contains an expression like: `if (loop { break value }) () else abort`

3. The pureness checker does NOT validate Loop/LoopCont constructs [5](#0-4) 

4. During spec rewriting, the pre-descent simplification matches the IfElse pattern and replaces the entire expression with `()` without processing the condition containing the Loop

5. The Loop construct is never detected, so `contains_imperative_expression` remains false

6. The spec function is NOT marked as uninterpreted [6](#0-5) 

7. The Move Prover verifies properties based on an incorrect model (without the loop semantics)

8. Buggy code passes verification and can be deployed on-chain

**Invariant Violations:**

This breaks the **Deterministic Execution** invariant (Invariant #1) because validators relying on different verification results could execute different code paths. It also violates **Move VM Safety** (Invariant #3) by allowing unverified bytecode patterns to bypass formal verification.

## Impact Explanation

**Severity: High to Critical**

This vulnerability compromises the fundamental soundness guarantee of the Move Prover, which is a core security mechanism for the Aptos blockchain. According to Aptos documentation, the Move Prover ensures that deployed smart contracts meet their specifications.

**Potential Impacts:**

1. **Consensus Violations (Critical)**: If different validators use different versions of the verifier or verification results, they could accept/reject different transactions, leading to consensus divergence. This qualifies as "Consensus/Safety violations" under Critical severity.

2. **Smart Contract Exploits (High)**: Attackers could deploy Move modules with subtle bugs in lambda expressions that:
   - Bypass verification by hiding imperative logic in assert conditions
   - Cause unexpected state transitions
   - Manipulate governance voting or staking calculations
   - Lead to fund loss or unauthorized access

3. **State Inconsistencies (Medium)**: Verified code that executes differently than modeled could cause state corruption requiring validator coordination to resolve.

The severity is **High** with potential for **Critical** if this can be shown to cause consensus divergence in practice.

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**

1. **Lambda expressions are common** in Move code for higher-order functions and callbacks
2. **Assert patterns are idiomatic** in Move programming for precondition checking
3. **Loop/LoopCont are NOT checked** by the pureness checker, creating a detection gap [5](#0-4) 
4. **The code explicitly handles imperative expressions** in lambda functions, indicating this scenario is expected [6](#0-5) 

**Factors Decreasing Likelihood:**

1. Requires specific nesting: imperative construct → IfElse condition → lambda
2. Most developers may not intentionally write such patterns
3. Static analysis tools might catch obviously malicious patterns

However, given that the pureness checker has a documented gap (no Loop/LoopCont checking) and the spec rewriter's explicit handling suggests this scenario occurs in practice, the likelihood is **Medium**.

## Recommendation

**Fix:** Process the condition of assert-like IfElse patterns before simplification, or perform the simplification after descent instead of before.

**Option 1 - Move simplification to post-descent:**

Remove the pre-descent IfElse simplification at lines 450-456 since the same pattern is already handled post-descent at lines 516-522. The post-descent version will catch imperative constructs because descent has already occurred.

**Option 2 - Descent into condition before simplification:**

Before simplifying the IfElse at lines 450-456, explicitly descent into the condition to ensure imperative constructs are detected:

```rust
IfElse(id, cond, if_true, if_false)
    if matches!(if_true.as_ref(), Call(_, Tuple, _))
        && matches!(if_false.as_ref(), Call(_, Abort(_), _)) =>
{
    // Process condition first to detect imperative constructs
    let (_, _new_cond) = self.internal_rewrite_exp(cond);
    // Then reduce to unit
    Call(*id, Tuple, vec![]).into_exp()
},
```

**Option 3 - Add Loop/LoopCont to pureness checker:**

Extend the pureness checker to reject Loop and LoopCont in Specification mode, preventing them from reaching the spec rewriter: [7](#0-6) 

**Recommended approach:** Implement Option 1 (remove redundant pre-descent simplification) combined with Option 3 (extend pureness checker). This provides defense-in-depth.

## Proof of Concept

**Conceptual Move code triggering the vulnerability:**

```move
module test::vuln {
    // Lambda with imperative construct in assert condition
    public fun process_with_lambda<T>(items: vector<T>, processor: |&T| -> bool): bool {
        let result = false;
        vector::for_each_ref(&items, |item| {
            // This lambda contains: if (loop { ... }) () else abort
            // The loop in the condition will be missed
            if (loop { 
                if (processor(item)) {
                    break true
                };
                continue
            }) () else abort;
            result = true;
        });
        result
    }
}
```

**Rust test demonstrating the bypass:**

The test would need to:
1. Create a function definition with the problematic lambda pattern
2. Run `run_spec_rewriter_inline()` on it
3. Verify that `spec_fun.uninterpreted` is false (incorrectly)
4. Confirm that `spec_fun.body` is Some (should be None)

This demonstrates that imperative constructs in assert conditions escape detection, allowing unsound verification.

## Notes

The fundamental issue is that the pre-descent simplification at lines 449-463 operates on expression structure before semantic analysis (descent) has occurred. This creates a blind spot where imperative constructs can hide in eliminated sub-expressions. [8](#0-7) 

The ExpRewriterFunctions trait's design expects `rewrite_exp_descent()` to recursively process all sub-expressions, but the pre-descent transformation bypasses this guarantee. [9](#0-8) 

This vulnerability is particularly concerning because it affects the Move Prover's soundness, which is a foundational security guarantee for the Aptos blockchain's smart contract platform.

### Citations

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L266-273)
```rust
            // If the spec function contains imperative expressions, set it to uninterpreted
            if converter.contains_imperative_expression {
                let spec_fun = converter.env.get_spec_fun_mut(*id);
                spec_fun.uninterpreted = true;
                spec_fun.body = None;
            } else if !ExpData::ptr_eq(&new_exp, &exp) {
                *targets.state_mut(&target) = Def(new_exp)
            }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L447-463)
```rust
        } else {
            // Simplification which need to be done before descent
            let exp = match exp.as_ref() {
                IfElse(id, _, if_true, if_false)
                    if matches!(if_true.as_ref(), Call(_, Tuple, _))
                        && matches!(if_false.as_ref(), Call(_, Abort(_), _)) =>
                {
                    // The code pattern produced by an `assert!`: `if (c) () else abort`.
                    // Reduce to unit
                    Call(*id, Tuple, vec![]).into_exp()
                },
                Temporary(id, _) | LocalVar(id, _) => {
                    self.reference_strip_exempted.insert(*id);
                    exp
                },
                _ => exp,
            };
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L465-465)
```rust
            let exp = self.rewrite_exp_descent(exp);
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/spec_rewriter.rs (L591-597)
```rust
                ExpData::Return(..)
                | ExpData::Loop(..)
                | ExpData::Assign(..)
                | ExpData::Mutate(..)
                | ExpData::LoopCont(..) => {
                    self.contains_imperative_expression = true;
                    exp.clone()
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs (L785-789)
```rust
            function_value_spec_map = run_spec_rewriter_inline(
                env,
                target_qualified_fun_id.module_id,
                lifted_lambda_funs,
            );
```

**File:** third_party/move/move-model/src/pureness_checker.rs (L82-144)
```rust
        exp.visit_post_order(&mut |e| {
            use ExpData::*;
            use Operation::*;
            match e {
                Assign(id, ..) if self.mode == FunctionPurenessCheckerMode::Specification => {
                    (self.impure_action)(*id, "assigns variable", &self.visiting);
                    self.is_impure = true
                },
                Mutate(id, ..) => {
                    (self.impure_action)(*id, "mutates reference", &self.visiting);
                    self.is_impure = true;
                },
                Return(id, ..) if self.mode == FunctionPurenessCheckerMode::Specification => {
                    (self.impure_action)(
                        *id,
                        "return not allowed in specifications",
                        &self.visiting,
                    );
                },
                Block(id, _, None, _)
                    if self.mode == FunctionPurenessCheckerMode::Specification =>
                {
                    (self.impure_action)(
                        *id,
                        "uninitialized let not allowed in specifications",
                        &self.visiting,
                    );
                },
                Call(id, Borrow(ReferenceKind::Mutable), ..) => {
                    (self.impure_action)(*id, "mutably borrows value", &self.visiting);
                    self.is_impure = true;
                },
                Call(id, BorrowGlobal(ReferenceKind::Mutable), ..) => {
                    (self.impure_action)(
                        *id,
                        "mutably borrows from global storage",
                        &self.visiting,
                    );
                    self.is_impure = true;
                },
                Call(id, MoveFunction(mid, sid), ..) => {
                    let qid = mid.qualified(*sid);
                    // false positive: can't use entry because of borrow conflict
                    #[allow(clippy::map_entry)]
                    if !self.pureness.contains_key(&qid) {
                        self.visiting.push((qid, *id));
                        let old_impure = mem::take(&mut self.is_impure);
                        self.check_function(env, qid);
                        self.pureness.insert(qid, !self.is_impure);
                        self.visiting.pop();
                        self.is_impure |= old_impure;
                    }
                    if !self.pureness.get(&qid).unwrap() {
                        (self.impure_action)(
                            *id,
                            "calls a function which modifies state",
                            &self.visiting,
                        );
                        self.is_impure = true
                    }
                },
                _ => {},
            }
```

**File:** third_party/move/move-model/src/exp_rewriter.rs (L292-598)
```rust
    fn rewrite_exp_descent(&mut self, exp: Exp) -> Exp {
        use ExpData::*;
        match exp.as_ref() {
            Value(id, value) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_value(new_id, value) {
                    new_exp
                } else if id_changed {
                    Value(new_id, value.clone()).into_exp()
                } else {
                    exp
                }
            },
            LocalVar(id, sym) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_local_var(new_id, *sym) {
                    new_exp
                } else if id_changed {
                    LocalVar(new_id, *sym).into_exp()
                } else {
                    exp
                }
            },
            Temporary(id, idx) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_temporary(new_id, *idx) {
                    new_exp
                } else if id_changed {
                    Temporary(new_id, *idx).into_exp()
                } else {
                    exp
                }
            },
            Call(id, oper, args) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let new_args_opt = self.internal_rewrite_vec(args);
                let args_ref = if let Some(new_args) = &new_args_opt {
                    new_args.as_slice()
                } else {
                    args.as_slice()
                };
                if let Some(new_exp) = self.rewrite_call(new_id, oper, args_ref) {
                    new_exp
                } else if new_args_opt.is_some() || id_changed {
                    let args_owned = if let Some(new_args) = new_args_opt {
                        new_args
                    } else {
                        args.to_owned()
                    };
                    Call(new_id, oper.clone(), args_owned).into_exp()
                } else {
                    exp
                }
            },
            Invoke(id, target, args) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (target_changed, new_target) = self.internal_rewrite_exp(target);
                let new_args_opt = self.internal_rewrite_vec(args);
                let args_ref = if let Some(new_args) = &new_args_opt {
                    new_args.as_slice()
                } else {
                    args.as_slice()
                };
                if let Some(new_exp) = self.rewrite_invoke(new_id, &new_target, args_ref) {
                    new_exp
                } else if id_changed || target_changed || new_args_opt.is_some() {
                    let args_owned = if let Some(new_args) = new_args_opt {
                        new_args
                    } else {
                        args.to_owned()
                    };
                    Invoke(new_id, new_target, args_owned).into_exp()
                } else {
                    exp
                }
            },
            Lambda(id, pat, body, capture_kind, spec_opt) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (pat_changed, new_pat) = self.internal_rewrite_pattern(pat, true);
                self.rewrite_enter_scope(new_id, new_pat.vars().iter());
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                let (spec_body_changed, new_spec_opt) = if let Some(spec) = spec_opt {
                    let (spec_changed, new_spec) = self.internal_rewrite_exp(spec);
                    (spec_changed, Some(new_spec))
                } else {
                    (false, spec_opt.clone())
                };
                self.rewrite_exit_scope(new_id);
                if let Some(new_exp) =
                    self.rewrite_lambda(new_id, &new_pat, &new_body, *capture_kind, &new_spec_opt)
                {
                    new_exp
                } else if id_changed || pat_changed || body_changed || spec_body_changed {
                    Lambda(new_id, new_pat, new_body, *capture_kind, new_spec_opt).into_exp()
                } else {
                    exp
                }
            },
            Block(id, pat, binding, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                // Note that `binding` expr must be evaluated *before* we enter new pattern scope.
                let (binding_changed, new_binding) = if let Some(b) = binding {
                    let (changed, b) = self.internal_rewrite_exp(b);
                    (changed, Some(b))
                } else {
                    (false, None)
                };
                let (pat_changed, new_pat) = self.internal_rewrite_pattern(pat, true);
                let optional_pat = self.rewrite_enter_block_scope(new_id, &new_pat, &new_binding);
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                self.rewrite_exit_scope(new_id);
                let (pat_changed, newer_pat) = if let Some(rewritten_pat) = optional_pat {
                    (true, rewritten_pat)
                } else {
                    (pat_changed, new_pat)
                };
                if let Some(new_exp) =
                    self.rewrite_block(new_id, &newer_pat, &new_binding, &new_body)
                {
                    new_exp
                } else if id_changed || pat_changed || binding_changed || body_changed {
                    Block(new_id, newer_pat, new_binding, new_body).into_exp()
                } else {
                    exp
                }
            },
            Quant(id, kind, ranges, triggers, cond, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (ranges_changed, new_ranges) = self.internal_rewrite_quant_ranges(ranges);
                self.rewrite_enter_scope(
                    new_id,
                    ranges
                        .iter()
                        .flat_map(|(pat, _)| pat.vars())
                        .collect::<Vec<_>>()
                        .iter(),
                );
                let mut triggers_changed = false;
                let new_triggers = triggers
                    .iter()
                    .map(|p| {
                        let (c, new_p) = self
                            .internal_rewrite_vec(p)
                            .map(|pr| (true, pr))
                            .unwrap_or_else(|| (false, p.clone()));
                        triggers_changed = triggers_changed || c;
                        new_p
                    })
                    .collect_vec();
                let mut cond_changed = false;
                let new_cond = cond.as_ref().map(|c| {
                    let (c, new_c) = self.internal_rewrite_exp(c);
                    cond_changed = c;
                    new_c
                });
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                self.rewrite_exit_scope(new_id);
                if let Some(new_exp) =
                    self.rewrite_quant(new_id, &new_ranges, &new_triggers, &new_cond, &new_body)
                {
                    new_exp
                } else if id_changed
                    || ranges_changed
                    || triggers_changed
                    || cond_changed
                    || body_changed
                {
                    Quant(new_id, *kind, new_ranges, new_triggers, new_cond, new_body).into_exp()
                } else {
                    exp
                }
            },
            IfElse(id, cond, then, else_) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (cond_changed, new_cond) = self.internal_rewrite_exp(cond);
                let (then_changed, new_then) = self.internal_rewrite_exp(then);
                let (else_changed, new_else) = self.internal_rewrite_exp(else_);
                if let Some(new_exp) = self.rewrite_if_else(new_id, &new_cond, &new_then, &new_else)
                {
                    new_exp
                } else if id_changed || cond_changed || then_changed || else_changed {
                    IfElse(new_id, new_cond, new_then, new_else).into_exp()
                } else {
                    exp
                }
            },
            Match(id, disc, arms) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (disc_changed, new_disc) = self.internal_rewrite_exp(disc);

                let (mut arms_changed, mut new_arms) = (false, vec![]);
                for arm in arms {
                    let (pat_changed, new_pat) = self.internal_rewrite_pattern(&arm.pattern, true);
                    let optional_pat = self.rewrite_enter_block_scope(new_id, &new_pat, &None);
                    let (cond_changed, new_cond) = if let Some(c) = &arm.condition {
                        let (c, e) = self.internal_rewrite_exp(c);
                        (c, Some(e))
                    } else {
                        (false, None)
                    };
                    let (body_changed, new_body) = self.internal_rewrite_exp(&arm.body);
                    self.rewrite_exit_scope(new_id);
                    let (pat_changed, newer_pat) = if let Some(rewritten_pat) = optional_pat {
                        (true, rewritten_pat)
                    } else {
                        (pat_changed, new_pat)
                    };
                    let (arm_changed, new_arm) = if let Some(new_exp) =
                        self.rewrite_match_arm(new_id, &arm.loc, &newer_pat, &new_cond, &new_body)
                    {
                        (true, new_exp)
                    } else {
                        (false, MatchArm {
                            loc: arm.loc.clone(),
                            pattern: newer_pat,
                            condition: new_cond,
                            body: new_body,
                        })
                    };
                    new_arms.push(new_arm);
                    arms_changed =
                        arms_changed || arm_changed || pat_changed || cond_changed || body_changed;
                }
                if let Some(new_exp) = self.rewrite_match(new_id, &new_disc, &new_arms) {
                    new_exp
                } else if id_changed || disc_changed || arms_changed {
                    Match(new_id, new_disc, new_arms).into_exp()
                } else {
                    exp
                }
            },
            Sequence(id, es) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let changed_vec = self.internal_rewrite_vec(es);
                let vec_changed = changed_vec.is_some();
                let new_vec = changed_vec.unwrap_or_else(|| es.clone());
                if let Some(new_exp) = self.rewrite_sequence(new_id, &new_vec) {
                    new_exp
                } else if id_changed || vec_changed {
                    Sequence(new_id, new_vec).into_exp()
                } else {
                    exp
                }
            },
            Loop(id, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                if id_changed || body_changed {
                    Loop(new_id, new_body).into_exp()
                } else {
                    exp
                }
            },
            LoopCont(id, nest, do_cont) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if id_changed {
                    LoopCont(new_id, *nest, *do_cont).into_exp()
                } else {
                    exp
                }
            },
            Return(id, val) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (val_changed, new_val) = self.internal_rewrite_exp(val);
                if id_changed || val_changed {
                    Return(new_id, new_val).into_exp()
                } else {
                    exp
                }
            },
            Assign(id, lhs, rhs) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (rhs_changed, new_rhs) = self.internal_rewrite_exp(rhs);
                let (lhs_changed, new_lhs) = self.internal_rewrite_pattern(lhs, false);
                if let Some(new_exp) = self.rewrite_assign(new_id, &new_lhs, &new_rhs) {
                    new_exp
                } else if id_changed || lhs_changed || rhs_changed {
                    Assign(new_id, new_lhs, new_rhs).into_exp()
                } else {
                    exp
                }
            },
            Mutate(id, lhs, rhs) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (rhs_changed, new_rhs) = self.internal_rewrite_exp(rhs);
                let (lhs_changed, new_lhs) = self.internal_rewrite_exp(lhs);
                if id_changed || lhs_changed || rhs_changed {
                    Mutate(new_id, new_lhs, new_rhs).into_exp()
                } else {
                    exp
                }
            },
            SpecBlock(id, spec) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (spec_changed, new_spec) =
                    self.rewrite_spec_descent(&SpecBlockTarget::Inline, spec);
                if id_changed || spec_changed {
                    SpecBlock(new_id, new_spec).into_exp()
                } else {
                    exp
                }
            },
            // This can happen since we are calling the rewriter during type checking, and
            // we may have encountered an error which is represented as an Invalid expression.
            Invalid(id) => Invalid(*id).into_exp(),
        }
    }
```
