# Audit Report

## Title
Consensus Private Keys Not Zeroized From Memory - Defense-in-Depth Vulnerability

## Summary
The `bls12381::PrivateKey` struct used for consensus signing does not implement memory zeroization on drop, violating the codebase's own secure coding guidelines. Retrieved consensus private keys from `consensus_sk_by_pk()` remain in process memory indefinitely, making them vulnerable to extraction via memory dumps, core dumps, swap files, or memory forensics if an attacker gains privileged access to a validator node.

## Finding Description

The vulnerability exists across multiple layers of the consensus key management system:

**1. PrivateKey Structure Lacks Zeroization**

The `bls12381::PrivateKey` struct wraps `blst::min_pk::SecretKey` but does not implement `Drop` trait with memory zeroization: [1](#0-0) 

**2. Violated Security Guidelines**

The codebase's official secure coding standards explicitly require zeroization for cryptographic material: [2](#0-1) [3](#0-2) 

**3. consensus_sk_by_pk() Returns Unprotected Keys**

The function retrieves consensus private keys from storage and returns them without any memory protection: [4](#0-3) 

**4. ValidatorSigner Stores Keys Without Zeroization**

Retrieved keys are stored in `Arc<bls12381::PrivateKey>` within `ValidatorSigner`, which also lacks zeroization: [5](#0-4) [6](#0-5) 

**5. No Zeroize Crate Usage in Codebase**

Despite the security guidelines recommending the `zeroize` crate, there are zero instances of its usage in the entire codebase (grep search confirms no "use zeroize" statements exist).

**Attack Scenario:**

If an attacker compromises a validator node through:
- Remote code execution vulnerabilities
- Privilege escalation exploits  
- Physical access to the machine
- Supply chain attacks on dependencies

They can extract consensus private keys via:
- Process memory dumps (`gcore`, `/proc/[pid]/mem`)
- Core dumps from crashes
- Swap file/partition contents
- Hibernation files
- Memory forensics on deallocated-but-not-zeroed memory

With the stolen consensus private key, the attacker can:
- Sign malicious blocks as the legitimate validator
- Participate in equivocation attacks
- Violate consensus safety guarantees
- Fork the blockchain

## Impact Explanation

**Severity: Medium**

This qualifies as **Medium severity** under the bug bounty criteria for the following reasons:

1. **Requires Prior Node Compromise**: The vulnerability is not directly exploitable remotely. An attacker must first gain privileged access to the validator node through other means (RCE, privilege escalation, physical access).

2. **Defense-in-Depth Failure**: This represents a failure of defense-in-depth rather than a primary attack vector. It increases the blast radius of a node compromise by making consensus keys easier to extract.

3. **Violates Internal Security Standards**: The issue directly contradicts the project's documented secure coding guidelines, indicating a gap between policy and implementation.

4. **Consensus Key Materiality**: While extraction requires privileged access, consensus private keys are the most critical cryptographic material in the system. Their compromise enables attacks on the core consensus protocol (invariant #2: Consensus Safety).

5. **Limited But Real Impact**: If exploited post-compromise, this enables:
   - Validator impersonation
   - Consensus safety violations
   - Potential chain forks requiring intervention

The impact does not reach **Critical** severity because it requires prior privileged access to the validator node rather than being remotely exploitable on its own.

## Likelihood Explanation

**Likelihood: Medium**

The likelihood assessment considers:

**Factors Increasing Likelihood:**
- Validator nodes are high-value targets frequently targeted by sophisticated attackers
- Node compromises DO occur in production blockchain systems
- Once compromised, memory extraction is straightforward with standard tools
- The vulnerability affects ALL validators running Aptos consensus
- Core dumps may be automatically generated on crashes (often enabled by default)
- Swap files may be enabled on some validator deployments
- No active detection for this issue exists

**Factors Decreasing Likelihood:**
- Requires successful node compromise as a prerequisite
- Well-secured validator nodes have multiple defensive layers
- Most production deployments use secure enclaves or HSMs for key storage (mitigating memory exposure)
- Physical access attacks are lower probability for cloud-hosted validators

**Overall Assessment**: While the prerequisite of node compromise reduces direct exploitability, the widespread nature of the issue (affecting all validators) and the straightforward extraction process once compromised justify a Medium likelihood rating.

## Recommendation

**Implement Proper Memory Zeroization Using the `zeroize` Crate**

1. Add `zeroize` as a dependency in `crates/aptos-crypto/Cargo.toml`

2. Modify `bls12381::PrivateKey` to implement `ZeroizeOnDrop`:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay, ZeroizeOnDrop)]
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}

impl Drop for PrivateKey {
    fn drop(&mut self) {
        // Zeroize the internal representation
        let bytes = self.privkey.to_bytes();
        bytes.zeroize();
    }
}
```

3. Similarly update `Ed25519PrivateKey` and all other private key types in the codebase

4. Consider wrapping sensitive key material in `Zeroizing<T>` wrapper types for automatic cleanup

5. Update `ValidatorSigner` to explicitly zeroize keys when no longer needed

6. Add CI checks to enforce that all types containing cryptographic material implement zeroization

7. Document the zeroization requirements in security guidelines and enforce through code review

**Note**: Verify that the underlying `blst::min_pk::SecretKey` type properly supports zeroization or implement custom zeroization that directly zeroes the backing memory.

## Proof of Concept

```rust
#[cfg(test)]
mod memory_exposure_poc {
    use super::*;
    use aptos_crypto::{bls12381, PrivateKey, Uniform};
    use aptos_secure_storage::{InMemoryStorage, Storage};
    use aptos_types::validator_signer::ValidatorSigner;
    use std::sync::Arc;

    #[test]
    fn test_private_key_memory_not_zeroized() {
        // Generate a consensus private key
        let mut rng = rand::thread_rng();
        let consensus_key = bls12381::PrivateKey::generate(&mut rng);
        let key_bytes_original = consensus_key.to_bytes();
        
        // Store in PersistentSafetyStorage
        let storage = Storage::from(InMemoryStorage::new());
        let author = aptos_types::account_address::AccountAddress::random();
        let waypoint = aptos_types::waypoint::Waypoint::default();
        
        let mut safety_storage = PersistentSafetyStorage::initialize(
            storage,
            author,
            consensus_key,
            waypoint,
            true,
        );
        
        // Retrieve the key via consensus_sk_by_pk
        let public_key = bls12381::PublicKey::from(&safety_storage.default_consensus_sk().unwrap());
        let retrieved_key = safety_storage.consensus_sk_by_pk(public_key).unwrap();
        
        // Create ValidatorSigner (mimics real usage)
        let validator_signer = ValidatorSigner::new(author, Arc::new(retrieved_key));
        
        // Get the key bytes before drop
        let key_bytes_before = validator_signer.private_key().to_bytes();
        assert_eq!(key_bytes_original, key_bytes_before);
        
        // Drop the signer
        drop(validator_signer);
        
        // VULNERABILITY: The private key bytes remain in memory at this point
        // because neither PrivateKey nor ValidatorSigner implement Drop with zeroization.
        // 
        // In a real attack scenario:
        // 1. Attacker compromises validator node
        // 2. Attacker dumps process memory (/proc/[pid]/mem or gcore)
        // 3. Attacker searches memory dump for the 32-byte BLS private key pattern
        // 4. Attacker reconstructs the private key and can now sign as the validator
        //
        // To verify this PoC, you would need to:
        // - Inspect process memory before and after drop
        // - Confirm key bytes still present after drop
        // - This requires unsafe memory inspection or external tools
        
        println!("PoC: Private key was not zeroized on drop");
        println!("Original key bytes are still in process memory and extractable via memory dump");
    }
}
```

## Notes

While this issue represents a genuine violation of the project's secure coding standards and increases risk in the event of node compromise, it **does not meet the strict validation criteria** for a reportable vulnerability under the bug bounty program because:

1. **Requires Privileged Access**: Exploitation requires the attacker to have already compromised the validator node with root/admin privileges to access memory dumps or swap files.

2. **Defense-in-Depth Nature**: This is a defense-in-depth weakness rather than a directly exploitable vulnerability.

3. **Validation Checklist Failure**: The explicit requirement "Exploitable by unprivileged attacker (no validator insider access required)" is not met.

However, this represents an important **security hygiene issue** that should be addressed to:
- Comply with the project's documented security standards
- Reduce blast radius of potential node compromises
- Follow cryptographic best practices
- Align with industry standards for handling sensitive key material

The issue affects not just BLS consensus keys but all private key types in the codebase (Ed25519, ECDSA variants, etc.), making it a systemic implementation gap.

### Citations

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L41-45)
```rust
#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay)]
/// A BLS12381 private key
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L143-145)
```markdown
### Zeroing Sensitive Data

Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L326-330)
```rust
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
```

**File:** types/src/validator_signer.rs (L18-21)
```rust
pub struct ValidatorSigner {
    author: AccountAddress,
    private_key: Arc<bls12381::PrivateKey>,
}
```
