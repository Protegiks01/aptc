# Audit Report

## Title
Lack of Batch Expiration Validation in Proposal Processing Allows Malicious Proposers to Include Expired Transactions

## Summary
A malicious validator proposer can manipulate the timestamp used when pulling batches from the quorum store to include expired transactions in blocks, causing validators to waste execution resources processing transactions that will be discarded during prologue validation.

## Finding Description

The vulnerability exists in the proposal generation and validation flow. When a proposer creates a block, they pull batches from the quorum store using a `block_timestamp` parameter that filters expired transactions: [1](#0-0) 

The proposer obtains the timestamp from their local time service and uses it both for pulling batches and embedding in the block: [2](#0-1) [3](#0-2) 

**The Critical Gap:** When other validators receive and validate the proposal, they perform timestamp validation but do NOT verify that batches are unexpired relative to the block's timestamp: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Malicious proposer uses timestamp `T_pull` (in the past) when calling `pull_proofs()`
2. Transactions with expiration times `T_pull < expiration < T_current` pass the filter
3. Proposer embeds correct timestamp `T_current` in the BlockData
4. Block passes `verify_well_formed()` validation (only checks monotonicity and future bound)
5. During execution, expired transactions fail prologue validation: [6](#0-5) 

6. Failed transactions are discarded (not committed) as Validation errors: [7](#0-6) 

**Evidence of Missing Validation:** The consensus observer module correctly implements this validation, showing the protocol designers recognized it should exist: [8](#0-7) 

This validation is conspicuously absent from the main consensus flow in `round_manager.rs`.

## Impact Explanation

**Severity: High** (Significant Protocol Violation + Validator Resource Waste)

This violates the **Deterministic Execution** invariant and **Resource Limits** invariant:

1. **Protocol Violation**: Expired transactions that should never enter blocks are included, violating the design intent that `pull_proofs()` filters them out
2. **Resource Waste**: All validators waste CPU cycles executing prologues for transactions that will be discarded
3. **Block Space Waste**: Proof-of-store references consume block space for transactions that provide no value
4. **Potential DOS Vector**: A malicious proposer could repeatedly fill their blocks with expired transactions during their proposal turns

While users do not lose funds (expired transactions are discarded), this represents a significant protocol violation that enables resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Attacker must control a validator node (or compromise one)
- Must be selected as proposer (probability = 1/N where N = validator count)
- Must run modified software to use different timestamps

**Feasibility:**
- The attack is straightforward to implement (simple timestamp parameter change)
- Detection would require monitoring transaction expiration rates, which may not be immediately obvious
- Each proposer turn provides another opportunity to exploit
- No cryptographic barriers or complex state manipulation required

The likelihood is medium because it requires validator access, but the attack is simple to execute once that access is obtained.

## Recommendation

Add batch expiration validation during proposal processing in `round_manager.rs`:

```rust
// In process_proposal(), after existing payload validation:
if let Some(payload) = proposal.payload() {
    let block_timestamp = proposal.timestamp_usecs();
    
    // Validate that all batches (proofs and inline) are not expired
    let expired_batches = payload.get_expired_batches(block_timestamp);
    ensure!(
        expired_batches.is_empty(),
        "[RoundManager] Proposal contains {} expired batches relative to block timestamp {}",
        expired_batches.len(),
        block_timestamp
    );
}
```

Implement `get_expired_batches()` method on `Payload` enum to check all proof-of-store and inline batch expiration times against the block timestamp, similar to the existing validation in: [9](#0-8) 

This ensures validators reject proposals containing expired batches before wasting execution resources.

## Proof of Concept

```rust
// Add to consensus/src/quorum_store/tests/batch_proof_queue_test.rs

#[test]
fn test_expired_batch_manipulation() {
    use aptos_infallible::duration_since_epoch;
    use std::time::Duration;
    
    let my_peer_id = PeerId::random();
    let batch_store = Arc::new(BatchStore::new_for_test());
    let mut queue = BatchProofQueue::new(my_peer_id, batch_store, 100_000);
    
    // Create a batch that will expire soon
    let current_time = duration_since_epoch().as_micros() as u64;
    let expiration = current_time + 50_000; // Expires in 50ms
    
    let batch_info = create_batch_info(1, 100, expiration);
    let proof = create_proof_of_store(batch_info);
    
    queue.insert_proof(proof.clone());
    
    // Simulate malicious proposer behavior:
    // Use PAST timestamp to pull (includes the batch)
    let past_timestamp = Duration::from_micros(current_time - 100_000);
    let (proofs_with_past, _, _, _) = queue.pull_proofs(
        &HashSet::new(),
        PayloadTxnsSize::new(1000, 1000000),
        1000,
        1000,
        true,
        past_timestamp, // Past timestamp
    );
    
    // Batch is included because past_timestamp < expiration
    assert_eq!(proofs_with_past.len(), 1);
    
    // But if validators execute with CURRENT timestamp
    std::thread::sleep(Duration::from_millis(100));
    let current_timestamp = duration_since_epoch();
    
    // The batch would now be expired relative to current_timestamp
    assert!(current_timestamp.as_micros() as u64 > expiration);
    
    // This demonstrates the vulnerability: proposer pulled with one timestamp,
    // but the block would be executed with a different (later) timestamp,
    // causing transactions to fail as expired during execution.
}
```

**Notes**

The vulnerability requires Byzantine validator behavior (running modified software) to exploit. However, the question explicitly asks about validator manipulation, bringing this within scope. The consensus observer implementation demonstrates that batch expiration validation against block timestamp is a recognized requirement that should be enforced during proposal processing, not just payload reconstruction.

### Citations

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L644-647)
```rust
                                            && block_timestamp.as_secs()
                                                < txn_summary.expiration_timestamp_secs
                                    })
                                    .count() as u64
```

**File:** consensus/src/liveness/proposal_generator.rs (L601-601)
```rust
        let timestamp = self.time_service.get_current_timestamp();
```

**File:** consensus/src/liveness/proposal_generator.rs (L667-667)
```rust
                    block_timestamp: timestamp,
```

**File:** consensus/consensus-types/src/block.rs (L527-539)
```rust
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
            );

            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** consensus/src/round_manager.rs (L1233-1241)
```rust
        let block_time_since_epoch = Duration::from_micros(proposal.timestamp_usecs());

        ensure!(
            block_time_since_epoch < self.round_state.current_round_deadline(),
            "[RoundManager] Waiting until proposal block timestamp usecs {:?} \
            would exceed the round duration {:?}, hence will not vote for this round",
            block_time_since_epoch,
            self.round_state.current_round_deadline(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L139-142)
```text
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L295-297)
```rust
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L890-910)
```rust
        for proof_of_store in &payload_proofs {
            match reconstruct_batch(
                &block_info,
                &mut transactions_iter,
                proof_of_store.info(),
                true,
            ) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions
                        .push((proof_of_store.info().clone(), batch_transactions));
                },
                Ok(None) => { /* Nothing needs to be done (the batch was expired) */ },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct payload proof batch! Num transactions: {:?}, \
                        num batches: {:?}, num inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, proof_of_store.info(), error
                    )));
                },
            }
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L996-998)
```rust
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }
```
