# Audit Report

## Title
Domain Size Validation Bypass in LowDegreeTest Allows FFT Buffer Overflow When includes_zero=true and t=0

## Summary
The `LowDegreeTest::new()` function in `crates/aptos-crypto/src/arkworks/scrape.rs` has insufficient domain size validation when `includes_zero` is true. The check permits `batch_dom.size()` to be exactly `n - 1`, but subsequent FFT operations require the domain size to be at least `n - t`. When `t = 0`, this causes FFT to be invoked with a vector larger than the domain size, triggering either a panic (DoS) or potential out-of-bounds memory access.

## Finding Description
The SCRAPE low-degree test protocol uses FFT operations to verify polynomial degree bounds. The vulnerability exists in the domain size validation logic: [1](#0-0) 

When `includes_zero` is true, this check only requires `batch_dom.size() >= n - 1`. However, in the `dual_code_word()` method, FFT is performed on the polynomial `f`: [2](#0-1) 

The polynomial `f` has length `n - t`, which is validated here: [3](#0-2) 

**The Problem:** FFT requires `domain.size() >= input_vector.len()`. When:
- `includes_zero = true` 
- `batch_dom.size() = n - 1` (minimum allowed by check)
- `t = 0` (no validation prevents this)
- Then `f.len() = n - 0 = n`, but `domain.size() = n - 1`

This violates the FFT size requirement. The `serial_fft_assign` function expects the input slice length to exactly match `2^log_n`: [4](#0-3) 

**Exploitation Path:**
1. Call `LowDegreeTest::new()` with `t = 0`, `n = 9`, `includes_zero = true`, `batch_dom` of size 8, and `f` of length 9
2. All validations pass (8 >= 8, 0 <= 9, f.len() = 9)
3. Call `dual_code_word()` or any method using it
4. FFT invoked with domain size 8 but vector size 9
5. Result: panic assertion failure or undefined behavior

While `WeightedConfig::new()` prevents `threshold_weight = 0`: [5](#0-4) 

The `LowDegreeTest` API itself has no such protection and could be misused by other code.

## Impact Explanation
**HIGH Severity** - This vulnerability affects critical cryptographic verification code used in DKG (Distributed Key Generation): [6](#0-5) 

If triggered, it would cause:
- **Validator node crashes** during DKG verification (panic in FFT)
- **Potential memory corruption** if arkworks FFT lacks bounds checking
- **DoS attacks** against the DKG protocol if an attacker could influence configuration parameters

While current DKG usage is protected by `WeightedConfig` validation, the vulnerable library function could be exploited by future code or alternative usages, violating the **Cryptographic Correctness** and **Resource Limits** invariants.

## Likelihood Explanation
**MEDIUM Likelihood** - The vulnerability is not directly exploitable in current production code because:
1. DKG code uses `WeightedConfig` which validates `threshold_weight > 0`
2. LDT parameters come from system configuration, not user input

However, likelihood increases due to:
1. `LowDegreeTest::new()` and `random()` are public APIs
2. Future code could call them directly without proper validation
3. The validation gap is subtle and easy to miss
4. No compiler or type-system protection exists

## Recommendation
Add explicit validation in `LowDegreeTest::new()` to ensure the domain can accommodate the FFT operation:

```rust
pub fn new(
    f: Vec<F>,
    t: usize,
    n: usize,
    includes_zero: bool,
    batch_dom: &'a Radix2EvaluationDomain<F>,
) -> anyhow::Result<Self> {
    // FIX: Ensure domain size accommodates the FFT input
    let min_size = if includes_zero { 
        std::cmp::max(n - 1, n - t)  // Must hold both n-1 evaluations AND n-t FFT input
    } else { 
        n 
    };
    
    if batch_dom.size() < min_size {
        bail!(
            "expected batch evaluation domain size {} to be >= {}",
            batch_dom.size(),
            min_size
        );
    }

    // Alternative fix: explicitly validate t >= 1 when includes_zero is true
    if includes_zero && t == 0 {
        bail!("threshold t must be >= 1 when includes_zero is true");
    }

    // ... rest of validation
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "assertion failed")]
fn test_ldt_domain_size_vulnerability() {
    use ark_bn254::Fr;
    use ark_poly::{EvaluationDomain, Radix2EvaluationDomain};
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    
    // Create domain with size exactly 8 (power of 2)
    let domain = Radix2EvaluationDomain::<Fr>::new(8).unwrap();
    assert_eq!(domain.size(), 8);
    
    // Parameters that pass validation but cause FFT overflow
    let t = 0;  // No validation prevents this!
    let n = 9;  // One more than domain size
    let includes_zero = true;
    
    // Create f with length n - t = 9
    let f: Vec<Fr> = (0..9).map(|_| Fr::from(1u64)).collect();
    
    // This passes all validations
    let ldt = LowDegreeTest::new(f, t, n, includes_zero, &domain);
    assert!(ldt.is_ok(), "Validation should pass but is incorrect!");
    
    // This triggers the vulnerability - FFT with domain size 8 but vector size 9
    let ldt = ldt.unwrap();
    let _ = ldt.dual_code_word();  // PANIC: assertion failed in FFT
}
```

## Notes
The vulnerability exists specifically at the boundary condition where `includes_zero = true` and `t = 0`. The domain size check at line 44 calculates `min_size = n - 1` without considering that the FFT input has size `n - t`, which can exceed `n - 1` when `t = 0`. While production DKG code is currently protected, the cryptographic library's public API has a validation gap that violates memory safety guarantees.

### Citations

**File:** crates/aptos-crypto/src/arkworks/scrape.rs (L44-50)
```rust
        let min_size = if includes_zero { n - 1 } else { n };
        if batch_dom.size() < min_size {
            bail!(
                "expected batch evaluation domain size {} to be >= {}",
                batch_dom.size(),
                min_size
            );
```

**File:** crates/aptos-crypto/src/arkworks/scrape.rs (L57-62)
```rust
        if f.len() != n - t {
            bail!(
                "random polynomial f degree is {}; expected degree n - t - 1 = {}",
                f.len() - 1,
                n - t - 1
            )
```

**File:** crates/aptos-crypto/src/arkworks/scrape.rs (L213-213)
```rust
        let mut f_evals = self.batch_dom.fft(&self.f);
```

**File:** crates/aptos-crypto/src/blstrs/fft.rs (L72-73)
```rust
    let n = a.len() as u32;
    assert_eq!(n, 1 << log_n);
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L68-72)
```rust
        if threshold_weight == 0 {
            return Err(anyhow!(
                "expected the minimum reconstruction weight to be > 0"
            ));
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L206-212)
```rust
        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            sc.get_total_weight() + 1,
            true,
            &sc.get_threshold_config().domain,
        ); // includes_zero is true here means it includes a commitment to f(0), which is in V[n]
```
