# Audit Report

## Title
Chain ID Verification Bypass in Rosetta Block Retrieval

## Summary
The Rosetta API's `block()` function fails to verify that blocks retrieved from the REST API match the server's configured `chain_id`. The REST API returns chain_id information in response headers (via the `State` object), but this is discarded without verification, allowing blocks from incorrect networks to be served with wrong chain_id labels.

## Finding Description

The vulnerability exists in the block retrieval flow of the Rosetta API: [1](#0-0) 

The `block()` function retrieves blocks through `get_block_by_index()`: [2](#0-1) 

Which calls `BlockRetriever::get_block_by_height()`: [3](#0-2) 

**The Critical Flaw**: On lines 217 and 223, the code calls `.into_inner()` on the `Response<BcsBlock>` object. This REST client Response contains both the block data AND a `State` object with chain_id information from HTTP headers: [4](#0-3) [5](#0-4) 

The `State.chain_id` field is populated from the `X-Aptos-Chain-Id` response header: [6](#0-5) 

By calling `.into_inner()`, the code **discards the State object entirely**, losing the ability to verify that `state.chain_id` matches `server_context.chain_id`.

The `BcsBlock` struct itself does not contain chain_id: [7](#0-6) 

Subsequently, `BlockIdentifier::from_block()` blindly uses `server_context.chain_id` to construct the block identifier without any verification: [8](#0-7) 

**Startup Check Exists But Insufficient**: There is a one-time validation in `bootstrap_async()`: [9](#0-8) 

However, this only validates chain_id at startup. No runtime verification occurs during block retrieval.

## Impact Explanation

**Severity: High**

This vulnerability enables several attack scenarios if the REST API serves blocks from an incorrect network (due to misconfiguration, node restart, MITM attack, or REST API compromise):

1. **Cross-Chain Transaction Confusion**: Users querying the Rosetta API would receive blocks from network A tagged with network B's chain_id, potentially causing them to submit transactions to the wrong network.

2. **Cross-Chain Replay Vulnerabilities**: Applications relying on Rosetta for multi-chain support could be confused about which network they're operating on, leading to transaction replay attacks.

3. **Financial Application Failures**: Services using Rosetta API for blockchain data would make decisions based on incorrect network information.

4. **Undetected Runtime Network Switches**: If the underlying REST API node is reconfigured to point to a different network after Rosetta startup, this change would go undetected indefinitely.

This qualifies as **High Severity** under Aptos bug bounty criteria as it represents a "Significant protocol violation" - the API's fundamental guarantee that blocks belong to the specified network can be violated.

## Likelihood Explanation

**Likelihood: Medium**

While the vulnerability requires specific conditions to be exploited:
- Compromise or misconfiguration of the REST API endpoint, OR
- Man-in-the-middle attack on the REST API connection, OR  
- REST API software bug serving cross-chain data

These scenarios are realistic in production environments:
- Node operators may restart nodes with different configurations
- Network configuration errors can route traffic to wrong endpoints
- HTTPS misconfigurations can enable MITM attacks
- REST API bugs could serve incorrect data

The vulnerability is particularly concerning because:
1. The fix is trivially simple (verify the discarded chain_id)
2. The required data is already available but ignored
3. No runtime protection exists after the initial startup check

## Recommendation

Verify `state.chain_id` matches `server_context.chain_id` on every block retrieval:

**Modified `BlockRetriever::get_block_by_height()`:**

```rust
pub async fn get_block_by_height(
    &self,
    height: u64,
    with_transactions: bool,
    expected_chain_id: ChainId,
) -> ApiResult<aptos_rest_client::aptos_api_types::BcsBlock> {
    let response = if with_transactions {
        self.rest_client
            .get_full_block_by_height_bcs(height, self.page_size)
            .await?
    } else {
        self.rest_client
            .get_block_by_height_bcs(height, false)
            .await?
    };
    
    // Verify chain_id from response headers matches expected
    let state = response.state();
    if state.chain_id != expected_chain_id.id() {
        return Err(ApiError::InvalidInput(Some(format!(
            "Chain ID mismatch: expected {}, got {} from REST API for block {}",
            expected_chain_id.id(),
            state.chain_id,
            height
        ))));
    }
    
    Ok(response.into_inner())
}
```

Update all call sites to pass `server_context.chain_id` as a parameter.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_chain_id_mismatch_not_detected() {
    // Setup: Rosetta server configured for mainnet (chain_id=1)
    let mainnet_chain_id = ChainId::new(1);
    
    // Mock REST API that returns testnet blocks (chain_id=2)
    // but Rosetta server is configured for mainnet
    let mock_rest_client = create_mock_client_returning_testnet_blocks();
    
    let rosetta_context = RosettaContext::new(
        Some(Arc::new(mock_rest_client)),
        mainnet_chain_id,  // Configured for mainnet
        /* ... */
    ).await;
    
    // Request a block
    let block_request = BlockRequest {
        network_identifier: mainnet_chain_id.into(),
        block_identifier: PartialBlockIdentifier::block_index(100),
        /* ... */
    };
    
    // BUG: This succeeds and returns a testnet block tagged as mainnet
    let response = block(block_request, rosetta_context).await.unwrap();
    
    // The block identifier hash will be: "1-100" (mainnet chain_id)
    // But the actual block data is from testnet (chain_id 2)
    assert_eq!(response.block.block_identifier.hash, "1-100");
    
    // This is the vulnerability: wrong chain data with wrong chain_id label
    // No error is raised despite chain_id mismatch
}
```

## Notes

This vulnerability represents a critical defense-in-depth failure. While exploitation requires compromise of the REST API connection or endpoint, the impact is severe enough and the fix is simple enough that this should be addressed. The code already has access to the correct chain_id in response headers but explicitly discards it without verification, violating basic input validation principles for security-critical APIs.

### Citations

**File:** crates/aptos-rosetta/src/block.rs (L34-74)
```rust
async fn block(request: BlockRequest, server_context: RosettaContext) -> ApiResult<BlockResponse> {
    debug!("/block");
    trace!(
        request = ?request,
        server_context = ?server_context,
        "/block",
    );

    check_network(request.network_identifier, &server_context)?;

    // Retrieve by block index or by hash, neither is not allowed
    let block_index =
        get_block_index_from_request(&server_context, request.block_identifier).await?;

    let (parent_transaction, block) = get_block_by_index(
        server_context.block_cache()?.as_ref(),
        block_index,
        server_context.chain_id,
    )
    .await?;

    // A hack to reduce overhead, if set, it will drop empty transactions (no operations0 from the
    // block to reduce traffic sent
    let keep_empty_transactions = request
        .metadata
        .as_ref()
        .and_then(|inner| inner.keep_empty_transactions)
        .unwrap_or_default();

    // Build the block accordingly from the input data
    let block = build_block(
        &server_context,
        parent_transaction,
        block,
        server_context.chain_id,
        keep_empty_transactions,
    )
    .await?;

    Ok(BlockResponse { block })
}
```

**File:** crates/aptos-rosetta/src/block.rs (L116-141)
```rust
async fn get_block_by_index(
    block_cache: &BlockRetriever,
    block_height: u64,
    chain_id: ChainId,
) -> ApiResult<(
    BlockIdentifier,
    aptos_rest_client::aptos_api_types::BcsBlock,
)> {
    let block = block_cache.get_block_by_height(block_height, true).await?;

    // For the genesis block, we populate parent_block_identifier with the
    // same genesis block. Refer to
    // https://www.rosetta-api.org/docs/common_mistakes.html#malformed-genesis-block
    if block_height == 0 {
        Ok((BlockIdentifier::from_block(&block, chain_id), block))
    } else {
        // Retrieve the previous block's identifier
        let prev_block = block_cache
            .get_block_by_height(block_height - 1, false)
            .await?;
        let prev_block_id = BlockIdentifier::from_block(&prev_block, chain_id);

        // Retrieve the current block
        Ok((prev_block_id, block))
    }
}
```

**File:** crates/aptos-rosetta/src/block.rs (L205-225)
```rust
    pub async fn get_block_by_height(
        &self,
        height: u64,
        with_transactions: bool,
    ) -> ApiResult<aptos_rest_client::aptos_api_types::BcsBlock> {
        // If we request transactions, we have to provide the page size, it ideally is bigger than
        // the maximum block size.  If not, transactions will be missed.
        if with_transactions {
            Ok(self
                .rest_client
                .get_full_block_by_height_bcs(height, self.page_size)
                .await?
                .into_inner())
        } else {
            Ok(self
                .rest_client
                .get_block_by_height_bcs(height, false)
                .await?
                .into_inner())
        }
    }
```

**File:** crates/aptos-rest-client/src/response.rs (L6-31)
```rust
#[derive(Debug)]
pub struct Response<T> {
    inner: T,
    state: State,
}

impl<T> Response<T> {
    pub fn new(inner: T, state: State) -> Self {
        Self { inner, state }
    }

    pub fn inner(&self) -> &T {
        &self.inner
    }

    pub fn into_inner(self) -> T {
        self.inner
    }

    pub fn state(&self) -> &State {
        &self.state
    }

    pub fn into_parts(self) -> (T, State) {
        (self.inner, self.state)
    }
```

**File:** crates/aptos-rest-client/src/state.rs (L10-20)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```

**File:** crates/aptos-rest-client/src/state.rs (L23-102)
```rust
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** api/types/src/block.rs (L28-41)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BcsBlock {
    /// The block height (number of the block from 0)
    pub block_height: u64,
    pub block_hash: aptos_crypto::HashValue,
    /// The block timestamp in Unix epoch microseconds
    pub block_timestamp: u64,
    /// The first ledger version of the block inclusive
    pub first_version: u64,
    /// The last ledger version of the block inclusive
    pub last_version: u64,
    /// The transactions in the block in sequential order
    pub transactions: Option<Vec<TransactionOnChainData>>,
}
```

**File:** crates/aptos-rosetta/src/types/identifiers.rs (L424-432)
```rust
    pub fn from_block(
        block: &aptos_rest_client::aptos_api_types::BcsBlock,
        chain_id: ChainId,
    ) -> BlockIdentifier {
        BlockIdentifier {
            index: block.block_height,
            hash: BlockHash::new(chain_id, block.block_height).to_string(),
        }
    }
```

**File:** crates/aptos-rosetta/src/lib.rs (L125-136)
```rust
    if let Some(ref client) = rest_client {
        assert_eq!(
            chain_id.id(),
            client
                .get_ledger_information()
                .await
                .expect("Should successfully get ledger information from Rest API on bootstap")
                .into_inner()
                .chain_id,
            "Failed to match Rosetta chain Id to upstream server"
        );
    }
```
