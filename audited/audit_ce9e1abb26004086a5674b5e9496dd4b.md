# Audit Report

## Title
Path Traversal Vulnerability in Storage Directory Configuration Allows Database Creation in Arbitrary System Locations

## Summary
The `StorageConfig::dir()` method returns an unvalidated filesystem path that can be set to arbitrary locations including system directories (`/tmp`, `/etc`) or paths with directory traversal sequences (`../../tmp`). This path is used directly in `FastSyncStorageWrapper::initialize_dbs()` to create RocksDB databases without any security validation, allowing maliciously crafted configuration files to create databases in dangerous locations.

## Finding Description
The vulnerability exists in the configuration validation logic of the Aptos storage system. When a node initializes its databases through `FastSyncStorageWrapper::initialize_dbs()`, it retrieves the storage directory path via `config.storage.dir()`. [1](#0-0) 

The `dir()` method in `StorageConfig` simply returns the configured path without any validation. [2](#0-1) 

This unvalidated path is then used to create database directories. For the fast sync secondary database, the path is extended with `SECONDARY_DB_DIR` and passed directly to `AptosDB::open()`. [3](#0-2) 

The `StorageConfig::sanitize()` method validates paths in `db_path_overrides` to ensure they are absolute, demonstrating awareness of path security issues. [4](#0-3)  However, the main `dir` field receives no such validation. [5](#0-4) 

A malicious or compromised configuration file can specify:
- Absolute paths to system directories: `storage.dir: "/tmp"` or `storage.dir: "/etc"`
- Relative paths with directory traversal: `storage.dir: "../../tmp"`
- World-writable directories where attackers could pre-plant symlinks

When deserialized from YAML, these paths are accepted without validation. [6](#0-5) 

## Impact Explanation
This constitutes a **Medium severity** vulnerability per Aptos bug bounty criteria:

1. **State Inconsistencies**: Databases created in world-writable locations (e.g., `/tmp`) can be manipulated by local attackers, corrupting the node's state store and breaking consensus with other validators
2. **Denial of Service**: Creating large databases in system partitions could fill disk space, causing node crashes
3. **Data Integrity Violations**: Symlink attacks in `/tmp` could redirect database writes to attacker-controlled locations

The impact is limited to individual nodes and requires configuration file access, preventing classification as Critical or High severity.

## Likelihood Explanation
**Moderate likelihood** in specific deployment scenarios:

1. **Shared Development Environments**: Multiple developers with config access could accidentally or maliciously misconfigure paths
2. **Compromised CI/CD Pipelines**: Attackers gaining pipeline access could inject malicious configurations during deployment
3. **Container Misconfigurations**: Improperly secured config volumes in containerized deployments
4. **Supply Chain Attacks**: Compromised configuration management tools distributing malicious configs

However, production validator environments typically have strict access controls, reducing real-world likelihood.

## Recommendation
Implement path validation in `StorageConfig::sanitize()` to enforce security constraints:

```rust
// In StorageConfig::sanitize() method, add validation for the main dir field:

// Validate the main storage directory
let storage_dir = config.dir();

// Check 1: Path must be absolute (no relative paths)
if !storage_dir.is_absolute() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        format!("Storage directory {:?} must be an absolute path", storage_dir),
    ));
}

// Check 2: Canonicalize to prevent directory traversal
let canonical_path = storage_dir.canonicalize().map_err(|e| {
    Error::ConfigSanitizerFailed(
        sanitizer_name,
        format!("Failed to canonicalize storage directory {:?}: {}", storage_dir, e),
    )
})?;

// Check 3: Disallow system directories
const FORBIDDEN_DIRS: &[&str] = &["/tmp", "/etc", "/var", "/sys", "/proc", "/dev", "/boot"];
for forbidden in FORBIDDEN_DIRS {
    if canonical_path.starts_with(forbidden) {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!("Storage directory {:?} cannot be in system directory {}", canonical_path, forbidden),
        ));
    }
}

// Check 4: Ensure parent directory exists and is writable
if let Some(parent) = canonical_path.parent() {
    if !parent.exists() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            format!("Parent directory {:?} does not exist", parent),
        ));
    }
}
```

This validation should mirror the existing checks for `db_path_overrides` to maintain consistency.

## Proof of Concept

```rust
#[cfg(test)]
mod path_traversal_poc {
    use aptos_config::config::{NodeConfig, StorageConfig};
    use std::path::PathBuf;

    #[test]
    #[should_panic(expected = "system directory")]
    fn test_malicious_config_tmp_directory() {
        // Create a malicious config pointing to /tmp
        let yaml_config = r#"
        base:
          role: "full_node"
          waypoint:
            from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"
        storage:
          dir: "/tmp"
        "#;
        
        // This should fail during sanitization but currently doesn't
        let config: NodeConfig = serde_yaml::from_str(yaml_config).unwrap();
        let storage_dir = config.storage.dir();
        
        // Vulnerability: storage_dir is /tmp without any validation
        assert_eq!(storage_dir, PathBuf::from("/tmp"));
        
        // This would create databases in /tmp/fast_sync_secondary
        // allowing potential symlink attacks and data manipulation
    }

    #[test]
    #[should_panic(expected = "absolute path")]
    fn test_malicious_config_directory_traversal() {
        let yaml_config = r#"
        base:
          role: "full_node"
          waypoint:
            from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"
        storage:
          dir: "../../tmp/malicious_db"
          data_dir: "/opt/aptos/data"
        "#;
        
        let config: NodeConfig = serde_yaml::from_str(yaml_config).unwrap();
        let storage_dir = config.storage.dir();
        
        // Vulnerability: directory traversal is not prevented
        assert_eq!(storage_dir, PathBuf::from("/opt/aptos/tmp/malicious_db"));
    }
}
```

## Notes

The vulnerability represents an **inconsistency in security validation**: `db_path_overrides` paths are validated for being absolute [4](#0-3) , but the primary `dir` field lacks equivalent protection. This violates the principle of defense-in-depth by assuming configuration files are always trustworthy.

While production deployments typically have strict access controls limiting who can modify configuration files, security best practices dictate that all inputs—including configuration—should be validated to prevent accidental misconfigurations and limit damage from compromised deployment pipelines or insider threats.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L64-64)
```rust
        let mut db_dir = config.storage.dir();
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L78-90)
```rust
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
```

**File:** config/src/config/storage_config.rs (L267-304)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct StorageConfig {
    pub backup_service_address: SocketAddr,
    /// Top level directory to store the RocksDB
    pub dir: PathBuf,
    /// Hot state configuration
    pub hot_state_config: HotStateConfig,
    /// Storage pruning configuration
    pub storage_pruner_config: PrunerConfig,
    /// Subdirectory for storage in tests only
    #[serde(skip)]
    data_dir: PathBuf,
    /// AptosDB persists the state authentication structure off the critical path
    /// of transaction execution and batch up recent changes for performance. Once
    /// the number of buffered state updates exceeds this config, a dump of all
    /// buffered values into a snapshot is triggered. (Alternatively, if too many
    /// transactions have been processed since last dump, a new dump is processed
    /// as well.)
    pub buffered_state_target_items: usize,
    /// The max # of nodes for a lru cache shard.
    pub max_num_nodes_per_lru_cache_shard: usize,
    /// Rocksdb-specific configurations
    pub rocksdb_configs: RocksdbConfigs,
    /// Try to enable the internal indexer. The indexer expects to have seen all transactions
    /// since genesis. To recover operation after data loss, or to bootstrap a node in fast sync
    /// mode, the indexer db needs to be copied in from another node.
    /// TODO(jill): deprecate Indexer once Indexer Async V2 is ready
    pub enable_indexer: bool,
    /// Fine grained control for db paths of individal databases/shards.
    /// If not specificed, will use `dir` as default.
    /// Only allowed when sharding is enabled.
    db_path_overrides: Option<DbPathConfig>,
    /// ensure `ulimit -n`, set to 0 to not ensure.
    pub ensure_rlimit_nofile: u64,
    /// panic if failed to ensure `ulimit -n`
    pub assert_rlimit_nofile: bool,
}
```

**File:** config/src/config/storage_config.rs (L459-465)
```rust
    pub fn dir(&self) -> PathBuf {
        if self.dir.is_relative() {
            self.data_dir.join(&self.dir)
        } else {
            self.dir.clone()
        }
    }
```

**File:** config/src/config/storage_config.rs (L682-798)
```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        let epoch_snapshot_prune_window = config
            .storage_pruner_config
            .epoch_snapshot_pruner_config
            .prune_window;
        let user_pruning_window_offset = config
            .storage_pruner_config
            .ledger_pruner_config
            .user_pruning_window_offset;

        if ledger_prune_window < 50_000_000 {
            warn!("Ledger prune_window is too small, harming network data availability.");
        }
        if state_merkle_prune_window < 100_000 {
            warn!("State Merkle prune_window is too small, node might stop functioning.");
        }
        if epoch_snapshot_prune_window < 50_000_000 {
            warn!("Epoch snapshot prune_window is too small, harming network data availability.");
        }
        if user_pruning_window_offset > 1_000_000 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset too large, so big a buffer is unlikely necessary. Set something < 1 million.".to_string(),
            ));
        }
        if user_pruning_window_offset > ledger_prune_window {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset is larger than the ledger prune window, the API will refuse to return any data.".to_string(),
            ));
        }

        if let Some(db_path_overrides) = config.db_path_overrides.as_ref() {
            if !config.rocksdb_configs.enable_storage_sharding {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "db_path_overrides is allowed only if sharding is enabled.".to_string(),
                ));
            }

            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }

            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
        }

        Ok(())
    }
```
