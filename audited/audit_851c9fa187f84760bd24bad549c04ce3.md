# Audit Report

## Title
Optimistic Signature Verification Allows Mismatched Signatures to Bypass Early Detection, Causing Performance Degradation in Consensus

## Summary
The `CommitVote::new_with_signature()` function accepts signatures without validating they correspond to the provided ledger_info data. When optimistic signature verification is enabled (default), Byzantine validators can send valid BLS12-381 signatures signed over different data, which are accepted without verification until aggregation. This causes mandatory signature filtering operations and performance degradation on all validators processing these commit votes.

## Finding Description
The vulnerability exists in the commit vote validation pipeline: [1](#0-0) 

This function constructs a `CommitVote` without validating that the provided signature matches the `ledger_info`. The signature is only verified later when:

1. The vote is received and passed through verification: [2](#0-1) 

2. Which calls `optimistic_verify()` with the default configuration: [3](#0-2) 

3. The `optimistic_verify()` function skips verification when the flag is true: [4](#0-3) 

When `optimistic_sig_verification` is true (line 278), verification is ONLY performed if the author is in the `pessimistic_verify_set`. Otherwise, it returns `Ok(())` without checking the signature.

4. The unverified signature is added to the aggregator: [5](#0-4) 

5. During aggregation, all signatures are aggregated without individual verification: [6](#0-5) 

**Attack Scenario:**
A Byzantine validator sends a `CommitVote` where:
- `author` = their validator address
- `ledger_info` = correct block data
- `signature` = valid BLS12-381 signature BUT signed over DIFFERENT ledger_info data

This vote passes optimistic verification (line 284 returns `Ok()` without checking), gets stored, counts toward voting power, and only fails during aggregation (line 523). This forces expensive signature filtering (line 530) across all received signatures.

## Impact Explanation
**High Severity** - Validator Node Slowdowns

This qualifies as High severity per the Aptos bug bounty because:

1. **Performance Degradation**: When aggregation fails due to mismatched signatures, the system must perform expensive individual signature verification on ALL signatures in the set: [7](#0-6) 

This parallel verification operation (lines 295-310) is computationally expensive, especially with large validator sets.

2. **Amplification Effect**: A single malicious validator can force ALL honest validators attempting to aggregate that block's commit votes to perform this expensive filtering operation.

3. **Consensus Delay**: The block cannot advance to the aggregated state until the second aggregation attempt succeeds after filtering, potentially delaying consensus by one round.

4. **Resource Exhaustion**: Byzantine validators can repeatedly send such votes for sequential blocks (using different "wrong" data for each signature), causing sustained performance degradation until they're added to the pessimistic_verify_set.

## Likelihood Explanation
**High Likelihood**

1. **Low Attack Complexity**: A Byzantine validator only needs to:
   - Generate a valid signature over arbitrary data
   - Send it in a commit vote with correct ledger_info
   - No coordination required, single validator can execute

2. **Default Configuration**: Optimistic verification is enabled by default (line 382 in consensus_config.rs), making all deployments vulnerable.

3. **Detection Delay**: The attack succeeds until the first aggregation attempt, giving the attacker a guaranteed window of impact before being added to the pessimistic_verify_set.

4. **Practical Exploitability**: Any validator can launch this attack without detection before the damage (performance impact) occurs.

## Recommendation

Add signature validation in `CommitVote::verify()` or during the initial reception verification phase, even in optimistic mode, specifically to detect signature-data mismatch:

```rust
pub fn optimistic_verify<T: Serialize + CryptoHash>(
    &self,
    author: AccountAddress,
    message: &T,
    signature_with_status: &SignatureWithStatus,
) -> std::result::Result<(), VerifyError> {
    if self.get_public_key(&author).is_none() {
        return Err(VerifyError::UnknownAuthor);
    }
    
    // ADDED: Always verify if in pessimistic set OR if not yet verified
    // This catches mismatched signatures early
    if (self.pessimistic_verify_set.contains(&author) || !signature_with_status.is_verified())
        && self.optimistic_sig_verification
    {
        // Verify at least once to detect completely wrong signatures
        self.verify(author, message, signature_with_status.signature())?;
        signature_with_status.set_verified();
    } else if !self.optimistic_sig_verification && !signature_with_status.is_verified() {
        self.verify(author, message, signature_with_status.signature())?;
        signature_with_status.set_verified();
    }
    
    Ok(())
}
```

Alternatively, perform a lightweight check in `new_with_signature()` to at least verify the signature format and public key derivation match expectations before constructing the object.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
#[cfg(test)]
mod commit_vote_exploit_poc {
    use super::*;
    use aptos_crypto::{bls12381, PrivateKey, Uniform};
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        validator_verifier::ValidatorVerifier,
    };
    
    #[test]
    fn test_mismatched_signature_accepted_in_optimistic_mode() {
        let mut rng = rand::thread_rng();
        
        // Setup: Create validator keys and verifier
        let private_key = bls12381::PrivateKey::generate(&mut rng);
        let public_key = bls12381::PublicKey::from(&private_key);
        let author = AccountAddress::random();
        
        // Create correct ledger_info
        let correct_ledger_info = LedgerInfo::new(
            BlockInfo::empty(),
            HashValue::zero(),
        );
        
        // Create WRONG ledger_info and sign it
        let wrong_ledger_info = LedgerInfo::new(
            BlockInfo::random(1),  // Different block!
            HashValue::random(),
        );
        let wrong_signature = private_key.sign(&wrong_ledger_info).unwrap();
        
        // EXPLOIT: Create CommitVote with correct ledger_info but signature for wrong data
        let malicious_vote = CommitVote::new_with_signature(
            author,
            correct_ledger_info.clone(),
            wrong_signature,  // Signed over DIFFERENT data!
        );
        
        // Setup validator verifier with optimistic verification enabled
        let validator_infos = vec![ValidatorConsensusInfo::new(author, public_key, 1)];
        let mut verifier = ValidatorVerifier::new(validator_infos);
        verifier.set_optimistic_sig_verification_flag(true);
        
        // VULNERABILITY: This passes optimistic verification!
        let verify_result = malicious_vote.verify(author, &verifier);
        assert!(verify_result.is_ok(), "Mismatched signature should pass optimistic verification");
        
        // The signature is wrong, but aggregation will discover it later
        // causing expensive filtering operation on all validators
        
        // Demonstrate that non-optimistic mode catches it:
        verifier.set_optimistic_sig_verification_flag(false);
        let verify_result_strict = malicious_vote.verify(author, &verifier);
        assert!(verify_result_strict.is_err(), "Should fail with strict verification");
    }
}
```

## Notes

This vulnerability is inherent to the optimistic signature verification design but represents a real attack vector where Byzantine validators can cause measurable performance degradation. The mitigation mechanisms (pessimistic_verify_set) only engage AFTER the first attack succeeds, meaning the performance impact is guaranteed for the first malicious vote from each Byzantine validator. With multiple colluding validators, this can cause sustained performance degradation across the network.

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L59-69)
```rust
    pub fn new_with_signature(
        author: Author,
        ledger_info: LedgerInfo,
        signature: bls12381::Signature,
    ) -> Self {
        Self {
            author,
            ledger_info,
            signature: SignatureWithStatus::from(signature),
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
