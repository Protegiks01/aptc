# Audit Report

## Title
Genesis QC Invariant Bypass Through Missing Validation in create_merged_with_executed_state()

## Summary
The `create_merged_with_executed_state()` function in both `QuorumCert` and `WrappedLedgerInfo` lacks validation to prevent merging genesis quorum certificates (round 0) with executed states that contain validator signatures, potentially creating invalid certificates that violate the critical genesis invariant requiring zero signatures.

## Finding Description

Genesis quorum certificates in Aptos have a fundamental invariant enforced by the `verify()` function: blocks at round 0 must have exactly zero validator signatures, as they are implicitly agreed upon during epoch transitions without requiring consensus voting. [1](#0-0) 

However, the `create_merged_with_executed_state()` function only validates that the block metadata (epoch, round, id, timestamp) matches using `match_ordered_only()`, without checking whether the quorum certificate is for a genesis block (round 0) or validating the signature count: [2](#0-1) 

The `match_ordered_only()` validation only checks epoch, round, id, and timestamp, but does NOT check the number of signatures: [3](#0-2) 

The same vulnerability exists in `WrappedLedgerInfo`: [4](#0-3) 

**Critical Missing Check**: There is no validation preventing a genesis QC (created via `certificate_for_genesis_from_ledger_info()` with round 0 and zero signatures) from being merged with a `LedgerInfoWithSignatures` that has the same round 0 but contains actual validator signatures. [5](#0-4) 

Additionally, the vote aggregation logic in `pending_votes.rs` has no safeguard preventing signature collection for round 0 blocks: [6](#0-5) 

If validators were to vote on a round 0 block (which should never happen but isn't prevented), signatures would be collected and a `LedgerInfoWithSignatures` with round 0 and signatures could be created, which could then be merged with a genesis QC.

## Impact Explanation

While I could not identify a **currently exploitable attack path** in the production codebase (genesis blocks appear to be handled specially and don't go through normal consensus voting), this represents a **defensive programming vulnerability** with **Medium severity** impact:

1. **Code Evolution Risk**: Future code changes could inadvertently create a path where this merge happens, and the missing validation wouldn't catch it
2. **Invariant Violation**: If exploited, it would create invalid quorum certificates that violate fundamental consensus invariants
3. **Verification Failure**: The resulting merged QC would fail `verify()`, potentially causing consensus disruption

The lack of defensive validation violates the principle of defense-in-depth for critical consensus components.

## Likelihood Explanation

**Current Likelihood: Very Low** - I found no evidence that genesis blocks go through the execution pipeline's `commit_callback` flow where `create_merged_with_executed_state()` is invoked with potentially malicious parameters. Genesis blocks are created locally at epoch boundaries and handled specially.

**Future Likelihood: Medium** - Code refactoring, new features, or consensus protocol changes could introduce paths where this validation gap becomes exploitable.

## Recommendation

Add explicit validation in `create_merged_with_executed_state()` to enforce genesis invariants:

```rust
pub fn create_merged_with_executed_state(
    &self,
    executed_ledger_info: LedgerInfoWithSignatures,
) -> anyhow::Result<QuorumCert> {
    let self_commit_info = self.commit_info();
    let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
    ensure!(
        self_commit_info.match_ordered_only(executed_commit_info),
        "Block info from QC and executed LI need to match, {:?} and {:?}",
        self_commit_info,
        executed_commit_info
    );
    
    // NEW VALIDATION: Enforce genesis invariants
    if self.certified_block().round() == 0 {
        ensure!(
            executed_ledger_info.get_num_voters() == 0,
            "Cannot merge genesis QC with executed state containing signatures. \
             Genesis blocks (round 0) must have zero signatures"
        );
        ensure!(
            self.parent_block() == self.certified_block(),
            "Genesis QC merge validation: parent must equal certified block"
        );
    }
    
    Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
}
```

Apply the same fix to `WrappedLedgerInfo::create_merged_with_executed_state()`: [4](#0-3) 

## Proof of Concept

```rust
#[test]
fn test_genesis_qc_merge_invariant_violation() {
    use aptos_consensus_types::quorum_cert::QuorumCert;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        aggregate_signature::AggregateSignature,
        validator_verifier::ValidatorVerifier,
    };
    use aptos_bitvec::BitVec;
    use aptos_crypto::HashValue;
    
    // Create a genesis ledger info (from end of previous epoch)
    let prev_epoch_li = LedgerInfo::new(
        BlockInfo::new(0, 100, HashValue::random(), HashValue::random(), 1000, 1000, None),
        HashValue::random(),
    );
    
    let genesis_id = HashValue::random();
    
    // Create genesis QC using the official function
    let genesis_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
        &prev_epoch_li,
        genesis_id,
    );
    
    // Verify it's a valid genesis QC (round 0, no signatures)
    assert_eq!(genesis_qc.certified_block().round(), 0);
    assert_eq!(genesis_qc.ledger_info().get_num_voters(), 0);
    
    // Create a malicious executed_ledger_info with SAME block info but WITH signatures
    let malicious_executed_li = LedgerInfoWithSignatures::new(
        genesis_qc.ledger_info().ledger_info().clone(),
        AggregateSignature::new(BitVec::with_num_bits(4), Some(/* fake sig */)),
    );
    
    // This should FAIL but currently only checks match_ordered_only()
    let merged_qc = genesis_qc.create_merged_with_executed_state(malicious_executed_li);
    
    // The merged QC would have round 0 BUT num_voters > 0
    if let Ok(invalid_qc) = merged_qc {
        assert_eq!(invalid_qc.certified_block().round(), 0);
        // This violates the invariant: round 0 must have 0 signatures
        assert!(invalid_qc.ledger_info().get_num_voters() > 0);
        
        // This QC would FAIL verification
        // verify() would return error: "Genesis QC should not carry signatures"
    }
}
```

**Note**: This PoC demonstrates the missing validation conceptually. In practice, I could not find a production code path where an attacker could actually trigger this merge with malicious parameters, which is why the current exploitability is assessed as very low.

---

**Notes**: This is a defensive programming issue rather than an immediately exploitable vulnerability. The missing validation represents a gap in defense-in-depth for critical consensus components. While current code paths appear safe, the lack of explicit validation at the merge point creates unnecessary risk for future code evolution.

### Citations

**File:** consensus/consensus-types/src/quorum_cert.rs (L84-117)
```rust
    pub fn certificate_for_genesis_from_ledger_info(
        ledger_info: &LedgerInfo,
        genesis_id: HashValue,
    ) -> QuorumCert {
        let ancestor = BlockInfo::new(
            ledger_info
                .epoch()
                .checked_add(1)
                .expect("Integer overflow when creating cert for genesis from ledger info"),
            0,
            genesis_id,
            ledger_info.transaction_accumulator_hash(),
            ledger_info.version(),
            ledger_info.timestamp_usecs(),
            None,
        );

        let vote_data = VoteData::new(ancestor.clone(), ancestor.clone());
        let li = LedgerInfo::new(ancestor, vote_data.hash());

        let validator_set_size = ledger_info
            .next_epoch_state()
            .expect("Next epoch state not found in ledger info")
            .verifier
            .len();

        QuorumCert::new(
            vote_data,
            LedgerInfoWithSignatures::new(
                li,
                AggregateSignature::new(BitVec::with_num_bits(validator_set_size as u16), None),
            ),
        )
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L128-141)
```rust
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L150-163)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<QuorumCert> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L110-123)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<WrappedLedgerInfo> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** consensus/src/pending_votes.rs (L275-328)
```rust
    pub fn insert_vote(
        &mut self,
        vote: &Vote,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        // derive data from vote
        let li_digest = vote.ledger_info().hash();

        //
        // 1. Has the author already voted for this round?
        //

        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }

        //
        // 2. Store new vote (or update, in case it's a new timeout vote)
        //

        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));

        //
        // 3. Let's check if we can create a QC
        //

        let len = self.li_digest_to_votes.len() + 1;
        // obtain the ledger info with signatures associated to the vote's ledger info
        let (hash_index, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            (
                len,
                VoteStatus::NotEnoughVotes(SignatureAggregator::new(vote.ledger_info().clone())),
            )
```
