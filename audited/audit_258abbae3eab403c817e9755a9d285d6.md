# Audit Report

## Title
Missing Public Parameter Validation in DKG Convert::to() Implementations Allows Silent Cryptographic Failures

## Summary
The `Convert::to()` implementations in the DKG (Distributed Key Generation) module do not validate public parameters before using them. Combined with an empty `Valid::check()` implementation, this allows invalid public parameters (specifically, an identity element as the commitment base) to produce incorrect cryptographic results without error, potentially breaking the entire DKG protocol.

## Finding Description

The DKG system has multiple vulnerabilities in its public parameter handling:

**1. Empty Validation in PublicParameters:** [1](#0-0) 

The `Valid::check()` method performs no validation whatsoever, allowing any deserialized public parameters to be accepted as valid.

**2. Unvalidated Convert::to() for Scalar:** [2](#0-1) 

This implementation completely ignores the public parameters, accepting them without validation. While this specific conversion may seem harmless, it sets a pattern of no validation.

**3. Unvalidated Convert::to() for DealtPubKey:** [3](#0-2) 

This implementation uses `pp.get_commitment_base()` (G_2) without verifying it's not the identity element. If G_2 is the identity element, then for ANY input secret `s`, the computation `G_2 * s = identity * s = identity`, causing all dealt public keys to be identical regardless of input.

**4. Usage in Critical Path:** [4](#0-3) 

The unvalidated conversion is used in production code to derive dealt secrets from input secrets. [5](#0-4) 

**5. Arkworks Allows Identity Elements:** [6](#0-5) 

The test explicitly includes `G1Affine::zero()` and `G2Affine::zero()` (identity elements) and expects serialization/deserialization to succeed. This confirms that arkworks' `Validate::Yes` mode checks curve membership but NOT whether points are the identity element.

**Attack Scenario:**

While public parameters are currently generated securely via `default_with_bls_base()`, the deserialization path exists: [7](#0-6) 

If an attacker could inject malformed public parameters (through future code changes, storage compromise, or configuration vulnerabilities), the following would occur:

1. Malicious `PublicParameters` with `G_2 = identity element` are deserialized
2. Arkworks validation passes (identity is a valid curve point)
3. `Valid::check()` is empty, so no additional validation occurs
4. During DKG dealing, `aggregated_secret.to(pp)` computes `dpk = identity * secret = identity`
5. All dealt public keys become identical (the identity element)
6. DKG security is completely broken - there are no unique secrets to share

## Impact Explanation

**Current Risk: Medium to High** - While there's no immediate exploitation path, this represents a critical defense-in-depth failure. The code accepts cryptographically invalid parameters without error, which violates the **Cryptographic Correctness** invariant.

**Potential Future Risk: Critical** - If any future change introduces deserialization of public parameters from external sources (network, storage, configuration), this becomes a critical vulnerability enabling:
- Complete DKG failure
- Consensus randomness generation compromise  
- Validator set operation failures
- Potential consensus safety violations

This meets **High Severity** criteria per Aptos bug bounty: "Significant protocol violations" - the DKG protocol would fail completely with invalid parameters accepted silently.

## Likelihood Explanation

**Current Likelihood: Low** - Public parameters are generated internally via secure methods, not loaded from external sources.

**Future Likelihood: Medium to High** - Any code change that introduces:
- Loading parameters from persistent storage
- Accepting parameters from network messages
- Configuration-based parameter initialization

Would immediately make this exploitable. Given the complexity of the codebase and ongoing development, such changes are plausible.

## Recommendation

**1. Implement comprehensive validation in `Valid::check()`:**

```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        // Validate G_2 is not the identity element
        if self.G_2.is_zero() {
            return Err(SerializationError::InvalidData);
        }
        
        // Validate ell is reasonable
        if self.ell == 0 || self.ell > 32 {
            return Err(SerializationError::InvalidData);
        }
        
        // Validate encryption parameters
        if self.pp_elgamal.G.is_zero() || self.pp_elgamal.H.is_zero() {
            return Err(SerializationError::InvalidData);
        }
        
        // Ensure G and H are different
        if self.pp_elgamal.G == self.pp_elgamal.H {
            return Err(SerializationError::InvalidData);
        }
        
        Ok(())
    }
}
```

**2. Add validation in Convert::to() implementations:**

```rust
impl<E: Pairing> traits::Convert<keys::DealtPubKey<E>, PublicParameters<E>>
    for InputSecret<E::ScalarField>
{
    fn to(&self, pp: &PublicParameters<E>) -> keys::DealtPubKey<E> {
        // Validate commitment base is not identity
        assert!(!pp.get_commitment_base().is_zero(), 
                "Invalid public parameters: G_2 is identity element");
        
        keys::DealtPubKey::new(
            pp.get_commitment_base()
                .mul(self.get_secret_a())
                .into_affine(),
        )
    }
}
```

**3. Call validation after deserialization:**
Ensure `Valid::check()` is called immediately after any deserialization of public parameters.

## Proof of Concept

```rust
#[cfg(test)]
mod test_invalid_params {
    use super::*;
    use ark_bls12_381::Bls12_381;
    use ark_ec::Group;
    
    #[test]
    #[should_panic(expected = "Invalid public parameters")]
    fn test_identity_commitment_base_rejected() {
        type E = Bls12_381;
        
        // Create parameters with identity element as G_2
        let mut pp = PublicParameters::<E>::default();
        pp.G_2 = <E as Pairing>::G2Affine::zero(); // Identity element
        
        // This should fail validation but currently doesn't
        assert!(pp.check().is_ok()); // BUG: passes when it shouldn't
        
        // Create an input secret
        let secret = InputSecret::<E::ScalarField>::generate(&mut rand::thread_rng());
        
        // Convert to dealt public key - this will produce identity for ANY secret
        let dpk1: keys::DealtPubKey<E> = secret.to(&pp);
        
        // Create different secret
        let secret2 = InputSecret::<E::ScalarField>::generate(&mut rand::thread_rng());
        let dpk2: keys::DealtPubKey<E> = secret2.to(&pp);
        
        // BUG: Both public keys are identical (identity) despite different secrets!
        assert_eq!(dpk1.as_g2(), dpk2.as_g2());
        assert!(dpk1.as_g2().is_zero());
    }
}
```

**Notes:**
- This vulnerability represents a failure of defensive programming rather than an immediately exploitable bug
- The security impact depends on whether future code changes introduce untrusted deserialization paths
- The empty `Valid::check()` combined with no validation in cryptographic operations violates security best practices
- Arkworks' validation does NOT reject identity elements, only invalid curve points

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L120-124)
```rust
impl<E: Pairing> Valid for PublicParameters<E> {
    fn check(&self) -> Result<(), SerializationError> {
        Ok(())
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L134-146)
```rust
impl<E: Pairing> traits::Convert<keys::DealtPubKey<E>, PublicParameters<E>>
    for InputSecret<E::ScalarField>
{
    /// Computes the public key associated with the given input secret.
    /// NOTE: In the SCRAPE PVSS, a `DealtPublicKey` cannot be computed from a `DealtSecretKey` directly.
    fn to(&self, pp: &PublicParameters<E>) -> keys::DealtPubKey<E> {
        keys::DealtPubKey::new(
            pp.get_commitment_base()
                .mul(self.get_secret_a())
                .into_affine(),
        )
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L149-156)
```rust
impl<E: Pairing> TryFrom<&[u8]> for PublicParameters<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<PublicParameters<E>>(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/input_secret.rs (L54-60)
```rust
impl<E: Pairing> Convert<Scalar<E::ScalarField>, PublicParameters<E>>
    for InputSecret<E::ScalarField>
{
    fn to(&self, _with: &PublicParameters<E>) -> Scalar<E::ScalarField> {
        Scalar(*self.get_secret_a())
    }
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L234-239)
```rust
    fn dealt_secret_from_input(
        pub_params: &Self::PublicParams,
        input: &Self::InputSecret,
    ) -> Self::DealtSecret {
        input.to(&pub_params.pvss_config.pp)
    }
```

**File:** crates/aptos-dkg/src/pvss/test_utils.rs (L145-151)
```rust
    let mut aggregated_secret = T::InputSecret::zero();
    for is in &iss {
        aggregated_secret.add_assign(is);
    }

    let dpk = aggregated_secret.to(pp);
    let dsk = aggregated_secret.to(pp);
```

**File:** crates/aptos-crypto/src/arkworks/serialization.rs (L72-107)
```rust
        let mut points = vec![G1Affine::zero()]; // Include zero
        let mut g = G1Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G1 point round-trip failed for {:?}", p);
        }
    }

    #[test]
    fn test_g2_serialization_multiple_points() {
        #[derive(Serialize, Deserialize, PartialEq, Debug)]
        struct A(#[serde(serialize_with = "ark_se", deserialize_with = "ark_de")] G2Affine);

        let mut points = vec![G2Affine::zero()]; // Include zero
        let mut g = G2Projective::generator();

        for _ in 0..MAX_DOUBLINGS {
            points.push(g.into());
            g += g; // double for next
        }

        for p in points {
            let serialized = bcs::to_bytes(&A(p)).expect("Serialization failed");
            let deserialized: A = bcs::from_bytes(&serialized).expect("Deserialization failed");

            assert_eq!(deserialized.0, p, "G2 point round-trip failed for {:?}", p);
        }
    }
```
