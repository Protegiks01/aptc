# Audit Report

## Title
Config Buffer Race Condition Allows Governance Proposal Overwrites During DKG Reconfiguration

## Summary
A race condition in the epoch reconfiguration mechanism allows subsequently executed governance proposals to silently overwrite configuration changes from earlier approved proposals during Distributed Key Generation (DKG). When multiple consensus configuration governance proposals are executed while a DKG session is in progress, only the last proposal's configuration is applied, violating governance integrity and potentially compromising consensus security.

## Finding Description

The vulnerability exists in the interaction between the config buffering system and the DKG-based reconfiguration mechanism. The issue occurs in the following sequence: [1](#0-0) 

This Rust code generator creates governance proposal scripts that call `consensus_config::set_for_next_epoch()` followed by `aptos_governance::reconfigure()`. The vulnerability arises from how these functions interact with the config buffer and DKG state machine.

**Step 1: Config Buffer Overwrite** [2](#0-1) 

The `set_for_next_epoch()` function uses `config_buffer::upsert()` to buffer the configuration: [3](#0-2) 

The critical issue is that `simple_map::upsert()` replaces any existing buffered value: [4](#0-3) 

**Step 2: DKG Early Return** [5](#0-4) 

When `reconfigure()` is called and DKG is enabled, it calls `try_start()`: [6](#0-5) 

If a DKG session already exists for the current epoch, `try_start()` returns immediately without triggering a new reconfiguration. This means:
- Transaction 1: Buffers config_A, starts DKG
- Transaction 2: **Overwrites buffer with config_B**, but `try_start()` exits early
- DKG completes: Applies **config_B** instead of config_A

**Step 3: Wrong Config Applied** [7](#0-6) 

When DKG finishes, it applies the buffered config: [8](#0-7) 

The `extract_v2()` retrieves whatever is in the buffer, which is config_B from the second proposal, not config_A from the first approved proposal.

**No Protection Against Concurrent Executions**

There is no guard preventing governance proposal execution during reconfiguration: [9](#0-8) 

Unlike stake operations which check reconfiguration state, governance execution has no such protection.

## Impact Explanation

This is a **HIGH severity** vulnerability under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The core governance mechanism fails to execute approved proposals as intended, violating the fundamental assumption that governance decisions are deterministically applied.

2. **Consensus Configuration Manipulation**: An attacker who can get a governance proposal approved could deliberately front-run a legitimate consensus configuration change by submitting their own proposal immediately after the first one executes, knowing their configuration will be the one actually applied.

3. **Silent Failure**: There is no error, event, or indication that the first proposal's configuration was discarded. The blockchain state shows both proposals as "executed," but only the second one takes effect.

4. **Breaks Governance Integrity Invariant**: The documented invariant states "Voting power must be correctly calculated from stake" and implicitly that approved governance proposals execute their intended changes. This vulnerability violates that governance decisions are faithfully executed.

## Likelihood Explanation

**HIGH likelihood** - This can occur through both natural operation and deliberate exploitation:

**Natural Occurrence:**
- Two legitimate governance proposals for consensus configuration updates are approved in close succession
- The first proposal executes and starts a DKG session (which can take several minutes)
- The second proposal executes before DKG completes
- Network operators expect both configurations to be applied in sequence, but only the second takes effect

**Deliberate Exploitation:**
- Attacker monitors governance proposals and identifies a critical consensus configuration update being voted on
- Attacker submits their own malicious configuration proposal with sufficient stake backing
- When the legitimate proposal executes and starts DKG, attacker immediately executes their proposal
- Attacker's configuration overwrites the legitimate one in the buffer
- When DKG completes, attacker's configuration is applied instead

**Feasibility:**
- Requires only governance participation (sufficient stake to propose)
- No validator insider access needed
- Timing window is large (DKG sessions can take minutes)
- No technical sophistication required beyond standard governance operations

## Recommendation

Implement reconfiguration guards in governance proposal execution to prevent multiple config changes during an active reconfiguration:

**Option 1: Lock Config Buffer During DKG**

Add a check in `consensus_config::set_for_next_epoch()`:
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**Option 2: Queue Multiple Configs**

Modify the config buffer to support queuing multiple pending configs rather than overwriting, ensuring all approved proposals are applied in order across successive epochs.

**Option 3: Atomic Config Application**

Add versioning to the config buffer tied to specific governance proposal IDs, preventing overwrites and ensuring each approved proposal gets its own epoch transition.

**Recommended Fix:** Option 1 is the simplest and most secure. Add the reconfiguration guard to all `set_for_next_epoch()` variants across all config modules (consensus_config, execution_config, gas_schedule, etc.).

## Proof of Concept

```move
#[test_only]
module aptos_framework::governance_config_race_test {
    use aptos_framework::consensus_config;
    use aptos_framework::aptos_governance;
    use aptos_framework::reconfiguration_with_dkg;
    use aptos_framework::config_buffer;
    use std::features;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_config_overwrite_during_dkg(aptos_framework: &signer) {
        // Setup: Initialize system with DKG enabled
        // (Assuming proper genesis initialization)
        
        // Step 1: Execute governance proposal 1 with config_A
        let config_a = vector[0xAA, 0xBB, 0xCC];
        consensus_config::set_for_next_epoch(aptos_framework, config_a);
        aptos_governance::reconfigure(aptos_framework);
        
        // At this point, DKG has started and config_a is in the buffer
        assert!(config_buffer::does_exist<consensus_config::ConsensusConfig>(), 1);
        
        // Step 2: Execute governance proposal 2 with config_b BEFORE DKG completes
        let config_b = vector[0xDD, 0xEE, 0xFF];
        consensus_config::set_for_next_epoch(aptos_framework, config_b);
        // This overwrites config_a in the buffer!
        
        aptos_governance::reconfigure(aptos_framework);
        // This call does nothing because DKG is already in progress
        
        // Step 3: Simulate DKG completion
        // When DKG finishes and reconfiguration_with_dkg::finish() is called,
        // consensus_config::on_new_epoch() will extract config_b, NOT config_a
        
        // Expected: config_a should be applied (first approved proposal)
        // Actual: config_b will be applied (last written to buffer)
        // This violates governance integrity!
    }
}
```

**Notes:**
- This vulnerability affects all configuration types that use the config buffer pattern: `ConsensusConfig`, `ExecutionConfig`, `GasScheduleV2`, `Version`, `Features`, `JWKConsensusConfig`, `JWKs`, `KeylessConfiguration`, `RandomnessConfigSeqNum`, `RandomnessConfig`, and `RandomnessApiV0Config`
- The issue is specific to the DKG reconfiguration path; immediate reconfigurations (when DKG is disabled) are protected by the timestamp guard in `reconfiguration::reconfigure()`
- The vulnerability window extends for the entire duration of a DKG session, which can be several minutes to hours depending on network conditions
- Multiple governance proposals executing during the same DKG session will result in only the last one's configuration being applied

### Citations

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L40-46)
```rust
            emitln!(
                writer,
                "consensus_config::set_for_next_epoch({}, consensus_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-69)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L125-129)
```text
            if (&element.key == &key) {
                data.push_back(Element { key, value });
                data.swap(i, len);
                let Element { key, value } = data.pop_back();
                return (std::option::some(key), std::option::some(value))
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L634-641)
```text
    public fun resolve(
        proposal_id: u64,
        signer_address: address
    ): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {
        voting::resolve<GovernanceProposal>(@aptos_framework, proposal_id);
        remove_approved_hash(proposal_id);
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```
