# Audit Report

## Title
Failed Transaction Cleanup Discards Transactions Without Charging Gas, Enabling DoS Attacks

## Summary
When transaction execution fails and the system attempts to charge gas via the failure epilogue, any error in `finish_aborted_transaction` causes the transaction to be discarded without charging gas. This directly contradicts the developers' stated design principle that discarding failed transactions enables DoS attacks, as evidenced by their own code comments.

## Finding Description

The transaction execution flow documented in `aptos-move/aptos-vm/src/lib.rs` specifies that when execution fails, the system should "keep, only charge gas." However, the implementation in `failed_transaction_cleanup` contains a critical flaw: [1](#0-0) 

When `finish_aborted_transaction` returns an error (for ANY reason), the `.unwrap_or_else` handler calls `discarded_output`, which creates a `TransactionStatus::Discard` output. This means the transaction is discarded and **no gas is charged**, despite having already consumed network resources during execution.

The developers explicitly acknowledge this risk in their code comments: [2](#0-1) 

The comment states: "Option (2) [discard] does not work, since it would enable DoS attacks." Yet line 623 implements exactly this "option 2" as a fallback.

The `finish_aborted_transaction` function can fail in several scenarios:

1. **Epilogue execution failure** - If the Move epilogue function encounters any error: [3](#0-2) 

2. **Gas parameter loading failure** - If gas params cannot be loaded: [4](#0-3) 

3. **Session finalization failure** - If epilogue session cannot be finalized: [5](#0-4) 

When the epilogue fails, `expect_only_successful_execution` converts any error to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION`: [6](#0-5) 

The Move epilogue performs balance checks before burning gas: [7](#0-6) 

If the balance check at lines 609-618 fails, the epilogue aborts with `PROLOGUE_ECANT_PAY_GAS_DEPOSIT`, propagating the error up the call stack and ultimately causing transaction discard.

## Impact Explanation

This vulnerability enables **High Severity** DoS attacks as defined in the Aptos bug bounty program:
- **Validator node slowdowns**: Attackers can submit transactions that consume CPU, memory, and bandwidth without paying gas fees
- **Significant protocol violations**: The fundamental economic model of gas payment is bypassed

The impact includes:
- Validators process transactions without compensation
- Network resources exhausted by free spam transactions  
- Economic security model undermined
- Potential for sustained network degradation

## Likelihood Explanation

While the code path for discarding without gas charge is confirmed, the likelihood depends on triggering epilogue failures. Scenarios include:

1. **Parallel execution race conditions** (Block-STM): If transactions from the same account execute concurrently and one depletes the balance before another's epilogue runs
2. **VM internal errors**: Session finalization failures, change set squashing errors, or storage allocation violations
3. **System failures**: Gas parameter loading failures during high load

The vulnerability is more likely to manifest during:
- High transaction throughput periods
- Parallel execution with Block-STM
- Network stress conditions
- Edge cases in VM state management

## Recommendation

Replace the `.unwrap_or_else` fallback with a forced gas charge mechanism. If the epilogue fails, the system should attempt to charge gas using fallback methods rather than discarding:

```rust
let output = self
    .finish_aborted_transaction(
        prologue_session_change_set,
        gas_meter,
        txn_data,
        resolver,
        module_storage,
        serialized_signers,
        status,
        log_context,
        change_set_configs,
        traversal_context,
    )
    .unwrap_or_else(|epilogue_error| {
        // CRITICAL: Never discard without charging gas - this enables DoS
        // Instead, attempt forced gas charge with best-effort state
        self.force_charge_gas_on_epilogue_failure(
            gas_meter,
            txn_data,
            error_vm_status.clone(),
            epilogue_error,
            log_context,
        )
    });
```

Implement `force_charge_gas_on_epilogue_failure` to:
1. Log the epilogue failure as a critical error
2. Calculate minimum gas charge based on execution consumed
3. Create a Keep output with the gas charge, even if state changes are partial
4. Include metrics/alerts for monitoring epilogue failure rates

## Proof of Concept

```rust
// PoC: Demonstrate epilogue failure leading to no gas charge
// This would require triggering one of the epilogue failure conditions

use aptos_types::transaction::{TransactionStatus, SignedTransaction};
use move_core_types::vm_status::StatusCode;

#[test]
fn test_epilogue_failure_no_gas_charge() {
    // Setup: Create a transaction that will fail during execution
    // but should still charge gas
    
    let txn = create_failing_transaction();
    
    // Execute the transaction through the VM
    let output = vm.execute_transaction(txn);
    
    // Expected: Transaction should be Kept with gas charged
    // Actual: If epilogue fails, transaction is Discarded with no gas
    
    match output.status() {
        TransactionStatus::Keep(_) => {
            // Verify gas was charged
            assert!(output.gas_used() > 0, "Gas should be charged");
        },
        TransactionStatus::Discard(code) => {
            panic!("Transaction discarded without charging gas! Status: {:?}", code);
        },
        _ => panic!("Unexpected status"),
    }
}
```

**Notes**

The vulnerability exists in the code structure and violates the stated design principle that "discarding failed transactions enables DoS attacks." While demonstrating reliable exploitation requires specific conditions (epilogue failures), the code path is confirmed and the risk is acknowledged by the developers themselves in their comments. The system should never discard a transaction without charging gas once execution has begun, as this fundamentally breaks the economic security model.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L574-594)
```rust
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // Since we are already in the failure epilogue, there is not much we can do
            // other than logging the inconsistency.
            //
            // This is a tradeoff. We have to either
            //   1. Continue to calculate the gas cost based on the numbers we have.
            //   2. Discard the transaction.
            //
            // Option (2) does not work, since it would enable DoS attacks.
            // Option (1) is not ideal, but optimistically, it should allow the network
            // to continue functioning, less the transactions that run into this problem.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][failure-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L610-624)
```rust
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L760-760)
```rust
            let gas_params = self.gas_params(log_context)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L807-820)
```rust
        epilogue_session.execute(|session| {
            transaction_validation::run_failure_epilogue(
                session,
                module_storage,
                serialized_signers,
                gas_meter.balance(),
                fee_statement,
                self.features(),
                txn_data,
                log_context,
                traversal_context,
                self.is_simulation,
            )
        })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L821-821)
```rust
        epilogue_session.finish(fee_statement, status, change_set_configs, module_storage)
```

**File:** aptos-move/aptos-vm/src/errors.rs (L275-305)
```rust
pub fn expect_only_successful_execution(
    error: VMError,
    function_name: &str,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let status = error.into_vm_status();
    Err(match status {
        VMStatus::Executed => VMStatus::Executed,
        // Speculative errors are returned for caller to handle.
        e @ VMStatus::Error {
            status_code:
                StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
                | StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
            ..
        } => e,
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
    })
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L596-627)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;

        // it's important to maintain the error code consistent with vm
        // to do failed transaction cleanup.
        if (!skip_gas_payment(is_simulation, gas_payer)) {
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            };

            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer, burn_amount);
            } else if (transaction_fee_amount < storage_fee_refunded) {
                let mint_amount = storage_fee_refunded - transaction_fee_amount;
                transaction_fee::mint_and_refund(gas_payer, mint_amount);
            };
        };
```
