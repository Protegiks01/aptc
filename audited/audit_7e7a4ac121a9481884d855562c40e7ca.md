# Audit Report

## Title
Lack of Versioning in DKG PublicParameters Enables Consensus Split During Rolling Upgrades

## Summary
The DKG system's PublicParameters structures lack version fields, allowing different validators to derive incompatible cryptographic parameter sets during rolling upgrades if the hardcoded DST or SEED constants are modified. This breaks the deterministic execution invariant and can cause consensus disagreement.

## Finding Description

The weighted VUF and PVSS PublicParameters structures have no version field to identify which parameter set is in use. The parameters are derived deterministically from hardcoded constants: [1](#0-0) 

During DKG transcript generation and verification, validators call `DefaultDKG::new_public_params()` which creates parameters using these constants: [2](#0-1) 

The PublicParameters structures contain no version field: [3](#0-2) [4](#0-3) [5](#0-4) 

The on-chain `DKGSessionMetadata` also does not store the cryptographic parameters: [6](#0-5) 

During transcript verification in the VM, parameters are reconstructed from the same constants: [7](#0-6) 

The verification uses the derived group elements directly: [8](#0-7) 

**Attack Scenario:**
1. Aptos releases version N+1 that changes `DST_PVSS_PUBLIC_PARAMS` or `SEED_PVSS_PUBLIC_PARAMS` for security reasons
2. During rolling upgrade, some validators run version N (old constants), others run N+1 (new constants)
3. For the same `DKGSessionMetadata`, validators derive different group elements (g₁, g₂)
4. Version N validator creates transcript using g₂_old
5. Version N+1 validator verifies with g₂_new
6. Verification fails even for valid transcripts, or accepts invalid transcripts
7. Consensus cannot be reached on DKG completion

This violates the **Deterministic Execution** invariant - validators with identical on-chain state produce different verification results based solely on their software version.

## Impact Explanation

**Medium Severity**: "State inconsistencies requiring intervention"

During a rolling upgrade with modified cryptographic constants, the network would experience:
- DKG transcripts rejected by some validators, accepted by others
- Inability to complete DKG sessions and generate randomness
- Potential epoch transition failures
- Requires manual coordination to revert all validators to same version

This does not cause direct fund loss or permanent network partition (can be resolved by version synchronization), but requires operational intervention and disrupts randomness generation, which is critical for leader election and potentially other protocol features.

## Likelihood Explanation

**Medium Likelihood**: While developers would not intentionally change these constants without careful planning, the lack of versioning creates fragility:
- Security updates might require new domain separation tags
- Hash-to-curve algorithm updates could change parameter derivation
- No compile-time or runtime checks prevent this failure mode
- Easy to overlook during code review since the constants appear disconnected from the upgrade mechanism

The vulnerability makes the system unnecessarily fragile to what should be routine cryptographic parameter updates.

## Recommendation

Add a version field to all PublicParameters structures and include it in on-chain DKGSessionMetadata:

```rust
// In pvss/das/public_parameters.rs
#[derive(DeserializeKey, Clone, SerializeKey, Debug, PartialEq, Eq)]
pub struct PublicParameters {
    version: u64,  // Add this
    enc: encryption_elgamal::g1::PublicParameters,
    g_2: G2Projective,
}

// In weighted_vuf/bls/mod.rs
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct PublicParameters {
    version: u64,  // Add this
    g: G2Projective,
}
```

Store the version on-chain:
```move
// In dkg.move
struct DKGSessionMetadata has copy, drop, store {
    dealer_epoch: u64,
    randomness_config: RandomnessConfig,
    dealer_validator_set: vector<ValidatorConsensusInfo>,
    target_validator_set: vector<ValidatorConsensusInfo>,
    dkg_params_version: u64,  // Add this
}
```

During transcript verification, validate the version matches:
```rust
// In validator_txns/dkg.rs
let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
let transcript = bcs::from_bytes(...)?;

// Add version check
if transcript.params_version() != pub_params.version() {
    return Err(Expected(ParameterVersionMismatch));
}
```

This ensures all validators agree on which parameter set to use before attempting cryptographic operations.

## Proof of Concept

```rust
// Simulation showing parameter mismatch during rolling upgrade
#[test]
fn test_parameter_version_mismatch() {
    use aptos_dkg::pvss::das::PublicParameters;
    
    // Validator A uses old constants
    const OLD_DST: &[u8] = b"APTOS_DISTRIBUTED_RANDOMNESS_DST";
    const OLD_SEED: &[u8] = b"APTOS_DISTRIBUTED_RANDOMNESS_SEED";
    
    // Validator B uses new constants (hypothetical upgrade)
    const NEW_DST: &[u8] = b"APTOS_DISTRIBUTED_RANDOMNESS_DST_V2";
    const NEW_SEED: &[u8] = b"APTOS_DISTRIBUTED_RANDOMNESS_SEED";
    
    // Both validators create params from "same" metadata
    let params_old = PublicParameters::new_from_seed(OLD_SEED);
    let params_new = PublicParameters::new_from_seed(NEW_SEED);
    
    // Parameters differ - no way to detect this at runtime
    assert_ne!(params_old, params_new);
    assert_ne!(
        params_old.get_commitment_base(), 
        params_new.get_commitment_base()
    );
    
    // Both validators would verify the same transcript with different bases
    // leading to consensus disagreement
}
```

## Notes

This vulnerability is classified as operational/upgrade safety rather than external exploitation. It does not require a malicious actor - it manifests during legitimate software upgrades when cryptographic parameters evolve. The lack of versioning violates defense-in-depth principles and makes the protocol unnecessarily fragile to maintenance operations.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/public_parameters.rs (L23-25)
```rust
pub const DST_PVSS_PUBLIC_PARAMS: &[u8; 32] = b"APTOS_DISTRIBUTED_RANDOMNESS_DST";
/// "Nothing up my sleeve" seed to deterministically-derive the public parameters.
pub const SEED_PVSS_PUBLIC_PARAMS: &[u8; 33] = b"APTOS_DISTRIBUTED_RANDOMNESS_SEED";
```

**File:** crates/aptos-dkg/src/pvss/das/public_parameters.rs (L28-34)
```rust
#[derive(DeserializeKey, Clone, SerializeKey, Debug, PartialEq, Eq)]
pub struct PublicParameters {
    /// Encryption public parameters
    enc: encryption_elgamal::g1::PublicParameters,
    /// Base for the commitments to the polynomial evaluations (and for the dealt public key [shares])
    g_2: G2Projective,
}
```

**File:** types/src/dkg/real_dkg/mod.rs (L129-129)
```rust
    let pp = DkgPP::default_with_bls_base();
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L24-27)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct PublicParameters {
    g: G2Projective,
}
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L44-49)
```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PublicParameters {
    g: G1Projective,
    g_neg: G1Projective,
    g_hat: G2Projective,
}
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L18-23)
```text
    struct DKGSessionMetadata has copy, drop, store {
        dealer_epoch: u64,
        randomness_config: RandomnessConfig,
        dealer_validator_set: vector<ValidatorConsensusInfo>,
        target_validator_set: vector<ValidatorConsensusInfo>,
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L105-112)
```rust
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L300-301)
```rust
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
```
