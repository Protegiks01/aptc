# Audit Report

## Title
BatchInfo Persistence Allows Zero-Transaction Batches Violating PayloadTxnsSize Invariant and Enabling Quota Exhaustion

## Summary
The consensus quorum store allows persisting `BatchInfo` structures with `num_txns=0` and `num_bytes>0`, violating the documented `PayloadTxnsSize` invariant that requires `(count > 0 && bytes > 0) || (count == 0 && bytes == 0)`. This enables malicious validators to exhaust peer quota without contributing transactions and creates accounting inconsistencies between transaction counts and byte consumption.

## Finding Description

The `BatchInfo` structure stores batch metadata including `num_txns` and `num_bytes` fields that should satisfy the `PayloadTxnsSize` invariant documented in `consensus/consensus-types/src/utils.rs`: [1](#0-0) 

However, `BatchInfo` construction accepts raw `u64` values without validation: [2](#0-1) 

When a `BatchPayload` is created with an empty transaction vector, it produces `num_txns=0` but `num_bytes>0` due to serialization overhead. The test suite confirms this: [3](#0-2) 

With `BATCH_PADDING_BYTES = 160`, an empty batch has approximately 33 bytes (`160 - 127 = 33`): [4](#0-3) 

**Attack Vector:**

A malicious validator can craft a `Batch` with zero transactions and send it to peers:

1. The `Batch::verify()` method only checks consistency between payload and `BatchInfo`, not minimum transaction counts: [5](#0-4) 

2. The `ensure_max_limits()` validation only checks upper bounds: [6](#0-5) 

3. The `BatchMsg::verify()` only ensures the batches vector is non-empty, not individual batch transaction counts: [7](#0-6) 

4. The batch is persisted via BCS serialization without validation: [8](#0-7) 

5. The persisted batch consumes quota based on `num_bytes`: [9](#0-8) 

6. But transaction tracking uses `num_txns`: [10](#0-9) 

This creates a discrepancy: quota is consumed (33 bytes) but zero transactions are counted.

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies requiring intervention:

1. **Quota Exhaustion Attack**: A malicious validator can flood peers with empty batches consuming `db_quota`, `memory_quota`, and `batch_quota` without providing actual transactions. With default configuration allowing multiple batches per message, an attacker could rapidly exhaust victim node quota.

2. **Accounting Inconsistency**: The system tracks transactions via `remaining_txns_with_duplicates` based on `num_txns` while consuming quota based on `num_bytes`, causing accounting mismatches that could affect backpressure mechanisms and resource management.

3. **Invariant Violation**: When `BatchInfo.size()` is called, it creates a `PayloadTxnsSize` that violates the documented invariant, triggering normalization with warnings but potentially causing confusion in size-based calculations.

While this doesn't directly cause consensus violations or fund loss, it enables resource exhaustion and creates state inconsistencies that require manual intervention to resolve, meeting the Medium severity criteria per Aptos bug bounty guidelines.

## Likelihood Explanation

**High Likelihood**: This vulnerability is straightforward to exploit:
- No special permissions required beyond being a validator in the current epoch
- No cryptographic operations to bypass
- Simple message construction using existing APIs
- Validation gap is clear and consistent across the codebase

The only mitigation is that local batch generation prevents empty batches via early return: [11](#0-10) 

However, this provides no protection against malicious remote batches.

## Recommendation

Add minimum transaction count validation in `Batch::verify()`:

```rust
pub fn verify(&self) -> anyhow::Result<()> {
    ensure!(
        self.num_txns() > 0,
        "Batch must contain at least one transaction"
    );
    ensure!(
        self.payload.author() == self.author(),
        "Payload author doesn't match the info"
    );
    // ... rest of validation
}
```

Alternatively, add validation in `BatchInfo::new()` to enforce the invariant at construction time, or add validation in `ensure_max_limits()` to check minimum bounds.

## Proof of Concept

```rust
#[test]
fn test_empty_batch_validation_bypass() {
    use aptos_types::PeerId;
    use aptos_consensus_types::common::BatchPayload;
    use aptos_types::quorum_store::BatchId;
    
    // Create empty batch payload
    let author = PeerId::random();
    let empty_payload = BatchPayload::new(author, vec![]);
    
    // Verify invariant violation
    assert_eq!(empty_payload.num_txns(), 0);
    assert!(empty_payload.num_bytes() > 0); // Will be ~33 bytes
    
    // Create batch with empty payload
    let batch = Batch::new(
        BatchId::new(1),
        vec![], // Empty transaction vector
        1,      // epoch
        1000000,// expiration
        author,
        0,      // gas_bucket_start
    );
    
    // This batch passes verification despite violating invariant
    assert!(batch.verify().is_ok());
    assert_eq!(batch.num_txns(), 0);
    assert!(batch.num_bytes() > 0);
    
    // PayloadTxnsSize invariant violation
    let size = batch.size();
    // size() will normalize to (0, 0) but logged a warning
}
```

### Citations

**File:** consensus/consensus-types/src/utils.rs (L10-12)
```rust
/// This struct always ensures the following invariants:
/// * count <= bytes
/// * (count > 0 && bytes > 0) || (count == 0 && bytes == 0)
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L60-81)
```rust
impl BatchInfo {
    pub fn new(
        author: PeerId,
        batch_id: BatchId,
        epoch: u64,
        expiration: u64,
        digest: HashValue,
        num_txns: u64,
        num_bytes: u64,
        gas_bucket_start: u64,
    ) -> Self {
        Self {
            author,
            batch_id,
            epoch,
            expiration,
            digest,
            num_txns,
            num_bytes,
            gas_bucket_start,
        }
    }
```

**File:** consensus/src/quorum_store/types.rs (L133-142)
```rust
    #[test]
    fn test_batch_payload_padding() {
        use super::*;
        let empty_batch_payload = BatchPayload::new(PeerId::random(), vec![]);
        // We overestimate the ULEB128 encoding of the number of transactions as 128 bytes.
        assert_eq!(
            empty_batch_payload.num_bytes() + 127,
            config::BATCH_PADDING_BYTES
        );
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** config/src/config/quorum_store_config.rs (L12-12)
```rust
pub const BATCH_PADDING_BYTES: usize = 160;
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L137-171)
```rust
    fn ensure_max_limits(&self, batches: &[Batch<BatchInfoExt>]) -> anyhow::Result<()> {
        let mut total_txns = 0;
        let mut total_bytes = 0;
        for batch in batches.iter() {
            ensure!(
                batch.num_txns() <= self.max_batch_txns,
                "Exceeds batch txn limit {} > {}",
                batch.num_txns(),
                self.max_batch_txns,
            );
            ensure!(
                batch.num_bytes() <= self.max_batch_bytes,
                "Exceeds batch bytes limit {} > {}",
                batch.num_bytes(),
                self.max_batch_bytes,
            );

            total_txns += batch.num_txns();
            total_bytes += batch.num_bytes();
        }
        ensure!(
            total_txns <= self.max_total_txns,
            "Exceeds total txn limit {} > {}",
            total_txns,
            self.max_total_txns,
        );
        ensure!(
            total_bytes <= self.max_total_bytes,
            "Exceeds total bytes limit: {} > {}",
            total_bytes,
            self.max_total_bytes,
        );

        Ok(())
    }
```

**File:** consensus/src/quorum_store/schema.rs (L38-46)
```rust
impl ValueCodec<BatchSchema> for PersistedValue<BatchInfo> {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}
```

**File:** consensus/src/quorum_store/batch_store.rs (L64-84)
```rust
    pub(crate) fn update_quota(&mut self, num_bytes: usize) -> anyhow::Result<StorageMode> {
        if self.batch_balance == 0 {
            counters::EXCEEDED_BATCH_QUOTA_COUNT.inc();
            bail!("Batch quota exceeded ");
        }

        if self.db_balance >= num_bytes {
            self.batch_balance -= 1;
            self.db_balance -= num_bytes;

            if self.memory_balance >= num_bytes {
                self.memory_balance -= num_bytes;
                Ok(StorageMode::MemoryAndPersisted)
            } else {
                Ok(StorageMode::PersistedOnly)
            }
        } else {
            counters::EXCEEDED_STORAGE_QUOTA_COUNT.inc();
            bail!("Storage quota exceeded ");
        }
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L101-118)
```rust
    fn inc_remaining_proofs(&mut self, author: &PeerId, num_txns: u64) {
        self.remaining_txns_with_duplicates += num_txns;
        self.remaining_proofs += 1;
        if *author == self.my_peer_id {
            self.remaining_local_txns += num_txns;
            self.remaining_local_proofs += 1;
        }
    }

    #[inline]
    fn dec_remaining_proofs(&mut self, author: &PeerId, num_txns: u64) {
        self.remaining_txns_with_duplicates -= num_txns;
        self.remaining_proofs -= 1;
        if *author == self.my_peer_id {
            self.remaining_local_txns -= num_txns;
            self.remaining_local_proofs -= 1;
        }
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L364-372)
```rust
        if pulled_txns.is_empty() {
            counters::PULLED_EMPTY_TXNS_COUNT.inc();
            // Quorum store metrics
            counters::CREATED_EMPTY_BATCHES_COUNT.inc();

            counters::EMPTY_BATCH_CREATION_DURATION
                .observe_duration(self.last_end_batch_time.elapsed());
            self.last_end_batch_time = Instant::now();
            return vec![];
```
