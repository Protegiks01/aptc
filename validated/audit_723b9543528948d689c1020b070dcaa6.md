# Audit Report

## Title
Unvalidated Storage Summaries Enable Subscription DoS Attack via False Data Advertisements

## Summary
Malicious peers can send storage summaries containing `LedgerInfoWithSignatures` with arbitrarily high version numbers and invalid signatures. These unvalidated summaries are aggregated into the global data summary, causing honest nodes' subscription streams to repeatedly trigger `SubscriptionStreamIsLagging` errors, forcing perpetual subscription resets and degrading sync performance to non-optimized fallback modes.

## Finding Description

The state sync system polls peers for their storage summaries to determine what data is available in the network. When a peer responds with a `StorageServerSummary`, the `synced_ledger_info` field (a `LedgerInfoWithSignatures`) is accepted and aggregated into the global data summary without any cryptographic signature verification.

The storage summary is directly passed to `update_peer_storage_summary` without validation in the poller: [1](#0-0) 

This summary is stored directly without any validation checks: [2](#0-1) 

The summary is then aggregated into the global data summary where the highest version across all peers becomes the `highest_synced_ledger_info`: [3](#0-2) [4](#0-3) 

A malicious peer can construct a fake `LedgerInfoWithSignatures` with an arbitrarily high version using the public constructor, which accepts any `LedgerInfo` and `AggregateSignature` without validation: [5](#0-4) 

The `AggregateSignature` can be constructed with empty signatures: [6](#0-5) 

While `LedgerInfoWithSignatures` has a `verify_signatures()` method, it is never called when processing storage summaries: [7](#0-6) 

When processing subscription responses, the system checks for lag by comparing the highest response version against the highest advertised version from the global data summary: [8](#0-7) 

If the lag exceeds the configured threshold (`max_subscription_stream_lag_secs`, default 10 seconds) and increases, the subscription is deemed "beyond recovery": [9](#0-8) 

This triggers a `SubscriptionStreamIsLagging` error: [10](#0-9) 

The network architecture confirms that Validator Full Nodes accept connections from any public clients, not just trusted peers: [11](#0-10) 

**Attack Scenario:**

1. Malicious full node connects to the public network
2. Creates `LedgerInfoWithSignatures` with version 1,000,000,000 and empty signatures using public constructors
3. Responds to `GetStorageServerSummary` requests with this fake data
4. Honest node at version 1,000 accepts this without verification
5. Global data summary now shows highest advertised version as 1,000,000,000
6. Honest node's subscription responses (at version ~1,000) appear to lag by 999,999,000
7. After 10 seconds of lag, subscription triggers `SubscriptionStreamIsLagging` error
8. Subscription stream resets, falls back to regular requests
9. Once target reached, attempts new subscription
10. New subscription immediately lags against fake advertised version â†’ reset again
11. Perpetual cycle degrades sync performance significantly

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty program under the "Validator node slowdowns" category (up to $50,000).

The repeated subscription resets force nodes to use slower non-optimized sync modes, significantly degrading performance. While this does not completely prevent consensus participation (nodes can still sync via regular requests), it causes substantial performance degradation:

- Increases sync latency by forcing fallback from optimized subscription mode
- Wastes resources on repeated subscription creation/teardown cycles
- May cause nodes to fall behind blockchain growth rate if regular mode is significantly slower
- Degrades overall network health and validator quality-of-service

The attack requires no special privileges - any malicious peer running a full node can send false storage summaries. The impact affects all nodes that poll the malicious peer.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity: LOW** - Malicious peer simply needs to construct a `LedgerInfoWithSignatures` with a high version using public constructors and respond to storage summary requests
- **Attacker Requirements: LOW** - No special privileges needed beyond running a full node that can respond to `GetStorageServerSummary` requests
- **Detection Difficulty: MEDIUM** - Repeated subscription resets would be visible in logs/metrics, but root cause may not be immediately obvious
- **Exploitability: HIGH** - The attack is straightforward to implement and has deterministic effects

The vulnerability stems from a fundamental design flaw: trusting peer-advertised data without cryptographic verification, violating the principle that BFT systems must validate all data from potentially Byzantine actors.

## Recommendation

Validate `LedgerInfoWithSignatures` in storage summaries before accepting them:

1. Add signature verification when processing storage summaries:
   - Call `verify_signatures()` on the `synced_ledger_info` before storing
   - Obtain the appropriate `ValidatorVerifier` from the current epoch state
   - Reject summaries with invalid signatures

2. Implement timestamp validation to detect unrealistic versions:
   - Check that the timestamp in the ledger info is reasonable (not too far in the future)
   - Reject summaries claiming versions significantly beyond what's plausible

3. Add peer reputation tracking specifically for storage summary quality:
   - Track when peers advertise data they cannot actually serve
   - Heavily penalize peers sending unverifiable ledger infos
   - Automatically ignore peers with consistently bad summaries

The fix should be applied in `update_summary()` method in `peer_states.rs` to validate the ledger info before storing it.

## Proof of Concept

Due to the complexity of setting up a full Aptos network environment, a complete runnable PoC is not provided. However, the attack can be demonstrated conceptually:

```rust
// Malicious peer constructs fake LedgerInfoWithSignatures
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_types::block_info::BlockInfo;
use aptos_types::aggregate_signature::AggregateSignature;
use aptos_crypto::hash::HashValue;

// Create fake ledger info with arbitrarily high version
let fake_block_info = BlockInfo::new(
    /* epoch */ 100,
    /* round */ 1000,
    /* id */ HashValue::zero(),
    /* executed_state_id */ HashValue::zero(),
    /* version */ 1_000_000_000, // Arbitrarily high version
    /* timestamp_usecs */ 0,
    /* next_epoch_state */ None,
);

let fake_ledger_info = LedgerInfo::new(fake_block_info, HashValue::zero());
let fake_signatures = AggregateSignature::empty(); // No actual signatures

let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    fake_signatures,
);

// This fake data would be included in StorageServerSummary response
// and accepted without validation, poisoning the global data summary
```

The attack is reproducible by running a malicious full node that responds to `GetStorageServerSummary` requests with such fake data.

## Notes

- This is a protocol-level vulnerability, not a traditional network DoS attack
- The attack does not require compromising validator operators (a trusted role)
- Any malicious actor running a full node can execute this attack
- The vulnerability affects the state synchronization layer, not consensus itself
- Nodes remain functional but experience significant performance degradation
- The perpetual reset loop is particularly damaging as it prevents nodes from benefiting from optimized subscription-based sync

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L324-330)
```rust
    /// Updates the storage summary for the given peer
    pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
        self.peer_to_state
            .entry(peer)
            .or_insert(PeerState::new(self.data_client_config.clone()))
            .update_storage_summary(storage_summary);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** types/src/ledger_info.rs (L179-182)
```rust
impl LedgerInfoWithSignatures {
    pub fn new(ledger_info: LedgerInfo, signatures: AggregateSignature) -> Self {
        LedgerInfoWithSignatures::V0(LedgerInfoWithV0::new(ledger_info, signatures))
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** types/src/aggregate_signature.rs (L32-37)
```rust
    pub fn empty() -> Self {
        Self {
            validator_bitmask: BitVec::default(),
            sig: None,
        }
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L586-596)
```rust
        // Get the highest advertised version
        let highest_advertised_version = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .map(|ledger_info| ledger_info.ledger_info().version())
            .ok_or_else(|| {
                aptos_data_client::error::Error::UnexpectedErrorEncountered(
                    "The highest synced ledger info is missing from the global data summary!"
                        .into(),
                )
            })?;
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L613-618)
```rust
                return Err(
                    aptos_data_client::error::Error::SubscriptionStreamIsLagging(format!(
                        "The subscription stream is beyond recovery! Current lag: {:?}, last lag: {:?},",
                        current_stream_lag, subscription_stream_lag.version_lag
                    )),
                );
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L967-983)
```rust
    fn is_beyond_recovery(
        &mut self,
        streaming_service_config: DataStreamingServiceConfig,
        current_stream_lag: u64,
    ) -> bool {
        // Calculate the total duration the stream has been lagging
        let current_time = self.time_service.now();
        let stream_lag_duration = current_time.duration_since(self.start_time);
        let max_stream_lag_duration =
            Duration::from_secs(streaming_service_config.max_subscription_stream_lag_secs);

        // If the lag is further behind and enough time has passed, the stream has failed
        let lag_has_increased = current_stream_lag > self.version_lag;
        let lag_duration_exceeded = stream_lag_duration >= max_stream_lag_duration;
        if lag_has_increased && lag_duration_exceeded {
            return true; // The stream is beyond recovery
        }
```

**File:** network/README.md (L36-39)
```markdown
In contrast, Validator Full Node (VFNs) servers will only prioritize connections
from more trusted peers in the on-chain discovery set; they will still service
any public clients. Public Full Nodes (PFNs) connecting to VFNs will always
authenticate the VFN server using the available discovery information.
```
