# Audit Report

## Title
Unverified Epoch in Consensus Observer Sync Target Enables State Sync Disruption Attack

## Summary
The consensus observer component accepts `CommitDecision` messages with future epoch numbers without cryptographic verification, passing the unverified `LedgerInfoWithSignatures` directly to state sync as a sync target. This allows malicious peers to disrupt validator synchronization by triggering premature epoch ending requests and creating unreachable sync targets.

## Finding Description

The vulnerability exists in the consensus observer's handling of commit decisions for future epochs. The attack flow is as follows:

**Step 1: Bypass Verification**

When a `CommitDecision` message arrives with an epoch number greater than the validator's current epoch, verification is explicitly skipped. The code only verifies commits for the current epoch: [1](#0-0) 

Lines 497-498 acknowledge this limitation with a TODO comment: "TODO: identify the best way to handle an invalid commit decision for a future epoch. In such cases, we currently rely on state sync."

**Step 2: Unverified Target Propagation**

The unverified commit decision is passed to the state sync manager without cryptographic validation: [2](#0-1) [3](#0-2) 

**Step 3: Missing Epoch Validation in State Sync**

The state sync driver's `initialize_sync_target_request()` only validates version numbers, NOT epoch numbers: [4](#0-3) 

The validation logic only checks if the sync target version is less than committed/pre-committed versions. The target's epoch is never verified against the current epoch state.

**Step 4: Premature Epoch Ending Requests**

The stream engine uses the unverified target's epoch to determine if an epoch change has occurred: [5](#0-4) 

When `target_ledger_info.ledger_info().epoch() > next_request_epoch`, the engine immediately requests epoch ending ledger infos, even though the target was never cryptographically validated.

**Attack Scenario:**
1. Attacker (malicious peer) sends `CommitDecision` with epoch 999, version 1000000
2. Consensus observer sees epoch 999 > current epoch 10, skips verification
3. State sync accepts the target with only version checks
4. Stream engine detects "epoch change" and requests epoch ending for epoch 10
5. Validator wastes resources; sync may stall waiting for non-existent version 1000000

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator Node Slowdowns**: Validators waste network and computational resources processing premature epoch ending requests and attempting to reach fabricated sync targets. This fits the "Validator Node Slowdowns (High)" category worth up to $50,000.

- **Protocol Logic Violation**: The epoch validation invariant is violated - unverified epoch numbers are used to make synchronization decisions, allowing malicious peers to manipulate validator sync behavior.

- **Availability Impact**: Validators can be forced into stuck sync states where they wait indefinitely for non-existent target versions, causing temporary disruption.

**Important Note**: This does NOT constitute a **Critical** consensus safety violation because:

- Actual epoch ending ledger infos received from peers ARE verified using `EpochState::verify()`: [6](#0-5) [7](#0-6) 

- Transaction data payloads ARE verified against the current epoch state: [8](#0-7) [9](#0-8) 

Therefore, validators will not accept invalid epoch transitions or transaction data, but they will waste resources attempting to sync to fabricated targets.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires ability to send network messages to validators (any peer can connect to validator network)
- **Attack Complexity**: Low - simply craft a `CommitDecision` message with arbitrary future epoch and version numbers
- **Detection Difficulty**: Moderate - attack traffic may blend with normal sync messages
- **Exploitation Feasibility**: Trivial once network access is obtained - no special permissions or stake required

## Recommendation

Implement epoch validation for future epoch commit decisions before passing them to state sync:

1. **Add epoch validation in consensus observer**: Before calling `sync_to_commit()`, validate that the future epoch number is reasonable (e.g., not more than 1-2 epochs ahead).

2. **Add epoch validation in state sync driver**: In `initialize_sync_target_request()`, add validation that the sync target's epoch is not unreasonably far ahead of the current epoch state.

3. **Rate limiting**: Implement rate limiting for state sync requests triggered by future epoch commits to prevent resource exhaustion.

4. **Improved verification**: Consider requiring at least partial verification of future epoch commits (e.g., verify it has valid signatures from some validator set, even if not the current one).

Example fix for consensus observer:

```rust
// In process_commit_decision_message, after line 503:
let last_block = self.observer_block_data.lock().get_last_ordered_block();
let epoch_changed = commit_epoch > last_block.epoch();

// Add validation: reject if epoch is unreasonably far ahead
if commit_epoch > epoch_state.epoch + MAX_EPOCH_JUMP {
    error!("Commit decision epoch {} is too far ahead of current epoch {}", 
           commit_epoch, epoch_state.epoch);
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}
```

## Proof of Concept

While a complete PoC would require setting up validator nodes and network infrastructure, the vulnerability can be demonstrated conceptually:

1. An attacker crafts a `CommitDecision` message with:
   - `epoch = 999` (far future)
   - `version = 1000000` (arbitrary high version)
   - Valid message structure but invalid/fabricated signatures

2. The message bypasses verification at line 468 because `commit_epoch != epoch_state.epoch`

3. The unverified target propagates through state sync (lines 525-526)

4. Stream engine detects epoch change at line 1193 and requests epoch ending ledger infos

5. Validator wastes resources attempting to sync to non-existent epoch 999, version 1000000

The vulnerability is reproducible on any validator accepting consensus observer messages from untrusted peers.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L525-526)
```rust
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L219-221)
```rust
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L276-285)
```rust
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1193-1209)
```rust
                if target_ledger_info.ledger_info().epoch() > next_request_epoch {
                    // There was an epoch change. Request an epoch ending ledger info.
                    info!(
                        (LogSchema::new(LogEntry::AptosDataClient)
                            .event(LogEvent::Pending)
                            .message(&format!(
                                "Requested an epoch ending ledger info for epoch: {:?}",
                                next_request_epoch
                            )))
                    );
                    self.end_of_epoch_requested = true;
                    return Ok(vec![DataClientRequest::EpochEndingLedgerInfos(
                        EpochEndingLedgerInfosRequest {
                            start_epoch: next_request_epoch,
                            end_epoch: next_request_epoch,
                        },
                    )]);
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1095-1105)
```rust
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L453-455)
```rust
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
```

**File:** state-sync/state-sync-driver/src/utils.rs (L101-110)
```rust
    pub fn verify_ledger_info_with_signatures(
        &mut self,
        ledger_info_with_signatures: &LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        self.epoch_state
            .verify(ledger_info_with_signatures)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })
    }
```
