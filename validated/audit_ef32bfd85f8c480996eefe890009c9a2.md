# Audit Report

## Title
Missing Per-Validator Share Count Validation in Weighted PVSS Enables Share Redistribution Attack

## Summary
The weighted PVSS implementation in the chunky transcript lacks validation that each validator receives the correct number of encrypted shares matching their configured weight. A malicious dealer can redistribute shares among validators while maintaining the correct total count, causing decryption failures that prevent DKG completion and block epoch transitions.

## Finding Description

The weighted PVSS protocol is designed to distribute secret shares among validators proportionally to their configured stake-based weights. However, the implementation contains a critical validation gap that allows a malicious dealer to redistribute shares arbitrarily.

**Missing Validation - Evidence:**

The developers acknowledged this missing check with a TODO comment: [1](#0-0) 

The only validation present is a debug assertion that gets compiled out in production release builds: [2](#0-1) 

**Inadequate Verification:**

The transcript verification only validates the outer array structure and total flattened count: [3](#0-2) 

The flattened validation checks total count but NOT per-validator distribution: [4](#0-3) 

**Vulnerability in Decryption:**

During decryption, validators blindly iterate based on their configured weight without validating actual share count: [5](#0-4) 

**Attack Mechanism:**

A malicious dealer can exploit this by:
1. Creating a transcript where validator weights are [40, 35, 25] (total 100)
2. Redistributing shares as: Cs[0]=15 shares, Cs[1]=35 shares, Cs[2]=50 shares (total still 100)
3. The verification passes because:
   - Outer array length = 3 validators ✓
   - Total flattened count = 100 ✓  
   - Cryptographic proofs are valid for the provided structure ✓
4. When validator 0 calls `decrypt_own_share()` with weight=40, the loop `for i in 0..weight` attempts to access `Cs[i]` for i ∈ [0, 40), but only 15 elements exist, causing an out-of-bounds panic

The `WeightedCodomainShape` structure accepts arbitrary per-player distributions: [6](#0-5) 

## Impact Explanation

**Severity: High**

This vulnerability enables a Byzantine validator to disrupt the DKG protocol, which is critical for consensus operation. Impact includes:

1. **DKG Completion Failure**: Targeted validators panic during share decryption, preventing successful DKG completion for the epoch
2. **Epoch Transition Blocking**: Failed DKG prevents epoch transitions and randomness beacon generation
3. **Consensus Liveness Impact**: Without DKG, leader election and consensus operations that depend on shared randomness are impaired

This qualifies as "Significant protocol violations" under the High severity category in the Aptos bug bounty program, as it disrupts a critical consensus subsystem. While it doesn't directly cause fund loss, it breaks the correctness guarantees of weighted secret sharing and enables denial of service against specific validators.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is exploitable in the following scenarios:
- Any validator selected as DKG dealer can execute the attack (dealer role rotates among validators)
- The attack requires no special privileges beyond being selected as dealer in a DKG round
- The malicious behavior is detectable (validators will report decryption failures), allowing the network to identify and potentially exclude the malicious dealer
- The lack of validation exists in production release builds where debug assertions are disabled

The attack is straightforward to execute but detectable, making it medium-high likelihood.

## Recommendation

Add explicit per-validator share count validation in the `verify()` method:

```rust
// In weighted_transcript.rs and weighted_transcriptv2.rs verify() method
for (player_id, player_Cs) in self.subtrs.Cs.iter().enumerate() {
    let expected_weight = sc.get_player_weight(&sc.get_player(player_id));
    if player_Cs.len() != expected_weight {
        bail!(
            "Player {} received {} shares but expected {} based on weight",
            player_id,
            player_Cs.len(),
            expected_weight
        );
    }
}
```

Also replace the TODO comments with actual assertions in the `decrypt_own_share()` methods:

```rust
// In decrypt_own_share methods
let Cs = &self.Cs[player.id];
if Cs.len() != weight {
    bail!("Share count mismatch: expected {} shares for player weight, got {}", weight, Cs.len());
}
```

## Proof of Concept

A malicious dealer would construct a transcript programmatically:
1. Create weighted configuration with weights [40, 35, 25]
2. Generate witness with misaligned plaintext distribution: 15, 35, 50 shares
3. Generate valid cryptographic proof for this witness structure
4. Broadcast transcript which passes verification
5. Victim validator 0 panics when attempting to decrypt with configured weight 40

The vulnerability can be triggered by modifying the DKG test harness to create a transcript with redistributed shares and observing the panic during decryption.

## Notes

This vulnerability exists in both `weighted_transcript.rs` (v1) and `weighted_transcriptv2.rs` (v2) implementations. The cryptographic proofs validate that shares are correctly encrypted but do not enforce alignment with the weighted configuration. The TODO comments indicate developers were aware of this gap but the validation was never implemented, and it remains unprotected in production builds.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L622-622)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L837-862)
```rust
        let weight = sc.get_player_weight(player);

        let Cs = &self.subtrs.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .subtrs
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L115-118)
```rust
pub struct WeightedCodomainShape<T: CanonicalSerialize + CanonicalDeserialize + Clone> {
    pub chunks: Vec<Vec<Vec<T>>>, // Depending on T these can be chunked ciphertexts, or their MSM representations
    pub randomness: Vec<Vec<T>>,  // Same story, depending on T
}
```
