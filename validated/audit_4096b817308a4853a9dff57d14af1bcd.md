# Audit Report

## Title
Direct Coin Transfer Opt-Out Bypass via Fungible Asset Migration

## Summary
The migration from CoinStore to FungibleAsset has broken the `can_receive_direct_coin_transfers` protection mechanism. Users who explicitly opt out of receiving arbitrary coin types can still receive them, violating documented security controls and enabling token spam attacks.

## Finding Description

The Aptos Framework provides a documented mechanism for users to opt out of receiving unsolicited coin transfers via `set_allow_direct_coin_transfers(account, false)`. [1](#0-0)  This security control is stored in the `DirectTransferConfig` resource [2](#0-1)  and is intended to give users control over what coins they accept.

However, this protection is completely bypassed due to the fungible asset migration.

**Root Cause:**

The `coin::is_account_registered<CoinType>` function has been modified to always return `true` after verifying coin initialization. [3](#0-2)  The `_account_addr` parameter is unused (prefixed with underscore), and the function unconditionally returns `true` after the coin type validation.

**Broken Protection Logic:**

In `aptos_account::deposit_coins`, the protection check is supposed to verify user consent before depositing unregistered coin types. [4](#0-3)  Since `is_account_registered` always returns `true`, the condition `!coin::is_account_registered<CoinType>(to)` is always `false`. Therefore, the assertion checking `can_receive_direct_coin_transfers(to)` at lines 141-143 **never executes**. The code proceeds directly to `coin::deposit<CoinType>(to, coins)` at line 147, bypassing the user's documented security preference.

**The Opt-Out Mechanism:**

The check function that should be enforced: [5](#0-4)  This function returns `false` when a user has explicitly set `allow_arbitrary_coin_transfers: false`, but due to the bypass in `deposit_coins`, this check is never evaluated.

**Execution Flow:**

1. Attacker calls coin transfer to victim who has opted out via `aptos_account::transfer_coins<CoinType>` [6](#0-5) 
2. This calls `deposit_coins` which checks `!is_account_registered<CoinType>(to)` â†’ always false
3. Protection check bypassed
4. `coin::deposit` proceeds, converting coin to fungible asset [7](#0-6) 
5. Primary fungible store auto-created if needed [8](#0-7) 
6. Victim receives unwanted coins despite explicit opt-out

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria ("Limited protocol violations" and "State inconsistencies requiring manual intervention"):

1. **Security Control Bypass**: A documented security mechanism is completely ineffective. The error code `EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS` exists [9](#0-8)  but is never triggered due to the bypass.

2. **User Consent Violation**: Users who explicitly configure their accounts to reject arbitrary coins via the documented interface [10](#0-9)  have their preferences ignored.

3. **Token Spam Attack Vector**: Attackers can force any account to receive arbitrary tokens, including scam tokens, phishing tokens, or unwanted airdrops.

4. **Manual Intervention Required**: Users must manually manage and dispose of unwanted tokens, constituting a state inconsistency requiring intervention.

5. **Privacy Breach**: Users cannot control their on-chain token exposure, potentially revealing relationships or attracting unwanted attention.

This does not qualify as Critical or High severity because:
- No direct loss of funds occurs
- No consensus violations
- No permanent freezing of assets
- Users can still transfer out unwanted tokens

However, it meets Medium severity as it creates unwanted blockchain state that requires manual cleanup and violates documented security guarantees that users rely upon.

## Likelihood Explanation

**Likelihood: HIGH**

- **Affects All Users**: Every coin transfer in the current codebase is affected through the standard transfer path
- **No Privileges Required**: Any user can exploit this by simply transferring coins
- **Trivial Execution**: Standard SDK functions execute the bypass automatically
- **Complete Protection Failure**: Users who opted out are 100% unprotected
- **Documented Feature**: The opt-out mechanism is documented and users rely on it, yet it provides zero protection
- **No Preconditions**: Works against any account regardless of configuration or state

## Recommendation

Restore the original functionality of `coin::is_account_registered<CoinType>` to actually check whether an account has registered for the coin type. The function should verify the existence of either a `CoinStore<CoinType>` resource or a primary fungible store for the paired fungible asset:

```move
public fun is_account_registered<CoinType>(account_addr: address): bool {
    assert!(
        is_coin_initialized<CoinType>(),
        error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED)
    );
    
    // Check legacy CoinStore
    if (exists<CoinStore<CoinType>>(account_addr)) {
        return true
    };
    
    // Check primary fungible store for paired metadata
    let metadata_opt = paired_metadata<CoinType>();
    if (option::is_some(&metadata_opt)) {
        let metadata = option::destroy_some(metadata_opt);
        return primary_fungible_store::primary_store_exists(account_addr, metadata)
    };
    
    false
}
```

This ensures the protection check in `aptos_account::deposit_coins` executes correctly and enforces user consent preferences.

## Proof of Concept

```move
#[test(framework = @0x1, user = @0x123, attacker = @0x456)]
public fun test_direct_coin_transfer_bypass(
    framework: &signer,
    user: &signer, 
    attacker: &signer
) {
    use aptos_framework::aptos_account;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    
    // Setup
    aptos_account::create_account_for_test(signer::address_of(user));
    aptos_account::create_account_for_test(signer::address_of(attacker));
    
    // User explicitly opts out of receiving arbitrary coins
    aptos_account::set_allow_direct_coin_transfers(user, false);
    assert!(!aptos_account::can_receive_direct_coin_transfers(signer::address_of(user)), 0);
    
    // Register attacker for a custom coin type
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CustomCoin>(
        framework,
        string::utf8(b"Custom"),
        string::utf8(b"CUSTOM"),
        8,
        false
    );
    
    coin::register<CustomCoin>(attacker);
    let coins = coin::mint<CustomCoin>(1000, &mint_cap);
    coin::deposit(signer::address_of(attacker), coins);
    
    // Attack: Transfer custom coin to user who opted out
    // This should fail with EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS
    // but actually succeeds due to the bypass
    aptos_account::transfer_coins<CustomCoin>(attacker, signer::address_of(user), 100);
    
    // Verify user received coins despite opt-out (demonstrates the vulnerability)
    assert!(coin::balance<CustomCoin>(signer::address_of(user)) == 100, 1);
    
    // Cleanup
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_freeze_cap(freeze_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

This test demonstrates that users who have opted out of receiving arbitrary coins via `set_allow_direct_coin_transfers(user, false)` still receive coins, proving the security control is bypassed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L26-27)
```text
    /// Account opted out of receiving coins that they did not register to receive.
    const EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS: u64 = 3;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L36-39)
```text
    struct DirectTransferConfig has key {
        allow_arbitrary_coin_transfers: bool,
        update_coin_transfer_events: EventHandle<DirectCoinTransferConfigUpdatedEvent>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L120-124)
```text
    public entry fun transfer_coins<CoinType>(
        from: &signer, to: address, amount: u64
    ) acquires DirectTransferConfig {
        deposit_coins(to, coin::withdraw<CoinType>(from, amount));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L140-147)
```text
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L207-257)
```text
    /// Set whether `account` can receive direct transfers of coins that they have not explicitly registered to receive.
    public entry fun set_allow_direct_coin_transfers(
        account: &signer, allow: bool
    ) acquires DirectTransferConfig {
        let addr = signer::address_of(account);
        if (exists<DirectTransferConfig>(addr)) {
            let direct_transfer_config = borrow_global_mut<DirectTransferConfig>(addr);
            // Short-circuit to avoid emitting an event if direct transfer config is not changing.
            if (direct_transfer_config.allow_arbitrary_coin_transfers == allow) { return };

            direct_transfer_config.allow_arbitrary_coin_transfers = allow;

            if (std::features::module_event_migration_enabled()) {
                emit(
                    DirectCoinTransferConfigUpdated {
                        account: addr,
                        new_allow_direct_transfers: allow
                    }
                );
            } else {
                emit_event(
                    &mut direct_transfer_config.update_coin_transfer_events,
                    DirectCoinTransferConfigUpdatedEvent {
                        new_allow_direct_transfers: allow
                    }
                );
            };
        } else {
            let direct_transfer_config = DirectTransferConfig {
                allow_arbitrary_coin_transfers: allow,
                update_coin_transfer_events: new_event_handle<
                    DirectCoinTransferConfigUpdatedEvent>(account)
            };
            if (std::features::module_event_migration_enabled()) {
                emit(
                    DirectCoinTransferConfigUpdated {
                        account: addr,
                        new_allow_direct_transfers: allow
                    }
                );
            } else {
                emit_event(
                    &mut direct_transfer_config.update_coin_transfer_events,
                    DirectCoinTransferConfigUpdatedEvent {
                        new_allow_direct_transfers: allow
                    }
                );
            };
            move_to(account, direct_transfer_config);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L264-269)
```text
    public fun can_receive_direct_coin_transfers(
        account: address
    ): bool acquires DirectTransferConfig {
        !exists<DirectTransferConfig>(account)
            || borrow_global<DirectTransferConfig>(account).allow_arbitrary_coin_transfers
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L808-814)
```text
    public fun is_account_registered<CoinType>(_account_addr: address): bool {
        assert!(
            is_coin_initialized<CoinType>(),
            error::invalid_argument(ECOIN_INFO_NOT_PUBLISHED)
        );
        true
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L914-918)
```text
    public fun deposit<CoinType>(
        account_addr: address, coin: Coin<CoinType>
    ) acquires CoinConversionMap, CoinInfo {
        primary_fungible_store::deposit(account_addr, coin_to_fungible_asset(coin));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```
