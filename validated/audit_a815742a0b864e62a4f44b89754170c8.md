# Audit Report

## Title
Non-Deterministic JSON Serialization in UnsupportedJWK Causes JWK Consensus Liveness Failure

## Summary
The `UnsupportedJWK` type uses non-canonical JSON serialization (`json_value.to_string()`) when converting from `serde_json::Value`, causing validators observing the same JWK to produce different payload bytes and IDs. This breaks the JWK consensus view comparison mechanism, preventing signature aggregation and causing liveness failures for JWK updates.

## Finding Description

The JWK consensus system has a determinism flaw in how it handles non-RSA JWKs. When validators observe JWKs from OIDC providers, they convert JSON responses into `JWK` types. For non-RSA keys, the system creates `UnsupportedJWK` instances. [1](#0-0) 

The vulnerability lies in line 53's use of `json_value.to_string()`, which does NOT produce canonical JSON. The TODO comment explicitly acknowledges this unfixed issue. JSON object field ordering is not guaranteed, meaning the same logical JWK data can serialize to different byte sequences.

Since the `id` field is computed as a SHA3-256 hash of the payload (line 55), different payloads produce different IDs, creating fundamentally different `UnsupportedJWK` structures for the same logical key.

**Attack Flow:**

1. **JWK Fetching**: Validators periodically fetch JWKs from OIDC providers via HTTP. [2](#0-1) 

2. **JSON to JWK Conversion**: The `Vec<serde_json::Value>` is converted to `JWK` types (line 35). Non-RSA keys become `UnsupportedJWK`. [3](#0-2) 

3. **Signature Creation**: Validators create and sign `ProviderJWKs` containing these JWKs. [4](#0-3) 

4. **View Comparison Failure**: When aggregating signatures, validators compare their local view against peer views using equality. [5](#0-4) 

If validators have different JSON field orderings for UnsupportedJWKs:
- Different `payload` bytes → different `id` hashes → different `UnsupportedJWK` structures
- Different `jwks` in `ProviderJWKs` → equality check fails
- Error: "adding peer observation failed with mismatched view"
- No signature aggregation → no quorum → consensus failure

The signing uses BCS serialization which is deterministic: [6](#0-5) 

However, BCS operates on the already non-deterministic `UnsupportedJWK` data structures, producing different signatures for the same logical data.

## Impact Explanation

**Severity: HIGH** (per Aptos bug bounty: "Validator Node Slowdowns" or "Limited Protocol Violations")

This vulnerability causes **consensus liveness failure** for JWK updates:

1. **No Quorum Formation**: Validators cannot aggregate signatures due to view mismatches
2. **JWK Update Stalls**: Keyless account authentication updates fail to reach the blockchain  
3. **Resource Waste**: Continuous failed consensus attempts consume validator resources
4. **Service Degradation**: Keyless account functionality impaired if JWK rotations don't complete

This does NOT cause fund loss or main chain consensus failure (which would be Critical), but represents a significant protocol violation that breaks the JWK consensus subsystem, meeting High severity criteria.

## Likelihood Explanation

**Likelihood: MEDIUM**

While the technical vulnerability is real, the likelihood is moderate rather than high:

**Triggering Conditions:**
- OIDC provider must use non-RSA keys (ECDSA, EdDSA) - currently uncommon
- JSON field ordering must vary between validator observations
- Validators must fetch JWKs at times hitting different CDN nodes/serializations

**Mitigating Factors:**
- Major OIDC providers (Google, Facebook) primarily use RSA keys, bypassing the `UnsupportedJWK` path entirely
- Modern JSON libraries often preserve insertion order in practice
- Not observed in production or testing environments to date
- Smoke tests use controlled dummy providers with consistent formatting

**Risk Assessment:**
As Aptos scales and integrates with diverse OIDC providers, and as the industry adopts more ECDSA/EdDSA keys, the likelihood increases. The vulnerability is latent but realistic under certain real-world conditions.

## Recommendation

Replace non-canonical `to_string()` with canonical JSON serialization:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (sorted keys, no whitespace)
        let payload = serde_json::to_vec(&json_value)
            .expect("JSON Value should always serialize");
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Alternatively, use a dedicated canonical JSON library or implement field-sorted serialization to ensure deterministic output across all validators.

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_json_field_ordering_issue() {
    use serde_json::json;
    
    // Same logical JWK, different field ordering
    let json1 = json!({"kty": "EC", "crv": "P-256", "x": "abc", "y": "def"});
    let json2 = json!({"y": "def", "x": "abc", "kty": "EC", "crv": "P-256"});
    
    // Both are equal as JSON values
    assert_eq!(json1, json2);
    
    // But produce different UnsupportedJWK structures
    let jwk1 = UnsupportedJWK::from(json1);
    let jwk2 = UnsupportedJWK::from(json2);
    
    // Different payloads due to field ordering
    assert_ne!(jwk1.payload, jwk2.payload);
    // Different IDs due to different payload hashes
    assert_ne!(jwk1.id, jwk2.id);
    // Different structures fail equality check
    assert_ne!(jwk1, jwk2);
}
```

## Notes

This vulnerability is explicitly acknowledged via the TODO comment at line 53 of `types/src/jwks/unsupported/mod.rs` but remains unfixed. While the current impact is limited due to RSA key prevalence, the bug should be addressed before broader OIDC provider integration or increased adoption of ECDSA/EdDSA keys in the ecosystem.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-58)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-205)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
            let signature = self
                .consensus_key
                .sign(&observed)
                .context("process_new_observation failed with signing error")?;
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```
