# Audit Report

## Title
Missing Curve Point Validation in Noise Handshake Enables Small Subgroup Attack on Network Connections

## Summary
The x25519 public key validation in Aptos's Noise protocol implementation fails to check for low-order curve points, violating the Noise Protocol Framework specification. This allows attackers to force weak encryption keys during network handshakes, potentially compromising the confidentiality of peer-to-peer communications across the entire network.

## Finding Description

The Noise Protocol Framework specification (Section 9.2) explicitly requires implementations to validate that Curve25519 public keys are not low-order points. However, the Aptos implementation violates this requirement.

The `x25519::PublicKey::try_from()` method only validates the byte array length without checking for low-order points: [1](#0-0) 

This vulnerability manifests in the Noise handshake where two public keys are received without proper validation. The ephemeral key is converted using the infallible `PublicKey::from()`: [2](#0-1) 

The static key is converted using `PublicKey::try_from()` which only checks length: [3](#0-2) 

Both keys are subsequently used in Diffie-Hellman operations without validation: [4](#0-3)  and [5](#0-4) 

This function is invoked in the production network layer for all inbound connections: [6](#0-5) 

In `HandshakeAuthMode::MaybeMutual` mode, the system accepts connections from unknown peers, making this particularly exploitable: [7](#0-6) 

**Attack Mechanism**: Curve25519 has cofactor 8, creating low-order points with orders 1, 2, 4, and 8. When an attacker sends a low-order point during the handshake, the DH operation produces a low-order result, limiting the derived encryption keys to at most 8 possible values. The attacker can enumerate all keys to decrypt the session traffic.

**Evidence of Developer Awareness**: The codebase demonstrates awareness of this vulnerability class. Ed25519 public keys are properly validated against small subgroups: [8](#0-7) 

Additionally, ElGamal encryption validates curve points using `is_torsion_free()`: [9](#0-8)  and [10](#0-9) 

This indicates the x25519 Noise implementation lacks validation that other cryptographic operations properly implement.

## Impact Explanation

This vulnerability constitutes **HIGH severity** under Aptos bug bounty criteria as it represents a significant protocol specification violation with network-wide impact:

1. **Universal Exposure**: Affects all peer-to-peer connections including validator-to-validator, validator-to-VFN, and public network connections
2. **Protocol Violation**: Direct violation of Noise Protocol Framework security requirements
3. **Confidentiality Breach**: Enables decryption of network handshakes and session traffic, potentially exposing network topology, peer discovery patterns, and validator operations metadata

While this does not directly compromise consensus (which has additional authentication layers) or enable fund theft, it breaks the security guarantees of the network transport layer. The impact aligns with HIGH severity because it affects critical network infrastructure universally with low exploitation complexity.

## Likelihood Explanation

The likelihood is **HIGH** because:

1. **Low Attack Complexity**: Low-order points are well-documented constants requiring no cryptographic expertise
2. **No Authentication Required**: In MaybeMutual mode, any network peer can establish connections
3. **Universal Applicability**: Every node accepting inbound connections is vulnerable
4. **Specification Requirement**: The Noise specification explicitly requires this check, indicating it's a recognized attack vector

The only limitation is network connectivity, which is trivial for public-facing endpoints.

## Recommendation

Implement low-order point validation for x25519 public keys before use in Diffie-Hellman operations. The validation should check that the point is not in the 8-torsion subgroup.

Add validation in `x25519::PublicKey::try_from()`:
```rust
pub fn is_low_order(&self) -> bool {
    // Convert to Edwards form and check
    let compressed = curve25519_dalek::edwards::CompressedEdwardsY::from_slice(&self.0);
    if let Some(point) = compressed.decompress() {
        point.is_small_order()
    } else {
        true // Invalid points should be rejected
    }
}
```

Then validate in `parse_client_init_message()` before DH operations:
```rust
if re.is_low_order() {
    return Err(NoiseError::LowOrderPoint);
}
if rs.is_low_order() {
    return Err(NoiseError::LowOrderPoint);
}
```

## Proof of Concept

A PoC would construct a Noise handshake message with one of the 8 low-order points documented in the curve25519_dalek library, send it to an Aptos node, and demonstrate that:
1. The handshake completes successfully
2. The derived encryption keys are limited to a small set
3. Session traffic can be decrypted by enumerating the key space

The specific low-order points can be found in the curve25519_dalek documentation and test vectors.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L228-237)
```rust
impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
}
```

**File:** crates/aptos-crypto/src/noise.rs (L440-446)
```rust
        // <- e
        let mut re = [0u8; x25519::PUBLIC_KEY_SIZE];
        cursor
            .read_exact(&mut re)
            .map_err(|_| NoiseError::MsgTooShort)?;
        mix_hash(&mut h, &re);
        let re = x25519::PublicKey::from(re);
```

**File:** crates/aptos-crypto/src/noise.rs (L449-450)
```rust
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L461-466)
```rust
        let rs: &[u8] = aead
            .open_in_place(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Decrypt)?;

        let rs = x25519::PublicKey::try_from(rs).map_err(|_| NoiseError::WrongPublicKeyReceived)?;
        mix_hash(&mut h, &encrypted_remote_static);
```

**File:** crates/aptos-crypto/src/noise.rs (L469-470)
```rust
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** network/framework/src/noise/handshake.rs (L361-364)
```rust
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/noise/handshake.rs (L384-416)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L76-82)
```rust
    // Check if the point lies on a small subgroup. This is required when using curves with a
    // small cofactor (e.g., in Ed25519, cofactor = 8).
    // NOTE(Gas): O(1) cost: multiplies the point by the cofactor
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();

    Ok(smallvec![Value::bool(valid)])
```

**File:** crates/aptos-crypto/src/asymmetric_encryption/elgamal_curve25519_aes256_gcm.rs (L59-62)
```rust
        ensure!(
            pk.is_torsion_free(),
            "ElGamalCurve25519Aes256Gcm enc failed with non-prime-order PK"
        );
```

**File:** crates/aptos-crypto/src/asymmetric_encryption/elgamal_curve25519_aes256_gcm.rs (L109-112)
```rust
        ensure!(
            c0.is_torsion_free(),
            "ElGamalCurve25519Aes256Gcm dec failed with non-prime-order c0"
        );
```
