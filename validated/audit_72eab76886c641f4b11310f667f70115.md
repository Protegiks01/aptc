# Audit Report

## Title
Zip Iterator Truncation in DKG Decryption Due to Unvalidated Rs Array Lengths

## Summary
The weighted PVSS transcript verification in the DKG (Distributed Key Generation) implementation fails to validate that all `Rs[j]` inner vectors have consistent lengths. A malicious dealer can create transcripts with `Rs` arrays of varying lengths, which pass all cryptographic verifications but cause silent truncation during decryption via zip iterators, resulting in incorrect secret share recovery and DKG protocol failure.

## Finding Description

The chunky PVSS implementation uses a nested structure for encryption randomness commitments where `Rs: Vec<Vec<E::G1>>` represents randomness commitments, with the outer vector for shares (up to `max_weight`) and each inner vector containing chunks for that share. [1](#0-0) 

During transcript verification, the implementation checks that `Cs.len()` and `Vs.len()` match the expected player count: [2](#0-1) 

However, **no validation ensures all `Rs[j]` inner vectors have the same length**. The verification never checks that `Rs[0].len() == Rs[1].len() == ... == Rs[n].len()` or that each equals `num_chunks_per_scalar`.

During decryption, the implementation uses zip iterators which truncate to the shorter sequence: [3](#0-2) 

If `Rs[0]` has 10 elements but `Rs[1]` has only 5 elements, the zip iterator produces only 5 elements, resulting in incomplete decryption. The player recovers an incorrect secret share.

The only existing protection is a debug assertion that validates only the FIRST key and only in debug builds: [4](#0-3) 

This protection is **absent in production builds** and doesn't check all ephemeral keys.

The alternate decryption path has the same vulnerability: [5](#0-4) 

The weighted_transcriptv2 implementation also exhibits this vulnerability: [6](#0-5) 

**Attack Path:**
1. Malicious dealer creates transcript during `deal()` with inconsistent Rs inner vector lengths (e.g., `Rs[0].len() = 10`, `Rs[1].len() = 5`)
2. Dealer generates valid sigma protocol proof (SoK) for this structure
3. Transcript passes verification since sigma protocol checks proof correctness and multi-pairing equations don't validate Rs consistency
4. Players decrypt shares using zip iterators which truncate to shorter lengths
5. Incorrect secret shares are recovered, breaking DKG protocol correctness

DKG is used by validators during epoch transitions for randomness generation: [7](#0-6) 

## Impact Explanation

This vulnerability enables a Byzantine validator acting as a DKG dealer to break the Distributed Key Generation protocol, which is critical for on-chain randomness generation in Aptos.

**Impact Severity: High**

Per Aptos bug bounty criteria, this qualifies as **High Severity: "Significant protocol violations"**:

- **DKG Protocol Violation**: The DKG protocol's correctness guarantee is broken - validators receive incorrect shares despite verification passing
- **Randomness Generation Failure**: Validators cannot properly generate shared keys for on-chain randomness when they recover incorrect secret shares
- **Non-deterministic Failures**: Different validators may decrypt different numbers of chunks, causing inconsistent state across the validator set
- **Protocol Integrity**: While this doesn't directly break consensus safety (epochs can transition without DKG), it violates the fundamental correctness properties of the PVSS protocol

The system can handle DKG failures gracefully during epoch transitions, but this vulnerability silently produces incorrect outputs that pass verification, which is more insidious than outright failure.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attacker Requirements**: Requires being a dealer in DKG (i.e., a validator participating in the protocol)
- **Byzantine Fault Tolerance**: Aptos consensus explicitly handles up to 1/3 Byzantine validators, making malicious dealers within the threat model
- **Ease of Exploitation**: Trivial for a malicious dealer - simply construct `Rs` with inconsistent inner vector lengths during transcript generation
- **Detection Difficulty**: The malformed transcript passes all cryptographic verification checks including sigma protocol verification and range proofs, making detection impossible without explicit length validation
- **Attack Surface**: Every DKG execution involving the malicious dealer as a participant

The attack requires no cryptographic breaks, no collusion with other validators, and no unusual access beyond normal dealer operations.

## Recommendation

Add explicit validation in the `verify` function to ensure all `Rs[j]` inner vectors have consistent lengths:

```rust
// In verify() function after existing checks
let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
for (i, Rs_i) in self.subtrs.Rs.iter().enumerate() {
    if Rs_i.len() != expected_chunks {
        bail!(
            "Expected {} chunks in Rs[{}], but got {}",
            expected_chunks,
            i,
            Rs_i.len()
        );
    }
}
```

Additionally, replace the debug assertion with a production runtime check:

```rust
// In decrypt_own_share()
for (i, ephemeral_key) in ephemeral_keys.iter().enumerate() {
    if ephemeral_key.len() != Cs[0].len() {
        bail!(
            "Ephemeral key {} has {} elements but ciphertext has {} chunks",
            i,
            ephemeral_key.len(),
            Cs[0].len()
        );
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by constructing a malicious transcript with inconsistent Rs lengths. While a complete PoC would require setting up the full DKG environment, the core issue is evident from the code structure: the verification functions check outer vector lengths but not inner vector consistency, and the decryption uses zip iterators that silently truncate when lengths mismatch.

## Notes

This vulnerability affects both `weighted_transcript.rs` (v1) and `weighted_transcriptv2.rs` (v2) implementations. The issue stems from incomplete validation in the PVSS transcript verification logic, where dimensional checks on the nested `Rs` structure are insufficient. The honest dealer implementation generates Rs with consistent lengths, but a Byzantine dealer can violate this assumption without detection.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L78-91)
```rust
pub struct Subtranscript<E: Pairing> {
    // The dealt public key
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub V0: E::G2,
    // The dealt public key shares
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub Vs: Vec<Vec<E::G2>>,
    /// First chunked ElGamal component: C[i][j] = s_{i,j} * G + r_j * ek_i. Here s_i = \sum_j s_{i,j} * B^j // TODO: change notation because B is not a group element?
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub Cs: Vec<Vec<Vec<E::G1>>>, // TODO: maybe make this and the other fields affine? The verifier will have to do it anyway... and we are trying to speed that up
    /// Second chunked ElGamal component: R[j] = r_j * H
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    pub Rs: Vec<Vec<E::G1>>,
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L338-344)
```rust
        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L351-355)
```rust
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L327-333)
```rust
    for (row, Rs_row) in Cs_rows.iter().zip(Rs_rows.iter()) {
        // Compute C - d_k * R for each chunk
        let exp_chunks: Vec<C> = row
            .iter()
            .zip(Rs_row.iter())
            .map(|(C_ij, &R_j)| C_ij.sub(R_j * *dk))
            .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L864-867)
```rust
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
```

**File:** types/src/dkg/real_dkg/mod.rs (L241-263)
```rust
    fn generate_transcript<R: CryptoRng + RngCore>(
        rng: &mut R,
        pub_params: &Self::PublicParams,
        input_secret: &Self::InputSecret,
        my_index: u64,
        sk: &Self::DealerPrivateKey,
        pk: &Self::DealerPublicKey,
    ) -> Self::Transcript {
        let my_index = my_index as usize;
        let my_addr = pub_params.session_metadata.dealer_validator_set[my_index].addr;
        let aux = (pub_params.session_metadata.dealer_epoch, my_addr);

        let wtrx = WTrx::deal(
            &pub_params.pvss_config.wconfig,
            &pub_params.pvss_config.pp,
            sk,
            pk,
            &pub_params.pvss_config.eks,
            input_secret,
            &aux,
            &Player { id: my_index },
            rng,
        );
```
