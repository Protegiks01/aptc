# Audit Report

## Title
Division by Zero in Proposer Election Causes Validator Crash with All-Zero Voting Powers

## Summary
The `choose_index()` function in the consensus layer's proposer election mechanism lacks validation for all-zero weights, causing a division by zero panic that crashes all validator nodes when all validators in the active set have zero voting power. This represents a defensive programming failure where the Move framework explicitly allows `minimum_stake = 0`, but the Rust consensus layer cannot safely handle this configuration.

## Finding Description

The vulnerability exists in the proposer election logic where validators with zero voting power can remain in the active validator set under specific configurations, leading to a network-wide panic when selecting a proposer.

The `choose_index()` function accumulates weights into `total_weight` without validating whether the result is zero before performing division operations. [1](#0-0) 

The `next_in_range()` function performs a modulo operation where the divisor is `max` (which equals `total_weight`). When `max = 0`, this causes a division by zero panic on line 45. [2](#0-1) 

The stake weights used for proposer election are calculated by multiplying reputation weights with validator voting powers. If all validators have zero voting power, all stake weights become zero regardless of reputation values. [3](#0-2) 

The critical gap exists in the staking configuration validation, which only enforces `maximum_stake > 0` but does NOT require `minimum_stake > 0`. [4](#0-3) 

During epoch reconfiguration, validators with zero voting power pass the eligibility check when `minimum_stake = 0`, remaining in the active validator set. [5](#0-4) 

Similarly, when joining the validator set, the check allows zero voting power when `minimum_stake = 0`. [6](#0-5) 

At genesis, validators can be initialized with zero stake, as the `initialize_stake_owner` function only adds stake if `initial_stake_amount > 0`. [7](#0-6) 

The Rust consensus code in `leader_reputation.rs` logs an error when total voting power is zero but does not prevent the crash in `choose_index()`. [8](#0-7) 

This represents a defensive programming failure where the Move framework explicitly allows a configuration (`minimum_stake = 0`) that the Rust consensus layer cannot safely handle.

## Impact Explanation

**Critical Severity** - This vulnerability causes complete loss of network liveness:

- All validators in the network will panic and crash when attempting proposer election with all-zero voting powers
- The network becomes completely unavailable and unable to produce blocks
- Requires emergency intervention or hard fork to recover
- Meets the "Total loss of liveness/network availability" criteria per Aptos bug bounty program (Critical severity)

The panic would occur synchronously across all validators attempting to elect a proposer for the same round, resulting in immediate and total network halt.

## Likelihood Explanation

**Extremely Low Likelihood** - The only realistic trigger scenario is:

**Genesis Misconfiguration**: A network initialized with `minimum_stake = 0` and all validators configured with `stake_amount = 0` would crash immediately upon the first proposer election. While the Move framework accepts this as a valid configuration, it represents a critical operator error.

The governance attack scenario mentioned in the original report (setting `minimum_stake = 0` after validators withdraw all stake) is NOT realistic because it would require all validators to simultaneously withdraw all their stake, which is economically irrational and violates validator economic incentives.

This vulnerability represents an architectural mismatch between the Move framework's permissive configuration validation and the Rust consensus layer's assumptions, creating a defensive programming failure that could affect improperly configured networks.

## Recommendation

Implement validation at multiple layers:

1. **Move Framework**: Add minimum stake validation to prevent `minimum_stake = 0`:
```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(minimum_stake > 0 && minimum_stake <= maximum_stake && maximum_stake > 0, 
            error::invalid_argument(EINVALID_STAKE_RANGE));
}
```

2. **Rust Consensus Layer**: Add defensive check in `choose_index()`:
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    assert!(total_weight > 0, "Total weight must be greater than zero");
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

3. **Genesis Validation**: Add validation during genesis initialization to ensure all validators have non-zero stake.

## Proof of Concept

To reproduce this vulnerability, create a custom genesis configuration with:
- `minimum_stake = 0` in staking configuration
- All validators with `stake_amount = 0`

Upon network startup, when the first proposer election occurs, all validators will panic with a division by zero error in the `next_in_range()` function, causing total network liveness loss.

## Notes

While this vulnerability has critical impact, its likelihood is extremely low and limited to genesis misconfiguration scenarios. The governance attack vector is not realistic in practice. However, this represents a legitimate defensive programming failure that should be addressed to prevent accidental network misconfiguration and ensure robustness of the consensus layer against edge cases in the configuration space.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```

**File:** consensus/src/liveness/leader_reputation.rs (L670-678)
```rust
                        } else if total_voting_power >= 1.0 {
                            participating_voting_power / total_voting_power
                        } else {
                            error!(
                                "Total voting power is {}, should never happen",
                                total_voting_power
                            );
                            1.0
                        };
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-715)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L656-658)
```text
        if (initial_stake_amount > 0) {
            add_stake(owner, initial_stake_amount);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1391-1398)
```text
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1539-1556)
```text
            if (new_voting_power >= minimum_stake) {
                let config = *borrow_global<ValidatorConfig>(candidate.addr);
                config.validator_index = num_new_actives;
                let new_validator_info = ValidatorInfo {
                    addr: candidate.addr,
                    voting_power: new_voting_power,
                    config,
                };

                // Update ValidatorSet.
                spec {
                    assume new_total_power + new_voting_power <= MAX_U128;
                };
                new_total_power = new_total_power + (new_voting_power as u128);
                vector::push_back(&mut new_active_validators, new_validator_info);
                num_new_actives = num_new_actives + 1;

            };
```
