# Audit Report

## Title
Consensus Node Panic via Cross-Fork QuorumCert in SyncInfo Message

## Summary
A malicious validator can crash honest validators by sending a `SyncInfo` message containing a `QuorumCert` from a minority blockchain fork. The honest validator fetches and inserts blocks from the fork, then panics when attempting to execute them because the commit block is not a descendant of the current `ordered_root`.

## Finding Description

The vulnerability exists in how consensus nodes process `SyncInfo` messages containing certificates from different blockchain forks. The attack exploits three components:

**Step 1: Insufficient Fork Validation**

The `SyncInfo::verify()` method validates epoch consistency, round ordering, and cryptographic signatures, but does NOT verify that certificates reference blocks on the same blockchain fork. [1](#0-0) 

**Step 2: Cross-Fork Block Fetching and Insertion**

When `add_certs()` processes a SyncInfo, it calls `insert_quorum_cert()` with the peer's `highest_quorum_cert`. [2](#0-1) 

The `fetch_quorum_cert()` method fetches blocks by walking backwards via parent links, successfully retrieving blocks from minority forks as long as they share a common ancestor. [3](#0-2) 

**Step 3: Unchecked Execution Trigger**

If the quorum certificate's commit round exceeds the ordered root round, `send_for_execution()` is called without verifying that the commit block is a descendant of `ordered_root`. [4](#0-3) 

**Step 4: Panic on Path Resolution Failure**

The `send_for_execution()` function calls `path_from_ordered_root()` to find blocks between the ordered root and commit block. [5](#0-4) 

The `path_from_root_to_block()` method traverses backwards and returns `None` when it reaches the root round but the block ID doesn't match (indicating different forks). [6](#0-5) 

The `unwrap_or_default()` converts `None` to an empty vector, causing the subsequent assertion to panic and crash the validator.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability enables a single malicious validator to crash any honest validator, causing:

1. **Immediate validator crash** - The panic terminates the consensus process
2. **Consensus liveness failure** - Multiple crashed validators prevent network progress
3. **Repeated attacks** - Continuous re-exploitation after restart
4. **No authentication barrier** - Any validator can send SyncInfo messages

This qualifies as **Critical Severity** under Aptos bug bounty categories:
- "Total loss of liveness/network availability" - If enough validators crash simultaneously
- "Consensus/Safety violations" - Consensus process crashes prevent block production
- Requires < 1/3 Byzantine validators (single malicious validator sufficient)

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:

1. **Low complexity** - Single crafted network message
2. **No special privileges** - Any validator can send SyncInfo messages  
3. **Natural occurrence** - Valid minority fork certificates are created during normal network partitions
4. **No rate limiting** - Unlimited attack attempts
5. **Difficult attribution** - Crash appears as generic panic without malicious fingerprint

Attack requirements:
- Valid QuorumCert from minority fork with 2f+1 signatures (obtainable during consensus)
- Ability to send consensus messages (available to all validators)
- Target's commit round lower than QC's commit round (common during sync)

## Recommendation

Add fork ancestry validation before calling `send_for_execution()`:

```rust
if self.ordered_root().round() < qc.commit_info().round() {
    // Verify commit block is descendant of ordered_root before execution
    if self.path_from_ordered_root(qc.commit_info().id()).is_none() {
        bail!("Cannot execute block from different fork than ordered_root");
    }
    SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
    self.send_for_execution(qc.into_wrapped_ledger_info()).await?;
}
```

Alternatively, modify `send_for_execution()` to return an error instead of panicking when the path is empty, allowing graceful handling of cross-fork certificates.

## Proof of Concept

The vulnerability can be triggered in a test environment by:

1. Creating a blockchain fork where validators vote on different chains
2. Obtaining a valid QuorumCert from the minority fork 
3. Constructing a SyncInfo with this QC as `highest_quorum_cert`
4. Sending the SyncInfo to an honest validator on the main chain
5. Observing the panic when `send_for_execution` is called with the cross-fork commit block

The panic will occur with error: `assertion failed: !blocks_to_commit.is_empty()` at the specified line in block_store.rs.

## Notes

The original report emphasized "when order_vote_enabled is false", but the vulnerability actually exists regardless of this configuration. The panic occurs during the initial `insert_quorum_cert()` call at line 144 of sync_manager.rs, which executes for both order_vote_enabled settings. The critical issue is the missing fork ancestry validation before triggering execution, not the order vote configuration.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L144-145)
```rust
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L233-270)
```rust
    async fn fetch_quorum_cert(
        &self,
        qc: QuorumCert,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        let mut pending = vec![];
        let mut retrieve_qc = qc.clone();
        loop {
            if self.block_exists(retrieve_qc.certified_block().id()) {
                break;
            }
            BLOCKS_FETCHED_FROM_NETWORK_WHILE_INSERTING_QUORUM_CERT.inc_by(1);
            let target_block_retrieval_payload = match &self.window_size {
                None => TargetBlockRetrieval::TargetBlockId(retrieve_qc.certified_block().id()),
                Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
            };
            let mut blocks = retriever
                .retrieve_blocks_in_range(
                    retrieve_qc.certified_block().id(),
                    1,
                    target_block_retrieval_payload,
                    qc.ledger_info()
                        .get_voters(&retriever.validator_addresses()),
                )
                .await?;
            // retrieve_blocks_in_range guarantees that blocks has exactly 1 element
            let block = blocks.remove(0);
            retrieve_qc = block.quorum_cert().clone();
            pending.push(block);
        }
        // insert the qc <- block pair
        while let Some(block) = pending.pop() {
            let block_qc = block.quorum_cert().clone();
            self.insert_single_quorum_cert(block_qc)?;
            self.insert_block(block).await?;
        }
        self.insert_single_quorum_cert(qc)
    }
```

**File:** consensus/src/block_storage/block_store.rs (L327-331)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_tree.rs (L540-542)
```rust
        if cur_block_id != root_id {
            return None;
        }
```
