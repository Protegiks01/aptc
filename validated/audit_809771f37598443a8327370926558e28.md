# Audit Report

## Title
Consensus Safety Violation via Payload Type Confusion in Consensus Observer Verification

## Summary
The `verify_against_ordered_payload()` function in the consensus observer fails to enforce type matching between the ordered block's consensus-certified payload and the separately-received block transaction payload. This allows injection of unauthorized transactions that bypass verification, directly violating consensus safety and causing state divergence across the network.

## Finding Description

The consensus observer architecture separates block ordering from transaction data delivery. Validators agree on block ordering via consensus producing an `OrderedBlock` with a quorum-certified `Payload`, while transaction data arrives separately via `BlockPayload` messages. The `verify_against_ordered_payload()` function must ensure these match.

**The Critical Flaw:**

The verification function matches on the **ordered block's payload type** but does not enforce that the `BlockTransactionPayload` being verified is of the **same type**. [1](#0-0) 

When the ordered payload is `Payload::InQuorumStore`, the verification only calls `verify_batches()` to check proof batches (line 660). However, if the `BlockTransactionPayload` is of a different type like `OptQuorumStore` (lines 504-507), the additional payload field containing opt/inline batches with extra transactions is **never verified** because the match statement (line 652) branches on `ordered_block_payload` type, not on both types.

**Attack Scenario:**

1. **Consensus Agreement:** Validators certify a block with `Payload::InQuorumStore` containing empty proofs

2. **Malicious BlockPayload:** Attacker sends `BlockTransactionPayload::OptQuorumStore(empty_proofs, malicious_batches)`

3. **Verification Bypass:** 
   - The function matches on `InQuorumStore` (line 658)
   - Only `verify_batches()` is called (line 660)
   - This extracts proofs via `payload_proofs()` which for OptQuorumStore only returns the first field [2](#0-1) 
   - Empty proofs match empty proofs âœ“
   - The second field `Vec<BatchInfo>` containing malicious batches is **never checked**

4. **Payload Digest Verification Bypassed:**
   The `verify_payload_digests()` function checks internal consistency of the BlockPayload itself, not comparison against ordered payload [3](#0-2) 
   If attacker constructs transactions matching their declared batch digests, this passes.

5. **Unauthorized Execution:**
   During execution, `transaction_payload.transactions()` extracts **all** transactions including injected ones [4](#0-3) [5](#0-4) 

The verification is called during ordered block processing: [6](#0-5) 

**Broken Invariant:**

This violates **Deterministic Execution**: all validators must produce identical state roots for identical blocks. Honest nodes receiving correct payloads execute zero transactions, while attacked nodes execute injected transactions, causing **state divergence** across the network.

## Impact Explanation

**Severity: CRITICAL** (Aptos Bug Bounty $1,000,000 tier)

This vulnerability directly violates **Consensus Safety**, meeting the Critical severity criteria:

**Impact:**
- **Consensus Safety Violation:** Different nodes execute different transactions for the same block height, breaking Byzantine Fault Tolerance guarantees
- **State Divergence:** Honest and attacked nodes compute different state roots, causing permanent network split
- **Transaction Injection:** Attackers execute arbitrary transactions bypassing normal consensus voting
- **Network Partition:** If sufficient observers are attacked, the network fragments
- **Requires Hardfork Recovery:** State divergence necessitates coordinated hardfork

This breaks the fundamental blockchain property that all honest participants agree on the same ledger history.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Ability to send consensus observer messages to target nodes (available to any network peer)
- Knowledge of ordered block payload types from network monitoring
- No validator compromise required
- No special privileges needed

**Attack Complexity:**
- Low - simply construct mismatched payload types
- No race conditions or timing requirements
- The verification logic bug makes exploitation straightforward

**Realistic Deployment:**
- Consensus observers accept messages from publisher peers by design
- An attacker operating a malicious publisher node can target subscribed observers
- Affects any consensus observer node in production

The vulnerability executes whenever consensus observers process blocks, making exploitation highly feasible.

## Recommendation

Enforce type matching between `BlockTransactionPayload` and `Payload` in `verify_against_ordered_payload()`:

```rust
pub fn verify_against_ordered_payload(
    &self,
    ordered_block_payload: &Payload,
) -> Result<(), Error> {
    // First, verify payload type matches
    match (self, ordered_block_payload) {
        (BlockTransactionPayload::DeprecatedInQuorumStore(_), Payload::InQuorumStore(_)) |
        (BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(_), Payload::InQuorumStoreWithLimit(_)) |
        (BlockTransactionPayload::QuorumStoreInlineHybrid(_, _), Payload::QuorumStoreInlineHybrid(_, _, _)) |
        (BlockTransactionPayload::QuorumStoreInlineHybridV2(_, _), Payload::QuorumStoreInlineHybridV2(_, _, _)) |
        (BlockTransactionPayload::OptQuorumStore(_, _), Payload::OptQuorumStore(_)) => {},
        _ => {
            return Err(Error::InvalidMessageError(format!(
                "Payload type mismatch! BlockTransactionPayload type does not match ordered Payload type"
            )));
        }
    }
    
    // Then proceed with existing verification logic
    match ordered_block_payload {
        // ... existing match arms
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_type_confusion_attack() {
    // Consensus agrees on InQuorumStore with empty proofs
    let ordered_payload = Payload::InQuorumStore(ProofWithData::new(vec![], vec![]));
    
    // Attacker creates OptQuorumStore with empty proofs + malicious batch
    let malicious_batch = create_batch_info();
    let attack_payload = BlockTransactionPayload::new_opt_quorum_store(
        vec![create_signed_transaction()], // unauthorized transaction
        vec![], // empty proofs to match
        None,
        None,
        vec![malicious_batch], // unverified malicious batch
    );
    
    // Verification incorrectly passes due to type confusion
    assert!(attack_payload.verify_against_ordered_payload(&ordered_payload).is_ok());
    
    // But transactions() returns the injected transaction
    assert_eq!(attack_payload.transactions().len(), 1); // Should be 0!
}
```

## Notes

The vulnerability exists because `verify_against_ordered_payload()` uses pattern matching on only the `ordered_block_payload` parameter without validating that `self` (the `BlockTransactionPayload`) is the corresponding type. This allows type confusion where a `BlockTransactionPayload::OptQuorumStore` can masquerade as matching a `Payload::InQuorumStore` by only having its proofs field verified while its opt/inline batches field containing unauthorized transactions is completely ignored.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L616-628)
```rust
    pub fn payload_proofs(&self) -> Vec<ProofOfStore<BatchInfo>> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(payload) => payload.proofs.clone(),
            BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(payload) => {
                payload.payload_with_proof.proofs.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybrid(payload, _) => {
                payload.payload_with_proof.proofs.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.proofs(),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L631-645)
```rust
    pub fn transactions(&self) -> Vec<SignedTransaction> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(payload) => {
                payload.transactions.clone()
            },
            BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(payload) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybrid(payload, _) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.transactions(),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L647-717)
```rust
    /// Verifies the transaction payload against the given ordered block payload
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L874-958)
```rust
    /// Verifies the block payload digests and returns an error if the data is invalid
    pub fn verify_payload_digests(&self) -> Result<(), Error> {
        // Get the block info, transactions, payload proofs and inline batches
        let block_info = self.block.clone();
        let transactions = self.transaction_payload.transactions();
        let payload_proofs = self.transaction_payload.payload_proofs();
        let opt_and_inline_batches = self.transaction_payload.optqs_and_inline_batches();

        // Get the number of transactions, payload proofs and inline batches
        let num_transactions = transactions.len();
        let num_payload_proofs = payload_proofs.len();
        let num_opt_and_inline_batches = opt_and_inline_batches.len();

        // Gather the transactions for each payload batch
        let mut batches_and_transactions = vec![];
        let mut transactions_iter = transactions.into_iter();
        for proof_of_store in &payload_proofs {
            match reconstruct_batch(
                &block_info,
                &mut transactions_iter,
                proof_of_store.info(),
                true,
            ) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions
                        .push((proof_of_store.info().clone(), batch_transactions));
                },
                Ok(None) => { /* Nothing needs to be done (the batch was expired) */ },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct payload proof batch! Num transactions: {:?}, \
                        num batches: {:?}, num inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, proof_of_store.info(), error
                    )));
                },
            }
        }

        // Gather the transactions for each inline batch
        for batch_info in opt_and_inline_batches.iter() {
            match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, false) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions.push((batch_info.clone(), batch_transactions));
                },
                Ok(None) => {
                    return Err(Error::UnexpectedError(format!(
                        "Failed to reconstruct inline/opt batch! Batch was unexpectedly skipped: {:?}",
                        batch_info
                    )));
                },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct inline/opt batch! Num transactions: {:?}, \
                        num batches: {:?}, num opt/inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, batch_info, error
                    )));
                },
            }
        }

        // Verify all the reconstructed batches (in parallel)
        batches_and_transactions
            .into_par_iter()
            .with_min_len(2)
            .try_for_each(|(batch_info, transactions)| verify_batch(&batch_info, transactions))
            .map_err(|error| {
                Error::InvalidMessageError(format!(
                    "Failed to verify the payload batches and transactions! Error: {:?}",
                    error
                ))
            })?;

        // Verify that there are no transactions remaining (all transactions should be consumed)
        let remaining_transactions = transactions_iter.as_slice();
        if !remaining_transactions.is_empty() {
            return Err(Error::InvalidMessageError(format!(
                "Failed to verify payload transactions! Num transactions: {:?}, \
                transactions remaining: {:?}. Expected: 0",
                num_transactions,
                remaining_transactions.len()
            )));
        }

        Ok(()) // All digests match
    }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L70-76)
```rust
    // Return the transactions and the transaction limit
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
}
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L186-199)
```rust
                    // Get the ordered block payload
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
```
