# Audit Report

## Title
BLS12-381 Public Key Subgroup Check Severely Undercharged - Gas Metering Bypass Leading to Validator DoS

## Summary
The `bls12381_pk_subgroub_check` function charges incorrect gas (400,684 units instead of 1,360,120 units), allowing attackers to perform expensive cryptographic subgroup validation operations at approximately 70% discount, enabling resource exhaustion attacks against validator nodes.

## Finding Description

The BLS12-381 native function implementation contains a critical gas metering bug where public key subgroup checks are charged with the wrong gas parameter.

The vulnerable function is `bls12381_pk_subgroub_check` which performs an expensive elliptic curve subgroup check operation but charges gas for the much cheaper deserialization operation: [1](#0-0) 

Line 158 incorrectly charges `BLS12381_PER_PUBKEY_DESERIALIZE` when it should charge `BLS12381_PER_PUBKEY_SUBGROUP_CHECK`. For comparison, the signature subgroup check function correctly charges the appropriate gas parameter: [2](#0-1) 

The gas constants are defined as: [3](#0-2) 

This results in an undercharge of 959,436 gas units (70.5% discount). The operation is computationally expensive, involving elliptic curve point validation that takes approximately 39 microseconds per operation as documented in the code comment at line 157.

**Attack Vectors:**

1. **Direct validation**: The buggy function is called by `native_bls12381_validate_pubkey`, which is publicly accessible through the Move function `validate_pubkey_internal`: [4](#0-3) [5](#0-4) 

2. **Normal signature verification**: The function is also called during normal signature verification with subgroup checking enforced: [6](#0-5) [7](#0-6) 

**Attack Path:**
1. Attacker crafts transactions calling `bls12381::public_key_from_bytes` or `bls12381::verify_normal_signature` with adversarial inputs
2. Each call triggers the expensive `subgroup_check()` cryptographic operation (39 microseconds)
3. Gas is only charged 400,684 units instead of 1,360,120 units
4. Attacker can spam multiple such operations per transaction at 70% discount
5. Validator nodes experience significant CPU load from underpriced cryptographic operations

This breaks the fundamental invariant that all operations must be charged gas proportional to their computational cost.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty criteria)

This vulnerability enables a **validator node resource exhaustion attack**:

- **Computation Amplification**: Each undercharged operation costs validators 39 microseconds of CPU time but only charges ~30% of the appropriate gas
- **DoS Vector**: Attackers can flood the network with transactions containing multiple subgroup check operations, causing validator slowdowns
- **Economic Exploitation**: Attackers pay significantly less gas than the actual computational cost they impose on the network
- **Not Consensus-Breaking**: All validators process transactions identically, so this doesn't cause consensus splits
- **Not Fund Loss**: No direct theft or minting of tokens

The impact falls under the **"Validator Node Slowdowns (High)"** severity category as it enables DoS through resource exhaustion. However, it is reasonably bounded to **Medium** severity because:
- It requires sustained transaction submission (costs attacker some gas, albeit underpriced)
- Does not permanently damage the network
- Can be mitigated by validators adjusting mempool policies
- Does not affect consensus safety or fund security

This is a gas metering implementation bug enabling resource exhaustion, which is distinct from network-level DoS attacks that are explicitly out of scope.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:
- **Zero Prerequisites**: Any user can submit transactions calling the public Move functions `public_key_from_bytes` or `verify_normal_signature`
- **Low Cost**: Even with underpriced gas, the attack cost is minimal compared to the damage
- **Easy Detection**: The bug is in production code and the functions are publicly documented
- **Simple Exploitation**: A single Move script can trigger multiple undercharged operations
- **Clear Benefit**: Attackers can perform DoS attacks at significantly reduced cost (70% discount)
- **No Special Access**: Does not require validator privileges or special capabilities

The functions have been in production since BLS12-381 support was added to Aptos, making them readily exploitable.

## Recommendation

Fix the gas charging in the `bls12381_pk_subgroub_check` function by changing line 158 from:
```rust
context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;
```

To:
```rust
context.charge(BLS12381_PER_PUBKEY_SUBGROUP_CHECK * NumArgs::one())?;
```

This will ensure the operation is charged the correct gas amount proportional to its computational cost.

## Proof of Concept

```move
#[test_only]
module test_addr::bls_gas_exploit {
    use aptos_std::bls12381;
    use std::vector;

    #[test]
    fun test_undercharged_subgroup_check() {
        // This public key will deserialize successfully but trigger subgroup check
        let pk_bytes = x"b3e4921277221e01ed71284be5e3045292b26c7f465a6fcdba53ee47edd39ec5160da3b229a73c75671024dcb36de091";
        
        // Each call to public_key_from_bytes triggers:
        // 1. Deserialization (charged correctly)
        // 2. Subgroup check (charged INCORRECTLY as deserialization)
        // An attacker can call this hundreds of times per transaction
        let i = 0;
        while (i < 100) {
            let _pk = bls12381::public_key_from_bytes(pk_bytes);
            i = i + 1;
        };
        // Total gas charged: ~40M units
        // Actual computational cost: ~135M units equivalent
        // Attacker saves: ~95M gas units (70% discount)
    }
}
```

This proof of concept demonstrates how an attacker can repeatedly call the undercharged subgroup check operation, consuming significant validator CPU resources while paying only 30% of the appropriate gas cost.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L152-161)
```rust
/// Checks prime-order subgroup membership on a bls12381::PublicKey struct.
fn bls12381_pk_subgroub_check(
    pk: &bls12381::PublicKey,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    // NOTE(Gas): constant-time; around 39 microseconds on Apple M1
    context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;

    Ok(pk.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L163-171)
```rust
/// Checks prime-order subgroup membership on a bls12381::Signature struct.
fn bls12381_sig_subgroub_check(
    sig: &bls12381::Signature,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    context.charge(BLS12381_PER_SIG_SUBGROUP_CHECK * NumArgs::one())?;

    Ok(sig.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L203-227)
```rust
pub fn bls12381_verify_signature_helper(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
    check_pk_subgroup: bool,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 3);

    context.charge(BLS12381_BASE)?;

    let msg_bytes = safely_pop_arg!(arguments, Vec<u8>);
    let aggpk_bytes = safely_pop_arg!(arguments, Vec<u8>);
    let multisig_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(aggpk_bytes, context)? {
        Some(pk) => pk,
        None => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    if check_pk_subgroup && !bls12381_pk_subgroub_check(&pk, context)? {
        return Ok(smallvec![Value::bool(false)]);
    }
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L392-412)
```rust
fn native_bls12381_validate_pubkey(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    context.charge(BLS12381_BASE)?;

    let pk_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(pk_bytes, context)? {
        Some(key) => key,
        None => return Ok(smallvec![Value::bool(false)]),
    };

    let valid = bls12381_pk_subgroub_check(&pk, context)?;

    Ok(smallvec![Value::bool(valid)])
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L536-546)
```rust
pub fn native_bls12381_verify_normal_signature(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // For normal (non-aggregated) signatures, PK's typically don't come with PoPs and the caller
    // might forget to check prime-order subgroup membership of the PK. Therefore, we always enforce
    // it here.
    let check_pk_subgroup = true;
    bls12381_verify_signature_helper(context, ty_args, arguments, check_pk_subgroup)
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L174-176)
```rust
        [bls12381_per_pubkey_deserialize: InternalGasPerArg, "bls12381.per_pubkey_deserialize", 400684],
        [bls12381_per_pubkey_aggregate: InternalGasPerArg, "bls12381.per_pubkey_aggregate", 15439],
        [bls12381_per_pubkey_subgroup_check: InternalGasPerArg, "bls12381.per_pubkey_subgroup_check", 1360120],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L384-390)
```text
    /// Return `true` if the bytes in `public_key` are a valid BLS12-381 public key:
    ///  (1) it is NOT the identity point, and
    ///  (2) it is a BLS12-381 elliptic curve point, and
    ///  (3) it is a prime-order point
    /// Return `false` otherwise.
    /// Does not abort.
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;
```
