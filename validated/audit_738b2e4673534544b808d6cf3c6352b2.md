# Audit Report

## Title
Unbounded State Growth in ApprovedExecutionHashes Through Unexecuted Governance Proposals

## Summary
The `ApprovedExecutionHashes` resource in the Aptos governance system allows unbounded state growth when governance proposals reach `PROPOSAL_STATE_SUCCEEDED` but are never executed. The absence of cleanup mechanisms for abandoned proposals enables permanent on-chain storage bloat.

## Finding Description

The Aptos governance system maintains an `ApprovedExecutionHashes` resource to track execution script hashes for large governance proposals that need to bypass mempool size limits. [1](#0-0) 

When a vote is cast and the proposal transitions to `PROPOSAL_STATE_SUCCEEDED`, the system automatically adds the proposal's execution hash to the `ApprovedExecutionHashes` map: [2](#0-1) 

The `add_approved_script_hash` function retrieves the execution hash from the voting module and stores it in the SimpleMap: [3](#0-2) 

Hashes can only be removed through the `remove_approved_hash` function, which strictly enforces that the proposal must be resolved before cleanup: [4](#0-3) 

For a proposal to be resolved, the execution script with the exact matching hash must be submitted. This is enforced by the voting module's resolution validation: [5](#0-4) 

**The Attack Vector:**

1. An untrusted proposer creates a governance proposal with the required stake
2. Through legitimate voting by governance participants, the proposal reaches `PROPOSAL_STATE_SUCCEEDED`
3. The execution hash is automatically added to `ApprovedExecutionHashes`
4. The proposer abandons the proposal and never submits the execution script
5. The hash remains permanently in the `SimpleMap` with no cleanup mechanism

The `SimpleMap` data structure has no inherent size limits: [6](#0-5) 

Additionally, there is a public entry function that allows anyone to manually ensure hashes are added for succeeded proposals: [7](#0-6) 

This violates resource management invariants as the `ApprovedExecutionHashes` map can grow without bound, with no expiration-based cleanup, no administrative override function, and no size constraints enforced.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria for "State inconsistencies requiring intervention."

**Specific Impacts:**
- **Unbounded State Growth**: Each abandoned succeeded proposal permanently consumes on-chain storage in the global `ApprovedExecutionHashes` resource
- **Increased Gas Costs**: Operations on larger `SimpleMap` structures incur higher gas costs, degrading governance system performance
- **Manual Intervention Required**: No automated cleanup mechanism exists; removal requires governance action to force proposal resolution or protocol upgrade
- **Griefing Attack Vector**: Malicious actors can intentionally bloat state by repeatedly creating proposals that succeed but are never executed

The vulnerability does not directly enable fund theft or consensus violations, but it creates a permanent state management issue requiring manual remediation, aligning with Medium severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Requirements:**
- Proposer needs `required_proposer_stake` (configurable via governance, typically 100 APT based on initialization code): [8](#0-7) 
- Proposal must receive sufficient votes to reach `PROPOSAL_STATE_SUCCEEDED`
- Proposer then abandons the proposal without executing

**Why This Is Likely:**
1. **Economic Feasibility**: The stake is only locked temporarily, not burned, making repeated attacks economically viable
2. **Accidental Triggering**: Legitimate proposals can be abandoned accidentally by proposers who change priorities or lose access
3. **No Rate Limiting**: Beyond stake requirements, there are no mechanisms to prevent repeated proposal creation
4. **Coordination Not Required**: Once governance legitimately votes yes, a single malicious/negligent proposer can abandon execution
5. **Public Accessibility**: The public entry function allows any actor to ensure hashes are added: [7](#0-6) 

**Constraints:**
- Each proposal requires a voting period (default 1000 seconds): [9](#0-8) 
- Attack cost scales linearly with available stake for concurrent proposals

## Recommendation

Implement one or more of the following mitigations:

1. **Time-Based Expiration**: Add timestamps to `ApprovedExecutionHashes` entries and implement a cleanup function that removes hashes for proposals that have been succeeded but unresolved beyond a reasonable timeframe (e.g., 30 days)

2. **Size Limits**: Enforce a maximum size on the `ApprovedExecutionHashes` SimpleMap, preventing addition of new hashes once the limit is reached

3. **Administrative Override**: Add a governance-controlled function to remove hashes for proposals that have been abandoned, with appropriate authorization checks

4. **Automatic Cleanup on Expiration**: When a proposal's expiration time passes without resolution, automatically remove its hash from `ApprovedExecutionHashes` if it exists

Recommended implementation:
```move
// Add expiration tracking
struct ApprovedExecutionHashes has key {
    hashes: SimpleMap<u64, ApprovedHash>,
}

struct ApprovedHash has store {
    execution_hash: vector<u8>,
    added_timestamp: u64,
}

// Add cleanup function callable by governance
public fun cleanup_expired_hashes(
    aptos_framework: &signer,
    proposal_ids: vector<u64>,
    expiration_threshold_secs: u64
) acquires ApprovedExecutionHashes {
    system_addresses::assert_aptos_framework(aptos_framework);
    // Remove hashes for proposals older than threshold that remain unresolved
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter = @0x234)]
public entry fun test_unbounded_approved_hash_growth(
    aptos_framework: signer,
    proposer: signer,
    voter: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    // Setup governance
    setup_voting(&aptos_framework, &proposer, &voter, &voter);
    
    // Create proposal
    create_proposal(
        &proposer,
        signer::address_of(&proposer),
        vector[1],
        b"",
        b"",
    );
    
    // Vote yes to reach SUCCEEDED state
    vote(&voter, signer::address_of(&voter), 0, true);
    
    // Wait for voting period to end
    timestamp::update_global_time_for_test(100001000000);
    
    // Verify proposal succeeded
    let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, 0);
    assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, 1);
    
    // Add approved hash (happens automatically on vote or can be called manually)
    add_approved_script_hash(0);
    
    // Verify hash was added
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;
    assert!(simple_map::contains_key(&approved_hashes, &0), 2);
    
    // Proposer abandons - never calls resolve()
    // Hash remains permanently in ApprovedExecutionHashes
    
    // Demonstrate no cleanup mechanism exists
    // Even after expiration, hash cannot be removed without resolution
    timestamp::update_global_time_for_test(200001000000);
    
    // Hash still present
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework).hashes;
    assert!(simple_map::contains_key(&approved_hashes, &0), 3);
    
    // Attempting to remove without resolution aborts
    // remove_approved_hash(0); // Would abort with EPROPOSAL_NOT_RESOLVED_YET
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L108-112)
```text
    /// Used to track which execution script hashes have been approved by governance.
    /// This is required to bypass cases where the execution scripts exceed the size limit imposed by mempool.
    struct ApprovedExecutionHashes has key {
        hashes: SimpleMap<u64, vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L420-426)
```text
        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L430-434)
```text
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L600-604)
```text
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L606-608)
```text
    public entry fun add_approved_script_hash_script(proposal_id: u64) acquires ApprovedExecutionHashes {
        add_approved_script_hash(proposal_id)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L613-630)
```text
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L664-674)
```text
    public fun remove_approved_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        assert!(
            voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id),
            error::invalid_argument(EPROPOSAL_NOT_RESOLVED_YET),
        );

        let approved_hashes = &mut borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework).hashes;
        if (simple_map::contains_key(approved_hashes, &proposal_id)) {
            simple_map::remove(approved_hashes, &proposal_id);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L1-40)
```text
/// This module provides a solution for unsorted maps, that is it has the properties that
/// 1) Keys point to Values
/// 2) Each Key must be unique
/// 3) A Key can be found within O(N) time
/// 4) The keys are unsorted.
/// 5) Adds and removals take O(N) time
///
/// DEPRECATED: since it's implementation is inneficient, it
/// has been deprecated in favor of `ordered_map.move`.
module aptos_std::simple_map {
    use std::error;
    use std::option;
    use std::vector;

    /// Map key already exists
    const EKEY_ALREADY_EXISTS: u64 = 1;
    /// Map key is not found
    const EKEY_NOT_FOUND: u64 = 2;

    /// DEPRECATED: since it's implementation is inneficient, it
    /// has been deprecated in favor of `ordered_map.move`.
    struct SimpleMap<Key, Value> has copy, drop, store {
        data: vector<Element<Key, Value>>,
    }

    struct Element<Key, Value> has copy, drop, store {
        key: Key,
        value: Value,
    }

    public fun length<Key: store, Value: store>(self: &SimpleMap<Key, Value>): u64 {
        self.data.length()
    }

    /// Create an empty SimpleMap.
    public fun new<Key: store, Value: store>(): SimpleMap<Key, Value> {
        SimpleMap {
            data: vector::empty(),
        }
    }
```
