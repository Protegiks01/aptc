# Audit Report

## Title
Missing Per-Player Ciphertext Length Validation in Weighted PVSS Enables DKG Denial of Service

## Summary
The weighted PVSS transcript verification function fails to validate that each player's ciphertext array length matches their assigned weight, only checking the total flattened count. This allows a Byzantine dealer to create malformed transcripts that pass verification but cause reconstruction failures, breaking DKG liveness guarantees and potentially stalling epoch transitions.

## Finding Description

The weighted PVSS protocol in Aptos DKG assigns each validator a weight (number of shares) based on their stake. During dealing, the `Cs` array should contain exactly `player_weight` encrypted chunks for each player. However, the verification function only validates the aggregate flattened count, not per-player counts. [1](#0-0) 

The code checks only that the total flattened ciphertext count equals total weight, but does not verify that `Cs[player_id].len() == player_weight` for each player. A Byzantine dealer can exploit this by redistributing ciphertexts:
- Setting `Cs[victim_player]` to empty (length 0)
- Padding `Cs[other_player]` with extra chunks  
- Total flattened count still matches, passing verification

The developers acknowledged this missing validation with a TODO comment: [2](#0-1) 

When honest validators decrypt their shares, only debug assertions (compiled out in production) check consistency: [3](#0-2) 

The decryption process uses `decrypt_chunked_scalars()` which employs zip iterators that silently stop at the shortest iterator: [4](#0-3) 

When `Cs` is empty but `Rs` is not, the zip produces zero iterations, returning an empty vector of secret key shares. During weighted reconstruction, the flattening process iterates over each player's sub-shares: [5](#0-4) 

A player with zero sub-shares contributes nothing to `flattened_shares`. If total shares fall below the reconstruction threshold, the assertion fails: [6](#0-5) 

## Impact Explanation

This vulnerability enables a **DKG liveness failure** where a single Byzantine validator can prevent successful DKG completion. This qualifies as **High Severity** under "Validator Node Slowdowns" and "Significant protocol violations" affecting critical network operations.

The DKG protocol is essential for:
- **Epoch transitions**: Validator set updates require successful DKG completion [7](#0-6) 
- **Randomness beacon generation**: On-chain randomness depends on DKG-generated keys [8](#0-7) 
- **Network liveness**: Failed DKG can stall the network, requiring manual intervention through randomness override mechanisms [9](#0-8) 

While not causing permanent network partition or consensus safety violations (Critical severity), this breaks liveness guarantees - a core protocol requirement. The attack affects all participating validators and requires only one malicious dealer within the 1/3 Byzantine fault tolerance assumption.

## Likelihood Explanation

**Likelihood: High** - Any Byzantine validator can trivially exploit this during their dealing turn in the DKG protocol. The attack is:

1. **Simple to execute**: Create a transcript with `Cs[victim] = []` and redistribute chunks to other players
2. **Deterministic**: No timing dependencies or race conditions required
3. **Low cost**: Normal DKG participation, no additional resources needed
4. **Guaranteed to trigger**: The malformed transcript will pass all verification checks
5. **Within threat model**: Requires only 1 Byzantine validator (< 1/3 threshold)

The missing validation is a straightforward implementation gap acknowledged by the TODO comment, making exploitation trivial for any adversarial validator.

## Recommendation

Add per-player ciphertext count validation in the `verify()` function:

```rust
// After line 152 in weighted_transcript.rs, add:
for player_id in 0..sc.get_total_num_players() {
    let player = Player { id: player_id };
    let expected_weight = sc.get_player_weight(&player);
    if self.subtrs.Cs[player_id].len() != expected_weight {
        bail!(
            "Expected {} ciphertext chunks for player {}, but got {}",
            expected_weight,
            player_id,
            self.subtrs.Cs[player_id].len()
        );
    }
}
```

This ensures each player's ciphertext array has exactly the number of chunks corresponding to their weight, preventing the redistribution attack.

## Proof of Concept

A Byzantine validator would construct a malformed transcript during the dealing phase by manipulating the `Cs` array structure before calling the homomorphism to generate the transcript. The malformed transcript would have correct total count but incorrect per-player distribution, causing honest validators' reconstruction to fail when they attempt to aggregate shares below the threshold.

## Notes

This vulnerability affects both the chunky PVSS implementation [10](#0-9)  and the DAS weighted protocol implementation [11](#0-10) , as both only validate the total flattened count without per-player checks.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-152)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L329-329)
```rust
        // TODO: put an assert here saying that len(Cs) = weight
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L578-578)
```rust
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L327-327)
```rust
    for (row, Rs_row) in Cs_rows.iter().zip(Rs_rows.iter()) {
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L430-445)
```rust
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
```

**File:** crates/aptos-dkg/src/lib.rs (L116-116)
```rust
        assert_ge!(shares.len(), sc.get_threshold());
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L1-50)
```text
/// Reconfiguration with DKG helper functions.
module aptos_framework::reconfiguration_with_dkg {
    use std::features;
    use std::option;
    use aptos_framework::consensus_config;
    use aptos_framework::dkg;
    use aptos_framework::execution_config;
    use aptos_framework::gas_schedule;
    use aptos_framework::jwk_consensus_config;
    use aptos_framework::jwks;
    use aptos_framework::keyless_account;
    use aptos_framework::randomness_api_v0_config;
    use aptos_framework::randomness_config;
    use aptos_framework::randomness_config_seqnum;
    use aptos_framework::reconfiguration;
    use aptos_framework::reconfiguration_state;
    use aptos_framework::stake;
    use aptos_framework::system_addresses;
    friend aptos_framework::block;
    friend aptos_framework::aptos_governance;

    /// Trigger a reconfiguration with DKG.
    /// Do nothing if one is already in progress.
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }

    /// Clear incomplete DKG session, if it exists.
    /// Apply buffered on-chain configs (except for ValidatorSet, which is done inside `reconfiguration::reconfigure()`).
    /// Re-enable validator set changes.
    /// Run the default reconfiguration to enter the new epoch.
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** testsuite/smoke-test/src/randomness/randomness_stall_recovery.rs (L73-94)
```rust
            .randomness_override_seq_num = 1;
        validator_override_config
            .override_config_mut()
            .consensus
            .sync_only = false;
        info!("Updating validator {} config.", idx);
        validator_override_config.save_config(config_path).unwrap();
        info!("Restarting validator {}.", idx);
        validator.start().unwrap();
        info!("Let validator {} bake for 5 secs.", idx);
        tokio::time::sleep(Duration::from_secs(5)).await;
    }

    info!("Hot-fixing the VFNs.");
    for (idx, vfn) in swarm.fullnodes_mut().enumerate() {
        info!("Stopping VFN {}.", idx);
        vfn.stop();
        let config_path = vfn.config_path();
        let mut vfn_override_config = OverrideNodeConfig::load_config(config_path.clone()).unwrap();
        vfn_override_config
            .override_config_mut()
            .randomness_override_seq_num = 1;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L450-452)
```rust
        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }
```
