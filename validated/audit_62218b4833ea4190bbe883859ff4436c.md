# Audit Report

## Title
View Function API Bypasses Move Visibility Controls, Exposing Private and Friend Functions

## Summary
The view function execution path in AptosVM fails to enforce Move's visibility controls (private/friend/public), allowing any external caller to invoke private or friend view functions that should only be accessible within their defining module or to friend modules. This completely bypasses the Move language's fundamental access control mechanism for read-only functions.

## Finding Description

Move's visibility system defines three access levels for functions as documented in the official Move book:
- **Private** (no modifier): "can only be called within the same module" [1](#0-0) 
- **`public(friend)`**: Only callable by the same module or modules in the friend list [2](#0-1) 
- **`public`**: Callable by any module or external caller [3](#0-2) 

For regular function calls via bytecode instructions, the Move VM runtime enforces these visibility rules through `check_call_visibility()` which validates cross-module calls: [4](#0-3) 

This check invokes `check_cross_module_regular_call_visibility()` which explicitly rejects private functions and enforces friend restrictions: [5](#0-4) 

However, view functions executed through the API completely bypass this critical validation. The execution path in `execute_view_function_in_vm()` loads the function, validates it, and executes it without any visibility checks: [6](#0-5) 

The `validate_view_function()` only verifies the `#[view]` attribute exists, the function returns values, and arguments are valid: [7](#0-6) 

Critically, this validation never calls `is_private()`, `is_friend()`, or performs any visibility validation, despite the `LoadedFunction` having these methods available: [8](#0-7) 

The underlying `Function` struct stores visibility information: [9](#0-8) 

And implements visibility checking methods: [10](#0-9) 

But this visibility field is never consulted during view function execution. Even at compile-time, the extended checks do not enforce visibility for view functions: [11](#0-10) 

The compiler explicitly allows private functions to be marked with `#[view]`, as confirmed by the test suite: [12](#0-11) 

Real-world examples exist in production code with private view functions: [13](#0-12) 

**Attack Scenario:**
1. A DeFi protocol defines a private view function `get_internal_reserves()` marked with `#[view]` for internal queries
2. An attacker discovers this function through module metadata inspection
3. The attacker calls the view function API endpoint (`/view`) with the module ID and function name
4. The function executes successfully, bypassing all visibility checks
5. Private internal state is leaked to the attacker
6. The attacker uses this information to front-run trades or exploit arbitrage opportunities

## Impact Explanation

This vulnerability represents a **Medium Severity** issue classified as a "Limited Protocol Violation" under the Aptos bug bounty framework.

**Breaks Fundamental Security Invariant**: The Move visibility system is a core security feature designed to provide encapsulation and access control. The official Move documentation explicitly states that private functions "can only be called within the same module." This bypass completely undermines the access control model for view functions, violating a fundamental protocol guarantee that developers rely upon.

**Information Disclosure Risk**: Private view functions in governance, staking, or DeFi modules may expose:
- Internal accounting states not meant for public query
- Validator performance metrics intended for internal use only
- DeFi protocol reserve calculations and internal prices
- Governance proposal details before public announcement

**Violates Developer Expectations**: Module authors who mark functions as private have a reasonable expectation that the Move VM will enforce this restriction. The Move language specification documents this guarantee, but the view function execution path silently fails to uphold it, creating a false sense of security.

While view functions cannot modify state (limiting direct financial impact), the information disclosure severity is significant because it breaks a fundamental protocol invariant. This qualifies as a "Limited Protocol Violation" at Medium severity due to the fundamental nature of the broken invariant.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is:
- **Trivially exploitable**: Requires only a standard HTTP POST to the `/view` API endpoint with module ID and function name
- **No special privileges required**: Any network participant can invoke the view function API
- **Easily discoverable**: Attackers can enumerate module functions through on-chain metadata
- **Affects all deployed modules**: Any module with private or friend view functions is immediately vulnerable
- **Difficult to detect**: Module authors may not realize their private view functions are externally callable without explicit testing

The exploit requires no complex setup, coordination, or special access. Any user can immediately test calling private view functions through the publicly accessible REST API.

## Recommendation

Add visibility checking to the view function validation path:

1. In `validate_view_function()`, after checking the `#[view]` attribute, add visibility validation:
   - Check if the function `is_private()` or `is_friend()`
   - If private, reject the call with an error indicating visibility violation
   - If friend, validate that the caller is in the friend list (though this is complex for API calls which have no "caller module")

2. Alternative approach: Disallow private/friend functions from being marked with `#[view]` at compile-time by adding a check in `extended_checks.rs` that view functions must be public.

3. Update documentation to clarify that view functions must be public to be callable via the API, or explicitly document that view functions bypass visibility controls (though this would be a security anti-pattern).

The recommended fix is option 2: enforce at compile-time that `#[view]` can only be applied to public functions, maintaining the visibility system's integrity.

## Proof of Concept

```move
module 0xCAFE::Test {
    use std::signer;
    
    // Private view function that should NOT be callable externally
    #[view]
    fun get_secret_value(addr: address): u64 acquires SecretData {
        borrow_global<SecretData>(addr).secret
    }
    
    struct SecretData has key {
        secret: u64
    }
    
    public entry fun initialize(account: &signer) {
        move_to(account, SecretData { secret: 12345 });
    }
}
```

To exploit:
1. Deploy the module above
2. Call `initialize` to store secret data
3. Make a POST request to `/view` endpoint:
```json
{
  "function": "0xCAFE::Test::get_secret_value",
  "type_arguments": [],
  "arguments": ["0xCAFE"]
}
```

Expected: Request should fail with visibility violation error
Actual: Request succeeds and returns `12345`, bypassing private visibility

## Notes

This vulnerability represents a clear violation of Move's documented security model. While the immediate impact is limited to information disclosure (no state modification possible), it fundamentally breaks the access control guarantees that the Move language provides. Developers who mark functions as private have a legitimate expectation that the runtime will enforce this restriction across all execution paths, including view function calls through the API.

### Citations

**File:** third_party/move/documentation/book/src/functions.md (L21-21)
```markdown
Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.
```

**File:** third_party/move/documentation/book/src/functions.md (L48-53)
```markdown
#### `public` visibility

A `public` function can be called by *any* function defined in *any* module or script. As shown in the following example, a `public` function can be called by:
- other functions defined in the same module,
- functions defined in another module, or
- the function defined in a script.
```

**File:** third_party/move/documentation/book/src/functions.md (L78-84)
```markdown
#### `public(friend)` visibility

The `public(friend)` visibility modifier is a more restricted form of the `public` modifier to give more control about where a function can be used. A `public(friend)` function can be called by:
- other functions defined in the same module, or
- functions defined in modules which are explicitly specified in the **friend list** (see [Friends](./friends.md) on how to specify the friend list).

Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a `public(friend)` function.
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L42-81)
```rust
    fn check_call_visibility(
        caller: &LoadedFunction,
        callee: &LoadedFunction,
        call_type: CallType,
    ) -> PartialVMResult<()> {
        match call_type {
            CallType::Regular => {
                // We only need to check cross-contract calls.
                if caller.module_id() == callee.module_id() {
                    return Ok(());
                }
                Self::check_cross_module_regular_call_visibility(caller, callee)
            },
            CallType::ClosureDynamicDispatch => {
                // In difference to regular calls, we skip visibility check. It is possible to call
                // a private function of another module via a closure.
                Ok(())
            },
            CallType::NativeDynamicDispatch => {
                // Dynamic dispatch may fail at runtime and this is ok. Hence, these errors are not
                // invariant violations as they cannot be checked at compile- or load-time.
                //
                // Note: native dispatch cannot call into the same module, otherwise the reentrancy
                // check is broken. For more details, see AIP-73:
                //   https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-73.md
                if callee.is_friend_or_private() || callee.module_id() == caller.module_id() {
                    return Err(PartialVMError::new(StatusCode::RUNTIME_DISPATCH_ERROR)
                        .with_message(
                            "Invoking private or friend function during dispatch".to_string(),
                        ));
                }

                if callee.is_native() {
                    return Err(PartialVMError::new(StatusCode::RUNTIME_DISPATCH_ERROR)
                        .with_message("Invoking native function during dispatch".to_string()));
                }
                Ok(())
            },
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L945-981)
```rust
    fn check_cross_module_regular_call_visibility(
        caller: &LoadedFunction,
        callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if callee.is_private() {
            let msg = format!(
                "Function {}::{} cannot be called because it is private",
                callee.module_or_script_id(),
                callee.name()
            );
            return Err(
                PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
            );
        }

        if callee.is_friend() {
            let callee_module = callee.owner_as_module().map_err(|err| err.to_partial())?;
            if !caller
                .module_id()
                .is_some_and(|id| callee_module.friends.contains(id))
            {
                let msg = format!(
                    "Function {}::{} cannot be called because it has friend visibility, but {} \
                     is not {}'s friend",
                    callee.module_or_script_id(),
                    callee.name(),
                    caller.module_or_script_id(),
                    callee.module_or_script_id()
                );
                return Err(
                    PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
                );
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2739-2791)
```rust
    fn execute_view_function_in_vm(
        session: &mut SessionExt<impl AptosMoveResolver>,
        vm: &AptosVM,
        module_id: ModuleId,
        func_name: Identifier,
        ty_args: Vec<TypeTag>,
        arguments: Vec<Vec<u8>>,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<Vec<Vec<u8>>, VMError> {
        dispatch_loader!(module_storage, loader, {
            let func = loader.load_instantiated_function(
                &LegacyLoaderConfig::unmetered(),
                gas_meter,
                traversal_context,
                &module_id,
                &func_name,
                &ty_args,
            )?;

            let metadata = get_metadata(&func.owner_as_module()?.metadata);

            let arguments = view_function::validate_view_function(
                session,
                &loader,
                gas_meter,
                traversal_context,
                arguments,
                func_name.as_ident_str(),
                &func,
                metadata.as_ref().map(Arc::as_ref),
                vm.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )
            .map_err(|e| e.finish(Location::Module(module_id)))?;

            let result = session.execute_loaded_function(
                func,
                arguments,
                gas_meter,
                traversal_context,
                &loader,
                // No need to record any traces for view functions.
                &mut NoOpTraceRecorder,
            )?;

            Ok(result
                .return_values
                .into_iter()
                .map(|(bytes, _ty)| bytes)
                .collect::<Vec<_>>())
        })
    }
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L35-92)
```rust
pub(crate) fn validate_view_function(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    args: Vec<Vec<u8>>,
    fun_name: &IdentStr,
    func: &LoadedFunction,
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    struct_constructors_feature: bool,
) -> PartialVMResult<Vec<Vec<u8>>> {
    // Must be marked as view function.
    let is_view = determine_is_view(module_metadata, fun_name);
    if !is_view {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("function not marked as view function".to_string()),
        );
    }

    // Must return values.
    if func.return_tys().is_empty() {
        return Err(
            PartialVMError::new(StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE)
                .with_message("view function must return values".to_string()),
        );
    }

    let allowed_structs = get_allowed_structs(struct_constructors_feature);
    let result = if loader.is_lazy_loading_enabled() {
        transaction_arg_validation::construct_args(
            session,
            loader,
            gas_meter,
            traversal_context,
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    } else {
        let traversal_storage = TraversalStorage::new();
        transaction_arg_validation::construct_args(
            session,
            loader,
            // No metering with eager loading.
            &mut UnmeteredGasMeter,
            &mut TraversalContext::new(&traversal_storage),
            func.param_tys(),
            args,
            func.ty_args(),
            allowed_structs,
            true,
        )
    };
    result.map_err(|e| PartialVMError::new(e.status_code()))
}
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L66-92)
```rust
pub struct Function {
    #[allow(unused)]
    pub(crate) file_format_version: u32,
    pub(crate) index: FunctionDefinitionIndex,
    pub(crate) code: Vec<Instruction>,
    pub(crate) ty_param_abilities: Vec<AbilitySet>,
    // TODO: Make `native` and `def_is_native` become an enum.
    pub(crate) native: Option<NativeFunction>,
    pub(crate) is_native: bool,
    /// If true, this is a native function which does native dynamic dispatch (main use cases are
    /// fungible asset and account abstraction).
    pub(crate) is_dispatchable_native: bool,
    pub(crate) visibility: Visibility,
    pub(crate) is_entry: bool,
    pub(crate) name: Identifier,
    pub(crate) return_tys: Vec<Type>,
    // For non-native functions: parameter types first and then local types, if any.
    // For native functions, an empty vector (there are no locals). This is very important because
    // gas is charged based on number of locals which should be 0 for native calls (to be backwards
    // compatible).
    pub(crate) local_tys: Vec<Type>,
    pub(crate) param_tys: Vec<Type>,
    pub(crate) access_specifier: AccessSpecifier,
    pub(crate) is_persistent: bool,
    pub(crate) has_module_reentrancy_lock: bool,
    pub(crate) is_trusted: bool,
}
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L532-549)
```rust
    pub fn is_friend_or_private(&self) -> bool {
        self.is_friend() || self.is_private()
    }

    /// Returns true if the loaded function has public visibility.
    pub fn is_public(&self) -> bool {
        self.function.is_public()
    }

    /// Returns true if the loaded function has friend visibility.
    pub fn is_friend(&self) -> bool {
        self.function.is_friend()
    }

    /// Returns true if the loaded function has private visibility.
    pub fn is_private(&self) -> bool {
        self.function.is_private()
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L756-766)
```rust
    pub fn is_public(&self) -> bool {
        matches!(self.visibility, Visibility::Public)
    }

    pub fn is_friend(&self) -> bool {
        matches!(self.visibility, Visibility::Friend)
    }

    pub fn is_private(&self) -> bool {
        matches!(self.visibility, Visibility::Private)
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L689-741)
```rust
    fn check_and_record_view_functions(&mut self, module: &ModuleEnv) {
        for ref fun in module.get_functions() {
            if !self.has_attribute(fun, VIEW_FUN_ATTRIBUTE) {
                continue;
            }
            self.check_transaction_args(&fun.get_parameters());
            if fun.get_return_count() == 0 {
                self.env
                    .error(&fun.get_id_loc(), "`#[view]` function must return values")
            }

            fun.get_parameters()
                .iter()
                .for_each(
                    |Parameter(_sym, parameter_type, param_loc)| match parameter_type {
                        Type::Primitive(inner) => {
                            if inner == &PrimitiveType::Signer {
                                self.env.error(
                                    param_loc,
                                    "`#[view]` function cannot use a `signer` parameter",
                                )
                            }
                        },
                        Type::Reference(mutability, inner) => {
                            if let Type::Primitive(inner) = inner.as_ref() {
                                if inner == &PrimitiveType::Signer
                                // Avoid a redundant error message for `&mut signer`, which is
                                // always disallowed for transaction entries, not just for
                                // `#[view]`.
                                    && mutability == &ReferenceKind::Immutable
                                {
                                    self.env.error(
                                        param_loc,
                                        "`#[view]` function cannot use the `&signer` parameter",
                                    )
                                }
                            }
                        },
                        _ => (),
                    },
                );

            // Remember the runtime info that this is a view function
            let module_id = self.get_runtime_module_id(module);
            self.output
                .entry(module_id)
                .or_default()
                .fun_attributes
                .entry(fun.get_simple_name_string().to_string())
                .or_default()
                .push(KnownAttribute::view_function());
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L18-35)
```rust
#[test]
fn test_view_attribute() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun view(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    assert_success!(h.publish_package(&account, path.path()));
}
```

**File:** aptos-move/move-examples/token_objects/hero/sources/hero.move (L226-258)
```text
    #[view]
    fun view_hero(creator: address, collection: String, name: String): Hero acquires Hero {
        let token_address = token::create_token_address(
            &creator,
            &collection,
            &name,
        );
        move_from<Hero>(token_address)
    }

    #[view]
    fun view_hero_by_object(hero_obj: Object<Hero>): Hero acquires Hero {
        let token_address = object::object_address(&hero_obj);
        move_from<Hero>(token_address)
    }

    #[view]
    fun view_object<T: key>(obj: Object<T>): String acquires Armor, Gem, Hero, Shield, Weapon {
        let token_address = object::object_address(&obj);
        if (exists<Armor>(token_address)) {
            string_utils::to_string(borrow_global<Armor>(token_address))
        } else if (exists<Gem>(token_address)) {
            string_utils::to_string(borrow_global<Gem>(token_address))
        } else if (exists<Hero>(token_address)) {
            string_utils::to_string(borrow_global<Hero>(token_address))
        } else if (exists<Shield>(token_address)) {
            string_utils::to_string(borrow_global<Shield>(token_address))
        } else if (exists<Weapon>(token_address)) {
            string_utils::to_string(borrow_global<Weapon>(token_address))
        } else {
            abort EINVALID_TYPE
        }
    }
```
