# Audit Report

## Title
Order Vote Creation Race Condition Causes Network Liveness Failure Due to Non-Deterministic BlockInfo

## Summary
The `order_vote_proposal()` method creates order votes with non-deterministic `BlockInfo` that varies based on execution completion timing. This causes validators with different execution speeds to generate incompatible order votes, preventing quorum formation and blocking consensus ordering.

## Finding Description

The Aptos consensus protocol implements decoupled execution where voting and execution occur asynchronously. Regular votes correctly use deterministic dummy state, but order votes have a critical flaw that breaks this determinism.

**Regular Vote Path (Correct):**
Regular votes explicitly create `VoteProposal` with `decoupled_execution: true`, which causes `gen_vote_data()` to return `vote_data_ordering_only()` that generates deterministic BlockInfo with `ACCUMULATOR_PLACEHOLDER_HASH` and version 0. [1](#0-0) [2](#0-1) [3](#0-2) 

**Order Vote Path (Vulnerable):**
Order votes use a fundamentally different approach. The `order_vote_proposal()` method directly calls `self.block_info()`, which reads the current execution state from a mutex. [4](#0-3) 

The `block_info()` method calls `compute_result()` which returns whatever state is currently stored in the mutex: [5](#0-4) [6](#0-5) 

**Asynchronous Execution Updates:**
The execution pipeline asynchronously updates this state via `set_compute_result()` after execution completes, replacing the initial dummy state with actual execution results: [7](#0-6) [8](#0-7) 

**Safety Rules Validation:**
Safety rules explicitly validate that the order vote's BlockInfo matches the QC's certified block. If they differ, the order vote is rejected: [9](#0-8) 

**BlockInfo Structure:**
BlockInfo contains execution-specific fields (`executed_state_id` and `version`) that differ between dummy and executed states. The structure derives `PartialEq` for field-by-field comparison: [10](#0-9) 

The `is_ordered_only()` method confirms that dummy state uses `ACCUMULATOR_PLACEHOLDER_HASH` and version 0: [11](#0-10) 

**The Race Condition:**
Blocks are initialized with dummy state using `StateComputeResult::new_dummy()` which returns `ACCUMULATOR_PLACEHOLDER_HASH`: [12](#0-11) 

Order votes are created immediately after QC formation in the voting process: [13](#0-12) 

The sequence creates a race:
1. Block inserted with dummy state
2. Execution starts asynchronously
3. Validators vote with dummy state → QC forms with dummy state
4. Order votes created immediately after QC formation
5. **Fast validators**: execution completed → `block_info()` returns executed state → safety rules reject (BlockInfo mismatch)
6. **Slow validators**: execution not completed → `block_info()` returns dummy state → safety rules accept

## Impact Explanation

This vulnerability causes **temporary liveness failures** in the consensus ordering phase, qualifying as **HIGH severity** per Aptos Bug Bounty criteria ("Validator Node Slowdowns").

**Consensus Determinism Violation:**
The fundamental invariant that all validators must sign identical data is broken. Validators sign different BlockInfo structs depending on execution timing rather than block content.

**Liveness Impact:**
If fewer than 2f+1 validators create valid order votes (those with dummy state matching the QC), no ordered certificate can form. The ordering phase blocks until execution states converge or timeouts occur, causing:
- Increased block finalization latency
- Potential timeout cascades
- Network slowdown during periods of execution variance

**Not Critical Because:**
- Safety is preserved (no double-spend or chain split)
- Liveness eventually recovers when execution states converge
- No permanent network halt or fund loss

## Likelihood Explanation

**MODERATE to HIGH** likelihood due to natural network conditions:

1. **Hardware Variance**: Validators run on diverse hardware with different execution speeds. A validator with 128 cores can execute blocks significantly faster than an overloaded validator.

2. **Network Topology**: Validators receive blocks at different times based on network distance, giving early-receiving validators more time to complete execution.

3. **Empty/Small Blocks**: Blocks with few transactions execute very quickly, maximizing the probability that execution completes before order vote creation.

4. **No Synchronization**: The code has no mechanism to delay order vote creation or force dummy state usage for order votes like it does for regular votes. Decoupled execution is always enabled: [14](#0-13) 

5. **Observable Timing**: QC formation requires 2f+1 votes which takes time due to network propagation, while local execution can complete much faster, creating a race window.

## Recommendation

Modify `order_vote_proposal()` to use deterministic dummy state consistently, matching the approach used in `vote_proposal()`:

```rust
pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
    // Use dummy state for ordering-only consensus, similar to vote_proposal()
    let block_info = self.block.gen_block_info(
        *ACCUMULATOR_PLACEHOLDER_HASH,
        0,
        None,
    );
    OrderVoteProposal::new(self.block.clone(), block_info, quorum_cert)
}
```

This ensures order votes always use dummy state that matches the QC, eliminating the race condition.

## Proof of Concept

This vulnerability occurs naturally during normal network operation without requiring any special setup. The race condition manifests when:
1. A block is proposed and validators begin voting
2. Some validators complete execution quickly (fast hardware, empty block)
3. QC forms with dummy state from regular votes
4. Fast validators attempt order vote creation but fail safety rules validation
5. If <2f+1 validators successfully create order votes, ordering stalls

The vulnerability is inherent in the code structure difference between `vote_proposal()` (uses `decoupled_execution: true`) and `order_vote_proposal()` (reads mutable state), making it reproducible on any network with execution timing variance.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-307)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L461-469)
```rust
    pub fn vote_proposal(&self) -> VoteProposal {
        let compute_result = self.compute_result();
        VoteProposal::new(
            compute_result.extension_proof(),
            self.block.clone(),
            compute_result.epoch_state().clone(),
            true,
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L88-90)
```rust
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-77)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
        .boxed();
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L209-214)
```rust
    pub fn is_ordered_only(&self) -> bool {
        *self != BlockInfo::empty()
            && self.next_epoch_state.is_none()
            && self.executed_state_id == *ACCUMULATOR_PLACEHOLDER_HASH
            && self.version == 0
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L70-76)
```rust
    /// generate a new dummy state compute result with ACCUMULATOR_PLACEHOLDER_HASH as the root hash.
    /// this function is used in ordering_state_computer as a dummy state compute result,
    /// where the real compute result is generated after ordering_state_computer.commit pushes
    /// the blocks and the finality proof to the execution phase.
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/round_manager.rs (L1805-1816)
```rust
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
                Ok(())
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```
