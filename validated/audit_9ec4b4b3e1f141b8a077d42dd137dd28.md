# Audit Report

## Title
Gas Metering Bypass in Layout Cache: O(n²) Computation with O(n) Gas Cost via Nested Struct Hierarchies

## Summary
The Move VM's layout cache system caches only root struct layouts, not sub-layouts of nested fields. Combined with TraversalContext's per-transaction module visit tracking, this creates a gas metering bypass where an attacker can trigger O(n²) layout construction computations while paying only O(n) gas costs within a single transaction.

## Finding Description

The vulnerability stems from two design decisions in the Move VM's layout caching system that interact to create a gas metering bypass:

**Design Decision 1: Root-Only Caching**

The layout cache explicitly stores only root layouts, not sub-layouts of nested fields. [1](#0-0)  This architectural choice means that when requesting layouts for types A{b:B}, B{c:C}, and C{d:D} separately, the nested layouts must be reconstructed each time despite being part of previously constructed parent layouts.

**Design Decision 2: Per-Transaction Module Visit Tracking**

The TraversalContext maintains a visited set of modules within a transaction. [2](#0-1)  The `visit_if_not_special_module_id` method returns `false` when a module has already been visited, [3](#0-2)  preventing duplicate gas charges.

**Attack Mechanism:**

When a transaction loads resources of types A, B, C, and D where these types are deeply nested (A contains B, B contains C, C contains D):

1. **First resource load (type A):**
   - The data cache calls `create_data_cache_entry` which invokes layout construction [4](#0-3) 
   - Layout construction recursively processes all nested structs [5](#0-4) 
   - Marks modules A, B, C, D as visited and charges gas via `charge_module` [6](#0-5) 
   - Caches only layout A (root-only caching) [7](#0-6) 

2. **Second resource load (type B):**
   - B not in cache, constructs layout for B which recursively constructs C, D
   - Attempts to charge gas for modules B, C, D via `charge_module`
   - Since modules already visited, `visit_if_not_special_module_id` returns false → NO GAS CHARGED
   - Caches only layout B

3. **Subsequent loads (types C and D):**
   - Same pattern: layouts reconstructed but no gas charged for already-visited modules

**Cost Analysis:**
- Gas charged: O(n) for n modules (only on first visit)
- Computation performed: O(n²) due to repeated nested layout construction (1+2+3+...+n = n(n+1)/2)
- For depth=100: ~5,050 layout constructions for gas cost of ~100 modules
- **Amplification factor: ~50x**

The vulnerability violates the fundamental invariant that gas costs must be proportional to computational costs. The layout cache is global and shared across transactions, [8](#0-7)  but layout construction happens regardless of whether gas is charged.

## Impact Explanation

**Severity: High** ($50,000 according to Aptos Bug Bounty - Validator Node Slowdowns)

This vulnerability enables a **validator computational resource exhaustion attack** through gas metering bypass:

1. **Disproportionate Computational Load**: Attackers can craft transactions causing O(n²) computational work while paying O(n) gas. The layout depth limit is 128, [9](#0-8)  allowing up to 8,256 layout constructions for the cost of 128 module charges (~64x amplification).

2. **Validator Performance Degradation**: Within a single transaction, all validators perform the disproportionate computational work. Layout construction involves loading struct definitions, recursive field processing, and memory allocation—all computationally expensive operations performed during transaction execution.

3. **Deterministic but Wasteful**: While all validators perform identical operations (preserving consensus determinism), they all waste computational resources on redundant layout constructions that are neither cached nor properly charged.

4. **Below-Market Gas Rates**: The attack enables resource exhaustion at 1/50th to 1/64th the expected gas cost for the computation performed, violating the economic security model that relies on gas metering to prevent DoS attacks.

This falls under the "Validator Node Slowdowns (High)" category: significant performance degradation affecting consensus through resource exhaustion via gas metering bypass.

## Likelihood Explanation

**Likelihood: High (with limitations)**

The vulnerability can be exploited within a single transaction:

1. **Simple Attack Vector**: 
   - Deploy Move modules with deeply nested struct definitions (structs need both `key` and `store` abilities to be nested resources) [10](#0-9) 
   - Each module exposes a public function calling `borrow_global<T>()` for its type [11](#0-10) 
   - Send transaction calling all functions in sequence

2. **No Special Privileges Required**: Any user can deploy modules and publish resources on Aptos mainnet.

3. **Low Relative Cost**: Attacker pays O(n) gas but causes O(n²) computation within one transaction, achieving significant amplification.

4. **Limitation**: While exploitable once per module set per cache lifetime, [12](#0-11)  the attacker can deploy multiple module sets to sustain attacks across transactions. Module deployment costs provide economic resistance to sustained attacks.

## Recommendation

**Option 1: Cache Sub-Layouts**
Modify the layout caching system to cache all constructed layouts during the recursive traversal, not just the root layout. Update `store_layout_to_cache` to accept and store intermediate layouts.

**Option 2: Charge Gas Proportionally**
Modify `charge_module` to track and charge for layout construction work separately from module loading, ensuring computational cost matches gas charged even when modules are already visited.

**Option 3: Layout Construction Budget**
Introduce a per-transaction budget for layout construction operations that is charged independently of module visit tracking, preventing the O(n²) exploitation.

## Proof of Concept

```move
// Module A
module 0xAttacker::A {
    use 0xAttacker::B;
    struct ResourceA has key, store { b: B::ResourceB }
    public fun load_a(addr: address) acquires ResourceA {
        borrow_global<ResourceA>(addr);
    }
}

// Module B  
module 0xAttacker::B {
    use 0xAttacker::C;
    struct ResourceB has key, store { c: C::ResourceC }
    public fun load_b(addr: address) acquires ResourceB {
        borrow_global<ResourceB>(addr);
    }
}

// Module C
module 0xAttacker::C {
    use 0xAttacker::D;
    struct ResourceC has key, store { d: D::ResourceD }
    public fun load_c(addr: address) acquires ResourceC {
        borrow_global<ResourceC>(addr);
    }
}

// Module D
module 0xAttacker::D {
    struct ResourceD has key, store { x: u64 }
    public fun load_d(addr: address) acquires ResourceD {
        borrow_global<ResourceD>(addr);
    }
}

// Attack transaction calls:
// A::load_a(@addr); // 4 layouts constructed, 4 modules charged
// B::load_b(@addr); // 3 layouts constructed, 0 modules charged (already visited)
// C::load_c(@addr); // 2 layouts constructed, 0 modules charged
// D::load_d(@addr); // 1 layout constructed, 0 modules charged
// Total: 10 layout constructions for cost of 4 module charges
```

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L9-16)
```rust
//! Additionally, caches store only the layouts of resources (i.e., if there is a request for the
//! layout of resource A which contains a struct B inside, a layout of A is created and cached, but
//! not the layout of B - requesting layout of B will result in a cache miss). There is NO caching
//! for sub-layouts
//! because:
//!   1. This is more error-prone because enforcing of semantic equivalence when reading sub-layout
//!      is more difficult: e.g., one needs to ensure the depth and size of layouts are correct.
//!   2. Arguably, we need layouts for root-like values only (e.g., those with `key` ability).
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L23-24)
```rust
pub struct TraversalContext<'a> {
    visited: BTreeMap<(&'a AccountAddress, &'a IdentStr), ()>,
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L70-85)
```rust
    pub fn visit_if_not_special_module_id(&mut self, module_id: &ModuleId) -> bool {
        let addr = module_id.address();
        if addr.is_special() {
            return false;
        }

        let name = module_id.name();
        if self.visited.contains_key(&(addr, name)) {
            false
        } else {
            let module_id = self.referenced_module_ids.alloc(module_id.clone());
            self.visited
                .insert((module_id.address(), module_id.name()), ());
            true
        }
    }
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L255-278)
```rust
    fn create_data_cache_entry(
        metadata_loader: &impl ModuleMetadataLoader,
        layout_converter: &LayoutConverter<impl StructDefinitionLoader>,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &dyn ModuleStorage,
        resource_resolver: &dyn ResourceResolver,
        addr: &AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<(DataCacheEntry, NumBytes)> {
        let struct_tag = match module_storage.runtime_environment().ty_to_ty_tag(ty)? {
            TypeTag::Struct(struct_tag) => *struct_tag,
            _ => {
                // Since every resource is a struct, the tag must be also a struct tag.
                return Err(PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR));
            },
        };

        let layout_with_delayed_fields = layout_converter.type_to_type_layout_with_delayed_fields(
            gas_meter,
            traversal_context,
            ty,
            false,
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L117-129)
```rust
                // Otherwise a cache miss, compute the result and store it.
                let mut modules = DefiningModules::new();
                let layout = self.type_to_type_layout_with_delayed_fields_impl::<false>(
                    gas_meter,
                    traversal_context,
                    &mut modules,
                    ty,
                    check_option_type,
                )?;
                let cache_entry = LayoutCacheEntry::new(layout.clone(), modules);
                self.struct_definition_loader
                    .store_layout_to_cache(&key, cache_entry)?;
                return Ok(layout);
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L368-389)
```rust
    fn struct_to_type_layout<const ANNOTATED: bool>(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        modules: &mut DefiningModules,
        idx: &StructNameIndex,
        ty_args: &[Type],
        count: &mut u64,
        depth: u64,
        check_option_type: bool,
    ) -> PartialVMResult<(MoveTypeLayout, bool)> {
        let struct_definition = self.struct_definition_loader.load_struct_definition(
            gas_meter,
            traversal_context,
            idx,
        )?;
        let struct_identifier = self
            .struct_definition_loader
            .runtime_environment()
            .struct_name_index_map()
            .idx_to_struct_name_ref(*idx)?;
        modules.insert(struct_identifier.module());
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L55-77)
```rust
    fn charge_module(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<()> {
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L94-96)
```rust
    /// Cached layouts of structs or enums. This cache stores roots only and is invalidated when
    /// modules are published.
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L163-168)
```rust
    pub fn flush_layout_cache(&self) {
        // TODO(layouts):
        //   Flushing is only needed because of enums. Once we refactor layouts to store a single
        //   variant instead, this can be removed.
        self.struct_layouts.clear();
    }
```

**File:** third_party/move/move-vm/runtime/src/config.rs (L69-70)
```rust
            layout_max_size: 512,
            layout_max_depth: 128,
```

**File:** third_party/move/documentation/book/src/abilities.md (L44-48)
```markdown
### `key`

The `key` ability allows the type to serve as a key for [global storage operations](./global-storage-operators.md). It gates all global storage operations, so in order for a type to be used with `move_to`, `borrow_global`, `move_from`, etc., the type must have the `key` ability. Note that the operations still must be used in the module where the `key` type is defined (in a sense, the operations are private to the defining module).

If a value has `key`, all values contained inside of that value have `store`. This is the only ability with this sort of asymmetry.
```

**File:** third_party/move/documentation/book/src/global-storage-operators.md (L10-15)
```markdown
|`borrow_global_mut<T>(address): &mut T` | Return a mutable reference to the `T` stored under `address`    | If `address` does not hold a `T`        |
|`borrow_global<T>(address): &T`         | Return an immutable reference to the `T` stored under `address` | If `address` does not hold a `T`        |
|`exists<T>(address): bool`              | Return `true` if a `T` is stored under `address`                |  Never                                  |


Each of these instructions is parameterized by a type `T` with the [`key` ability](./abilities.md). However, each type `T` *must be declared in the current module*. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an [`address`](./address.md) or [`&signer`](./signer.md) representing the account address where the resource of type `T` is stored.
```
