# Audit Report

## Title
Transaction Loss During Validator Node Bootstrapping Due to Historical Commit Notifications

## Summary
BCS transactions submitted via the REST API during validator node synchronization are silently lost when the node processes historical blocks containing transactions with matching sender and sequence number. The mempool incorrectly removes newly submitted transactions upon receiving commit notifications for historical transactions, violating transaction delivery guarantees.

## Finding Description

During validator node bootstrapping, a critical race condition exists between REST API transaction acceptance and state synchronization that results in permanent transaction loss. The issue arises from the interaction between multiple components that were not designed to handle the bootstrapping phase correctly.

**Validated Execution Flow:**

1. **API Accepts Transactions Without Bootstrap Check**: The REST API transaction submission endpoint only verifies the `transaction_submission_enabled` flag before accepting transactions, with no check for bootstrap completion status. [1](#0-0)  The flag defaults to `true` in the configuration. [2](#0-1) 

2. **Transaction Validated Against Partially Synced State**: When transactions arrive, the API fetches the latest ledger info to validate them. [3](#0-2)  This returns the current storage state via `get_latest_ledger_info()`. [4](#0-3)  During bootstrapping, this reflects partially-synced state rather than the full network state.

3. **Storage Synchronizer Notifies Mempool of All Commits**: The storage synchronizer spawns a commit post-processor during initialization that processes ALL committed chunks without distinguishing between historical replays and real-time commits. [5](#0-4)  The commit post-processor is spawned during `StorageSynchronizer::new`. [6](#0-5) 

4. **Mempool Processes All Commit Notifications Identically**: When mempool receives commit notifications, it processes them uniformly through `handle_commit_notification`. [7](#0-6)  This calls `process_committed_transactions` which treats all commits identically. [8](#0-7) 

5. **Sequence Number Update Triggers Removal**: For sequence-number based transactions, `commit_transaction` updates the account sequence number and then calls cleanup. [9](#0-8)  The new sequence number is calculated as `max(current_account_seq_number, txn_sequence_number + 1)`. [10](#0-9) 

6. **All Lower Sequence Transactions Removed**: The cleanup method removes ALL transactions with sequence numbers strictly less than the provided account sequence number. [11](#0-10)  This includes newly submitted transactions that share the same sequence number as historical transactions.

**Component Initialization Confirms Vulnerability Window**: The node initialization sequence shows that the API is bootstrapped and starts accepting connections before state sync completes. [12](#0-11)  Mempool is also started before waiting for state sync initialization. [13](#0-12)  The API server begins listening for connections immediately. [14](#0-13) 

**Attack Scenario:**

1. Validator node restarts and begins bootstrapping from version 1000 to version 2000
2. At version 1000, account A has sequence number 50 (next expected transaction is A:50)
3. User queries the bootstrapping node and sees sequence 50 as the next expected
4. User submits a fresh transaction A:50 via `/transactions` endpoint
5. Mempool validates against state at version 1000, accepts transaction, returns HTTP 202 Accepted
6. State sync continues processing historical blocks
7. At version 1500, a historical transaction A:50 (different content, already committed on network) is processed
8. Storage synchronizer sends commit notification to mempool for historical A:50
9. Mempool updates account A's sequence to 51 and calls `clean_committed_transactions_below_account_seq_num(account, 51)`
10. The cleanup removes ALL transactions with sequence < 51, including the user's newly submitted A:50
11. User's transaction is permanently lost without any notification mechanism

**Security Guarantees Broken:**
- **API Contract Violation**: HTTP 202 Accepted response indicates the transaction will be processed, but it is silently discarded
- **Transaction Delivery Guarantee**: Accepted transactions should either be processed or explicitly rejected with notification
- **State Consistency**: Mempool state becomes inconsistent with user expectations who received successful submission confirmations

## Impact Explanation

This vulnerability qualifies as **Medium Severity** according to Aptos bug bounty criteria:

**State inconsistencies requiring manual intervention**: The mempool state becomes inconsistent with user expectations. Users receive successful HTTP 202 Accepted responses but their transactions vanish without trace. Users must manually detect the loss and resubmit with updated sequence numbers.

**Limited funds loss or manipulation**: Users submitting transactions to bootstrapping nodes lose those transactions entirely. For fund transfers, payments, or time-sensitive operations (e.g., DeFi trades, NFT purchases), users suffer financial loss while believing their transactions succeeded. The loss is "limited" in that it affects individual users rather than causing network-wide fund theft.

**Silent failure without notification mechanism**: Users have no way to detect transaction loss. The initial HTTP 202 Accepted response provides false confidence, and there are no subsequent notifications about mempool removal. The transaction simply disappears.

The impact does not reach Critical severity because:
- Only affects individual users submitting to bootstrapping nodes (not network-wide)
- Does not compromise consensus safety or validator operation
- Temporary vulnerability window exists only during bootstrapping phase
- Does not enable unlimited fund theft or network halting

However, it clearly exceeds Low severity because:
- Results in actual transaction loss with direct financial implications
- Occurs during normal operations (node restarts are routine maintenance)
- Affects real user transactions with no automated recovery mechanism
- Violates fundamental API contract guarantees

## Likelihood Explanation

**High Likelihood Assessment:**

1. **Bootstrapping is Common**: Validator nodes frequently bootstrap in multiple scenarios:
   - New validators joining the network must sync from genesis or checkpoint
   - Existing validators restarting for software updates or maintenance
   - Nodes recovering from crashes or hardware failures
   - Nodes falling behind due to network issues and needing to catch up
   
   These scenarios create frequent and predictable vulnerability windows.

2. **API Enabled by Default**: The `transaction_submission_enabled` flag defaults to `true` with no automatic disabling during bootstrapping. [2](#0-1) [15](#0-14) 

3. **No Bootstrap State Check**: The API transaction submission endpoint performs no verification of bootstrap completion before accepting transactions. [1](#0-0)  The only validation is the configuration flag check.

4. **Mempool Operational During Bootstrap**: Mempool is initialized and fully operational while state sync processes historical blocks, allowing the race condition to occur throughout the entire bootstrapping period. The initialization sequence confirms mempool starts before state sync completes. [16](#0-15) 

5. **Extended Vulnerability Window**: The vulnerability persists for the entire duration of bootstrapping, which can range from minutes to hours depending on how far behind the node has fallen. During this entire window, any user transaction can be lost.

6. **User Discovery Probability**: Users have no indication that a node is bootstrapping. The API responds normally to queries, returning partially-synced state that appears valid. Users submitting transactions receive standard HTTP 202 responses, creating false confidence.

## Recommendation

Implement bootstrap-aware transaction submission with the following changes:

1. **Add Bootstrap State Check to API**: Modify the transaction submission endpoint to verify bootstrap completion before accepting transactions:

```rust
// In api/src/transactions.rs, modify submit_transaction:
if !self.context.node_config.api.transaction_submission_enabled {
    return Err(api_disabled("Submit transaction"));
}

// Add bootstrap check
if !self.context.is_bootstrapped() {
    return Err(service_unavailable(
        "Node is bootstrapping, transaction submission temporarily unavailable"
    ));
}
```

2. **Expose Bootstrap State in Context**: Add a method to check bootstrap completion status from the state sync driver through the API context.

3. **Filter Historical Commit Notifications**: Modify the commit post-processor to tag notifications as historical vs. real-time, and have mempool handle them differently:

```rust
// In mempool commit handling, skip removal for historical commits during bootstrap
if notification.is_historical && !is_bootstrapped {
    // Log but don't remove user-submitted transactions
    continue;
}
```

4. **Automatic Flag Management**: Automatically set `transaction_submission_enabled = false` during bootstrapping and re-enable it only after bootstrap completion.

5. **User-Facing Indication**: Add a `/health` or `/status` endpoint indicating whether the node is fully synced and ready for transaction submission.

## Proof of Concept

This vulnerability can be demonstrated through the following scenario:

**Setup:**
1. Run a validator node and let it sync to version N
2. Stop the node
3. While the node is offline, submit a transaction T1 with sequence S to the network (gets committed at version N+100)
4. Restart the node to begin bootstrapping from version N

**Exploitation:**
1. Query the bootstrapping node's API at `/accounts/{address}` - it shows sequence S as next expected
2. Submit a NEW transaction T2 with the same sequence S to the bootstrapping node via `/transactions`
3. Receive HTTP 202 Accepted response
4. Monitor mempool - transaction T2 is accepted
5. Wait for node to sync past version N+100
6. When the node processes the historical block containing T1(sequence S), mempool receives commit notification
7. Mempool updates account sequence to S+1 and removes ALL transactions with sequence < S+1
8. Transaction T2 is silently removed from mempool
9. Query `/transactions/by_hash/{T2_hash}` - returns 404 Not Found
10. User's transaction T2 is permanently lost

**Expected Behavior:**
- Either reject T2 during bootstrap with appropriate error message
- Or preserve T2 and don't remove it when processing historical T1

**Actual Behavior:**
- T2 accepted with HTTP 202
- T2 silently removed when historical T1 processed
- No notification of removal
- Transaction permanently lost

This can be validated by examining the code paths documented above and observing the mempool state before and after historical commit processing during bootstrap.

## Notes

This vulnerability represents a fundamental design issue where the REST API, mempool, and state synchronization components operate independently without coordination around the bootstrap phase. The silent failure mode is particularly concerning as users have no automated way to detect transaction loss and must manually monitor their account state to discover the issue.

The vulnerability is exacerbated by the fact that bootstrapping nodes appear fully functional from the API perspective - they respond to queries, validate transactions, and return success responses, providing no indication to users that their transactions are at risk.

### Citations

**File:** api/src/transactions.rs (L490-492)
```rust
        if !self.context.node_config.api.transaction_submission_enabled {
            return Err(api_disabled("Submit transaction"));
        }
```

**File:** api/src/transactions.rs (L495-496)
```rust
        let ledger_info = self.context.get_latest_ledger_info()?;
        let signed_transaction = self.get_signed_transaction(&ledger_info, data)?;
```

**File:** config/src/config/api_config.rs (L104-106)
```rust
fn default_enabled() -> bool {
    true
}
```

**File:** config/src/config/api_config.rs (L127-127)
```rust
            transaction_submission_enabled: default_enabled(),
```

**File:** api/src/context.rs (L271-278)
```rust
    pub fn get_latest_ledger_info<E: ServiceUnavailableError>(&self) -> Result<LedgerInfo, E> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            if indexer_reader.is_internal_indexer_enabled() {
                return self.get_latest_internal_indexer_ledger_info();
            }
        }
        self.get_latest_storage_ledger_info()
    }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L265-273)
```rust
        let commit_post_processor_handle = spawn_commit_post_processor(
            commit_post_processor_listener,
            event_subscription_service,
            mempool_notification_handler,
            storage_service_notification_handler,
            pending_data_chunks.clone(),
            runtime.clone(),
            storage.reader.clone(),
        );
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L805-817)
```rust
            // Handle the committed transaction notification (e.g., notify mempool)
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
```

**File:** mempool/src/shared_mempool/coordinator.rs (L229-257)
```rust
fn handle_commit_notification<TransactionValidator>(
    mempool: &Arc<Mutex<CoreMempool>>,
    mempool_validator: &Arc<RwLock<TransactionValidator>>,
    use_case_history: &Arc<Mutex<UseCaseHistory>>,
    msg: MempoolCommitNotification,
    num_committed_txns_received_since_peers_updated: &Arc<AtomicU64>,
) where
    TransactionValidator: TransactionValidation,
{
    debug!(
        block_timestamp_usecs = msg.block_timestamp_usecs,
        num_committed_txns = msg.transactions.len(),
        LogSchema::event_log(LogEntry::StateSyncCommit, LogEvent::Received),
    );

    // Process and time committed user transactions.
    let start_time = Instant::now();
    counters::mempool_service_transactions(
        counters::COMMIT_STATE_SYNC_LABEL,
        msg.transactions.len(),
    );
    num_committed_txns_received_since_peers_updated
        .fetch_add(msg.transactions.len() as u64, Ordering::Relaxed);
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
```

**File:** mempool/src/shared_mempool/tasks.rs (L728-738)
```rust
    for transaction in transactions {
        pool.log_commit_transaction(
            &transaction.sender,
            transaction.replay_protector,
            tracking_usecases
                .get(&transaction.use_case)
                .map(|name| (transaction.use_case.clone(), name)),
            block_timestamp,
        );
        pool.commit_transaction(&transaction.sender, transaction.replay_protector);
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L635-665)
```rust
    fn clean_committed_transactions_below_account_seq_num(
        &mut self,
        address: &AccountAddress,
        account_sequence_number: u64,
    ) {
        // Remove all previous seq number transactions for this account.
        // This can happen if transactions are sent to multiple nodes and one of the
        // nodes has sent the transaction to consensus but this node still has the
        // transaction sitting in mempool.
        if let Some(txns) = self.transactions.get_mut(address) {
            let mut active = txns.seq_num_split_off(account_sequence_number);
            let txns_for_removal = txns.clone();
            txns.clear();
            txns.append(&mut active);

            let mut rm_txns = match aptos_logger::enabled!(Level::Trace) {
                true => TxnsLog::new(),
                false => TxnsLog::new_with_max(10),
            };
            for transaction in txns_for_removal.values() {
                rm_txns.add(transaction.get_sender(), transaction.get_replay_protector());
                self.index_remove(transaction);
            }
            trace!(
                LogSchema::new(LogEntry::CleanCommittedTxn).txns(rm_txns),
                "txns cleaned with committing tx {}:{}",
                address,
                account_sequence_number
            );
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L677-688)
```rust
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
```

**File:** aptos-node/src/lib.rs (L787-795)
```rust
    ) = services::bootstrap_api_and_indexer(
        &node_config,
        db_rw.clone(),
        chain_id,
        indexer_db_opt,
        update_receiver,
        api_port_tx,
        indexer_grpc_port_tx,
    )?;
```

**File:** aptos-node/src/lib.rs (L801-826)
```rust
    let (mempool_runtime, consensus_to_mempool_sender) =
        services::start_mempool_runtime_and_get_consensus_sender(
            &mut node_config,
            &db_rw,
            mempool_reconfig_subscription,
            mempool_network_interfaces,
            mempool_listener,
            mempool_client_receiver,
            peers_and_metadata,
        );

    // Create the DKG runtime and get the VTxn pool
    let (vtxn_pool, dkg_runtime) =
        consensus::create_dkg_runtime(&mut node_config, dkg_subscriptions, dkg_network_interfaces);

    // Create the JWK consensus runtime
    let jwk_consensus_runtime = consensus::create_jwk_consensus_runtime(
        &mut node_config,
        jwk_consensus_subscriptions,
        jwk_consensus_network_interfaces,
        &vtxn_pool,
    );

    // Wait until state sync has been initialized
    debug!("Waiting until state sync is initialized!");
    state_sync_runtimes.block_until_initialized();
```

**File:** api/src/runtime.rs (L260-266)
```rust
        Server::new_with_acceptor(acceptor)
            .run(route)
            .await
            .map_err(anyhow::Error::msg)
    });

    info!("API server is running at {}", actual_address);
```
