# Audit Report

## Title
REST Discovery Accepts Stale ValidatorSet Data Without Epoch Validation Leading to Network Isolation

## Summary
The `RestStream::poll_next()` function retrieves ValidatorSet data from a REST endpoint without validating the epoch, version, or timestamp metadata. The REST API response includes State metadata containing these fields, but the code immediately discards this information by calling `into_inner()`, allowing nodes to unknowingly use outdated validator information from previous epochs.

## Finding Description

The REST discovery mechanism allows nodes to discover validator peers by polling a trusted REST endpoint. The endpoint returns a `Response<ValidatorSet>` which includes State metadata containing `epoch`, `version`, and `timestamp_usecs` fields. [1](#0-0) [2](#0-1) 

However, the `poll_next()` implementation extracts only the inner ValidatorSet and discards all metadata: [3](#0-2) 

The code calls `into_inner()` on line 54, which extracts only the ValidatorSet and discards the State containing epoch information. This data is then passed directly to `extract_validator_set_updates()` without any freshness validation.

**Attack Scenario:**

1. A fullnode or validator is configured to use REST discovery pointing to a REST endpoint
2. The REST endpoint (malicious, compromised, or severely lagging) serves ValidatorSet data from epoch N-10
3. The node accepts this stale data without checking the epoch field in the Response State
4. The node attempts to connect to validators from the old epoch who may no longer be active
5. The node fails to connect to current active validators participating in consensus
6. The node becomes isolated from the current validator set and cannot participate in consensus or receive current blocks

**Why This Breaks Security Invariants:**

The ValidatorSet structure itself does not contain epoch information: [4](#0-3) 

Epoch information is tracked separately through EpochState: [5](#0-4) 

While nodes have access to their current epoch through the storage interface and EpochState implements epoch validation for consensus messages: [6](#0-5) 

The vulnerability is that REST discovery never validates that the epoch from the REST response matches the node's current epoch before using the ValidatorSet data for peer discovery. The RestStream is created without access to storage or epoch information: [7](#0-6) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos bug bounty criteria)

This vulnerability can cause:

1. **Validator Node Isolation**: Validators using REST discovery could connect to outdated validator sets and become isolated from current consensus, leading to reduced network voting power and potential liveness issues if enough validators are affected.

2. **Fullnode Network Partitioning**: Fullnodes would connect to wrong Validator Fullnodes (VFNs), receiving outdated chain data or no data at all.

3. **Consensus Participation Failure**: Isolated validators cannot receive proposals, send votes, or participate in consensus rounds. While consensus messages would eventually be rejected due to epoch mismatch, the node cannot establish connections with the correct current-epoch validators.

4. **No Automatic Recovery**: Unlike on-chain discovery (ValidatorSetStream) which is triggered by reconfig events, REST discovery polls independently and has no mechanism to detect or recover from stale data until the REST endpoint itself updates.

The impact aligns with **High Severity** criteria:
- "Validator node slowdowns" - nodes attempting to connect to wrong validators experience degraded performance and cannot participate in consensus
- "Significant protocol violations" - nodes violate the implicit requirement to connect to current validator sets

While this doesn't directly cause consensus safety violations (epoch validation occurs at the message level), it causes severe availability/liveness issues for affected nodes.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is likely to occur because:

1. **Trust Assumption**: REST discovery assumes the configured endpoint always serves current data, with no defense-in-depth validation despite epoch information being available in the response.

2. **Multiple Failure Modes**:
   - Malicious REST endpoint operator deliberately serves old data
   - REST endpoint compromised by attacker
   - REST endpoint infrastructure has caching layer serving stale data
   - REST endpoint node is severely behind the chain due to sync issues
   - Network issues cause REST endpoint to serve outdated cached responses

3. **Configuration Pattern**: The test suite shows REST discovery is intended for production use: [8](#0-7) 

4. **No Alerting**: The node would not immediately detect the issueâ€”it would simply fail to establish connections with current validators without clear indication that the ValidatorSet data is stale.

## Recommendation

The `RestStream::poll_next()` method should validate the epoch from the REST response State before using the ValidatorSet data. The implementation should:

1. Preserve the State information instead of calling `into_inner()`
2. Access the node's current epoch (requires passing DbReader or epoch information to RestStream during construction)
3. Compare the REST response epoch with the node's current epoch
4. Reject ValidatorSet data if the epoch doesn't match or is significantly behind
5. Log warnings when stale data is detected

Example fix approach:
```rust
// In poll_next():
let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(...));
match response {
    Ok(response) => {
        let state = response.state();
        // Validate epoch matches current epoch
        if state.epoch < self.current_epoch {
            return Poll::Ready(Some(Err(DiscoveryError::StaleEpoch)));
        }
        let validator_set = response.into_inner();
        // ... rest of processing
    }
}
```

This requires modifying RestStream to have access to current epoch information, which may require architectural changes to pass storage or epoch state during initialization.

## Proof of Concept

Note: A complete PoC would require setting up a REST endpoint serving stale ValidatorSet data and observing node isolation. The vulnerability is demonstrated through code analysis showing:

1. State metadata including epoch is discarded at line 54 of rest.rs
2. No epoch validation exists in the REST discovery path
3. RestStream lacks access to current epoch information for validation
4. The test demonstrates REST discovery is used in production configurations

A reproduction would involve:
1. Configure a node with REST discovery
2. Point it to a REST endpoint serving ValidatorSet from an old epoch
3. Observe the node attempting to connect to outdated validators
4. Verify the node cannot participate in current epoch consensus

## Notes

This is a defense-in-depth vulnerability where available validation information (epoch in REST response State) is explicitly discarded. While the REST endpoint is externally configured, the protocol should not trust external data without validation, especially when the validation information is already present in the response. The vulnerability affects nodes using REST discovery and requires the REST endpoint to serve stale data, but this can occur through multiple failure modes including compromise, caching issues, or synchronization lag.

### Citations

**File:** crates/aptos-rest-client/src/state.rs (L10-20)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```

**File:** crates/aptos-rest-client/src/response.rs (L6-23)
```rust
#[derive(Debug)]
pub struct Response<T> {
    inner: T,
    state: State,
}

impl<T> Response<T> {
    pub fn new(inner: T, state: State) -> Self {
        Self { inner, state }
    }

    pub fn inner(&self) -> &T {
        &self.inner
    }

    pub fn into_inner(self) -> T {
        self.inner
    }
```

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** types/src/on_chain_config/validator_set.rs (L23-32)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ValidatorSet {
    pub scheme: ConsensusScheme,
    pub active_validators: Vec<ValidatorInfo>,
    pub pending_inactive: Vec<ValidatorInfo>,
    pub pending_active: Vec<ValidatorInfo>,
    pub total_voting_power: u128,
    pub total_joining_power: u128,
}
```

**File:** types/src/epoch_state.rs (L15-22)
```rust
/// EpochState represents a trusted validator set to validate messages from the specific epoch,
/// it could be updated with EpochChangeProof.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** network/builder/src/builder.rs (L379-385)
```rust
                DiscoveryMethod::Rest(rest_discovery) => DiscoveryChangeListener::rest(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    rest_discovery.url.clone(),
                    Duration::from_secs(rest_discovery.interval_secs),
                    self.time_service.clone(),
                ),
```

**File:** testsuite/smoke-test/src/network.rs (L145-170)
```rust
#[tokio::test]
async fn test_rest_discovery() {
    let mut swarm = SwarmBuilder::new_local(1).with_aptos().build().await;

    // Point to an already existing node
    let (version, rest_endpoint) = {
        let validator = swarm.validators().next().unwrap();
        (validator.version(), validator.rest_api_endpoint())
    };
    let mut full_node_config = NodeConfig::get_default_pfn_config();
    let network_config = full_node_config.full_node_networks.first_mut().unwrap();
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: rest_endpoint,
        interval_secs: 1,
    });

    // Start a new node that should connect to the previous node only via REST
    // The startup wait time should check if it connects successfully
    swarm
        .add_full_node(
            &version,
            OverrideNodeConfig::new_with_default_base(full_node_config),
        )
        .await
        .unwrap();
}
```
