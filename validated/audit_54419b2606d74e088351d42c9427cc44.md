# Audit Report

## Title
State Corruption in SecretShareStore Due to Improper Error Handling in add_share_with_metadata()

## Summary
The `SecretShareStore::add_self_share()` function contains a state corruption bug where calling `add_share_with_metadata()` leaves the secret share aggregator in a corrupted state with an incorrect author (`Author::ONE`) when processing multiple blocks for the same round, breaking the secret sharing protocol required for consensus randomness generation.

## Finding Description

The vulnerability exists in the error handling path of `SecretShareItem::add_share_with_metadata()`. [1](#0-0) 

The function uses `std::mem::replace(self, Self::new(Author::ONE))` to temporarily take ownership of the current state. [2](#0-1) 

However, when the state is `PendingDecision`, the function calls `bail!()` returning an error. [3](#0-2) 

Similarly, when the state is `Decided`, it returns early with `Ok(())`. [4](#0-3) 

In both cases, the final restoration `std::mem::replace(self, new_item)` never executes, leaving the `SecretShareItem` corrupted with `Author::ONE` instead of the correct validator's author. [5](#0-4) 

The corrupted state persists in the `secret_share_map` which is keyed by round only. [6](#0-5) 

**Triggering Conditions:**

This occurs when `add_self_share()` is called multiple times for the same round, which happens when multiple different blocks are proposed for the same round. The `SecretShareStore` uses a `HashMap<Round, SecretShareItem>` keyed by round only, so two different blocks at the same round map to the same item. [7](#0-6) 

Byzantine equivocation (multiple blocks per round) is explicitly acknowledged by the block tree, which logs warnings when this occurs but continues processing. [8](#0-7) 

Each block triggers `process_incoming_block()` which calls `add_self_share()`. [9](#0-8) 

**Breaking Consensus Invariants:**

Once corrupted, the `SecretShareItem` has `self_author = Author::ONE` instead of the correct validator. [10](#0-9) 

When `get_self_share()` is called, it searches for a share from `Author::ONE` which doesn't exist, preventing successful share aggregation. [11](#0-10) 

**Comparison with Correct Implementation:**

The parallel `RandStore` implementation handles this scenario correctly by returning the item unchanged for `PendingDecision` and `Decided` states, ensuring the final `std::mem::replace()` always executes. [12](#0-11) 

## Impact Explanation

**Severity: MEDIUM**

This vulnerability causes state inconsistencies requiring intervention, which qualifies as Medium severity per the Aptos bug bounty program.

**Specific Impacts:**

1. **Liveness Degradation**: Affected validator nodes cannot complete secret share aggregation for the corrupted round, blocking randomness generation needed for consensus
2. **Protocol Disruption**: Secret sharing protocol fails silently (in the `Decided` case) or with errors (in the `PendingDecision` case) 
3. **Requires Intervention**: The corrupted state persists in memory until the node restarts or the epoch changes
4. **Validator Subset Impact**: Only validators that process multiple blocks for the same round are affected, not the entire network

This does not reach Critical severity because:
- It doesn't cause permanent fund loss
- It doesn't break consensus safety (only liveness)
- It doesn't require a hard fork to recover
- Impact is limited to specific nodes under specific conditions

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability can be triggered by Byzantine equivocation where a malicious proposer creates multiple blocks at the same round. The block tree explicitly acknowledges this scenario can occur and logs warnings, but the `SecretShareManager` processes blocks before/concurrently with validation, and the `SecretShareStore` lacks proper defensive handling.

The Aptos codebase demonstrates awareness of this scenario through explicit warnings about multiple blocks per round, indicating the developers anticipated this possibility but the `SecretShareStore` implementation does not handle it correctly.

## Recommendation

Fix the error handling in `add_share_with_metadata()` to match the correct pattern used in `RandStore::add_metadata()`. Instead of using `bail!()` or early return, return the original item unchanged to ensure the final `std::mem::replace()` always executes:

```rust
fn add_share_with_metadata(
    &mut self,
    share: SecretShare,
    share_weights: &HashMap<Author, u64>,
) -> anyhow::Result<()> {
    let item = std::mem::replace(self, Self::new(Author::ONE));
    let share_weight = *share_weights
        .get(share.author())
        .expect("Author must exist in weights");
    let new_item = match item {
        SecretShareItem::PendingMetadata(mut share_aggregator) => {
            let metadata = share.metadata.clone();
            share_aggregator.retain(share.metadata(), share_weights);
            share_aggregator.add_share(share, share_weight);
            SecretShareItem::PendingDecision {
                metadata,
                share_aggregator,
            }
        },
        // Return item unchanged instead of early return
        item @ (SecretShareItem::PendingDecision { .. } | SecretShareItem::Decided { .. }) => item,
    };
    let _ = std::mem::replace(self, new_item);
    Ok(())
}
```

## Proof of Concept

A PoC would require setting up a test scenario where:
1. A Byzantine validator proposes two different blocks at the same round
2. Both blocks are processed by the `SecretShareManager`
3. The first call to `add_self_share()` succeeds and transitions to `PendingDecision`
4. The second call to `add_self_share()` triggers the bug, leaving corrupted state
5. Subsequent `get_self_share()` calls fail to find the share due to wrong author

The test would verify that the `SecretShareItem` has `self_author = Author::ONE` after the second call, and that share aggregation fails for that round.

## Notes

This is a valid MEDIUM severity vulnerability in the Aptos consensus layer that can be triggered by Byzantine equivocation within the < 1/3 Byzantine assumption. The block tree code explicitly acknowledges that multiple blocks per round can occur, but the `SecretShareStore` lacks the defensive handling present in the parallel `RandStore` implementation. The bug causes state corruption requiring node restart or epoch change to recover, affecting liveness but not safety.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L17-21)
```rust
pub struct SecretShareAggregator {
    self_author: Author,
    shares: HashMap<Author, SecretShare>,
    total_weight: u64,
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L83-85)
```rust
    fn get_self_share(&self) -> Option<SecretShare> {
        self.shares.get(&self.self_author).cloned()
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L211-211)
```rust
    secret_share_map: HashMap<Round, SecretShareItem>,
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L250-256)
```rust
        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
```

**File:** consensus/src/block_storage/block_tree.rs (L326-332)
```rust
            // Note: the assumption is that we have/enforce unequivocal proposer election.
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-148)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L180-193)
```rust
    fn add_metadata(&mut self, rand_config: &RandConfig, rand_metadata: FullRandMetadata) {
        let item = std::mem::replace(self, Self::new(Author::ONE, PathType::Slow));
        let new_item = match item {
            RandItem::PendingMetadata(mut share_aggregator) => {
                share_aggregator.retain(rand_config, &rand_metadata);
                Self::PendingDecision {
                    metadata: rand_metadata,
                    share_aggregator,
                }
            },
            item @ (RandItem::PendingDecision { .. } | RandItem::Decided { .. }) => item,
        };
        let _ = std::mem::replace(self, new_item);
    }
```
