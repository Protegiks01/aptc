# Audit Report

## Title
Control Flow Graph Construction DoS via Unbounded Resource Consumption During Bytecode Verification

## Summary
The Move bytecode verifier constructs Control Flow Graphs (CFGs) for functions without enforcing resource limits beforehand, enabling attackers to cause validator node slowdowns through module publishing transactions containing pathologically large functions.

## Finding Description

The vulnerability exists in the bytecode verification pipeline where CFG construction occurs before the `max_basic_blocks` limit is enforced. When a Move module is published, the verification flow proceeds as follows:

**1. Deserialization Limit**
Module deserialization enforces `BYTECODE_COUNT_MAX = 65535`, allowing functions with up to 65,535 instructions. [1](#0-0) 

**2. Complexity Checking (Does Not Construct CFG)**
Binary format complexity checking meters signatures and instantiations but does not construct the control flow graph. [2](#0-1) 

**3. Verification Pipeline Begins**
Module verification calls `verify_module_with_config` which runs verification passes sequentially. [3](#0-2) 

**4. CodeUnitVerifier Invokes Function Verification**
The `CodeUnitVerifier::verify_module` pass calls `verify_function` for each function definition. [4](#0-3) 

**5. Control Flow Verification Creates FunctionView**
The `control_flow::verify_function` creates a `FunctionView` which triggers CFG construction. [5](#0-4) 

**6. FunctionView Constructor Immediately Builds CFG**
The `FunctionView::function` constructor immediately constructs the complete CFG via `VMControlFlowGraph::new(&code.code)` without any size checking. [6](#0-5) 

**7. CFG Construction Algorithm Complexity**
The CFG construction performs O(n) iteration to identify block boundaries, followed by O(V+E) depth-first search for loop analysis, allocating multiple data structures including blocks map, exploration map, DFS stack, and post-order traversal. [7](#0-6) 

**8. Limit Check Occurs AFTER CFG Construction**
Only AFTER the CFG is fully constructed does the verifier check `max_basic_blocks`, which is set to 1024 in production. [8](#0-7) [9](#0-8) 

**9. Metering Not Enforced**
The meter parameter passed to `verify_function` is explicitly marked as unused with a TODO comment, indicating no resource metering occurs during CFG construction. [10](#0-9) 

**10. Permission Model Allows Any Account**
Any regular account can publish modules because master signers (non-permissioned signers) automatically pass all permission checks without requiring explicit grants. [11](#0-10) [12](#0-11) 

An attacker can craft a function with 65,535 instructions structured to maximize basic blocks (e.g., alternating branch instructions), potentially creating tens of thousands of basic blocks. While the production config limits `max_basic_blocks` to 1024, this check occurs only after the expensive CFG construction completes and all memory allocations are made.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns - Significant performance degradation affecting consensus."

Each malicious module submission forces every validator to:
- Allocate memory for CFG data structures proportional to the number of basic blocks (potentially tens of thousands)
- Execute O(V+E) depth-first search algorithm where V (vertices/blocks) can approach ~32,000 with clever instruction patterns
- Perform complete loop analysis with exploration maps and post-order traversal
- Only then reject the module for exceeding `max_basic_blocks`

The attack is economically asymmetric: attackers pay gas proportional to module byte size (~65KB), while validators incur computational costs proportional to basic block count (potentially orders of magnitude higher). Gas charging occurs based on bytecode size, not verification complexity. [13](#0-12) 

An attacker can repeatedly submit such modules, causing sustained CPU and memory pressure on all validators simultaneously during block execution. This degrades network performance and can affect consensus timing if sufficient transaction volume is maintained.

## Likelihood Explanation

**High likelihood** of exploitation:

1. **No Special Permissions Required**: Master signers (regular accounts) bypass all permission checks by default, so any funded account can publish modules without prior authorization.

2. **Trivial Attack Construction**: Creating a pathological function requires only sequential branch instructions (e.g., `BrTrue`, `BrFalse` targeting different offsets), which is trivially achievable with basic Move compiler knowledge.

3. **Economic Viability**: Gas costs scale with bytecode size (linear), while verification costs scale with basic block count (potentially quadratic with V+E edges). The attacker's cost-to-impact ratio is highly favorable.

4. **Sustained Attack Capability**: No rate limiting exists beyond normal transaction throughput. An attacker can continuously submit such transactions in every block.

5. **Guaranteed Processing**: Once included in a block proposal, all validators must perform the expensive verification during block execution, regardless of whether the transaction ultimately succeeds or fails.

## Recommendation

Implement pre-construction limit checking by enforcing `max_basic_blocks` before CFG construction:

```rust
// In control_flow::verify_function, before creating FunctionView:
if let Some(max_blocks) = verifier_config.max_basic_blocks {
    // Perform lightweight pre-check by counting potential block boundaries
    let mut potential_blocks = 1; // Entry block
    for (pc, instr) in code.code.iter().enumerate() {
        if instr.is_branch() || (pc > 0 && is_branch_target(pc, &code.code)) {
            potential_blocks += 1;
            if potential_blocks > max_blocks {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS));
            }
        }
    }
}
```

Additionally, enable the metering system by removing the TODO and implementing actual resource tracking during CFG construction to enforce per-function verification budgets.

## Proof of Concept

A complete PoC would require constructing a Move module with a function containing maximum branch instructions within the 65,535 bytecode limit, then submitting it via transaction to demonstrate the verification delay. The module would look like:

```move
module 0xCAFE::dos_attack {
    public entry fun pathological_function() {
        // Repeat pattern to create ~30,000+ basic blocks:
        // label_0: if (condition) goto label_2 else label_1
        // label_1: if (condition) goto label_3 else label_2  
        // ... repeated 32,000+ times within 65,535 instruction limit
    }
}
```

Timing measurements would show CFG construction consuming significant CPU time proportional to basic block count before the `max_basic_blocks` check rejects it, demonstrating the resource exhaustion vulnerability.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L259-395)
```rust
    fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
        use Bytecode::*;

        self.meter_signature(code.locals)?;

        for instr in &code.code {
            match instr {
                CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                    self.meter_function_instantiation(*idx)?;
                },
                PackGeneric(idx) | UnpackGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
                CallClosure(idx)
                | VecPack(idx, _)
                | VecLen(idx)
                | VecImmBorrow(idx)
                | VecMutBorrow(idx)
                | VecPushBack(idx)
                | VecPopBack(idx)
                | VecUnpack(idx, _)
                | VecSwap(idx) => {
                    self.meter_signature(*idx)?;
                },

                // List out the other options explicitly so there's a compile error if a new
                // bytecode gets added.
                Pop
                | Ret
                | Branch(_)
                | BrTrue(_)
                | BrFalse(_)
                | LdU8(_)
                | LdU16(_)
                | LdU32(_)
                | LdU64(_)
                | LdU128(_)
                | LdU256(_)
                | LdI8(_)
                | LdI16(_)
                | LdI32(_)
                | LdI64(_)
                | LdI128(_)
                | LdI256(_)
                | LdConst(_)
                | CastU8
                | CastU16
                | CastU32
                | CastU64
                | CastU128
                | CastU256
                | CastI8
                | CastI16
                | CastI32
                | CastI64
                | CastI128
                | CastI256
                | LdTrue
                | LdFalse
                | Call(_)
                | Pack(_)
                | Unpack(_)
                | PackVariant(_)
                | UnpackVariant(_)
                | TestVariant(_)
                | PackClosure(..)
                | ReadRef
                | WriteRef
                | FreezeRef
                | Add
                | Sub
                | Mul
                | Mod
                | Div
                | Negate
                | BitOr
                | BitAnd
                | Xor
                | Shl
                | Shr
                | Or
                | And
                | Not
                | Eq
                | Neq
                | Lt
                | Gt
                | Le
                | Ge
                | CopyLoc(_)
                | MoveLoc(_)
                | StLoc(_)
                | MutBorrowLoc(_)
                | ImmBorrowLoc(_)
                | MutBorrowField(_)
                | ImmBorrowField(_)
                | MutBorrowVariantField(_)
                | ImmBorrowVariantField(_)
                | MutBorrowGlobal(_)
                | ImmBorrowGlobal(_)
                | Exists(_)
                | MoveTo(_)
                | MoveFrom(_)
                | Abort
                | AbortMsg
                | Nop => (),
            }
        }
        Ok(())
    }

    fn meter_function_defs(&self) -> PartialVMResult<()> {
        let func_defs = self.resolver.function_defs().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get func defs -- not a module.".to_string())
        })?;

        for func_def in func_defs {
            if let Some(code) = &func_def.code {
                self.meter_code(code)?;
            }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-175)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}

/// Helper for a "canonical" verification of a script.
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L117-177)
```rust
    fn verify_function(
        verifier_config: &VerifierConfig,
        index: FunctionDefinitionIndex,
        function_definition: &FunctionDefinition,
        module: &CompiledModule,
        name_def_map: &HashMap<IdentifierIndex, FunctionDefinitionIndex>,
        meter: &mut impl Meter,
    ) -> PartialVMResult<usize> {
        meter.enter_scope(
            module
                .identifier_at(module.function_handle_at(function_definition.function).name)
                .as_str(),
            Scope::Function,
        );
        // nothing to verify for native function
        let code = match &function_definition.code {
            Some(code) => code,
            None => return Ok(0),
        };

        // create `FunctionView` and `BinaryIndexedView`
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;

        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }

        let num_back_edges = function_view.cfg().num_back_edges();
        if let Some(limit) = verifier_config.max_back_edges_per_function {
            if num_back_edges > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES).at_code_offset(index, 0)
                );
            }
        }

        let resolver = BinaryIndexedView::Module(module);
        // verify
        let code_unit_verifier = CodeUnitVerifier {
            resolver,
            function_view,
            name_def_map,
        };
        code_unit_verifier.verify_common(verifier_config, meter)?;
        AcquiresVerifier::verify(module, index, function_definition, meter)?;

        meter.transfer(Scope::Function, Scope::Module, 1.0)?;

        Ok(num_back_edges)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L35-54)
```rust
pub fn verify_function<'a>(
    verifier_config: &'a VerifierConfig,
    module: &'a CompiledModule,
    index: FunctionDefinitionIndex,
    function_definition: &'a FunctionDefinition,
    code: &'a CodeUnit,
    _meter: &mut impl Meter, // TODO: metering
) -> PartialVMResult<FunctionView<'a>> {
    let function_handle = module.function_handle_at(function_definition.function);

    if module.version() <= 5 {
        control_flow_v5::verify(verifier_config, Some(index), code)?;
        Ok(FunctionView::function(module, index, code, function_handle))
    } else {
        verify_fallthrough(Some(index), code)?;
        let function_view = FunctionView::function(module, index, code, function_handle);
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
    }
}
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L436-451)
```rust
    pub fn function(
        module: &'a CompiledModule,
        index: FunctionDefinitionIndex,
        code: &'a CodeUnit,
        function_handle: &'a FunctionHandle,
    ) -> Self {
        Self {
            index: Some(index),
            code,
            parameters: module.signature_at(function_handle.parameters),
            return_: module.signature_at(function_handle.return_),
            locals: module.signature_at(code.locals),
            type_parameters: &function_handle.type_parameters,
            cfg: VMControlFlowGraph::new(&code.code),
        }
    }
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L84-225)
```rust
    pub fn new(code: &[Bytecode]) -> Self {
        let code_len = code.len() as CodeOffset;
        // First go through and collect block ids, i.e., offsets that begin basic blocks.
        // Need to do this first in order to handle backwards edges.
        let mut block_ids = Set::new();
        block_ids.insert(ENTRY_BLOCK_ID);
        for pc in 0..code.len() {
            VMControlFlowGraph::record_block_ids(pc as CodeOffset, code, &mut block_ids);
        }

        // Create basic blocks
        let mut blocks = Map::new();
        let mut entry = 0;
        let mut exit_to_entry = Map::new();
        for pc in 0..code.len() {
            let co_pc = pc as CodeOffset;

            // Create a basic block
            if Self::is_end_of_block(co_pc, code, &block_ids) {
                let exit = co_pc;
                exit_to_entry.insert(exit, entry);
                let successors = Bytecode::get_successors(co_pc, code);
                let bb = BasicBlock { exit, successors };
                blocks.insert(entry, bb);
                entry = co_pc + 1;
            }
        }
        let blocks = blocks;
        assert_eq!(entry, code_len);

        // # Loop analysis
        //
        // This section identifies loops in the control-flow graph, picks a back edge and loop head
        // (the basic block the back edge returns to), and decides the order that blocks are
        // traversed during abstract interpretation (reverse post-order).
        //
        // The implementation is based on the algorithm for finding widening points in Section 4.1,
        // "Depth-first numbering" of Bourdoncle [1993], "Efficient chaotic iteration strategies
        // with widenings."
        //
        // NB. The comments below refer to a block's sub-graph -- the reflexive transitive closure
        // of its successor edges, modulo cycles.

        #[derive(Copy, Clone)]
        enum Exploration {
            InProgress,
            Done,
        }

        let mut exploration: Map<BlockId, Exploration> = Map::new();
        let mut stack = vec![ENTRY_BLOCK_ID];

        // For every loop in the CFG that is reachable from the entry block, there is an entry in
        // `loop_heads` mapping to all the back edges pointing to it, and vice versa.
        //
        // Entry in `loop_heads` implies loop in the CFG is justified by the comments in the loop
        // below.  Loop in the CFG implies entry in `loop_heads` is justified by considering the
        // point at which the first node in that loop, `F` is added to the `exploration` map:
        //
        // - By definition `F` is part of a loop, meaning there is a block `L` such that:
        //
        //     F - ... -> L -> F
        //
        // - `F` will not transition to `Done` until all the nodes reachable from it (including `L`)
        //   have been visited.
        // - Because `F` is the first node seen in the loop, all the other nodes in the loop
        //   (including `L`) will be visited while `F` is `InProgress`.
        // - Therefore, we will process the `L -> F` edge while `F` is `InProgress`.
        // - Therefore, we will record a back edge to it.
        let mut loop_heads: Map<BlockId, Set<BlockId>> = Map::new();

        // Blocks appear in `post_order` after all the blocks in their (non-reflexive) sub-graph.
        let mut post_order = Vec::with_capacity(blocks.len());

        while let Some(block) = stack.pop() {
            match exploration.entry(block) {
                Entry::Vacant(entry) => {
                    // Record the fact that exploration of this block and its sub-graph has started.
                    entry.insert(Exploration::InProgress);

                    // Push the block back on the stack to finish processing it, and mark it as done
                    // once its sub-graph has been traversed.
                    stack.push(block);

                    for succ in &blocks[&block].successors {
                        match exploration.get(succ) {
                            // This successor has never been visited before, add it to the stack to
                            // be explored before `block` gets marked `Done`.
                            None => stack.push(*succ),

                            // This block's sub-graph was being explored, meaning it is a (reflexive
                            // transitive) predecessor of `block` as well as being a successor,
                            // implying a loop has been detected -- greedily choose the successor
                            // block as the loop head.
                            Some(Exploration::InProgress) => {
                                loop_heads.entry(*succ).or_default().insert(block);
                            },

                            // Cross-edge detected, this block and its entire sub-graph (modulo
                            // cycles) has already been explored via a different path, and is
                            // already present in `post_order`.
                            Some(Exploration::Done) => { /* skip */ },
                        };
                    }
                },

                Entry::Occupied(mut entry) => match entry.get() {
                    // Already traversed the sub-graph reachable from this block, so skip it.
                    Exploration::Done => continue,

                    // Finish up the traversal by adding this block to the post-order traversal
                    // after its sub-graph (modulo cycles).
                    Exploration::InProgress => {
                        post_order.push(block);
                        entry.insert(Exploration::Done);
                    },
                },
            }
        }

        let traversal_order = {
            // This reverse post order is akin to a topological sort (ignoring cycles) and is
            // different from a pre-order in the presence of diamond patterns in the graph.
            post_order.reverse();
            post_order
        };

        // build a mapping from a block id to the next block id in the traversal order
        let traversal_successors = traversal_order
            .windows(2)
            .map(|window| {
                debug_assert!(window.len() == 2);
                (window[0], window[1])
            })
            .collect();

        VMControlFlowGraph {
            blocks,
            traversal_successors,
            loop_heads,
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```

**File:** aptos-move/framework/aptos-framework/sources/permissioned_signer.move (L558-573)
```text
    public(package) fun check_permission_capacity_above<PermKey: copy + drop + store>(
        s: &signer, threshold: u256, perm: PermKey
    ): bool acquires PermissionStorage {
        if (!is_permissioned_signer(s)) {
            // master signer has all permissions
            return true
        };
        map_or(
            s,
            perm,
            |stored_permission| {
                is_above(stored_permission, threshold)
            },
            false,
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L117-122)
```text
    public(friend) fun check_code_publishing_permission(s: &signer) {
        assert!(
            permissioned_signer::check_permission_exists(s, CodePublishingPermission {}),
            error::permission_denied(ENO_CODE_PERMISSION),
        );
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::unzip_metadata_str;
use anyhow::bail;
use aptos_gas_schedule::gas_params::natives::aptos_framework::*;
use aptos_native_interface::{
    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeError,
    SafeNativeResult,
};
use aptos_types::{
    move_any::Any, on_chain_config::OnChainConfig, transaction::ModuleBundle, vm_status::StatusCode,
};
use better_any::{Tid, TidAble};
use move_binary_format::errors::{PartialVMError, PartialVMResult};
use move_core_types::{
    account_address::AccountAddress,
    gas_algebra::NumBytes,
    ident_str,
    identifier::IdentStr,
    move_resource::{MoveResource, MoveStructType},
};
use move_vm_runtime::{
    native_extensions::{NativeRuntimeRefCheckModelsCompleted, SessionListener},
    native_functions::NativeFunction,
};
use move_vm_types::{
    loaded_data::runtime_types::Type,
    values::{Struct, Value},
};
use serde::{Deserialize, Serialize};
use smallvec::{smallvec, SmallVec};
use std::{
    collections::{btree_map::Entry, BTreeMap, BTreeSet, VecDeque},
    fmt,
    str::FromStr,
};

/// The package registry at the given address.
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct PackageRegistry {
    /// Packages installed at this address.
    pub packages: Vec<PackageMetadata>,
}

impl OnChainConfig for PackageRegistry {
    const MODULE_IDENTIFIER: &'static str = "code";
    const TYPE_IDENTIFIER: &'static str = "PackageRegistry";
}

```
