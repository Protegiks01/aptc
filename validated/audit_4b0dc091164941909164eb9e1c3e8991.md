# Audit Report

## Title
Compilation Metadata Bypass Allows Unstable Bytecode on Mainnet

## Summary
The `reject_unstable_bytecode()` function only validates bytecode stability when compilation metadata is present. An attacker can strip the `COMPILATION_METADATA_KEY` from compiled modules to bypass the mainnet stability check, allowing unstable/experimental bytecode to be deployed on production networks.

## Finding Description
The Aptos VM implements a security control to prevent unstable (experimental) bytecode from being published on mainnet. This is enforced through the `reject_unstable_bytecode()` function which checks the `unstable` flag in compilation metadata. [1](#0-0) 

The vulnerability exists because this function uses an `if let Some(metadata)` pattern at line 1745 that only performs the check when metadata is present. If `get_compilation_metadata()` returns `None`, the check is completely skipped and the function returns `Ok(())`. [2](#0-1) 

The `get_compilation_metadata()` function returns `None` when no `COMPILATION_METADATA_KEY` is found in the module's metadata section. Critically, there is **no requirement** that this metadata must be present. The metadata format checker only validates that IF metadata exists, it has known keys, but doesn't enforce presence: [3](#0-2) 

During normal compilation, the metadata is added automatically: [4](#0-3) 

However, since Move bytecode is serialized binary data, an attacker can deserialize compiled modules, manipulate the metadata vector, and re-serialize for submission.

**Attack Path:**

1. Attacker compiles a module using an unstable compiler version (CompilerVersion::V2_1) or unstable language version (LanguageVersion::V2_4 or V2_5): [5](#0-4) [6](#0-5) 

2. The compiled module contains `CompilationMetadata` with `unstable: true`: [7](#0-6) 

3. Attacker deserializes the `CompiledModule`, filters out entries with key `COMPILATION_METADATA_KEY` from the `metadata` vector, then re-serializes

4. Attacker publishes the modified module to mainnet via `code_publish_package_txn`

5. During validation in `validate_publish_request()`, the `reject_unstable_bytecode()` function is called: [8](#0-7) 

6. Since `get_compilation_metadata(module)` returns `None`, the if-let doesn't match and the unstable check is completely bypassed

7. The module passes all subsequent validation (bytecode verification, metadata format checks) and is accepted on mainnet, violating the security invariant

The bytecode verifier does not check for compilation metadata presence: [9](#0-8) 

## Impact Explanation
This is a **High Severity** vulnerability under the Aptos bug bounty program as it represents a "Significant protocol violation."

The unstable flag exists specifically to prevent unvetted, experimental code from running on production networks. Unstable compiler versions and language versions are marked as such because they may contain:
- Experimental features that haven't undergone full security review
- Known bugs that are being fixed before stabilization  
- Semantic differences that could cause consensus splits if validators run different compiler versions
- Unaudited optimizations or code generation patterns [10](#0-9) 

By bypassing this check, an attacker can:
- Deploy bytecode compiled with experimental features onto mainnet
- Potentially exploit bugs that only exist in unstable versions
- Undermine the security model that ensures production networks only run stable, vetted code
- Create risk of consensus divergence if unstable features have semantic differences

While the bytecode itself still passes all safety verification checks (type safety, reference safety, etc.), the policy violation allows untested experimental code on production systems, creating an attack surface that the unstable flag was designed to prevent.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Complexity**: The attack requires only basic bytecode manipulation - deserialize, filter metadata vector, re-serialize using standard Rust BCS libraries

2. **No Special Privileges**: Any user can publish modules on mainnet with proper gas fees and account setup

3. **Clear Motivation**: Attackers may want to exploit experimental features or bugs that only exist in unstable compiler/language versions

4. **No Detection**: The bypass is completely silent - validators would execute the bytecode without any indication it was compiled with an unstable version

5. **Existing Tooling**: Standard Rust serialization libraries (`bcs`, `serde`) can manipulate `CompiledModule` structures

The existing test suite validates that unstable bytecode is rejected when metadata is present, but no test validates the case where metadata is completely absent: [11](#0-10) 

## Recommendation
Enforce the presence of `COMPILATION_METADATA_KEY` for all modules published on mainnet. Modify `reject_unstable_bytecode()` to:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message("compilation metadata required on mainnet".to_string())
                    .finish(Location::Undefined)
            })?;
            
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message("code marked unstable is not published on mainnet".to_string())
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

This ensures that all modules on mainnet must have compilation metadata, preventing the bypass while maintaining backward compatibility for existing modules.

## Proof of Concept
```rust
use move_binary_format::CompiledModule;
use move_model::metadata::COMPILATION_METADATA_KEY;

fn strip_compilation_metadata(module_bytes: &[u8]) -> Vec<u8> {
    // Deserialize the compiled module
    let mut module = CompiledModule::deserialize(module_bytes)
        .expect("Failed to deserialize module");
    
    // Filter out COMPILATION_METADATA_KEY from metadata vector
    module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    // Re-serialize the modified module
    let mut stripped_bytes = vec![];
    module.serialize(&mut stripped_bytes)
        .expect("Failed to serialize module");
    
    stripped_bytes
}

// This stripped bytecode will bypass reject_unstable_bytecode() on mainnet
// even if it was originally compiled with unstable compiler/language versions
```

## Notes
This vulnerability represents a clear security control bypass rather than a direct consensus or fund theft issue. However, it violates a deliberate protective policy designed to keep experimental, untested code off production networks. The unstable flag system exists precisely to prevent deployment of code that may contain unknown bugs or consensus-breaking behavior. Bypassing this control undermines a critical layer of defense in the Aptos security model.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1679-1689)
```rust
    /// Validate a publish request.
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L310-317)
```rust
/// Extract compilation metadata from a compiled module or script.
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L165-174)
```rust
        let compilation_metadata = CompilationMetadata::new(compiler_version, language_version);
        let metadata = Metadata {
            key: COMPILATION_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&compilation_metadata)
                .expect("Serialization of CompilationMetadata should succeed"),
        };
        let module = move_binary_format::CompiledModule {
            version: file_format_common::VERSION_MAX,
            self_module_handle_idx: FF::ModuleHandleIndex(0),
            metadata: vec![metadata],
```

**File:** third_party/move/move-model/src/metadata.rs (L19-24)
```rust
/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();

pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L64-71)
```rust
impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L151-157)
```rust
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L288-294)
```rust
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L318-331)
```rust
#[test]
fn test_compilation_metadata() {
    // publish unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // publish stable compiler code to mainnet
    assert_success!(test_compilation_metadata_internal(true, false,));
    // publish unstable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, true,));
    // publish stable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, false,));
}
```
