# Audit Report

## Title
Race Condition in sync_info() Causes Invalid Certificate Round Ordering Leading to Consensus Synchronization Failures

## Summary
The `BlockStore::sync_info()` method reads three certificates through separate, non-atomic read lock acquisitions, allowing concurrent updates to create an inconsistent `SyncInfo` that violates round ordering invariants and causes peer synchronization failures.

## Finding Description
The AptosBFT consensus protocol requires strict ordering between certificate rounds (HQC.round >= HOC.round >= HCC.round). The `SyncInfo` struct enforces this through validation that explicitly checks these invariants: [1](#0-0) 

However, `BlockStore::sync_info()` violates atomicity by calling three separate methods, each acquiring and releasing the read lock independently: [2](#0-1) 

Each certificate accessor method acquires its own read lock: [3](#0-2) 

**Race Condition Scenario:**

1. Thread A calls `sync_info()` and reads `highest_quorum_cert()` returning round 10, then releases the read lock
2. Thread B calls `insert_quorum_cert()` with a QC certifying round 12, acquiring a write lock
3. Thread B updates `highest_quorum_cert` to round 12 and `highest_ordered_cert` to round 11 atomically under write lock: [4](#0-3) 
4. Thread A continues and reads `highest_ordered_cert()` returning round 11, then reads `highest_commit_cert()`
5. Thread A constructs `SyncInfo` with HQC.round=10, HOC.round=11, violating the invariant

The asynchronous pipeline callback mechanism enables this race: [5](#0-4) 

When this invalid `SyncInfo` is broadcast in consensus messages, peers reject it during verification.

## Impact Explanation
This vulnerability causes **HIGH severity** impact per Aptos bug bounty criteria:

- **Validator Node Performance Degradation**: During peak load periods with concurrent execution, the race window allows construction of invalid `SyncInfo` messages that are rejected by peers
- **Protocol Violation**: Breaks consensus synchronization invariants required for AptosBFT operation
- **Liveness Impact**: Affected nodes experience message rejections requiring retry cycles, degrading consensus performance

The impact is limited to liveness rather than safety—invalid `SyncInfo` is correctly rejected by peers rather than causing state divergence. However, in production networks processing high transaction throughput with multi-core validators, this race can occur during normal operation, causing noticeable performance degradation.

**Note**: While the vulnerability is real, the impact is transient rather than persistent. Each subsequent call to `sync_info()` will read a consistent state once the race window passes.

## Likelihood Explanation
**Likelihood: Medium**

The race condition can occur during normal network operation when:
- Nodes generate proposals, votes, or timeout messages (calling `sync_info()`)
- Concurrently, the execution pipeline processes block commitments (calling certificate update methods)
- The narrow microsecond window between read lock acquisitions allows interleaving with write operations

**Triggering Factors:**
- High transaction throughput increases pipeline callback frequency
- Multi-core validator systems enable true concurrent execution
- Async pipeline execution creates concurrent state updates

The race window is narrow but can occur naturally during peak load without requiring attacker intervention.

## Recommendation
Acquire a single read lock for all three certificate reads to ensure atomicity:

```rust
fn sync_info(&self) -> SyncInfo {
    let inner = self.inner.read();
    SyncInfo::new_decoupled(
        inner.highest_quorum_cert().as_ref().clone(),
        inner.highest_ordered_cert().as_ref().clone(),
        inner.highest_commit_cert().as_ref().clone(),
        inner.highest_2chain_timeout_cert().map(|tc| tc.as_ref().clone()),
    )
}
```

This ensures all three certificates are read from a consistent snapshot of the consensus state.

## Proof of Concept
The race condition can be demonstrated by:
1. Starting concurrent threads calling `sync_info()` while processing block commitments
2. Observing occasional "HQC has lower round than HOC" validation failures in peer logs
3. Monitoring consensus message rejection rates during high-TPS periods

The vulnerability is evidenced by the non-atomic code structure rather than requiring a specific exploit sequence, as it occurs naturally during concurrent operation.

## Notes
- This is a concurrency bug in consensus state management, not a blockchain state atomicity issue
- The vulnerability affects consensus liveness/performance, not safety guarantees
- The race is transient—subsequent `sync_info()` calls will succeed once the race window passes
- Fix is straightforward: hold a single read lock across all three certificate reads
- Production networks with multi-core validators and high TPS are most affected

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L152-156)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );
```

**File:** consensus/src/block_storage/block_store.rs (L475-489)
```rust
            let callback = Box::new(
                move |finality_proof: WrappedLedgerInfo,
                      commit_decision: LedgerInfoWithSignatures| {
                    if let Some(tree) = block_tree.upgrade() {
                        tree.write().commit_callback(
                            storage,
                            id,
                            round,
                            finality_proof,
                            commit_decision,
                            window_size,
                        );
                    }
                },
            );
```

**File:** consensus/src/block_storage/block_store.rs (L664-674)
```rust
    fn highest_quorum_cert(&self) -> Arc<QuorumCert> {
        self.inner.read().highest_quorum_cert()
    }

    fn highest_ordered_cert(&self) -> Arc<WrappedLedgerInfo> {
        self.inner.read().highest_ordered_cert()
    }

    fn highest_commit_cert(&self) -> Arc<WrappedLedgerInfo> {
        self.inner.read().highest_commit_cert()
    }
```

**File:** consensus/src/block_storage/block_store.rs (L680-688)
```rust
    fn sync_info(&self) -> SyncInfo {
        SyncInfo::new_decoupled(
            self.highest_quorum_cert().as_ref().clone(),
            self.highest_ordered_cert().as_ref().clone(),
            self.highest_commit_cert().as_ref().clone(),
            self.highest_2chain_timeout_cert()
                .map(|tc| tc.as_ref().clone()),
        )
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L349-386)
```rust
    pub(super) fn insert_quorum_cert(&mut self, qc: QuorumCert) -> anyhow::Result<()> {
        let block_id = qc.certified_block().id();
        let qc = Arc::new(qc);

        // Safety invariant: For any two quorum certificates qc1, qc2 in the block store,
        // qc1 == qc2 || qc1.round != qc2.round
        // The invariant is quadratic but can be maintained in linear time by the check
        // below.
        precondition!({
            let qc_round = qc.certified_block().round();
            self.id_to_quorum_cert.values().all(|x| {
                (*(*x).ledger_info()).ledger_info().consensus_data_hash()
                    == (*(*qc).ledger_info()).ledger_info().consensus_data_hash()
                    || x.certified_block().round() != qc_round
            })
        });

        match self.get_block(&block_id) {
            Some(block) => {
                if block.round() > self.highest_certified_block().round() {
                    self.highest_certified_block_id = block.id();
                    self.highest_quorum_cert = Arc::clone(&qc);
                }
            },
            None => bail!("Block {} not found", block_id),
        }

        self.id_to_quorum_cert
            .entry(block_id)
            .or_insert_with(|| Arc::clone(&qc));

        if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
            // Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?
            self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
        }

        Ok(())
    }
```
