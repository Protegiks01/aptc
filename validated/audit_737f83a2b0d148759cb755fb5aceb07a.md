# Audit Report

## Title
Gas Overcharge in MultiEd25519 Signature Verification Due to Premature Gas Calculation

## Summary
The `native_signature_verify_strict` function in the MultiEd25519 cryptography module charges gas for public key deserialization before validating the public key format. This allows malformed public keys with more than 32 keys (beyond the MAX_NUM_OF_KEYS boundary) to incur gas charges for all keys before being rejected, resulting in up to ~286 gas units of overcharge for maximum-sized malformed inputs.

## Finding Description
The vulnerability exists in the gas charging order within the native signature verification function. The function calculates the number of sub-public keys by simple integer division without any validation, immediately charges gas based on this count, and only then performs format validation that can reject the input. [1](#0-0) 

The vulnerable code calculates `num_sub_pks = pubkey.len() / ED25519_PUBLIC_KEY_LENGTH` without checking against MAX_NUM_OF_KEYS, then immediately charges `ED25519_PER_PUBKEY_DESERIALIZE * num_sub_pks` gas. Only after this charge does it call `MultiEd25519PublicKey::try_from`, which invokes validation. [2](#0-1) 

The `check_and_get_threshold` function properly validates that `num_of_keys > MAX_NUM_OF_KEYS` and rejects such inputs, but this validation occurs AFTER gas has already been charged for all the "keys" in the malformed input. [3](#0-2) 

The constant MAX_NUM_OF_KEYS is defined as 32.

**Attack Scenario:**
1. Attacker provides a 1,057-byte public key (33 keys × 32 bytes + 1 threshold byte)
2. Line 130 calculates: `num_sub_pks = 1057 / 32 = 33`
3. Line 133 charges gas for 33 keys: `33 × 139,688 = 4,609,704 internal gas units`
4. Line 134's `try_from` calls `check_and_get_threshold`, which detects 33 > 32 and rejects
5. Function returns false, but gas for 33 keys was already consumed

For maximum exploitation with 64 KB transaction: `2,048 keys × 139,688 = 286,073,856 internal gas units ≈ 286 external gas units`.

**Correct Implementation Pattern:** [4](#0-3) 

The `native_public_key_validate_v2` function demonstrates the correct approach: it calls `check_and_get_threshold` FIRST to validate format and extract the legitimate key count, returning early if validation fails, and only then processes keys with proper gas charging.

## Impact Explanation
This vulnerability violates the Resource Limits invariant - specifically that all operations must charge gas proportional to actual work performed. The gas charged does not match the work done since validation fails before any actual deserialization work occurs.

**Impact Quantification:** [5](#0-4) 

Maximum transaction size is 64 KB, allowing up to 2,048 malformed "key chunks". [6](#0-5) 

Gas cost per key deserialization is 139,688 internal gas units. [7](#0-6) 

With a scaling factor of 1,000,000, maximum overcharge is approximately 286 external gas units.

This constitutes **Medium Severity** under "Limited protocol violations" because:
- Users with malformed public keys are overcharged gas
- The overcharge scales with malformed input size up to transaction limits
- Violates gas metering correctness, a fundamental economic invariant
- While the absolute economic loss is limited (~0.03 APT maximum), it represents measurable incorrect resource charging

## Likelihood Explanation
**High Likelihood**: This vulnerability is triggered whenever signature verification is called with a malformed MultiEd25519 public key containing more than 32 keys. This can occur through: [8](#0-7) 

The public Move API `signature_verify_strict` directly passes raw bytes to the native function without pre-validation, making this exploitable by any user submitting transactions with malformed keys, whether accidentally or deliberately. Smart contracts processing untrusted public key inputs are particularly vulnerable.

## Recommendation
Reorder the validation to occur before gas charging, following the pattern in `native_public_key_validate_v2`:

1. Call `check_and_get_threshold` to validate format and extract legitimate key count
2. Return early if validation fails
3. Only then charge gas based on the validated key count
4. Proceed with deserialization

This ensures gas charges match actual work performed.

## Proof of Concept
```rust
// This can be tested by submitting a transaction calling signature_verify_strict_internal
// with a public key of 1057 bytes (33 keys + 1 threshold byte) and observing:
// 1. Gas charged for 33 keys (4,609,704 internal units)
// 2. Function returns false due to validation failure
// 3. Net result: overcharge of 1 key worth of gas (139,688 internal units)
```

**Notes:**
- The vulnerability is confirmed through direct code analysis showing gas charging occurs before validation
- The issue affects only malformed inputs; valid 32-key or fewer public keys work correctly
- The same vulnerability pattern exists for signature deserialization at lines 141-147, though the report focuses on public keys
- The economic impact, while limited in absolute terms, represents a protocol violation of correct resource metering

### Citations

**File:** aptos-move/framework/src/natives/cryptography/multi_ed25519.rs (L30-56)
```rust
fn native_public_key_validate_v2(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(ty_args.len(), 0);
    safely_assert_eq!(arguments.len(), 1);

    let pks_bytes = safely_pop_arg!(arguments, Vec<u8>);

    context.charge(ED25519_BASE)?;

    // Checks that these bytes correctly-encode a t-out-of-n MultiEd25519 PK
    let (_, num_sub_pks) = match multi_ed25519::check_and_get_threshold(
        &pks_bytes,
        ed25519::ED25519_PUBLIC_KEY_LENGTH,
    ) {
        Ok((t, n)) => (t, n),
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    let num_valid = num_valid_subpks(context, pks_bytes)?;
    let all_valid = num_valid == num_sub_pks as usize;

    Ok(smallvec![Value::bool(all_valid)])
```

**File:** aptos-move/framework/src/natives/cryptography/multi_ed25519.rs (L130-139)
```rust
    let num_sub_pks = NumArgs::new((pubkey.len() / ED25519_PUBLIC_KEY_LENGTH) as u64);
    let num_sub_sigs = NumArgs::new((signature.len() / ED25519_SIGNATURE_LENGTH) as u64);

    context.charge(ED25519_PER_PUBKEY_DESERIALIZE * num_sub_pks)?;
    let pk = match multi_ed25519::MultiEd25519PublicKey::try_from(pubkey.as_slice()) {
        Ok(pk) => pk,
        Err(_) => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L24-25)
```rust
/// const for max number of ed25519 keys allowed for multi-ed25519 keys
pub const MAX_NUM_OF_KEYS: usize = 32;
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L591-609)
```rust
pub fn check_and_get_threshold(
    bytes: &[u8],
    key_size: usize,
) -> std::result::Result<(u8, u8), CryptoMaterialError> {
    let payload_length = bytes.len();
    if bytes.is_empty() {
        return Err(CryptoMaterialError::WrongLengthError);
    }
    let threshold_num_of_bytes = payload_length % key_size;
    let num_of_keys = payload_length / key_size;
    let threshold_byte = bytes[bytes.len() - 1];

    if num_of_keys == 0 || num_of_keys > MAX_NUM_OF_KEYS || threshold_num_of_bytes != 1 {
        Err(CryptoMaterialError::WrongLengthError)
    } else if threshold_byte == 0 || threshold_byte > num_of_keys as u8 {
        Err(CryptoMaterialError::ValidationError)
    } else {
        Ok((threshold_byte, num_of_keys as u8))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L191-191)
```rust
        [ed25519_per_pubkey_deserialize: InternalGasPerArg, "signature.per_pubkey_deserialize", 139688],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/multi_ed25519.move (L217-225)
```text
    /// Verifies a purported MultiEd25519 `multisignature` under an *unvalidated* `public_key` on the specified `message`.
    /// This call will validate the public key by checking it is NOT in the small subgroup.
    public fun signature_verify_strict(
        multisignature: &Signature,
        public_key: &UnvalidatedPublicKey,
        message: vector<u8>
    ): bool {
        signature_verify_strict_internal(multisignature.bytes, public_key.bytes, message)
    }
```
