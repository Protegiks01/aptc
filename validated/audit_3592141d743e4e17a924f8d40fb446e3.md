# Audit Report

## Title
Consensus Configuration Inconsistency Due to Missing Version Compatibility Enforcement in OnChain Config Deserialization

## Summary
During rolling upgrades, validators running different software versions can operate with inconsistent consensus configurations when a governance proposal updates `OnChainConsensusConfig` to a newer variant (e.g., V5) that older validators cannot deserialize. This creates a critical liveness failure where validators sign different `LedgerInfo` hashes, preventing quorum formation and halting the network.

## Finding Description

The vulnerability stems from the interaction between BCS enum deserialization, fallback behavior, and the `order_vote_enabled` flag's impact on commit ledger info generation.

**Execution Flow:**

1. **Config Deserialization Phase**: At epoch transition, validators fetch `OnChainConsensusConfig` from on-chain state and attempt deserialization. [1](#0-0) 

2. **Deserialization Failure**: Validators running older software (knowing only V1-V4) fail to deserialize V5 configs via BCS, as BCS cannot handle unknown enum variants. The code logs a warning but continues execution.

3. **Fallback to Default**: Failed deserialization triggers `unwrap_or_default()`, returning `OnChainConsensusConfig::V4` with `order_vote_enabled: false`. [2](#0-1)  The default implementation returns V4 variant. [3](#0-2)  This default uses `ConsensusAlgorithmConfig::default_if_missing()` which sets `order_vote_enabled: false`. [4](#0-3) 

4. **Config Divergence**: The `OnChainConsensusConfig` enum supports variants V1 through V5, with V5 having additional fields. [5](#0-4)  Newer validators successfully deserialize V5 (potentially with `order_vote_enabled: true`), while older validators use V4 default (with `order_vote_enabled: false`). The `order_vote_enabled()` method returns different values based on the config variant. [6](#0-5) 

5. **Critical Impact - Different LedgerInfo Construction**: The `generate_commit_ledger_info` function creates fundamentally different `LedgerInfo` objects based on `order_vote_enabled`: when true, it uses `HashValue::zero()` as `consensus_data_hash`; when false, it uses `ordered_proof.ledger_info().consensus_data_hash()`. [7](#0-6)  This same conditional logic is also enforced in the commit vote signing path. [8](#0-7) 

6. **Quorum Formation Failure**: Validators sign different `LedgerInfo` hashes based on their config interpretation, making signature aggregation impossible. The network cannot form a commit quorum as signatures are collected on incompatible `LedgerInfo` objects. [9](#0-8) 

**No Version Enforcement**: The Move framework's `set_for_next_epoch` only validates that config bytes are non-empty, with no check that all validators can deserialize the new variant. [10](#0-9) 

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability**

This vulnerability meets the Aptos bug bounty's **Critical** criteria for "Total Loss of Liveness/Network Availability: Network halts due to protocol bug, all validators unable to progress."

The impact is severe because:

1. **Complete Network Halt**: Validators cannot aggregate signatures on commit decisions, preventing any blocks from being committed
2. **Silent Failure**: Validators continue operating but cannot reach consensus, making the issue difficult to diagnose
3. **Requires Manual Intervention**: Recovery requires coordinated validator upgrades or governance action to roll back the config
4. **Breaks Consensus Invariant**: Violates the requirement that all honest validators produce identical behavior for identical inputs

The vulnerability specifically causes different `consensus_data_hash` values in `LedgerInfo` objects that validators must sign, fundamentally breaking the ability to form a quorum certificate.

## Likelihood Explanation

**Medium Likelihood** during operational windows:

**Triggering Conditions:**
- Rolling upgrade in progress with mixed validator versions (standard practice)
- Governance proposal updates `OnChainConsensusConfig` to newer variant (V5) with `order_vote_enabled: true`
- No coordination between upgrade completion and config update timing

**Realistic Scenario:**
1. Validators begin rolling upgrade from version supporting V1-V4 to version supporting V1-V5
2. During upgrade window (50% upgraded, 50% not), governance proposal passes updating config to V5
3. At next epoch boundary, divergence occurs silently

**No Code-Level Protection:**
- Framework validation only checks non-empty bytes
- No minimum version requirements enforced
- No validator capability checks before applying configs
- Relies entirely on operational coordination (not enforced in code)

**Mitigating Factors:**
- Requires operational timing error (config update during incomplete upgrade)
- Aptos governance reviews proposals, but no technical enforcement
- The default genesis configuration uses `order_vote_enabled: true`, meaning any V5 config with this standard setting would trigger the vulnerability during incomplete upgrades

## Recommendation

Implement version compatibility enforcement at multiple layers:

1. **Move Framework Validation**: Add version compatibility checks in `set_for_next_epoch` that validate the config can be deserialized successfully before staging it for the next epoch.

2. **Epoch Manager Fail-Fast**: Instead of silently falling back to default on deserialization failure, validators should halt or refuse to participate in the new epoch when unable to deserialize the consensus config.

3. **Minimum Version Enforcement**: Introduce a mechanism to specify minimum validator software versions required for specific config variants, preventing config updates when validators don't meet requirements.

4. **Config Deployment Guards**: Add runtime checks during config application that verify all active validators report successful deserialization before the config becomes effective.

## Proof of Concept

This vulnerability requires a multi-validator testnet environment to demonstrate:

1. Deploy validator set with mixed software versions (some supporting V1-V4, others V1-V5)
2. Submit governance proposal updating `OnChainConsensusConfig` to V5 with `order_vote_enabled: true`
3. Trigger epoch transition
4. Observe that old validators fall back to V4 default with `order_vote_enabled: false`
5. Monitor commit vote phase - validators generate different `LedgerInfo` hashes
6. Verify signature aggregation fails and network cannot form quorum
7. Observe network halt due to inability to commit blocks

The core issue is validated by the code paths showing: deserialization fallback behavior, different `consensus_data_hash` values based on `order_vote_enabled`, and lack of version validation in the Move framework.

**Notes:**

This is a protocol-level vulnerability where the fallback mechanism for config deserialization failures creates silent consensus divergence rather than failing fast. The issue demonstrates a gap between the versioned enum design and the runtime enforcement of version compatibility across the validator set. While the vulnerability requires specific operational conditions (rolling upgrade + poorly timed config update), these conditions are realistic in production networks and the impact is catastrophic when triggered.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1189)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L192-213)
```rust
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L278-286)
```rust
    pub fn order_vote_enabled(&self) -> bool {
        match &self {
            OnChainConsensusConfig::V1(_config) => false,
            OnChainConsensusConfig::V2(_) => false,
            OnChainConsensusConfig::V3 { alg, .. }
            | OnChainConsensusConfig::V4 { alg, .. }
            | OnChainConsensusConfig::V5 { alg, .. } => alg.order_vote_enabled(),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L159-188)
```rust
                    let commit_ledger_info = generate_commit_ledger_info(
                        &commit_info,
                        &ordered_proof,
                        order_vote_enabled,
                    );

                    let mut partial_commit_proof =
                        create_signature_aggregator(unverified_votes, &commit_ledger_info);
                    if let Ok(commit_proof) = partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        debug!(
                            "{} advance to aggregated from ordered",
                            commit_proof.commit_info()
                        );
                        Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks,
                            commit_proof,
                        }))
                    } else {
                        Self::Executed(Box::new(ExecutedItem {
                            executed_blocks,
                            partial_commit_proof,
                            commit_info,
                            ordered_proof,
                        }))
                    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1004-1006)
```rust
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
