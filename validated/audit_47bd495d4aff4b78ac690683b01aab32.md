# Audit Report

## Title
Incomplete Complexity Metering for Variant Instantiation Tables in VERSION_7+ Modules

## Summary
The complexity checker fails to meter `struct_variant_instantiations` and `variant_field_instantiations` tables at the module level, allowing VERSION_7+ modules to include arbitrarily large, unused variant instantiation tables that bypass complexity limits.

## Finding Description

The Move binary format VERSION_7 introduced variant-related features (enums), adding four new tables to `CompiledModule`, including `struct_variant_instantiations` and `variant_field_instantiations`. [1](#0-0) 

The complexity checker in `check_module_complexity()` explicitly meters standard instantiation tables (`struct_def_instantiations`, `field_instantiations`, and `function_instantiations`) but completely omits the variant versions. [2](#0-1) 

While helper functions `meter_struct_variant_instantiation()` and `meter_variant_field_instantiation()` exist in the codebase [3](#0-2) [4](#0-3) , they are never called from `check_module_complexity()`. Unlike the metered instantiation types which have corresponding loop functions (e.g., `meter_struct_def_instantiations()`, `meter_field_instantiations()`), no such loop functions exist for variant instantiation tables. [5](#0-4) [6](#0-5) 

These individual metering functions are only invoked from `meter_code()` when specific variant bytecode instructions are encountered during function body analysis. [7](#0-6) 

**Attack Scenario:**
1. Attacker creates a VERSION_7+ module (VERSION_7 is supported; current VERSION_MAX is VERSION_10) [8](#0-7) 
2. Populates `struct_variant_instantiations` and `variant_field_instantiations` with hundreds of entries containing complex type signatures
3. Never references these instantiations in bytecode or struct definitions
4. The bounds checker validates all entries are well-formed [9](#0-8) 
5. Module publishing calls `check_module_complexity()` with budget `2048 + blob.code().len() * 20` [10](#0-9) 
6. But `check_module_complexity()` never meters the variant instantiation tables, allowing complexity budget bypass
7. Module consumes resources during deserialization, bounds checking, and VM operations without corresponding complexity charges

## Impact Explanation

This is a **Medium severity** vulnerability aligning with "Limited Protocol Violations" category (up to $10,000 per Aptos bug bounty):

**Resource Limits Violation:** The complexity checker exists to enforce computational limits on module complexity. This gap allows modules to exceed intended complexity budgets by including unmeasured variant instantiation tables containing arbitrarily complex type signatures.

**Limited but Real Impact:**
- Unused instantiation tables consume CPU cycles during module deserialization and bounds checking
- They occupy storage in the module binary and blockchain state
- The blob size-based budget (20 units per byte) provides partial protection, but complex type signatures in compact encodings can have a much higher processing cost per byte than this ratio accounts for
- This violates the fundamental resource limits invariant that all operations must respect computational limits

**Not Critical because:**
- All validators process modules identically (no consensus split or safety violation)
- The blob size budget provides some proportional scaling
- Bounds checking prevents malformed entries that could cause crashes
- Attack requires module publishing permissions and associated gas costs

## Likelihood Explanation

**Likelihood: Medium to High**

**Ease of Exploitation:**
- Any user with module publishing access can create such modules through standard transaction submission
- No special permissions, validator collusion, or infrastructure access required
- The bug is straightforward to exploit once discovered - simply populate the unused tables with complex instantiations
- VERSION_7+ modules are widely supported in production (current VERSION_MAX is VERSION_10)
- The gap is a simple omission in the metering logic, not a complex timing or race condition

**Mitigating Factors:**
- Requires understanding of Move binary format internals to craft effective exploits
- Module publishing has inherent gas costs that provide economic disincentive for spam
- The blob size-based budget component provides partial protection by scaling with module size
- Bounds checking prevents truly malicious or malformed entries

## Recommendation

Add loop functions to meter all entries in the variant instantiation tables, following the same pattern as other instantiation tables:

```rust
fn meter_struct_variant_instantiations(&self) -> PartialVMResult<()> {
    let struct_variant_insts = self.resolver.struct_variant_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get struct variant instantiations -- not a module.".to_string())
    })?;
    
    for struct_variant_inst_idx in 0..struct_variant_insts.len() {
        self.meter_struct_variant_instantiation(StructVariantInstantiationIndex(struct_variant_inst_idx as u16))?;
    }
    Ok(())
}

fn meter_variant_field_instantiations(&self) -> PartialVMResult<()> {
    let variant_field_insts = self.resolver.variant_field_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get variant field instantiations -- not a module.".to_string())
    })?;
    
    for variant_field_inst_idx in 0..variant_field_insts.len() {
        self.meter_variant_field_instantiation(VariantFieldInstantiationIndex(variant_field_inst_idx as u16))?;
    }
    Ok(())
}
```

Then call these functions in `check_module_complexity()`:

```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    // ... existing code ...
    
    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;
    meter.meter_struct_variant_instantiations()?;  // ADD THIS
    meter.meter_variant_field_instantiations()?;   // ADD THIS
    
    // ... rest of function ...
}
```

## Proof of Concept

A proof of concept would involve:
1. Creating a VERSION_7+ Move module with empty functions
2. Manually crafting the binary format to include large `struct_variant_instantiations` and `variant_field_instantiations` tables with complex type signatures
3. Ensuring these instantiations are never referenced in bytecode
4. Submitting the module for publishing
5. Observing that it passes complexity checking despite containing unmeasured complexity

The core vulnerability is demonstrated by the code structure itself - the absence of metering calls for these tables in `check_module_complexity()` compared to the presence of such calls for analogous tables.

## Notes

This is a clear implementation oversight where the metering pattern established for other instantiation tables (`struct_def_instantiations`, `field_instantiations`, `function_instantiations`) was not applied to the variant instantiation tables introduced in VERSION_7. The individual metering functions exist but lack the wrapper loop functions and calls from `check_module_complexity()` that would make them effective at the module level.

### Citations

**File:** third_party/move/move-binary-format/src/file_format.rs (L3474-3478)
```rust
    /// Since bytecode version 7: variant related handle tables
    pub struct_variant_handles: Vec<StructVariantHandle>,
    pub struct_variant_instantiations: Vec<StructVariantInstantiation>,
    pub variant_field_handles: Vec<VariantFieldHandle>,
    pub variant_field_instantiations: Vec<VariantFieldInstantiation>,
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L139-153)
```rust
    fn meter_struct_variant_instantiation(
        &self,
        struct_inst_idx: StructVariantInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_variant_insts =
            self.resolver
                .struct_variant_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get enum type instantiation -- not a module.".to_string(),
                    )
                })?;
        let struct_variant_inst = safe_get_table(struct_variant_insts, struct_inst_idx.0)?;
        self.meter_signature(struct_variant_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L155-165)
```rust
    fn meter_struct_def_instantiations(&self) -> PartialVMResult<()> {
        let struct_insts = self.resolver.struct_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct instantiations -- not a module.".to_string())
        })?;

        for struct_inst_idx in 0..struct_insts.len() {
            self.meter_struct_instantiation(StructDefInstantiationIndex(struct_inst_idx as u16))?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L180-195)
```rust
    fn meter_variant_field_instantiation(
        &self,
        variant_field_inst_idx: VariantFieldInstantiationIndex,
    ) -> PartialVMResult<()> {
        let variant_field_insts =
            self.resolver
                .variant_field_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get variant field instantiations -- not a module.".to_string(),
                    )
                })?;
        let field_inst = safe_get_table(variant_field_insts, variant_field_inst_idx.0)?;

        self.meter_signature(field_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L197-207)
```rust
    fn meter_field_instantiations(&self) -> PartialVMResult<()> {
        let field_insts = self.resolver.field_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get field instantiations -- not a module.".to_string())
        })?;

        for field_inst_idx in 0..field_insts.len() {
            self.meter_field_instantiation(FieldInstantiationIndex(field_inst_idx as u16))?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L272-286)
```rust
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L543-565)
```rust
/// Version 7: changes compare to version 6
/// + access specifiers (read/write set)
/// + enum types
pub const VERSION_7: u32 = 7;

/// Version 8: changes compared to version 7
/// + closure instructions
pub const VERSION_8: u32 = 8;

/// Version 9: changes compared to version 8
/// + signed integers
/// + allow `$` in identifiers
pub const VERSION_9: u32 = 9;

/// Version 10: changes compared to version 9
/// + abort with message instruction
pub const VERSION_10: u32 = 10;

/// Mark which oldest version is supported.
pub const VERSION_MIN: u32 = VERSION_5;

/// Mark which version is the latest version.
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L107-114)
```rust
        self.check_table(
            self.view.variant_field_instantiations(),
            Self::check_variant_field_instantiation,
        )?;
        self.check_table(
            self.view.struct_variant_instantiations(),
            Self::check_struct_variant_instantiation,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```
