# Audit Report

## Title
Epoch Mismatch in verify_payload_signatures() Causes Unverified Payload Accumulation Leading to Denial of Service

## Summary
The `verify_payload_signatures()` function in the consensus observer's payload store contains a logic flaw where payloads from epochs older than the current epoch are silently skipped without removal. This allows old unverified payloads to accumulate when a node skips epochs during commit sync, eventually exhausting the `max_num_pending_blocks` limit and causing legitimate payloads to be dropped, resulting in liveness failure for consensus observer nodes.

## Finding Description

The vulnerability exists in the epoch matching logic of `verify_payload_signatures()`. [1](#0-0) 

The function iterates through stored payloads and handles three cases:
1. **Breaks early** if `epoch > current_epoch` (future epochs)
2. **Processes** payloads where `epoch == current_epoch` (verifies or removes them)
3. **Silently skips** payloads where `epoch < current_epoch` (past epochs) - no code path handles this case

When a node receives block payloads for future epochs, they are stored as unverified because signature verification requires the epoch state. [2](#0-1) 

The accumulation occurs when:

1. A Byzantine validator/VFN sends block payloads for future epochs (e.g., epochs 6-10) while the observer is at epoch 5
2. These are stored as unverified (verified_payload = false) since signatures cannot be verified for future epochs
3. The node receives a commit decision and performs commit sync, transitioning directly from epoch 5 to epoch 11 (skipping epochs 6-10) [3](#0-2) 
4. After epoch transition, `verify_payload_signatures()` is called with the new epoch state
5. Payloads for epochs 6-10 have `epoch < current_epoch (11)`, so they are skipped in the iteration without verification or removal
6. These old unverified payloads persist indefinitely in the store
7. Repeated over subsequent epochs, the store accumulates old payloads until reaching the limit

When the store reaches `max_num_pending_blocks`, new payloads are dropped. [4](#0-3) 

**Critical Asymmetry**: The fallback sync path correctly clears all payloads by calling `clear_pending_block_state()` [5](#0-4)  which invokes `clear_all_payloads()` [6](#0-5) . However, the commit sync path does not perform this cleanup before calling `verify_payload_signatures()`, creating the vulnerability.

## Impact Explanation

This vulnerability causes **Medium to High Severity** impact:

- **Consensus Observer Node Liveness Failure**: Accumulated payloads exhaust the store limit (default 150 blocks [7](#0-6) ), preventing legitimate payloads from being stored and causing the observer node to fail processing new blocks

- **Resource Exhaustion**: Unbounded payload accumulation causes memory bloat affecting node performance

- **Protocol Invariant Violation**: The `max_num_pending_blocks` limit is designed to bound resource usage, but the logic flaw allows it to fill with stale unverified payloads rather than legitimate current-epoch payloads

**Important Clarification**: This affects Validator Fullnode (VFN) consensus observers, not consensus validators directly. [8](#0-7)  VFNs have both observer and publisher enabled, while validators only run publishers. However, VFN liveness failures can impact API availability and transaction relay capabilities.

The impact qualifies as High severity under "API crashes" if affected VFNs serve REST API requests, or Medium severity as a "temporary liveness issue" for observer infrastructure.

## Likelihood Explanation

**Likelihood: Medium**

Required conditions:
1. **Byzantine actor with publisher capability**: A malicious or compromised validator/VFN sending crafted block payloads (< 1/3 Byzantine is within Aptos threat model)
2. **Epoch skipping during commit sync**: Common when nodes fall behind or during network disruptions
3. **Sustained attack**: Attacker must send payloads for multiple future epochs over time

The attack complexity is moderate - it requires control of a publisher node (validator or VFN) but does not require cryptographic breaks or majority stake collusion. The commit sync path triggering epoch skips is a normal operational scenario.

## Recommendation

Add cleanup logic for old epoch payloads in `verify_payload_signatures()`:

```rust
for (epoch, round) in payload_epochs_and_rounds {
    if epoch > current_epoch {
        break;
    }
    
    if epoch == current_epoch {
        // Existing verification logic...
    } else if epoch < current_epoch {
        // NEW: Remove old epoch payloads
        self.block_payloads.lock().remove(&(epoch, round));
    }
}
```

Alternatively, call `clear_all_payloads()` or `remove_blocks_for_epoch_round()` before calling `verify_payload_signatures()` in the commit sync path to match the fallback sync behavior.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Configuring a consensus observer node
2. Having a Byzantine publisher send BlockPayload messages for epochs N+1, N+2, N+3 while observer is at epoch N
3. Triggering commit sync that skips those epochs (e.g., sync to epoch N+5)
4. Observing that old payloads remain in the store via metrics
5. Repeating until `max_num_pending_blocks` is exhausted
6. Verifying that new legitimate payloads are dropped

A full Rust test would require setting up consensus observer test infrastructure with mock publishers and state sync, but the logic flaw is evident from code inspection of the asymmetric cleanup paths.

## Notes

- The vulnerability is a logic bug in epoch handling, not a pure network DoS attack
- The fix is straightforward: add cleanup for `epoch < current_epoch` case
- The asymmetry between commit sync and fallback sync paths is the root cause
- Impact severity depends on whether affected VFNs serve critical API endpoints

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L217-274)
```rust
    pub fn verify_payload_signatures(&mut self, epoch_state: &EpochState) -> Vec<Round> {
        // Get the current epoch
        let current_epoch = epoch_state.epoch;

        // Gather the keys for the block payloads
        let payload_epochs_and_rounds: Vec<(u64, Round)> =
            self.block_payloads.lock().keys().cloned().collect();

        // Go through all unverified blocks and attempt to verify the signatures
        let mut verified_payloads_to_update = vec![];
        for (epoch, round) in payload_epochs_and_rounds {
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }

            // Otherwise, attempt to verify the payload signatures
            if epoch == current_epoch {
                if let Entry::Occupied(mut entry) = self.block_payloads.lock().entry((epoch, round))
                {
                    if let BlockPayloadStatus::AvailableAndUnverified(block_payload) =
                        entry.get_mut()
                    {
                        if let Err(error) = block_payload.verify_payload_signatures(epoch_state) {
                            // Log the verification failure
                            error!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Failed to verify the block payload signatures for epoch: {:?} and round: {:?}. Error: {:?}",
                                    epoch, round, error
                                ))
                            );

                            // Remove the block payload from the store
                            entry.remove();
                        } else {
                            // Save the block payload for reinsertion
                            verified_payloads_to_update.push(block_payload.clone());
                        }
                    }
                }
            }
        }

        // Collect the rounds of all newly verified blocks
        let verified_payload_rounds: Vec<Round> = verified_payloads_to_update
            .iter()
            .map(|block_payload| block_payload.round())
            .collect();

        // Update the verified block payloads. Note: this will cause
        // notifications to be sent to any listeners that are waiting.
        for verified_payload in verified_payloads_to_update {
            self.insert_block_payload(verified_payload, true);
        }

        // Return the newly verified payload rounds
        verified_payload_rounds
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-418)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L960-961)
```rust
        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1025-1045)
```rust
        // Otherwise, the commit sync notification matches the block data root.
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-95)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```
