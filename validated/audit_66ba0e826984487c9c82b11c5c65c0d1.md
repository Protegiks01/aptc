# Audit Report

## Title
Binary Complexity Check Bypass via Non-Generic Instruction Sequences

## Summary
The `meter_code()` function in the Move binary complexity checker only meters generic bytecode instructions for their type instantiations, while non-generic instructions incur no complexity cost. This allows attackers to publish modules containing up to 65,535 non-generic instructions that bypass the intended complexity budget, causing excessive computational cost during verification on all validator nodes.

## Finding Description

The binary complexity checking system is designed to prevent resource exhaustion during module verification. The budget is calculated as `2048 + blob.code().len() * 20`: [1](#0-0) 

However, the `meter_code()` function only meters generic bytecode variants (CallGeneric, PackGeneric, etc.) for their type instantiations: [2](#0-1) 

Non-generic instructions, including arithmetic operations, branches, local operations, field accesses, and global operations, perform no metering at all: [3](#0-2) 

An attacker can create a function with up to 65,535 non-generic instructions (maximum allowed by BYTECODE_COUNT_MAX): [4](#0-3) 

These instructions can fit within a single basic block, bypassing the `max_basic_blocks: 1024` production limit: [5](#0-4) 

During module verification, all instructions must be processed by multiple verification passes. The `verify_module_with_config` function executes multiple verifiers including CodeUnitVerifier: [6](#0-5) 

The type safety verifier iterates through every instruction in the code: [7](#0-6) 

While verifier metering (`max_per_fun_meter_units`) provides a secondary defense: [8](#0-7) 

The metering cost for simple non-generic instructions is minimal. Arithmetic operations charge only TYPE_NODE_COST (30 units) per simple type pushed: [9](#0-8) [10](#0-9) 

For 65,535 instructions, this totals approximately 1,966,050 unitsâ€”only 2.45% of the 80,000,000 limit. The binary complexity check becomes ineffective while verification still requires multiple complete iterations through all instructions.

Module verification occurs during transaction execution when modules are loaded: [11](#0-10) 

## Impact Explanation

This represents **High Severity** under the Aptos bug bounty program's "Validator Node Slowdowns" category. All validators must verify published modules during transaction execution. A malicious module with 65,535 non-generic instructions would force all validator nodes to perform expensive verification (multiple passes through all instructions) while consuming minimal complexity budget. This causes significant performance degradation that could affect block execution timing and consensus participation.

The binary complexity check is specifically designed to prevent this type of resource exhaustion, but fails for non-generic instructions, making this a protocol-level vulnerability rather than a mere performance issue.

## Likelihood Explanation

This vulnerability is highly exploitable:
1. Any user can publish modules to the blockchain via standard transactions
2. Creating a module with maximum non-generic instructions is straightforward
3. No special privileges or validator access required  
4. The binary complexity check is performed on every module publication
5. All validators are affected simultaneously during transaction execution
6. Verification cost scales linearly with instruction count

## Recommendation

Modify the `meter_code()` function to charge complexity costs for non-generic instructions based on instruction count, not just generic type instantiations. A simple approach would be to charge a base cost per instruction:

```rust
fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
    self.meter_signature(code.locals)?;
    
    // Charge base cost per instruction
    const COST_PER_INSTRUCTION: u64 = 1;
    self.charge(code.code.len() as u64 * COST_PER_INSTRUCTION)?;
    
    // Then charge additional costs for generic instantiations
    for instr in &code.code {
        match instr {
            // ... existing generic instruction metering
        }
    }
    Ok(())
}
```

Alternatively, adjust the budget formula to account for instruction count explicitly, or lower the `max_per_fun_meter_units` limit to make the verifier metering more effective.

## Proof of Concept

A PoC would involve creating a Move module with a function containing 65,535 arithmetic operations (e.g., repeated `x = x + 1` operations) and submitting it as a module publication transaction. The module would pass binary complexity checks but force expensive verification on all validators.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L266-298)
```rust
                CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                    self.meter_function_instantiation(*idx)?;
                },
                PackGeneric(idx) | UnpackGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
                CallClosure(idx)
                | VecPack(idx, _)
                | VecLen(idx)
                | VecImmBorrow(idx)
                | VecMutBorrow(idx)
                | VecPushBack(idx)
                | VecPopBack(idx)
                | VecUnpack(idx, _)
                | VecSwap(idx) => {
                    self.meter_signature(*idx)?;
                },
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L300-380)
```rust
                // List out the other options explicitly so there's a compile error if a new
                // bytecode gets added.
                Pop
                | Ret
                | Branch(_)
                | BrTrue(_)
                | BrFalse(_)
                | LdU8(_)
                | LdU16(_)
                | LdU32(_)
                | LdU64(_)
                | LdU128(_)
                | LdU256(_)
                | LdI8(_)
                | LdI16(_)
                | LdI32(_)
                | LdI64(_)
                | LdI128(_)
                | LdI256(_)
                | LdConst(_)
                | CastU8
                | CastU16
                | CastU32
                | CastU64
                | CastU128
                | CastU256
                | CastI8
                | CastI16
                | CastI32
                | CastI64
                | CastI128
                | CastI256
                | LdTrue
                | LdFalse
                | Call(_)
                | Pack(_)
                | Unpack(_)
                | PackVariant(_)
                | UnpackVariant(_)
                | TestVariant(_)
                | PackClosure(..)
                | ReadRef
                | WriteRef
                | FreezeRef
                | Add
                | Sub
                | Mul
                | Mod
                | Div
                | Negate
                | BitOr
                | BitAnd
                | Xor
                | Shl
                | Shr
                | Or
                | And
                | Not
                | Eq
                | Neq
                | Lt
                | Gt
                | Le
                | Ge
                | CopyLoc(_)
                | MoveLoc(_)
                | StLoc(_)
                | MutBorrowLoc(_)
                | ImmBorrowLoc(_)
                | MutBorrowField(_)
                | ImmBorrowField(_)
                | MutBorrowVariantField(_)
                | ImmBorrowVariantField(_)
                | MutBorrowGlobal(_)
                | ImmBorrowGlobal(_)
                | Exists(_)
                | MoveTo(_)
                | MoveFrom(_)
                | Abort
                | AbortMsg
                | Nop => (),
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L30-30)
```rust
const TYPE_NODE_COST: u128 = 30;
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L113-128)
```rust
pub(crate) fn verify<'a>(
    resolver: &'a BinaryIndexedView<'a>,
    function_view: &'a FunctionView<'a>,
    meter: &mut impl Meter, // currently unused
) -> PartialVMResult<()> {
    let verifier = &mut TypeSafetyChecker::new(resolver, function_view);

    for block_id in function_view.cfg().blocks() {
        for offset in function_view.cfg().instr_indexes(block_id) {
            let instr = &verifier.function_view.code().code[offset as usize];
            verify_instr(verifier, instr, offset, meter)?
        }
    }

    Ok(())
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1042-1050)
```rust
        Bytecode::Add | Bytecode::Sub | Bytecode::Mul | Bytecode::Mod | Bytecode::Div => {
            let operand1 = safe_unwrap!(verifier.stack.pop());
            let operand2 = safe_unwrap!(verifier.stack.pop());
            if operand1.is_integer() && operand1 == operand2 {
                verifier.push(meter, operand1)?;
            } else {
                return Err(verifier.error(StatusCode::INTEGER_OP_TYPE_MISMATCH_ERROR, offset));
            }
        },
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L183-201)
```rust
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```
