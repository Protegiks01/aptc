# Audit Report

## Title
Non-Exhaustive Pattern Matching Causes Silent Drop of Quorum Store V2 Messages Leading to Consensus Liveness Failure

## Summary
The `NetworkTask::start()` method in `consensus/src/network.rs` uses a non-exhaustive match statement when processing direct-send consensus messages. Three critical quorum store V2 message variants (`BatchMsgV2`, `SignedBatchInfoMsgV2`, `ProofOfStoreMsgV2`) are not handled by this match statement, causing them to be silently dropped when received. This breaks the quorum store protocol and causes total consensus liveness failure when V2 batching is enabled.

## Finding Description

The `ConsensusMsg` enum defines three V2 quorum store message variants that use `BatchInfoExt` instead of the legacy `BatchInfo` type: [1](#0-0) 

These V2 messages are actively used in production code when the `enable_batch_v2` configuration flag is enabled. The configuration flag is defined in the quorum store config: [2](#0-1) 

The batch generator broadcasts V2 batch messages when the flag is enabled: [3](#0-2) 

The batch coordinator sends V2 signed batch info messages when it detects V2 batches: [4](#0-3) 

The proof coordinator broadcasts V2 proof of store messages when proofs contain V2 batch info: [5](#0-4) 

These messages are sent via the `broadcast()` and `send()` methods, which deliver messages through the `Event::Message` path (direct-send): [6](#0-5) 

The `NetworkSender` implementation wraps V2 batches in the appropriate message variants: [7](#0-6) [8](#0-7) 

However, the `NetworkTask::start()` method's match statement for `Event::Message` only handles the V1 versions of these messages: [9](#0-8) 

The V2 variants (`ConsensusMsg::BatchMsgV2`, `ConsensusMsg::SignedBatchInfoMsgV2`, `ConsensusMsg::ProofOfStoreMsgV2`) are not included in any match arms. They fall through to the wildcard pattern which only logs a warning and drops the message: [10](#0-9) 

Meanwhile, the round manager defines `UnverifiedEvent` variants for V2 messages and expects to receive them: [11](#0-10) 

The conversion from `ConsensusMsg` to `UnverifiedEvent` includes V2 variants: [12](#0-11) 

However, these messages never reach the round manager because they are dropped at the network layer before they can be converted and forwarded.

**Attack Path:**
1. Network operators enable `enable_batch_v2` flag in quorum store configuration
2. Quorum store components begin broadcasting `BatchMsgV2`, `SignedBatchInfoMsgV2`, and `ProofOfStoreMsgV2` messages via direct-send
3. Receiving validators' `NetworkTask::start()` processes these messages via `Event::Message`
4. Match statement fails to find patterns for V2 variants
5. Messages hit wildcard branch at line 937-940 and are silently dropped with only a warning log
6. Validators cannot exchange batch information or form quorum certificates
7. Consensus protocol stalls - no new blocks can be proposed or committed

## Impact Explanation

This vulnerability has **Critical Severity** impact per the Aptos bug bounty program.

**Total Loss of Liveness/Network Availability**: When V2 batching is enabled, all validators are unable to exchange quorum store messages. This completely breaks the transaction batching protocol required for consensus operation. Without the ability to exchange batch messages, signed batch information, and proofs of store, validators cannot:
- Disseminate transaction batches to peers
- Collect batch signatures from other validators
- Form and broadcast proofs of store
- Create block proposals with valid quorum store payloads

The network becomes completely unavailable for processing transactions and requires operator intervention to disable V2 batching or apply a code hotfix.

**Non-recoverable without code changes**: Unlike temporary network issues or transient bugs, this is a deterministic code-level defect. All validators in the network are affected simultaneously when V2 is enabled, and the issue persists until the match statement is corrected.

This meets the Critical Severity criteria: "Total loss of liveness/network availability" with potential damages up to $1,000,000 per the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger automatically whenever the `enable_batch_v2` configuration flag is enabled, which represents the intended upgrade path for the quorum store protocol. No attacker action is required - this is a protocol-level implementation bug that affects all honest validators.

The vulnerability was introduced when V2 message types were added to the `ConsensusMsg` enum to support `BatchInfoExt` with enhanced batch metadata, but the `NetworkTask::start()` message handler was not updated to include these new variants in its match statement. The code explicitly checks the configuration flag and conditionally sends V2 messages in production paths, making this a guaranteed trigger condition rather than an edge case.

## Recommendation

Update the `NetworkTask::start()` method in `consensus/src/network.rs` to handle V2 quorum store message variants. The match statement at lines 823-831 should be extended to include:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)
| ConsensusMsg::BatchMsgV2(_)
| ConsensusMsg::ProofOfStoreMsgV2(_)) => {
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
},
```

This ensures that both V1 and V2 quorum store messages are properly forwarded to the quorum store message queue for processing.

## Proof of Concept

The bug can be demonstrated by:

1. Enabling `enable_batch_v2: true` in the quorum store configuration
2. Starting a validator network with this configuration
3. Observing that V2 batch messages are sent via `broadcast_batch_msg_v2()`
4. Monitoring logs for "Unexpected direct send msg" warnings when V2 messages are received
5. Confirming that consensus stalls as validators cannot exchange batch information

The deterministic nature of this bug means it will manifest immediately upon enabling the V2 flag on a live network, causing complete consensus failure.

## Notes

This is a critical protocol-level bug that demonstrates incomplete migration from V1 to V2 batch message types. The sender code was updated to support V2 messages, the data structures were extended to include V2 variants, and the round manager was updated to process V2 events, but the network receive path was not updated, creating a complete disconnect in the message flow. This would cause catastrophic consensus failure if the `enable_batch_v2` flag were enabled in production.

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-495)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L108-110)
```rust
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L487-487)
```rust
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
```

**File:** consensus/src/network.rs (L363-385)
```rust
    async fn broadcast(&self, msg: ConsensusMsg) {
        fail_point!("consensus::send::any", |_| ());
        // Directly send the message to ourself without going through network.
        let self_msg = Event::Message(self.author, msg.clone());
        let mut self_sender = self.self_sender.clone();
        if let Err(err) = self_sender.send(self_msg).await {
            error!("Error broadcasting to self: {:?}", err);
        }

        #[cfg(feature = "failpoints")]
        {
            let msg_ref = &msg;
            fail_point!("consensus::send::broadcast_self_only", |maybe_msg_name| {
                if let Some(msg_name) = maybe_msg_name {
                    if msg_ref.name() != &msg_name {
                        self.broadcast_without_self(msg_ref.clone());
                    }
                }
            });
        }

        self.broadcast_without_self(msg);
    }
```

**File:** consensus/src/network.rs (L617-620)
```rust
    async fn broadcast_batch_msg_v2(&mut self, batches: Vec<Batch<BatchInfoExt>>) {
        fail_point!("consensus::send::broadcast_batch", |_| ());
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L629-632)
```rust
    async fn broadcast_proof_of_store_msg_v2(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
```

**File:** consensus/src/network.rs (L822-831)
```rust
                    match msg {
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
                        },
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/round_manager.rs (L97-101)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/round_manager.rs (L263-265)
```rust
            ConsensusMsg::BatchMsgV2(m) => UnverifiedEvent::BatchMsgV2(m),
            ConsensusMsg::SignedBatchInfoMsgV2(m) => UnverifiedEvent::SignedBatchInfoMsgV2(m),
            ConsensusMsg::ProofOfStoreMsgV2(m) => UnverifiedEvent::ProofOfStoreMsgV2(m),
```
