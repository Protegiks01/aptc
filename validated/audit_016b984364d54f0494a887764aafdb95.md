# Audit Report

## Title
Timeout Certificate Invalidation via Duplicate Validator Timeout Submissions with Mismatched HQC Rounds

## Summary
A Byzantine validator can submit multiple `RoundTimeout` messages for the same round with different `hqc_round` values, causing aggregated `TwoChainTimeoutCertificate` to become invalid and preventing affected validators from syncing with the network.

## Finding Description

The vulnerability exists in the timeout signature aggregation logic where duplicate timeout messages from the same validator are processed inconsistently.

**Core Vulnerability:**

The `TwoChainTimeoutWithPartialSignatures::add()` method performs two operations that become inconsistent when duplicate timeouts are received: [1](#0-0) 

The first operation updates the timeout object if `hqc_round` is higher, while the second operation adds the signature using `.or_insert()`: [2](#0-1) 

The `.or_insert()` pattern only inserts if the validator key doesn't exist, meaning:
- First timeout from validator A with hqc_round=5: Stores signature with round 5
- Second timeout from validator A with hqc_round=10: Signature NOT updated (remains round 5), but timeout object IS updated to hqc_round=10

**Verification Failure:**

When the timeout certificate is verified, it checks that the timeout's hqc_round equals the maximum of all signed rounds: [3](#0-2) 

With the inconsistency (e.g., timeout.hqc_round=10 but max(signed_rounds)=5), this check fails.

**No Deduplication:**

The vulnerability is exploitable because no deduplication exists in the timeout processing pipeline: [4](#0-3) [5](#0-4) 

Unlike vote processing which explicitly checks for duplicate authors and returns `DuplicateVote`, timeout processing has no such protection.

**Attack Propagation:**

When validators with invalid TCs attempt to sync with others, the TC verification fails: [6](#0-5) [7](#0-6) 

The `sync_info.verify()` call rejects the invalid TC, preventing affected validators from syncing and causing liveness disruption.

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as **High Severity** ($50,000) under the Aptos bug bounty criteria for "Significant protocol violations" and "Validator Node Slowdowns."

**Impact:**
- Validators that aggregate invalid TCs cannot sync with the network (SyncInfo verification fails)
- Consensus liveness is disrupted for affected rounds
- Requires validators to wait for new TCs or epoch changes to recover
- A single Byzantine validator (< 1/3 stake) can trigger this attack

**Note:** While the report claims "Total loss of liveness/network availability" (Critical severity), the actual impact is more limited. The network can potentially recover when new valid TCs are formed, and not all validators are permanently affected. This is a temporary liveness disruption rather than permanent network failure.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly realistic because:
- Any validator can send multiple `RoundTimeout` network messages for the same round (no rate limiting)
- No message deduplication exists at any layer (network, round manager, round state, pending votes)
- Requires only a single Byzantine validator (< 1/3 stake requirement)
- Attack can be executed silently without detection until TCs fail verification
- Minimal timing requirements - both timeouts just need to arrive before quorum is reached

## Recommendation

Implement duplicate timeout detection in `PendingVotes::insert_round_timeout()` similar to the duplicate vote handling:

```rust
// Add to PendingVotes struct
author_to_timeout: HashMap<Author, RoundTimeout>,

// In insert_round_timeout(), add check before processing:
if let Some(previous_timeout) = self.author_to_timeout.get(&round_timeout.author()) {
    // Check if it's the same timeout
    if previous_timeout.two_chain_timeout().hqc_round() == timeout.hqc_round() {
        return VoteReceptionResult::DuplicateVote; // Reuse existing enum variant
    } else {
        // Different timeout from same author - potential equivocation
        error!("Validator {} sent multiple different timeouts for round {}", 
               round_timeout.author(), round);
        return VoteReceptionResult::EquivocateVote;
    }
}
self.author_to_timeout.insert(round_timeout.author(), round_timeout.clone());
```

Alternatively, modify `PartialSignaturesWithRound::add_signature` to use `.insert()` instead of `.or_insert()` to always update signatures, ensuring consistency.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a test network with 4 validators
2. Having validator A send timeout(hqc_round=5)
3. Having validator A send timeout(hqc_round=10) for the same round
4. Having validators B and C send their timeouts
5. Observing that the aggregated TC has inconsistent hqc_round vs signed_rounds
6. Verifying that TC verification fails with the "Inconsistent hqc round" error

A Rust test case would follow the pattern in the existing test suite: [8](#0-7) 

## Notes

This is a valid consensus protocol vulnerability that affects the timeout certificate mechanism in AptosBFT. While the technical details are accurate, the severity should be classified as **HIGH** rather than Critical, as the impact is temporary liveness disruption rather than permanent network failure. The vulnerability is within the threat model (single Byzantine validator < 1/3 stake) and can be triggered without special preconditions.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L259-262)
```rust
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L492-499)
```rust
        // hqc round does not match signed round
        let mut invalid_timeout_cert = invalid_tc_with_partial_sig.clone();
        invalid_timeout_cert.timeout.quorum_cert = generate_quorum(2, quorum_size);

        let invalid_tc_with_sig = invalid_timeout_cert
            .aggregate_signatures(&validators)
            .unwrap();
        invalid_tc_with_sig.verify(&validators).unwrap_err();
```

**File:** consensus/src/pending_votes.rs (L190-232)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/src/liveness/round_state.rs (L306-316)
```rust
    pub fn insert_round_timeout(
        &mut self,
        timeout: &RoundTimeout,
        verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        if timeout.round() == self.current_round {
            self.pending_votes.insert_round_timeout(timeout, verifier)
        } else {
            VoteReceptionResult::UnexpectedRound(timeout.round(), self.current_round)
        }
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L204-209)
```rust
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
```

**File:** consensus/src/round_manager.rs (L888-896)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```
