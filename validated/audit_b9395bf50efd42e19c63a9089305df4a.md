# Audit Report

## Title
Consensus Safety Violation via Partial Transaction Filter Validation in Hybrid Payloads

## Summary
The consensus validation phase only checks inline transactions against filter rules, while the execution phase filters ALL transactions (including proof-based batches). Since validators use separate local `consensus_filter` and `execution_filter` configurations with no cross-validator consistency enforcement, validators with different execution filter settings will execute different transaction sets from the same committed block, producing divergent state roots and breaking consensus safety.

## Finding Description

The vulnerability stems from an architectural mismatch in how transaction filtering is applied across the consensus-to-execution pipeline for hybrid payloads.

**Two Separate Filter Configurations:**

The system maintains distinct filter configurations for consensus and execution phases: [1](#0-0) 

These are local node configurations, not on-chain consensus parameters: [2](#0-1) [3](#0-2) 

**Validation Phase (Proposal Acceptance):**

During proposal validation, the round manager calls `check_denied_inline_transactions()`: [4](#0-3) 

For `QuorumStorePayloadManager`, this method only validates inline transactions: [5](#0-4) 

The `get_inline_transactions()` helper extracts ONLY inline batches, ignoring proof-based batches: [6](#0-5) 

**Execution Phase (Transaction Retrieval):**

When blocks are executed, `get_transactions()` retrieves ALL transactions including proof-based portions: [7](#0-6) 

This calls `get_transactions_quorum_store_inline_hybrid()` which fetches transactions from both inline batches AND proof batches: [8](#0-7) 

The `process_qs_payload()` function retrieves transactions from `proof_with_data.proofs` that were never validated during proposal acceptance: [9](#0-8) 

**Filtering During Execution:**

During block preparation for execution, ALL transactions are filtered using the `execution_filter` configuration: [10](#0-9) 

The filtering logic removes transactions matching the filter rules: [11](#0-10) 

**Attack Scenario:**

1. **Validator Configuration:** Validator A configures `execution_filter` to deny transactions from address 0xABCD for legitimate operational reasons (e.g., regulatory compliance, emergency response). Validator B has no execution filter or different rules.

2. **Block Proposal:** A block proposer creates a `QuorumStoreInlineHybrid` payload through normal quorum store operations:
   - `inline_batches`: Contains transactions that pass all validators' consensus filters
   - `proof_with_data.proofs`: Contains a transaction from address 0xABCD (naturally placed by quorum store mechanism)

3. **Validation Phase:** All validators call `check_denied_inline_transactions()` → only inline batches checked → transaction from 0xABCD not in inline portion → PASS for all validators

4. **Voting & Commitment:** All validators vote on the block → block achieves 2f+1 votes → block is committed

5. **Execution Phase:**
   - Validator A: Retrieves ALL transactions (inline + proof) → `execution_filter` removes 0xABCD transaction → executes N-1 transactions → computes state root R₁
   - Validator B: Retrieves ALL transactions → no execution filter → executes ALL N transactions → computes state root R₂

6. **Consensus Divergence:** R₁ ≠ R₂ → Validators cannot agree on the next block's parent state → Consensus halts or chain splits

This violates the fundamental consensus safety invariant: **"All honest validators must produce identical state roots for identical committed blocks"**

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program's "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" categories:

1. **Consensus Safety Break:** Validators compute different state roots for the same committed block, directly violating AptosBFT's safety guarantees. Unlike typical Byzantine faults that require >1/3 malicious validators, this exploits legitimate configuration differences.

2. **Network Partition:** Once divergence occurs, validators form incompatible ledger states that cannot reconcile through normal consensus operations. The network effectively splits into groups based on their execution filter configurations.

3. **Requires Hardfork Recovery:** The divergence is permanent and irrecoverable through protocol mechanisms. Manual coordination and a hardfork are required to resolve the state inconsistency and reunify the network.

4. **No Detection Mechanism:** Validators silently diverge without immediate alerts, as they both voted on and committed the same block. The divergence only becomes apparent when trying to build the next block.

## Likelihood Explanation

**High Likelihood:**

1. **Legitimate Configuration Diversity:** Production blockchain networks commonly have validators with different operational configurations for valid reasons:
   - Gradual rollout of new filter rules across validator set
   - Emergency response capabilities (quick blocking of specific transactions)
   - Regulatory compliance requirements varying by jurisdiction
   - Testing new filter configurations before full deployment

2. **No Consistency Enforcement:** The codebase contains no validation or enforcement mechanism to ensure all validators use identical `execution_filter` configurations. Each validator independently configures their local node settings.

3. **Natural Trigger Condition:** The vulnerability doesn't require a malicious proposer. The quorum store mechanism naturally distributes transactions between inline batches and proof batches. If any proof-based transaction matches a filter rule, divergence occurs.

4. **Silent Failure Mode:** The consensus protocol successfully commits blocks during the validation phase, providing no indication of impending execution divergence. Validators only discover the issue when attempting to build subsequent blocks.

5. **Low Barrier to Trigger:** The attack requires only:
   - Natural variation in validator configurations (common in production)
   - Normal block proposal operations (no special manipulation needed)
   - Standard hybrid payload types (supported protocol feature)

## Recommendation

Implement one of the following architectural fixes:

**Option 1: Unified Filter Configuration**
- Make `execution_filter` identical to `consensus_filter` by design
- Remove the separate `execution_filter` configuration
- Apply the same filter rules during both validation and execution phases

**Option 2: Consensus-Level Filter Enforcement**
- Move filter configurations to on-chain consensus parameters
- Require all validators to use identical filter configurations through on-chain governance
- Reject blocks from validators with divergent filter configurations

**Option 3: Complete Validation at Proposal Time**
- Extend `check_denied_inline_transactions()` to validate ALL transactions (inline + proof-based)
- Modify `get_inline_transactions()` to extract transactions from all payload portions
- Ensure validation phase checks the complete transaction set that will be executed

**Option 4: Filter-Aware Consensus**
- Include filtered transaction lists in the block commitment
- Make filter results part of the consensus-agreed state
- Ensure all validators agree on which transactions to execute before committing

**Recommended Implementation (Option 3 - Least Disruptive):**

Modify the validation phase to check all transactions:

```rust
// In quorum_store_payload_manager.rs
fn check_denied_inline_transactions(
    &self,
    block: &Block,
    block_txn_filter_config: &BlockTransactionFilterConfig,
) -> anyhow::Result<()> {
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }

    // Get ALL transactions that will be executed (not just inline)
    let all_transactions = self.get_all_transactions_for_validation(block)?;
    
    if all_transactions.is_empty() {
        return Ok(());
    }

    // Check all transactions against the filter
    let denied_transactions = block_txn_filter_config
        .block_transaction_filter()
        .get_denied_block_transactions(
            block.id(),
            block.author(),
            block.epoch(),
            block.timestamp_usecs(),
            all_transactions,
        );
        
    if !denied_transactions.is_empty() {
        return Err(anyhow::anyhow!(
            "Block contains denied transactions: {:?}",
            denied_transactions
        ));
    }

    Ok(())
}
```

Additionally, add runtime validation to ensure `consensus_filter` and `execution_filter` are identical:

```rust
// In node startup
fn validate_filter_consistency(config: &NodeConfig) -> Result<()> {
    if config.transaction_filters.consensus_filter != config.transaction_filters.execution_filter {
        return Err(anyhow::anyhow!(
            "consensus_filter and execution_filter must be identical to prevent consensus divergence"
        ));
    }
    Ok(())
}
```

## Proof of Concept

Due to the architectural nature of this vulnerability, a complete PoC requires a multi-validator testnet setup. However, the vulnerability can be demonstrated through the following test scenario:

```rust
#[tokio::test]
async fn test_execution_filter_consensus_divergence() {
    // Setup two validators with different execution filters
    let mut validator_a_config = create_test_config();
    validator_a_config.transaction_filters.execution_filter = 
        BlockTransactionFilterConfig::new(
            true,
            BlockTransactionFilter::with_sender_filter(vec![test_address_a])
        );
    
    let mut validator_b_config = create_test_config();
    validator_b_config.transaction_filters.execution_filter = 
        BlockTransactionFilterConfig::new(false, BlockTransactionFilter::empty());

    // Create a hybrid payload with filtered transaction in proof portion
    let hybrid_payload = create_hybrid_payload_with_proof_transaction(test_address_a);
    
    // Both validators validate and vote on the proposal (only inline checked)
    assert!(validator_a.validate_proposal(&hybrid_payload).is_ok());
    assert!(validator_b.validate_proposal(&hybrid_payload).is_ok());
    
    // Execute on both validators
    let state_root_a = validator_a.execute_block(&hybrid_payload).await.unwrap();
    let state_root_b = validator_b.execute_block(&hybrid_payload).await.unwrap();
    
    // Assert consensus divergence
    assert_ne!(state_root_a, state_root_b, "State roots should diverge due to different execution filters");
}
```

The test demonstrates that validators with different `execution_filter` configurations produce different state roots for the same committed block, violating consensus safety.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L14-15)
```rust
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/consensus_provider.rs (L69-69)
```rust
        node_config.transaction_filters.execution_filter.clone(),
```

**File:** consensus/src/round_manager.rs (L1204-1206)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L134-150)
```rust
        let all_transactions = {
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L483-495)
```rust
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                self.get_transactions_quorum_store_inline_hybrid(
                    block,
                    inline_batches,
                    proof_with_data,
                    max_txns_to_execute,
                    &None,
                )
                .await?
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L641-662)
```rust
async fn process_qs_payload(
    proof_with_data: &ProofWithData,
    batch_reader: Arc<dyn BatchReader>,
    block: &Block,
    ordered_authors: &[PeerId],
) -> ExecutorResult<Vec<SignedTransaction>> {
    QuorumStorePayloadManager::request_and_wait_transactions(
        proof_with_data
            .proofs
            .iter()
            .map(|proof| {
                (
                    proof.info().clone(),
                    proof.shuffled_signers(ordered_authors),
                )
            })
            .collect(),
        block.timestamp_usecs(),
        batch_reader,
    )
    .await
}
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/block_preparer.rs (L123-146)
```rust
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```
