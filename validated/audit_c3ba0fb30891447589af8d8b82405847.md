# Audit Report

## Title
Hot State LRU Chain Desynchronization Causing Validator Panic via set_commited() Bypass

## Summary
The `Committer::validate_lru()` function can panic when walking the hot state LRU chain if entries referenced by `next()`/`prev()` pointers don't exist in the shard DashMap. This occurs when `HotState::set_commited()` directly updates the committed State without synchronizing the Committer's shard, creating a desynchronization that violates the invariant that all LRU chain entries must exist in the shard.

## Finding Description

The `Committer` maintains two critical data structures for hot state management: the committed `State` (containing full LRU chain metadata) and `self.base.shards` (DashMap storing actual entries). [1](#0-0) 

The vulnerability occurs because `set_commited()` bypasses the normal commit flow by only updating the committed State without touching the shard DashMap. [2](#0-1) 

This function is called via `PersistedState::hack_reset()` during node initialization and restore operations. [3](#0-2) 

When `set_commited()` is invoked with a State containing hot entries, it updates `self.committed` but leaves `self.base.shards` unchanged. Subsequently, when `commit()` processes a new State, it calculates a delta containing only changed entries. [4](#0-3) 

The delta is computed using `view_layers_after()` which filters entries to only those with `cell.layer > base_layer`, meaning unchanged LRU chain entries are excluded. [5](#0-4) 

The `commit()` function iterates over the delta and inserts only changed entries into the shard, but then sets heads and tails to reference the full LRU chain from `to_commit`. [6](#0-5) 

The `validate_lru()` function attempts to walk the entire chain and panics with `.expect("Must exist.")` when it encounters a key in the LRU chain that doesn't exist in the shard. [7](#0-6) 

**Attack Scenario:**
1. System initialized with empty HotState
2. `hack_reset()` called with State containing hot entries A→B→C
   - `self.committed` now has entries {A, B, C} with proper LRU links
   - `self.base.shards` remains empty
3. New commit enqueued adding entry D as new head: D→A→B→C
   - Delta contains {D (new), A (prev pointer modified)} only
   - B and C unchanged, not in delta
4. `commit()` processes:
   - Inserts D and A into shard
   - Sets heads[shard_id] = D, tails[shard_id] = C
   - `validate_lru()` walks D→A→B
   - Attempts `shard.get(&B).expect("Must exist.")` → **PANIC**

## Impact Explanation

**Severity: HIGH**

This violates the critical invariant that all LRU chain entries must exist in the shard DashMap. The impact includes:

1. **Debug Builds**: Immediate validator node crash when `debug_assert!(self.validate_lru(shard_id).is_ok())` panics at line 269, causing validator unavailability. [8](#0-7) 

2. **Release Builds**: The debug_assert is compiled out, but the shard remains incomplete, leading to:
   - Incorrect hot state queries via `HotStateView`
   - Potential consensus divergence if different validators have different shard states
   - Unpredictable behavior when hot state is accessed

This meets **High Severity** criteria per Aptos Bug Bounty: "Validator node slowdowns" and crashes - a validator crash during state commit is a critical protocol violation affecting network liveness and availability.

## Likelihood Explanation

**Likelihood: MEDIUM**

While `hack_reset()` has a comment indicating restricted use ("Can only be used when no on the fly commit is in the queue"), it's called in production code paths:

1. **BufferedState initialization**: Called when creating a BufferedState at a snapshot during node startup. [9](#0-8) 

2. **Restore operations**: Called during database restore with KV replay. [10](#0-9) 

3. **State reset**: Called via `StateStore::set_state_ignoring_summary()`. [11](#0-10) 

The vulnerability requires:
1. Calling `set_commited()` with a non-empty State containing hot entries
2. Subsequent commit with partial LRU chain updates where some unchanged entries exist in the chain

While not trivially exploitable by external attackers, this can be inadvertently triggered during:
- Node restarts with existing hot state
- Database recovery operations
- State synchronization during restore

These are legitimate operational scenarios that could cause validator crashes and network disruption.

## Recommendation

The fix should ensure that `set_commited()` is only used with empty states, or that it properly synchronizes the Committer's shard when called with non-empty states. Possible solutions:

1. **Option 1 - Prevent non-empty states**: Add assertion in `set_commited()` to ensure it's only called with empty states:
```rust
pub(crate) fn set_commited(&self, state: State) {
    debug_assert!(state.shards().iter().all(|s| s.is_empty()), 
                  "set_commited must only be called with empty states");
    *self.committed.lock() = state
}
```

2. **Option 2 - Synchronize shards**: Modify `hack_reset()` to enqueue the state through the normal commit queue instead of bypassing it, ensuring proper shard synchronization:
```rust
pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
    let (state, summary) = state_with_summary.into_inner();
    *self.summary.lock() = summary;
    self.hot_state.enqueue_commit(state); // Use normal flow instead of set_commited
}
```

3. **Option 3 - Full population**: Populate the shard with all hot entries from the state in `set_commited()` before updating the committed state.

Option 2 is recommended as it maintains consistency with the normal commit flow while ensuring the Committer thread properly synchronizes all data structures.

## Proof of Concept

The vulnerability can be demonstrated with a Rust unit test that simulates the desynchronization scenario. The test would:

1. Create a `HotState` with empty state
2. Construct a non-empty `State` with hot entries forming an LRU chain
3. Call `set_commited()` directly to bypass normal commit flow
4. Enqueue a new commit that modifies only part of the LRU chain
5. Observe panic in debug builds when `validate_lru()` is called

While I cannot provide executable code without access to the full test harness, the vulnerability is demonstrable through code inspection of the commit flow and the delta calculation mechanism as documented in the citations above.

### Citations

**File:** storage/aptosdb/src/state_store/hot_state.rs (L127-129)
```rust
    pub(crate) fn set_commited(&self, state: State) {
        *self.committed.lock() = state
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L160-170)
```rust
pub struct Committer {
    base: Arc<HotStateBase>,
    committed: Arc<Mutex<State>>,
    rx: Receiver<State>,
    total_key_bytes: usize,
    total_value_bytes: usize,
    /// Points to the newest entry. `None` if empty.
    heads: [Option<StateKey>; NUM_STATE_SHARDS],
    /// Points to the oldest entry. `None` if empty.
    tails: [Option<StateKey>; NUM_STATE_SHARDS],
}
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L235-243)
```rust
    fn commit(&mut self, to_commit: &State) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["hot_state_commit"]);

        let mut n_insert = 0;
        let mut n_update = 0;
        let mut n_evict = 0;

        let delta = to_commit.make_delta(&self.committed.lock());
        for shard_id in 0..NUM_STATE_SHARDS {
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L244-263)
```rust
            for (key, slot) in delta.shards[shard_id].iter() {
                if slot.is_hot() {
                    let key_size = key.size();
                    self.total_key_bytes += key_size;
                    self.total_value_bytes += slot.size();
                    if let Some(old_slot) = self.base.shards[shard_id].insert(key, slot) {
                        self.total_key_bytes -= key_size;
                        self.total_value_bytes -= old_slot.size();
                        n_update += 1;
                    } else {
                        n_insert += 1;
                    }
                } else if let Some((key, old_slot)) = self.base.shards[shard_id].remove(&key) {
                    self.total_key_bytes -= key.size();
                    self.total_value_bytes -= old_slot.size();
                    n_evict += 1;
                }
            }
            self.heads[shard_id] = to_commit.latest_hot_key(shard_id);
            self.tails[shard_id] = to_commit.oldest_hot_key(shard_id);
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L269-269)
```rust
            debug_assert!(self.validate_lru(shard_id).is_ok());
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L277-311)
```rust
    /// Traverses the entire map and checks if all the pointers are correctly linked.
    fn validate_lru(&self, shard_id: usize) -> Result<()> {
        let head = &self.heads[shard_id];
        let tail = &self.tails[shard_id];
        ensure!(head.is_some() == tail.is_some());
        let shard = &self.base.shards[shard_id];

        {
            let mut num_visited = 0;
            let mut current = head.clone();
            while let Some(key) = current {
                let entry = shard.get(&key).expect("Must exist.");
                num_visited += 1;
                ensure!(num_visited <= shard.len());
                ensure!(entry.is_hot());
                current = entry.next().cloned();
            }
            ensure!(num_visited == shard.len());
        }

        {
            let mut num_visited = 0;
            let mut current = tail.clone();
            while let Some(key) = current {
                let entry = shard.get(&key).expect("Must exist.");
                num_visited += 1;
                ensure!(num_visited <= shard.len());
                ensure!(entry.is_hot());
                current = entry.prev().cloned();
            }
            ensure!(num_visited == shard.len());
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L65-69)
```rust
    pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
        let (state, summary) = state_with_summary.into_inner();
        *self.summary.lock() = summary;
        self.hot_state.set_commited(state);
    }
```

**File:** experimental/storage/layered-map/src/node.rs (L29-37)
```rust
    pub fn into_iter(self, base_layer: u64) -> impl Iterator<Item = (K, V)> {
        match self {
            LeafContent::UniqueLatest { key, value } => Either::Left(std::iter::once((key, value))),
            LeafContent::Collision(map) => {
                Either::Right(map.into_iter().filter_map(move |(key, cell)| {
                    (cell.layer > base_layer).then_some((key, cell.value))
                }))
            },
        }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L55-67)
```rust
    pub(crate) fn new_at_snapshot(
        state_db: &Arc<StateDb>,
        last_snapshot: StateWithSummary,
        target_items: usize,
        out_current_state: Arc<Mutex<LedgerStateWithSummary>>,
        out_persisted_state: PersistedState,
    ) -> Self {
        let (state_commit_sender, state_commit_receiver) =
            mpsc::sync_channel(ASYNC_COMMIT_CHANNEL_BUFFER_SIZE as usize);
        let arc_state_db = Arc::clone(state_db);
        *out_current_state.lock() =
            LedgerStateWithSummary::new_at_checkpoint(last_snapshot.clone());
        out_persisted_state.hack_reset(last_snapshot.clone());
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-276)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1208-1234)
```rust
    pub fn set_state_ignoring_summary(&self, ledger_state: LedgerState) {
        let hot_smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let last_checkpoint_summary = StateSummary::new_at_version(
            ledger_state.last_checkpoint().version(),
            hot_smt.clone(),
            smt.clone(),
            HotStateConfig::default(),
        );
        let summary = StateSummary::new_at_version(
            ledger_state.version(),
            hot_smt,
            smt,
            HotStateConfig::default(),
        );

        let last_checkpoint = StateWithSummary::new(
            ledger_state.last_checkpoint().clone(),
            last_checkpoint_summary.clone(),
        );
        let latest = StateWithSummary::new(ledger_state.latest().clone(), summary);
        let current = LedgerStateWithSummary::from_latest_and_last_checkpoint(
            latest,
            last_checkpoint.clone(),
        );

        self.persisted_state.hack_reset(last_checkpoint.clone());
```
