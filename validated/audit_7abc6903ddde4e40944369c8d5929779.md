# Audit Report

## Title
Incomplete Complexity Metering for Variant Instantiation Tables in VERSION_7+ Modules

## Summary
The Move binary format complexity checker fails to meter `struct_variant_instantiations` and `variant_field_instantiations` tables at the module level, allowing VERSION_7+ modules to bypass complexity limits by including arbitrarily large, unused variant instantiation tables with complex type signatures.

## Finding Description

The Move binary format VERSION_7 introduced variant-related features (enums), adding four new tables to `CompiledModule`, including `struct_variant_instantiations` and `variant_field_instantiations` fields. [1](#0-0) [2](#0-1) 

The complexity checker in `check_module_complexity()` explicitly meters standard instantiation tables (`struct_def_instantiations`, `field_instantiations`, and `function_instantiations`) but completely omits the variant versions. [3](#0-2) 

While helper functions `meter_struct_variant_instantiation()` and `meter_variant_field_instantiation()` exist in the codebase [4](#0-3) [5](#0-4) , they are **never called** from `check_module_complexity()`. These functions contain a `SignatureIndex` that points to potentially complex type parameter signatures. [6](#0-5) [7](#0-6) 

The individual metering functions are only invoked from `meter_code()` when specific variant bytecode instructions are encountered during function body analysis. [8](#0-7) 

**Attack Scenario:**
1. Attacker creates a VERSION_7+ module (VERSION_7 is supported; current VERSION_MAX is VERSION_10) [9](#0-8) 
2. Populates `struct_variant_instantiations` and `variant_field_instantiations` with hundreds of entries containing complex type signatures
3. Never references these instantiations in bytecode or struct definitions
4. The bounds checker validates all entries are well-formed [10](#0-9) [11](#0-10) 
5. Module publishing calls `check_module_complexity()` with budget `2048 + blob.code().len() * 20` [12](#0-11) 
6. But `check_module_complexity()` never meters the variant instantiation tables, allowing complexity budget bypass
7. Module consumes resources during deserialization, bounds checking, and VM operations without corresponding complexity charges

## Impact Explanation

This is a **Medium severity** vulnerability aligning with "Limited Protocol Violations" category (up to $10,000 per Aptos bug bounty):

**Resource Limits Violation:** The complexity checker exists to enforce computational limits on module complexity. This gap allows modules to exceed intended complexity budgets by including unmeasured variant instantiation tables containing arbitrarily complex type signatures.

**Limited but Real Impact:**
- Unused instantiation tables consume CPU cycles during module deserialization and bounds checking
- They occupy storage in the module binary and blockchain state  
- The blob size-based budget (20 units per byte) provides partial protection, but complex type signatures in compact encodings can have a much higher processing cost per byte than this ratio accounts for
- This violates the fundamental resource limits invariant that all operations must respect computational limits

**Not Critical because:**
- All validators process modules identically (no consensus split or safety violation)
- The blob size budget provides some proportional scaling
- Bounds checking prevents malformed entries that could cause crashes
- Attack requires module publishing permissions and associated gas costs

## Likelihood Explanation

**Likelihood: Medium to High**

**Ease of Exploitation:**
- Any user with module publishing access can create such modules through standard transaction submission
- No special permissions, validator collusion, or infrastructure access required
- The bug is straightforward to exploit once discovered - simply populate the unused tables with complex instantiations
- VERSION_7+ modules are widely supported in production (current VERSION_MAX is VERSION_10)
- The gap is a simple omission in the metering logic, not a complex timing or race condition

**Mitigating Factors:**
- Requires understanding of Move binary format internals to craft effective exploits
- Module publishing has inherent gas costs that provide economic disincentive for spam
- The blob size-based budget component provides partial protection by scaling with module size
- Bounds checking prevents truly malicious or malformed entries

## Recommendation

Add loop functions to meter all variant instantiation tables at the module level, similar to existing `meter_struct_def_instantiations()` and `meter_field_instantiations()` functions:

1. Implement `meter_struct_variant_instantiations()` to iterate through all `struct_variant_instantiations` entries
2. Implement `meter_variant_field_instantiations()` to iterate through all `variant_field_instantiations` entries  
3. Call these functions from `check_module_complexity()` after line 411, alongside the other instantiation metering calls

This ensures consistency with how other instantiation tables are metered and closes the resource limits bypass.

## Proof of Concept

A complete PoC would require crafting a CompiledModule binary with populated variant instantiation tables that are never referenced in bytecode. The vulnerability can be verified by:

1. Creating a VERSION_7+ module with generic enum types
2. Manually adding unused `StructVariantInstantiation` and `VariantFieldInstantiation` entries with complex type parameters to the binary
3. Observing that `check_module_complexity()` returns without charging for these entries
4. Comparing with similar unused `StructDefInstantiation` or `FieldInstantiation` entries which would be metered

The code examination clearly demonstrates the omission in the complexity checking logic.

## Notes

This vulnerability represents a design inconsistency where VERSION_7 features were added to the binary format without corresponding updates to all verification systems. The complexity checker meters all other instantiation types but omits variant instantiations, creating an asymmetry that can be exploited to bypass resource limits. While the blob size budget provides partial protection, the fundamental issue is that the complexity checker's design invariant—that all module components must be metered—is violated for these specific tables.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L543-546)
```rust
/// Version 7: changes compare to version 6
/// + access specifiers (read/write set)
/// + enum types
pub const VERSION_7: u32 = 7;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L565-565)
```rust
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L541-544)
```rust
pub struct StructVariantInstantiation {
    pub handle: StructVariantHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L585-588)
```rust
pub struct VariantFieldInstantiation {
    pub handle: VariantFieldHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3474-3478)
```rust
    /// Since bytecode version 7: variant related handle tables
    pub struct_variant_handles: Vec<StructVariantHandle>,
    pub struct_variant_instantiations: Vec<StructVariantInstantiation>,
    pub variant_field_handles: Vec<VariantFieldHandle>,
    pub variant_field_instantiations: Vec<VariantFieldInstantiation>,
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L139-153)
```rust
    fn meter_struct_variant_instantiation(
        &self,
        struct_inst_idx: StructVariantInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_variant_insts =
            self.resolver
                .struct_variant_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get enum type instantiation -- not a module.".to_string(),
                    )
                })?;
        let struct_variant_inst = safe_get_table(struct_variant_insts, struct_inst_idx.0)?;
        self.meter_signature(struct_variant_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L180-195)
```rust
    fn meter_variant_field_instantiation(
        &self,
        variant_field_inst_idx: VariantFieldInstantiationIndex,
    ) -> PartialVMResult<()> {
        let variant_field_insts =
            self.resolver
                .variant_field_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get variant field instantiations -- not a module.".to_string(),
                    )
                })?;
        let field_inst = safe_get_table(variant_field_insts, variant_field_inst_idx.0)?;

        self.meter_signature(field_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L272-287)
```rust
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L107-114)
```rust
        self.check_table(
            self.view.variant_field_instantiations(),
            Self::check_variant_field_instantiation,
        )?;
        self.check_table(
            self.view.struct_variant_instantiations(),
            Self::check_struct_variant_instantiation,
        )?;
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L346-360)
```rust
    fn check_variant_field_instantiation(
        &self,
        inst: &VariantFieldInstantiation,
    ) -> PartialVMResult<()> {
        check_bounds_impl_opt(&self.view.variant_field_handles(), inst.handle)?;
        check_bounds_impl(self.view.signatures(), inst.type_parameters)
    }

    fn check_struct_variant_instantiation(
        &self,
        inst: &StructVariantInstantiation,
    ) -> PartialVMResult<()> {
        check_bounds_impl_opt(&self.view.struct_variant_handles(), inst.handle)?;
        check_bounds_impl(self.view.signatures(), inst.type_parameters)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1555-1558)
```rust
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```
