# Audit Report

## Title
Byzantine Validator OptQS Denial-of-Service via Window Manipulation

## Summary
Byzantine validators can systematically disable Optimistic Quorum Store (OptQS) by proposing blocks with unavailable payload batches, causing the failure window to grow exponentially and preventing OptQS from re-enabling, thereby permanently degrading network throughput.

## Finding Description

The `ExponentialWindowFailureTracker` in the consensus layer tracks proposal failures to determine when to enable OptQS. Byzantine validators can exploit this mechanism to keep OptQS permanently disabled through the following attack path:

**Step 1: Window Doubling on Failure**

When a `PayloadUnavailable` timeout occurs, the failure tracker doubles the window size. The `last_consecutive_success_count` is reset to 0 on any `PayloadUnavailable` failure: [1](#0-0) 

The window doubles until reaching `max_window` (typically 100).

**Step 2: OptQS Enabling Condition**

OptQS is only enabled when consecutive successes meet or exceed the window size: [2](#0-1) 

Once the window reaches 100, the system requires 100 consecutive successful proposals without any `PayloadUnavailable` failures to re-enable OptQS.

**Step 3: Byzantine Validator Creates Unavailable Batches**

When a Byzantine validator becomes proposer, they create an `OptQuorumStorePayload` with opt_batches that exist locally but were never broadcast to the network. The validation only checks that batch authors are valid validators, not that batches are available: [3](#0-2) 

This validation does NOT verify signatures on opt_batches or check batch availability on the network.

**Step 4: Payload Availability Check Fails**

When honest validators receive the proposal, they check if opt_batches exist locally: [4](#0-3) 

Missing batches cause the check to return an error with a BitVec of missing authors.

**Step 5: PayloadUnavailable Timeout Triggered**

This missing payload triggers a `PayloadUnavailable` timeout reason: [5](#0-4) 

The `missing_authors` BitVec is included in the timeout reason, which is then used during timeout processing: [6](#0-5) 

**Step 6: Attack Persistence**

Byzantine validators (even with <1/3 stake) become proposers proportionally to their stake. They can periodically trigger `PayloadUnavailable` failures (e.g., once every 99 rounds) to prevent the system from ever accumulating 100 consecutive successes, keeping OptQS disabled indefinitely.

The `exclude_authors` mechanism only prevents pulling batches from specific authors: [7](#0-6) 

This doesn't prevent the window growth or the need for 100 consecutive successes.

## Impact Explanation

This constitutes a **High Severity** vulnerability per the Aptos bug bounty criteria under "Validator node slowdowns":

1. **Persistent Performance Degradation**: OptQS is a critical throughput optimization. The substantial infrastructure dedicated to OptQS (including ExponentialWindowFailureTracker, OptQSPullParamsProvider, and related configuration) indicates its importance to network performance.

2. **Network-Wide Impact**: Once OptQS is disabled, ALL validators and users experience reduced transaction throughput until manual intervention occurs.

3. **Indefinite Duration**: Unlike temporary network issues, this attack can persist indefinitely as long as Byzantine validators periodically trigger failures.

4. **Protocol-Level DoS**: This represents a deliberate manipulation of the consensus protocol's optimization mechanism through resource exhaustion, not a network-layer DDoS attack. This falls under "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion" per the bounty framework.

While the network continues to function using standard quorum store payloads, the persistent throughput degradation constitutes a significant liveness attack that impacts the entire network's utility.

## Likelihood Explanation

**High likelihood** of exploitation:

1. **Natural Proposer Selection**: Byzantine validators with any stake percentage will become proposers proportionally (e.g., 10% stake = proposer ~10% of rounds). No special conditions or timing required.

2. **Low Attack Cost**: Once the window reaches maximum size (100), maintaining the attack requires only periodic failures (approximately one failure per 100 rounds to prevent 100 consecutive successes).

3. **Stealth**: The attack appears as network issues or legitimate payload unavailability rather than obvious malicious behavior, making detection difficult.

4. **No Effective Mitigation**: The reputation system only penalizes validators whose failure rate exceeds a threshold (default 10%): [8](#0-7) 

Byzantine validators can stay below this threshold (e.g., 1% failure rate with one failure per 100 rounds) while still maintaining the attack, as even a single `PayloadUnavailable` failure resets the consecutive success count to zero.

5. **Coordination Potential**: Multiple Byzantine validators can coordinate to cycle through the attack, further sustaining the degradation.

## Recommendation

Implement one or more of the following mitigations:

1. **Cap the Maximum Window Size**: Reduce the `max_window` from 100 to a more reasonable value (e.g., 10-20) to limit the number of consecutive successes required for OptQS re-enabling.

2. **Decay the Window Over Time**: Instead of requiring consecutive successes equal to the window size, implement a decay mechanism that gradually reduces the window size over time even without consecutive successes.

3. **Author-Specific Tracking**: Track failure rates per author and permanently exclude authors with sustained low-frequency failures from OptQS participation, even if below the 10% threshold.

4. **Signature Verification**: Add cryptographic verification of opt_batches during proposal validation to ensure batches were actually created and broadcast by the claimed authors.

5. **Adaptive Thresholds**: Dynamically adjust the consecutive success requirement based on network conditions and detected Byzantine behavior patterns.

## Proof of Concept

```rust
// This is a conceptual PoC demonstrating the attack flow
// In practice, this would be implemented in the consensus test suite

#[test]
fn test_byzantine_optqs_dos() {
    // Setup: Create validator set with one Byzantine validator (10% stake)
    let (signers, verifier) = random_validator_verifier(10, None, false);
    let byzantine_index = 0; // First validator is Byzantine
    
    // Initialize failure tracker with max_window = 100
    let mut tracker = ExponentialWindowFailureTracker::new(
        100, 
        verifier.get_ordered_account_addresses()
    );
    
    // Step 1: Byzantine validator triggers PayloadUnavailable failures
    // to grow window to maximum
    for _ in 0..10 {
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable {
                missing_authors: BitVec::with_num_bits(10)
            }
        ));
    }
    assert_eq!(tracker.window, 100); // Window is now at maximum
    
    // Step 2: Honest validators propose successfully 99 times
    for _ in 0..99 {
        tracker.push(NewRoundReason::QCReady);
    }
    assert_eq!(tracker.last_consecutive_success_count, 99);
    
    // Step 3: Byzantine validator (becomes proposer ~10% of time)
    // triggers one PayloadUnavailable failure
    tracker.push(NewRoundReason::Timeout(
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: BitVec::with_num_bits(10)
        }
    ));
    
    // Step 4: Consecutive success count resets to 0
    assert_eq!(tracker.last_consecutive_success_count, 0);
    // Window remains at maximum
    assert_eq!(tracker.window, 100);
    
    // Step 5: OptQS remains disabled because consecutive successes < window
    let provider = OptQSPullParamsProvider::new(
        true,
        1000,
        Arc::new(Mutex::new(tracker))
    );
    assert!(provider.get_params().is_none()); // OptQS is disabled
    
    // Attack can repeat indefinitely with just ~1% failure rate
}
```

## Notes

This vulnerability exploits a design flaw in the failure tracking mechanism where the system assumes that `PayloadUnavailable` failures are transient network issues rather than deliberate Byzantine attacks. The exponential window growth combined with the consecutive success requirement creates a situation where Byzantine validators can keep OptQS permanently disabled with minimal attack frequency (below the reputation penalty threshold).

The attack is particularly insidious because:
- It requires no majority stake control (<1/3 Byzantine is sufficient)
- It operates below detection thresholds (1% vs 10% reputation penalty)
- It degrades performance network-wide without causing a complete halt
- It appears as legitimate network congestion rather than malicious behavior

This represents a protocol-level denial-of-service through consensus mechanism manipulation, distinct from network-layer DDoS attacks.

### Citations

**File:** consensus/src/liveness/proposal_status_tracker.rs (L66-78)
```rust
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L128-143)
```rust
    fn get_params(&self) -> Option<OptQSPayloadPullParams> {
        if !self.enable_opt_qs {
            return None;
        }

        let tracker = self.failure_tracker.lock();

        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT
            .observe(tracker.last_consecutive_success_count as f64);
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }
```

**File:** consensus/consensus-types/src/common.rs (L558-570)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/round_manager.rs (L968-983)
```rust
    fn compute_timeout_reason(&self, round: Round) -> RoundTimeoutReason {
        if self.round_state().vote_sent().is_some() {
            return RoundTimeoutReason::NoQC;
        }

        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
    }
```

**File:** consensus/src/round_manager.rs (L1023-1030)
```rust
                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
```

**File:** consensus/src/liveness/leader_reputation.rs (L541-549)
```rust
                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
```
