# Audit Report

## Title
Byzantine Validators Can Cause Unbounded Memory Growth in JWK Consensus via Malicious RPC Requests

## Summary
Byzantine validators can exploit a logic flaw in the JWK consensus subsystem's `KeyLevelConsensusManager` to cause unbounded memory growth by sending arbitrary `KeyLevelObservationRequest` RPC messages with fake (issuer, kid) pairs, leading to memory exhaustion and potential validator node crashes within an epoch.

## Finding Description

The `KeyLevelConsensusManager` maintains a HashMap mapping `(Issuer, KID)` tuples to `ConsensusState` instances for tracking consensus on individual JWK updates. [1](#0-0) 

When processing incoming `KeyLevelObservationRequest` RPC messages, the code unconditionally creates new HashMap entries via `.entry().or_default()` without validating whether the (issuer, kid) pair corresponds to a legitimate OIDC provider or key. [2](#0-1) 

The `Issuer` and `KID` types are simple `Vec<u8>` aliases with no inherent size constraints, allowing arbitrarily large or numerous values. [3](#0-2) 

Each unique (issuer, kid) pair creates a `ConsensusState::NotStarted` entry (the default variant) that persists in memory. [4](#0-3) 

The vulnerability is compounded by a critical logic flaw in the cleanup mechanism `reset_with_on_chain_state()`. The retention logic compares on-chain versions, but for malicious entries with arbitrary issuers not present in on-chain state, both `new_onchain_jwks.get(issuer)` and `self.onchain_jwks.get(issuer)` return `None`, which default to version 0 via `.unwrap_or_default()`. Since 0 == 0, these malicious entries are incorrectly retained throughout the epoch. [5](#0-4) 

The `EpochManager` validates only that the RPC message epoch matches the current epoch, but does not validate the legitimacy of the (issuer, kid) pairs contained in the request. [6](#0-5) 

**Attack Flow:**
1. Byzantine validator crafts `KeyLevelObservationRequest` messages with arbitrary unique (issuer, kid) pairs
2. Messages pass through network layer with only queue size limits (10 at network layer, 100 at epoch manager), but these limits do not prevent unique pair accumulation over time [7](#0-6) [8](#0-7) 
3. `process_peer_request()` creates `NotStarted` entries for each unique pair
4. Malicious entries persist until epoch boundary due to cleanup logic flaw
5. Repeated attacks across an epoch cause unbounded HashMap growth leading to memory exhaustion

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** per Aptos bug bounty criteria, specifically "Validator Node Slowdowns" through resource exhaustion affecting consensus participation.

**Impact Assessment:**
- **Resource Exhaustion**: Unbounded memory growth degrades validator performance and can cause node crashes, directly impacting consensus participation and network liveness
- **Consensus Disruption**: Memory exhaustion forcing validator restarts reduces available validator stake, potentially approaching liveness thresholds
- **Temporal Scope**: While entries clear at epoch boundaries, epochs last hours to days in production, providing extended attack windows
- **Sustained Attacks**: Attackers can repeat across epochs, causing persistent degradation

The impact is not Critical because:
- Does not directly cause consensus safety violations (no state root divergence)
- Does not enable fund theft or unauthorized minting
- Network recovers at epoch boundaries without requiring hardforks
- Requires Byzantine validator capability (< 1/3 of validator set)

However, memory exhaustion can force validator restarts and significantly degrade network performance, qualifying this as HIGH severity validator node resource exhaustion.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivial to execute within the Aptos Byzantine fault tolerance threat model:
- Byzantine validators (< 1/3) are explicitly assumed in Aptos's BFT consensus model and have native RPC capabilities
- No validation checks legitimacy of (issuer, kid) pairs in RPC request contents
- Automatic entry creation via `.entry().or_default()` requires no preconditions
- No effective rate limiting beyond channel queue sizes, which only throttle rate but not total accumulation
- Single Byzantine validator can continuously send unique pairs with minimal computational cost
- Attack requires no on-chain gas costs or stake requirements beyond existing validator status

The Aptos security model explicitly designs for < 1/3 Byzantine validators, making this a realistic and expected attack scenario that the protocol should defend against.

## Recommendation

Implement validation of (issuer, kid) pairs against `SupportedOIDCProviders` before creating HashMap entries:

```rust
pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest {
        msg,
        mut response_sender,
        ..
    } = rpc_req;
    match msg {
        JWKConsensusMsg::KeyLevelObservationRequest(request) => {
            let ObservedKeyLevelUpdateRequest { issuer, kid, .. } = request;
            
            // Validate issuer is in supported providers
            if !self.onchain_jwks.contains_key(&issuer) {
                debug!("Rejecting request for unsupported issuer");
                return Ok(());
            }
            
            let consensus_state = self
                .states_by_key
                .entry((issuer.clone(), kid.clone()))
                .or_default();
            // ... rest of existing logic
        },
        _ => bail!("unexpected rpc: {}", msg.name()),
    }
}
```

Additionally, fix the cleanup logic to properly remove entries for non-existent issuers:

```rust
self.states_by_key.retain(|(issuer, _), _| {
    // Only retain if issuer exists in new on-chain state AND version unchanged
    new_onchain_jwks.get(issuer).is_some()
        && new_onchain_jwks.get(issuer).map(|jwks| jwks.version)
            == self.onchain_jwks.get(issuer).map(|jwks| jwks.version)
});
```

## Proof of Concept

A Byzantine validator can exploit this by sending RPC messages:

```rust
// Simulated attack - Byzantine validator sends malicious RPC
for i in 0..10000 {
    let malicious_issuer = format!("fake-issuer-{}", i).into_bytes();
    let malicious_kid = format!("fake-kid-{}", i).into_bytes();
    
    let request = JWKConsensusMsg::KeyLevelObservationRequest(
        ObservedKeyLevelUpdateRequest {
            epoch: current_epoch,
            issuer: malicious_issuer,
            kid: malicious_kid,
        }
    );
    
    // Send to victim validators
    network_client.send_rpc(victim_validator, request, timeout).await;
}

// Result: Victim validator's states_by_key HashMap grows unbounded
// Each unique (issuer, kid) creates a NotStarted entry that persists until epoch end
// reset_with_on_chain_state() fails to clean up due to 0 == 0 comparison
```

The attack succeeds because:
1. No validation checks if issuer is in `SupportedOIDCProviders`
2. `.entry().or_default()` unconditionally creates entries
3. Cleanup logic retains entries for non-existent issuers (0 == 0)
4. Memory consumption grows unbounded within the epoch

## Notes

This vulnerability represents a protocol-level resource management flaw distinct from network-layer DoS attacks. The issue stems from incorrect validation and cleanup logic in the consensus protocol itself, not network flooding. Byzantine validators operating within Aptos's < 1/3 Byzantine tolerance model can exploit this to degrade network performance and availability through validator node resource exhaustion.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L272-277)
```rust
            JWKConsensusMsg::KeyLevelObservationRequest(request) => {
                let ObservedKeyLevelUpdateRequest { issuer, kid, .. } = request;
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L167-170)
```rust
impl<T: Debug + Clone + Eq + PartialEq> Default for ConsensusState<T> {
    fn default() -> Self {
        Self::NotStarted
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L94-105)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        rpc_request: IncomingRpcRequest,
    ) -> Result<()> {
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L222-222)
```rust
            let (jwk_rpc_msg_tx, jwk_rpc_msg_rx) = aptos_channel::new(QueueStyle::FIFO, 100, None);
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-169)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
```
