# Audit Report

## Title
Resource Group Cache Memory Exhaustion Before Gas Charging Enables Validator Node OOM

## Summary
The `load_to_cache()` function in `ResourceGroupAdapter` deserializes entire resource groups into memory before gas is charged for the read operation. An attacker can create resource groups with many large members, and when transactions access these groups, the full deserialization occurs before gas limits are enforced, enabling memory exhaustion attacks against validator nodes.

## Finding Description

The vulnerability exists in the resource group loading mechanism where **deserialization precedes gas charging**, violating the Move VM safety invariant that bytecode execution must respect gas limits and memory constraints.

**Technical Flow:**

When a transaction accesses a resource group member, the execution follows this path:

1. The Move VM interpreter calls `load_resource_mut()` which invokes the data cache [1](#0-0) 

2. This triggers `create_data_cache_entry()` which calls the resource resolver [2](#0-1) 

3. For resource groups, `StorageAdapter::get_any_resource_with_layout()` is invoked [3](#0-2) 

4. This calls `ResourceGroupAdapter::load_to_cache()` which **deserializes the entire BTreeMap** [4](#0-3) 

5. **Only after deserialization completes** does the interpreter charge gas [5](#0-4) 

**Parallel Execution Amplification:**

Each parallel transaction gets its own resolver instance via `as_move_resolver_with_group_view()` [6](#0-5) 

Since each `StorageAdapter` contains its own `ResourceGroupAdapter` with independent cache [7](#0-6) , multiple parallel transactions accessing the same resource group will each independently deserialize it into memory simultaneously.

**No Size Limits on Reads:**

The codebase has write limits for resource group creation [8](#0-7)  but no corresponding limits prevent reading arbitrarily large resource groups. The memory tracker only checks limits **after** deserialization [9](#0-8) 

## Impact Explanation

**High Severity** per Aptos Bug Bounty Program - "Validator node slowdowns/API crashes"

This vulnerability enables:

1. **Validator Process Crashes**: Multiple parallel transactions deserializing large resource groups before gas limits trigger causes cumulative memory consumption exceeding available RAM, resulting in OOM kills of validator processes.

2. **Consensus Availability Impact**: When validators crash, network consensus participation degrades. If multiple validators are affected, this can cause transaction processing delays or liveness issues.

3. **Persistent Attack Vector**: Once large resource groups exist on-chain (after paying one-time storage fees), any subsequent transaction reading them triggers the vulnerability. The attack can be repeated indefinitely without additional cost.

4. **Pre-Gas-Accounting Failure**: Unlike normal gas exhaustion which cleanly aborts transactions, memory allocation during BCS deserialization occurs before gas accounting, providing no protective abort mechanism.

## Likelihood Explanation

**High Likelihood**:

1. **Low Complexity**: Attacker creates resource groups using standard `#[resource_group_member]` attributes, adds large members over multiple transactions (subject to write limits per transaction), then waits for or triggers reads.

2. **Economic Viability**: While storage fees apply during creation, write limits can be bypassed by incremental additions across transactions. Once created, perpetual exploitation with no additional cost.

3. **No Privileges Required**: Any account can create resource groups and deploy Move modules using them.

4. **Parallel Execution Multiplier**: Block executor's parallel execution (configurable thread count) multiplies memory impact as each thread maintains independent caches.

## Recommendation

Implement size checks **before** deserialization:

1. Add `MAX_RESOURCE_GROUP_SIZE` configuration parameter
2. Check blob size in `load_to_cache()` before calling `bcs::from_bytes()`
3. Charge estimated gas based on blob size before deserialization
4. Consider global memory limits across all parallel transactions
5. Add rate limiting for resource group reads per block

Example fix in `resource_group_adapter.rs`:
```rust
fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
    // ... existing checks ...
    
    let group_data_blob = self.resource_view.get_resource_bytes(group_key, None)?;
    if let Some(blob) = &group_data_blob {
        // Check size BEFORE deserialization
        if blob.len() > MAX_RESOURCE_GROUP_SIZE {
            return Err(PartialVMError::new(StatusCode::RESOURCE_GROUP_TOO_LARGE));
        }
    }
    
    // Now safe to deserialize
    // ... rest of function
}
```

## Proof of Concept

A complete PoC would require:
1. Move module creating resource group with `#[resource_group_member]` attribute
2. Transactions adding large members incrementally (respecting per-transaction write limits)
3. Parallel transactions reading the large resource group
4. Monitoring validator memory consumption during execution

The vulnerability is confirmed by code analysis showing deserialization precedes gas charging, independent per-transaction caches in parallel execution, and absence of pre-deserialization size checks.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1318-1332)
```rust
        let (gv, bytes_loaded) =
            data_cache.load_resource_mut(gas_meter, traversal_context, &addr, ty)?;
        if let Some(bytes_loaded) = bytes_loaded {
            gas_meter.charge_load_resource(
                addr,
                TypeWithRuntimeEnvironment {
                    ty,
                    runtime_environment: self.loader.runtime_environment(),
                },
                gv.view(),
                bytes_loaded,
            )?;
        }

        Ok(gv)
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L289-295)
```rust
            resource_resolver.get_resource_bytes_with_metadata_and_layout(
                addr,
                &struct_tag,
                &module.metadata,
                layout_with_delayed_fields.layout_when_contains_delayed_fields(),
            )?
        };
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L67-71)
```rust
pub struct StorageAdapter<'e, E> {
    executor_view: &'e E,
    resource_group_view: ResourceGroupAdapter<'e>,
    accessed_groups: RefCell<HashSet<StateKey>>,
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L106-120)
```rust
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L164-197)
```rust
    fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
        let already_cached = self.group_cache.borrow().contains_key(group_key);
        if already_cached {
            return Ok(true);
        }

        let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
        let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
            || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
            |group_data_blob| {
                let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                    PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                        format!(
                            "Failed to deserialize the resource group at {:? }: {:?}",
                            group_key, e
                        ),
                    )
                })?;
                Ok((group_data, group_data_blob.len() as u64))
            },
        )?;

        let group_size = match self.group_size_kind {
            GroupSizeKind::None => ResourceGroupSize::Concrete(0),
            GroupSizeKind::AsBlob => ResourceGroupSize::Concrete(blob_len),
            GroupSizeKind::AsSum => {
                group_size_as_sum(group_data.iter().map(|(t, v)| (t, v.len())))?
            },
        };
        self.group_cache
            .borrow_mut()
            .insert(group_key.clone(), (group_data, group_size));
        Ok(false)
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L63-63)
```rust
        let resolver = self.vm.as_move_resolver_with_group_view(view);
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L10-17)
```rust
pub struct ChangeSetConfigs {
    gas_feature_version: u64,
    max_bytes_per_write_op: u64,
    max_bytes_all_write_ops_per_transaction: u64,
    max_bytes_per_event: u64,
    max_bytes_all_events_per_transaction: u64,
    max_write_ops_per_transaction: u64,
}
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L378-398)
```rust
    fn charge_load_resource(
        &mut self,
        addr: AccountAddress,
        ty: impl TypeView,
        val: Option<impl ValueView>,
        bytes_loaded: NumBytes,
    ) -> PartialVMResult<()> {
        if self.feature_version() != 0 {
            // TODO(Gas): Rewrite this in a better way.
            if let Some(val) = &val {
                self.use_heap_memory(
                    self.vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?,
                )?;
            }
        }

        self.base.charge_load_resource(addr, ty, val, bytes_loaded)
    }
```
