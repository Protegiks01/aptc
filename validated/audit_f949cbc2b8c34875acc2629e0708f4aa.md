# Audit Report

## Title
Memory Reallocation Vulnerability in jemalloc Stats Collection Can Crash Validator Node

## Summary
A buffer capacity calculation error in the jemalloc statistics collection callback allows vector reallocation despite explicit design intent to avoid allocations. If the reallocation fails under memory pressure, it triggers a process-wide panic that crashes the entire validator node during operation.

## Finding Description
The `write_cb` callback function contains a critical bug in its capacity calculation. When jemalloc's `malloc_stats_print` calls this callback multiple times to output statistics incrementally, the code incorrectly calculates the remaining buffer capacity. [1](#0-0) 

The bug on line 18 computes `std::cmp::min(out.capacity(), stats_cstr.len())` which checks against the **total capacity** of the Vec, not the **remaining capacity**. The correct calculation should be `std::cmp::min(out.capacity() - out.len(), stats_cstr.len())`.

**Attack Scenario:**
1. Vec is created with 2MB capacity (default `malloc_stats_max_len`) [2](#0-1) 
2. First callback: Adds 1.5MB of stats data (Vec.len = 1.5MB, remaining = 0.5MB)
3. Second callback: Attempts to add another 1MB chunk
   - Code calculates: `min(2MB, 1MB) = 1MB`
   - Tries to extend Vec by 1MB, but only 0.5MB remaining
   - `extend_from_slice` triggers reallocation to ~2.5MB
4. If reallocation fails (OOM in containerized environment or under memory pressure), Rust panics
5. Global panic handler catches panic and calls `process::exit(12)` [3](#0-2) 
6. Entire validator process terminates, killing consensus, mempool, state sync, and all other services

The admin service starts before consensus and runs in the same process [4](#0-3) [5](#0-4) , and when an operator queries `/malloc/stats` [6](#0-5)  (typically during memory debugging), the callback violation occurs while consensus is actively running.

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program ("Validator node slowdowns" / "API crashes"). When triggered, it causes immediate validator termination via `process::exit(12)`, resulting in:

- **Loss of liveness**: Validator stops participating in consensus
- **Network impact**: Reduces validator set size, moving closer to Byzantine threshold  
- **Timing criticality**: Most likely to occur when debugging memory issues (i.e., when node is already stressed)

The vulnerability breaks resource management guarantees by allowing unbounded reallocation attempts in a callback explicitly designed to avoid allocations [7](#0-6) .

## Likelihood Explanation
**Medium-to-Low Likelihood** due to multiple prerequisites:

1. **Admin service must be enabled**: Disabled by default on mainnet, enabled on testnet [8](#0-7) 

2. **Authentication required on mainnet**: Reduces attack surface but doesn't eliminate operator error [9](#0-8) 

3. **Memory pressure needed**: Allocation must fail for crash to occur
   - More likely in containerized environments with memory limits (common for validators)
   - Precisely when operators would query malloc stats for debugging
   - Creates a dangerous feedback loop: memory issues → query stats → trigger reallocation → crash

4. **Large jemalloc output**: Stats must exceed initial capacity to trigger multiple callbacks
   - With default 2MB buffer, achievable with detailed heap profiling enabled

## Recommendation
Fix the capacity calculation to account for already-used buffer space:

```rust
let len = std::cmp::min(out.capacity() - out.len(), stats_cstr.len());
```

This ensures the callback never attempts to extend beyond the Vec's current capacity, honoring the design intent stated in the comment.

## Proof of Concept
The vulnerability can be demonstrated by enabling the admin service on a validator node under memory pressure, enabling jemalloc profiling to generate large stats output (>2MB), and querying the `/malloc/stats` endpoint. When the stats output exceeds the initial 2MB buffer capacity across multiple callback invocations, and memory allocation fails, the process will terminate with exit code 12.

A minimal reproduction would involve:
1. Configure a validator with admin service enabled and jemalloc profiling active
2. Run the validator in a memory-constrained container
3. Generate memory pressure to approach OOM conditions
4. Query `GET /malloc/stats` endpoint
5. Observe process termination via `process::exit(12)` when reallocation fails

### Citations

**File:** crates/aptos-admin-service/src/server/malloc.rs (L14-20)
```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let len = std::cmp::min(out.capacity(), stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

**File:** config/src/config/admin_service_config.rs (L48-48)
```rust
            malloc_stats_max_len: 2 * 1024 * 1024,
```

**File:** config/src/config/admin_service_config.rs (L67-76)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** aptos-node/src/lib.rs (L700-701)
```rust
    // Starts the admin service
    let mut admin_service = services::start_admin_service(&node_config);
```

**File:** aptos-node/src/lib.rs (L841-850)
```rust
    let consensus_runtime = consensus::create_consensus_runtime(
        &node_config,
        db_rw.clone(),
        consensus_reconfig_subscription,
        consensus_network_interfaces,
        consensus_notifier.clone(),
        consensus_to_mempool_sender.clone(),
        vtxn_pool,
        consensus_publisher.clone(),
        &mut admin_service,
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L189-191)
```rust
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
```
