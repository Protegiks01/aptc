# Audit Report

## Title
Subscription Request Validation Bypass Allows Rate Limiting Evasion and State Probing

## Summary
Subscription requests in the storage service completely bypass the RequestModerator's validation and invalid request tracking mechanism, allowing attackers to repeatedly send malformed subscription requests to probe internal subscription state without triggering the TooManyInvalidRequests protection designed to limit abusive peers.

## Finding Description

The storage service implements a RequestModerator to track peers sending invalid requests and temporarily ignore peers that exceed configurable thresholds. However, subscription requests follow a completely separate code path that bypasses this protection mechanism.

When subscription requests are received in `process_request_and_respond`, they are identified and routed directly to `handle_subscription_request`, completely skipping the normal validation flow: [1](#0-0) 

In contrast, regular (non-subscription, non-optimistic-fetch) requests go through `process_request`, which calls `validate_and_handle_request`: [2](#0-1) 

The `validate_and_handle_request` method explicitly calls the RequestModerator's validation before processing any request: [3](#0-2) 

The RequestModerator's `validate_request` method checks if a peer should be ignored and increments the invalid request counter when requests cannot be serviced: [4](#0-3) 

When subscription requests fail validation in `add_subscription_request` (due to invalid metadata, indices too low, or exceeding max active subscriptions), they return errors: [5](#0-4) 

These errors are handled by `handle_subscription_request_failure`, which only logs the error, updates metrics, and notifies the client—crucially, it never calls the RequestModerator to increment any invalid request counter: [6](#0-5) 

The RequestModerator specifically tracks unhealthy peer states and marks public network peers for temporary ignoring after they exceed `max_invalid_requests_per_peer`: [7](#0-6) 

**Attack Path:**
1. Attacker (as any network peer) establishes a subscription stream with a valid initial request
2. Attacker sends subscription requests with systematically varied indices (0, 1, 2, 3, etc.)
3. By observing which indices return "index too low" errors, attacker learns the internal `next_index_to_serve` value
4. By observing which indices return "overwriting existing subscription" errors, attacker can map pending subscription requests
5. This can be repeated indefinitely without ever triggering the TooManyInvalidRequests error
6. For public network peers, this completely circumvents the protection mechanism designed to limit abusive behavior

## Impact Explanation

This vulnerability represents a **Medium severity** issue per Aptos bug bounty criteria under "State inconsistencies requiring intervention," because:

1. **Rate Limiting Control Bypass**: The RequestModerator exists as a security control to protect against peers sending excessive invalid requests. Subscription requests completely evade this control, creating an inconsistency in the rate limiting state machine where some request types are protected and others are not.

2. **Information Disclosure**: Attackers can probe internal subscription state (`next_index_to_serve`, pending request indices, subscription stream metadata) through systematic probing without consequence. While this doesn't directly leak sensitive user data, it provides attackers with information about server internal state that could aid in coordinating more sophisticated attacks.

3. **Operational Impact**: Unbounded invalid subscription requests can cause:
   - Log spam through repeated error messages
   - Metric pollution making legitimate monitoring difficult  
   - Resource consumption through repeated memory allocations for subscription tracking
   - Response generation overhead for each invalid request

4. **Design Inconsistency**: The vulnerability breaks the intended security model where all invalid requests should be tracked and limited, regardless of request type.

While this does not directly cause fund loss, consensus violations, or network halts (which would be Critical/High), it represents a legitimate protocol-level security control bypass with operational and information disclosure implications that warrant Medium severity classification.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable with the following characteristics:

1. **No Special Privileges Required**: Any network peer (public PFN, VFN, or validator) can send subscription requests. The bypass affects all peer types.

2. **Simple Execution**: The attack requires only sending subscription requests with varying indices—no complex timing, race conditions, or coordinated multi-block sequences.

3. **No Preconditions**: The vulnerability exists in the core request handling logic and requires no specific blockchain state, epoch, or configuration.

4. **Immediate Exploitation**: An attacker can begin probing immediately upon connecting to the network.

5. **Present in Core Logic**: The bypass is in the fundamental request routing mechanism in `handler.rs`, affecting all nodes running the storage service.

## Recommendation

Subscription request validation failures should increment the RequestModerator's invalid request counter, consistent with how regular requests are handled. Modify `handle_subscription_request_failure` to call the RequestModerator:

```rust
fn handle_subscription_request_failure(
    &self,
    peer_network_id: PeerNetworkId,
    request: StorageServiceRequest,
    error: Error,
    subscription_request: SubscriptionRequest,
) {
    // Log the error
    sample!(
        SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
        warn!(LogSchema::new(LogEntry::SubscriptionRequest)
            .error(&error)
            .peer_network_id(&peer_network_id)
            .request(&request)
        );
    );

    // Increment invalid request count for the peer
    if let Error::InvalidRequest(_) = error {
        // Get or create unhealthy peer state
        let mut unhealthy_peer_state = self
            .request_moderator
            .get_unhealthy_peer_states()
            .entry(peer_network_id)
            .or_insert_with(|| {
                UnhealthyPeerState::new(
                    self.storage_service_config.max_invalid_requests_per_peer,
                    self.storage_service_config.min_time_to_ignore_peers_secs,
                    self.time_service.clone(),
                )
            });
        unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
    }

    // Update metrics and notify client
    update_failed_subscription_metrics(peer_network_id);
    self.send_response(
        request,
        Err(StorageServiceError::InvalidRequest(error.to_string())),
        subscription_request.take_response_sender(),
    );
}
```

Alternatively, route subscription requests through `validate_and_handle_request` before the specialized subscription handling, ensuring all requests benefit from the moderator's protection.

## Proof of Concept

The vulnerability can be demonstrated by sending subscription requests with invalid indices and observing that no TooManyInvalidRequests error is ever triggered, regardless of how many invalid requests are sent:

```rust
#[tokio::test]
async fn test_subscription_bypass_rate_limiting() {
    // Create storage service with rate limiting configured
    let max_invalid_requests = 3;
    let storage_config = StorageServiceConfig {
        max_invalid_requests_per_peer: max_invalid_requests,
        ..Default::default()
    };
    
    let (mut mock_client, mut service, _, _, _) = 
        MockClient::new(None, Some(storage_config));
    
    // Create a public network peer
    let peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Send many invalid subscription requests (indices too low)
    for _ in 0..(max_invalid_requests * 10) {
        let request = create_subscription_request_with_invalid_index(0);
        let response = mock_client.send_request(request, peer).await;
        
        // Should get InvalidRequest, never TooManyInvalidRequests
        assert_matches!(response.unwrap_err(), 
            StorageServiceError::InvalidRequest(_));
    }
    
    // Verify peer is NOT ignored despite sending many invalid requests
    let moderator = service.get_request_moderator();
    let peer_states = moderator.get_unhealthy_peer_states();
    assert!(peer_states.get(&peer).is_none() || 
            !peer_states.get(&peer).unwrap().is_ignored());
    
    // In contrast, regular invalid requests WOULD trigger rate limiting
    for _ in 0..max_invalid_requests {
        let request = create_invalid_regular_request();
        mock_client.send_request(request, peer).await;
    }
    
    // Now the peer SHOULD be ignored
    let request = create_invalid_regular_request();
    let response = mock_client.send_request(request, peer).await;
    assert_matches!(response.unwrap_err(),
        StorageServiceError::TooManyInvalidRequests(_));
}
```

## Notes

This vulnerability is confirmed in the current codebase at `state-sync/storage-service/server/src/handler.rs`. The separation of subscription and regular request handling appears to be intentional for architectural reasons (subscriptions are queued and served asynchronously when data becomes available), but the security implications of bypassing the RequestModerator were not addressed. The fix should ensure that subscription validation failures are tracked by the moderator while maintaining the architectural separation of concerns.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L125-134)
```rust
        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L136-138)
```rust
        // Process the request and return the response to the client
        let response = self.process_request(&peer_network_id, request.clone(), false);
        self.send_response(request, response, response_sender);
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-213)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/handler.rs (L354-380)
```rust
    fn handle_subscription_request_failure(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        error: Error,
        subscription_request: SubscriptionRequest,
    ) {
        // Something went wrong when adding the request to the stream
        sample!(
            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
            warn!(LogSchema::new(LogEntry::SubscriptionRequest)
                .error(&error)
                .peer_network_id(&peer_network_id)
                .request(&request)
            );
        );

        // Update the subscription metrics
        update_failed_subscription_metrics(peer_network_id);

        // Notify the client of the failure
        self.send_response(
            request,
            Err(StorageServiceError::InvalidRequest(error.to_string())),
            subscription_request.take_response_sender(),
        );
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-196)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L341-404)
```rust
    pub fn add_subscription_request(
        &mut self,
        storage_service_config: StorageServiceConfig,
        subscription_request: SubscriptionRequest,
    ) -> Result<(), (Error, SubscriptionRequest)> {
        // Verify that the subscription metadata is valid
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();
        if subscription_stream_metadata != self.subscription_stream_metadata {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request stream metadata is invalid! Expected: {:?}, found: {:?}",
                    self.subscription_stream_metadata, subscription_stream_metadata
                )),
                subscription_request,
            ));
        }

        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }

        // Verify that the number of active subscriptions respects the maximum
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }

        // Insert the subscription request into the pending requests
        let existing_request = self.pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        // Refresh the last stream update time
        self.refresh_last_stream_update_time();

        // If a pending request already existed, return the previous request to the caller
        if let Some(existing_request) = existing_request {
            return Err((
                Error::InvalidRequest(format!(
                    "Overwriting an existing subscription request for the given index: {:?}",
                    subscription_request_index
                )),
                existing_request,
            ));
        }

        Ok(())
    }
```
