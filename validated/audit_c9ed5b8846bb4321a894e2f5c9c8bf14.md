# Audit Report

## Title
Race Condition in Per-Key JWK Consensus Causes Silent Discarding of Legitimate Updates

## Summary
When the `JWK_CONSENSUS_PER_KEY_MODE` feature flag is enabled, multiple JWK updates for the same issuer but different keys can be included in a single block. Due to sequential execution and issuer-level version checking, only the first update succeeds while subsequent updates fail the version check and are silently discarded, resulting in permanent loss of legitimate security updates.

## Finding Description

The vulnerability exists in the interaction between per-key consensus mode and version validation logic. When per-key mode is enabled, validators create independent quorum-certified updates for different keys of the same issuer using distinct topics in the validator transaction pool. [1](#0-0) 

The pool architecture allows multiple updates for the same issuer (with different key IDs) to coexist because they use different topics (one transaction per topic): [2](#0-1) 

When creating updates, all key-level updates for the same issuer use the current on-chain version as their `base_version`: [3](#0-2) 

During block execution, validator transactions are processed sequentially. Each update is converted to have `version = base_version + 1`: [4](#0-3) 

The first update succeeds and modifies the on-chain version. When the second update executes in the same block, it fails the version check because it loads the already-modified state: [5](#0-4) 

This triggers the Expected failure path, which returns a Discard status: [6](#0-5) 

The Move code also enforces this version check in per-key mode: [7](#0-6) 

After block execution, when the on-chain state update event is processed, `reset_with_on_chain_state` discards consensus states for keys where the version changed, causing the `vtxn_guard` to drop and permanently remove the failed transaction from the pool: [8](#0-7) 

The block proposal mechanism has no filtering to prevent multiple updates for the same issuer from being pulled together. The pull method only filters by transaction hash, not by issuer: [9](#0-8) [10](#0-9) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria ("Significant protocol violations"):

1. **Authentication/Authorization Impact**: Legitimate JWK updates being discarded while potentially stale or malicious keys remain compromises OIDC-based authentication mechanisms
2. **Silent Data Loss**: Quorum-certified security updates are permanently discarded with no error or recovery mechanism
3. **Protocol Integrity Violation**: The per-key consensus feature is documented to enable independent key updates, but this bug makes multiple updates mutually exclusive within a block

The test suite comment confirms updates happen sequentially, not concurrently: [11](#0-10) 

While not Critical severity (no direct fund loss or network halt), this significantly impacts protocol security and authentication systems.

## Likelihood Explanation

**Likelihood: Medium to High** when per-key mode is enabled.

Factors increasing likelihood:
- No malicious intent required - this occurs between legitimate validators performing their duties
- Happens whenever multiple validators independently observe different key updates for the same issuer within timing that allows both to reach the same block proposal
- More likely during JWK rotation events when providers update multiple keys simultaneously
- The per-key mode is specifically designed to enable independent key updates, making this scenario the expected use case
- The feature flag enabling this mode can be activated via governance

## Recommendation

Implement one of the following fixes:

**Option 1: Per-key versioning**
Replace issuer-level versioning with per-key versioning to allow truly independent key updates.

**Option 2: Issuer-level coordination in pool**
Modify the validator transaction pool to enforce only one transaction per issuer (not per key) when in per-key mode, ensuring updates are serialized across blocks.

**Option 3: Version-agnostic execution**
Modify the execution logic to check if the specific key being updated matches the expected state, rather than checking the issuer's version number.

The recommended approach is Option 1, as it aligns with the design intent of per-key consensus while preventing the race condition.

## Proof of Concept

The existing test suite demonstrates this behavior. At line 187 of `testsuite/smoke-test/src/jwks/jwk_consensus_per_key.rs`, the comment explicitly states: "In per-key mode, we can only consensus one key at a time, and need 2 txns here." The test shows that when Alice needs to update multiple keys (a1, a2), the version only reaches 2 after 30 seconds, indicating sequential processing rather than concurrent updates. [12](#0-11) 

A complete PoC would involve:
1. Configuring two validators to observe different key updates for the same issuer simultaneously
2. Both achieving quorum certification
3. Both transactions entering the same block proposal
4. Observing that only one update succeeds while the other is permanently discarded

### Citations

**File:** types/src/validator_txn.rs (L55-64)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Topic {
    DKG,
    JWK_CONSENSUS(jwks::Issuer),
    JWK_CONSENSUS_PER_KEY_MODE {
        issuer: jwks::Issuer,
        kid: jwks::KID,
    },
}
```

**File:** crates/validator-transaction-pool/src/lib.rs (L114-124)
```rust
pub struct PoolStateInner {
    /// Incremented every time a txn is pushed in. The txn gets the old value as its sequence number.
    next_seq_num: u64,

    /// Track Topic -> seq_num mapping.
    /// We allow only 1 txn per topic and this index helps find the old txn when adding a new one for the same topic.
    seq_nums_by_topic: HashMap<Topic, u64>,

    /// Txns ordered by their sequence numbers (i.e. time they entered the pool).
    txn_queue: BTreeMap<u64, PoolItem>,
}
```

**File:** crates/validator-transaction-pool/src/lib.rs (L152-199)
```rust
    pub fn pull(
        &mut self,
        deadline: Instant,
        mut max_items: u64,
        mut max_bytes: u64,
        filter: TransactionFilter,
    ) -> Vec<ValidatorTransaction> {
        let mut ret = vec![];
        let mut seq_num_lower_bound = 0;

        // Check deadline at the end of every iteration to ensure validator txns get a chance no matter what current proposal delay is.
        while max_items >= 1 && max_bytes >= 1 {
            // Find the seq_num of the first txn that satisfies the quota.
            if let Some(seq_num) = self
                .txn_queue
                .range(seq_num_lower_bound..)
                .filter(|(_, item)| {
                    item.txn.size_in_bytes() as u64 <= max_bytes
                        && !filter.should_exclude(&item.txn)
                })
                .map(|(seq_num, _)| *seq_num)
                .next()
            {
                // Update the quota usage.
                // Send the pull notification if requested.
                let PoolItem {
                    txn,
                    pull_notification_tx,
                    ..
                } = self.txn_queue.get(&seq_num).unwrap();
                if let Some(tx) = pull_notification_tx {
                    let _ = tx.push((), txn.clone());
                }
                max_items -= 1;
                max_bytes -= txn.size_in_bytes() as u64;
                seq_num_lower_bound = seq_num + 1;
                ret.push(txn.as_ref().clone());

                if Instant::now() >= deadline {
                    break;
                }
            } else {
                break;
            }
        }

        ret
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L138-143)
```rust
                        let update = KeyLevelUpdate {
                            issuer: issuer.clone(),
                            base_version: effectively_onchain.version,
                            kid: kid.clone(),
                            to_upsert: Some(y.clone()),
                        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L243-254)
```rust
        // for an existing state entry (iss, kid) -> state, discard it unless `new_onchain_jwks[iss].version == self.onchain_jwks[iss].version`.
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** types/src/jwks/mod.rs (L342-358)
```rust
    pub fn try_as_issuer_level_repr(&self) -> anyhow::Result<ProviderJWKs> {
        let jwk_repr = self.to_upsert.clone().unwrap_or_else(|| {
            JWK::Unsupported(UnsupportedJWK {
                id: self.kid.clone(),
                payload: DELETE_COMMAND_INDICATOR.as_bytes().to_vec(),
            })
        });
        let version = self
            .base_version
            .checked_add(1)
            .context("KeyLevelUpdate::as_issuer_level_repr failed on version")?;
        Ok(ProviderJWKs {
            issuer: self.issuer.clone(),
            version,
            jwks: vec![JWKMoveStruct::from(jwk_repr)],
        })
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L78-88)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                debug!("Processing dkg transaction expected failure: {:?}", failure);
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-130)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L466-478)
```text
        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
```

**File:** consensus/src/liveness/proposal_generator.rs (L643-650)
```rust
        let pending_validator_txn_hashes: HashSet<HashValue> = pending_blocks
            .iter()
            .filter_map(|block| block.validator_txns())
            .flatten()
            .map(ValidatorTransaction::hash)
            .collect();
        let validator_txn_filter =
            vtxn_pool::TransactionFilter::PendingTxnHashSet(pending_validator_txn_hashes);
```

**File:** testsuite/smoke-test/src/jwks/jwk_consensus_per_key.rs (L145-211)
```rust
    // https://alice.io exposes 4 new keys, but equivocates.
    let alice_jwk_0 = r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"a0","e":"AQAB","n":"999"}"#;
    let alice_jwk_1 = r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"a1","e":"AQAB","n":"998"}"#;
    let alice_jwk_2 = r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"a2","e":"AQAB","n":"997"}"#;
    let alice_jwk_3 = r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"a3","e":"AQAB","n":"996"}"#;
    alice_jwks_server.update_request_handler(Some(Arc::new(EquivocatingServer::new(
        format!(
            r#"{{"keys": [{},{},{}]}}"#,
            alice_jwk_0, alice_jwk_1, alice_jwk_2
        )
        .as_str()
        .as_bytes()
        .to_vec(), // Content A
        format!(
            r#"{{"keys": [{},{},{}]}}"#,
            alice_jwk_1, alice_jwk_2, alice_jwk_3
        )
        .as_str()
        .as_bytes()
        .to_vec(), // Content B
        2, // The first 2 clients get Content A, others get Content B.
    ))));

    // https://bob.dev deletes `b0`, updates `b1`, add `b2`.
    let bob_jwk_1_edited =
        r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"b1","e":"AQAB","n":"991ex"}"#;
    let bob_jwk_2 = r#"{"alg":"RS256","use":"sig","kty":"RSA","kid":"b2","e":"AQAB","n":"992"}"#;
    bob_jwks_server.update_request_handler(Some(Arc::new(StaticContentServer::new(
        format!(r#"{{"keys": [{},{}]}}"#, bob_jwk_1_edited, bob_jwk_2)
            .as_str()
            .as_bytes()
            .to_vec(),
    ))));

    info!("Wait for 30 secs and `a1, a2, b1 (new ver.), b2` should be on chain.");
    sleep(Duration::from_secs(30)).await;
    let patched_jwks = get_patched_jwks(&client).await;
    assert_eq!(
        AllProvidersJWKs {
            entries: vec![
                ProviderJWKs {
                    issuer: alice_issuer_id.as_bytes().to_vec(),
                    version: 2, // In per-key mode, we can only consensus one key at a time, and need 2 txns here.
                    jwks: vec![
                        JWK::RSA(RSA_JWK::new_256_aqab("a1", "998")).into(),
                        JWK::RSA(RSA_JWK::new_256_aqab("a2", "997")).into(),
                    ],
                },
                ProviderJWKs {
                    issuer: bob_issuer_id.as_bytes().to_vec(),
                    version: 5, // 3 changes since version 2: 1 delete and 2 upserts.
                    jwks: vec![
                        JWK::RSA(RSA_JWK::new_256_aqab("b1", "991ex")).into(),
                        JWK::RSA(RSA_JWK::new_256_aqab("b2", "992")).into(),
                    ],
                },
                ProviderJWKs {
                    issuer: get_sample_iss().into_bytes(),
                    version: 0,
                    jwks: vec![secure_test_rsa_jwk().into()],
                },
            ]
        }
        .indexed()
        .unwrap(),
        patched_jwks.jwks.indexed().unwrap()
    );
```
