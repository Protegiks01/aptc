# Audit Report

## Title
Non-Deterministic Random Number Generation in Change Set Validation Breaks Consensus Safety

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic random number generation (`rand::thread_rng()`) in the consensus-critical transaction execution path. This introduces non-determinism that causes different validators to produce different execution results for identical transactions, violating the fundamental deterministic execution requirement of blockchain consensus and causing network-wide liveness failures.

## Finding Description

The `randomly_check_layout_matches()` function contains non-deterministic logic that is executed during the epilogue phase of every user transaction. [1](#0-0) 

The function generates a random number between 0-99, and only performs the expensive layout equality check when the random number equals 1 (1% probability). When layouts don't match and the random check executes, it returns a `PanicError` causing transaction failure. When the check is skipped (99% probability), the function returns `Ok()` allowing the transaction to succeed.

This function is invoked during the critical change set squashing operations:

1. **During resource write squashing**: Called when squashing `WriteWithDelayedFields` operations [2](#0-1) 

2. **During change set squashing**: Invoked via the squash operation chain [3](#0-2) 

3. **During epilogue finalization**: Called when finishing the epilogue session [4](#0-3) 

4. **During transaction cleanup**: Executed in the success transaction cleanup path [5](#0-4) 

**Consensus Impact:**

According to the Aptos consensus design, validators execute blocks speculatively and vote on the resulting state root. [6](#0-5) 

When a layout mismatch condition exists:
- **~1% of validators**: Random number = 1 → check executes → error detected → transaction fails → state root X
- **~99% of validators**: Random number ≠ 1 → check skipped → transaction succeeds → state root Y
- **Result**: Validators cannot reach 2f+1 quorum on the same state root → consensus halts

Each validator independently generates its own random number, ensuring different execution results across the validator set for the same transaction.

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest severity category under the Aptos Bug Bounty program:

1. **Consensus/Safety Violations**: Different validators produce different execution results for identical transactions, preventing quorum formation on state roots. This directly violates the fundamental consensus safety property that all honest validators must agree on the state resulting from a given block.

2. **Total Loss of Liveness/Network Availability**: When validators cannot reach quorum (2f+1 agreement) on state roots due to non-deterministic execution, the blockchain cannot progress. No new blocks can be committed, halting all transaction processing network-wide.

3. **Non-recoverable Network Partition**: Once validators have committed to different state roots in their votes, recovery requires manual intervention (likely a hard fork) to bring validators back into consensus. The network cannot self-recover from this state divergence.

The impact affects **all validators simultaneously** - this is not a race condition or timing issue, but a fundamental logic error where non-deterministic code exists in a path that must be deterministic for consensus safety.

## Likelihood Explanation

**High Likelihood** - The vulnerability has two components:

1. **Non-determinism is always present**: Every transaction execution goes through the epilogue phase where this function is called. The non-deterministic random number generation occurs on every execution. [7](#0-6) 

2. **Triggering condition**: The consensus break manifests when a layout mismatch condition exists. While the code comment indicates layouts "are supposed to match" (suggesting mismatches indicate invariant violations), the probabilistic check itself is the vulnerability because:
   - If an invariant violation occurs, 99% of validators silently ignore it while 1% detect it
   - This converts any potential layout mismatch into a guaranteed consensus failure
   - The non-determinism makes debugging extremely difficult (only manifests 1% of the time)

The function is explicitly designed to "sporadically" check layouts as an optimization, demonstrating intentional non-determinism in a consensus-critical path. This violates the core design principle stated in the consensus documentation that the system should be "resistant to non-determinism bugs."

## Recommendation

Replace the non-deterministic probabilistic check with a deterministic validation approach:

**Option 1 - Always Check (Most Secure)**:
Remove the random number generation and always perform the layout equality check. While more expensive, this ensures deterministic execution across all validators.

**Option 2 - Compile-Time Toggle**:
Use a feature flag or compilation constant to enable/disable the check deterministically (e.g., enable in debug builds, disable in production). This ensures all validators behave identically.

**Option 3 - Remove Check**:
If the layouts are truly expected to always match (as the comment suggests), remove this defensive check entirely. If mismatches indicate serious bugs, they should be caught by comprehensive testing, not probabilistic runtime checks.

The core principle: **No non-deterministic operations (including random number generation) should exist in consensus-critical transaction execution paths.**

## Proof of Concept

The vulnerability is evident from code inspection without requiring a PoC, as it's a fundamental logic error in design. The execution path through the consensus-critical epilogue is confirmed by tracing:

Transaction execution → epilogue session → finish → squash_additional_change_set → squash_additional_resource_writes → randomly_check_layout_matches → rand::thread_rng()

Any transaction that triggers change set squashing (essentially all non-trivial transactions) executes this non-deterministic code path, with different validators independently generating different random numbers for the same transaction.

## Notes

This vulnerability represents a fundamental violation of blockchain consensus requirements. The Aptos documentation explicitly states the system was designed to be "more resistant to non-determinism bugs" by having validators collectively sign execution results. However, this code introduces non-determinism directly into the execution path that produces those results, undermining the entire consensus safety mechanism.

The severity is critical regardless of how frequently layout mismatches occur, because the non-determinism itself is the vulnerability that converts any potential invariant violation into a consensus-breaking event.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L60-66)
```rust
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L588-588)
```rust
                            randomly_check_layout_matches(Some(layout), Some(additional_layout))?;
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L757-760)
```rust
        Self::squash_additional_resource_writes(
            &mut self.resource_write_set,
            additional_resource_write_set,
        )?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L100-101)
```rust
        change_set
            .squash_additional_change_set(additional_change_set)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L869-874)
```rust
        let output = epilogue_session.finish(
            fee_statement,
            ExecutionStatus::Success,
            change_set_configs,
            module_storage,
        )?;
```

**File:** consensus/README.md (L35-35)
```markdown
We reformulate the safety conditions and provide extended proofs of safety, liveness, and optimistic responsiveness. We also implement a number of additional features. First, we make the protocol more resistant to non-determinism bugs, by having validators collectively sign the resulting state of a block rather than just the sequence of transactions. This also allows clients to use quorum certificates to authenticate reads from the database. Second, we design a round_state that emits explicit timeouts, and validators rely on a quorum of those to move to the next round — without requiring synchronized clocks. Third, we intend to design an unpredictable leader election mechanism in which the leader of a round is determined by the proposer of the latest committed block using a verifiable rand ... (truncated)
```
