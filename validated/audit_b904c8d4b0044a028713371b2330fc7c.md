# Audit Report

## Title
Validator Node Crash via Integer Underflow in Aggregator Delta Validation with max_value=0

## Summary
A critical integer underflow vulnerability exists in the aggregator delta history validation logic that causes all validator nodes to panic when processing transactions containing aggregators with `max_value=0`. This enables a denial-of-service attack that can completely halt the Aptos network.

## Finding Description

The vulnerability exists in the `validate_against_base_value` function where overflow validation performs an unchecked unsigned integer subtraction. [1](#0-0) 

When `max_value = 0` and an overflow is recorded (e.g., `min_overflow_positive_delta = 1`), the expression `max_value - min_overflow_positive_delta` becomes `0 - 1`, causing integer underflow. Since Aptos builds with `overflow-checks = true` [2](#0-1) , this subtraction panics at runtime, crashing the validator node.

**Attack Propagation:**

1. Attacker creates an aggregator with `max_value = 0` using the public API through `native_create_aggregator`. [3](#0-2)  No validation exists preventing `max_value = 0` in the native implementation - the function accepts any max_value without bounds checking.

2. Attacker calls `try_add(&mut agg, 1)`, which correctly fails due to overflow. [4](#0-3) 

3. The overflow is recorded in the aggregator's delta history via `record_overflow`. [5](#0-4) 

4. During block execution with delayed field optimization enabled, the optimization is conditionally enabled based on the feature flag. [6](#0-5)  Both required feature flags (`AGGREGATOR_V2_DELAYED_FIELDS` and `RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET`) are enabled by default in production. [7](#0-6) 

5. At commit time, `validate_delayed_field_reads` is invoked. [8](#0-7) 

6. The validation calls `validate_against_base_value(0, 0)` [9](#0-8) , which executes the underflowing subtraction at line 175, causing a panic before error handling can catch it.

The panic is not caught by any `catch_unwind` wrapper and will terminate the validator process. The `validate_and_commit_delayed_fields` function returns `Result<bool, PanicError>` [10](#0-9) , but the actual Rust panic from integer underflow occurs before any Result can be returned.

## Impact Explanation

**Severity: CRITICAL** - This vulnerability enables complete network unavailability, meeting the "Total loss of liveness/network availability" criterion from the Aptos bug bounty program.

- **All validators crash simultaneously**: When any validator processes a block containing such a transaction, it panics during the commit phase due to the integer underflow
- **Network-wide denial of service**: The entire Aptos blockchain halts as all validators fail to process the malicious transaction
- **Deterministic failure**: The panic is guaranteed and unavoidable once the transaction enters a block
- **Zero attack cost**: Any user can submit such a transaction with minimal gas fees

This breaks the **Deterministic Execution** invariant as nodes crash instead of producing state roots, and violates the **State Consistency** guarantee.

## Likelihood Explanation

**Likelihood: VERY HIGH**

- **No special privileges required**: Any user can create aggregators and submit transactions through the public API
- **Simple attack vector**: Requires only two Move function calls (create_aggregator + try_add)
- **No validation barriers**: No input validation prevents `max_value = 0` at any layer
- **Guaranteed success**: The panic is deterministic and occurs during block execution with the feature flags enabled by default
- **Difficult to detect**: The transaction appears valid during submission and only fails during commit-time validation

## Recommendation

Add validation in the `native_create_aggregator` function to reject `max_value = 0`:

```rust
fn native_create_aggregator(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);
    debug_assert_eq!(ty_args.len(), 1);
    context.charge(AGGREGATOR_V2_CREATE_AGGREGATOR_BASE)?;

    let max_value = pop_value_by_type(&ty_args[0], &mut args, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    
    // Add validation to prevent max_value = 0
    if max_value == 0 {
        return Err(SafeNativeError::Abort {
            abort_code: EINVALID_AGGREGATOR_MAX_VALUE,
        });
    }
    
    create_aggregator_with_max_value(context, &ty_args[0], max_value)
}
```

Alternatively, fix the underflow in `validate_against_base_value` by using checked subtraction:

```rust
if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
    if let Some(threshold) = max_value.checked_sub(min_overflow_positive_delta) {
        if base_value <= threshold {
            return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(min_overflow_positive_delta),
                reason: DeltaApplicationFailureReason::ExpectedOverflow,
            });
        }
    }
    // If checked_sub returns None (underflow), the condition is always false
}
```

## Proof of Concept

```move
#[test_only]
module attacker::validator_crash_poc {
    use aptos_framework::aggregator_v2::{Self, Aggregator};

    #[test]
    fun test_validator_crash() {
        // Create aggregator with max_value = 0
        let agg: Aggregator<u64> = aggregator_v2::create_aggregator(0);
        
        // Try to add 1, which will fail and record overflow
        let success = aggregator_v2::try_add(&mut agg, 1);
        assert!(!success, 0); // Correctly returns false
        
        // At this point, the aggregator has:
        // - base_value = 0
        // - max_value = 0
        // - min_overflow_positive_delta = Some(1)
        //
        // When this transaction is committed with delayed field optimization,
        // validate_against_base_value(0, 0) will execute:
        //   if 0 <= 0 - 1  // This subtraction panics!
        //
        // All validator nodes will crash when processing this block.
    }
}
```

## Notes

This vulnerability demonstrates a critical oversight where arithmetic operations involving user-controlled values were not properly validated. The issue is exacerbated by the fact that:

1. The feature flags enabling this code path are active by default on mainnet
2. The panic occurs during the commit phase, after consensus has already decided on the block
3. No upper-layer error handling can catch a Rust panic from integer underflow with overflow-checks enabled

The fix requires either input validation to prevent `max_value = 0` or defensive programming using checked arithmetic operations in the validation logic.

### Citations

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L175-175)
```rust
            if base_value <= max_value - min_overflow_positive_delta {
```

**File:** Cargo.toml (L923-923)
```text
overflow-checks = true
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L99-111)
```rust
fn get_context_data<'t, 'b>(
    context: &'t mut SafeNativeContext<'_, 'b, '_, '_>,
) -> Option<(&'b dyn DelayedFieldResolver, RefMut<'t, DelayedFieldData>)> {
    let aggregator_context = context.extensions().get::<NativeAggregatorContext>();
    if aggregator_context.delayed_field_optimization_enabled {
        Some((
            aggregator_context.delayed_field_resolver,
            aggregator_context.delayed_field_data.borrow_mut(),
        ))
    } else {
        None
    }
}
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L138-149)
```rust
fn native_create_aggregator(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);
    debug_assert_eq!(ty_args.len(), 1);
    context.charge(AGGREGATOR_V2_CREATE_AGGREGATOR_BASE)?;

    let max_value = pop_value_by_type(&ty_args[0], &mut args, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    create_aggregator_with_max_value(context, &ty_args[0], max_value)
}
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L171-212)
```rust
fn native_try_add(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 2);
    debug_assert_eq!(ty_args.len(), 1);
    context.charge(AGGREGATOR_V2_TRY_ADD_BASE)?;

    let aggregator_value_ty = &ty_args[0];
    let rhs = pop_value_by_type(aggregator_value_ty, &mut args, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    let aggregator = safely_pop_arg!(args, StructRef);

    let max_value = get_aggregator_max_value(&aggregator, aggregator_value_ty)?;

    let success = if let Some((resolver, mut delayed_field_data)) = get_context_data(context) {
        let id = get_aggregator_value_as_id(&aggregator, aggregator_value_ty, resolver)?;
        delayed_field_data.try_add_or_check_delta(
            id,
            max_value,
            SignedU128::Positive(rhs),
            resolver,
            true,
        )?
    } else {
        let lhs = get_aggregator_value(&aggregator, aggregator_value_ty)?;
        match BoundedMath::new(max_value).unsigned_add(lhs, rhs) {
            Ok(result) => {
                let new_value = create_value_by_type(
                    aggregator_value_ty,
                    result,
                    EUNSUPPORTED_AGGREGATOR_TYPE,
                )?;
                set_aggregator_value(&aggregator, new_value)?;
                true
            },
            Err(_) => false,
        }
    };

    Ok(smallvec![Value::bool(success)])
}
```

**File:** aptos-move/block-executor/src/view.rs (L362-363)
```rust
            SignedU128::Positive(delta_value) => {
                history.record_overflow(*delta_value);
```

**File:** types/src/on_chain_config/aptos_features.rs (L210-215)
```rust
            FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS,
            FeatureFlag::CONCURRENT_TOKEN_V2,
            FeatureFlag::LIMIT_MAX_IDENTIFIER_LENGTH,
            FeatureFlag::OPERATOR_BENEFICIARY_CHANGE,
            FeatureFlag::BN254_STRUCTURES,
            FeatureFlag::RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET,
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1142-1184)
```rust
    pub(crate) fn validate_delayed_field_reads(
        &self,
        delayed_fields: &dyn TVersionedDelayedFieldView<DelayedFieldID>,
        idx_to_validate: TxnIndex,
    ) -> Result<bool, PanicError> {
        if self.delayed_field_speculative_failure {
            return Ok(false);
        }

        use MVDelayedFieldsError::*;
        for (id, read_value) in &self.delayed_field_reads {
            match delayed_fields.read_latest_predicted_value(
                id,
                idx_to_validate,
                ReadPosition::BeforeCurrentTxn,
            ) {
                Ok(current_value) => match read_value {
                    DelayedFieldRead::Value { value, .. } => {
                        if value != &current_value {
                            return Ok(false);
                        }
                    },
                    DelayedFieldRead::HistoryBounded {
                        restriction,
                        max_value,
                        ..
                    } => match restriction.validate_against_base_value(
                        current_value.into_aggregator_value()?,
                        *max_value,
                    ) {
                        Ok(_) => {},
                        Err(_) => {
                            return Ok(false);
                        },
                    },
                },
                Err(NotFound) | Err(Dependency(_)) | Err(DeltaApplicationFailure) => {
                    return Ok(false);
                },
            }
        }
        Ok(true)
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L846-889)
```rust
    fn validate_and_commit_delayed_fields(
        txn_idx: TxnIndex,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        last_input_output: &TxnLastInputOutput<T, E::Output>,
        is_v2: bool,
    ) -> Result<bool, PanicError> {
        let (read_set, is_speculative_failure) = last_input_output
            .read_set(txn_idx)
            .ok_or_else(|| code_invariant_error("Read set must be recorded"))?;

        if is_speculative_failure {
            return Ok(false);
        }

        if !read_set.validate_delayed_field_reads(versioned_cache.delayed_fields(), txn_idx)?
            || (is_v2
                && !read_set.validate_aggregator_v1_reads(
                    versioned_cache.data(),
                    last_input_output
                        .modified_aggregator_v1_keys(txn_idx)
                        .ok_or_else(|| {
                            code_invariant_error("Modified aggregator v1 keys must be recorded")
                        })?,
                    txn_idx,
                )?)
        {
            return Ok(false);
        }

        let delayed_field_ids = last_input_output
            .delayed_field_keys(txn_idx)
            .ok_or_else(|| code_invariant_error("Delayed field keys must be recorded"))?;
        if let Err(e) = versioned_cache
            .delayed_fields()
            .try_commit(txn_idx, delayed_field_ids)
        {
            return match e {
                CommitError::ReExecutionNeeded(_) => Ok(false),
                CommitError::CodeInvariantError(msg) => Err(code_invariant_error(msg)),
            };
        }

        Ok(true)
    }
```
