# Audit Report

## Title
Event V2 Translation Produces Non-Monotonic Sequence Numbers Due to Latest State View Usage

## Summary
The event V2 to V1 translator incorrectly uses `latest_state_checkpoint_view()` instead of version-specific state views when retrieving resource state, causing sequence numbers to be assigned based on current blockchain state rather than the historical state at the transaction version being processed. This results in non-monotonic sequence numbers that violate indexer data integrity requirements.

## Finding Description

The vulnerability exists in the Event V2 translation pipeline within the indexer component. When V2 events are translated to V1 format for backward compatibility, the system must reconstruct sequence numbers by querying on-chain resource state to determine event handle counters. [1](#0-0) 

The critical flaw occurs in `get_state_value_bytes_for_resource()` which calls `latest_state_checkpoint_view()` to retrieve the current blockchain state rather than the state at the specific transaction version being indexed. This method is called by all event translators to fetch resource state for sequence number determination. [2](#0-1) 

For example, `CoinDepositTranslator` reads the `CoinStore` resource to extract the `deposit_events.count()` value, which is then passed as the `default` parameter to `get_next_sequence_number()`. [3](#0-2) 

The `get_next_sequence_number()` method uses this `default` value when no cached or persisted sequence number exists, causing the first event for any key to receive a sequence number equal to the **current** event count rather than the historical count.

The codebase provides the correct mechanism via `state_view_at_version()`: [4](#0-3) 

However, the translator uses the wrong method: [5](#0-4) 

**Trigger Scenario:**

When the indexer processes historical transactions (version < latest version), it occurs during:
1. Initial validator sync from genesis
2. Re-indexing after database corruption  
3. Catch-up indexing after node downtime
4. Fresh indexing on new indexer instances [6](#0-5) 

The transaction version is available in the processing loop but is not passed to the translator, causing it to default to reading latest state.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria under "State inconsistencies requiring manual intervention":

1. **Data Integrity Violation**: Event sequence numbers are fundamental indexer invariants. Incorrect values break the monotonic sequence assumption that dApps, analytics tools, and debugging utilities rely upon for event ordering and querying.

2. **Non-Deterministic Indexing**: Different nodes indexing the same historical transactions at different times (when blockchain has advanced to different versions) will produce different sequence numbers for identical events, violating deterministic execution expectations.

3. **API Data Corruption**: All `get_events_by_event_key()` queries return corrupted sequence numbers, affecting ecosystem participants who depend on indexed event data for application logic, monitoring, and state reconstruction. [7](#0-6) 

4. **Requires Manual Intervention**: Once incorrect sequence numbers persist to the indexer database, they remain across restarts and require coordinated remediation:
   - Complete indexer DB wipe
   - Re-indexing from genesis with fixed code
   - Coordination across all affected nodes

The issue does **not** affect consensus (events are correctly committed on-chain with proper V2 semantics), limiting impact to the indexer layer. However, the indexed view is critical infrastructure that ecosystem participants depend on for querying historical event data.

## Likelihood Explanation

**Likelihood: High** - This vulnerability triggers automatically during normal validator operations:

1. **Guaranteed Trigger**: Any indexer processing transactions at version V where V < latest_version will assign incorrect sequence numbers. This is deterministic, not probabilistic.

2. **Common Operational Scenarios**:
   - New validators performing initial blockchain sync
   - Existing validators recovering from crashes/downtime
   - Database corruption requiring fresh indexing
   - Indexer software upgrades requiring data migration [8](#0-7) 

3. **No Attacker Required**: This is a logic bug in normal code paths, not requiring malicious input, Byzantine behavior, or adversarial conditions.

4. **Persistent Corruption**: Once wrong sequence numbers enter the database, they propagate through the cache mechanism in subsequent batch processing and persist across restarts. [9](#0-8) 

## Recommendation

Modify the event translation engine to accept and use transaction version when retrieving state:

1. Update `EventV2TranslationEngine` methods to accept `version: Version` parameter
2. Replace `latest_state_checkpoint_view()` with `state_view_at_version(Some(version))`
3. Update `DBIndexer::translate_event_v2_to_v1()` to pass the transaction version to the translation engine
4. Update all translator implementations to pass version through the call chain

Proposed fix structure:
```rust
// In event_v2_translator.rs
pub fn get_state_value_bytes_for_resource(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,  // Add version parameter
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))  // Use version-specific view
        .expect("Failed to get state view");
    // ... rest of implementation
}

// In db_indexer.rs line 451
self.translate_event_v2_to_v1(v2, version)  // Pass version
```

After deploying the fix, affected nodes must wipe their indexer databases and re-index from genesis to correct the corrupted sequence numbers.

## Proof of Concept

The vulnerability can be verified through code inspection by tracing the execution path:

1. Observe `process_a_batch()` processes transactions sequentially with version counter
2. Note that `translate_event_v2_to_v1()` is called without version parameter
3. Trace to `get_state_value_bytes_for_resource()` using `latest_state_checkpoint_view()`
4. Compare with correct `state_view_at_version()` method available in the codebase

A full integration test would require:
- Setting up a test blockchain with historical transactions containing V2 events
- Advancing blockchain state to create new events (increasing event counts)
- Running indexer against historical transactions
- Verifying sequence numbers skip initial values and start from current counts

However, the vulnerability is evident from static code analysis without requiring runtime execution.

## Notes

This vulnerability is confined to the indexer subsystem and does not affect consensus, transaction execution, or on-chain state. The V2 events are correctly stored on-chain; only the translated V1 representation in the indexer has corrupted sequence numbers. The impact is limited to ecosystem participants querying historical events through indexer APIs rather than affecting core blockchain security guarantees.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-273)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L77-91)
```rust
pub trait LatestDbStateCheckpointView {
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView>;
}

impl LatestDbStateCheckpointView for Arc<dyn DbReader> {
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/indexer/src/db_indexer.rs (L396-407)
```rust
    /// Process all transactions from `start_version` to `end_version`. Left inclusive, right exclusive.
    pub fn process(&self, start_version: Version, end_version: Version) -> Result<Version> {
        let mut version = start_version;
        while version < end_version {
            let next_version = self.process_a_batch(version, end_version)?;
            if next_version == version {
                break;
            }
            version = next_version;
        }
        Ok(version)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L418-486)
```rust
        db_iter.try_for_each(|res| {
            let (txn, events, writeset) = res?;
            if let Some(signed_txn) = txn.try_as_signed_user_txn() {
                if self.indexer_db.transaction_enabled() {
                    if let ReplayProtector::SequenceNumber(seq_num) = signed_txn.replay_protector()
                    {
                        batch.put::<OrderedTransactionByAccountSchema>(
                            &(signed_txn.sender(), seq_num),
                            &version,
                        )?;
                    }
                }
            }

            if self.indexer_db.event_enabled() {
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
```

**File:** storage/indexer/src/db_indexer.rs (L505-522)
```rust
        if self.indexer_db.event_v2_translation_enabled() {
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::EventV2TranslationVersion,
                &MetadataValue::Version(version - 1),
            )?;

            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
        }
```

**File:** storage/indexer/src/db_indexer.rs (L644-724)
```rust
    pub fn get_events_by_event_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        order: Order,
        limit: u64,
        ledger_version: Version,
    ) -> Result<Vec<EventWithVersion>> {
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
        error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
        let get_latest = order == Order::Descending && start_seq_num == u64::MAX;

        let cursor = if get_latest {
            // Caller wants the latest, figure out the latest seq_num.
            // In the case of no events on that path, use 0 and expect empty result below.
            self.indexer_db
                .get_latest_sequence_number(ledger_version, event_key)?
                .unwrap_or(0)
        } else {
            start_seq_num
        };

        // Convert requested range and order to a range in ascending order.
        let (first_seq, real_limit) = get_first_seq_num_and_limit(order, cursor, limit)?;

        // Query the index.
        let mut event_indices = self.indexer_db.lookup_events_by_key(
            event_key,
            first_seq,
            real_limit,
            ledger_version,
        )?;

        // When descending, it's possible that user is asking for something beyond the latest
        // sequence number, in which case we will consider it a bad request and return an empty
        // list.
        // For example, if the latest sequence number is 100, and the caller is asking for 110 to
        // 90, we will get 90 to 100 from the index lookup above. Seeing that the last item
        // is 100 instead of 110 tells us 110 is out of bound.
        if order == Order::Descending {
            if let Some((seq_num, _, _)) = event_indices.last() {
                if *seq_num < cursor {
                    event_indices = Vec::new();
                }
            }
        }

        let mut events_with_version = event_indices
            .into_iter()
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
                {
                    event @ ContractEvent::V1(_) => event,
                    ContractEvent::V2(_) => ContractEvent::V1(
                        self.indexer_db
                            .get_translated_v1_event_by_version_and_index(ver, idx)?,
                    ),
                };
                let v0 = match &event {
                    ContractEvent::V1(event) => event,
                    ContractEvent::V2(_) => bail!("Unexpected module event"),
                };
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );

                Ok(EventWithVersion::new(ver, event))
            })
            .collect::<Result<Vec<_>>>()?;
        if order == Order::Descending {
            events_with_version.reverse();
        }

        Ok(events_with_version)
    }
```
