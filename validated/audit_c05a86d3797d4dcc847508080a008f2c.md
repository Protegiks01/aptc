# Audit Report

## Title
Database Truncation Causes Permanent Node Failure Due to Inverted Version Range (`min_readable_version > latest_version`)

## Summary
After performing a database truncation to an earlier version (a legitimate recovery operation), the node enters an unrecoverable state where `min_readable_version` exceeds `latest_version`. This causes all read queries to fail permanently, rendering the node completely unusable until manual metadata correction.

## Finding Description

The vulnerability occurs in the interaction between the database truncation mechanism and the ledger pruner manager's initialization logic.

**Root Cause:**

The truncate operation updates only the `OverallCommitProgress` to roll back the database to a target version, but fails to update the ledger pruner progress metadata. [1](#0-0) 

The `sync_commit_progress` function called during truncation only truncates ledger data, state KV, and state merkle databases, but does not update any pruner metadata. [2](#0-1) 

**Initialization Logic:**

When `LedgerPrunerManager` is created during node restart, it loads `min_readable_version` from persisted pruner progress and initializes both `min_readable_version` and `latest_version` to this persisted value. [3](#0-2) 

The persisted progress is retrieved without any validation against the actual database state. [4](#0-3) 

**Update Attempt:**

During database initialization, `maybe_set_pruner_target_db_version` is called with the synced version (the truncated version). [5](#0-4) 

**The Critical Bug:**

The `maybe_set_pruner_target_db_version` method updates `latest_version` unconditionally, but only updates `min_readable_version` if a specific condition is met. [6](#0-5) 

When the truncated version (e.g., 115) is less than `min_readable_version + pruning_batch_size + prune_window` (e.g., 120 + batch_size + window), the check at lines 72-74 fails, and `set_pruner_target_db_version` is never called, leaving `min_readable_version` at its stale persisted value.

**Final State:** `latest_version = 115`, `min_readable_version = 120`

**Query Failure:**

All read queries validate that the requested version is not pruned before accessing data. [7](#0-6) 

The `get_transactions` method checks both that `start_version <= ledger_version` and that the version is not pruned. [8](#0-7) 

When `min_readable_version > ledger_version`, all versions fail the pruning check because no version can satisfy both `version <= ledger_version` (115) AND `version >= min_readable_version` (120).

**Concrete Scenario:**

1. **Before Truncation:** Database at version 220, pruning active with `min_readable_version = 120`
2. **Admin Truncates:** `db-tool truncate --target-version 115` (legitimate recovery)
3. **Restart Node:** Database opens, initializes pruner manager with stale metadata
4. **Bug Triggered:** `latest_version = 115`, `min_readable_version = 120`
5. **Result:** All queries return "pruned" errors; node is completely unusable

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria)

This vulnerability causes:
- **Total Loss of Node Availability**: The affected validator or fullnode cannot serve any queries and becomes completely non-functional
- **Validator Node Unavailability**: Meets the "Validator node slowdowns" criterion for High severity (though this is actually complete failure, not just slowdown)
- **Significant Protocol Violation**: Breaks the fundamental invariant that `min_readable_version <= latest_version`

The impact is severe because:
1. Node becomes permanently unusable after legitimate recovery operations
2. Requires manual database metadata correction to recover
3. Affects any node operator performing database maintenance
4. Could impact network liveness if multiple validators are affected simultaneously

This does NOT reach Critical severity because it:
- Does not cause loss of funds
- Does not break consensus safety (affected node just stops participating)
- Only affects the single node that performed truncation
- Is recoverable through manual intervention (not requiring a hardfork)

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers **automatically** whenever:
1. A node has active pruning enabled (standard configuration in production)
2. Database is truncated to a version below `min_readable_version` (common in recovery scenarios)
3. Node is restarted after truncation

Database truncation is a documented recovery tool used in scenarios like:
- Recovering from database corruption
- Rolling back after detecting state inconsistencies
- Testing and validation workflows
- Disaster recovery procedures

No malicious actor is requiredâ€”this is a deterministic bug in legitimate maintenance operations performed by trusted node operators.

## Recommendation

The truncate operation should update pruner metadata in addition to `OverallCommitProgress`. Specifically, after updating `OverallCommitProgress`, the system should:

1. Reset all pruner progress metadata to the target version or 0:
   - `LedgerPrunerProgress`
   - `StateKvPrunerProgress`
   - `StateMerklePrunerProgress`

2. Add validation during `LedgerPrunerManager::new()` to ensure `min_readable_version <= synced_version`, and reset to 0 if the invariant is violated.

3. Alternatively, add an assertion in `maybe_set_pruner_target_db_version` to detect and handle the inverted range condition.

The fix should be applied in `storage/aptosdb/src/db_debugger/truncate/mod.rs` after line 135 to write the pruner progress metadata, or in `storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs` to add defensive validation.

## Proof of Concept

**Reproduction Steps:**

1. Start a node with pruning enabled (standard configuration)
2. Let the database reach version 220 with `min_readable_version` advancing to 120
3. Stop the node
4. Execute: `aptos-db-tool debug truncate --db-dir /path/to/db --target-version 115 --opt-out-backup-checkpoint`
5. Restart the node
6. Attempt any query (e.g., `GET /v1/transactions?start=100&limit=10`)

**Expected Result:** Query returns transaction data

**Actual Result:** Query fails with error indicating version is pruned (min_readable_version=120)

**Verification:** Check database state shows `ledger_version=115` but `min_readable_version=120`, making all data inaccessible.

### Citations

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L130-135)
```rust
        let mut batch = SchemaBatch::new();
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        ledger_db.metadata_db().write_schemas(batch)?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-502)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L66-77)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        *self.latest_version.lock() = latest_version;

        let min_readable_version = self.get_min_readable_version();
        // Only wake up the ledger pruner if there are `ledger_pruner_pruning_batch_size` pending
        // versions.
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-137)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        Self {
            ledger_db,
            prune_window: ledger_pruner_config.prune_window,
            pruner_worker,
            pruning_batch_size: ledger_pruner_config.batch_size,
            latest_version: Arc::new(Mutex::new(min_readable_version)),
            user_pruning_window_offset: ledger_pruner_config.user_pruning_window_offset,
            min_readable_version: AtomicVersion::new(min_readable_version),
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L19-21)
```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    Ok(ledger_db.metadata_db().get_pruner_progress().unwrap_or(0))
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L162-170)
```rust
        if !readonly {
            if let Some(version) = myself.get_synced_version()? {
                myself
                    .ledger_pruner
                    .maybe_set_pruner_target_db_version(version);
                myself
                    .state_store
                    .state_kv_pruner
                    .maybe_set_pruner_target_db_version(version);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-270)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L277-280)
```rust
            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
            }
            self.error_if_ledger_pruned("Transaction", start_version)?;
```
