# Audit Report

## Title
Consensus Split Vulnerability During Rolling Upgrades Due to TransactionDeduperType Deserialization Failures

## Summary
A critical vulnerability exists where adding a new `TransactionDeduperType` enum variant and updating the on-chain configuration during a rolling upgrade causes validators with older binaries to silently fall back to a different deduper type. Since every validator independently deduplicates transactions during block execution, this creates a consensus split where different validators compute different state roots from the same proposed block.

## Finding Description

The vulnerability stems from the interaction between BCS deserialization error handling and the consensus execution pipeline:

**Enum Definition and Exhaustive Matching:**
The `TransactionDeduperType` enum is defined with two variants (`NoDedup` and `TxnHashAndAuthenticatorV1`). [1](#0-0) 

The `create_transaction_deduper()` function uses exhaustive pattern matching on this enum. [2](#0-1) 

**Silent Fallback Mechanism:**
When epoch transitions occur, validators attempt to deserialize the on-chain execution config. If deserialization fails (e.g., due to an unknown enum variant), the system logs a warning and falls back to `OnChainExecutionConfig::Missing`. [3](#0-2) 

The `Missing` variant is explicitly designed for backwards compatibility and maps to `TransactionDeduperType::TxnHashAndAuthenticatorV1`. [4](#0-3) 

**Universal Deduplication During Block Processing:**
The critical issue is that EVERY validator runs deduplication on EVERY block they receive. When a block is inserted for voting, the consensus pipeline builder is invoked. [5](#0-4) 

This spawns the prepare phase which calls transaction deduplication. [6](#0-5) 

The prepare phase executes `BlockPreparer::prepare_block()` which performs deduplication via `txn_deduper.dedup()`. [7](#0-6) 

**Attack Scenario:**
1. Developers add `TransactionDeduperType::TxnHashAndAuthenticatorV2` with different deduplication logic
2. New binary (N+1) is deployed to 40% of validators
3. Governance updates on-chain config to use V2
4. Validators with N+1: Successfully deserialize and create V2 deduper
5. Validators with N: Fail to deserialize, fall back to Missing â†’ V1 deduper
6. When processing the same block:
   - V1 deduper filters transactions differently than V2
   - Validators execute different transaction sets
   - Different state roots are computed
   - Consensus split occurs

## Impact Explanation

This vulnerability represents a **HIGH severity** issue under Aptos bug bounty criteria:

**Significant Protocol Violations:**
- Validators with different software versions compute different state roots for identical blocks
- This breaks the fundamental deterministic execution guarantee of the blockchain
- Creates temporary consensus split that can cause chain forks or liveness failures

**Validator Node Issues:**
- Nodes produce conflicting votes on the same block
- Quorum formation may fail during the mixed-version window
- Network operates in an inconsistent state requiring emergency intervention

The impact is not Critical because:
- No direct fund theft or permanent loss occurs
- Recoverable through coordinated validator rollback or emergency upgrade completion
- Temporary rather than permanent network failure
- Requires external coordination to resolve

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring during normal operations:

**Standard Operating Procedures:**
- Rolling upgrades are the standard deployment pattern for validator software updates
- On-chain governance regularly updates execution configurations
- The compatibility test suite validates rolling upgrades but does not test on-chain config updates during partial deployments

**No Protective Mechanisms:**
- No version gating prevents governance from updating configs before all validators upgrade
- The silent fallback behavior masks the issue with only a warning log
- No compile-time or runtime checks enforce that all validators must use the same deduper

**Automatic Triggering:**
- Happens automatically without malicious intent
- Any new `TransactionDeduperType` variant introduction triggers the vulnerability
- Requires only normal governance process and rolling upgrade timing overlap

## Recommendation

Implement one or more of the following mitigations:

1. **Version Gating for Config Updates:**
   - Add validator version tracking to on-chain state
   - Require minimum validator version percentage before allowing config updates
   - Reject governance proposals that update deduper types during rolling upgrades

2. **Fail-Safe Fallback:**
   - Instead of falling back to `Missing`, validators should refuse to participate in consensus when they cannot deserialize critical execution configs
   - Log critical error and wait for operator intervention

3. **Backwards-Compatible Enum Extension:**
   - When adding new deduper types, ensure the new variant produces identical results to V1 for a transition period
   - Use feature flags to enable divergent behavior only after all validators upgrade

4. **Explicit Version Checking:**
   ```rust
   pub fn transaction_deduper_type(&self) -> Result<TransactionDeduperType> {
       match &self {
           OnChainExecutionConfig::Missing => Ok(TransactionDeduperType::TxnHashAndAuthenticatorV1),
           // ... other variants
           _ => Err(anyhow!("Unsupported execution config version - upgrade required"))
       }
   }
   ```

## Proof of Concept

A complete PoC would require:
1. Modifying `TransactionDeduperType` to add a third variant
2. Implementing a deduper with different logic (e.g., more aggressive filtering)
3. Deploying mixed validator set with old/new binaries
4. Updating on-chain config via governance
5. Observing state root divergence on block execution

The vulnerability path is fully validated through code analysis showing that every validator independently deduplicates transactions during the prepare phase, creating the conditions for consensus split when deduplicate logic differs.

## Notes

The backwards compatibility mechanism (the `Missing` variant) is intentionally designed for replay compatibility as documented in the code comments. [8](#0-7)  However, this design creates a vulnerability during rolling upgrades when combined with on-chain config updates that introduce new enum variants.

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L16-18)
```rust
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
    Missing,
```

**File:** types/src/on_chain_config/execution_config.rs (L108-111)
```rust
    pub fn transaction_deduper_type(&self) -> TransactionDeduperType {
        match &self {
            // Note, this behavior was enabled before OnChainExecutionConfig was registered.
            OnChainExecutionConfig::Missing => TransactionDeduperType::TxnHashAndAuthenticatorV1,
```

**File:** types/src/on_chain_config/execution_config.rs (L265-270)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum TransactionDeduperType {
    NoDedup,
    TxnHashAndAuthenticatorV1,
}
```

**File:** consensus/src/transaction_deduper.rs (L23-33)
```rust
pub fn create_transaction_deduper(
    deduper_type: TransactionDeduperType,
) -> Arc<dyn TransactionDeduper> {
    match deduper_type {
        TransactionDeduperType::NoDedup => Arc::new(NoOpDeduper {}),
        TransactionDeduperType::TxnHashAndAuthenticatorV1 => {
            info!("Using simple hash set transaction deduper");
            Arc::new(TxnHashAndAuthenticatorDeduper::new())
        },
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1191-1203)
```rust
        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** consensus/src/block_storage/block_store.rs (L490-496)
```rust
            pipeline_builder.build_for_consensus(
                &pipelined_block,
                parent_block.pipeline_futs().ok_or_else(|| {
                    anyhow::anyhow!("Parent future doesn't exist, potentially epoch ended")
                })?,
                callback,
            );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L472-475)
```rust
        let prepare_fut = spawn_shared_fut(
            Self::prepare(decryption_fut, self.block_preparer.clone(), block.clone()),
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/block_preparer.rs (L99-99)
```rust
            let deduped_txns = txn_deduper.dedup(filtered_txns);
```
