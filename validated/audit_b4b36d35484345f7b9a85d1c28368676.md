# Audit Report

## Title
Incomplete CompilationMetadata Verification Allows Deployment of Unstable Bytecode to Mainnet

## Summary
The Aptos VM's bytecode verification system fails to validate the integrity of `CompilationMetadata` version strings against the `unstable` flag. An attacker can compile Move modules with experimental language features (V2.4, V2.5), manually modify the serialized metadata to falsely claim stability, and successfully deploy to mainnet, bypassing the intended security control that restricts untested bytecode from production networks.

## Finding Description

The `CompilationMetadata` structure contains three fields designed to track compilation stability: [1](#0-0) 

During legitimate compilation, the `unstable` flag is correctly set based on whether compiler or language versions are experimental: [2](#0-1) 

Language versions V2.4 and V2.5 are explicitly marked as unstable: [3](#0-2) 

The VM's mainnet protection mechanism only validates the boolean `unstable` field: [4](#0-3) 

**The Critical Flaw**: The VM never cross-validates that the `unstable` flag matches the actual `compiler_version` and `language_version` strings. The parsing methods exist to convert strings back to enums: [5](#0-4) 

However, systematic grep search confirms these methods are **never called** during VM validation (0 occurrences of `metadata.compiler_version()` or `metadata.language_version()` in validation code).

The metadata format checking only validates deserialization and duplicate keys, not semantic correctness: [6](#0-5) 

**Attack Execution Path**:

1. Attacker compiles Move code with unstable language version (e.g., V2.5)
2. Compiler correctly generates: `{unstable: true, compiler_version: "2.0", language_version: "2.5"}`
3. Attacker deserializes the `CompiledModule` (standard operation demonstrated in tests): [7](#0-6) 

4. Attacker modifies `CompilationMetadata` to: `{unstable: false, compiler_version: "2.0", language_version: "2.5"}`
5. Re-serializes and submits via `code_publish_package_txn`
6. VM calls `reject_unstable_bytecode()` which only checks the boolean flag
7. Since `unstable: false`, deployment succeeds despite containing V2.5 experimental features

## Impact Explanation

**Severity: HIGH** 

This vulnerability bypasses a critical security control designed to protect mainnet from experimental, potentially unsafe bytecode. The impact categories include:

1. **Security Control Bypass**: The unstable bytecode rejection mechanism is completely circumvented, allowing any experimental language features onto mainnet

2. **Potential Consensus/Safety Violations**: Unstable language versions (V2.4, V2.5) contain experimental features that have not been validated for production consensus safety. These features may exhibit non-deterministic behavior across different validator implementations or configurations, potentially causing state divergence

3. **Network-Wide Risk**: A single malicious module with unstable features could affect all validators processing transactions that interact with it

The validation logic is called during module publishing: [8](#0-7) 

## Likelihood Explanation

**Likelihood: HIGH**

The attack is straightforward to execute:

- **No Special Privileges**: Any user can submit module publishing transactions
- **Simple Tooling**: `CompiledModule::deserialize()` and `serialize()` are public APIs
- **BCS Manipulation**: The `CompilationMetadata` is standard BCS-serialized data, easily modifiable
- **No Integrity Protection**: No cryptographic signatures or hashes protect metadata integrity
- **Validation Gap**: The vulnerability is in the validation logic itself, not a race condition

The existing test suite validates legitimately compiled unstable bytecode rejection: [9](#0-8) 

However, these tests do not cover scenarios where attackers manually falsify metadata post-compilation.

## Recommendation

Add cross-validation in `reject_unstable_bytecode()` to verify the `unstable` flag matches the actual version strings:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            if let Some(metadata) = get_compilation_metadata(module) {
                // Existing check
                if metadata.unstable {
                    return Err(/*...*/);
                }
                
                // NEW: Cross-validate version strings
                if let (Ok(compiler_ver), Ok(lang_ver)) = 
                    (metadata.compiler_version(), metadata.language_version()) {
                    if compiler_ver.unstable() || lang_ver.unstable() {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message("version strings indicate unstable code".to_string())
                            .finish(Location::Undefined));
                    }
                }
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script()`.

## Proof of Concept

```rust
#[test]
fn test_falsified_compilation_metadata() {
    let mut h = MoveHarness::new();
    h.set_resource(CORE_CODE_ADDRESS, ChainId::struct_tag(), &ChainId::mainnet().id());
    
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Compile with unstable language version
    let package = BuiltPackage::build(path, BuildOptions {
        language_version: Some(LanguageVersion::V2_5), // unstable
        ..BuildOptions::default()
    }).unwrap();
    
    let mut compiled_module = CompiledModule::deserialize(&package.extract_code()[0]).unwrap();
    
    // Find and modify CompilationMetadata
    for metadata in &mut compiled_module.metadata {
        if metadata.key == *COMPILATION_METADATA_KEY {
            let mut comp_meta: CompilationMetadata = bcs::from_bytes(&metadata.value).unwrap();
            // Falsify the unstable flag while keeping V2.5 version string
            comp_meta.unstable = false; // ATTACK: Set to false despite V2.5
            metadata.value = bcs::to_bytes(&comp_meta).unwrap();
            break;
        }
    }
    
    let mut modified_code = vec![];
    compiled_module.serialize(&mut modified_code).unwrap();
    
    // This should fail but currently succeeds on mainnet
    let result = h.run_transaction_payload_mainnet(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            vec![modified_code],
        ),
    );
    
    // Currently passes (vulnerability), should return UNSTABLE_BYTECODE_REJECTED
    assert_vm_status!(result, StatusCode::UNSTABLE_BYTECODE_REJECTED);
}
```

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** third_party/move/move-model/src/metadata.rs (L65-71)
```rust
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L73-79)
```rust
    pub fn compiler_version(&self) -> anyhow::Result<CompilerVersion> {
        CompilerVersion::from_str(&self.compiler_version)
    }

    pub fn language_version(&self) -> anyhow::Result<LanguageVersion> {
        LanguageVersion::from_str(&self.language_version)
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1679-1716)
```rust
    /// Validate a publish request.
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L123-127)
```rust
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L303-331)
```rust
#[test]
fn test_compilation_metadata_for_script() {
    // run unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_script_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // run stable compiler code to mainnet
    assert_success!(test_compilation_metadata_script_internal(true, false,));
    // run unstable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, true,));
    // run stable compiler code to test
    assert_success!(test_compilation_metadata_script_internal(false, false,));
}

#[test]
fn test_compilation_metadata() {
    // publish unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // publish stable compiler code to mainnet
    assert_success!(test_compilation_metadata_internal(true, false,));
    // publish unstable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, true,));
    // publish stable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, false,));
}
```
