# Audit Report

## Title
Governance Proposals Race Condition Causes JWK Patch State Corruption via Complete Replacement

## Summary
Multiple governance proposals modifying JWK patches can execute in the same block due to BlockSTM parallel execution. The `set_patches` function performs complete replacement rather than merging, causing the last proposal to overwrite previous proposals' patches, resulting in loss of approved governance decisions.

## Finding Description

The vulnerability exists in the JWK patch governance mechanism where `set_patches` performs a complete replacement of the global `Patches` resource. [1](#0-0) 

This function directly assigns the patches vector, replacing all existing patches rather than merging with them. The `Patches` resource is a singleton stored at `@aptos_framework`: [2](#0-1) 

**Attack Scenario:**

Two independent governance proposals (Proposal A with ID=100 adding `[PatchA1, PatchA2]` and Proposal B with ID=101 adding `[PatchB1]`) are approved and ready to resolve. Each proposal has its own `is_resolved` flag that only prevents the same proposal from being resolved twice: [3](#0-2) 

When two separate script transactions resolve these proposals in the same block:
- Transaction A resolves Proposal 100, calls `set_patches(fx, [PatchA1, PatchA2])`
- Transaction B resolves Proposal 101, calls `set_patches(fx, [PatchB1])`

BlockSTM's parallel execution causes Transaction B to validate after Transaction A commits, detect the `Patches` resource modification, and re-execute. During re-execution, Transaction B reads the new state but still performs complete replacement, resulting in `Patches.patches = [PatchB1]` and losing `[PatchA1, PatchA2]`.

The `regenerate_patched_jwks()` function then applies only Proposal B's patches: [4](#0-3) 

Test evidence confirms this complete replacement behavior: [5](#0-4) 

## Impact Explanation

This qualifies as **MEDIUM severity** per Aptos bug bounty criteria under "Limited Protocol Violations":

1. **Governance Integrity Violation**: Approved governance proposals lose their effect. If Proposal A addressed a critical security issue (e.g., removing a compromised JWK) and Proposal B was routine, the security-critical operation is lost.

2. **State Inconsistency**: The final JWK state doesn't reflect all approved governance decisions. While deterministic across validators, it violates semantic correctness - the state doesn't reflect governance intent.

3. **Authentication Impact**: JWK patches control OIDC authentication for keyless accounts. Loss of security-critical patches could have authentication implications.

4. **No Consensus Break**: This does NOT break consensus - all validators reach the same state deterministically. It's a governance semantic issue, not a consensus safety violation.

## Likelihood Explanation

**Likelihood: MEDIUM**

- **Natural Occurrence**: Can happen without malicious intent when legitimate governance participants independently resolve approved proposals
- **No Coordination Mechanism**: No locking, queuing, or serialization prevents concurrent `set_patches` calls
- **Realistic Scenario**: Proposals accumulate during voting periods; multiple can be ready to resolve simultaneously
- **BlockSTM Enabled**: Parallel execution is enabled by default, allowing this scenario to manifest
- **Public Resolution**: Governance resolution functions are public; anyone can submit resolve transactions once proposals pass [6](#0-5) 

## Recommendation

Implement one of the following solutions:

1. **Merge Semantics**: Modify `set_patches` to merge new patches with existing ones instead of replacement
2. **Global Lock**: Add a global governance execution lock to serialize proposal resolutions
3. **Proposal Queue**: Implement a queue mechanism ensuring proposals execute sequentially
4. **Atomic Batch**: Allow grouping multiple patch updates into a single proposal

Example fix for merge semantics:
```move
public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    let existing_patches = &mut borrow_global_mut<Patches>(@aptos_framework).patches;
    vector::append(existing_patches, patches);
    regenerate_patched_jwks();
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_concurrent_patch_proposals(aptos_framework: &signer) {
    // Initialize JWK system
    initialize_for_test(aptos_framework);
    
    // Simulate Proposal A: Set patches [PatchA1, PatchA2]
    let patch_a1 = new_patch_upsert_jwk(b"issuer_a", new_unsupported_jwk(b"key_a1", b"data_a1"));
    let patch_a2 = new_patch_upsert_jwk(b"issuer_a", new_unsupported_jwk(b"key_a2", b"data_a2"));
    set_patches(aptos_framework, vector[patch_a1, patch_a2]);
    
    // Verify Proposal A's patches are set
    let patches_after_a = borrow_global<Patches>(@aptos_framework);
    assert!(vector::length(&patches_after_a.patches) == 2, 1);
    
    // Simulate Proposal B: Set patches [PatchB1] (in same block via BlockSTM re-execution)
    let patch_b1 = new_patch_upsert_jwk(b"issuer_b", new_unsupported_jwk(b"key_b1", b"data_b1"));
    set_patches(aptos_framework, vector[patch_b1]);
    
    // BUG: Proposal A's patches are lost, only Proposal B's patches remain
    let patches_final = borrow_global<Patches>(@aptos_framework);
    assert!(vector::length(&patches_final.patches) == 1, 2); // Only 1 patch, not 3
}
```

## Notes

This vulnerability does not break consensus or enable direct fund theft, but violates governance integrity guarantees. The complete replacement semantic appears intentional per the test suite, but the lack of serialization for concurrent proposals creates a governance correctness issue where approved decisions are lost.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L160-162)
```text
    struct Patches has key {
        patches: vector<Patch>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L996-1015)
```text
        set_patches(&aptos_framework, vector[
            new_patch_remove_issuer(b"bob"),
        ]);
        assert!(option::none() == try_get_patched_jwk(b"bob", b"key_id_3"), 1);

        // Update one of Bob's key..
        set_patches(&aptos_framework, vector[
            new_patch_upsert_jwk(b"bob", jwk_3b),
        ]);
        assert!(jwk_3b == get_patched_jwk(b"bob", b"key_id_3"), 1);
        assert!(option::some(jwk_3b) == try_get_patched_jwk(b"bob", b"key_id_3"), 1);

        // Wipe everything, then add some keys back.
        set_patches(&aptos_framework, vector[
            new_patch_remove_all(),
            new_patch_upsert_jwk(b"alice", jwk_1),
            new_patch_upsert_jwk(b"bob", jwk_3),
        ]);
        assert!(jwk_3 == get_patched_jwk(b"bob", b"key_id_3"), 1);
        assert!(option::some(jwk_3) == try_get_patched_jwk(b"bob", b"key_id_3"), 1);
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L431-451)
```text
    fun is_proposal_resolvable<ProposalType: store>(
        voting_forum_address: address,
        proposal_id: u64,
    ) acquires VotingForum {
        let proposal_state = get_proposal_state<ProposalType>(voting_forum_address, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_state(EPROPOSAL_CANNOT_BE_RESOLVED));

        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);
        assert!(!proposal.is_resolved, error::invalid_state(EPROPOSAL_ALREADY_RESOLVED));

        // We need to make sure that the resolution is happening in
        // a separate transaction from the last vote to guard against any potential flashloan attacks.
        let resolvable_time = to_u64(*simple_map::borrow(&proposal.metadata, &utf8(RESOLVABLE_TIME_METADATA_KEY)));
        assert!(timestamp::now_seconds() > resolvable_time, error::invalid_state(ERESOLUTION_CANNOT_BE_ATOMIC));

        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L634-641)
```text
    public fun resolve(
        proposal_id: u64,
        signer_address: address
    ): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {
        voting::resolve<GovernanceProposal>(@aptos_framework, proposal_id);
        remove_approved_hash(proposal_id);
        get_signer(signer_address)
    }
```
