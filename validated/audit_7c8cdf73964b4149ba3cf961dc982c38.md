# Audit Report

## Title
Unstable Bytecode Validation Bypass via Empty Metadata Slice

## Summary
A logic vulnerability in the module publishing validation flow allows attackers to bypass the mainnet unstable bytecode rejection check by stripping all metadata from compiled modules. This enables deployment of modules compiled with unstable compiler/language versions to production networks, violating the explicit security policy that "only stable versions are allowed on production networks."

## Finding Description

The Aptos VM's module publishing validation contains a critical logic flaw where empty metadata is treated as safe rather than suspicious, allowing security checks to be bypassed.

**Technical Analysis:**

The `check_metadata_format()` function iterates over the module's metadata vector and performs validation on each entry. When the metadata vector is empty, the loop executes zero iterations and returns `Ok(())` without any validation. [1](#0-0) 

The `verify_module_metadata_for_module_publishing()` function calls `get_metadata_from_compiled_code()` which searches for Aptos-specific metadata keys. When no metadata exists, this returns `None`, causing an early return with `Ok(())`. [2](#0-1) [3](#0-2) 

Most critically, the `reject_unstable_bytecode()` function only checks for unstable compilation metadata when it exists. The function uses `if let Some(metadata) = get_compilation_metadata(module)` pattern, which silently passes when metadata is absent. [4](#0-3) 

The `get_compilation_metadata()` function returns `None` when the metadata vector is empty or lacks the compilation metadata key. [5](#0-4) 

**Attack Vector:**

The `CompiledModule` struct's metadata field is publicly accessible, enabling direct manipulation. [6](#0-5) 

The Move compiler always adds `CompilationMetadata` to every compiled module during bytecode generation, making the absence of metadata an abnormal state that should trigger rejection. [7](#0-6) 

**Exploitation Path:**
1. Compile Move code with unstable compiler version (V2_1) or unstable language versions (V2_4, V2_5)
2. The compiler sets `CompilationMetadata.unstable = true` based on version checks [8](#0-7) 
3. Deserialize the `CompiledModule` and set `metadata = vec![]`
4. Re-serialize and publish to mainnet via standard publishing transaction
5. All validation checks pass, deploying unstable bytecode

**Policy Violation:**

The explicit security policy states that unstable versions should not be allowed on production networks. [9](#0-8) 

Unstable compiler versions are explicitly marked to prevent mainnet deployment. [10](#0-9) 

Unstable language versions are similarly restricted. [11](#0-10) 

## Impact Explanation

This vulnerability qualifies as **MEDIUM to HIGH severity** under Aptos bug bounty criteria for "Limited Protocol Violations" to "Significant Protocol Violations."

**Confirmed Impacts:**

1. **Protocol Policy Bypass**: Directly violates the documented security requirement that only stable, production-ready compiler and language versions should run on mainnet. This policy exists to ensure code reliability and prevent deployment of features that haven't completed full testing cycles.

2. **Security Guarantee Violation**: The validation flow's security guarantee is that unstable bytecode cannot be deployed to mainnet. This guarantee is completely bypassed.

**Potential Impacts:**

3. **Unstable Feature Risks**: Unstable compiler/language versions may contain:
   - Bugs in new optimization passes that could produce incorrect bytecode
   - Unfinished language features with edge cases
   - Breaking changes that haven't been finalized
   - Features that haven't undergone full security review

4. **Operational Risks**: If unstable versions contain bugs, deployed modules could exhibit unexpected behavior requiring emergency intervention or governance actions.

While the Move VM's deterministic execution provides some protection, the explicit policy exists because unstable versions are not production-ready and may have issues that haven't been discovered through full testing and review cycles.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly exploitable:

1. **Trivial Technical Complexity**: Requires only basic operations available in standard Move tooling - deserialize compiled module, modify public field, re-serialize. No deep VM internals knowledge required.

2. **No Privilege Requirements**: Any user can publish modules to their own account address. No validator status, governance role, or special permissions needed.

3. **Strong Attacker Motivation**: Developers may want to use latest language features immediately without waiting for stable release cycles, providing economic incentive to bypass the check.

4. **Low Detection Probability**: Empty metadata appears valid to all current validation checks. No monitoring or alerting exists for this anomaly.

5. **No Alternative Defenses**: The unstable bytecode check is the sole protection mechanism. Once bypassed, no other validation catches this violation.

Existing test coverage validates that unstable code is properly rejected when metadata is present, but no tests exist for the empty metadata edge case. [12](#0-11) 

## Recommendation

Implement defense-in-depth by treating absent metadata as a validation failure rather than success:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message("compilation metadata required for mainnet deployment".to_string())
                    .finish(Location::Undefined)
            })?;
            
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message("code marked unstable is not published on mainnet".to_string())
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Additionally, enhance `check_metadata_format()` to explicitly require compilation metadata for mainnet deployments.

## Proof of Concept

```rust
use aptos_types::chain_id::ChainId;
use move_binary_format::CompiledModule;
use move_core_types::metadata::Metadata;
use move_model::metadata::{CompilationMetadata, CompilerVersion, COMPILATION_METADATA_KEY};

#[test]
fn test_unstable_bytecode_bypass_via_empty_metadata() {
    // 1. Compile module with unstable compiler version
    let package = build_package_with_compiler_version(CompilerVersion::V2_1);
    let code = package.extract_code()[0].clone();
    
    // 2. Deserialize and verify it has unstable metadata
    let mut module = CompiledModule::deserialize(&code).unwrap();
    let original_metadata = get_compilation_metadata(&module).unwrap();
    assert!(original_metadata.unstable, "Module should be marked unstable");
    
    // 3. Strip all metadata
    module.metadata = vec![];
    
    // 4. Re-serialize
    let mut modified_code = vec![];
    module.serialize(&mut modified_code).unwrap();
    
    // 5. Attempt to publish on mainnet
    let mut harness = MoveHarness::new_with_chain_id(ChainId::mainnet());
    let account = harness.new_account_at(AccountAddress::random());
    
    // 6. Publishing should succeed (demonstrating the vulnerability)
    let result = harness.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).unwrap(),
            vec![modified_code],
        ),
    );
    
    // This should fail but passes, proving the bypass
    assert_success!(result);
}
```

**Notes:**
- The validation logic flaw is a "fail-open" design where absence of evidence (no metadata) is incorrectly treated as evidence of absence (not unstable)
- The correct approach is "fail-closed" where missing required metadata should trigger rejection
- This represents a fundamental security principle violation: validation should be explicit, not implicit

### Citations

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L287-307)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
```

**File:** types/src/vm/module_metadata.rs (L311-316)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
```

**File:** types/src/vm/module_metadata.rs (L452-455)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3467-3467)
```rust
    pub metadata: Vec<Metadata>,
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L165-174)
```rust
        let compilation_metadata = CompilationMetadata::new(compiler_version, language_version);
        let metadata = Metadata {
            key: COMPILATION_METADATA_KEY.to_vec(),
            value: bcs::to_bytes(&compilation_metadata)
                .expect("Serialization of CompilationMetadata should succeed"),
        };
        let module = move_binary_format::CompiledModule {
            version: file_format_common::VERSION_MAX,
            self_module_handle_idx: FF::ModuleHandleIndex(0),
            metadata: vec![metadata],
```

**File:** third_party/move/move-model/src/metadata.rs (L19-20)
```rust
/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
```

**File:** third_party/move/move-model/src/metadata.rs (L65-71)
```rust
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L149-157)
```rust
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-293)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L319-330)
```rust
fn test_compilation_metadata() {
    // publish unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // publish stable compiler code to mainnet
    assert_success!(test_compilation_metadata_internal(true, false,));
    // publish unstable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, true,));
    // publish stable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, false,));
```
