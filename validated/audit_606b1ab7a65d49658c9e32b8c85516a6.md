# Audit Report

## Title
Staking Lockup Bypass in Vesting Contracts Due to Uninitialized Lockup Period

## Summary
Vesting contracts create underlying stake pools with `locked_until_secs = 0` and never initialize the staking lockup period. For INACTIVE stake pools, this allows shareholders to immediately withdraw vested coins by exploiting an edge case in `withdraw_with_cap`, completely bypassing the intended staking lockup mechanism.

## Finding Description

The vesting contract system implements two-tier locking: **vesting lockup** and **staking lockup**. The documentation explicitly states: "After the unlocked rewards become fully withdrawable (as it's subject to staking lockup), shareholders can call distribute()." [1](#0-0) 

However, this guarantee is violated due to the following:

**Root Cause**: When a stake pool is initialized through `initialize_owner`, it creates a `StakePool` with `locked_until_secs: 0`. [2](#0-1) 

The vesting contract creation flow calls `create_staking_contract_with_coins` [3](#0-2)  which calls `create_stake_pool` [4](#0-3)  which ultimately invokes `initialize_owner` [5](#0-4)  but never calls `reset_lockup()` to set an actual lockup period.

**No Automatic Renewal**: For ACTIVE validators, lockup is automatically renewed during `on_new_epoch` when their stake pool is in the active validator set. [6](#0-5)  However, vesting contracts typically create INACTIVE stake pools that never join the validator set, so this automatic renewal never applies.

**Edge Case Exploitation**: When shareholders call `distribute()`, it eventually calls `withdraw_with_cap()`, which contains an edge case for INACTIVE validators: [7](#0-6) 

This edge case immediately moves all `pending_inactive` stake to `inactive` if the validator status is INACTIVE [8](#0-7)  and current time >= `locked_until_secs` (always true when `locked_until_secs = 0`).

**Attack Flow**:
1. Admin creates vesting contract → underlying stake pool has `locked_until_secs = 0`, status INACTIVE
2. After vesting period passes, shareholder calls `vest()` [9](#0-8)  which moves vested coins to `pending_inactive`
3. Shareholder immediately calls `distribute()` [10](#0-9)  → `withdraw_stake()` [11](#0-10)  → `staking_contract::distribute()` [12](#0-11)  → edge case triggers → coins withdrawn

## Impact Explanation

**Severity: MEDIUM-HIGH** - Limited Protocol Violation

This vulnerability violates a documented security guarantee of the vesting system. According to the Aptos bug bounty framework, this qualifies as a "Limited Protocol Violation" (MEDIUM severity) because:

1. **Protocol Violation**: The documented two-tier locking mechanism is bypassed for the staking lockup component
2. **Premature Fund Access**: Shareholders can access their own vested funds immediately after they vest, without waiting for any staking lockup period to expire
3. **Affects Common Configurations**: Any INACTIVE vesting contract (those not running validators) that doesn't manually call `reset_lockup()` after creation is vulnerable
4. **No Code Enforcement**: There is no code enforcement or clear documentation requiring admins to call `reset_lockup()` after contract creation

While this doesn't constitute direct theft (shareholders access their own funds) or consensus violations (no impact on validator set or block production), it represents a significant bypass of a documented security mechanism affecting a core protocol feature.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to occur because:

1. **No Special Permissions Required**: Any shareholder can trigger the exploit by calling standard public entry functions
2. **Trivial Execution**: Requires only two transaction calls (`vest()` and `distribute()`)
3. **Natural User Flow**: Shareholders would naturally call these functions to claim their vested tokens
4. **Common Configuration**: Vesting contracts that don't join the validator set (common scenario) remain INACTIVE
5. **No Visible Warning**: Neither code nor documentation indicates admins must call `reset_lockup()` after contract creation

## Recommendation

The `create_vesting_contract` function should automatically initialize the staking lockup period by calling `reset_lockup()` after creating the underlying staking contract. Alternatively, add explicit documentation and validation requiring admins to set a lockup period before any distributions can occur.

## Proof of Concept

A complete PoC would require setting up a vesting contract, waiting for the vesting period, then calling `vest()` followed immediately by `distribute()` to demonstrate immediate withdrawal without waiting for staking lockup. The key assertion would verify that `pending_inactive` stake becomes immediately withdrawable for INACTIVE stake pools with `locked_until_secs = 0`.

## Notes

- This vulnerability only affects INACTIVE stake pools (vesting contracts not participating as validators)
- ACTIVE validators automatically get lockup renewal and are not affected
- The edge case in `withdraw_with_cap` was designed to prevent stake from being stuck, but inadvertently enables this bypass for uninitialized lockup periods
- The admin's `reset_lockup()` function exists but is optional, not required during initialization

### Citations

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L17-18)
```text
/// 3. After the unlocked rewards become fully withdrawable (as it's subject to staking lockup), shareholders can call
/// distribute() to send all withdrawable funds to all shareholders based on the original grant's shares structure.
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L600-601)
```text
        let pool_address = staking_contract::create_staking_contract_with_coins(
            &contract_signer, operator, voter, grant, commission_percentage, contract_creation_seed);
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L717-717)
```text
        unlock_stake(vesting_contract, vested_amount);
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L760-760)
```text
        let coins = withdraw_stake(vesting_contract, contract_address);
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L1198-1198)
```text
        staking_contract::distribute(contract_address, vesting_contract.staking.operator);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L423-434)
```text
    /// Returns the validator's state.
    public fun get_validator_state(pool_address: address): u64 acquires ValidatorSet {
        let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
        if (option::is_some(&find_validator(&validator_set.pending_active, pool_address))) {
            VALIDATOR_STATUS_PENDING_ACTIVE
        } else if (option::is_some(&find_validator(&validator_set.active_validators, pool_address))) {
            VALIDATOR_STATUS_ACTIVE
        } else if (option::is_some(&find_validator(&validator_set.pending_inactive, pool_address))) {
            VALIDATOR_STATUS_PENDING_INACTIVE
        } else {
            VALIDATOR_STATUS_INACTIVE
        }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L648-648)
```text
        initialize_owner(owner);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L700-705)
```text
        move_to(owner, StakePool {
            active: coin::zero<AptosCoin>(),
            pending_active: coin::zero<AptosCoin>(),
            pending_inactive: coin::zero<AptosCoin>(),
            inactive: coin::zero<AptosCoin>(),
            locked_until_secs: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1177-1181)
```text
        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&
            timestamp::now_seconds() >= stake_pool.locked_until_secs) {
            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1435-1449)
```text
            // Automatically renew a validator's lockup for validators that will still be in the validator set in the
            // next epoch.
            let stake_pool = borrow_global_mut<StakePool>(validator_info.addr);
            let now_secs = timestamp::now_seconds();
            let reconfig_start_secs = if (chain_status::is_operating()) {
                get_reconfig_start_time_secs()
            } else {
                now_secs
            };
            if (stake_pool.locked_until_secs <= reconfig_start_secs) {
                spec {
                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;
                };
                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L948-950)
```text
            stake::withdraw_with_cap(
                &staking_contract.owner_cap, total_potential_withdrawable
            );
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1088-1088)
```text
        stake::initialize_stake_owner(&stake_pool_signer, 0, operator, voter);
```
