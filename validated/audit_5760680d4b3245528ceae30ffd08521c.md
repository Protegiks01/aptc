# Audit Report

## Title
Governance Vote Direction Manipulation via Partial Voting - Stake Pools Can Vote Both YES and NO on Same Proposal

## Summary
The `partial_vote()` function in Aptos Governance allows a stake pool to vote multiple times on the same proposal in different directions (both YES and NO), violating the fundamental governance invariant that each stake pool should commit to a single voting position. This enables manipulation of proposal outcomes by simultaneously inflating both yes and no vote counts.

## Finding Description

The vulnerability exists in how `VotingRecordsV2` tracks voting power usage. The system only records the total amount of voting power used by each stake pool per proposal, without tracking the direction (yes/no) of those votes. [1](#0-0) 

The `RecordKey` structure used to index voting records contains only the stake pool address and proposal ID, with no direction field: [2](#0-1) 

The `vote_internal` function calculates remaining voting power and updates used voting power without any direction tracking: [3](#0-2) 

Specifically, line 574 simply adds to the total used voting power regardless of direction: [4](#0-3) 

The `get_remaining_voting_power` function returns total remaining power without considering previous vote directions: [5](#0-4) 

The underlying `voting::vote` function adds votes to either `yes_votes` or `no_votes` based solely on the `should_pass` parameter: [6](#0-5) 

**Attack Path:**
1. Attacker controls a stake pool with 100 voting power
2. Calls `partial_vote(stake_pool, proposal_id, 50, true)` → adds 50 to yes_votes, records 50 power as used
3. `get_remaining_voting_power` returns 50 (100 - 50)
4. Calls `partial_vote(stake_pool, proposal_id, 50, false)` → adds 50 to no_votes, records 100 total power as used
5. Both votes are counted: proposal has +50 YES and +50 NO from the same stake pool

The existing test suite only verifies voting multiple times in the same direction: [7](#0-6) 

No test exists that validates prevention of voting in opposite directions, confirming this is an undetected vulnerability.

## Impact Explanation

**Severity: MEDIUM** - This constitutes a governance protocol violation that undermines governance integrity.

**Attack Scenarios:**
1. **Early Resolution Manipulation**: Attacker votes both YES and NO to artificially inflate total vote counts, potentially triggering early resolution thresholds prematurely
2. **Proposal Outcome Manipulation**: Near voting deadlines, attacker votes both ways to prevent clear majority formation or manipulate the yes/no ratio
3. **Governance Deadlock**: Multiple attackers voting both ways can create artificial contention on critical governance proposals
4. **Vote Count Inflation**: Absolute vote counts are manipulated, affecting governance metrics and participation tracking

This affects critical governance decisions including network parameter updates, framework upgrades, validator set changes, feature flag modifications, and staking configuration changes.

Per Aptos Bug Bounty categories, this falls under **MEDIUM severity** as a "Limited Protocol Violation" - it creates state inconsistencies and undermines governance integrity but does not directly cause fund loss, consensus failure, or network halt. While governance controls critical network operations, the direct impact is manipulation of the voting process rather than immediate critical system compromise.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is trivially exploitable.

**Attacker Requirements:**
- Control or be the delegated voter for any stake pool (common for validators and token holders)
- No special privileges beyond normal governance participation
- Attack executed via standard transaction submission

**Complexity: LOW**
- Two simple function calls to `partial_vote()` with opposite `should_pass` values
- No sophisticated timing or state manipulation required
- Works on any active proposal during voting period

The attack has no technical barriers and requires only basic governance participation rights that many network participants already possess.

## Recommendation

Modify `VotingRecordsV2` to track vote direction per stake pool per proposal. The fix should:

1. Update `RecordKey` to include vote direction or create separate tracking for yes/no votes:
```move
struct VoteRecord has store {
    yes_votes_used: u64,
    no_votes_used: u64,
}

struct VotingRecordsV2 has key {
    votes: SmartTable<RecordKey, VoteRecord>
}
```

2. In `vote_internal`, track direction-specific voting power:
```move
let vote_record = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, VoteRecord { yes_votes_used: 0, no_votes_used: 0 });
if (should_pass) {
    vote_record.yes_votes_used += voting_power;
} else {
    vote_record.no_votes_used += voting_power;
}
```

3. Update `get_remaining_voting_power` to consider both directions and return the minimum available power.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @345)]
public entry fun test_cannot_vote_in_opposite_directions(
    aptos_framework: signer,
    proposer: signer,
    voter_1: signer,
    voter_2: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
    let voter_1_addr = signer::address_of(&voter_1);
    
    create_proposal_for_test(&proposer, true);
    
    // Vote YES with 10 voting power
    partial_vote(&voter_1, voter_1_addr, 0, 10, true);
    assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 0);
    
    // Vote NO with remaining 10 voting power - this should succeed due to the bug
    partial_vote(&voter_1, voter_1_addr, 0, 10, false);
    
    // The stake pool has now voted both YES and NO on the same proposal
    // This violates the governance invariant but is currently allowed
}
```

This test demonstrates that a stake pool can successfully vote in both directions on the same proposal, confirming the vulnerability.

## Notes

This vulnerability represents a fundamental flaw in the governance vote tracking mechanism. The current implementation treats voting power as a fungible resource without direction constraints, allowing the same power to be allocated to opposing outcomes. This violates the core governance principle that each stake pool should commit to a single position per proposal. The fix requires architectural changes to track direction-specific vote allocations.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L93-96)
```text
    struct RecordKey has copy, drop, store {
        stake_pool: address,
        proposal_id: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L104-106)
```text
    struct VotingRecordsV2 has key {
        votes: SmartTable<RecordKey, u64>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L320-348)
```text
    public fun get_remaining_voting_power(
        stake_pool: address,
        proposal_id: u64
    ): u64 acquires VotingRecords, VotingRecordsV2 {
        assert_voting_initialization();

        let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(
            @aptos_framework,
            proposal_id
        );
        let lockup_until = stake::get_lockup_secs(stake_pool);
        // The voter's stake needs to be locked up at least as long as the proposal's expiration.
        // Also no one can vote on a expired proposal.
        if (proposal_expiration > lockup_until || timestamp::now_seconds() > proposal_expiration) {
            return 0
        };

        // If a stake pool has already voted on a proposal before partial governance voting is enabled, the stake pool
        // cannot vote on the proposal even after partial governance voting is enabled.
        if (has_entirely_voted(stake_pool, proposal_id)) {
            return 0
        };
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = *VotingRecordsV2[@aptos_framework].votes.borrow_with_default(record_key, &0);
        get_voting_power(stake_pool) - used_voting_power
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L539-604)
```text
    fun vote_internal(
        voter: &signer,
        stake_pool: address,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        permissioned_signer::assert_master_signer(voter);
        let voter_address = signer::address_of(voter);
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));

        assert_proposal_expiration(stake_pool, proposal_id);

        // If a stake pool has already voted on a proposal before partial governance voting is enabled,
        // `get_remaining_voting_power` returns 0.
        let staking_pool_voting_power = get_remaining_voting_power(stake_pool, proposal_id);
        voting_power = min(voting_power, staking_pool_voting_power);

        // Short-circuit if the voter has no voting power.
        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));

        voting::vote<GovernanceProposal>(
            &governance_proposal::create_empty_proposal(),
            @aptos_framework,
            proposal_id,
            voting_power,
            should_pass,
        );

        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                Vote {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        } else {
            let events = &mut GovernanceEvents[@aptos_framework];
            event::emit_event(
                &mut events.vote_events,
                VoteEvent {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        };

        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1074-1097)
```text
    public entry fun test_stake_pool_can_vote_on_partial_voting_proposal_many_times(
        aptos_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
        let execution_hash = vector[1];
        let proposer_addr = signer::address_of(&proposer);
        let voter_1_addr = signer::address_of(&voter_1);
        let voter_2_addr = signer::address_of(&voter_2);

        create_proposal_for_test(&proposer, true);

        partial_vote(&voter_1, voter_1_addr, 0, 5, true);
        partial_vote(&voter_1, voter_1_addr, 0, 3, true);
        partial_vote(&voter_1, voter_1_addr, 0, 2, true);

        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);
        assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 1);
        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);

        test_resolving_proposal_generic(aptos_framework, true, execution_hash);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L405-409)
```text
        if (should_pass) {
            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);
        } else {
            proposal.no_votes = proposal.no_votes + (num_votes as u128);
        };
```
