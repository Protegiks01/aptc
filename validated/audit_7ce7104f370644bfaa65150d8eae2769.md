# Audit Report

## Title
Consensus Disagreement in LeaderReputation Due to Database State Divergence When Switching Proposer Election Implementations

## Summary
When switching proposer election implementations to `LeaderReputation` with `ProposerAndVoterV2` at epoch boundaries, validators with different database sync states compute different root hashes for historical rounds. This causes validators to elect different proposers for the same round, preventing quorum formation and resulting in complete network halt.

## Finding Description

The vulnerability occurs in the `LeaderReputation` proposer election when `use_root_hash=true`, which is the default for `ProposerAndVoterV2`. The system uses historical block metadata to compute a root hash for weighted random proposer selection. [1](#0-0) 

The default consensus configuration uses `ProposerAndVoterV2`: [2](#0-1) 

When validators have different database states, the `get_block_metadata` method returns different results. When no historical events are found or the accumulator hash fetch fails, the function explicitly returns `HashValue::zero()`: [3](#0-2) [4](#0-3) [5](#0-4) 

This creates determinism breaks: validators with full historical data compute actual root hashes, while validators with pruned/incomplete databases compute `HashValue::zero()`. The code includes an explicit warning acknowledging this issue: [6](#0-5) 

These different root hashes are passed to `choose_index` for weighted random selection: [7](#0-6) 

When proposals arrive, validators validate them using `is_valid_proposer`, which checks if the proposer matches the locally-computed valid proposer: [8](#0-7) 

The `process_proposal` method rejects proposals from unexpected proposers: [9](#0-8) [10](#0-9) 

The `use_root_hash` flag is passed during `LeaderReputation` initialization: [11](#0-10) 

## Impact Explanation

This is a **Critical Severity** vulnerability under Aptos Bug Bounty criteria, specifically under **"Total Loss of Liveness/Network Availability (Critical)"**.

The vulnerability causes:

1. **Complete Network Halt**: When validator voting power is split between those with full history versus pruned history, neither group can form the required >2/3 quorum. All block production stops.

2. **No Byzantine Actors Required**: This affects honest validators behaving correctly but with different local database states—a scenario beyond what BFT consensus tolerates (< 1/3 Byzantine).

3. **Persistent Condition**: Unlike transient network issues, this persists until database states manually converge or configuration is rolled back.

4. **Triggered by Normal Operations**: Occurs during routine governance configuration changes, not malicious attacks.

This qualifies as Critical because it causes "Network halts due to protocol bug" and "All validators unable to progress"—meeting the exact criteria for Critical severity in the bug bounty program.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers when:

1. **Governance Config Change**: Network switches to `LeaderReputation(ProposerAndVoterV2)` via on-chain governance (standard operational procedure).

2. **Different Database States** (common scenarios):
   - New validators joining via state sync from checkpoints without full `NewBlockEvent` history
   - Validators with different pruning configurations (pruning is enabled in production)
   - Validators experiencing storage issues causing database query failures
   - Fast sync scenarios where recent state is downloaded without full history

3. **Default Configuration**: The default config uses `ProposerAndVoterV2` with `use_root_hash=true`, making this the standard production configuration.

The code's explicit warning message indicates developers recognize this scenario can occur in production, confirming it's a realistic operational risk.

## Recommendation

**Option 1: Remove Root Hash Dependency**
Revert to deterministic seed generation for proposer selection (like `ProposerAndVoter` V1) that doesn't depend on potentially-divergent database state:

```rust
let state = [
    self.epoch.to_le_bytes().to_vec(),
    round.to_le_bytes().to_vec(),
].concat();
```

**Option 2: Consensus-Agreed Root Hash**
Instead of querying local database, include the root hash in the block proposal itself, making it part of consensus-agreed state. This ensures all validators use identical root hashes for subsequent proposer elections.

**Option 3: Ensure Database Consistency**
Before epoch transitions that change proposer election type:
1. Halt block production temporarily
2. Verify all validators have synced required historical data
3. Only proceed when database states are consistent
4. Resume with new proposer election algorithm

**Option 4: Fallback to Deterministic Selection**
If `get_block_metadata` returns empty events or fails, fallback to deterministic proposer selection (round-robin) instead of using `HashValue::zero()` which creates divergence.

## Proof of Concept

This vulnerability manifests operationally rather than through a single code execution. A reproduction requires:

1. A test network with validators in different database states (some with full history, some with pruned/fast-synced state)
2. Governance proposal to switch from `RotatingProposer` to `LeaderReputation(ProposerAndVoterV2)`
3. Observation that validators compute different proposers and reject each other's proposals

The code paths demonstrated in the citations above confirm this behavior occurs as described, with explicit warning messages acknowledging the issue.

## Notes

This is a **liveness vulnerability**, not a safety vulnerability. It prevents the network from making progress (liveness) but does not cause conflicting blocks to be committed (safety). However, both qualify as Critical severity under the Aptos bug bounty program.

The explicit warning message "Elected proposers are unlikely to match!!" confirms developers are aware this scenario can occur, indicating it's a recognized operational risk rather than a theoretical concern. The severity remains Critical because it causes complete network halt requiring manual intervention or rollback to resolve.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L488-502)
```rust
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
```

**File:** types/src/on_chain_config/consensus_config.rs (L541-544)
```rust
    pub fn use_root_hash_for_seed(&self) -> bool {
        // all versions after V1 should use root hash
        !matches!(self, Self::ProposerAndVoter(_))
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L119-122)
```rust
                warn!(
                    "Local history is too old, asking for {} epoch and {} round, and latest from db is {} epoch and {} round! Elected proposers are unlikely to match!!",
                    target_epoch, target_round, events.first().map_or(0, |e| e.event.epoch()), events.first().map_or(0, |e| e.event.round()))
            }
```

**File:** consensus/src/liveness/leader_reputation.rs (L149-164)
```rust
        if result.is_empty() {
            warn!("No events in the requested window could be found");
            (result, HashValue::zero())
        } else {
            let root_hash = self
                .aptos_db
                .get_accumulator_root_hash(max_version)
                .unwrap_or_else(|_| {
                    error!(
                        "We couldn't fetch accumulator hash for the {} version, for {} epoch, {} round",
                        max_version, target_epoch, target_round,
                    );
                    HashValue::zero()
                });
            (result, root_hash)
        }
```

**File:** consensus/src/liveness/leader_reputation.rs (L183-183)
```rust
                return (vec![], HashValue::zero());
```

**File:** consensus/src/liveness/leader_reputation.rs (L208-208)
```rust
                    (vec![], HashValue::zero())
```

**File:** consensus/src/liveness/leader_reputation.rs (L717-733)
```rust
        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
        (proposers[chosen_index], voting_power_participation_ratio)
```

**File:** consensus/src/liveness/proposer_election.rs (L14-16)
```rust
    fn is_valid_proposer(&self, author: Author, round: Round) -> bool {
        self.get_valid_proposer(round) == author
    }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-60)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
```

**File:** consensus/src/epoch_manager.rs (L378-387)
```rust
                let proposer_election = Box::new(LeaderReputation::new(
                    epoch_state.epoch,
                    epoch_to_proposers,
                    voting_powers,
                    backend,
                    heuristic,
                    onchain_config.leader_reputation_exclude_round(),
                    leader_reputation_type.use_root_hash_for_seed(),
                    self.config.window_for_chain_health,
                ));
```
