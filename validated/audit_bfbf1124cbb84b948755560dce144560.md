# Audit Report

## Title
Test Poison Bypass in Move Compiler V2 Enables Unlimited Coin Minting Through Framework Test Functions

## Summary
A flag state mismatch in Move Compiler V2 causes test functions to be retained in compiled bytecode without adding the protective "test poison" function. This bypasses the security mechanism designed to prevent test-compiled modules from being deployed to production VMs. If Aptos framework modules are accidentally published with `--test` flag, test-only public functions like `stake::mint_coins()` would enable unlimited minting of AptosCoin, constituting a critical loss of funds vulnerability.

## Finding Description

The Move compiler implements a "test poison" mechanism to prevent modules compiled in test mode from being deployed to production VMs by injecting a dummy function that calls `create_signers_for_testing`, which only exists in test VMs. [1](#0-0) 

However, when using Move Compiler v2 with the `--test` flag, a critical flag state mismatch occurs:

**Flag Mismatch Flow:**

1. When `BuildConfig.test_mode = true`, flags are created via `Flags::testing()` with `test=true, keep_testing_functions=false` [2](#0-1) 

2. The `keep_testing_functions()` method returns `self.test || self.keep_testing_functions`, evaluating to `true` [3](#0-2) 

3. This `true` value is passed to compiler v2 as `compile_test_code` [4](#0-3) 

4. The model builder creates NEW flags starting from `Flags::model_compilation()` with `test=false, keep_testing_functions=true` [5](#0-4) 

5. These flags are passed to the legacy compiler for filtering, where the poison is only added when `is_testing()` returns `true` [6](#0-5) 

6. Since `is_testing()` only checks the `test` field (now `false`), the poison is NOT added [7](#0-6) 

7. Test functions are retained because `should_remove_node` only removes them when `keep_testing_functions()` returns `false` [8](#0-7) 

**Critical Security Impact:**

The Aptos framework contains dangerous `#[test_only]` `public` functions that would enable unlimited coin minting if published: [9](#0-8) 

The `mint_coins` function requires no signer and can mint arbitrary amounts of AptosCoin. If framework code compiled with `--test` is published, any external module can call `0x1::stake::mint_coins(amount)` to mint unlimited coins.

## Impact Explanation

This qualifies as **CRITICAL** severity per Aptos bug bounty criteria under "Loss of Funds (Critical): Unlimited minting capabilities."

If Aptos framework modules are accidentally published with the `--test` flag:
- The `stake::mint_coins()` function would be publicly callable without access controls
- Any attacker can deploy a malicious module that calls this function
- Unlimited AptosCoin can be minted, completely destroying the token economics
- This constitutes direct theft through inflation

The production VM validates that test natives don't exist via `assert_no_test_natives`: [10](#0-9) 

The test poison mechanism is the critical control preventing this scenario, and this bug disables that protection.

## Likelihood Explanation

While the bug triggers automatically when compiling with `--test` in compiler v2, exploitation requires the Aptos framework team to accidentally publish test-compiled bytecode through the governance process. This represents a defense-in-depth control failure rather than a directly exploitable vulnerability.

However, this is a **logic vulnerability** in a critical security mechanism. The test poison is specifically designed to prevent exactly this class of errors, and its failure creates a path to critical impact.

## Recommendation

Fix the flag state mismatch by ensuring the model builder preserves the original `test` flag value:

```rust
// In run_model_builder_in_compiler_mode
Flags::model_compilation()
    .set_verify(compile_verify_code)
    .set_keep_testing_functions(compile_test_code)
    .set_test(compile_test_code)  // ADD THIS LINE to preserve test flag
    // ... other settings
```

Alternatively, modify `filter_map_module` to check `keep_testing_functions()` instead of `is_testing()`:

```rust
// In filter_map_module
if !self.env.flags().keep_testing_functions() {
    return Some(module_def);
}
```

## Proof of Concept

1. Create framework module with test_only public function
2. Compile with `--test` flag using compiler v2
3. Verify bytecode contains test function but NOT poison function
4. Deploy malicious module calling the test function
5. Mint unlimited coins

The vulnerability is confirmed by code analysis showing the flag mismatch and the presence of dangerous test-only functions in the actual Aptos framework.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L48-50)
```rust
        if !self.env.flags().is_testing() {
            return Some(module_def);
        }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-169)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L414-419)
```rust
    pub fn testing() -> Self {
        Self {
            test: true,
            ..Self::empty()
        }
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L438-447)
```rust
    pub fn model_compilation() -> Self {
        Self {
            test: false,
            verify: true,
            shadow: true, // allows overlapping between sources and deps
            keep_testing_functions: true,
            lang_v2: true,
            ..Self::empty()
        }
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L474-476)
```rust
    pub fn is_testing(&self) -> bool {
        self.test
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L478-480)
```rust
    pub fn keep_testing_functions(&self) -> bool {
        self.test || self.keep_testing_functions
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L664-664)
```rust
                        compile_test_code: flags.keep_testing_functions(),
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L2001-2005)
```text
    #[test_only]
    public fun mint_coins(amount: u64): Coin<AptosCoin> acquires AptosCoinCapabilities {
        let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;
        coin::mint(amount, mint_cap)
    }
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```
