# Audit Report

## Title
Integer Underflow in DKG PVSS Schnorr Batch Verification Causes Validator Denial of Service

## Summary
The `pok_batch_verify` function contains an integer underflow vulnerability when processing empty proof vectors. A Byzantine validator can exploit this to crash debug-mode validators or hang release-mode validators during DKG transcript verification in block proposals.

## Finding Description

The vulnerability exists in the Schnorr proof batch verification logic used during DKG (Distributed Key Generation) PVSS (Publicly Verifiable Secret Sharing) transcript verification.

**Vulnerable Code Path:**

The integer underflow occurs in `pok_batch_verify()` when `n = 0`: [1](#0-0) 

With `n = 0`, the loop `for _ in 0..(n - 1)` evaluates to `0..(0 - 1)`, causing:
- **Debug mode**: Immediate panic with "attempt to subtract with overflow"
- **Release mode**: Wraps to `usize::MAX`, creating an effectively infinite loop

**Missing Validation:**

The `check_sizes()` method validates V, V_hat, R, R_hat, and C vector lengths but does NOT validate the `soks` vector: [2](#0-1) 

**Vulnerable Call Chain:**

When `batch_verify_soks()` receives an empty `soks` array, it creates an empty `poks` vector and passes it to `pok_batch_verify()`: [3](#0-2) 

**Attack Vector:**

The vulnerability is triggered when validators verify block proposals containing malicious DKG results. The verification path bypasses dealer set validation: [4](#0-3) 

This calls `verify_transcript_extra()` with `ensures_single_dealer = None`, which skips the empty dealer set check: [5](#0-4) 

Subsequently, `verify_transcript()` invokes the vulnerable PVSS verification: [6](#0-5) 

**Attack Flow:**

1. Byzantine validator crafts a PVSS transcript with empty `soks` vector, correctly sized V/C/R vectors, and `V[W]` set to identity
2. Transcript deserializes successfully (no non-empty `soks` requirement)
3. When selected as block proposer, includes malicious DKG result in block
4. Other validators receive block proposal and call `ValidatorTransaction::verify()`
5. Verification proceeds through `DKGTranscript::verify()` → `verify_transcript_extra(..., None)` → `verify_transcript()` → `batch_verify_soks()` → `pok_batch_verify()`
6. Integer underflow triggers, crashing/hanging validators

## Impact Explanation

**Severity: HIGH** - Validator Node Slowdowns/Crashes

This vulnerability enables a single Byzantine validator to:
- **Crash debug-mode validators**: Immediate panic and termination
- **Hang release-mode validators**: Validators enter an infinite loop becoming unresponsive
- **Disrupt consensus**: Affects block verification during critical epoch transitions

Per Aptos Bug Bounty categories, this qualifies as HIGH severity:
- "Validator node slowdowns" - release builds hang indefinitely (HIGH)
- "API crashes" - debug builds crash immediately (HIGH)

This breaks Byzantine fault tolerance by allowing a single malicious validator (<1/3) to incapacitate validators verifying their block proposals, potentially disrupting network availability during DKG phases.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is feasible for a Byzantine validator because:
1. **Simple payload construction**: Only requires empty vectors and identity elements
2. **Deterministic trigger**: Bug triggers reliably with crafted input
3. **Block proposer opportunity**: Attacker who becomes proposer can include malicious DKG result
4. **No cryptographic complexity**: No signature forgery required
5. **Affects all node types**: Both debug and release builds vulnerable

**Required conditions:**
- Attacker must be a validator (within 1/3 Byzantine threat model)
- Must be selected as block proposer (probabilistic but achievable)
- Must bypass own validation to include malicious DKG result in proposal

## Recommendation

Add validation to ensure `soks` vector is non-empty when `pk` is non-identity:

```rust
fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
    let W = sc.get_total_weight();
    
    // Existing checks...
    
    // Add validation for soks vector
    if self.V.last().unwrap() != &G1Projective::identity() && self.soks.is_empty() {
        bail!("Expected non-empty soks vector for non-identity dealt public key");
    }
    
    Ok(())
}
```

Additionally, fix the underflow by handling the empty case:

```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    
    // Handle empty case
    if n == 0 {
        return Ok(());
    }
    
    // Existing logic...
}
```

## Proof of Concept

The vulnerability can be demonstrated by constructing a transcript with empty `soks` and verifying it through the block proposal path, triggering the integer underflow in `pok_batch_verify()`.

## Notes

The vulnerability exists in the block proposal verification path, not the peer transcript aggregation path. During peer transcript verification, the `ensures_single_dealer` check would reject empty dealer sets. However, when verifying DKG results in block proposals, this check is bypassed (`ensures_single_dealer = None`), allowing the vulnerability to be triggered.

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L77-86)
```rust
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L56-76)
```rust
    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }

    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L312-316)
```rust
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
