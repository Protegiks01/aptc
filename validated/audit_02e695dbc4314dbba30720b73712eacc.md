# Audit Report

## Title
Unbounded State Sync Notification Channel Causes Memory Exhaustion in Consensus Observer

## Summary
The consensus observer uses an unbounded Tokio channel for state sync notifications that can accumulate unlimited notifications when async tasks complete faster than the observer can process them, leading to out-of-memory (OOM) crashes on validator fullnode (VFN) infrastructure.

## Finding Description

The consensus observer initializes two channels with asymmetric bounded/unbounded semantics. The `consensus_observer_message_receiver` is properly bounded at 1000 messages [1](#0-0) , created using `aptos_channel::new()` with `QueueStyle::FIFO` [2](#0-1) . However, the `state_sync_notification_listener` is created as an unbounded channel [3](#0-2) .

This unbounded channel receives `StateSyncNotification` messages from spawned async tasks when state sync operations complete. There are two notification sources:

1. **Fallback sync completions**: Spawned tasks send `FallbackSyncCompleted` notifications [4](#0-3) 

2. **Commit sync completions**: Spawned tasks send `CommitSyncCompleted` notifications [5](#0-4) 

**Vulnerability Attack Path:**

When the consensus observer receives commit decision messages, it checks whether to trigger state sync at lines 502-527 [6](#0-5) . The critical check at line 507 only prevents duplicate syncs when `is_syncing_through_epoch()` returns true, which only occurs for epoch transitions [7](#0-6) .

For same-epoch commits with increasing rounds, multiple `sync_to_commit()` calls can be triggered. Each call spawns an async task [8](#0-7)  that independently sends a notification upon completion [5](#0-4) . When a new sync replaces the task handle [9](#0-8) , the previous task may have already completed and sent its notification.

The main observer loop processes notifications sequentially [10](#0-9)  using slow async operations including `end_epoch().await`, `wait_for_epoch_start().await`, signature verification, and block ordering loops [11](#0-10) . If notifications arrive faster than processing completes, they accumulate unboundedly in memory.

## Impact Explanation

**High Severity** - This vulnerability directly maps to Aptos Bug Bounty HIGH severity categories:

1. **Validator Node Slowdowns**: Memory pressure from accumulating notifications degrades VFN performance, affecting consensus participation
2. **API Crashes**: OOM crashes terminate VFN nodes, disrupting network services

The consensus observer is enabled by default on validator fullnodes [12](#0-11) , making this a validator infrastructure vulnerability. If multiple VFNs crash simultaneously, it disrupts the validator ecosystem's ability to observe and sync consensus state.

The asymmetric protection is critical: the bounded `consensus_observer_message_receiver` protects against external network floods by dropping excess messages, but the unbounded internal channel lacks backpressure, allowing memory exhaustion from legitimate protocol operations triggered by external messages.

## Likelihood Explanation

**High Likelihood** - Multiple triggering scenarios exist:

1. **Natural Network Conditions**: During network congestion, epoch transitions, or catch-up scenarios, rapid commit decisions naturally arrive while the observer processes previous notifications
2. **Malicious Exploitation**: An untrusted network peer can deliberately send rapid commit decisions with increasing rounds in the same epoch to trigger repeated sync operations
3. **No Rate Limiting**: No backpressure mechanism exists on the unbounded channel
4. **Processing Bottleneck**: State sync notification processing involves inherently slow async operations (epoch transitions, signature verification, block ordering), creating a natural accumulation point

The check at line 507 only prevents syncs during epoch transitions, allowing multiple same-epoch syncs with different rounds to accumulate notifications without bounds.

## Recommendation

Replace the unbounded channel with a bounded channel and implement backpressure:

```rust
// In consensus_provider.rs, replace line 188-189:
let (state_sync_notification_sender, state_sync_notification_listener) =
    tokio::sync::mpsc::channel(1000); // Use bounded channel with appropriate size
```

Additionally, implement notification deduplication or cancellation when new syncs supersede old ones:

```rust
// In state_sync_manager.rs, track pending notifications and cancel obsolete ones
// when a new sync replaces the previous handle
```

## Proof of Concept

A full PoC would require setting up a test network environment with:
1. A consensus observer node with instrumented memory tracking
2. A malicious peer sending rapid commit decisions with increasing rounds
3. Monitoring showing unbounded channel growth and eventual OOM

The vulnerability is evidenced by the code analysis showing:
- Unbounded channel creation without backpressure
- Multiple sync triggering conditions bypassing the epoch check
- Sequential processing slower than potential notification arrival rate
- No deduplication or cancellation mechanism for superseded notifications

## Notes

This is a protocol-level vulnerability, not a simple network DoS. The bounded network channel already protects against message floods, but the unbounded internal notification channel creates an asymmetric vulnerability where legitimate protocol operations can exhaust memory. This maps to explicit HIGH severity categories in the Aptos Bug Bounty program ("Validator node slowdowns" and "API crashes") and affects critical validator infrastructure (VFNs).

### Citations

**File:** config/src/config/consensus_observer_config.rs (L68-68)
```rust
            max_network_channel_size: 1000,
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L94-98)
```rust
        let (observer_message_sender, observer_message_receiver) = aptos_channel::new(
            QueueStyle::FIFO,
            consensus_observer_config.max_network_channel_size as usize,
            None,
        );
```

**File:** consensus/src/consensus_provider.rs (L188-189)
```rust
    let (state_sync_notification_sender, state_sync_notification_listener) =
        tokio::sync::mpsc::unbounded_channel();
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L107-109)
```rust
    pub fn is_syncing_through_epoch(&self) -> bool {
        matches!(self.sync_to_commit_handle, Some((_, true)))
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L164-173)
```rust
                let state_sync_notification =
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info);
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for fallback! Error: {:?}",
                            error
                        ))
                    );
                }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L207-254)
```rust
        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }

                // Notify consensus observer that we've synced to the commit decision
                let state_sync_notification = StateSyncNotification::commit_sync_completed(
                    commit_decision.commit_proof().clone(),
                );
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for commit decision epoch: {:?}, round: {:?}! Error: {:?}",
                            commit_epoch, commit_round, error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    0, // We're no longer syncing to a commit decision
                );
            },
            abort_registration,
        ));
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L257-257)
```rust
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L502-527)
```rust
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1028-1044)
```rust
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1128-1141)
```rust
            tokio::select! {
                Some(network_message) = consensus_observer_message_receiver.next() => {
                    self.process_network_message(network_message).await;
                }
                Some(state_sync_notification) = state_sync_notification_listener.recv() => {
                    self.process_state_sync_notification(state_sync_notification).await;
                },
                _ = progress_check_interval.select_next_some() => {
                    self.check_progress().await;
                }
                else => {
                    break; // Exit the consensus observer loop
                }
            }
```
