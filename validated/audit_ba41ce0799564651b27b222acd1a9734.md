# Audit Report

## Title
Missing Gas Pre-Charge Enforcement Enables Test-and-Abort Attacks on Randomness API

## Summary
The Aptos randomness API is designed to prevent test-and-abort attacks by requiring transactions to pre-charge the maximum gas amount. However, the enforcement mechanism is not implemented in the transaction validation code, allowing attackers to repeatedly abort transactions after observing unfavorable random values while paying only minimal gas costs.

## Finding Description

The randomness system explicitly documents its security model: "Because we need to run a special transaction prologue to pre-charge maximum amount of gas, we require all callers to have an annotation that the entry function call is unbiasable." [1](#0-0) 

The complete infrastructure for this protection exists:

1. **On-chain configuration types**: `RequiredGasDeposit` and `AllowCustomMaxGasFlag` are defined to control deposit requirements. [2](#0-1) 

2. **VM configuration struct**: `RandomnessConfig` fetches these values from state. [3](#0-2) 

3. **Error code**: `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` is defined for validation failures. [4](#0-3) 

4. **Annotation extraction**: The VM extracts randomness annotations with `max_gas` declarations. [5](#0-4) 

**However, the enforcement is completely missing.** The `check_gas` function validates basic gas parameters but never checks `RandomnessConfig` or validates the required deposit against the transaction's `max_gas_amount`. [6](#0-5) 

When transactions abort, gas is charged using the standard epilogue mechanism that only bills for actual consumption: [7](#0-6) 

The test suite expects this validation to occur, checking for `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` errors: [8](#0-7) 

**Attack scenario:**
1. Attacker deploys a Move module with `#[randomness(max_gas=1000000)]`
2. Submit transaction with low `max_gas_amount` (e.g., 1000 gas units)
3. Call randomness API to obtain random value via `fetch_and_increment_txn_counter`
4. Check if value is favorable
5. If unfavorable, abort early (consuming ~100 gas units)
6. If favorable, continue execution

The attacker can probe the randomness space thousands of times for the cost of a single full execution, completely bypassing the economic disincentive mechanism.

## Impact Explanation

This constitutes a **High Severity** vulnerability under Aptos bug bounty criteria as it represents a "Significant protocol violation." The randomness API's fundamental security guarantee—prevention of biased randomness through mandatory gas pre-charging—is completely broken.

Concrete impacts include:
- **Gambling dapps**: Attackers can bias outcomes in their favor
- **NFT mints**: Attackers can selectively mint rare items
- **Lottery systems**: Attackers can manipulate winning probabilities  
- **Resource allocation**: Any randomness-based selection can be gamed

This undermines trust in the entire randomness infrastructure, affecting all applications that depend on unbiased randomness. The vulnerability breaks the stated security model rather than causing direct fund loss or consensus violations, placing it in the HIGH severity category.

## Likelihood Explanation

**Likelihood: High**

The attack has low barriers to entry:
- **No special privileges required**: Any user can submit transactions
- **Simple to exploit**: Deploy a module with conditional abort logic
- **Low cost**: Pay only for successful transactions, not failed attempts
- **No coordination needed**: Single-transaction attack
- **High incentive**: Substantial profit in high-value gambling/NFT scenarios

The presence of test infrastructure checking for the validation error indicates this feature was designed but never completed, making it a clear implementation gap rather than an intentional design decision.

## Recommendation

Implement the missing gas pre-charge validation in the `check_gas` function or add a new validation function that:

1. Fetches `RandomnessConfig` from state view
2. Extracts the randomness annotation from the entry function (if present)
3. Determines the required deposit:
   - If `allow_rand_contract_custom_max_gas` is true and annotation has `max_gas`, use that value
   - Otherwise, use `randomness_api_v0_required_deposit`
4. Validates that `txn_metadata.max_gas_amount()` meets the required deposit
5. Returns `VMStatus::error(StatusCode::REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS, None)` on failure

Additionally, ensure the prologue pre-charges the full deposit amount before executing the transaction, independent of actual gas consumption.

## Proof of Concept

```move
module attacker::biased_dice {
    use aptos_framework::randomness;
    
    #[randomness(max_gas=1000000)]
    entry fun roll_until_six() {
        let random_bytes = randomness::fetch_and_increment_txn_counter();
        let roll = (*vector::borrow(&random_bytes, 0) % 6) + 1;
        
        // Abort if not favorable, paying minimal gas
        assert!(roll == 6, 1);
        
        // Continue with favorable outcome
        // ... award prize/mint NFT/etc
    }
}
```

With current implementation: Attacker submits with `max_gas_amount=1000`. Failed attempts cost ~100 gas. Successful attempt costs full 1000 gas. Expected cost to get roll of 6: ~600 gas (6 attempts average × 100 gas).

With proper enforcement: Transaction would be rejected with `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` because `max_gas_amount=1000` < required deposit of `1000000`.

### Citations

**File:** aptos-move/framework/src/natives/randomness.rs (L105-107)
```rust
    // Because we need to run a special transaction prologue to pre-charge maximum
    // amount of gas, we require all callers to have an annotation that the entry
    // function call is unbiasable. This property is only checked at runtime here.
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_api_v0_config.move (L8-15)
```text
    struct RequiredGasDeposit has key, drop, store {
        gas_amount: Option<u64>,
    }

    /// If this flag is set, `max_gas` specified inside `#[randomness()]` will be used as the required deposit.
    struct AllowCustomMaxGasFlag has key, drop, store {
        value: bool,
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L279-297)
```rust
pub struct RandomnessConfig {
    pub randomness_api_v0_required_deposit: Option<u64>,
    pub allow_rand_contract_custom_max_gas: bool,
}

impl RandomnessConfig {
    /// Returns randomness config based on the current state.
    pub fn fetch(state_view: &impl StateView) -> Self {
        let randomness_api_v0_required_deposit = RequiredGasDeposit::fetch_config(state_view)
            .unwrap_or_else(RequiredGasDeposit::default_if_missing)
            .gas_amount;
        let allow_rand_contract_custom_max_gas = AllowCustomMaxGasFlag::fetch_config(state_view)
            .unwrap_or_else(AllowCustomMaxGasFlag::default_if_missing)
            .value;
        Self {
            randomness_api_v0_required_deposit,
            allow_rand_contract_custom_max_gas,
        }
    }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L658-658)
```rust
    REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS = 39,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L984-990)
```rust
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L70-250)
```rust
pub(crate) fn check_gas(
    gas_params: &AptosGasParameters,
    gas_feature_version: u64,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
    txn_metadata: &TransactionMetadata,
    features: &Features,
    is_approved_gov_script: bool,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let txn_gas_params = &gas_params.vm.txn;
    let raw_bytes_len = txn_metadata.transaction_size;

    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }

    // The submitted max gas units that the transaction can consume is greater than the
    // maximum number of gas units bound that we have set for any
    // transaction.
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }

    // The submitted transactions max gas units needs to be at least enough to cover the
    // intrinsic cost of the transaction as calculated against the size of the
    // underlying `RawTransaction`.
    let keyless = if txn_metadata.is_keyless() {
        KEYLESS_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let slh_dsa_sha2_128s = if txn_metadata.is_slh_dsa_sha2_128s() {
        SLH_DSA_SHA2_128S_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }

    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }

    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }

    // If this is for a potentially new account, ensure there's enough gas to cover storage, execution, and IO costs.
    // TODO: This isn't the cleaning code, thus we localize it just here and will remove it
    // once accountv2 is available and we no longer need to create accounts.
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
        if actual < expected {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Insufficient gas for account creation; min {}, submitted {}",
                    expected, actual,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
                None,
            ));
        }
    }

    Ok(())
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L597-597)
```text
        let gas_used = txn_max_gas_units - gas_units_remaining;
```

**File:** testsuite/smoke-test/src/randomness/entry_func_attrs.rs (L60-60)
```rust
                    if msg.contains("REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS") {
```
