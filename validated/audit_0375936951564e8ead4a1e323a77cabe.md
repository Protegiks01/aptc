# Audit Report

## Title
Abort Hook Bypass Allows Account Creation at Protected Framework Reserved Addresses

## Summary
The abort hook mechanism in user transaction processing can create Account resources at protected framework reserved addresses (0x2, 0x4-0xa) and @core_resources (0xA550C18) through sponsored transaction abuse. The `create_account_if_does_not_exist` function only validates three specific addresses but fails to protect all framework reserved addresses, violating the critical invariant that system addresses must be protected from user transactions.

## Finding Description

The vulnerability exists due to inconsistent address validation across three components:

**1. Abort Hook Account Creation**: When a user transaction aborts with sponsored automatic account creation features enabled and sequence number 0, the abort hook calls `create_account_if_does_not_exist` for the transaction sender. [1](#0-0) 

This is triggered when `should_create_account_resource` returns true. [2](#0-1) 

**2. Insufficient Address Protection**: The `create_account_if_does_not_exist` function only validates against three specific addresses (@vm_reserved=0x0, @aptos_framework=0x1, @aptos_token=0x3). [3](#0-2) 

However, the framework defines addresses 0x1-0xa as "framework reserved". [4](#0-3) 

This leaves addresses 0x2, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa unprotected, along with @core_resources (0xA550C18).

**3. Sponsored Transaction Validation Bypass**: The prologue allows sponsored transactions with non-existent sender accounts when sender ≠ gas_payer, features enabled, and sequence_number = 0. [5](#0-4) 

**Attack Path:**
1. Attacker creates account A with gas balance
2. Submits sponsored transaction: sender=0x2 (or 0x4-0xa, 0xA550C18), gas_payer=A, seq=0, aborting payload
3. Prologue passes due to sponsored account creation logic
4. Transaction executes and aborts
5. Abort hook invokes `create_account_if_does_not_exist(0x2)`
6. Validation passes (0x2 ≠ 0x0, 0x2 ≠ 0x1, 0x2 ≠ 0x3)
7. Account resource created at protected address

**Invariant Violation**: Genesis creates framework reserved accounts exclusively through `create_framework_reserved_account`, which is a friend-only function. [6](#0-5) [7](#0-6) 

## Impact Explanation

**Medium Severity** - Qualifies as "State inconsistencies requiring manual intervention":

1. **Protocol Violation**: Breaks the documented invariant that framework reserved addresses (0x1-0xa) are protected from user modification
2. **Access Control Bypass**: Allows unprivileged users to create Account resources at system addresses that should only be created via friend-only `create_framework_reserved_account`
3. **Governance Impact**: Future governance operations expecting these addresses to be in genesis-initialized state may fail
4. **Formal Verification Violations**: Breaks specifications assuming only genesis/framework code populates these addresses

While the attacker cannot control the created account (authentication key = BCS(address), requiring SHA3-256 preimage attack), the existence of Account resources at protected addresses violates critical security boundaries.

## Likelihood Explanation

**High Likelihood**:

1. **Feature Availability**: Either `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` or `DEFAULT_ACCOUNT_RESOURCE` must be enabled - these are production features. [8](#0-7) [9](#0-8) 

2. **Low Attack Cost**: Requires only gas balance and standard transaction submission
3. **Deterministic Exploitation**: No race conditions or timing dependencies
4. **Multiple Targets**: Can create accounts at 0x2, 0x4-0xa (7 addresses), and @core_resources

## Recommendation

Modify `create_account_if_does_not_exist` to use the same validation as `create_framework_reserved_account`:

```move
public fun create_account_if_does_not_exist(account_address: address) {
    if (!resource_exists_at(account_address)) {
        assert!(
            !system_addresses::is_framework_reserved_address(account_address) && 
            !system_addresses::is_core_resource_address(account_address),
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        create_account_unchecked(account_address);
    }
}
```

This ensures consistent protection across all framework reserved addresses and @core_resources.

## Proof of Concept

```move
#[test(attacker = @0x999, framework = @aptos_framework)]
fun test_reserved_address_creation_via_abort_hook(attacker: signer, framework: signer) {
    // Setup: Enable sponsored account creation feature
    features::change_feature_flags(&framework, vector[34], vector[]);
    
    // Attacker creates sponsored transaction with sender=0x2, seq=0
    // Transaction will abort but abort hook creates account at 0x2
    let payload = /* aborting transaction payload */;
    aptos_account::create_account(@0x999); // attacker's account for gas
    
    // Submit sponsored txn: sender=0x2, gas_payer=0x999, seq=0
    // Transaction aborts, but account created at 0x2
    
    assert!(account::exists_at(@0x2), 0); // Account now exists at reserved address
}
```

## Notes

The issue stems from inconsistent validation logic. The `create_framework_reserved_account` function properly validates all addresses 0x1-0xa, while `create_account_if_does_not_exist` only checks three specific addresses. The comment at line 292 of account.move acknowledges @core_resources is created via `create_account`, but this same exemption inappropriately applies to `create_account_if_does_not_exist` when called from the abort hook, allowing user transactions to create accounts at system addresses.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L708-719)
```rust
        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1156-1173)
```text
    public(friend) fun create_framework_reserved_account(addr: address): (signer, SignerCapability) {
        assert!(
            addr == @0x1 ||
                addr == @0x2 ||
                addr == @0x3 ||
                addr == @0x4 ||
                addr == @0x5 ||
                addr == @0x6 ||
                addr == @0x7 ||
                addr == @0x8 ||
                addr == @0x9 ||
                addr == @0xa,
            error::permission_denied(ENO_VALID_FRAMEWORK_RESERVED_ADDRESS),
        );
        let signer = create_account_unchecked(addr);
        let signer_cap = SignerCapability { account: addr };
        (signer, signer_cap)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L44-56)
```text
    /// Return true if `addr` is 0x0 or under the on chain governance's control.
    public fun is_framework_reserved_address(addr: address): bool {
        is_aptos_framework_address(addr) ||
            addr == @0x2 ||
            addr == @0x3 ||
            addr == @0x4 ||
            addr == @0x5 ||
            addr == @0x6 ||
            addr == @0x7 ||
            addr == @0x8 ||
            addr == @0x9 ||
            addr == @0xa
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L220-249)
```text
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L100-106)
```text
        // put reserved framework reserved accounts under aptos governance
        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];
        while (!vector::is_empty(&framework_reserved_addresses)) {
            let address = vector::pop_back<address>(&mut framework_reserved_addresses);
            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);
            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);
        };
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L301-307)
```text
    const SPONSORED_AUTOMATIC_ACCOUNT_CREATION: u64 = 34;

    public fun get_sponsored_automatic_account_creation(): u64 { SPONSORED_AUTOMATIC_ACCOUNT_CREATION }

    public fun sponsored_automatic_account_creation_enabled(): bool acquires Features {
        is_enabled(SPONSORED_AUTOMATIC_ACCOUNT_CREATION)
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L684-690)
```text
    const DEFAULT_ACCOUNT_RESOURCE: u64 = 91;

    public fun get_default_account_resource_feature(): u64 { DEFAULT_ACCOUNT_RESOURCE }

    public fun is_default_account_resource_enabled(): bool acquires Features {
        is_enabled(DEFAULT_ACCOUNT_RESOURCE)
    }
```
