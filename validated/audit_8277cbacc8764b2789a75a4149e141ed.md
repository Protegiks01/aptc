# Audit Report

## Title
Consensus Divergence via Stale Module Cache When Switching Between Forked Blocks

## Summary
The `CachedModuleView::reset_state_view()` method updates the state view without invalidating the module cache, relying solely on version-based validation. When validators speculatively execute forked blocks that share a common grandparent, stale cached modules from one fork can be incorrectly reused while executing transactions on another fork, leading to consensus divergence through different block metadata transactions.

## Finding Description

This vulnerability arises from the interaction between module cache management in the consensus pipeline and version-based cache validation. The attack exploits four key implementation details:

**1. Module Cache Persistence Without Invalidation**

The `reset_state_view()` method only updates the state view reference without clearing cached modules or the VM environment. [1](#0-0) 

**2. Version-Only Cache Validation**

Cache validation compares only version numbers, not state view IDs or content hashes. When a cached module's version matches the state view's version for that module key, the cached module is returned without re-deserialization. [2](#0-1) 

**3. Grandparent ID Checking in Consensus**

The `rand_check` function checks if the previous state view ID matches the grandparent block ID (not the parent block ID). If they match, it calls `reset_state_view` instead of `reset_all`, preserving the module cache. [3](#0-2) [4](#0-3) 

**4. Identical Version Assignment Across Forks**

Each block's first version equals its parent's next version. Forked blocks extending from the same parent therefore assign identical versions to state updates at the same transaction index. [5](#0-4) 

**Attack Scenario:**

1. Block GP (grandparent) is committed at version 1000
2. Block P1 extends GP: transaction 0 modifies module `0x1::M` → assigns version 1001 with P1's content (e.g., with randomness annotation)
3. Block P2 extends GP (fork): transaction 0 modifies module `0x1::M` → assigns version 1001 with P2's different content (e.g., without randomness annotation)
4. Validator V executes P1:
   - Caches module `0x1::M` with version 1001 (P1's content)
   - After rand_check: cache's `state_view_id` becomes GP's ID
5. Validator V then executes C2 (child of P2, grandparent is GP):
   - `grand_parent_id = GP` (from C2's QC's parent_block)
   - `previous_state_view = StateViewId::BlockExecution { block_id: GP }` (from cache)
   - `expected_state_view = StateViewId::BlockExecution { block_id: GP }`
   - Match! Calls `reset_state_view(P2's state)` instead of `reset_all()`
   - Cache retains P1's module with version 1001
   - When checking modules in rand_check: cached version 1001 == P2's state version 1001 → validation PASSES
   - Uses P1's module metadata to determine randomness requirement
   - **Creates different metadata transaction than validators using P2's modules**

**Consensus Divergence:**

Different randomness detection results lead to different metadata transaction types. The `rand_check` function determines whether to create a V1 metadata transaction with randomness or a V0 metadata transaction. [6](#0-5) 

These different `BlockMetadataExt` variants convert to different `Transaction` enum variants (V0 → `Transaction::BlockMetadata`, V1 → `Transaction::BlockMetadataExt`), which execute differently and produce different state roots. [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability satisfies the Consensus/Safety Violations category from the Aptos bug bounty program:

- **Different validators produce different state roots**: Validators using stale cached modules create `BlockMetadataExt` with different randomness values compared to validators with correct modules. Since `BlockMetadataExt::V0` and `BlockMetadataExt::V1` convert to different `Transaction` enum variants, they execute with different state transitions and produce different state roots.

- **Consensus split**: Different metadata transactions cause different execution results, preventing validators from agreeing on block validity. This breaks the fundamental safety property of BFT consensus.

- **No Byzantine validators required**: Honest validators diverge due to timing of speculative execution. The vulnerability is triggered by the order in which validators execute forked blocks, which varies naturally across the network.

- **Chain cannot progress**: Once validators diverge on state roots, they cannot reach consensus on subsequent blocks, requiring manual intervention or a hard fork to recover.

The vulnerability is amplified because it affects the randomness detection path, which is critical for on-chain randomness generation, and occurs during normal speculative execution in the consensus pipeline.

## Likelihood Explanation

**High Likelihood** during normal consensus operation:

1. **Trigger Conditions Are Common:**
   - Multiple validators regularly propose competing blocks for the same round during normal consensus operation
   - Forked blocks naturally share common grandparents in the block DAG structure
   - Move module deployments and upgrades are frequent on-chain operations

2. **No Special Permissions Required:**
   - Occurs during normal speculative execution by honest validators
   - Triggered purely by timing of block proposals and execution order
   - No Byzantine behavior or coordination needed

3. **Inevitable During Fork Resolution:**
   - Validators speculatively execute blocks from multiple forks to optimize throughput
   - The module cache persists across these executions within the same consensus round
   - The grandparent ID check makes stale cache usage likely when forks converge

The `rand_check_enabled` flag is enabled by default in genesis configuration. [8](#0-7) 

## Recommendation

Modify the `rand_check` function in `pipeline_builder.rs` to always call `reset_all()` instead of conditionally calling `reset_state_view()`. This ensures the module cache is cleared when switching between any blocks, preventing stale cache usage:

```rust
// In rand_check function, replace the conditional logic (lines 719-726) with:
cache_mut.reset_all(parent_state_view);
```

Alternatively, enhance cache validation to include block ID verification in addition to version checking. Modify `CachedModuleView::get_module_or_build_with` to store and validate the originating block ID alongside the version number.

## Proof of Concept

A complete PoC would require setting up a multi-validator testnet with the following steps:

1. Deploy a test module with randomness annotation to block P1 extending GP
2. Deploy a different test module without randomness annotation to block P2 also extending GP  
3. Have validators execute P1, then execute C2 (child of P2)
4. Observe different metadata transactions created by different validators
5. Verify consensus failure due to state root mismatch

The technical analysis above demonstrates all necessary code paths exist for this vulnerability to manifest during normal fork resolution in consensus.

## Notes

This vulnerability represents a subtle interaction between three separate systems: the module cache in `CachedModuleView`, the grandparent-based optimization in `rand_check`, and version-based cache validation. The issue only manifests when validators speculatively execute forked blocks that modify the same modules, making it timing-dependent but highly likely during normal network operation. The fix should prioritize safety over the minor performance optimization of preserving cache across fork boundaries.

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L244-245)
```rust
        Ok(if version == value_version {
            Some((module, version))
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L703-703)
```rust
        let grand_parent_id = block.quorum_cert().parent_block().id();
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L715-726)
```rust
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L807-811)
```rust
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** execution/executor/src/block_executor/mod.rs (L213-213)
```rust
            first_version = parent_output.execution_output.next_version(),
```

**File:** types/src/transaction/mod.rs (L2979-2985)
```rust
impl From<BlockMetadataExt> for Transaction {
    fn from(metadata: BlockMetadataExt) -> Self {
        match metadata {
            BlockMetadataExt::V0(v0) => Transaction::BlockMetadata(v0),
            vx => Transaction::BlockMetadataExt(vx),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L222-222)
```rust
            rand_check_enabled: true,
```
