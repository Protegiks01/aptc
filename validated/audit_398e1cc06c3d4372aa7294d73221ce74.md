# Audit Report

## Title
Peer Monitoring Metadata Poisoning Enables Eclipse Attacks and State Sync Manipulation via False Distance Claims

## Summary
Malicious peers can inject false `distance_from_validators` metadata into peer monitoring systems, causing honest nodes to make incorrect routing decisions for state synchronization, mempool transaction forwarding, and consensus observer subscriptions. The validation logic only performs strict role-based checks for distances 0 and 1, but accepts any self-reported distance from 2 to 100 without verification.

## Finding Description

The peer monitoring service allows peers to self-report their `distance_from_validators` metric through `GetNetworkInformation` RPC responses. This metric measures topological distance from the validator set and is critical for peer selection across three major subsystems:

1. **State Sync**: Peer selection for blockchain data requests [1](#0-0) 

2. **Mempool**: Transaction forwarding priority [2](#0-1) 

3. **Consensus Observer**: Subscription peer selection [3](#0-2) 

The validation logic in the peer monitoring client performs role-based checks for distances 0 and 1, but for distances ≥ 2, only validates that the distance is below the maximum threshold: [4](#0-3) 

**Attack Path:**

1. Malicious PFN connects to an honest PFN on the Public network using `MaybeMutual` authentication mode
2. In `MaybeMutual` mode, untrusted peers are assigned `PeerRole::Unknown` [5](#0-4) 
3. The malicious peer responds to `GetNetworkInformation` requests with a fabricated `distance_from_validators = 2`
4. Since `PeerRole::Unknown` is neither validator nor VFN, it fails validation for distances 0 and 1, but passes for distance 2 (only checking `distance <= 100`)
5. The honest node's state sync client groups peers by distance using a `BTreeMap`, which sorts by ascending distance [6](#0-5) 
6. When selecting peers for data requests, the malicious peer at (false) distance 2 is prioritized over honest peers at (true) distances 5-10
7. Similarly, mempool prioritizes the malicious peer for transaction forwarding [7](#0-6) 
8. Consensus observer also prioritizes the malicious peer for subscriptions [8](#0-7) 

The metadata is recorded without cryptographic verification and directly influences routing decisions [9](#0-8) 

## Impact Explanation

**High Severity** - This vulnerability enables multiple attack vectors affecting full node security:

1. **Peer Selection Manipulation**: Malicious peers gain unfair priority in peer selection for state sync, mempool, and consensus observer, allowing them to monopolize connections to honest nodes

2. **Network Performance Degradation**: By claiming optimal distance, malicious peers can serve stale data or drop requests, causing sync delays, transaction forwarding failures, and consensus propagation issues

3. **Resource Exhaustion**: Honest nodes waste resources repeatedly connecting to and requesting data from malicious peers that provide poor service

4. **Censorship Capability**: In mempool transaction forwarding, malicious peers claiming low distance receive transactions first and can selectively delay or drop them before failover mechanisms activate

While this does not directly compromise validator consensus safety (validators use `Mutual` authentication on dedicated networks), it severely impacts the security and reliability of full nodes (VFN/PFN), which are critical for ecosystem health. The attack requires no privileged access and can be executed by any peer connecting to public networks.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

1. **Low Barrier to Entry**: Any entity can spin up a malicious full node and connect to the public network
2. **No Authentication Required**: Public networks use `MaybeMutual` authentication by default [10](#0-9) , allowing any peer to connect
3. **Simple Exploitation**: The attacker only needs to return a false distance value (2-100) in a standard RPC response
4. **Immediate Effect**: The false metadata is immediately incorporated into routing decisions with no additional verification beyond the insufficient role-based checks
5. **Persistent Impact**: Once the false metadata is accepted, it continues to influence routing decisions until the peer disconnects

The vulnerability is currently exploitable in production networks wherever `MaybeMutual` authentication is used, which includes all PFN-PFN and VFN-PFN connections on public networks.

## Recommendation

Implement cryptographic verification of distance claims:

1. **Proof-Based Validation**: Require peers claiming distance `d` to provide proof of connection to a peer at distance `d-1`, forming a verifiable chain back to validators

2. **Enhanced Role Verification**: For distances 2+, verify the peer's connection history or implement reputation-based scoring that penalizes peers providing poor service

3. **Bounded Distance Claims**: Reject distance claims that are suspiciously low for peers with `PeerRole::Unknown` on public networks

4. **Monitoring and Outlier Detection**: Track peer behavior over time and flag peers whose claimed distance doesn't match their actual service quality (e.g., serving stale data despite claiming low distance)

Example fix for the validation logic:
```rust
distance_from_validators => {
    // For Unknown peers on public networks, enforce minimum distance
    if peer_metadata.get_connection_metadata().role == PeerRole::Unknown 
        && network_id.is_public_network() 
        && distance_from_validators < MIN_DISTANCE_FOR_UNKNOWN_PEERS {
        false
    } else {
        distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a malicious PFN that responds to `GetNetworkInformation` requests with `distance_from_validators = 2`
2. Connecting to an honest PFN on the public network
3. Observing that the honest node accepts the false distance and prioritizes the malicious peer in state sync, mempool, and consensus observer operations
4. Monitoring the honest node's peer selection decisions to confirm the malicious peer receives preferential treatment over honest peers at true distances 5-10

The validation logic at lines 118-141 of `network_info.rs` will accept the false claim because it only checks `distance <= MAX_DISTANCE_FROM_VALIDATORS` for distances ≥ 2, without verifying the peer's actual network topology or role.

## Notes

This vulnerability specifically affects the peer monitoring metadata validation logic and its usage across state sync, mempool, and consensus observer systems. The core issue is that the validation performs strict role-based checks for distances 0 and 1, but relies solely on a maximum threshold check for distances 2-100, allowing any peer with `PeerRole::Unknown` to claim any distance in this range without verification.

The impact is primarily on full node operations rather than direct validator consensus, since validators use `Mutual` authentication on dedicated networks. However, full nodes are critical infrastructure for the ecosystem, serving user requests, propagating transactions, and providing redundancy.

### Citations

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L615-639)
```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L325-334)
```rust
    // Sort the peers by distance and latency. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut sorted_peers_and_latencies = Vec::new();
    for (_, mut peers_and_latencies) in peers_and_latencies_by_distance {
        // Sort the peers by latency
        peers_and_latencies.sort_by_key(|(_, latency)| *latency);

        // Add the peers to the sorted list (in sorted order)
        sorted_peers_and_latencies.extend(peers_and_latencies);
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L54-64)
```rust
    /// Records the new network info response for the peer
    pub fn record_network_info_response(
        &mut self,
        network_info_response: NetworkInformationResponse,
    ) {
        // Update the request tracker with a successful response
        self.request_tracker.write().record_response_success();

        // Save the network info
        self.recorded_network_info_response = Some(network_info_response);
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** config/src/config/network_config.rs (L79-79)
```rust
    pub mutual_authentication: bool,
```
