# Audit Report

## Title
Backup Poisoning via Unverified Ledger Info Import in Epoch Ending Restore

## Summary
The epoch ending restore process fails to cryptographically verify the first ledger info when restoring from backups without trusted waypoints. This allows attackers with compromised backup access to inject malicious ledger infos that are blindly imported into the database, causing validator node startup failures through waypoint verification panics.

## Finding Description

The vulnerability exists in the epoch ending ledger info restoration logic where cryptographic verification is missing for the initial ledger info when no trusted waypoint is provided.

The verification logic in `preheat_impl()` has two conditional branches that check ledger infos: [1](#0-0) 

**The Critical Gap:** The `previous_li` variable is initialized as `None`: [2](#0-1) 

For the first ledger info during restore:
- If no trusted waypoint exists for that version → first branch fails (line 129)
- Since `previous_li` is `None` → second branch fails (line 136)
- **No else clause exists** → ledger info is accepted without any cryptographic verification

The unverified ledger info is then added to the list: [3](#0-2) 

Additionally, in the coordinator, the first epoch is processed with no previous ledger info: [4](#0-3) 

This means the secondary verification in `run_impl()` is also skipped for the first epoch: [5](#0-4) 

Trusted waypoints are optional CLI parameters with empty defaults: [6](#0-5) 

The unverified ledger infos are committed to the database via the restore handler: [7](#0-6) 

**Attack Propagation:** When the validator node starts up, it reads the unverified ledger info from the database to initialize the epoch state: [8](#0-7) 

The bootstrapper fetches this epoch state during initialization: [9](#0-8) 

The fake `next_epoch_state` from the unverified ledger info becomes the trusted validator set for the bootstrapper, breaking the chain of trust.

## Impact Explanation

**HIGH Severity (Guaranteed Impact):**

- **Validator Node Unavailability**: When properly configured with a genesis waypoint, the node startup will detect the mismatch during waypoint verification and panic, causing denial of service: [10](#0-9) 

- **Silent Database Corruption**: The restore completes without errors, leaving operators unaware that the database contains cryptographically unverified data until node startup fails.

- **Operational Disruption**: Forces complete database wipe and re-restore from clean backup source.

Per Aptos Bug Bounty criteria, this qualifies as **HIGH Severity** under "Validator Node Slowdowns" due to the startup DoS that prevents the validator from participating in consensus.

## Likelihood Explanation

**Likelihood: Medium-High**

Factors increasing likelihood:
1. **Optional Security Parameter**: The `--trust-waypoint` flag is optional with no enforcement, warnings, or validation that it was provided
2. **Default Unsafe Behavior**: Empty trusted waypoints is the default, making the unsafe path the default path
3. **Realistic Attack Vector**: Compromised backup storage or MitM attacks on backup retrieval are realistic threats for blockchain infrastructure
4. **Human Error**: Operators following incomplete procedures or automation scripts may easily omit the optional flag

Factors limiting likelihood:
1. **Waypoint Verification at Startup**: Properly configured nodes will detect and reject corrupted state (though causing DoS)
2. **Requires Backup Compromise**: Attacker needs write access to backup storage or network position for MitM

## Recommendation

Add mandatory verification for the first ledger info when no trusted waypoint is provided. The fix should:

1. Add an explicit validation path for the first epoch's ledger info:
```rust
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(*wp_trusted == wp_li, ...);
} else if let Some(pre_li) = previous_li {
    pre_li.ledger_info().next_epoch_state()...verify(&li)?;
} else {
    // NEW: Require trusted waypoint for first epoch
    return Err(anyhow!(
        "First epoch ending ledger info at version {} requires a trusted waypoint for verification",
        li.ledger_info().version()
    ));
}
```

2. Make `--trust-waypoint` mandatory for epoch 0 restores with clear error messages
3. Add validation that genesis/epoch 0 waypoint is always provided during restore operations
4. Update documentation to emphasize the critical security requirement of waypoints

## Proof of Concept

Attack scenario:
1. Attacker compromises backup storage and modifies the first epoch ending ledger info
2. Operator runs: `aptos-node restore --epoch-ending-manifest backup.json --target-db-dir /data/db`
3. The modified first ledger info passes through `preheat_impl()` without verification (no waypoint, no previous_li)
4. Unverified data is committed to database via `save_ledger_infos()`
5. Operator starts validator node with proper genesis waypoint configured
6. Node reads compromised epoch state from database during `Bootstrapper::new()`
7. Waypoint verification detects mismatch and panics: "Failed to verify the waypoint"
8. Validator node fails to start → DoS

**Notes**

This vulnerability represents a logic flaw where the verification code assumes at least one of two conditions will be true (trusted waypoint OR previous ledger info), but for the first epoch during restore, both can be false. The waypoint verification at startup acts as a defense-in-depth mechanism that catches the corruption but causes DoS, rather than allowing silent corruption to persist. The severity is HIGH due to the confirmed DoS impact, though the underlying trust chain break could theoretically escalate if waypoint verification were somehow bypassed (which the report does not demonstrate).

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-149)
```rust
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L248-249)
```rust
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L375-381)
```rust
        let mut next_epoch = 0u64;
        let mut previous_li = None;
        let mut epoch_endings = Vec::new();

        while let Some(preheated_restore) = futs_stream.next().await {
            let manifest_handle = preheated_restore.controller.manifest_handle.clone();
            let lis = preheated_restore.run(previous_li).await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L696-706)
```rust
    fn get_latest_epoch_state(&self) -> Result<EpochState> {
        gauged_api("get_latest_epoch_state", || {
            let latest_ledger_info = self.ledger_db.metadata_db().get_latest_ledger_info()?;
            match latest_ledger_info.ledger_info().next_epoch_state() {
                Some(epoch_state) => Ok(epoch_state.clone()),
                None => self
                    .ledger_db
                    .metadata_db()
                    .get_epoch_state(latest_ledger_info.ledger_info().epoch()),
            }
        })
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L144-160)
```rust
            if ledger_info_version > waypoint_version {
                panic!(
                    "Failed to verify the waypoint: ledger info version is too high! Waypoint version: {:?}, ledger info version: {:?}",
                    waypoint_version, ledger_info_version
                );
            }

            // Check if we've found the ledger info corresponding to the waypoint version
            if ledger_info_version == waypoint_version {
                match waypoint.verify(ledger_info) {
                    Ok(()) => self.set_verified_waypoint(waypoint_version),
                    Err(error) => {
                        panic!(
                            "Failed to verify the waypoint: {:?}! Waypoint: {:?}, given ledger info: {:?}",
                            error, waypoint, ledger_info
                        );
                    },
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L342-344)
```rust
        let latest_epoch_state = utils::fetch_latest_epoch_state(storage.clone())
            .expect("Unable to fetch latest epoch state!");
        let verified_epoch_states = VerifiedEpochStates::new(latest_epoch_state);
```
