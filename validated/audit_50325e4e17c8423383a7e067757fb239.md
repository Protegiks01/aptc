# Audit Report

## Title
Consensus Failure Due to Inconsistent max_aa_gas Parameter During Rolling Validator Upgrades

## Summary
A version gating mismatch in the `max_aa_gas` parameter causes consensus divergence during rolling validator upgrades. Validators running updated node software with gas feature version < 30 initialize `max_aa_gas` to 0, causing all Account Abstraction transactions to fail, while validators on older software without this logic process the same transactions successfully, breaking consensus determinism.

## Finding Description

The vulnerability stems from a critical mismatch between parameter **definition** (which has version gating) and parameter **usage** (which does not).

The `max_aa_gas` parameter is defined with version gating tied to RELEASE_V1_26 (gas feature version 30): [1](#0-0) 

The version constant RELEASE_V1_26 equals 30: [2](#0-1) 

The version gating macro implementation skips loading parameters when `feature_version` doesn't match the specified range. When the key extraction returns `None`, the parameter is not loaded from the on-chain gas schedule: [3](#0-2) [4](#0-3) 

Unloaded parameters retain their zero-initialized value from the `zeros()` function: [5](#0-4) 

However, the code that **uses** `max_aa_gas` performs NO version gating - it only checks if account abstraction feature flags are enabled: [6](#0-5) 

The same pattern appears in transaction validation: [7](#0-6) 

When `max_aa_gas = 0`, the expression `min(0, txn.max_gas_amount())` evaluates to 0, causing the gas meter to start with zero balance. Any gas consumption during prologue validation triggers an OUT_OF_GAS error: [8](#0-7) 

The `unwrap_or_discard!` macro catches these errors and converts them to discarded transactions: [9](#0-8) [10](#0-9) 

**Consensus Divergence Scenario:**

The Account Abstraction features are enabled by default in the feature set: [11](#0-10) 

The `gas_feature_version` comes from the on-chain `GasScheduleV2` configuration, which is controlled by governance separately from node software upgrades: [12](#0-11) 

Rolling validator upgrades are explicitly supported and tested in the codebase, with validators upgraded in batches while maintaining network operation: [13](#0-12) [14](#0-13) 

During a rolling upgrade where:
1. On-chain `gas_feature_version` < 30 (governance hasn't upgraded yet)
2. Some validators run new software (with max_aa_gas logic)
3. Some validators run old software (without max_aa_gas logic)
4. A user submits an AA transaction

**Result:**
- **New validators**: Load `max_aa_gas = 0` (not loaded from on-chain due to version gate), set `initial_balance = 0`, transaction fails with OUT_OF_GAS during prologue
- **Old validators**: No max_aa_gas logic exists in their codebase, use full `txn.max_gas_amount()`, transaction executes successfully
- **Outcome**: Different execution results → consensus divergence → potential network partition

## Impact Explanation

This is a **Critical** severity vulnerability per Aptos bug bounty criteria because it directly causes **Consensus/Safety violations** (Category 2: "Different validators commit different blocks").

During rolling upgrades, the network will experience:
- **Consensus failures**: Validators produce different state roots for identical blocks containing AA transactions
- **Network partition risk**: Chain may fork as validators disagree on block validity
- **Transaction non-determinism**: Same transaction yields different results on different validators
- **Potential hardfork requirement**: Recovery may require coordinated manual intervention

The vulnerability affects all AA transactions during the upgrade window, which could represent significant network traffic depending on AA adoption rates.

## Likelihood Explanation

**High likelihood** of occurrence:

1. **Default enabled feature**: Account Abstraction features are in the default feature set, making the vulnerable code path active without additional configuration
2. **Standard operational practice**: Rolling upgrades are the documented standard for validator updates to maintain network availability
3. **Temporal coordination gap**: Node software releases and governance gas schedule updates occur at different times through separate processes, creating a vulnerable window
4. **No runtime protection**: The code lacks version checks (`gas_feature_version >= RELEASE_V1_26`) before using `max_aa_gas`, allowing it to use the zero-initialized value
5. **Natural trigger**: Any user submitting an AA transaction during the vulnerable window triggers the issue - no attacker needed

The vulnerability triggers automatically when:
- Validators run mixed software versions (standard during rolling upgrades)
- `gas_feature_version < 30` (before governance approval)
- AA feature flags enabled (default state)
- Any AA transaction submitted (normal user activity)

## Recommendation

Add a gas feature version check before using `max_aa_gas`. The code should verify that `gas_feature_version >= RELEASE_V1_26` before applying the max_aa_gas logic:

```rust
let initial_balance = if (self.features().is_account_abstraction_enabled()
    || self.features().is_derivable_account_abstraction_enabled())
    && self.gas_feature_version() >= gas_feature_versions::RELEASE_V1_26
{
    vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
} else {
    txn.max_gas_amount().into()
};
```

Apply this fix to both locations:
- Line 2149-2155 in `aptos-move/aptos-vm/src/aptos_vm.rs` (execution path)
- Line 3263-3269 in `aptos-move/aptos-vm/src/aptos_vm.rs` (validation path)

Additionally, update the post-prologue balance injection logic at lines 2014-2025 with the same version check.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Set up a test network with validators running mixed software versions
2. Ensure on-chain `gas_feature_version < 30`
3. Ensure AA feature flags are enabled (default configuration)
4. Submit an Account Abstraction transaction
5. Observe that:
   - Validators with new software discard the transaction (OUT_OF_GAS)
   - Validators with old software execute the transaction successfully
   - Consensus fails as validators produce different state roots

**Notes:**
- This vulnerability only manifests during rolling upgrades when validators run heterogeneous software versions
- The issue is automatically resolved once all validators complete the upgrade and governance updates `gas_feature_version >= 30`
- The vulnerable window exists between node software deployment and governance gas schedule upgrade
- The fix is straightforward but critical to prevent consensus failures during standard operational procedures

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L276-279)
```rust
            max_aa_gas: Gas,
            { RELEASE_V1_26.. => "max_aa_gas" },
            60,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L96-96)
```rust
    pub const RELEASE_V1_26: u64 = 30;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L9-15)
```rust
    ({ $($ver: pat => $key: literal),+ }, $cur_ver: expr) => {
        match $cur_ver {
            $($ver => Some($key)),+,
            #[allow(unreachable_patterns)]
            _ => None,
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-41)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L64-67)
```rust
            pub fn zeros() -> Self {
                Self {
                    $($name: 0.into()),*
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-189)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
        }
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2001-2012)
```rust
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2149-2155)
```rust
        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn.max_gas_amount().into())
        } else {
            txn.max_gas_amount().into()
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3263-3269)
```rust
        let initial_balance = if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            vm_params.txn.max_aa_gas.min(txn_data.max_gas_amount())
        } else {
            txn_data.max_gas_amount()
        };
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L189-201)
```rust
        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.execution_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.execution_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
```

**File:** types/src/on_chain_config/aptos_features.rs (L254-256)
```rust
            FeatureFlag::ACCOUNT_ABSTRACTION,
            FeatureFlag::BULLETPROOFS_BATCH_NATIVES,
            FeatureFlag::DERIVABLE_ACCOUNT_ABSTRACTION,
```

**File:** types/src/on_chain_config/gas_schedule.rs (L14-17)
```rust
pub struct GasScheduleV2 {
    pub feature_version: u64,
    pub entries: Vec<(String, u64)>,
}
```

**File:** testsuite/testcases/src/compatibility_test.rs (L12-50)
```rust
pub struct SimpleValidatorUpgrade;

impl SimpleValidatorUpgrade {
    pub const EPOCH_DURATION_SECS: u64 = 30;
}

impl Test for SimpleValidatorUpgrade {
    fn name(&self) -> &'static str {
        "compatibility::simple-validator-upgrade"
    }
}

#[async_trait]
impl NetworkTest for SimpleValidatorUpgrade {
    async fn run<'a>(&self, ctxa: NetworkContextSynchronizer<'a>) -> Result<()> {
        let upgrade_wait_for_healthy = true;
        let upgrade_node_delay = Duration::from_secs(20);
        let upgrade_max_wait = Duration::from_secs(40);

        let epoch_duration = Duration::from_secs(Self::EPOCH_DURATION_SECS);

        // Get the different versions we're testing with
        let (old_version, new_version) = {
            let mut versions = ctxa
                .ctx
                .lock()
                .await
                .swarm
                .read()
                .await
                .versions()
                .collect::<Vec<_>>();
            versions.sort();
            if versions.len() != 2 {
                bail!("exactly two different versions needed to run compat test");
            }

            (versions[0].clone(), versions[1].clone())
        };
```

**File:** testsuite/testcases/src/compatibility_test.rs (L83-86)
```rust
        let mut first_batch = all_validators.clone();
        let second_batch = first_batch.split_off(first_batch.len() / 2);
        let first_node = first_batch.pop().unwrap();
        let duration = Duration::from_secs(30);
```
