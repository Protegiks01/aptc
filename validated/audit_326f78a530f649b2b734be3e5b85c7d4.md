# Audit Report

## Title
Missing Quorum Verification for First Epoch Ending in Backup Restore Without Trusted Waypoint

## Summary
The epoch ending backup restore logic fails to verify signatures for the first ledger info when no trusted waypoint is provided and no previous epoch ending ledger info exists. This allows injection of malicious epoch endings with insufficient validator signatures, bypassing the fundamental consensus safety requirement that epoch changes must be approved by 2/3+ validators.

## Finding Description

The vulnerability exists in the epoch ending restore verification logic where two conditional branches exist but neither executes under specific conditions.

**Branch A**: If a trusted waypoint exists for the ledger info's version, the code verifies the waypoint hash matches: [1](#0-0) 

**Branch B**: If a previous ledger info exists in memory, the code verifies signatures using the previous epoch's validator set: [2](#0-1) 

**Critical Gap**: When neither condition is met (no trusted waypoint AND `previous_li` is `None`), no verification occurs. The ledger info is pushed to the list without any signature or quorum validation: [3](#0-2) 

This occurs specifically when the backup starts from a non-genesis epoch (N > 0), no trusted waypoint is provided, `previous_li` is `None` during the first iteration, and the restore is invoked with `previous_epoch_ending_ledger_info = None`.

The entry point through `aptos-db-tool` always passes `None`: [4](#0-3) 

An additional verification opportunity in `run_impl()` is also bypassed when `previous_epoch_ending_ledger_info` is `None`: [5](#0-4) 

When verification IS called, it properly enforces quorum requirements. The `verify()` method checks signatures against the validator verifier: [6](#0-5) 

The signature verification calls `verify_multi_signatures` which enforces quorum: [7](#0-6) 

The quorum calculation correctly implements 2f+1: [8](#0-7) 

However, the logic gap prevents `verify()` from being called at all for the first ledger info in non-genesis restores without waypoints.

**Exploitation Path**:
1. Attacker creates malicious backup starting from epoch N > 0
2. First `LedgerInfoWithSignatures` contains < 2/3 validator signatures or arbitrary `next_epoch_state`
3. Node operator runs restore without trusted waypoints during disaster recovery
4. In `preheat_impl()`: `previous_li = None`, no waypoint → no verification
5. In `run_impl()`: `previous_epoch_ending_ledger_info = None` → no verification
6. Malicious first ledger info accepted without validation, containing arbitrary validator set for next epoch
7. Subsequent ledger infos verify correctly against the malicious validator set
8. Node operates on forked chain with attacker-controlled validator set

The test suite demonstrates awareness that this should fail without waypoints: [9](#0-8) 

The test explicitly creates ledger infos with empty signatures and expects verification to fail without waypoints (`should_fail_without_waypoints = true`), but this protection is not enforced in the actual restore code.

## Impact Explanation

This is **Critical Severity** per Aptos bug bounty criteria under "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" categories:

1. **Consensus/Safety Violation**: The fundamental consensus invariant requiring 2/3+ validator approval for epoch changes is completely bypassed. Each epoch ending must be signed by a quorum of validators from the previous epoch, but the first ledger info escapes this validation entirely.

2. **Validator Set Manipulation**: Attackers can inject arbitrary validator sets by forging the `next_epoch_state` in epoch ending ledger infos. Once the malicious first ledger info is accepted, all subsequent epochs are verified against the attacker's chosen validator set, allowing complete control over future block signing and epoch transitions.

3. **Chain Fork Attack**: Nodes restoring from malicious backups operate on a fundamentally different chain than the canonical network. The forked chain has a different validator set foundation, creating permanent divergence requiring hardfork intervention to reconcile.

4. **Loss of Byzantine Fault Tolerance**: Once a node accepts the unverified epoch ending, all subsequent state transitions are built on a foundation that never achieved proper consensus, violating the core BFT guarantee that 2f+1 honest validators agreed on the state transition.

## Likelihood Explanation

**Likelihood: Medium**

**Factors increasing likelihood**:
- Accessible via public `aptos-db-tool` CLI without special privileges or validator keys
- Node operators regularly perform backup/restore during disaster recovery, node migration, and network joining
- Only requires crafting a malicious backup file - no insider access needed
- Backup sources may be compromised through supply chain attacks
- Documentation and code structure suggest waypoints are optional rather than mandatory for security

**Factors decreasing likelihood**:
- Requires operator to use an untrusted or compromised backup source
- Best practices likely recommend using trusted waypoints from known-good sources
- Experienced operators may understand the security implications
- Normal bootstrap flow typically starts from genesis or uses trusted snapshots

The vulnerability represents a realistic operational security threat, particularly in disaster recovery scenarios where operators may use backups from potentially compromised storage systems.

## Recommendation

Add mandatory quorum verification for the first epoch ending ledger info when no previous ledger info exists. Specifically:

1. **Require trusted waypoint for first epoch**: When `previous_li` is `None` and the backup doesn't start from genesis (epoch 0), require a trusted waypoint for the first ledger info. Fail the restore if no waypoint is provided.

2. **Add explicit validation**: Before line 148 in `preheat_impl()`, add a check:
```rust
// After line 147, before line 148
if previous_li.is_none() && self.trusted_waypoints.get(&wp_li.version()).is_none() && li.ledger_info().epoch() != 0 {
    bail!("First non-genesis epoch ending ledger info requires a trusted waypoint for verification");
}
```

3. **Update documentation**: Clearly document that trusted waypoints are REQUIRED (not optional) for security when restoring from non-genesis epochs.

4. **Enforce in run_impl()**: Add similar validation in `run_impl()` to ensure the first ledger info has been properly verified.

## Proof of Concept

The test suite already demonstrates this vulnerability. The test at lines 137-157 creates ledger infos with empty signatures, sets `should_fail_without_waypoints = true`, and expects the restore to fail without waypoints. However, the actual restore code does not enforce this security boundary, allowing the test to pass when it should fail (or the test expectations are incorrect and the vulnerability exists).

A concrete PoC would involve:
1. Creating a backup manifest starting from epoch 1+ with a crafted `LedgerInfoWithSignatures` containing empty or invalid signatures
2. Running `aptos-db-tool restore` without providing trusted waypoints
3. Observing that the restore succeeds without verification
4. Verifying the database contains the unverified epoch ending ledger info

## Notes

This vulnerability specifically affects the backup/restore operational security boundary. While validator operators are listed as trusted roles, this vulnerability protects against:
1. Compromised backup storage systems (supply chain attacks)
2. Operational errors during disaster recovery
3. Malicious fullnode operators (who are not trusted roles)
4. Social engineering attacks providing malicious backups

The test suite's explicit expectation that verification should fail without waypoints (`should_fail_without_waypoints = true`) indicates this is an intended security boundary that is not being properly enforced in the implementation.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-135)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L136-147)
```rust
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L148-149)
```rust
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/db-tool/src/restore.rs (L80-80)
```rust
                        .run(None)
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L137-157)
```rust
        let mut should_fail_without_waypoints = false;
        let mut res_lis = Vec::new();
        let mut res_waypoints = Vec::new();
        for (block_size, r#gen, overwrite, trusted) in blocks {
            let mut li = r#gen.materialize(&mut universe, block_size);
            if li.ledger_info().ends_epoch() {
                if overwrite && li.ledger_info().epoch() != 0 {
                    li = LedgerInfoWithSignatures::new(
                        li.ledger_info().clone(),
                        AggregateSignature::empty(),
                    );
                    should_fail_without_waypoints = true;
                }
                if overwrite || trusted {
                    res_waypoints.push(Waypoint::new_epoch_boundary(li.ledger_info()).unwrap())
                }
                res_lis.push(li);

            }
        }
        (res_lis, res_waypoints, should_fail_without_waypoints)
```
