# Audit Report

## Title
Byzantine Validators Can Evade Exclusion Through Window Size Exploitation in OptQS Failure Tracker

## Summary
The `ExponentialWindowFailureTracker` in the consensus layer contains a logic flaw where the `get_exclude_authors()` method only examines the most recent `window` entries from a bounded queue, allowing Byzantine validators to evade exclusion by strategically timing `PayloadUnavailable` failures to remain in the historical queue but outside the active inspection window.

## Finding Description

The vulnerability exists in the interaction between the failure tracking window and the exclusion mechanism in `consensus/src/liveness/proposal_status_tracker.rs`. [1](#0-0) 

The `ExponentialWindowFailureTracker` maintains a `BoundedVecDeque` with capacity set to `max_window`, which is hardcoded to 100 in the epoch manager: [2](#0-1) 

The tracking window starts at 2 and doubles on each `PayloadUnavailable` failure up to the maximum: [3](#0-2) 

The critical flaw lies in `get_exclude_authors()`, which only examines the most recent `window` entries: [4](#0-3) 

**Exploitation Path:**

1. Byzantine validator causes a `PayloadUnavailable` timeout by withholding batch data. This is detected during round timeout computation: [5](#0-4) 

2. The failure is pushed to the tracker, causing the window to double (e.g., 2â†’4)
3. Validator behaves correctly for exactly `window` rounds (4 successful rounds)
4. The failure remains in the `BoundedVecDeque` at position 5 from the end
5. When OptQS is re-enabled (because `last_consecutive_success_count >= window`), `get_exclude_authors()` only checks the last 4 entries: [6](#0-5) 

6. The failure at position 5 is invisible to the exclusion logic since `.iter().rev().take(window)` only examines the most recent entries
7. The validator is not excluded despite having a recent failure in the tracking history

The excluded authors are used to filter batches during OptQS payload pulls: [7](#0-6) 

This breaks the security expectation that validators causing `PayloadUnavailable` failures should be excluded from OptQS operations until they demonstrate sustained reliability across their entire tracked history.

## Impact Explanation

This is **High Severity** per the Aptos bug bounty criteria under "Validator Node Slowdowns" (up to $50,000).

Byzantine validators can exploit this logic flaw to cause persistent liveness degradation:

- **Validator Node Slowdowns**: Repeated `PayloadUnavailable` timeouts force consensus rounds to time out rather than complete optimistically, degrading throughput. Each timeout adds latency to block production.
- **Protocol Logic Circumvention**: The exponential backoff mechanism designed to protect against unreliable validators is circumvented through strategic timing, not through any network-level attack.
- **Consensus Liveness Impact**: While not breaking safety (no double-spending or fund theft), up to 1/3 of validators could exploit this pattern to cause periodic timeouts, resulting in cumulative liveness degradation.
- **Byzantine Threshold Not Violated**: This attack works with any number of Byzantine validators up to the standard BFT assumption of <1/3, making it realistic within the consensus threat model.

The `PayloadUnavailable` timeout reason is specifically tracked for OptQS exclusion purposes: [8](#0-7) 

By evading exclusion, Byzantine validators can remain in the OptQS participant set and continue causing failures that trigger timeout-based consensus rounds instead of optimistic ones.

## Likelihood Explanation

**Likelihood: High** for networks with Byzantine validators who understand the consensus implementation.

**Attacker Requirements:**
- Must be an active validator in the validator set (untrusted actors within BFT threat model)
- Knowledge of the window size algorithm and timing (observable through metrics and logs)
- Ability to selectively withhold payload batches (validators control their own nodes)

**Attack Complexity: Low** once the validator understands the mechanism:
- The window algorithm is deterministic and can be observed through round outcomes
- Timing failures requires only counting rounds and controlling batch availability
- No cryptographic breaks, race conditions, or >1/3 Byzantine stake needed
- No modification of network protocols or infrastructure attacks required

Byzantine validators are explicitly assumed in the threat model for BFT consensus protocols. The exponential backoff behavior is observable, making the exploitation strategy discoverable through normal operation.

## Recommendation

Modify the exclusion logic to consider failures across the entire tracking history, not just the recent window. One approach:

1. **Option A**: Change `get_exclude_authors()` to examine all entries in the queue, not just the last `window` entries. This ensures failures remain visible until the entire queue is cleared.

2. **Option B**: Only re-enable OptQS when the entire queue has been filled with successes (i.e., `last_consecutive_success_count == past_round_statuses.len()`), consistent with the window reset condition.

3. **Option C**: Add a separate "exclusion window" that is larger than the "enable window", ensuring failures remain tracked for longer after OptQS is re-enabled.

The fix should align the exclusion checking logic with the window reset condition to maintain consistency in the failure tracking semantics.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_bitvec::BitVec;
    use aptos_consensus_types::round_timeout::RoundTimeoutReason;
    use aptos_types::validator_verifier::random_validator_verifier;

    #[test]
    fn test_byzantine_validator_evades_exclusion() {
        let (_signers, verifier) = random_validator_verifier(4, None, false);
        let ordered_authors = verifier.get_ordered_account_addresses();
        let byzantine_validator = ordered_authors[0];
        
        let mut tracker = ExponentialWindowFailureTracker::new(100, ordered_authors.clone());
        
        // Initial state: window = 2
        assert_eq!(tracker.window, 2);
        
        // Two successful rounds
        tracker.push(NewRoundReason::QCReady);
        tracker.push(NewRoundReason::QCReady);
        assert_eq!(tracker.window, 2);
        assert_eq!(tracker.last_consecutive_success_count, 2);
        
        // Byzantine validator causes PayloadUnavailable
        let mut missing_authors = BitVec::with_num_bits(4);
        missing_authors.set(0); // Byzantine validator at index 0
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable { missing_authors: missing_authors.clone() }
        ));
        
        // Window doubles to 4
        assert_eq!(tracker.window, 4);
        assert_eq!(tracker.last_consecutive_success_count, 0);
        
        // Byzantine validator should be excluded
        let excluded = tracker.get_exclude_authors();
        assert!(excluded.contains(&byzantine_validator));
        
        // Now push exactly 4 successful rounds
        for _ in 0..4 {
            tracker.push(NewRoundReason::QCReady);
        }
        
        // Window remains at 4, last_consecutive_success_count = 4
        assert_eq!(tracker.window, 4);
        assert_eq!(tracker.last_consecutive_success_count, 4);
        
        // OptQS would be enabled (4 >= 4), but check exclusions
        let excluded = tracker.get_exclude_authors();
        
        // BUG: Byzantine validator is NO LONGER excluded!
        // The PayloadUnavailable failure is at position 5 from the end,
        // but get_exclude_authors only checks the last 4 entries (all successes)
        assert!(excluded.is_empty(), "Byzantine validator evaded exclusion!");
        assert!(!excluded.contains(&byzantine_validator), "Vulnerability confirmed: validator not excluded despite recent failure in queue");
    }
}
```

**Notes:**

This is a valid logic vulnerability in the Aptos consensus layer that allows Byzantine validators to systematically evade OptQS exclusion through strategic timing of payload unavailability. The vulnerability stems from an inconsistency between the window reset condition (which checks the entire queue) and the exclusion logic (which only checks the recent window). This enables Byzantine validators to cause periodic liveness degradation within the standard BFT threat model without violating the <1/3 Byzantine assumption.

### Citations

**File:** consensus/src/liveness/proposal_status_tracker.rs (L30-46)
```rust
pub struct ExponentialWindowFailureTracker {
    window: usize,
    max_window: usize,
    past_round_statuses: BoundedVecDeque<NewRoundReason>,
    last_consecutive_success_count: usize,
    ordered_authors: Vec<Author>,
}

impl ExponentialWindowFailureTracker {
    pub(crate) fn new(max_window: usize, ordered_authors: Vec<Author>) -> Self {
        Self {
            window: 2,
            max_window,
            past_round_statuses: BoundedVecDeque::new(max_window),
            last_consecutive_success_count: 0,
            ordered_authors,
        }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L127-160)
```rust
impl TOptQSPullParamsProvider for OptQSPullParamsProvider {
    fn get_params(&self) -> Option<OptQSPayloadPullParams> {
        if !self.enable_opt_qs {
            return None;
        }

        let tracker = self.failure_tracker.lock();

        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT
            .observe(tracker.last_consecutive_success_count as f64);
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }

        let exclude_authors = tracker.get_exclude_authors();
        if !exclude_authors.is_empty() {
            let exclude_authors_str: Vec<_> =
                exclude_authors.iter().map(|a| a.short_str()).collect();
            for author in &exclude_authors_str {
                counters::OPTQS_EXCLUDE_AUTHORS_COUNT
                    .with_label_values(&[author.as_str()])
                    .inc();
            }
            warn!("OptQS exclude authors: {:?}", exclude_authors_str);
        }
        Some(OptQSPayloadPullParams {
            exclude_authors,
            minimum_batch_age_usecs: self.minimum_batch_age_usecs,
        })
    }
```

**File:** consensus/src/epoch_manager.rs (L901-904)
```rust
        let failures_tracker = Arc::new(Mutex::new(ExponentialWindowFailureTracker::new(
            100,
            epoch_state.verifier.get_ordered_account_addresses(),
        )));
```

**File:** consensus/src/round_manager.rs (L968-983)
```rust
    fn compute_timeout_reason(&self, round: Round) -> RoundTimeoutReason {
        if self.round_state().vote_sent().is_some() {
            return RoundTimeoutReason::NoQC;
        }

        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```

**File:** consensus/consensus-types/src/round_timeout.rs (L16-22)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq, Hash, Debug)]
pub enum RoundTimeoutReason {
    Unknown,
    ProposalNotReceived,
    PayloadUnavailable { missing_authors: BitVec },
    NoQC,
}
```
