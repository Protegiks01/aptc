# Audit Report

## Title
Consensus Safety Violation: Race Condition Between Fast and Slow Randomness Paths Causes Validator Divergence

## Summary
The randomness generation system has two independent paths (fast and slow) that produce cryptographically different randomness values for the same block. When these paths complete at different times across validators, some validators dequeue blocks with fast-path randomness while others use slow-path randomness, causing a consensus safety violation where validators diverge on block content.

## Finding Description

The vulnerability occurs in the interaction between the fast path and slow path randomness generation mechanisms. The system maintains two parallel randomness generation paths with different thresholds and cryptographic keys.

**Different Cryptographic Keys:**

The fast and slow paths use separate augmented key pairs generated sequentially from the same RNG, resulting in different random scalars and different deltas. [1](#0-0) 

Each call to `augment_key_pair` samples a new random scalar from the RNG, creating cryptographically distinct augmented secret keys. [2](#0-1) 

The `AugmentedData` structure explicitly stores both `delta` and `fast_delta` as separate values. [3](#0-2) 

**Different Randomness Values:**

When generating shares, each path uses its respective augmented secret key from the corresponding `RandConfig`, producing different cryptographic shares. [4](#0-3) 

During aggregation, these different shares produce different final randomness values. [5](#0-4) 

**Dual Path Aggregation:**

When metadata arrives, both slow and fast paths begin aggregating shares independently and call `try_aggregate` with the same `decision_tx` channel. [6](#0-5) 

When threshold is reached, each path spawns an asynchronous task that sends its randomness to the shared channel. [7](#0-6) 

**Race Condition and Silent Drop:**

The first randomness to arrive gets set on the block. The `set_randomness` method only succeeds if the block doesn't already have randomness, using a `OnceCell` that can only be set once. [8](#0-7) [9](#0-8) 

The block queue checks if randomness is already set before attempting to set it again. [10](#0-9) 

The main event loop processes randomness and immediately dequeues ready blocks in the same iteration. [11](#0-10) [12](#0-11) 

When the second randomness arrives, `process_randomness` attempts to find the block via `item_mut`, which returns `None` if the block was already dequeued. The randomness is then silently dropped with no error or warning. [13](#0-12) [14](#0-13) 

**Default Configuration:**

Fast randomness is enabled by default in V2 configuration, which is the standard configuration returned by `default_enabled()` and `default_for_genesis()`. [15](#0-14) [16](#0-15) [17](#0-16) 

**Divergence Scenario:**

Different validators experience different network conditions, causing shares to arrive at different times. Validator A's fast path completes first and sets `randomness_fast` on the block, which is immediately dequeued. When its slow path completes, the randomness is dropped. Validator B's slow path completes first and sets `randomness_slow`, which is immediately dequeued. Since the two paths use different augmented keys, `randomness_fast â‰  randomness_slow`, and the validators diverge on block content, violating the deterministic execution invariant.

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation)

This vulnerability directly violates consensus safety, the most critical invariant in blockchain systems. According to the Aptos bug bounty program, "Consensus/Safety violations" are categorized as Critical Severity with bounties up to $1,000,000.

The impact includes:

1. **Chain Split:** Validators diverge on block content (different randomness values), causing them to compute different state roots and potentially fork the chain.

2. **Non-Recoverable Partition:** Once validators commit blocks with different randomness, they are on incompatible forks requiring manual intervention or hard fork to resolve.

3. **Randomness-Dependent Application Failures:** On-chain applications using randomness receive different values on different validators, breaking application logic and potentially enabling exploits.

4. **Validator Set Inconsistency:** If randomness is used in validator selection or reward distribution, validators may disagree on the active validator set.

## Likelihood Explanation

**Likelihood: HIGH** when fast path is enabled (default configuration)

The vulnerability occurs naturally during normal network operation:

1. **Network Variability:** Different validators have different network topologies, latencies, and peer connections, naturally causing shares to arrive at different times.

2. **Threshold Differences:** The fast and slow paths can have different thresholds, meaning they complete at different times.

3. **No Attacker Required:** This is a natural race condition inherent in the system design, not requiring any malicious action.

4. **Probabilistic but Inevitable:** While it may not happen on every block, over thousands of blocks, the probability that at least one block experiences this race condition approaches 100%.

5. **Default Configuration:** Fast path is enabled by default in V2 configuration, meaning all networks using standard settings are vulnerable.

## Recommendation

The fast and slow paths should use the same augmented key pair to ensure they produce identical randomness values. The augmentation should happen once before the split into fast and slow paths:

```rust
// Generate augmented key pair ONCE
let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);

// Use the SAME augmented key for both paths
let (ask, apk) = augmented_key_pair.clone();
let keys = RandKeys::new(ask, apk, pk_shares, new_epoch_state.verifier.len());

// Both configs use the same augmented keys
let rand_config = RandConfig::new(..., keys.clone(), ...);
let fast_rand_config = Some(RandConfig::new(..., keys, fast_weighted_config));
```

This ensures that both paths produce the same randomness value, eliminating the consensus divergence risk while maintaining the fast path optimization (lower threshold for quicker consensus).

## Proof of Concept

While a full integration test would require setting up multiple validator nodes with controlled network conditions, the vulnerability can be demonstrated by examining the code flow:

1. The fast and slow paths generate different augmented keys
2. Both paths independently aggregate shares and send to the same channel
3. The first to complete sets the block's randomness via OnceCell
4. The block is immediately dequeued
5. The second randomness is silently dropped

The deterministic reproduction requires network timing control, but the vulnerability is inherent in the design where two cryptographically independent paths race to set a single value that determines consensus state.

### Citations

**File:** consensus/src/epoch_manager.rs (L1104-1107)
```rust
            let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);
            let fast_augmented_key_pair = if fast_randomness_is_enabled {
                if let (Some(sk), Some(pk)) = (sk.fast, pk.fast) {
                    Some(WVUF::augment_key_pair(&vuf_pp, sk, pk, &mut rng))
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L82-82)
```rust
    fn augment_key_pair<R: rand_core::RngCore + rand_core::CryptoRng>(
```

**File:** consensus/src/rand/rand_gen/types.rs (L46-49)
```rust
pub struct AugmentedData {
    delta: Delta,
    fast_delta: Option<Delta>,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L84-95)
```rust
    fn generate(rand_config: &RandConfig, rand_metadata: RandMetadata) -> RandShare<Self>
    where
        Self: Sized,
    {
        let share = Share {
            share: WVUF::create_share(
                &rand_config.keys.ask,
                bcs::to_bytes(&rand_metadata).unwrap().as_slice(),
            ),
        };
        RandShare::new(rand_config.author(), rand_metadata, share)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L69-89)
```rust
        tokio::task::spawn_blocking(move || {
            let maybe_randomness = S::aggregate(
                self.shares.values(),
                &rand_config,
                rand_metadata.metadata.clone(),
            );
            match maybe_randomness {
                Ok(randomness) => {
                    let _ = decision_tx.unbounded_send(randomness);
                },
                Err(e) => {
                    warn!(
                        epoch = rand_metadata.metadata.epoch,
                        round = rand_metadata.metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
        Either::Right(self_share)
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L261-277)
```rust
    pub fn add_rand_metadata(&mut self, rand_metadata: FullRandMetadata) {
        let rand_item = self
            .rand_map
            .entry(rand_metadata.round())
            .or_insert_with(|| RandItem::new(self.author, PathType::Slow));
        rand_item.add_metadata(&self.rand_config, rand_metadata.clone());
        rand_item.try_aggregate(&self.rand_config, self.decision_tx.clone());
        // fast path
        if let (Some(fast_rand_map), Some(fast_rand_config)) =
            (self.fast_rand_map.as_mut(), self.fast_rand_config.as_ref())
        {
            let fast_rand_item = fast_rand_map
                .entry(rand_metadata.round())
                .or_insert_with(|| RandItem::new(self.author, PathType::Fast));
            fast_rand_item.add_metadata(fast_rand_config, rand_metadata.clone());
            fast_rand_item.try_aggregate(fast_rand_config, self.decision_tx.clone());
        }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L209-209)
```rust
    randomness: OnceCell<Randomness>,
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L332-334)
```rust
    pub fn set_randomness(&self, randomness: Randomness) {
        assert!(self.randomness.set(randomness.clone()).is_ok());
    }
```

**File:** consensus/src/rand/rand_gen/block_queue.rs (L69-82)
```rust
    pub fn set_randomness(&mut self, round: Round, rand: Randomness) -> bool {
        let offset = self.offset(round);
        if !self.blocks()[offset].has_randomness() {
            observe_block(
                self.blocks()[offset].timestamp_usecs(),
                BlockStage::RAND_ADD_DECISION,
            );
            self.blocks_mut()[offset].set_randomness(rand);
            self.num_undecided_blocks -= 1;
            true
        } else {
            false
        }
    }
```

**File:** consensus/src/rand/rand_gen/block_queue.rs (L140-146)
```rust
    pub fn item_mut(&mut self, round: Round) -> Option<&mut QueueItem> {
        self.queue
            .range_mut(0..=round)
            .last()
            .map(|(_, item)| item)
            .filter(|item| item.offsets_by_round.contains_key(&round))
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L196-206)
```rust
    fn process_randomness(&mut self, randomness: Randomness) {
        let rand = hex::encode(randomness.randomness());
        info!(
            metadata = randomness.metadata(),
            rand = rand,
            "Processing decisioned randomness."
        );
        if let Some(block) = self.block_queue.item_mut(randomness.round()) {
            block.set_randomness(randomness.round(), randomness);
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L387-388)
```rust
                Some(randomness) = self.decision_rx.next()  => {
                    self.process_randomness(randomness);
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L469-472)
```rust
            let maybe_ready_blocks = self.block_queue.dequeue_rand_ready_prefix();
            if !maybe_ready_blocks.is_empty() {
                self.process_ready_blocks(maybe_ready_blocks);
            }
```

**File:** types/src/on_chain_config/randomness_config.rs (L189-191)
```rust
    pub fn default_enabled() -> Self {
        OnChainRandomnessConfig::V2(ConfigV2::default())
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L201-203)
```rust
    pub fn default_for_genesis() -> Self {
        OnChainRandomnessConfig::V2(ConfigV2::default())
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L213-219)
```rust
    pub fn fast_randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::V1(_) => false,
            OnChainRandomnessConfig::V2(_) => true,
        }
    }
```
