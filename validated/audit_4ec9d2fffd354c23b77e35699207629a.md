# Audit Report

## Title
State Version Mismatch in Events API Causes Incorrect Event Deserialization

## Summary
The Events API fetches events at a historical ledger version but creates the state view at the **current latest** checkpoint version, causing a version mismatch. This results in events being deserialized using potentially incompatible module ABIs from a different version, leading to API crashes when module upgrades occur.

## Finding Description
The vulnerability exists in the event conversion flow within the Events API's `list()` function. [1](#0-0) 

The function extracts `ledger_version` from `latest_ledger_info` (captured when the Account object was created) and fetches events at this historical version. However, when converting events to JSON format: [2](#0-1) 

The code calls `latest_state_view_poem()` which ignores the historical ledger version and instead creates a state view at the **current latest** checkpoint version: [3](#0-2) 

This implementation calls `db.latest_state_checkpoint_view()`: [4](#0-3) 

The `get_latest_state_checkpoint_version()` call at line 86 retrieves the **current** latest version from the database at invocation time, completely ignoring the historical `ledger_version` used to fetch the events.

This creates a version mismatch where:
1. Events are fetched at version V1 (historical)
2. Between event fetching and state view creation, new blocks commit, advancing to V2
3. State view is created at version V2 (latest)
4. Event deserialization loads module ABIs from V2 to interpret event data serialized at V1

The event converter's `MoveValueAnnotator` loads modules from the state view: [5](#0-4) 

When module ABIs change between V1 and V2 (e.g., struct fields added/removed/reordered), BCS deserialization will fail or produce incorrect data.

**Contrast with Correct Implementation:** [6](#0-5) 

The `get_resources_by_pagination()` function demonstrates the correct pattern: it uses `state_view_at_version(version)` to ensure the state view matches the version at which data was fetched.

## Impact Explanation
**Severity: High**

This vulnerability causes:

1. **API Crashes**: When module ABIs change incompatibly between V1 and V2, BCS deserialization fails. The error handling converts this to a 500 Internal Server Error: [7](#0-6) 

2. **Data Corruption**: If deserialization succeeds but interprets fields incorrectly (e.g., field reordering), clients receive corrupted event data, potentially leading to incorrect application state or financial calculations in dependent systems.

3. **State Inconsistency**: Different API nodes queried at different times return different results for the same historical event query, violating blockchain immutability guarantees.

This meets the **High Severity** criteria per the Aptos bug bounty program: "API crashes" are explicitly listed as High severity impacts.

**Note**: This vulnerability only affects JSON API responses. BCS responses return raw event data without deserialization and are not affected.

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability occurs naturally without attacker intervention when:

1. **Module Upgrades**: The Aptos framework or user modules are upgraded with changes to event struct definitions
2. **API Request Timing**: An API request spans the module upgrade (Account created before upgrade, state view created after)
3. **Event Usage**: The queried events use the upgraded event type

The race window exists between:
- Line 79: `Account::new()` captures ledger info at T1
- Line 184: `latest_state_view_poem()` called at T2

While module upgrades are not continuous like block production, they do occur regularly during framework upgrades and user module deployments. The vulnerability manifests naturally during these upgrade windows without requiring attacker intervention.

## Recommendation
Replace `latest_state_view_poem()` with `state_view_at_version()` to ensure the state view matches the version at which events were fetched:

```rust
// In events.rs list() function, replace line 184:
// OLD:
let state_view = self.context.latest_state_view_poem(&latest_ledger_info)?;

// NEW:
let state_view = self.context.state_view_at_version(ledger_version)
    .context("Failed to create state view at version")
    .map_err(|err| {
        BasicErrorWith404::internal_with_code(
            err,
            AptosErrorCode::InternalError,
            &latest_ledger_info,
        )
    })?;
```

This ensures module ABIs are loaded from the same version as the event data, maintaining consistency.

## Proof of Concept
Reproduction steps:

1. Deploy a Move module with events that have a specific struct definition
2. Emit events using this module
3. Upgrade the module to change the event struct (add/remove/reorder fields)
4. Query historical events from before the upgrade via the Events API JSON endpoint
5. Observe either:
   - 500 Internal Server Error (if changes are incompatible)
   - Corrupted event data (if changes allow deserialization but with wrong field mappings)

The vulnerability can be verified by comparing the behavior with the correct implementation in `get_resources_by_pagination()` which uses version-matched state views.

## Notes
- The vulnerability is specific to the JSON API response format; BCS responses are unaffected as they return raw event data
- The issue represents a violation of the blockchain immutability guarantee where historical data should always be interpreted consistently
- The correct implementation pattern already exists elsewhere in the codebase (e.g., `get_resources_by_pagination()`), making this a straightforward fix

### Citations

**File:** api/src/events.rs (L162-169)
```rust
        let ledger_version = latest_ledger_info.version();
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
```

**File:** api/src/events.rs (L184-186)
```rust
                    .latest_state_view_poem(&latest_ledger_info)?
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                    .try_into_versioned_events(&events)
```

**File:** api/src/events.rs (L187-194)
```rust
                    .context("Failed to convert events from storage into response")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &latest_ledger_info,
                        )
                    })?;
```

**File:** api/src/context.rs (L160-168)
```rust
    pub fn latest_state_view_poem<E: InternalError>(
        &self,
        ledger_info: &LedgerInfo,
    ) -> Result<DbStateView, E> {
        self.db
            .latest_state_checkpoint_view()
            .context("Failed to read latest state checkpoint from DB")
            .map_err(|e| E::internal_with_code(e, AptosErrorCode::InternalError, ledger_info))
    }
```

**File:** api/src/context.rs (L532-533)
```rust
        let state_view = self.state_view_at_version(version)?;
        let converter = state_view.as_converter(self.db.clone(), self.indexer_reader.clone());
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L56-68)
```rust
    fn view_compiled_module(&self, module_id: &ModuleId) -> anyhow::Result<Option<Self::Item>> {
        let mut module_cache = self.module_cache.borrow_mut();
        if let Some(module) = module_cache.get(module_id) {
            return Ok(Some(module.clone()));
        }

        let state_key = StateKey::module_id(module_id);
        Ok(
            match self
                .state_view
                .get_state_value_bytes(&state_key)
                .map_err(|e| anyhow!("Error retrieving module {:?}: {:?}", module_id, e))?
            {
```
