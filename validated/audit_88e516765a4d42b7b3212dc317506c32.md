# Audit Report

## Title
Unstable Bytecode Deployment Bypass via CompilationMetadata Stripping on Mainnet

## Summary
The mainnet protection mechanism that prevents deployment of bytecode compiled with unstable compiler/language versions can be bypassed by removing the `CompilationMetadata` from compiled modules. When `CompilationMetadata` is absent, the system assumes the bytecode is legacy/stable and allows it on mainnet, violating the production readiness guarantees enforced by the `_REJECT_UNSTABLE_BYTECODE` feature flag.

## Finding Description

The Aptos blockchain enforces that bytecode compiled with unstable compiler or language versions cannot be published or executed on mainnet. This protection is implemented in the `reject_unstable_bytecode` function which is called during module publishing validation. [1](#0-0) 

The function checks whether `CompilationMetadata` exists and if it marks the code as unstable. However, the critical flaw is that when `get_compilation_metadata(module)` returns `None`, the check is completely skipped and the module passes validation. [2](#0-1) 

The `get_compilation_metadata` function returns `None` when no metadata entry with `COMPILATION_METADATA_KEY` exists in the bytecode. [3](#0-2) 

Currently, `CompilerVersion::V2_1` is marked as unstable [4](#0-3) , and language versions `V2_4` and `V2_5` are also marked as unstable. [5](#0-4) 

**Attack Path:**
1. Attacker compiles Move code using an unstable compiler version (e.g., V2_1) or language version (e.g., V2_4/V2_5)
2. The modern V2 compiler automatically embeds `CompilationMetadata` with `unstable: true` [6](#0-5) 
3. Attacker deserializes the `CompiledModule` bytecode
4. Attacker removes the `CompilationMetadata` entry from the metadata vector
5. Attacker re-serializes the modified bytecode
6. Attacker publishes to mainnet via normal publishing API
7. In `validate_publish_request`, the `reject_unstable_bytecode` check passes because `get_compilation_metadata()` returns `None` [7](#0-6) 
8. Unstable bytecode is accepted and deployed on mainnet

The metadata format validation does not require `CompilationMetadata` to be present - it only validates format if metadata exists. [8](#0-7) 

This behavior was originally designed for backward compatibility with V1 modules that predate the `CompilationMetadata` feature [9](#0-8) , but it creates a bypass for modern V2 modules where an attacker intentionally strips metadata.

## Impact Explanation

This vulnerability allows bypassing a critical production safety control. The impact qualifies as **Medium Severity** under the "Limited Protocol Violations" category because:

1. **Protocol Violation**: Mainnet explicitly forbids unstable bytecode through the `_REJECT_UNSTABLE_BYTECODE` feature flag (flag 58), which is permanently enabled and cannot be disabled. [10](#0-9) 

2. **Test Suite Confirms Expected Behavior**: The test suite explicitly verifies that unstable compiler code should be rejected on mainnet. [11](#0-10) 

3. **Production Risk**: Unstable versions are marked as "experimental and should not be used in production" [12](#0-11) , indicating they may contain experimental features, compiler bugs, or untested semantic changes that could potentially cause validator issues or unexpected behavior.

4. **Lack of Integrity Protection**: The metadata has no cryptographic binding to the bytecode, making stripping trivial through standard deserialization/serialization operations demonstrated in existing tests. [13](#0-12) 

While the concrete harm from specific unstable features is speculative, the existence of this permanent mainnet control indicates Aptos considers unstable bytecode a genuine production risk.

## Likelihood Explanation

**Likelihood: Medium**

The attack is technically straightforward to execute:
- Requires only standard bytecode manipulation (deserialize → modify → serialize)
- No special privileges beyond normal module publishing rights
- Pattern is already used in test infrastructure for metadata manipulation [14](#0-13) 
- The attack surface is permanent

However, the attacker must:
- Have access to unstable compiler versions
- Deliberately strip metadata (not accidental)
- Have a specific reason to use unstable features on mainnet

The likelihood increases if unstable versions offer desirable features unavailable in stable releases or if developers inadvertently attempt deployment after testing with unstable versions.

## Recommendation

Modify the `reject_unstable_bytecode` function to reject modules when `CompilationMetadata` is absent AND the module uses bytecode features that did not exist in V1. This maintains backward compatibility for legitimate legacy modules while preventing the bypass.

Alternatively, implement a more robust approach:
1. Add a feature flag to require `CompilationMetadata` on all new module deployments
2. During the transition period, log warnings for modules without metadata
3. After sufficient notice, enforce mandatory metadata presence
4. For legacy V1 modules, verify they only use V1 bytecode features

A simple immediate fix:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            let metadata = get_compilation_metadata(module);
            if metadata.is_none() {
                // Check if module uses bytecode version > V1
                // If yes, reject as it should have metadata
                if module.version > VERSION_1 {
                    return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message("modules compiled with v2+ must include compilation metadata".to_string())
                        .finish(Location::Undefined));
                }
            } else if metadata.unwrap().unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message("code marked unstable is not published on mainnet".to_string())
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn test_unstable_bytecode_bypass_via_metadata_stripping() {
    use aptos_types::chain_id::ChainId;
    use move_binary_format::CompiledModule;
    use aptos_framework::{BuildOptions, BuiltPackage};
    use aptos_package_builder::PackageBuilder;
    use move_model::metadata::CompilerVersion;
    
    let mut h = MoveHarness::new_with_chain_id(ChainId::mainnet());
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Build package with unstable compiler
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", r#"
        module 0xf00d::M {
            public fun foo(): u64 { 42 }
        }
    "#);
    let path = builder.write_to_temp().unwrap();
    
    let package = BuiltPackage::build(
        path.path().to_path_buf(),
        BuildOptions {
            compiler_version: Some(CompilerVersion::V2_1), // Unstable version
            ..BuildOptions::default()
        }
    ).expect("building package must succeed");
    
    // Extract and strip metadata
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    
    // Remove compilation metadata
    compiled_module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    let mut stripped_code = vec![];
    compiled_module.serialize(&mut stripped_code).unwrap();
    
    // Attempt to publish - should fail but currently succeeds
    let result = h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            vec![stripped_code],
        ),
    );
    
    // This assertion SHOULD pass (module should be rejected)
    // but currently FAILS (module is accepted)
    assert_vm_status!(result, StatusCode::UNSTABLE_BYTECODE_REJECTED);
}
```

## Notes

This vulnerability represents a logic flaw where the absence of metadata (designed for backward compatibility) creates an unintended bypass path. The fix requires carefully distinguishing between legitimate legacy V1 modules and modern V2 modules with deliberately stripped metadata.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1689-1689)
```rust
        self.reject_unstable_bytecode(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1756)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
```

**File:** types/src/vm/module_metadata.rs (L253-282)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
```

**File:** types/src/vm/module_metadata.rs (L311-316)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
```

**File:** types/src/vm/module_metadata.rs (L452-456)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** third_party/move/move-model/src/metadata.rs (L65-70)
```rust
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
```

**File:** third_party/move/move-model/src/metadata.rs (L149-150)
```rust
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
```

**File:** third_party/move/move-model/src/metadata.rs (L151-156)
```rust
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
```

**File:** third_party/move/move-model/src/metadata.rs (L288-293)
```rust
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L79-80)
```rust
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L104-127)
```rust
fn test_metadata_with_changes(f: impl Fn() -> Vec<Metadata>) -> TransactionStatus {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun foo(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L318-331)
```rust
#[test]
fn test_compilation_metadata() {
    // publish unstable compiler code to mainnet
    assert_vm_status!(
        test_compilation_metadata_internal(true, true),
        StatusCode::UNSTABLE_BYTECODE_REJECTED
    );
    // publish stable compiler code to mainnet
    assert_success!(test_compilation_metadata_internal(true, false,));
    // publish unstable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, true,));
    // publish stable compiler code to test
    assert_success!(test_compilation_metadata_internal(false, false,));
}
```
