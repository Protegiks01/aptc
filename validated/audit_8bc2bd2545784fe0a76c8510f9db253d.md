# Audit Report

## Title
Race Condition Between Fallback and Commit Sync Causes State Corruption in Consensus Observer

## Summary
The consensus observer's state sync system has a critical race condition where concurrent fallback sync and commit sync operations can cause state corruption. The `process_fallback_sync_notification()` handler lacks validation to prevent overwriting the root ledger info set by a concurrent commit sync operation, causing observer nodes to end up at incorrect ledger positions and requiring manual intervention to recover.

## Finding Description
The vulnerability exists in how the consensus observer handles two independent synchronization mechanisms that can execute concurrently:

**1. Fallback Sync:** Triggered when the observer falls behind, syncing for a configured duration. [1](#0-0) 

**2. Commit Sync:** Triggered when a commit decision arrives for a future round, syncing to a specific target. [2](#0-1) 

The state sync manager stores these as separate optional fields, allowing both to be active simultaneously: [3](#0-2) 

**The Critical Flaw:**

When a commit decision arrives for a future round within the same epoch, the system only checks `is_syncing_through_epoch()` which requires an epoch change. It does NOT check if fallback sync is already active: [4](#0-3) 

This allows the commit sync to start while fallback sync is running. The root is updated to the commit target, and both sync tasks execute concurrently.

The vulnerability manifests in `process_fallback_sync_notification()` which only validates that fallback mode is active but does NOT validate the synced ledger info against the current root: [5](#0-4) 

In contrast, `process_commit_sync_notification()` properly validates the synced ledger info against the block data root and rejects notifications that don't match: [6](#0-5) 

**Exploitation Scenario:**
1. Observer enters fallback mode at epoch 5, round 100 (spawns async task A)
2. While task A runs, commit decision arrives for epoch 5, round 150
3. Root is updated to (5, 150) via `update_blocks_for_state_sync_commit()`
4. Commit sync starts (spawns async task B)
5. Task A completes first, sends `FallbackSyncCompleted(5, 100)`
6. Handler checks `in_fallback_mode()` â†’ passes, updates root to (5, 100)
7. Task B completes, sends `CommitSyncCompleted(5, 150)`
8. Handler validates (5, 150) > (5, 100), rejects as invalid
9. **Observer stuck at wrong position (5, 100) instead of correct (5, 150)**

The notifications are processed sequentially through the event loop: [7](#0-6) 

## Impact Explanation
This is **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention."

The vulnerability breaks the state consistency invariant for consensus observer nodes. Affected observers:
- End up at incorrect ledger positions diverging from the actual chain state
- Cannot process newer blocks and commit decisions
- Lose consensus observer functionality until manually recovered
- Require operator intervention to restore normal operation

This meets the Medium severity threshold because it causes state corruption requiring intervention but does not result in fund loss, consensus safety violations, or validator compromise. Observer nodes do not participate in consensus or hold funds, limiting the blast radius to observer functionality degradation.

## Likelihood Explanation
**Likelihood: High**

This race condition occurs naturally during normal network operations:
- **Network delays** regularly cause observers to fall behind, triggering fallback sync
- **Commit decisions** from subscribed peers arrive continuously during normal operation
- **Timing window** is the entire fallback sync duration (configurable, typically several seconds)
- **No attacker control needed** - purely timing-dependent on network conditions
- **Deterministic exploitation** - once the race condition triggers, state corruption is guaranteed

The vulnerability can trigger during routine operations without any malicious intent or coordination.

## Recommendation
Add validation in `process_fallback_sync_notification()` to prevent overwriting a newer root:

```rust
async fn process_fallback_sync_notification(
    &mut self,
    latest_synced_ledger_info: LedgerInfoWithSignatures,
) {
    // Get the epoch and round for the latest synced ledger info
    let ledger_info = latest_synced_ledger_info.ledger_info();
    let epoch = ledger_info.epoch();
    let round = ledger_info.round();

    // Verify that there is an active fallback sync
    if !self.state_sync_manager.in_fallback_mode() {
        error!(LogSchema::new(LogEntry::ConsensusObserver).message(
            "Failed to process fallback sync notification! No active fallback sync found!"
        ));
        return;
    }

    // **NEW: Validate against current root**
    let current_root = self.observer_block_data.lock().root();
    let current_epoch = current_root.ledger_info().epoch();
    let current_round = current_root.ledger_info().round();
    
    if (epoch, round) < (current_epoch, current_round) {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Ignoring stale fallback sync notification for epoch: {}, round: {}! Current root: epoch {}, round {}",
                epoch, round, current_epoch, current_round
            ))
        );
        self.state_sync_manager.clear_active_fallback_sync();
        return;
    }

    // Continue with existing logic...
    self.observer_fallback_manager
        .reset_syncing_progress(&latest_synced_ledger_info);
    self.observer_block_data
        .lock()
        .update_root(latest_synced_ledger_info);
    // ... rest of the function
}
```

Additionally, consider preventing concurrent sync operations by checking `in_fallback_mode()` before starting commit sync, or aborting the fallback sync when a commit sync is initiated.

## Proof of Concept
This vulnerability can be demonstrated by creating a test scenario where:

1. Start a fallback sync with a slow state sync client (using delays)
2. Before fallback completes, inject a commit decision for a higher round in the same epoch
3. Verify root is updated to the commit target
4. Allow fallback to complete first
5. Verify root is incorrectly overwritten to the fallback sync target
6. Verify commit sync completion is rejected

A complete PoC would require mocking the execution client to control sync timing and create the race condition window, demonstrating that the fallback notification can overwrite a newer commit sync root.

## Notes
This vulnerability affects the consensus observer component, which is part of the Aptos Core consensus layer. While observer nodes do not participate in consensus voting, they are critical infrastructure for monitoring and relaying consensus state. The state corruption caused by this race condition requires manual operator intervention to detect and resolve, making it a legitimate Medium severity security issue per the Aptos bug bounty program criteria.

### Citations

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L53-61)
```rust
    // The active fallback sync handle. If this is set, it means that
    // we've fallen back to state sync, and we should wait for it to complete.
    fallback_sync_handle: Option<DropGuard>,

    // The active sync to commit handle. If this is set, it means that
    // we're waiting for state sync to synchronize to a known commit decision.
    // The flag indicates if the commit will transition us to a new epoch.
    sync_to_commit_handle: Option<(DropGuard, bool)>,
}
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L116-187)
```rust
    /// Invokes state sync to synchronize in fallback mode
    pub fn sync_for_fallback(&mut self) {
        // Log that we're starting to sync in fallback mode
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing in fallback mode! Syncing duration: {:?} ms!",
                self.consensus_observer_config.observer_fallback_duration_ms
            ))
        );

        // Update the state sync fallback counter
        metrics::increment_counter_without_labels(&metrics::OBSERVER_STATE_SYNC_FALLBACK_COUNTER);

        // Clone the required components for the state sync task
        let consensus_observer_config = self.consensus_observer_config;
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync for the fallback
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing for the fallback
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );

                // Get the fallback duration
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };

                // Notify consensus observer that we've synced for the fallback
                let state_sync_notification =
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info);
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for fallback! Error: {:?}",
                            error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    0, // We're no longer syncing for the fallback
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L189-258)
```rust
    /// Invokes state sync to synchronize to a new commit decision
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );

        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Clone the required components for the state sync task
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }

                // Notify consensus observer that we've synced to the commit decision
                let state_sync_notification = StateSyncNotification::commit_sync_completed(
                    commit_decision.commit_proof().clone(),
                );
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for commit decision epoch: {:?}, round: {:?}! Error: {:?}",
                            commit_epoch, commit_round, error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    0, // We're no longer syncing to a commit decision
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L917-965)
```rust
    async fn process_fallback_sync_notification(
        &mut self,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) {
        // Get the epoch and round for the latest synced ledger info
        let ledger_info = latest_synced_ledger_info.ledger_info();
        let epoch = ledger_info.epoch();
        let round = ledger_info.round();

        // Log the state sync notification
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Received state sync notification for fallback completion! Epoch {}, round: {}!",
                epoch, round
            ))
        );

        // Verify that there is an active fallback sync
        if !self.state_sync_manager.in_fallback_mode() {
            // Log the error and return early
            error!(LogSchema::new(LogEntry::ConsensusObserver).message(
                "Failed to process fallback sync notification! No active fallback sync found!"
            ));
            return;
        }

        // Reset the fallback manager state
        self.observer_fallback_manager
            .reset_syncing_progress(&latest_synced_ledger_info);

        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);

        // If the epoch has changed, end the current epoch and start the latest one
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };

        // Reset the pending block state
        self.clear_pending_block_state().await;

        // Reset the state sync manager for the synced fallback
        self.state_sync_manager.clear_active_fallback_sync();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L968-1023)
```rust
    async fn process_commit_sync_notification(
        &mut self,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) {
        // Get the epoch and round for the synced commit decision
        let ledger_info = latest_synced_ledger_info.ledger_info();
        let synced_epoch = ledger_info.epoch();
        let synced_round = ledger_info.round();

        // Log the state sync notification
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Received state sync notification for commit completion! Synced epoch {}, round: {}!",
                synced_epoch, synced_round
            ))
        );

        // Verify that there is an active commit sync
        if !self.state_sync_manager.is_syncing_to_commit() {
            // Log the error and return early
            error!(LogSchema::new(LogEntry::ConsensusObserver).message(
                "Failed to process commit sync notification! No active commit sync found!"
            ));
            return;
        }

        // Get the block data root epoch and round
        let block_data_root = self.observer_block_data.lock().root();
        let block_data_epoch = block_data_root.ledger_info().epoch();
        let block_data_round = block_data_root.ledger_info().round();

        // If the commit sync notification is behind the block data root, ignore it. This
        // is possible due to a race condition where we started syncing to a newer commit
        // at the same time that state sync sent the notification for a previous commit.
        if (synced_epoch, synced_round) < (block_data_epoch, block_data_round) {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Ignoring old commit sync notification for epoch: {}, round: {}! Current root: {:?}",
                    synced_epoch, synced_round, block_data_root
                ))
            );
            return;
        }

        // If the commit sync notification is ahead the block data root, something has gone wrong!
        if (synced_epoch, synced_round) > (block_data_epoch, block_data_round) {
            // Log the error, reset the state sync manager and return early
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received invalid commit sync notification for epoch: {}, round: {}! Current root: {:?}",
                    synced_epoch, synced_round, block_data_root
                ))
            );
            self.state_sync_manager.clear_active_commit_sync();
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1127-1142)
```rust
        loop {
            tokio::select! {
                Some(network_message) = consensus_observer_message_receiver.next() => {
                    self.process_network_message(network_message).await;
                }
                Some(state_sync_notification) = state_sync_notification_listener.recv() => {
                    self.process_state_sync_notification(state_sync_notification).await;
                },
                _ = progress_check_interval.select_next_some() => {
                    self.check_progress().await;
                }
                else => {
                    break; // Exit the consensus observer loop
                }
            }
        }
```
