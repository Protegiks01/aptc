# Audit Report

## Title
Validator Node Panic Due to Partial State in ledger_update() Retry Scenario

## Summary
The `ledger_update()` function in BlockExecutor sets `state_checkpoint_output` and `ledger_update_output` sequentially using `OnceCell` fields. If an error occurs after the first field is set but before the second completes, the block remains with partial state. A subsequent call to `ledger_update()` on the same block triggers a panic when attempting to set the already-set `state_checkpoint_output`, causing validator node crash.

## Finding Description

The vulnerability exists in the block executor's ledger update workflow. The `PartialStateComputeResult` structure uses two `OnceCell` fields to store computation results: [1](#0-0) 

The `get_complete_result()` method only checks if `ledger_update_output` is set, returning `None` if it's not: [2](#0-1) 

In the `ledger_update()` function, these outputs are set sequentially within a closure: [3](#0-2) 

The critical issue is that if any error occurs between lines 320 (after `set_state_checkpoint_output()` succeeds) and line 328 (before `set_ledger_update_output()` completes), the block remains in the BlockTree with `state_checkpoint_output` SET but `ledger_update_output` NOT SET.

The retry detection check uses `get_complete_result()`: [4](#0-3) 

Since `get_complete_result()` only checks `ledger_update_output`, this partial state is not detected, and execution continues to line 315-320 where it attempts to set `state_checkpoint_output` again.

The `set_state_checkpoint_output()` method panics when called on an already-set `OnceCell`: [5](#0-4) 

This panic crashes the validator node.

**Potential Failure Points:**
1. The `.expect("Already sorted.")` in `DoLedgerUpdate::run()` can panic: [6](#0-5) 

2. Resource exhaustion (OOM, thread pool) could cause failures
3. The fail-point infrastructure indicates error injection is anticipated: [7](#0-6) 

## Impact Explanation

**Medium Severity**: This vulnerability causes validator node crashes, resulting in temporary liveness loss for affected validators. While this doesn't compromise consensus safety (the network can continue with 2/3+ honest validators), it reduces network resilience and forces validator operators to manually intervene.

The impact aligns with Medium severity per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention" and node availability issues. The validator must be restarted to recover, and the problematic block may need to be handled specially.

## Likelihood Explanation

**Low to Low-Medium Likelihood**: The vulnerability requires specific conditions:

1. `DoStateCheckpoint::run()` must succeed (line 315-320)
2. A failure must occur before `set_ledger_update_output()` completes (line 321-328)
3. The same block's `ledger_update()` must be invoked again

The TODO comment acknowledges uncertainty about retry scenarios: [8](#0-7) 

While the normal consensus pipeline doesn't have explicit retry logic for ledger_update failures, the presence of defensive checks and TODO comments suggests the developers are aware that retry scenarios may exist in edge cases (epoch transitions, network issues, operator intervention, or future code modifications).

## Recommendation

Modify the retry check to detect partial state:

```rust
// Check if already complete OR if partial state exists
if let Some(complete_result) = block.output.get_complete_result() {
    info!(block_id = block_id, "ledger_update already done.");
    return Ok(complete_result);
}

// NEW: Check for partial state and handle appropriately
if block.output.state_checkpoint_output.get().is_some() {
    error!(block_id = block_id, "Partial state detected - state_checkpoint_output set but ledger_update_output not set");
    return Err(ExecutorError::InternalError {
        error: "Partial ledger update state detected".to_string(),
    }.into());
}
```

Alternatively, make the operation atomic or use a different synchronization mechanism that prevents partial state.

## Proof of Concept

While a full PoC requires consensus infrastructure, the vulnerability can be demonstrated with a unit test showing the panic:

```rust
#[test]
#[should_panic(expected = "StateCheckpointOutput already set")]
fn test_double_set_state_checkpoint_panic() {
    let execution_output = ExecutionOutput::new_empty(/* ... */);
    let partial_result = PartialStateComputeResult::new(execution_output);
    
    // First set succeeds
    partial_result.set_state_checkpoint_output(/* ... */);
    
    // Second set panics
    partial_result.set_state_checkpoint_output(/* ... */);
}
```

## Notes

This is a logic vulnerability in the code structure. While the exact retry mechanism that would trigger this in production is not explicitly visible in the current consensus pipeline, the defensive checks, TODO comments, and fail-point infrastructure indicate the developers themselves are uncertain about whether retry scenarios can occur. The code definitively allows partial state and lacks proper detection, making this a valid vulnerability that should be addressed.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L84-87)
```rust
                        .status()
                        .as_kept_status()
                        .expect("Already sorted."),
                    auxiliary_info_hash,
```
