# Audit Report

## Title
Vote Counting Inconsistency Leading to Consensus Liveness Degradation via Invalid Signature Phantom Votes

## Summary
A validator can send a vote with an invalid signature that passes initial optimistic verification but fails during batch signature aggregation, creating a "phantom vote" that is recorded in the author tracking map but excluded from signature aggregation. This prevents the validator from correcting their vote and can cause rounds to fail to form Quorum Certificates (QCs), leading to consensus liveness degradation.

## Finding Description

The vulnerability exists in the interaction between optimistic signature verification and the vote aggregation logic in `insert_vote()`. When optimistic signature verification is enabled (the default configuration), the system exhibits the following critical flow:

**1. Optimistic Verification Allows Invalid Signatures Through**

By default, `optimistic_sig_verification` is enabled in production: [1](#0-0) 

When a vote is received and verified, the `Vote::verify()` method calls `optimistic_verify()`: [2](#0-1) 

The `optimistic_verify()` function returns `Ok()` without actually verifying the signature if the author is not in the pessimistic verify set and optimistic verification is enabled: [3](#0-2) 

**2. Vote Added to Author Map Before Signature Verification**

In `insert_vote()`, after basic duplicate checks, the vote is immediately added to the `author_to_vote` map: [4](#0-3) 

The duplicate detection logic only checks the ledger info digest, not the signature itself.

**3. Optimistic Voting Power Check Counts All Signatures**

The `check_voting_power()` call in the SignatureAggregator uses `all_voters()` which counts ALL voters regardless of signature validity: [5](#0-4) 

The `all_voters()` method returns all signatures without validation: [6](#0-5) 

**4. Batch Verification Filters Out Invalid Signatures**

When apparent quorum is reached, `aggregate_and_verify()` is called: [7](#0-6) 

Inside `aggregate_and_verify()`, if batch signature verification fails, `filter_invalid_signatures()` removes invalid signatures: [8](#0-7) 

The filtering process verifies each signature individually using parallel iteration and removes those that fail: [9](#0-8) 

**5. Insufficient Voting Power After Filtering**

After filtering, `try_aggregate()` is called again, which can fail with `TooLittleVotingPower` if the remaining valid signatures don't meet quorum: [10](#0-9) 

This error is caught in `insert_vote()` and the reduced voting power is returned: [11](#0-10) 

**6. Phantom Vote: Cannot Resend Valid Signature**

The critical issue is that the vote remains in `author_to_vote` map (added at line 315-316), but the signature was removed from the aggregator by `filter_invalid_signatures()`. When the validator attempts to resend with a valid signature, duplicate detection blocks it because it only checks the ledger info digest, not the signature: [12](#0-11) 

This creates a desynchronization where:
- The vote is recorded in `author_to_vote` 
- The signature was filtered out from the aggregator
- The vote returns `VoteAdded` (appears accepted)
- But it doesn't contribute to QC formation
- The validator cannot correct it by resending

**Attack Scenario:**

Consider 4 validators with voting power: A(30%), B(30%), C(20%), D(20%), where quorum = 67%:

1. Validators A and B send valid votes (60% total)
2. Validator C sends a vote with an invalid signature (passes optimistic verification)
3. `check_voting_power()` sees 80% (A + B + C) ≥ 67%, proceeds to aggregate
4. Batch signature verification fails due to C's invalid signature
5. After filtering, only A and B remain (60% < 67%)
6. `TooLittleVotingPower` is returned with voting_power = 60
7. C's vote remains in `author_to_vote` but signature is removed from aggregator
8. C attempts to resend with valid signature → rejected as `DuplicateVote`
9. If D is offline or Byzantine, the round cannot form a QC
10. Round times out, forcing slower timeout-based consensus progression

The test case `test_qc_aggregation_with_unverified_votes` demonstrates the filtering behavior: [13](#0-12) 

However, this test does not cover the case where the validator attempts to resend with a valid signature after filtering, which is the critical vulnerability.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program, specifically category 8: "Validator Node Slowdowns."

**Concrete Impacts:**
- **Liveness Degradation**: Rounds repeatedly fail to form QCs when validators have invalid signatures, forcing timeout-based round progression which is significantly slower than normal consensus operation
- **Protocol Violation**: Votes are accepted (return `VoteAdded`) but don't contribute to QCs, violating the invariant that accepted votes with sufficient voting power should form QCs
- **Resource Waste**: Validators waste computational resources attempting aggregation that will fail, and the round wastes time waiting for a QC that cannot form

**Why NOT Critical:**
- Consensus safety is maintained (no double-signing or chain splits)
- The system eventually recovers after round timeout
- No funds are lost, stolen, or permanently frozen
- Network availability is degraded but not eliminated
- Requires only temporary manual intervention if persistent

## Likelihood Explanation

**For Honest Validators: Low to Medium**
- Could occur due to software bugs in signature generation libraries
- Key corruption or inconsistent cryptographic state during validator operations
- Implementation errors in BLS signature handling
- Race conditions during concurrent signature creation

**For Byzantine Validators: High**
- Trivially exploitable by any validator in the active set
- Requires no special privileges beyond validator status
- Can be triggered deterministically by sending intentionally invalid signatures
- No cryptographic complexity required
- Byzantine validators (up to f < n/3) can coordinate to amplify the effect

**Overall Likelihood: Medium** - While honest validators generating invalid signatures should be rare, the ease of exploitation by Byzantine actors (who are expected to exist within the < n/3 threshold) and the complete lack of recovery mechanism make this a realistic attack vector that could manifest in production.

## Recommendation

**Short-term Fix**: Modify the duplicate vote detection logic to allow updating a vote if the previous signature was filtered out. Track which votes had their signatures removed during filtering and allow those specific authors to resend.

**Implementation Approach**:
1. Add a field to track authors whose signatures were filtered: `filtered_authors: HashSet<AccountAddress>`
2. In `filter_invalid_signatures`, record which authors were filtered
3. In duplicate detection, check if author is in `filtered_authors` and allow the resend
4. Remove author from `filtered_authors` after accepting the new vote

**Long-term Fix**: Consider implementing a signature verification cache or requiring immediate verification for validators with a history of invalid signatures (expand the pessimistic_verify_set trigger conditions).

## Proof of Concept

The existing test demonstrates the filtering behavior but not the inability to resend. A complete PoC would involve:

1. Setting up 4 validators with voting power as described
2. Having validator C send a vote with an invalid signature
3. Verifying that `VoteAdded` is returned
4. Verifying that after filtering, voting power is insufficient
5. Attempting to resend from validator C with a valid signature
6. Confirming that `DuplicateVote` is returned
7. Demonstrating that the round times out without forming a QC

The code paths verified in this report confirm this behavior will occur as described.

### Citations

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** consensus/consensus-types/src/vote.rs (L151-160)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        // TODO(ibalajiarun): Ensure timeout is None if RoundTimeoutMsg is enabled.

        ensure!(
            self.ledger_info.consensus_data_hash() == self.vote_data.hash(),
            "Vote's hash mismatch with LedgerInfo"
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Vote")?;
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pending_votes.rs (L287-316)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }

        //
        // 2. Store new vote (or update, in case it's a new timeout vote)
        //

        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));
```

**File:** consensus/src/pending_votes.rs (L371-400)
```rust
                match sig_aggregator.check_voting_power(validator_verifier, true) {
                    // a quorum of signature was reached, a new QC is formed
                    Ok(aggregated_voting_power) => {
                        assert!(
                                aggregated_voting_power >= validator_verifier.quorum_voting_power(),
                                "QC aggregation should not be triggered if we don't have enough votes to form a QC"
                            );
                        let verification_result = {
                            let _timer = counters::VERIFY_MSG
                                .with_label_values(&["vote_aggregate_and_verify"])
                                .start_timer();

                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
                        match verification_result {
                            Ok(ledger_info_with_sig) => {
                                *status = VoteStatus::EnoughVotes(ledger_info_with_sig.clone());
                                return VoteReceptionResult::NewQuorumCertificate(Arc::new(
                                    QuorumCert::new(vote.vote_data().clone(), ledger_info_with_sig),
                                ));
                            },
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                voting_power
                            },
                            Err(e) => return VoteReceptionResult::ErrorAggregatingSignature(e),
                        }
```

**File:** consensus/src/pending_votes.rs (L660-789)
```rust
    fn test_qc_aggregation_with_unverified_votes() {
        ::aptos_logger::Logger::init_for_testing();

        // set up 4 validators
        let (signers, validator_verifier) = random_validator_verifier(7, Some(3), false);
        let mut pending_votes = PendingVotes::new();

        // create random vote from validator[0]
        let mut li = random_ledger_info();
        let vote_data = random_vote_data();
        li.set_consensus_data_hash(vote_data.hash());
        let li_hash = li.hash();

        let mut partial_sigs = PartialSignatures::empty();

        let vote_0 = Vote::new(
            vote_data.clone(),
            signers[0].author(),
            li.clone(),
            &signers[0],
        )
        .unwrap();

        let vote_1 = Vote::new(
            vote_data.clone(),
            signers[1].author(),
            li.clone(),
            &signers[1],
        )
        .unwrap();

        let vote_2 = Vote::new_with_signature(
            vote_data.clone(),
            signers[2].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let vote_3 = Vote::new(
            vote_data.clone(),
            signers[3].author(),
            li.clone(),
            &signers[3],
        )
        .unwrap();

        let vote_4 = Vote::new(
            vote_data.clone(),
            signers[4].author(),
            li.clone(),
            &signers[4],
        )
        .unwrap();

        // first time a new vote is added -> VoteAdded
        assert_eq!(
            pending_votes.insert_vote(&vote_0, &validator_verifier),
            VoteReceptionResult::VoteAdded(1)
        );
        partial_sigs.add_signature(signers[0].author(), vote_0.signature().clone());

        // same author voting for the same thing -> DuplicateVote
        assert_eq!(
            pending_votes.insert_vote(&vote_0, &validator_verifier),
            VoteReceptionResult::DuplicateVote
        );

        assert_eq!(
            pending_votes.insert_vote(&vote_1, &validator_verifier),
            VoteReceptionResult::VoteAdded(2)
        );
        partial_sigs.add_signature(signers[1].author(), vote_1.signature().clone());

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 0);

        assert_eq!(
            pending_votes.insert_vote(&vote_2, &validator_verifier),
            VoteReceptionResult::VoteAdded(2)
        );

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);
        let (_, vote_status) = pending_votes.li_digest_to_votes.get(&li_hash).unwrap();
        match vote_status {
            VoteStatus::NotEnoughVotes(sig_aggregator) => {
                assert_eq!(sig_aggregator.verified_voters().count(), 2);
                assert_eq!(sig_aggregator.unverified_voters().count(), 0);
            },
            _ => {
                panic!("QC should not be formed yet.");
            },
        }

        partial_sigs.add_signature(signers[3].author(), vote_3.signature().clone());
        let aggregated_sig = validator_verifier
            .aggregate_signatures(partial_sigs.signatures_iter())
            .unwrap();
        match pending_votes.insert_vote(&vote_3, &validator_verifier) {
            VoteReceptionResult::NewQuorumCertificate(qc) => {
                assert!(qc
                    .ledger_info()
                    .check_voting_power(&validator_verifier)
                    .is_ok());
                assert_eq!(
                    qc.ledger_info().signatures().clone(),
                    aggregated_sig.clone()
                );
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        match pending_votes.insert_vote(&vote_4, &validator_verifier) {
            VoteReceptionResult::NewQuorumCertificate(qc) => {
                assert!(qc
                    .ledger_info()
                    .check_voting_power(&validator_verifier)
                    .is_ok());
                assert_eq!(
                    qc.ledger_info().signatures().clone(),
                    aggregated_sig.clone()
                );
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);
    }
```

**File:** types/src/ledger_info.rs (L484-486)
```rust
    pub fn all_voters(&self) -> impl Iterator<Item = &AccountAddress> {
        self.signatures.keys()
    }
```

**File:** types/src/ledger_info.rs (L488-495)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }
```

**File:** types/src/ledger_info.rs (L497-508)
```rust
    fn try_aggregate(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<AggregateSignature, VerifyError> {
        self.check_voting_power(verifier, true)?;

        let all_signatures = self
            .signatures
            .iter()
            .map(|(voter, sig)| (voter, sig.signature()));
        verifier.aggregate_signatures(all_signatures)
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
