# Audit Report

## Title
Late-Joining Validators Cannot Participate in Randomness Generation Due to Missing Re-Request Mechanism for Certified Augmented Data

## Summary
Validators that restart mid-epoch or join late cannot obtain certified augmented data from peers that have already completed their one-time broadcast. Without this data, they cannot verify randomness shares from other validators, resulting in liveness failures and inability to participate in consensus for the remainder of the epoch.

## Finding Description

The Aptos randomness generation protocol requires validators to exchange certified augmented data containing Delta values for augmented public keys at epoch start. This data is essential for verifying randomness shares throughout the entire epoch.

**The vulnerability stems from a missing recovery mechanism:**

When `AugDataStore::new()` is called during validator initialization, it loads data from persistent storage and aggressively filters out data from non-current epochs. [1](#0-0) 

The `filter_by_epoch` helper function only checks epoch equality, removing all non-matching epoch data and keeping only current epoch data. [2](#0-1) 

**Critical gap:** The `RandMessage` enum contains no mechanism to request historical certified augmented data. The enum only includes: `RequestShare`, `Share`, `AugData`, `AugDataSignature`, `CertifiedAugData`, `CertifiedAugDataAck`, and `FastShare`. [3](#0-2) 

Note that `RequestShare` exists for requesting randomness shares, but no corresponding `RequestCertifiedAugData` message exists.

**Attack scenario execution path:**

1. Epoch N+1 starts, all validators initialize `RandManager` and call `broadcast_aug_data()` once during startup. [4](#0-3) 

2. The broadcast uses `ReliableBroadcast::broadcast()` which sends to all validators in the epoch and completes when aggregation threshold is reached. [5](#0-4) 

3. Validator V4 crashes mid-epoch after other validators complete their broadcasts.

4. V4 restarts and initializes new `RandManager`, which creates a new `AugDataStore` that filters data by epoch. [6](#0-5) 

5. V4 broadcasts its own augmented data but never receives V1, V2, V3's certified data because their `ReliableBroadcast` tasks already completed and returned. [7](#0-6) 

6. When V4 receives randomness shares from V1, V2, V3, verification fails. Share verification requires certified augmented public keys (APKs) which are only populated when CertifiedAugData is received. [8](#0-7) 

7. Failed share verifications are logged but shares are dropped without retry. [9](#0-8) 

8. Without sufficient shares, V4 cannot aggregate randomness. Blocks requiring randomness remain stuck in the queue awaiting randomness generation. [10](#0-9) 

**Invariant broken:** The protocol assumes validators can always catch up on certified augmented data, but no mechanism exists for late joiners to request this critical data from peers who have already completed their broadcasts.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

**"Validator node slowdowns" (HIGH - up to $50,000):**
- Affected validators cannot process blocks waiting for randomness
- Block queue accumulates indefinitely, causing severe performance degradation
- Validator cannot participate in consensus for randomness-dependent operations until next epoch transition
- Reduces effective validator participation and network robustness mid-epoch

**"Partial Loss of Liveness":**
- Restarting validators become unable to participate in randomness generation for the remainder of the epoch
- Affects validator availability and network decentralization
- Multiple simultaneous validator restarts could significantly impact randomness generation capacity

The certified APK requirement for share verification is explicit and mandatory - without it, verification deterministically fails. [11](#0-10) 

The `augment()` function is only called when CertifiedAugData is received, which populates the certified APKs used for verification. [12](#0-11) 

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers in common operational scenarios:
- Validator node restarts (software updates, crashes, maintenance)
- Network partitions causing temporary disconnection during critical initialization period
- Any `RandManager` reinitialization during an epoch

The issue is **deterministic** - every late-joining/restarting validator experiences this problem. Recovery requires waiting for the next epoch transition when all validators re-broadcast augmented data.

The one-time broadcast pattern is inherent to the design, with `broadcast_aug_data()` called only once at initialization. [13](#0-12) 

## Recommendation

Implement a recovery mechanism for late-joining validators:

1. **Add `RequestCertifiedAugData` message variant** to `RandMessage` enum to allow validators to request missing certified augmented data from peers.

2. **Implement periodic check** in `RandManager` to detect missing certified APKs and request them from peers who have already broadcast.

3. **Add request handler** that responds with stored `CertifiedAugData` when requested by peers.

4. **Alternative approach**: Modify `ReliableBroadcast` to support a "subscribe" mechanism where new validators can request historical broadcasts from the current epoch.

Example fix structure:
```rust
// Add to RandMessage enum
pub enum RandMessage<S, D> {
    // ... existing variants ...
    RequestCertifiedAugData(RequestCertifiedAugData),
}

// New request type
pub struct RequestCertifiedAugData {
    epoch: u64,
    requested_author: Author,
}
```

## Proof of Concept

While a full PoC requires integration testing infrastructure, the vulnerability can be demonstrated through the following sequence:

1. Start epoch with 4 validators (V1, V2, V3, V4)
2. All validators successfully broadcast and receive CertifiedAugData
3. Simulate V4 crash by stopping its `RandManager`
4. Create new `RandManager` for V4 (simulating restart)
5. Observe that V4's `certified_apks` only contains its own APK
6. Send randomness shares from V1, V2, V3 to V4
7. Verify that all share verifications fail with "No augmented public key" error
8. Confirm blocks remain stuck in V4's queue awaiting randomness
9. Observe that V4 remains unable to process randomness-dependent blocks until epoch transition

The core issue is architectural: the protocol lacks a pull-based recovery mechanism for critical initialization data, relying solely on a one-time push broadcast at epoch start.

## Notes

This vulnerability highlights a fundamental assumption in the randomness protocol design: that all validators participating in an epoch will be continuously online from epoch start. This assumption is broken by common operational realities (restarts, updates, network issues). The fix requires adding an explicit recovery path for late-joining validators to catch up on missed certified augmented data broadcasts.

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L28-42)
```rust
    fn filter_by_epoch<T>(
        epoch: u64,
        all_data: impl Iterator<Item = (AugDataId, T)>,
    ) -> (Vec<T>, Vec<(AugDataId, T)>) {
        let mut to_remove = vec![];
        let mut to_keep = vec![];
        for (id, data) in all_data {
            if id.epoch() != epoch {
                to_remove.push(data)
            } else {
                to_keep.push((id, data))
            }
        }
        (to_remove, to_keep)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L44-59)
```rust
    pub fn new(
        epoch: u64,
        signer: Arc<ValidatorSigner>,
        config: RandConfig,
        fast_config: Option<RandConfig>,
        db: Arc<dyn RandStorage<D>>,
    ) -> Self {
        let all_data = db.get_all_aug_data().unwrap_or_default();
        let (to_remove, aug_data) = Self::filter_by_epoch(epoch, all_data.into_iter());
        if let Err(e) = db.remove_aug_data(to_remove) {
            error!("[AugDataStore] failed to remove aug data: {:?}", e);
        }

        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
        let (to_remove, certified_data) =
            Self::filter_by_epoch(epoch, all_certified_data.into_iter());
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L117-131)
```rust
    pub fn add_certified_aug_data(
        &mut self,
        certified_data: CertifiedAugData<D>,
    ) -> anyhow::Result<CertifiedAugDataAck> {
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
        self.db.save_certified_aug_data(&certified_data)?;
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
        self.certified_data
            .insert(*certified_data.author(), certified_data);
        Ok(CertifiedAugDataAck::new(self.epoch))
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L24-33)
```rust
#[derive(Clone, Serialize, Deserialize, EnumConversion)]
pub enum RandMessage<S, D> {
    RequestShare(RequestShare),
    Share(RandShare<S>),
    AugData(AugData<D>),
    AugDataSignature(AugDataSignature),
    CertifiedAugData(CertifiedAugData<D>),
    CertifiedAugDataAck(CertifiedAugDataAck),
    FastShare(FastShare<S>),
}
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L105-111)
```rust
        let aug_data_store = AugDataStore::new(
            epoch_state.epoch,
            signer,
            config.clone(),
            fast_config.clone(),
            db,
        );
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L196-206)
```rust
    fn process_randomness(&mut self, randomness: Randomness) {
        let rand = hex::encode(randomness.randomness());
        info!(
            metadata = randomness.metadata(),
            rand = rand,
            "Processing decisioned randomness."
        );
        if let Some(block) = self.block_queue.item_mut(randomness.round()) {
            block.set_randomness(randomness.round(), randomness);
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L305-346)
```rust
    async fn broadcast_aug_data(&mut self) -> DropGuard {
        let data = self
            .aug_data_store
            .get_my_aug_data()
            .unwrap_or_else(|| D::generate(&self.config, &self.fast_config));
        // Add it synchronously to avoid race that it sends to others but panics before it persists locally.
        self.aug_data_store
            .add_aug_data(data.clone())
            .expect("Add self aug data should succeed");
        let aug_ack = AugDataCertBuilder::new(data.clone(), self.epoch_state.clone());
        let rb = self.reliable_broadcast.clone();
        let rb2 = self.reliable_broadcast.clone();
        let validators = self.epoch_state.verifier.get_ordered_account_addresses();
        let maybe_existing_certified_data = self.aug_data_store.get_my_certified_aug_data();
        let phase1 = async move {
            if let Some(certified_data) = maybe_existing_certified_data {
                info!("[RandManager] Already have certified aug data");
                return certified_data;
            }
            info!("[RandManager] Start broadcasting aug data");
            info!(LogSchema::new(LogEvent::BroadcastAugData)
                .author(*data.author())
                .epoch(data.epoch()));
            let certified_data = rb.broadcast(data, aug_ack).await.expect("cannot fail");
            info!("[RandManager] Finish broadcasting aug data");
            certified_data
        };
        let ack_state = Arc::new(CertifiedAugDataAckState::new(validators.into_iter()));
        let task = phase1.then(|certified_data| async move {
            info!(LogSchema::new(LogEvent::BroadcastCertifiedAugData)
                .author(*certified_data.author())
                .epoch(certified_data.epoch()));
            info!("[RandManager] Start broadcasting certified aug data");
            rb2.broadcast(certified_data, ack_state)
                .await
                .expect("Broadcast cannot fail");
            info!("[RandManager] Finish broadcasting certified aug data");
        });
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        DropGuard::new(abort_handle)
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L348-376)
```rust
    pub async fn start(
        mut self,
        mut incoming_blocks: Receiver<OrderedBlocks>,
        incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        mut reset_rx: Receiver<ResetRequest>,
        bounded_executor: BoundedExecutor,
        highest_known_round: Round,
    ) {
        info!("RandManager started");
        let (verified_msg_tx, mut verified_msg_rx) = unbounded();
        let epoch_state = self.epoch_state.clone();
        let rand_config = self.config.clone();
        let fast_rand_config = self.fast_config.clone();
        self.rand_store
            .lock()
            .update_highest_known_round(highest_known_round);
        spawn_named!(
            "rand manager verification",
            Self::verification_task(
                epoch_state,
                incoming_rpc_request,
                verified_msg_tx,
                rand_config,
                fast_rand_config,
                bounded_executor,
            )
        );

        let _guard = self.broadcast_aug_data().await;
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L414-424)
```rust
                        RandMessage::Share(share) => {
                            trace!(LogSchema::new(LogEvent::ReceiveProactiveRandShare)
                                .author(self.author)
                                .epoch(share.epoch())
                                .round(share.metadata().round)
                                .remote_peer(*share.author()));

                            if let Err(e) = self.rand_store.lock().add_share(share, PathType::Slow) {
                                warn!("[RandManager] Failed to add share: {}", e);
                            }
                        }
```

**File:** crates/reliable-broadcast/src/lib.rs (L167-206)
```rust
            loop {
                tokio::select! {
                    Some((receiver, result)) = rpc_futures.next() => {
                        let aggregating = aggregating.clone();
                        let future = executor.spawn(async move {
                            (
                                    receiver,
                                    result
                                        .and_then(|msg| {
                                            msg.try_into().map_err(|e| anyhow::anyhow!("{:?}", e))
                                        })
                                        .and_then(|ack| aggregating.add(receiver, ack)),
                            )
                        }).await;
                        aggregate_futures.push(future);
                    },
                    Some(result) = aggregate_futures.next() => {
                        let (receiver, result) = result.expect("spawned task must succeed");
                        match result {
                            Ok(may_be_aggragated) => {
                                if let Some(aggregated) = may_be_aggragated {
                                    return Ok(aggregated);
                                }
                            },
                            Err(e) => {
                                log_rpc_failure(e, receiver);

                                let backoff_strategy = backoff_policies
                                    .get_mut(&receiver)
                                    .expect("should be present");
                                let duration = backoff_strategy.next().expect("should produce value");
                                rpc_futures
                                    .push(send_message(receiver, Some(duration)));
                            },
                        }
                    },
                    else => unreachable!("Should aggregate with all responses")
                }
            }
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```
