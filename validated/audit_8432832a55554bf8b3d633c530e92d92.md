# Audit Report

## Title
Unhandled Panic in Account Balance Handler Causes Rosetta Server Crash

## Summary
The Aptos Rosetta API service contains an unhandled panic vulnerability in the account balance endpoint. User-provided fungible asset addresses are parsed using `.unwrap()` without validation, allowing attackers to crash the server by sending malformed address strings in the `/account/balance` request.

## Finding Description

The vulnerability exists in the request handling flow for the `/account/balance` endpoint. The `handle_request()` wrapper function only catches `Result<Resp, ApiError>` errors and does not handle panics. [1](#0-0) 

The attack path executes as follows:

1. An attacker sends a POST request to `/account/balance` with a malformed `fa_address` in the `currencies` array
2. The request is deserialized into `AccountBalanceRequest`, which contains an optional `currencies` field [2](#0-1) 
3. Each currency can have `CurrencyMetadata` with an `fa_address` string field that is fully user-controlled [3](#0-2) 
4. The `account_balance` handler calls `get_balances()`, which passes user-provided currencies directly to `get_base_balances()` without validation [4](#0-3) 
5. In `get_base_balances()`, the malformed `fa_address` is parsed with `AccountAddress::from_str(fa_address).unwrap()` [5](#0-4) 
6. When the address string is invalid, `from_str()` returns an `Err`, and `.unwrap()` triggers a panic
7. The panic is not caught by `handle_request()` and propagates to the global panic handler
8. When running in Online mode (with local full node), the global panic handler is installed [6](#0-5)  and terminates the process [7](#0-6) 

The critical flaw is that user-provided currencies in the request are used directly without validating that they exist in `server_context.currencies`. [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria, specifically the "API Crashes (High)" category worth up to $50,000. The impact includes:

- **Complete service unavailability**: The entire Rosetta server process terminates when running in Online mode with a local full node
- **Denial of Service**: Any node operator can be taken offline with a single malicious request
- **No authentication required**: The `/account/balance` endpoint is publicly accessible
- **Instant impact**: The crash occurs immediately upon processing the request

The vulnerability breaks the availability guarantee that API services should remain operational even when receiving malformed input.

## Likelihood Explanation

This vulnerability has **High likelihood** of exploitation:

- **Trivial complexity**: Requires only a single HTTP POST request with malformed JSON
- **No authentication**: Publicly accessible endpoint
- **No special permissions**: Any network client can exploit this
- **Deterministic result**: Crash occurs 100% of the time with malformed input
- **Zero cost**: Single HTTP request with no resource requirements

An attacker simply needs to send:
```json
{
  "network_identifier": { "blockchain": "aptos", "network": "mainnet" },
  "account_identifier": { "address": "0x1" },
  "currencies": [{
    "symbol": "FAKE",
    "decimals": 6,
    "metadata": { "fa_address": "not_a_valid_address" }
  }]
}
```

## Recommendation

Replace `.unwrap()` with proper error handling:

```rust
vec![
    bcs::to_bytes(&owner_address)?,
    bcs::to_bytes(&AccountAddress::from_str(fa_address)
        .map_err(|_| ApiError::InvalidInput(Some(format!("Invalid fa_address: {}", fa_address))))?
    )?,
]
```

Additionally, validate user-provided currencies against `server_context.currencies` before processing, or only accept currency filtering rather than allowing arbitrary currency specifications.

## Proof of Concept

```bash
curl -X POST http://localhost:8082/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": { "blockchain": "aptos", "network": "testnet" },
    "account_identifier": { "address": "0x1" },
    "currencies": [{
      "symbol": "MALICIOUS",
      "decimals": 6,
      "metadata": { "fa_address": "invalid_hex_string" }
    }]
  }'
```

When the Rosetta server is running in Online mode with a local full node, this request will cause an immediate panic in `AccountAddress::from_str()`, which will be caught by the global panic handler and terminate the entire process with exit code 12.

## Notes

The vulnerability's impact varies by deployment mode:
- **Online mode** (local full node): Process termination via global panic handler - CRITICAL impact
- **OnlineRemote/Offline modes**: Request failure but server continues - reduced impact

The root cause is using `.unwrap()` on user-controlled input without validation. Even in deployment modes without the global panic handler, this is still a bug that causes request failures and should be fixed with proper error handling.

### Citations

**File:** crates/aptos-rosetta/src/common.rs (L62-98)
```rust
pub fn handle_request<'a, F, R, Req, Resp>(
    handler: F,
) -> impl Fn(
    Req,
    RosettaContext,
) -> BoxFuture<'static, Result<warp::reply::WithStatus<warp::reply::Json>, Infallible>>
       + Clone
       + use<F, R, Req, Resp>
where
    F: FnOnce(Req, RosettaContext) -> R + Clone + Copy + Send + 'static,
    R: Future<Output = Result<Resp, ApiError>> + Send,
    Req: Deserialize<'a> + Send + 'static,
    Resp: std::fmt::Debug + Serialize,
{
    move |request, options| {
        let fut = async move {
            match handler(request, options).await {
                Ok(response) => {
                    debug!("Response: {:?}", serde_json::to_string_pretty(&response));
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        warp::http::StatusCode::OK,
                    ))
                },
                Err(api_error) => {
                    debug!("Error: {:?}", api_error);
                    let status = api_error.status_code();
                    Ok(warp::reply::with_status(
                        warp::reply::json(&api_error.into_error()),
                        status,
                    ))
                },
            }
        };
        Box::pin(fut)
    }
}
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L26-38)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountBalanceRequest {
    /// Network identifier describing the blockchain and the chain id
    pub network_identifier: NetworkIdentifier,
    /// Account identifier describing the account address
    pub account_identifier: AccountIdentifier,
    /// For historical balance lookups by either hash or version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_identifier: Option<PartialBlockIdentifier>,
    /// For filtering which currencies to show
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencies: Option<Vec<Currency>>,
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** crates/aptos-rosetta/src/account.rs (L78-84)
```rust
    let (sequence_number, operators, balances, lockup_expiration) = get_balances(
        &server_context,
        request.account_identifier,
        balance_version,
        request.currencies,
    )
    .await?;
```

**File:** crates/aptos-rosetta/src/account.rs (L119-123)
```rust
    let currencies_to_lookup = if let Some(currencies) = maybe_filter_currencies {
        currencies.into_iter().collect()
    } else {
        server_context.currencies.clone()
    };
```

**File:** crates/aptos-rosetta/src/account.rs (L333-336)
```rust
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
