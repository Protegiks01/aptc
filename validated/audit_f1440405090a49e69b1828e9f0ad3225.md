# Audit Report

## Title
Consensus Split During OnChainConsensusConfig V4→V5 Migration Due to Inconsistent Deserialization Fallbacks

## Summary
During migration from `OnChainConsensusConfig::V4` to `V5`, validators running different software versions produce inconsistent `validator_txn_enabled()` results, causing consensus divergence in both the reconfiguration state machine and block validation logic. This breaks fundamental consensus safety invariants and can cause network partition.

## Finding Description

The vulnerability exists in two critical code paths that use `unwrap_or_default()` when BCS deserialization fails:

**Path 1: Native function in Move VM** [1](#0-0) 

**Path 2: Consensus engine epoch initialization** [2](#0-1) 

The default configuration returns V4 with validator transactions **disabled**: [3](#0-2) 

Where `ValidatorTxnConfig::default_if_missing()` returns `V0` (disabled): [4](#0-3) 

**Attack Scenario:**

1. Network initially runs with V4 config where `vtxn = V1 {...}` (enabled)
2. Governance proposes upgrade to V5 with `vtxn = V1 {...}` (enabled) and `rand_check_enabled = true`
3. During rolling upgrade, only 60% of validators have upgraded their node software to support V5 deserialization
4. Governance proposal executes, updating on-chain config to V5 bytes
5. Epoch change triggers, all validators execute `aptos_governance::reconfigure()`

**Divergence Point 1 - Reconfiguration State Machine:** [5](#0-4) 

- **Validators with NEW software (40%)**: Successfully deserialize V5 → `validator_txn_enabled()` returns **true** → Execute `reconfiguration_with_dkg::try_start()` → Enter DKG waiting state
- **Validators with OLD software (60%)**: Fail to deserialize V5 → Fall back to default V4 → `validator_txn_enabled()` returns **false** → Execute `reconfiguration_with_dkg::finish()` → Immediately enter new epoch

This creates a fundamental state machine split where validators are in different reconfiguration states: [6](#0-5) [7](#0-6) 

**Divergence Point 2 - Block Validation:**

In RoundManager, the `vtxn_config` field is initialized from the consensus config: [8](#0-7) 

This config determines whether ProposalExt blocks (containing validator transactions) are accepted: [9](#0-8) 

- **Validators with NEW software**: `vtxn_config.enabled() = true` → Accept ProposalExt blocks
- **Validators with OLD software**: `vtxn_config.enabled() = false` → **Reject** ProposalExt blocks with error "ProposalExt unexpected while the vtxn feature is disabled"

This means validators cannot reach consensus on blocks containing validator transactions, violating the deterministic execution invariant.

## Impact Explanation

**Severity: CRITICAL** (Consensus Safety Violation + Network Partition)

This vulnerability breaks multiple critical invariants:

1. **Deterministic Execution Invariant Violation**: Different validators produce different execution results for the same on-chain config bytes when executing the native function [10](#0-9) 

2. **Consensus Safety Violation**: Network splits into two partitions that cannot agree on blocks or epoch state
3. **Total Liveness Failure**: Cannot progress if >1/3 validators are in the wrong state

The impact qualifies as **CRITICAL** under Aptos bug bounty criteria:
- **Consensus/Safety violations**: Validators disagree on fundamental protocol state
- **Non-recoverable network partition**: Requires emergency intervention or hardfork to resolve
- **Total loss of liveness**: Network cannot make progress when validators split between DKG-waiting and new-epoch states

The affected validator percentage determines severity:
- **Scenario A** (≥34% old validators): Cannot achieve 2f+1 quorum for DKG or blocks → Complete liveness failure
- **Scenario B** (20-33% old validators): Can achieve quorum but with degraded safety margins, risk of subsequent failures
- **Scenario C** (<20% old validators): Old validators permanently out of sync, must be forced offline

## Likelihood Explanation

**Likelihood: HIGH during any V4→V5 migration**

This vulnerability **will** occur with certainty during any governance-initiated V4 to V5 upgrade unless:
1. ALL validators upgrade their software simultaneously (impossible in practice)
2. The on-chain config remains at V4 until 100% validator software is upgraded (defeats purpose of versioning)

Real-world constraints make this highly likely:
- Validator software upgrades are deliberately staggered for safety
- Governance proposals have fixed voting periods (typically days)
- No mechanism exists to prevent config version advancement during partial upgrades
- The OnChainConsensusConfig enum definition uses BCS deserialization which fails when encountering unknown variants [11](#0-10) 

## Recommendation

Implement one of the following fixes:

1. **Add version negotiation**: Check minimum software version before allowing V5 config activation
2. **Forward-compatible deserialization**: Modify the native function to handle unknown config versions gracefully by reading the on-chain config version first and falling back to the last supported version's behavior rather than default
3. **Two-phase upgrade**: First upgrade all validator software to support V5 deserialization, then activate V5 config in a separate governance action
4. **Remove fallback**: Change `unwrap_or_default()` to `expect()` to fail fast rather than silently diverging

## Proof of Concept

The vulnerability can be demonstrated by:
1. Starting a testnet with validators running V4-aware software
2. Deploying V5 config bytes to on-chain ConsensusConfig
3. Triggering reconfiguration
4. Observing that validators with old software deserialize to default V4 (vtxn disabled) while new software deserializes to V5 (vtxn enabled)
5. Confirming that validators cannot reach consensus on subsequent blocks

The core issue is in the enum-based BCS deserialization where old code cannot deserialize new enum variants, combined with the silent fallback to default values that have different semantics.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L19-19)
```rust
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L191-213)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** consensus/src/round_manager.rs (L363-363)
```rust
        let vtxn_config = onchain_config.effective_validator_txn_config();
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-76)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }

    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;
```
