# Audit Report

## Title
Type Instantiation CPU Exhaustion via Unmetered Struct Field Expansion in Bytecode Verification

## Summary
The bytecode verifier performs type instantiation for all struct fields without proper metering in `type_fields_signature()`, allowing attackers to cause O(num_fields × type_complexity) CPU usage during module verification while only being charged for O(type_complexity) in complexity checks. This enables validator node slowdowns through maliciously crafted Move modules.

## Finding Description

The vulnerability exists in the bytecode verification pipeline, specifically in how generic struct instantiations are metered during the type safety verification pass.

Module verification is executed synchronously during transaction processing. When a validator processes a module publishing transaction, it calls `verify_module_with_config` [1](#0-0) , which invokes `CodeUnitVerifier::verify_module` [2](#0-1) , which then calls `type_safety::verify` for each function [3](#0-2) .

During static complexity checking, `meter_struct_instantiation()` only meters the type parameters signature [4](#0-3) .

However, during bytecode verification, when the verifier encounters a `PackGeneric` instruction, it charges for the type arguments via `charge_tys` [5](#0-4)  and then calls `pack()` which invokes `type_fields_signature()` [6](#0-5) .

The critical issue is where the meter parameter is explicitly unused with a TODO comment indicating missing metering implementation [7](#0-6) .

This function calls `instantiate()` recursively for each field [8](#0-7)  and [9](#0-8) .

The `instantiate()` function recursively traverses the entire type tree [10](#0-9) . This performs O(type_depth) work per field, but this work is completely unmetered.

**Attack Path:**
1. Attacker creates a struct with the maximum allowed fields (255 per binary format limit [11](#0-10) ) with a generic type parameter
2. Production configuration allows unlimited fields [12](#0-11) 
3. Attacker instantiates the struct with a deeply nested type (up to 20 levels in production [13](#0-12) )
4. During verification, the verifier charges only for the type parameters via `charge_tys` [14](#0-13) 
5. But then performs 255 × 20 = 5,100 type node traversals without additional metering
6. This bypasses the `max_per_fun_meter_units` limit [15](#0-14)  intended to prevent excessive verification cost

## Impact Explanation

This vulnerability enables **High Severity** validator node slowdowns as defined in the Aptos bug bounty program category "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

An attacker can:
- Cause significant CPU exhaustion on all validators during module verification
- Delay block production and consensus progress by making verification slow
- Force validators to process malicious modules repeatedly if published in successive transactions
- Impact all validators simultaneously since all must verify published modules synchronously

The attack does not require validator privileges and can be executed by any account capable of publishing modules. The verification happens synchronously during transaction execution [16](#0-15) , directly impacting consensus performance.

## Likelihood Explanation

**High likelihood** - The attack is:
- **Easy to execute**: Simply publish a Move module with a struct containing 255 fields of generic type `T`, then instantiate it with a deeply nested type
- **Low cost**: Only requires gas for module publication
- **Guaranteed impact**: Every validator must verify the module during transaction execution
- **Repeatable**: Attacker can publish multiple such modules in successive transactions
- **Currently unmitigated**: The TODO comment explicitly confirms metering is not implemented [7](#0-6) 

The binary format explicitly allows up to 255 fields, and production configuration sets no limit on struct field count, making this attack fully viable in production.

## Recommendation

Implement proper metering in `type_fields_signature()` by removing the unused meter parameter and adding metering for each field instantiation. The meter should charge based on the complexity of instantiating each field's type signature, similar to how `charge_tys` meters type arguments.

Specifically:
1. In `type_fields_signature()`, call `verifier.charge_ty(meter, &instantiated_field_type)` for each field after instantiation
2. This ensures the cost scales with O(num_fields × type_complexity) as it should
3. Consider adding a `max_fields_in_struct` limit in production configuration as an additional safeguard

## Proof of Concept

```move
module attacker::exploit {
    // Create a struct with maximum fields (255) with generic type
    struct LargeStruct<T> has drop {
        f1: T, f2: T, f3: T, f4: T, f5: T,
        // ... repeat for 255 fields total ...
        f255: T
    }
    
    // Instantiate with deeply nested type (20 levels)
    public fun trigger() {
        let _ = LargeStruct<
            vector<vector<vector<vector<vector<
            vector<vector<vector<vector<vector<
            vector<vector<vector<vector<vector<
            vector<vector<vector<vector<vector<u64>>>>>
            >>>>>>>>>>>>>>>>> {
            f1: vector[], f2: vector[], // ... initialize all 255 fields
        };
    }
}
```

When this module is published, all validators must verify it synchronously, causing them to perform 255 × 20 = 5,100 unmetered type node traversals per `PackGeneric` instruction, bypassing the intended verification cost limits and causing significant CPU exhaustion.

## Notes

This vulnerability specifically affects the type safety verification pass during bytecode verification, not runtime execution. The synchronous nature of module verification during transaction processing makes this a consensus-level performance issue rather than a simple denial of service. The TODO comment in the code confirms this is a known limitation that has not been addressed.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L185-185)
```rust
        type_safety::verify(&self.resolver, &self.function_view, meter)?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L126-137)
```rust
    fn meter_struct_instantiation(
        &self,
        struct_inst_idx: StructDefInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_insts = self.resolver.struct_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct instantiations -- not a module.".to_string())
        })?;
        let struct_inst = safe_get_table(struct_insts, struct_inst_idx.0)?;

        self.meter_signature(struct_inst.type_parameters)
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L101-110)
```rust
    fn charge_tys(
        &mut self,
        meter: &mut impl Meter,
        tys: &[SignatureToken],
    ) -> PartialVMResult<()> {
        for ty in tys {
            self.charge_ty(meter, ty)?
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L404-404)
```rust
    _meter: &mut impl Meter, // TODO: metering
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L414-414)
```rust
                .map(|field_def| instantiate(&field_def.signature.0, type_args))
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L424-424)
```rust
                    .map(|field_def| instantiate(&field_def.signature.0, type_args))
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L444-444)
```rust
    let field_sig = type_fields_signature(verifier, meter, offset, struct_def, variant, type_args)?;
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L894-894)
```rust
            verifier.charge_tys(meter, &type_args.0)?;
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1348-1389)
```rust
fn instantiate(token: &SignatureToken, subst: &Signature) -> SignatureToken {
    use SignatureToken::*;

    if subst.0.is_empty() {
        return token.clone();
    }

    let inst_vec = |v: &[SignatureToken]| -> Vec<SignatureToken> {
        v.iter().map(|ty| instantiate(ty, subst)).collect()
    };
    match token {
        Bool => Bool,
        U8 => U8,
        U16 => U16,
        U32 => U32,
        U64 => U64,
        U128 => U128,
        U256 => U256,
        I8 => I8,
        I16 => I16,
        I32 => I32,
        I64 => I64,
        I128 => I128,
        I256 => I256,
        Address => Address,
        Signer => Signer,
        Vector(ty) => Vector(Box::new(instantiate(ty, subst))),
        Function(args, result, abilities) => Function(inst_vec(args), inst_vec(result), *abilities),
        Struct(idx) => Struct(*idx),
        StructInstantiation(idx, struct_type_args) => {
            StructInstantiation(*idx, inst_vec(struct_type_args))
        },
        Reference(ty) => Reference(Box::new(instantiate(ty, subst))),
        MutableReference(ty) => MutableReference(Box::new(instantiate(ty, subst))),
        TypeParameter(idx) => {
            // Assume that the caller has previously parsed and verified the structure of the
            // file and that this guarantees that type parameter indices are always in bounds.
            debug_assert!((*idx as usize) < subst.len());
            subst.0[*idx as usize].clone()
        },
    }
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L78-78)
```rust
pub const FIELD_COUNT_MAX: u64 = 255;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L170-170)
```rust
        max_fields_in_struct: None,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-175)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-190)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
```
