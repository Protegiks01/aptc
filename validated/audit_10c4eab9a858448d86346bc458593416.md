# Audit Report

## Title
Missing Epoch Validation in Timeout Certificate Verification Allows Epoch Boundary Violations

## Summary
The `verify_tc()` function in SafetyRules performs only cryptographic signature verification without validating that the Timeout Certificate (TC) belongs to the current epoch. This missing defense-in-depth check allows TCs from incorrect epochs to be processed when validator sets remain similar across epoch boundaries, violating critical consensus invariants.

## Finding Description

The `verify_tc()` function only performs signature verification without epoch validation: [1](#0-0) 

In contrast, the codebase consistently validates epochs for other consensus messages through `verify_epoch()`: [2](#0-1) 

**Timeout epoch validation** occurs before TC verification: [3](#0-2) 

**Proposal epoch validation** occurs during proposal verification: [4](#0-3) 

However, when TCs are verified in both voting and timeout signing flows, no epoch check occurs: [5](#0-4) [6](#0-5) 

The TC structure contains an epoch field accessible via `tc.epoch()`: [7](#0-6) 

While `SyncInfo::verify()` checks that TC and HQC epochs match each other: [8](#0-7) 

This check is insufficient because it only ensures TC and HQC epochs match **each other**, not the **current** epoch in `safety_data.epoch`. If both are from epoch N-1 but the node is in epoch N, the check passes.

**Attack Flow:**

1. Network transitions from epoch N-1 to epoch N with similar validator sets
2. Attacker sends SyncInfo with HQC and TC both from epoch N-1
3. `SyncInfo::verify()` passes (both components match each other)
4. TC from epoch N-1 is inserted into block_store: [9](#0-8) 

5. When voting, TC is retrieved from block_store and passed to SafetyRules: [10](#0-9) 

6. If validator sets are identical between epochs, signature verification succeeds using the current epoch's verifier on signatures from the previous epoch
7. Validator signs consensus message with TC from wrong epoch

During epoch transitions, `epoch_state` is updated: [11](#0-10) 

If validator sets are identical or very similar between epochs, the ValidatorVerifier remains effectively the same, allowing cross-epoch signature verification to succeed.

## Impact Explanation

**Severity: Critical**

This vulnerability enables **Consensus Safety Violations** per the Aptos bug bounty Critical category:

1. **Epoch Boundary Violation**: Epochs are fundamental consensus boundaries with distinct validator sets and safety state. Accepting TCs from incorrect epochs violates the invariant that all consensus messages within an epoch must originate from that epoch.

2. **Safety Rule Bypass**: When transitioning to a new epoch, SafetyRules resets critical state (last_voted_round, preferred_round, one_chain_round). A TC from the previous epoch references rounds and QCs from that epoch's context, which should be invalidated. Using it in the new epoch bypasses these safety guarantees.

3. **Inconsistent Consensus State**: Different validators may process epoch transitions at different times. If some accept cross-epoch TCs while others reject them, this creates potential for voting inconsistencies that could violate consensus safety under adversarial conditions.

4. **Defense-in-Depth Failure**: SafetyRules is the final security-critical component that must enforce ALL consensus invariants before signing. It should never rely solely on upstream validation that could be bypassed, contain bugs, or change in future protocol versions.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable when:

1. **Validator sets remain similar between epochs** - Common in test networks, during initial deployment, or in networks with stable validator participation where validator set composition doesn't change significantly
2. **Epoch transition periods** - Attack window exists during network epoch transitions
3. **No privileged access required** - Any network participant can send SyncInfo messages

The attack requires:
- Ability to send sync messages (available to any network peer)
- Network in or near epoch transition
- Similar validator sets between consecutive epochs
- No validator compromise needed

## Recommendation

Add explicit epoch validation in `verify_tc()` to match the pattern used for other consensus messages:

```rust
fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
    let epoch_state = self.epoch_state()?;
    let safety_data = self.persistent_storage.safety_data()?;
    
    // Add epoch validation
    if tc.epoch() != safety_data.epoch {
        return Err(Error::IncorrectEpoch(tc.epoch(), safety_data.epoch));
    }
    
    if !self.skip_sig_verify {
        tc.verify(&epoch_state.verifier)
            .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
    }
    Ok(())
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with identical validator sets across two epochs
2. During epoch N, sending a SyncInfo containing TC from epoch N-1
3. Observing that `verify_tc()` accepts the cross-epoch TC
4. The validator signs a consensus message using the wrong-epoch TC

The core issue is verified by the code analysis showing that `verify_tc()` never calls `verify_epoch()` or compares `tc.epoch()` against `safety_data.epoch`, unlike all other consensus message verification paths.

## Notes

This represents a critical defense-in-depth failure. While `SyncInfo::verify()` provides partial protection by checking TC and HQC epoch consistency, and signature verification may fail when validator sets differ significantly, SafetyRules must independently validate all invariants. The epoch boundary is a fundamental consensus invariant, and its enforcement should not depend on upstream validation that may have bugs, be bypassed, or change in future protocol versions.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L26-26)
```rust
        self.verify_epoch(timeout.epoch(), &safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L33-33)
```rust
            self.verify_tc(tc)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L63-63)
```rust
            self.verify_tc(tc)?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L70-70)
```rust
        self.verify_epoch(proposed_block.epoch(), &safety_data)?;
```

**File:** consensus/safety-rules/src/safety_rules.rs (L204-210)
```rust
    pub(crate) fn verify_epoch(&self, epoch: u64, safety_data: &SafetyData) -> Result<(), Error> {
        if epoch != safety_data.epoch {
            return Err(Error::IncorrectEpoch(epoch, safety_data.epoch));
        }

        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L310-310)
```rust
        self.epoch_state = Some(epoch_state.clone());
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L186-188)
```rust
    pub fn epoch(&self) -> u64 {
        self.timeout.epoch()
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L148-150)
```rust
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1520-1523)
```rust
        let vote_result = self.safety_rules.lock().construct_and_sign_vote_two_chain(
            &vote_proposal,
            self.block_store.highest_2chain_timeout_cert().as_deref(),
        );
```
