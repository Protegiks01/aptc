# Audit Report

## Title
Silent Dropping of Critical JWK Consensus RPC Requests Due to Channel Saturation Without Observability

## Summary
The JWK consensus network task silently drops incoming RPC requests when its internal channel becomes saturated, with zero observability (no metrics, no feedback, no alerts). This can prevent validators from participating in JWK consensus, potentially blocking quorum and preventing on-chain JWK updates required for keyless account authentication.

## Finding Description

The vulnerability exists in the JWK consensus network message handling pipeline. When validators exchange JWK observation requests to reach consensus on JSON Web Keys from OIDC providers, incoming RPC requests are pushed to an internal channel with a capacity of only 10 messages per peer. [1](#0-0) 

When this channel becomes saturated, the `aptos_channel` implementation silently drops new messages. The `PerKeyQueue` underlying the channel drops messages when full. [2](#0-1)  For FIFO queue style (used by JWK consensus), it drops the newest message being pushed. [3](#0-2) 

The error handling appears to log failures, but the `aptos_channel::push()` method only returns an error when the receiver is dropped (channel closed), not when messages are dropped due to saturation. [4](#0-3)  The warning log at the call site only fires on channel closure. [5](#0-4) 

The critical issues are:

1. **No metrics registered**: The channel is created with `None` for the counters parameter, so dropped messages aren't tracked
2. **No status feedback**: No status channel is used when calling `push()`, so `ElementStatus::Dropped` notifications are never sent  
3. **Misleading error handling**: The warning log only fires on channel closure, never on saturation
4. **Silent message loss**: RPC requests from peer validators are dropped with zero indication

When an RPC request is dropped, the requesting validator never receives a response. The `ReliableBroadcast` mechanism retries with exponential backoff [6](#0-5) , but if the channel remains saturated, retries also fail. If enough validators experience this simultaneously, the quorum cannot be reached.

The `ObservationAggregationState` requires quorum voting power to produce a `QuorumCertifiedUpdate`. [7](#0-6)  Missing responses prevent reaching this threshold.

## Impact Explanation

**Severity: MEDIUM to HIGH** - This represents a liveness issue for keyless account functionality.

**Concrete Impact:**

1. **JWK Consensus Liveness Failure**: If validators cannot respond to observation requests due to channel saturation, the consensus process for certifying JWK updates stalls
2. **Keyless Account Disruption**: JWK updates enable keyless accounts to authenticate using OIDC providers. Stale or missing JWKs cause transaction failures with `INVALID_SIGNATURE` errors [8](#0-7) 
3. **User Fund Access**: Users relying on keyless accounts cannot transact, effectively losing access to their funds until JWKs are updated

This doesn't violate consensus safety (no double-spend or chain split), but it's a liveness issue affecting keyless account users. The lack of observability means operators cannot detect or diagnose the problem proactively.

## Likelihood Explanation

**Likelihood: MEDIUM** depending on network conditions.

**Triggering Scenarios:**

1. **Epoch Transitions**: During epoch changes, all validators may simultaneously send observation requests, creating traffic spikes that can saturate per-peer queues
2. **Slow Message Processing**: If the EpochManager processes messages slowly (blocked on other operations), incoming RPC requests can accumulate and exceed the 10-message per-peer capacity
3. **High Load Scenarios**: With multiple OIDC providers and frequent key rotations, sustained high RPC traffic can trigger saturation

**Comparison to Other Systems:**

The main AptosBFT consensus uses the same channel pattern (capacity 10, warn on error), but with metrics enabled for observability. [9](#0-8) [10](#0-9) 

JWK consensus lacks this safeguard - no metrics are registered for dropped messages.

## Recommendation

1. **Add metrics to JWK consensus RPC channel**:
```rust
// In crates/aptos-jwk-consensus/src/network.rs, line 169
// Change from:
let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
// To:
let (rpc_tx, rpc_rx) = aptos_channel::new(
    QueueStyle::FIFO, 
    10, 
    Some(&counters::JWK_CONSENSUS_RPC_CHANNEL_MSGS)
);
```

2. **Define the metrics counter** in a JWK consensus counters module:
```rust
pub static JWK_CONSENSUS_RPC_CHANNEL_MSGS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_jwk_consensus_rpc_channel_msgs_count",
        "Counters(queued,dequeued,dropped) related to JWK consensus RPC channel",
        &["state"]
    )
    .unwrap()
});
```

3. **Consider increasing channel capacity**: Evaluate whether capacity 10 per peer is sufficient for JWK consensus traffic patterns, especially during epoch transitions.

4. **Add monitoring alerts**: Configure alerts on the "dropped" metric to notify operators when messages are being dropped.

## Proof of Concept

A full proof of concept would require setting up a test network with multiple validators and simulating high RPC load during epoch transitions. However, the code path can be traced through the existing codebase:

1. Validator receives RPC request: Network event arrives at `NetworkTask::start()` 
2. Push to channel: `self.rpc_tx.push(peer_id, (peer_id, req))` attempts to queue the message
3. If 10 messages from that peer are already queued and unprocessed, `PerKeyQueue::push()` returns `Some(message)` indicating the message was dropped
4. No error is logged (only happens on channel close), no metric is incremented (counters = None)
5. Requesting validator times out waiting for response, triggering retry with exponential backoff

The vulnerability is confirmed by code inspection showing the missing metrics parameter and the FIFO dropping behavior.

### Citations

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-169)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L201-203)
```rust
                    if let Err(e) = self.rpc_tx.push(peer_id, (peer_id, req)) {
                        warn!(error = ?e, "aptos channel closed");
                    };
```

**File:** crates/channel/src/message_queues.rs (L134-147)
```rust
        if key_message_queue.len() >= self.max_queue_size.get() {
            if let Some(c) = self.counters.as_ref() {
                c.with_label_values(&["dropped"]).inc();
            }
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```

**File:** crates/channel/src/aptos_channel.rs (L98-98)
```rust
        ensure!(!shared_state.receiver_dropped, "Channel is closed");
```

**File:** crates/reliable-broadcast/src/lib.rs (L191-200)
```rust
                            Err(e) => {
                                log_rpc_failure(e, receiver);

                                let backoff_strategy = backoff_policies
                                    .get_mut(&receiver)
                                    .expect("should be present");
                                let duration = backoff_strategy.next().expect("should produce value");
                                rpc_futures
                                    .push(send_message(receiver, Some(duration)));
                            },
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L94-117)
```rust
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(voters.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };

        info!(
            epoch = self.epoch_state.epoch,
            peer = sender,
            issuer = String::from_utf8(self.local_view.issuer.clone()).ok(),
            peer_power = peer_power,
            new_total_power = new_total_power,
            threshold = self.epoch_state.verifier.quorum_voting_power(),
            threshold_exceeded = power_check_result.is_ok(),
            "Peer vote aggregated."
        );

        if power_check_result.is_err() {
            return Ok(None);
        }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-150)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;

    let jwk = JWK::try_from(jwk_move_struct)
        .map_err(|_| invalid_signature!("Could not unpack Any in JWK Move struct"))?;

    match &jwk {
        JWK::RSA(rsa_jwk) => {
            if rsa_jwk.alg != jwt_header.alg {
                return Err(invalid_signature!(format!(
                    "JWK alg ({}) does not match JWT header's alg ({})",
                    rsa_jwk.alg, jwt_header.alg
                )));
            }
        },
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
    }

    Ok(jwk)
}
```

**File:** consensus/src/network.rs (L769-769)
```rust
            aptos_channel::new(QueueStyle::FIFO, 10, Some(&counters::RPC_CHANNEL_MSGS));
```

**File:** consensus/src/counters.rs (L1128-1135)
```rust
pub static RPC_CHANNEL_MSGS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_consensus_rpc_channel_msgs_count",
        "Counters(queued,dequeued,dropped) related to rpc request channel",
        &["state"]
    )
    .unwrap()
});
```
