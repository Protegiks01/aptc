# Audit Report

## Title
Secret Share Verification Task RPC Flooding Denial of Service

## Summary
Byzantine validators can exploit a design flaw in the secret sharing verification task to cause denial of service. The `verification_task()` uses blocking spawns that prevent message processing when the bounded executor is saturated, allowing Byzantine validators to flood the system and cause legitimate secret shares to be dropped, stalling consensus.

## Finding Description

The secret sharing subsystem in Aptos consensus contains a critical design flaw in the `verification_task()` function that processes incoming RPC requests from validators.

**Vulnerable Architecture:**

The incoming RPC channel is configured with `QueueStyle::KLAST` and a per-validator capacity of 10 messages (default `internal_per_key_channel_size`). [1](#0-0) 

The `QueueStyle::KLAST` policy drops the oldest messages when the queue reaches capacity. [2](#0-1) 

Messages are pushed to the channel without any cryptographic verification or validation - they are merely wrapped and forwarded. [3](#0-2) 

**The Critical Flaw:**

The `verification_task()` function has a blocking loop that calls `bounded_executor.spawn().await` for each message. [4](#0-3) 

The `BoundedExecutor::spawn()` method is explicitly documented to block when the executor reaches capacity: "This function is async and will block if the executor is at capacity until one of the other spawned futures completes." [5](#0-4) 

The bounded executor has a default capacity of 16 concurrent tasks. [6](#0-5) 

The channel capacity per validator defaults to 10 messages. [7](#0-6) 

**Attack Execution:**

1. Byzantine validators send numerous secret share RPC requests (either valid `Share` messages requiring expensive cryptographic verification or malformed messages)
2. Each Byzantine validator can queue up to 10 messages in their per-validator channel
3. The verification task dequeues messages and spawns verification jobs on the bounded executor
4. Once 16 verification tasks are running, `spawn().await` **blocks the entire verification loop**
5. While blocked, the verification task cannot dequeue ANY new messages from ANY validator
6. When honest validators send messages and queues fill up, the KLAST policy drops old messages
7. Legitimate secret shares are lost, preventing secret sharing aggregation required for consensus

The cryptographic verification involves computationally expensive pairing operations. [8](#0-7) 

Even 2-3 Byzantine validators can sustain this attack by continuously sending requests, keeping the bounded executor saturated and preventing legitimate message processing.

## Impact Explanation

This vulnerability represents **High Severity** under the Aptos bug bounty criteria:

**Validator Node Slowdowns (High):** The attack directly causes validator nodes to experience significant slowdowns in secret sharing, which is a critical consensus component. The blocking verification task prevents timely processing of legitimate secret shares, degrading consensus performance.

**Consensus Liveness Impact:** Secret sharing is integral to the consensus protocol. The inability to aggregate secret shares means blocks cannot complete their secret sharing phase, violating the protocol's liveness guarantees. While not a complete network halt, this significantly degrades consensus and can cause temporary stalls.

**Low Attack Threshold:** Byzantine validators only need to send RPC requests continuously. With default configuration (10 messages per validator, 16 executor capacity), just 2-3 Byzantine validators can effectively mount this attack without requiring the 1/3 Byzantine threshold.

## Likelihood Explanation

**Likelihood: High**

1. **Low Barrier:** Any validator in the consensus set can become Byzantine. The Aptos consensus protocol explicitly assumes up to <1/3 Byzantine validators in its threat model.

2. **Easy Execution:** The attack requires only sending RPC requests, which is normal validator behavior. No sophisticated exploitation or precise timing is needed.

3. **No Rate Limiting:** There is no per-validator rate limiting before messages enter the verification queue. The only limit is the per-key queue size of 10 messages.

4. **Small Attack Scale:** With just 2-3 Byzantine validators sending continuous requests, the attack can saturate the bounded executor and cause message dropping.

5. **Detection Difficulty:** The attack traffic resembles legitimate secret sharing traffic, making it difficult to distinguish from honest behavior.

## Recommendation

Replace the blocking `spawn().await` with non-blocking `try_spawn()` in the verification task:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        
        // Use try_spawn instead of spawn to avoid blocking
        match bounded_executor.try_spawn(async move {
            match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                Ok(msg) => {
                    if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                        let _ = tx.unbounded_send(SecretShareRpc {
                            msg,
                            protocol: dec_msg.protocol,
                            response_sender: dec_msg.response_sender,
                        });
                    }
                },
                Err(e) => {
                    warn!("Invalid dec message: {}", e);
                },
            }
        }) {
            Ok(_) => {},
            Err(_) => {
                // Executor at capacity, log and drop this message
                warn!("Bounded executor at capacity, dropping message");
            }
        }
    }
}
```

Additionally, consider:
1. Implementing per-validator rate limiting before channel enqueueing
2. Adding metrics to detect sustained high verification load
3. Increasing bounded executor capacity if needed for high-throughput scenarios

## Proof of Concept

A complete PoC would require:
1. Setting up a local Aptos testnet with multiple validators
2. Configuring 2-3 validators as Byzantine
3. Programming these validators to continuously send secret share RPC requests
4. Monitoring honest validators for dropped messages and consensus stalls

The vulnerability can be demonstrated by:
1. Byzantine validators sending continuous `SecretShareMessage::RequestShare` or `SecretShareMessage::Share` messages
2. Monitoring the bounded executor saturation through metrics
3. Observing increased message drop rates on honest validators
4. Measuring consensus block latency increases due to incomplete secret sharing

## Notes

This vulnerability exploits a design flaw in the application-level message processing logic rather than network-layer flooding. The root cause is the blocking `spawn().await` call that prevents the verification task from processing any messages when the bounded executor is at capacity. This is analogous to other application-level resource exhaustion vulnerabilities in consensus systems.

The vulnerability is particularly concerning because:
1. It affects a critical consensus component (secret sharing)
2. It can be triggered by a small number of Byzantine validators
3. It's difficult to detect without proper metrics
4. The attack traffic resembles legitimate protocol behavior

The fix is straightforward (use `try_spawn` instead of `spawn`) but requires careful consideration of error handling and message prioritization strategies.

### Citations

**File:** consensus/src/epoch_manager.rs (L1285-1290)
```rust
        let (secret_share_manager_tx, secret_share_manager_rx) =
            aptos_channel::new::<AccountAddress, IncomingSecretShareRequest>(
                QueueStyle::KLAST,
                self.config.internal_per_key_channel_size,
                None,
            );
```

**File:** crates/channel/src/message_queues.rs (L138-147)
```rust
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```

**File:** consensus/src/network.rs (L920-936)
```rust
                        ConsensusMsg::SecretShareMsg(req) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback = IncomingRpcRequest::SecretShareRequest(
                                IncomingSecretShareRequest {
                                    req,
                                    sender: peer_id,
                                    protocol: RPC[0],
                                    response_sender: tx,
                                },
                            );
                            if let Err(e) = self.rpc_tx.push(
                                (peer_id, discriminant(&req_with_callback)),
                                (peer_id, req_with_callback),
                            ) {
                                warn!(error = ?e, "aptos channel closed");
                            };
                        },
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** crates/bounded-executor/src/executor.rs (L41-52)
```rust
    /// Spawn a [`Future`] on the `BoundedExecutor`. This function is async and
    /// will block if the executor is at capacity until one of the other spawned
    /// futures completes. This function returns a [`JoinHandle`] that the caller
    /// can `.await` on for the results of the [`Future`].
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```

**File:** config/src/config/consensus_config.rs (L242-242)
```rust
            internal_per_key_channel_size: 10,
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```
