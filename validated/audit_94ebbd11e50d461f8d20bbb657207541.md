# Audit Report

## Title
Critical State Inconsistency Between Vesting and Staking Contract Modules Causing Permanent Fund Freezing

## Summary
The vesting module exposes `get_vesting_account_signer` allowing admins to bypass vesting module state management and directly call `staking_contract::switch_operator`. This creates an irrecoverable state inconsistency where the cached operator in `VestingContract.staking.operator` no longer matches the actual operator key in `Store.staking_contracts`, causing all vesting operations to permanently fail with `ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR`.

## Finding Description

The vulnerability exploits a state synchronization flaw between the vesting and staking_contract modules.

**Root Cause:**

The `VestingContract` struct maintains a cached copy of the operator address in its `StakingInfo` field: [1](#0-0) 

The vesting module exposes an emergency function allowing admins to obtain the vesting account signer: [2](#0-1) 

**The Critical Flaw:**

With this signer, an admin can directly call `staking_contract::switch_operator`, which internally moves the `StakingContract` from the old operator key to the new operator key in the SimpleMap: [3](#0-2) [4](#0-3) 

However, this bypass does NOT update the cached `vesting_contract.staking.operator` field, creating permanent state inconsistency.

**Exploitation Impact:**

All vesting operations fail because they query using the stale cached operator:

`total_accumulated_rewards` uses the cached operator: [5](#0-4) 

`staking_contract_amounts` looks up by operator key and fails with `ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR` when keys don't match: [6](#0-5) [7](#0-6) 

All dependent functions fail: `unlock_rewards` (line 660), `vest` (line 679), `distribute` (line 756), `terminate_vesting_contract` (line 819), and internal helpers `unlock_stake` and `withdraw_stake`.

**No Recovery Mechanism:**

The proper `update_operator` function synchronizes both states: [8](#0-7) 

However, once state is broken, `update_operator` cannot fix it because it reads the stale cached operator (line 901) and attempts to switch from the wrong key, which will fail since no contract exists under the cached operator anymore.

## Impact Explanation

**Severity: CRITICAL** - Permanent Freezing of Funds

This matches Aptos Bug Bounty Critical Severity Category #5: "Permanent freezing of funds (requires hardfork)."

Impact:
1. **Permanent Fund Freezing**: All vested tokens and accumulated staking rewards become permanently inaccessible to all shareholders
2. **Complete DoS**: All core vesting functions immediately fail with assertion errors  
3. **Irrecoverable State**: No function exists to manually correct the cached operator. Recovery requires hardfork
4. **Affects Innocent Parties**: Shareholders (untrusted actors) lose funds due to admin error

The vulnerability affects potentially millions of dollars in production vesting contracts used for employee compensation, investor vesting schedules, and validator rewards across the Aptos ecosystem.

## Likelihood Explanation

**Likelihood: MEDIUM**

1. **Admin Access Required**: Requires vesting contract admin, but admins are NOT trusted roles per Aptos threat model (not core developers, validators, or governance participants). Any organization can create vesting contracts.

2. **Legitimate Emergency Use**: The function is explicitly documented as "for emergency use" - admins may legitimately attempt to call staking functions directly during operational emergencies.

3. **No Protections**: Zero guardrails, warnings, or runtime checks prevent this operation. The comment misleadingly claims this "doesn't give the admin total power" when it actually provides power to brick the contract.

4. **Accidental Triggering**: Can occur during legitimate emergency operations without malicious intent.

## Recommendation

**Fix:** Remove or restrict `get_vesting_account_signer` to prevent direct staking contract manipulation, OR add a recovery function that allows manual operator cache synchronization:

```move
// Add recovery function
public entry fun sync_operator_cache(
    admin: &signer,
    contract_address: address,
    actual_operator: address
) acquires VestingContract {
    let vesting_contract = borrow_global_mut<VestingContract>(contract_address);
    verify_admin(admin, vesting_contract);
    
    // Verify the actual_operator has the staking contract
    assert!(
        staking_contract::staking_contract_exists(contract_address, actual_operator),
        error::invalid_argument(ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR)
    );
    
    // Update cached operator
    vesting_contract.staking.operator = actual_operator;
}
```

**Better Fix:** Make `get_vesting_account_signer` a private friend function only callable by trusted modules.

## Proof of Concept

```move
#[test(aptos_framework = @0x1, admin = @0x123, shareholder = @0x234, operator_a = @0x111, operator_b = @0x222)]
public entry fun test_state_inconsistency_poc(
    aptos_framework: &signer,
    admin: &signer,
    shareholder: &signer,
    operator_a: &signer,
    operator_b: &signer,
) acquires AdminStore, VestingContract {
    // Setup vesting contract with operator_a
    let admin_addr = signer::address_of(admin);
    let shareholder_addr = signer::address_of(shareholder);
    let operator_a_addr = signer::address_of(operator_a);
    let operator_b_addr = signer::address_of(operator_b);
    
    setup(aptos_framework, &vector[admin_addr, shareholder_addr, operator_a_addr, operator_b_addr]);
    
    let contract_address = setup_vesting_contract(
        admin, 
        &vector[shareholder_addr],
        &vector[GRANT_AMOUNT],
        admin_addr,
        10 // commission
    );
    
    // Verify initial state works
    let rewards = total_accumulated_rewards(contract_address); // Works
    
    // Admin gets signer and directly switches operator (BYPASS)
    let vesting_signer = get_vesting_account_signer(admin, contract_address);
    staking_contract::switch_operator(&vesting_signer, operator_a_addr, operator_b_addr, 10);
    
    // Now all vesting operations fail permanently
    total_accumulated_rewards(contract_address); // FAILS with ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR
    vest(contract_address); // FAILS
    distribute(contract_address); // FAILS
    
    // Admin cannot recover - update_operator will also fail
    update_operator(admin, contract_address, operator_b_addr, 10); // FAILS - tries to switch from cached operator_a which doesn't exist
}
```

This demonstrates permanent, irrecoverable fund freezing affecting all shareholders due to state inconsistency between vesting and staking contract modules.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L126-135)
```text
    struct StakingInfo has store {
        // Where the vesting's stake pool is located at. Included for convenience.
        pool_address: address,
        // The currently assigned operator.
        operator: address,
        // The currently assigned voter.
        voter: address,
        // Commission paid to the operator of the stake pool.
        commission_percentage: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L459-466)
```text
    public fun total_accumulated_rewards(vesting_contract_address: address): u64 acquires VestingContract {
        assert_active_vesting_contract(vesting_contract_address);

        let vesting_contract = borrow_global<VestingContract>(vesting_contract_address);
        let (total_active_stake, _, commission_amount) =
            staking_contract::staking_contract_amounts(vesting_contract_address, vesting_contract.staking.operator);
        total_active_stake - vesting_contract.remaining_grant - commission_amount
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L892-904)
```text
    public entry fun update_operator(
        admin: &signer,
        contract_address: address,
        new_operator: address,
        commission_percentage: u64,
    ) acquires VestingContract {
        let vesting_contract = borrow_global_mut<VestingContract>(contract_address);
        verify_admin(admin, vesting_contract);
        let contract_signer = &get_vesting_account_signer_internal(vesting_contract);
        let old_operator = vesting_contract.staking.operator;
        staking_contract::switch_operator(contract_signer, old_operator, new_operator, commission_percentage);
        vesting_contract.staking.operator = new_operator;
        vesting_contract.staking.commission_percentage = commission_percentage;
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L1137-1144)
```text
    /// For emergency use in case the admin needs emergency control of vesting contract account.
    /// This doesn't give the admin total power as the admin would still need to follow the rules set by
    /// staking_contract and stake modules.
    public fun get_vesting_account_signer(admin: &signer, contract_address: address): signer acquires VestingContract {
        let vesting_contract = borrow_global<VestingContract>(contract_address);
        verify_admin(admin, vesting_contract);
        get_vesting_account_signer_internal(vesting_contract)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L325-332)
```text
    public fun staking_contract_amounts(
        staker: address, operator: address
    ): (u64, u64, u64) acquires Store {
        assert_staking_contract_exists(staker, operator);
        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;
        let staking_contract = simple_map::borrow(staking_contracts, &operator);
        get_staking_contract_amounts_internal(staking_contract)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L847-847)
```text
        let (_, staking_contract) = simple_map::remove(staking_contracts, &old_operator);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L870-870)
```text
        simple_map::add(staking_contracts, new_operator, staking_contract);
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1012-1024)
```text
    fun assert_staking_contract_exists(
        staker: address, operator: address
    ) acquires Store {
        assert!(
            exists<Store>(staker),
            error::not_found(ENO_STAKING_CONTRACT_FOUND_FOR_STAKER)
        );
        let staking_contracts = &borrow_global<Store>(staker).staking_contracts;
        assert!(
            simple_map::contains_key(staking_contracts, &operator),
            error::not_found(ENO_STAKING_CONTRACT_FOUND_FOR_OPERATOR)
        );
    }
```
