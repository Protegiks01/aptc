# Audit Report

## Title
Player Identity Mismatch in Batch Threshold Decryption Allows Denial of Service

## Summary
The batch threshold encryption system fails to validate that the Player ID embedded within a DecryptionKeyShare matches the expected Player ID of the validator submitting the share. A Byzantine validator can exploit this to submit shares with manipulated Player IDs, causing Shamir secret reconstruction to fail and resulting in denial of service for encrypted transaction decryption.

## Finding Description

The vulnerability exists in the secret share verification logic used for threshold decryption of encrypted transactions in consensus. When a validator submits a `SecretShare`, the verification retrieves the validator's index from their `Author` address and validates the cryptographic signature, but **never checks that the Player ID inside the share matches the expected Player ID**. [1](#0-0) 

The verification uses the author-to-index mapping to look up the correct verification key, but the Player ID embedded in the `DecryptionKeyShare` tuple is never validated against this expected index. [2](#0-1) [3](#0-2) 

The BLS signature verification only validates cryptographic correctness, not the Player ID: [4](#0-3) 

During weighted threshold verification, the verification logic actually creates a **new tuple** with the correct Player ID from the verification key for cryptographic validation, but this doesn't sanitize the original share: [5](#0-4) 

At line 167, it creates `&(self.weighted_player, dk_share.clone())` - using the verification key's Player ID for cryptographic checks, but the **original share retains its manipulated Player ID**.

When shares are aggregated for reconstruction, the **unsanitized Player IDs** from the original shares are extracted and used for Shamir secret sharing Lagrange interpolation: [6](#0-5) 

At line 436, `sc.get_virtual_player(player, pos)` uses the Player from the share tuple. If manipulated, this computes wrong virtual player indices. [7](#0-6) 

At line 323, Player IDs are extracted via `p.get_id()` and used at line 326 for computing Lagrange coefficients. Incorrect Player IDs cause Lagrange interpolation to use wrong evaluation points, resulting in reconstruction failure.

**Attack Path:**

1. Byzantine validator derives legitimate decryption key share using their master secret key
2. Before broadcasting, modifies the Player ID in the share tuple to an arbitrary value
3. Broadcasts the modified share with their correct Author address
4. Share passes verification because:
   - Author-to-index mapping succeeds
   - BLS signature verification succeeds (using correct verification key)
   - **No validation checks Player ID matches expected value**
5. During reconstruction, the manipulated Player ID is used to compute virtual player indices
6. Lagrange interpolation uses wrong indices, causing reconstruction failure
7. Encrypted transaction decryption fails [8](#0-7) 

## Impact Explanation

This vulnerability constitutes **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns" and protocol violations.

The batch threshold decryption system is integrated into consensus for processing encrypted transactions: [9](#0-8) [10](#0-9) 

A single Byzantine validator can inject malformed shares that pass all cryptographic verifications but cause reconstruction failures. When the malicious share is included in the threshold subset, the decryption key cannot be reconstructed correctly.

**Impact includes:**
- **Probabilistic DoS**: If the malicious share is among the first `threshold` shares aggregated, decryption fails
- **Protocol Violation**: Verified shares must be usable for reconstruction - this invariant is broken
- **Consensus Delays**: Failed decryption disrupts encrypted transaction processing
- **Liveness Impact**: Encrypted transaction processing is a consensus component

The aggregation logic takes shares as they arrive: [11](#0-10) 

A malicious share from a fast-responding validator has high probability of inclusion in the reconstruction set.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low barrier to entry**: Any validator can execute this attack without special resources or collusion
2. **Simple execution**: Requires only modifying the Player field in a tuple before broadcasting
3. **Difficult detection**: The malformed shares pass all cryptographic verifications
4. **No economic cost**: No stake slashing mechanism for this behavior
5. **Economic incentive**: Malicious validators could delay encrypted transaction processing for competitive advantages

The only requirement is being a registered validator, which is within the Byzantine threat model (up to 1/3 malicious validators).

## Recommendation

Add validation to ensure the Player ID in the share matches the expected Player ID for the validator's index:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author());
    let decryption_key_share = self.share().clone();
    
    // NEW: Validate Player ID matches expected index
    let expected_player = Player { id: index };
    if decryption_key_share.player() != expected_player {
        return Err(anyhow::anyhow!(
            "Player ID mismatch: share has {:?}, expected {:?}",
            decryption_key_share.player(),
            expected_player
        ));
    }
    
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

This validation should be added to `SecretShare::verify` in `types/src/secret_sharing.rs` to ensure the Player ID in the share matches the expected value derived from the author's validator index.

## Proof of Concept

While a complete runnable PoC is not provided in this report, the attack path is straightforward:

1. In a test validator, after deriving a legitimate share at `decryption_pipeline_builder.rs:103`
2. Before creating the `SecretShare` at line 105, modify the Player ID in the `derived_key_share` tuple
3. Broadcast the modified share
4. Observe that verification passes but reconstruction fails when this share is included

The vulnerability is confirmed by code inspection showing:
- No Player ID validation in the verification path
- Player IDs from shares are used directly in Lagrange interpolation
- Wrong Player IDs will cause reconstruction to fail or produce incorrect results

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L84-92)
```rust
    pub fn aggregate<'a>(
        dec_shares: impl Iterator<Item = &'a SecretShare>,
        config: &SecretShareConfig,
    ) -> anyhow::Result<DecryptionKey> {
        let threshold = config.threshold();
        let shares: Vec<SecretKeyShare> = dec_shares
            .map(|dec_share| dec_share.share.clone())
            .take(threshold as usize)
            .collect();
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L38-38)
```rust
pub type BIBEDecryptionKeyShare = (Player, BIBEDecryptionKeyShareValue);
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L118-133)
```rust
fn verify_bls(
    verification_key_g2: G2Affine,
    digest: &Digest,
    offset: G2Affine,
    signature: G1Affine,
) -> Result<()> {
    let hashed_offset: G1Affine = symmetric::hash_g2_element(offset)?;

    if PairingSetting::pairing(digest.as_g1() + hashed_offset, verification_key_g2)
        == PairingSetting::pairing(signature, G2Affine::generator())
    {
        Ok(())
    } else {
        Err(anyhow::anyhow!("bls verification error"))
    }
}
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L38-38)
```rust
pub type WeightedBIBEDecryptionKeyShare = (Player, Vec<BIBEDecryptionKeyShareValue>);
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L158-169)
```rust
        self.vks_g2
            .iter()
            .map(|vk_g2| BIBEVerificationKey {
                mpk_g2: self.mpk_g2,
                vk_g2: *vk_g2,
                player: self.weighted_player, // arbitrary
            })
            .zip(&dk_share.1)
            .try_for_each(|(vk, dk_share)| {
                vk.verify_decryption_key_share(digest, &(self.weighted_player, dk_share.clone()))
            })
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L429-446)
```rust
        // println!();
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }
```

**File:** crates/aptos-crypto/src/arkworks/shamir.rs (L319-329)
```rust
        } else {
            let (roots_of_unity_indices, bases): (Vec<usize>, Vec<Self::ShareValue>) = shares
                [..sc.t]
                .iter()
                .map(|(p, g_y)| (p.get_id(), g_y))
                .collect();

            let lagrange_coeffs = sc.lagrange_for_subset(&roots_of_unity_indices);

            Ok(T::weighted_sum(&bases, &lagrange_coeffs))
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L55-70)
```rust
        tokio::task::spawn_blocking(move || {
            let maybe_key = SecretShare::aggregate(self.shares.values(), &dec_config);
            match maybe_key {
                Ok(key) => {
                    let dec_key = SecretSharedKey::new(metadata, key);
                    let _ = decision_tx.unbounded_send(dec_key);
                },
                Err(e) => {
                    warn!(
                        epoch = metadata.epoch,
                        round = metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L27-43)
```rust
    pub(crate) async fn decrypt_encrypted_txns(
        materialize_fut: TaskFuture<MaterializeResult>,
        block: Arc<Block>,
        author: Author,
        secret_share_config: Option<SecretShareConfig>,
        derived_self_key_share_tx: oneshot::Sender<Option<SecretShare>>,
        secret_shared_key_rx: oneshot::Receiver<Option<SecretSharedKey>>,
    ) -> TaskResult<DecryptionResult> {
        let mut tracker = Tracker::start_waiting("decrypt_encrypted_txns", &block);
        let (input_txns, max_txns_from_block_to_execute, block_gas_limit) = materialize_fut.await?;

        tracker.start_working();

        if secret_share_config.is_none() {
            return Ok((input_txns, max_txns_from_block_to_execute, block_gas_limit));
        }

```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L103-120)
```rust
        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

```
