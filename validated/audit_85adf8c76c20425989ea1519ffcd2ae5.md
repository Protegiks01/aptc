# Audit Report

## Title
Non-Deterministic DKG Transcript Verification Violates Consensus Determinism Invariant

## Summary
The DKG transcript verification uses `thread_rng()` to generate random challenge scalars during consensus block execution, violating the fundamental requirement that all validators must execute blocks deterministically. This creates a theoretical possibility of consensus divergence, though with extremely low probability.

## Finding Description

The production DKG implementation uses non-deterministic randomness during consensus-critical block execution. When validators process blocks containing `DKGResult` transactions, each validator independently generates different random challenges for cryptographic verification.

**Verified Execution Flow:**

ValidatorTransactions are ordered between BlockMetadata and UserTransactions in the canonical block execution sequence. [1](#0-0) 

The AptosVM routes ValidatorTransaction::DKGResult to the DKG processing module. [2](#0-1) 

The DKG processor validates transcripts cryptographically before publishing on-chain. [3](#0-2) 

This calls `DefaultDKG::verify_transcript()` which verifies the weighted transcript. [4](#0-3) 

The weighted transcript verification explicitly uses **non-deterministic `thread_rng()`** to generate random challenge scalars. [5](#0-4) 

The code comment at line 295 acknowledges: "Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable." This assessment fails to consider that consensus execution requires absolute determinism.

**Broken Invariant:** All blockchain consensus systems require deterministic execution - identical inputs must produce identical outputs across all validators. Using `thread_rng()` during block execution categorically violates this invariant.

**Consensus Divergence Risk:** While the cryptographic soundness error is typically <2^-128, the principle of deterministic execution in consensus is absolute. Each DKG session generates different random values per validator, creating theoretical possibility that verification outcomes diverge, preventing 2f+1 quorum formation.

## Impact Explanation

**Severity: HIGH**

This vulnerability violates fundamental consensus safety properties:

1. **Consensus Invariant Violation**: The code definitively uses non-deterministic randomness during block execution, violating the absolute requirement for deterministic consensus execution.

2. **Theoretical Network Partition Risk**: If verification outcomes diverge (however unlikely), validators cannot reach consensus, requiring manual intervention or hard fork to resolve.

3. **No Safety Mechanisms**: There are no checks, fallbacks, or recovery mechanisms to detect or prevent execution non-determinism at the consensus layer.

4. **Production Code Path**: This affects the real DKG implementation used during validator set changes, not test-only code paths.

While the practical probability of actual divergence is astronomically low (cryptographic soundness error typically <2^-128), the architectural violation of consensus determinism principles is a HIGH severity issue that should be remediated. The risk compounds over thousands of DKG sessions across blockchain lifetime.

## Likelihood Explanation

**Likelihood: LOW (practical divergence) / HIGH (architectural violation)**

The non-determinism occurs with 100% certainty - each validator generates different random values during every DKG session. However, the likelihood of this causing actual consensus divergence depends on:

- **Cryptographic Soundness**: With correct implementations, different random challenges should produce identical accept/reject decisions with overwhelming probability (1 - 2^-128)
- **DKG Session Frequency**: Sessions occur only during epoch transitions
- **No Historical Evidence**: No documented instances of this causing consensus failures

The key issue is that this is a **logic vulnerability** - deterministic execution is a hard requirement in consensus systems, not a probabilistic property. The violation of this principle is guaranteed, even if practical harm is unlikely.

## Recommendation

Replace non-deterministic `thread_rng()` with deterministic Fiat-Shamir challenge derivation. The codebase already contains a proper implementation: [6](#0-5) 

The `fiat_shamir_challenge_for_sigma_protocol` function uses Merlin transcripts to derive deterministic challenges from the transcript data itself, ensuring all validators compute identical challenges.

**Fix approach:**
1. Modify the `verify` function signature to accept a domain separation tag
2. Replace `rand::thread_rng()` with calls to `fiat_shamir_challenge_for_sigma_protocol`
3. Derive challenges by hashing the transcript contents, public parameters, and auxiliary data
4. Ensure all validators compute identical challenges deterministically

Note: The sigma protocol implementation also uses `thread_rng()` at line 95, which should similarly be replaced with deterministic challenge derivation.

## Proof of Concept

The vulnerability triggers automatically during DKG execution. To observe the non-deterministic behavior:

1. Deploy multiple validator nodes
2. Trigger a DKG session during epoch transition
3. Add logging to capture the random challenge values generated at `weighted_protocol.rs:297`
4. Observe that each validator generates different random scalars for `extra` variable
5. While verification outcomes will match with overwhelming probability, the execution is provably non-deterministic

The architectural violation is evident from code inspection without requiring a functional PoC of consensus divergence, as the probability of divergence (while non-zero) is cryptographically negligible.

## Notes

This finding represents a **logic vulnerability** rather than a practically exploitable bug. The code violates the architectural principle that consensus execution must be deterministic, even though the probability of actual harm is vanishingly small. Blockchain consensus systems have zero tolerance for non-determinism, and this issue should be remediated by adopting deterministic Fiat-Shamir challenge derivation as used elsewhere in the codebase.

### Citations

**File:** consensus/consensus-types/src/block.rs (L553-566)
```rust
    pub fn combine_to_input_transactions(
        validator_txns: Vec<ValidatorTransaction>,
        txns: Vec<SignedTransaction>,
        metadata: BlockMetadataExt,
    ) -> Vec<Transaction> {
        once(Transaction::from(metadata))
            .chain(
                validator_txns
                    .into_iter()
                    .map(Transaction::ValidatorTransaction),
            )
            .chain(txns.into_iter().map(Transaction::UserTransaction))
            .collect()
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/mod.rs (L16-36)
```rust
    pub(crate) fn process_validator_transaction(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        txn: ValidatorTransaction,
        log_context: &AdapterLogSchema,
    ) -> Result<(VMStatus, VMOutput), VMStatus> {
        let session_id = SessionId::validator_txn(&txn);
        match txn {
            ValidatorTransaction::DKGResult(dkg_node) => {
                self.process_dkg_result(resolver, module_storage, log_context, session_id, dkg_node)
            },
            ValidatorTransaction::ObservedJWKUpdate(jwk_update) => self.process_jwk_update(
                resolver,
                module_storage,
                log_context,
                session_id,
                jwk_update,
            ),
        }
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L83-149)
```rust
    fn process_dkg_result_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        dkg_node: DKGTranscript,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        let dkg_state =
            OnChainConfig::fetch_config(resolver).ok_or(Expected(MissingResourceDKGState))?;
        let config_resource = ConfigurationResource::fetch_config(resolver)
            .ok_or(Expected(MissingResourceConfiguration))?;
        let DKGState { in_progress, .. } = dkg_state;
        let in_progress_session_state =
            in_progress.ok_or(Expected(MissingResourceInprogressDKGSession))?;

        // Check epoch number.
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }

        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;

        // All check passed, invoke VM to publish DKG result on chain.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            dkg_node.transcript_bytes.as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &RECONFIGURATION_WITH_DKG_MODULE,
                FINISH_WITH_DKG_RESULT,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, FINISH_WITH_DKG_RESULT.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-401)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;

        // Verify fast path is present if and only if fast_wconfig is present.
        ensure!(
            trx.fast.is_some() == params.pvss_config.fast_wconfig.is_some(),
            "real_dkg::verify_transcript failed with mismatched fast path flag in trx and params."
        );

        if let Some(fast_trx) = trx.fast.as_ref() {
            let fast_dealers = fast_trx
                .get_dealers()
                .iter()
                .map(|player| player.id)
                .collect::<Vec<usize>>();
            ensure!(
                dealers == fast_dealers,
                "real_dkg::verify_transcript failed with inconsistent dealer index."
            );
        }

        if let (Some(fast_trx), Some(fast_wconfig)) =
            (trx.fast.as_ref(), params.pvss_config.fast_wconfig.as_ref())
        {
            fast_trx.verify(fast_wconfig, &params.pvss_config.pp, &spks, &all_eks, &aux)?;
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L280-377)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        self.check_sizes(sc)?;
        let n = sc.get_total_num_players();
        if eks.len() != n {
            bail!("Expected {} encryption keys, but got {}", n, eks.len());
        }
        let W = sc.get_total_weight();

        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = rand::thread_rng();
        let extra = random_scalars(2 + W * 3, &mut rng);

        let sok_vrfy_challenge = &extra[W * 3 + 1];
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;

        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;

        //
        // Correctness of encryptions check
        //

        let alphas_betas_and_gammas = &extra[0..W * 3 + 1];
        let (alphas_and_betas, gammas) = alphas_betas_and_gammas.split_at(2 * W + 1);
        let (alphas, betas) = alphas_and_betas.split_at(W + 1);
        assert_eq!(alphas.len(), W + 1);
        assert_eq!(betas.len(), W);
        assert_eq!(gammas.len(), W);

        let lc_VR_hat = G2Projective::multi_exp_iter(
            self.V_hat.iter().chain(self.R_hat.iter()),
            alphas_and_betas.iter(),
        );
        let lc_VRC = G1Projective::multi_exp_iter(
            self.V.iter().chain(self.R.iter()).chain(self.C.iter()),
            alphas_betas_and_gammas.iter(),
        );
        let lc_V_hat = G2Projective::multi_exp_iter(self.V_hat.iter().take(W), gammas.iter());
        let mut lc_R_hat = Vec::with_capacity(n);

        for i in 0..n {
            let p = sc.get_player(i);
            let weight = sc.get_player_weight(&p);
            let s_i = sc.get_player_starting_index(&p);

            lc_R_hat.push(g2_multi_exp(
                &self.R_hat[s_i..s_i + weight],
                &gammas[s_i..s_i + weight],
            ));
        }

        let h = pp.get_encryption_public_params().message_base();
        let g_2_neg = g_2.neg();
        let eks = eks
            .iter()
            .map(Into::<G1Projective>::into)
            .collect::<Vec<G1Projective>>();
        // The vector of left-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L400-462)
```rust
/// Computes the Fiat–Shamir challenge for a Σ-protocol instance.
///
/// This function derives a non-interactive challenge scalar by appending
/// protocol-specific data to a Merlin transcript. In the abstraction used here,
/// the protocol proves knowledge of a preimage under a homomorphism. Therefore,
/// all public data relevant to that homomorphism (e.g., its MSM bases) and
/// the image under consideration are included in the transcript.
///
/// # Arguments
/// - `cntxt`: Extra "context" material that needs to be hashed for the challenge.
/// - `hom`: The homomorphism structure carrying its public data (e.g., MSM bases).
/// - `statement`: The public statement, i.e. the image of a witness under the homomorphism.
/// - `prover_first_message`: the first message in the Σ-protocol (the prover's commitment)
/// - `dst`: A domain separation tag to ensure unique challenges per protocol.
///
/// # Returns
/// The derived Fiat–Shamir challenge scalar, after incorporating the domain
/// separator, public data, statement, and prover’s first message into the transcript.
pub fn fiat_shamir_challenge_for_sigma_protocol<
    Ct: Serialize,
    F: PrimeField,
    H: homomorphism::Trait + CanonicalSerialize,
>(
    cntxt: &Ct,
    hom: &H,
    statement: &H::Codomain,
    prover_first_message: &H::Codomain,
    dst: &[u8],
) -> F
where
    H::Domain: Witness<F>,
    H::Codomain: Statement,
{
    // Initialise the transcript
    let mut fs_t = merlin::Transcript::new(dst);

    // Append the "context" to the transcript
    <merlin::Transcript as fiat_shamir::SigmaProtocol<F, H>>::append_sigma_protocol_ctxt(
        &mut fs_t, cntxt,
    );

    // Append the MSM bases to the transcript. (If the same hom is used for many proofs, maybe use a single transcript + a boolean to prevent it from repeating?)
    <merlin::Transcript as fiat_shamir::SigmaProtocol<F, H>>::append_sigma_protocol_msm_bases(
        &mut fs_t, hom,
    );

    // Append the public statement (the image of the witness) to the transcript
    <merlin::Transcript as fiat_shamir::SigmaProtocol<F, H>>::append_sigma_protocol_public_statement(
        &mut fs_t,
        statement,
    );

    // Add the first prover message (the commitment) to the transcript
    <merlin::Transcript as fiat_shamir::SigmaProtocol<F, H>>::append_sigma_protocol_first_prover_message(
        &mut fs_t,
        prover_first_message,
    );

    // Generate the Fiat-Shamir challenge from the updated transcript
    <merlin::Transcript as fiat_shamir::SigmaProtocol<F, H>>::challenge_for_sigma_protocol(
        &mut fs_t,
    )
}
```
