# Audit Report

## Title
Panic-Induced Denial of Service via Removed Validator Secret Shares

## Summary
When validators leave the validator set during epoch transitions, the secret sharing verification code uses `.expect()` to retrieve their validator index, causing a panic when they are not found. This allows removed validators to crash verification tasks by sending secret share messages during timing windows, leading to resource exhaustion and disruption of the randomness generation subsystem.

## Finding Description

The secret sharing mechanism fails to gracefully handle messages from validators who have left the validator set. The vulnerability exists in multiple `get_id()` implementations that use `.expect()` without bounds checking: [1](#0-0) [2](#0-1) 

The verification flow demonstrates the vulnerability:

1. Network messages arrive and are wrapped into `IncomingSecretShareRequest` with the sender's peer_id: [3](#0-2) 

2. The verification task spawns bounded executor tasks to process messages: [4](#0-3) 

3. Message epoch is validated first, then for Share messages, verification is called: [5](#0-4) 

4. The `SecretShare::verify()` method calls `get_id()` which panics BEFORE cryptographic validation: [6](#0-5) 

The code contains a TODO comment acknowledging this missing validation: [7](#0-6) 

**Attack Scenario:**
- Validator V participates in epoch N
- Epoch transitions to N+1, V is removed from validator set  
- A timing window exists where the new epoch's `SecretShareManager` is running but V's connection hasn't been closed yet
- V crafts a `SecretShareMessage::Share` with epoch=N+1 and author=V's address
- V sends this message before connection closure
- Receiving node's verification task calls `get_id(V's address)`
- HashMap lookup returns `None`, `.expect()` panics
- Task crashes, wasting bounded executor resources

The `BoundedExecutor` implementation shows that permits are released even when tasks panic, preventing permanent resource exhaustion: [8](#0-7) 

However, the `IncomingSecretShareRequest.sender` field is marked unused, indicating no validation against the message author: [9](#0-8) 

## Impact Explanation

This vulnerability represents **Medium to High Severity** impact:

**Resource Exhaustion (Medium-High):** Each malicious message spawns a verification task that panics, consuming CPU cycles and temporarily exhausting bounded executor capacity. While permits are released on panic (preventing permanent DoS), repeated messages during timing windows can degrade validator performance.

**Randomness Generation Disruption (Medium):** The secret sharing mechanism is critical for the randomness subsystem. Repeated panics during epoch transitions could disrupt proper secret aggregation, affecting validator operations.

The impact is mitigated by:
- Bounded executor capacity limiting concurrent task spawning
- Automatic permit release on panic
- Limited timing window for exploitation
- Connection closure mechanisms

This aligns with the Aptos bug bounty criterion for "Validator Node Slowdowns (High): Significant performance degradation affecting consensus; DoS through resource exhaustion," though the actual severity may lean toward the lower end due to the mitigating factors.

## Likelihood Explanation

**Likelihood: Medium**

**Exploitability Factors:**
- **Timing Window Exists:** During epoch transitions, there's a window where the `SecretShareManager` starts with the new validator set before `ConnectivityManager` closes stale connections asynchronously
- **Simple Execution:** Attacker only needs to craft a message with matching epoch and their address as author
- **No Cryptographic Material Required:** Panic occurs at line 76 before cryptographic verification at lines 79-80
- **Repeatable:** Attack can be executed on every epoch transition

**Attack Requirements:**
- Must be a former validator (had network keys and connections for previous epoch)
- Network connection during timing window
- Basic message crafting ability

**Mitigating Factors:**
- Requires former validator status (limited attacker pool)
- Timing window is constrained by asynchronous connection closure
- Each task releases its permit on panic (no permanent DoS)
- Network authentication and connection management reduce attack surface

## Recommendation

Replace the `.expect()` calls with proper error handling that gracefully handles missing validator indices:

```rust
pub fn get_id(&self, peer: &Author) -> anyhow::Result<usize> {
    self.validator
        .address_to_validator_index()
        .get(peer)
        .copied()
        .ok_or_else(|| anyhow::anyhow!("Peer {} not in current validator set", peer))
}
```

Update the `verify()` method to handle the error:

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author())?;
    ensure!(index < config.verification_keys.len(), "Index out of bounds");
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

Additionally, consider validating that the message author matches the network peer_id in the verification task before deserializing and processing the message.

## Proof of Concept

A proof of concept would require:
1. Setting up a multi-validator testnet
2. Removing a validator from the validator set via epoch transition
3. Having the removed validator send crafted `SecretShareMessage::Share` messages with the new epoch number during the timing window
4. Observing panic logs and verification task crashes on receiving validators

The exploit is straightforward given network access during the timing window, as the code will panic when attempting to retrieve the validator index for a removed validator.

## Notes

This vulnerability highlights a broader code quality issue where `.expect()` is used in production code that processes external network inputs. While the immediate impact is mitigated by the bounded executor's permit release mechanism and limited timing windows, this represents a legitimate protocol vulnerability that should be addressed. The TODO comment at line 78 confirms this is known technical debt requiring proper bounds checking and error handling.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/types.rs (L75-81)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/network.rs (L155-161)
```rust
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/network.rs (L920-928)
```rust
                        ConsensusMsg::SecretShareMsg(req) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback = IncomingRpcRequest::SecretShareRequest(
                                IncomingSecretShareRequest {
                                    req,
                                    sender: peer_id,
                                    protocol: RPC[0],
                                    response_sender: tx,
                                },
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** crates/bounded-executor/src/executor.rs (L100-109)
```rust
fn future_with_permit<F>(future: F, permit: OwnedSemaphorePermit) -> impl Future<Output = F::Output>
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{
    future.map(move |ret| {
        drop(permit);
        ret
    })
}
```
