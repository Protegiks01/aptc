# Audit Report

## Title
EventPrunerProgress Divergence Leading to Permanent Dangling Index Corruption

## Summary
The EventStorePruner maintains separate progress metadata in main and indexer databases. Database truncation operations systematically skip cleaning up indexer indices, creating dangling pointers that cause permanent API query failures when db_sharding is enabled.

## Finding Description

The system violates state consistency through a critical flaw in the database truncation path:

**Core Issue: Truncation Ignores Indexer Indices**

The `delete_event_data` function explicitly skips cleaning up indexer DB indices during truncation, passing `None` for `indices_batch` with a TODO comment acknowledging the missing cleanup. [1](#0-0) 

This function is called during database synchronization at startup when `sync_commit_progress` detects inconsistencies: [2](#0-1) [3](#0-2) 

When `prune_event_indices` receives `None` for `indices_batch`, it skips the index deletion loop: [4](#0-3) 

**Non-Atomic Progress Updates**

EventStorePruner writes progress to two databases sequentially - first to indexer DB, then to main DB: [5](#0-4) 

If a crash occurs between line 78 and line 80, the indexer DB has newer progress than main DB.

**One-Directional Conflict Resolution**

On restart, EventStorePruner only reads progress from the main database: [6](#0-5) 

The catch-up prune at line 106 only moves forward, never cleaning up stale indexer indices.

**Exploitation via Query Failures**

When `db_sharding_enabled` is true (default configuration), queries route to the indexer reader: [7](#0-6) [8](#0-7) 

The indexer retrieves indices from indexer DB via `lookup_events_by_key`, then fetches events from main DB: [9](#0-8) 

If dangling indices exist, `get_event_by_version_and_index` fails with NotFound: [10](#0-9) 

## Impact Explanation

**Medium Severity** - This meets the "Limited Protocol Violations" category:

1. **State Inconsistencies**: EventPrunerProgress metadata diverges between databases, requiring manual intervention to resolve
2. **Data Availability Loss**: Event queries fail with "Event X of Txn Y not found" errors for affected ranges when using db_sharding
3. **Persistent Corruption**: The divergence is permanent because the pruner never retroactively cleans up stale indices

The impact is limited to nodes with `enable_storage_sharding=true` (default configuration) and only affects event query APIs, not consensus or fund safety.

## Likelihood Explanation

**Medium Likelihood** - This occurs when:

1. Database synchronization detects inconsistencies (uncommitted data after crash)
2. `sync_commit_progress` truncates ledger DB back to overall commit progress
3. Events are deleted from main DB but indices remain in indexer DB
4. Subsequent queries encounter the dangling indices

The truncation path is guaranteed to skip indexer cleanup (evidenced by TODO comment at line 537), but requires specific preconditions (database inconsistency requiring truncation). The vulnerability affects the default production configuration where `enable_storage_sharding=true`.

## Recommendation

Implement proper indexer DB cleanup in the `delete_event_data` function:

1. Pass a valid `SchemaBatch` for indexer indices when calling `prune_event_indices`
2. Add a parameter to `delete_event_data` to accept the internal indexer DB reference
3. Delete indices from `EventByKeySchema` and `EventByVersionSchema` in the indexer DB
4. Ensure atomic cleanup of both main and indexer databases during truncation

Alternatively, implement a desync detection and recovery mechanism in `EventStorePruner::new()` that compares progress between main and indexer databases and performs cleanup if divergence is detected.

## Proof of Concept

The vulnerability can be reproduced through the following scenario:

1. Run an Aptos node with `enable_storage_sharding=true` (default)
2. Enable event indexing in internal indexer
3. Trigger a system crash immediately after the indexer DB write (line 78) but before the main DB write (line 80) in `EventStorePruner::prune()`
4. On restart, `sync_commit_progress` will detect database inconsistency and call `truncate_ledger_db`
5. The truncation deletes events from main DB but leaves indices in indexer DB
6. Query events using the API - requests will route to indexer reader
7. Observe NotFound errors when the indexer tries to fetch events that were deleted from main DB

The corrupted state is permanent and requires manual database cleanup or re-indexing to resolve.

## Notes

This vulnerability represents a design flaw in the database truncation recovery mechanism where the assumption that "same data will be overwritten into indices" (per the TODO comment) does not hold in crash scenarios. The EventStorePruner's forward-only pruning strategy cannot retroactively fix desynchronization introduced by truncation operations, making this corruption persistent until manual intervention.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L345-345)
```rust
    delete_event_data(ledger_db, start_version, &mut batch.event_db_batches)?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L532-538)
```rust
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
```

**File:** storage/aptosdb/src/state_store/mod.rs (L448-449)
```rust
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L206-217)
```rust
            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L66-80)
```rust
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::EventPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;

        if let Some(mut indexer_batch) = indexer_batch {
            indexer_batch.put::<InternalIndexerMetadataSchema>(
                &IndexerMetadataKey::EventPrunerProgress,
                &IndexerMetadataValue::Version(target_version),
            )?;
            self.expect_indexer_db()
                .get_inner_db_ref()
                .write_schemas(indexer_batch)?;
        }
        self.ledger_db.event_db().write_schemas(batch)
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/event_store_pruner.rs (L90-94)
```rust
        let progress = get_or_initialize_subpruner_progress(
            ledger_db.event_db_raw(),
            &DbMetadataKey::EventPrunerProgress,
            metadata_progress,
        )?;
```

**File:** api/src/context.rs (L443-443)
```rust
        let mut iter = if !db_sharding_enabled(&self.node_config) {
```

**File:** config/src/config/storage_config.rs (L233-234)
```rust
            enable_storage_sharding: true,
            high_priority_background_threads: 4,
```

**File:** storage/indexer/src/db_indexer.rs (L671-697)
```rust
        let mut event_indices = self.indexer_db.lookup_events_by_key(
            event_key,
            first_seq,
            real_limit,
            ledger_version,
        )?;

        // When descending, it's possible that user is asking for something beyond the latest
        // sequence number, in which case we will consider it a bad request and return an empty
        // list.
        // For example, if the latest sequence number is 100, and the caller is asking for 110 to
        // 90, we will get 90 to 100 from the index lookup above. Seeing that the last item
        // is 100 instead of 110 tells us 110 is out of bound.
        if order == Order::Descending {
            if let Some((seq_num, _, _)) = event_indices.last() {
                if *seq_num < cursor {
                    event_indices = Vec::new();
                }
            }
        }

        let mut events_with_version = event_indices
            .into_iter()
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
```

**File:** storage/aptosdb/src/event_store/mod.rs (L42-50)
```rust
    pub fn get_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEvent> {
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```
