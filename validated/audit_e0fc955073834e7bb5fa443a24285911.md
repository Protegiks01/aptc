# Audit Report

## Title
Gas Metering Undercharge in VecUnpack Operation Allows Unpaid Computation Before Validation

## Summary
The `charge_vec_unpack()` function charges gas based on `expect_num_elements` parameter, but the actual unpacking operation processes all elements in the vector before validating the count. This allows attackers to pay gas for fewer elements while forcing validators to perform O(n) work, where n is the actual vector size, violating the Move VM's gas metering invariants.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Gas Charging**

The gas meter implementation completely ignores the actual vector size passed in the `_elems` parameter (indicated by underscore prefix for unused parameter), charging only based on `expect_num_elements`: [1](#0-0) 

**2. VM Execution Order**

The interpreter charges gas BEFORE calling `vec_val.unpack(*num)`, meaning validators commit to undercharged gas when validation subsequently fails: [2](#0-1) 

**3. Unpack Implementation**

The `unpack()` method first calls `unpack_unchecked()` which iterates through ALL actual elements before validation: [3](#0-2) 

The `unpack_unchecked()` implementation iterates through all elements, wrapping each in a Value container: [4](#0-3) 

**Attack Flow:**

1. Attacker publishes a Move module using Move IR with bytecode containing `VecUnpack(signature_index, 1)` in a function that accepts a vector parameter

2. The function is called with a vector containing 100,000 elements

3. Gas charged: VEC_UNPACK_BASE (1838) + VEC_UNPACK_PER_EXPECTED_ELEM (147) × 1 = 1985 internal gas units [5](#0-4) 

4. The VM calls `unpack_unchecked()` which iterates through all 100,000 elements, wrapping each in a Value container

5. Only after this O(n) work, the validation check detects the mismatch and returns VEC_UNPACK_PARITY_MISMATCH error

6. Transaction aborts, but validators have already performed work proportional to 100,000 elements while being paid for 1 element

**Why Bytecode Verifier Cannot Prevent This:**

The bytecode verifier only validates that the `num` parameter is within bounds (≤ u16::MAX), not that it matches runtime vector lengths: [6](#0-5) 

Type safety verification only checks types, not runtime correctness: [7](#0-6) 

Test files confirm mismatched VecUnpack instructions are allowed by the verifier: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria:

**Validator Node Slowdowns (High Category - up to $50,000):**

Attackers can cause validators to perform disproportionate CPU work relative to gas paid. The work amplification factor is calculated as:
- Gas charged: 1,838 + 147 × 1 = 1,985 internal gas units
- Work performed: equivalent to 1,838 + 147 × 100,000 = 14,701,838 internal gas units
- **Amplification: 7,400×**

This creates a significant performance degradation vector affecting consensus, as validators must:
- Iterate through millions of vector elements
- Allocate Value enum wrappers for each element (16-24 bytes each)
- Process memory allocations before transaction aborts

**Significant Protocol Violation:**

The gas metering system is a fundamental security mechanism ensuring validators are compensated for computational work. This bug allows work to be performed with insufficient compensation, violating core protocol invariants: "All operations must respect gas, storage, and computational limits."

**DoS Potential:**

Coordinated attackers can systematically exploit this by:
- Storing large vectors once (paying creation cost)
- Publishing modules with mismatched VecUnpack instructions
- Inducing users to call malicious functions with their own large vectors
- Each call amplifies work 1,000-10,000× relative to gas paid

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Ability to publish Move modules: Standard capability for any Aptos user
- Knowledge to craft bytecode: Move IR directly supports `vec_unpack_N<T>(vector)` syntax with explicit element counts
- Capital: Only transaction fees for module publishing and function calls

**Ease of Exploitation:**
- Move IR allows explicit specification: `x = vec_unpack_1<u64>(move(v))`
- Bytecode verifier cannot prevent this (validated by test evidence)
- Attackers can publish seemingly legitimate modules containing mismatched unpacks
- Vectors can be passed as arguments or loaded from storage, with unpack cost disproportionate to data transfer cost

**Practical Exploitation:**
1. Attacker publishes module with public function containing `VecUnpack(si, 1)`
2. Users call function with their own large vectors from legitimate use cases
3. Each call triggers 1,000-10,000× work amplification
4. No special timing or coordination required

## Recommendation

Modify the gas charging mechanism to account for actual vector size:

```rust
fn charge_vec_unpack(
    &mut self,
    expect_num_elements: NumArgs,
    elems: impl ExactSizeIterator<Item = impl ValueView>,
) -> PartialVMResult<()> {
    let actual_num = NumArgs::new(elems.len() as u64);
    let num_to_charge = std::cmp::max(expect_num_elements, actual_num);
    self.algebra
        .charge_execution(VEC_UNPACK_BASE + VEC_UNPACK_PER_EXPECTED_ELEM * num_to_charge)
}
```

Alternatively, perform early validation before iteration:
- Check vector length before calling `unpack_unchecked()`
- Return error immediately if mismatch detected
- Avoid O(n) work for mismatched vectors

## Proof of Concept

```move
// File: sources/exploit.move
module attacker::exploit {
    public fun process_vector(v: vector<u64>) {
        // This would be compiled with Move IR to generate:
        // VecUnpack(signature_index, 1)
        // When called with 100,000 element vector:
        // - Charges gas for 1 element
        // - Forces iteration through all 100,000 elements
        // - Aborts after work is done
    }
}

// Caller code:
script {
    fun exploit_call() {
        let large_vec = vector::empty<u64>();
        let i = 0;
        while (i < 100000) {
            vector::push_back(&mut large_vec, i);
            i = i + 1;
        };
        
        attacker::exploit::process_vector(large_vec);
        // Transaction aborts with VEC_UNPACK_PARITY_MISMATCH
        // But validators already did 100k iterations
    }
}
```

## Notes

This vulnerability is confirmed by multiple code locations showing the exact execution flow described. The work amplification is mathematically demonstrable (7,400× for 100k elements) and the bytecode verifier's inability to prevent this is evidenced by existing test files that explicitly test mismatched VecUnpack scenarios. The vulnerability breaks the fundamental gas metering invariant that computational work must be compensated proportionally.

### Citations

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L495-502)
```rust
    fn charge_vec_unpack(
        &mut self,
        expect_num_elements: NumArgs,
        _elems: impl ExactSizeIterator<Item = impl ValueView>,
    ) -> PartialVMResult<()> {
        self.algebra
            .charge_execution(VEC_UNPACK_BASE + VEC_UNPACK_PER_EXPECTED_ELEM * expect_num_elements)
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L3008-3017)
```rust
                    Instruction::VecUnpack(si, num) => {
                        let vec_val = interpreter.operand_stack.pop_as::<Vector>()?;
                        let (_, ty_count) = frame_cache.get_signature_index_type(*si, self)?;
                        gas_meter.charge_create_ty(ty_count)?;
                        gas_meter.charge_vec_unpack(NumArgs::new(*num), vec_val.elem_views())?;
                        let elements = vec_val.unpack(*num)?;
                        for value in elements {
                            interpreter.operand_stack.push(value)?;
                        }
                    },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4071-4136)
```rust
    pub fn unpack_unchecked(self) -> PartialVMResult<Vec<Value>> {
        let elements: Vec<_> = match self.0 {
            Container::VecU8(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u8)
                .collect(),
            Container::VecU16(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u16)
                .collect(),
            Container::VecU32(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u32)
                .collect(),
            Container::VecU64(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u64)
                .collect(),
            Container::VecU128(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u128)
                .collect(),
            Container::VecU256(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::u256)
                .collect(),
            Container::VecI8(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i8)
                .collect(),
            Container::VecI16(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i16)
                .collect(),
            Container::VecI32(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i32)
                .collect(),
            Container::VecI64(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i64)
                .collect(),
            Container::VecI128(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i128)
                .collect(),
            Container::VecI256(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::i256)
                .collect(),
            Container::VecBool(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::bool)
                .collect(),
            Container::VecAddress(r) => take_unique_ownership(r)?
                .into_iter()
                .map(Value::address)
                .collect(),
            Container::Vec(r) => take_unique_ownership(r)?.into_iter().collect(),
            Container::Locals(_) | Container::Struct(_) => {
                return Err(PartialVMError::new_invariant_violation(
                    "Unexpected non-vector container",
                ))
            },
        };
        Ok(elements)
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4139-4147)
```rust
    pub fn unpack(self, expected_num: u64) -> PartialVMResult<Vec<Value>> {
        let elements = self.unpack_unchecked()?;
        if expected_num as usize == elements.len() {
            Ok(elements)
        } else {
            Err(PartialVMError::new(StatusCode::VECTOR_OPERATION_ERROR)
                .with_sub_status(VEC_UNPACK_PARITY_MISMATCH))
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L164-165)
```rust
        [vec_unpack_base: InternalGas, "vec_unpack.base", 1838],
        [vec_unpack_per_expected_elem: InternalGasPerArg, "vec_unpack.per_expected_elem", 147],
```

**File:** third_party/move/move-bytecode-verifier/src/instruction_consistency.rs (L137-143)
```rust
                VecPack(_, num) | VecUnpack(_, num) => {
                    if *num > u16::MAX as u64 {
                        return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                            .at_code_offset(self.current_function(), offset as CodeOffset)
                            .with_message("VecPack/VecUnpack argument out of range".to_string()));
                    }
                },
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1243-1252)
```rust
        Bytecode::VecUnpack(idx, num) => {
            let operand_vec = safe_unwrap!(verifier.stack.pop());
            let declared_element_type = &verifier.resolver.signature_at(*idx).0[0];
            if operand_vec != ST::Vector(Box::new(declared_element_type.clone())) {
                return Err(verifier.error(StatusCode::TYPE_MISMATCH, offset));
            }
            for _ in 0..*num {
                verifier.push(meter, declared_element_type.clone())?;
            }
        },
```

**File:** third_party/move/move-bytecode-verifier/transactional-tests/tests/stack_usage_verifier/vector_ops_pack_unpack.mvir (L17-25)
```text
//# run
main() {
    let v: vector<bool>;
    let x: bool;
label b0:
    v = vec_pack_1<bool>(true);
    x = vec_unpack_2<bool>(move(v));
    return;
}
```
