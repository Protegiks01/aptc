# Audit Report

## Title
Gas Metering Bypass via UTF-8 Validation Before Charge in native_format_list

## Summary
The `native_format_list` function performs UTF-8 validation on the format string before charging gas. When validation fails, the function aborts without charging for the O(n) validation work performed, violating the documented gas charging principle and enabling attackers to execute computation without proportional gas payment.

## Finding Description

The vulnerability exists in `native_format_list` where UTF-8 validation occurs before gas charging, violating the documented principle in SafeNativeContext: [1](#0-0) 

The execution flow in `native_format_list` demonstrates the violation:

1. Arguments are popped from the stack
2. UTF-8 validation is performed using `std::str::from_utf8()` which scans all bytes - an O(n) operation
3. If validation fails, the function returns `SafeNativeError::Abort` with `abort_code: EINVALID_FORMAT`
4. Gas charging only happens AFTER validation completes successfully [2](#0-1) 

When the abort is converted to `NativeResult`, it uses `context.legacy_gas_used` which is 0 at the point of abort since line 613 hasn't executed: [3](#0-2) 

The VM interpreter then charges only this 0 gas amount for the aborted native function: [4](#0-3) 

**Comparison with Correct Implementation:**

The stdlib's `native_check_utf8` correctly charges gas BEFORE performing UTF-8 validation: [5](#0-4) 

**Attack Path:**

1. Attacker constructs a large byte vector with invalid UTF-8 (e.g., valid UTF-8 with an invalid byte near the end)
2. Calls `format1()`, `format2()`, `format3()`, or `format4()` from `aptos_std::string_utils` - all are public functions: [6](#0-5) 
3. The native function performs O(n) UTF-8 validation scanning all bytes
4. Validation fails, returning abort with 0 gas cost
5. Attacker repeats across multiple transactions, getting free O(n) computation

## Impact Explanation

This vulnerability enables a gas metering bypass that violates the fundamental security property that "all computation must be paid for." The documented gas charging principle explicitly requires charging gas before execution, yet this function violates that principle. [1](#0-0) 

While UTF-8 validation is optimized in Rust's standard library, attackers can amplify the impact by:
- Storing large invalid UTF-8 vectors once (one-time cost)  
- Repeatedly calling format functions on these vectors (minimal cost per call)
- Each call performs O(n) validation work without charging proportional gas

The practical impact is limited by transaction base costs [7](#0-6) , fast UTF-8 validation performance, and transaction rate limits.

However, this represents a protocol-level violation of documented security principles and creates inconsistency with other native functions that handle UTF-8 validation correctly.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Any unprivileged transaction sender
- **Complexity**: Trivial - single transaction calling `format1(&invalid_utf8_vector, value)`  
- **Cost**: Minimal (base transaction cost only, no gas for validation work)
- **Detection**: Indistinguishable from legitimate failed format operations
- **Scalability**: Repeatable across unlimited transactions

No special permissions, validator access, or complex setup required. The vulnerable functions are publicly accessible through the Move standard library. [6](#0-5) 

## Recommendation

Move the gas charging to occur BEFORE UTF-8 validation, following the same pattern used in `native_check_utf8`. The fix should charge gas based on the format string length before calling `std::str::from_utf8()`:

```rust
// Charge gas BEFORE validation
context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt_ref2.as_slice().len() as u64))?;

// Then perform validation
let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
    abort_code: EINVALID_FORMAT,
})?;
```

This ensures that even if validation fails, the O(n) computation work is paid for, maintaining consistency with the documented gas charging principle and other native functions.

## Proof of Concept

```move
#[test_only]
module test_addr::gas_bypass_poc {
    use std::string;
    use aptos_std::string_utils;
    
    #[test]
    public fun demonstrate_gas_bypass() {
        // Create invalid UTF-8: valid UTF-8 followed by invalid byte
        let invalid_utf8 = vector<u8>[
            72, 101, 108, 108, 111, // "Hello"
            255, // Invalid UTF-8 byte
        ];
        
        // This will perform O(n) UTF-8 validation but charge 0 gas
        // when validation fails
        string_utils::format1(&invalid_utf8, 123);
        
        // The above call should abort with EINVALID_FORMAT (code 2)
        // but without charging gas for the validation work performed
    }
}
```

## Notes

This is a valid protocol-level security vulnerability that violates documented gas charging principles. While the practical impact is mitigated by transaction base costs and fast UTF-8 validation performance, it represents a defense-in-depth violation and creates an exploitable inconsistency in the codebase. The vulnerability should be fixed to maintain consistency with security principles, even though the real-world impact on validator performance would be minimal.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L69-72)
```rust
    /// Always remember: first charge gas, then execute!
    ///
    /// In other words, this function **MUST** always be called **BEFORE** executing **any**
    /// gas-metered operation or library call within a native function.
```

**File:** aptos-move/framework/src/natives/string_utils.rs (L606-613)
```rust
    let fmt_ref = safely_pop_arg!(arguments, VectorRef);
    let fmt_ref2 = fmt_ref.as_bytes_ref();
    // Could use unsafe here, but it's forbidden in this crate.
    let fmt = std::str::from_utf8(fmt_ref2.as_slice()).map_err(|_| SafeNativeError::Abort {
        abort_code: EINVALID_FORMAT,
    })?;

    context.charge(STRING_UTILS_PER_BYTE * NumBytes::new(fmt.len() as u64))?;
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L134-136)
```rust
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1150-1152)
```rust
            NativeResult::Abort { cost, abort_code } => {
                gas_meter.charge_native_function(cost, Option::<std::iter::Empty<&Value>>::None)?;
                Err(PartialVMError::new(StatusCode::ABORTED).with_sub_status(abort_code))
```

**File:** aptos-move/framework/move-stdlib/src/natives/string.rs (L46-51)
```rust
    context.charge(
        STRING_CHECK_UTF8_BASE
            + STRING_CHECK_UTF8_PER_BYTE * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
```

**File:** aptos-move/framework/aptos-stdlib/sources/string_utils.move (L39-50)
```text
    public fun format1<T0: drop>(fmt: &vector<u8>, a: T0): String {
        native_format_list(fmt, &list1(a))
    }
    public fun format2<T0: drop, T1: drop>(fmt: &vector<u8>, a: T0, b: T1): String {
        native_format_list(fmt, &list2(a, b))
    }
    public fun format3<T0: drop, T1: drop, T2: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2): String {
        native_format_list(fmt, &list3(a, b, c))
    }
    public fun format4<T0: drop, T1: drop, T2: drop, T3: drop>(fmt: &vector<u8>, a: T0, b: T1, c: T2, d: T3): String {
        native_format_list(fmt, &list4(a, b, c, d))
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L29-36)
```rust
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
```
