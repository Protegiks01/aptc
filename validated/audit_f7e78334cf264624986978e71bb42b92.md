# Audit Report

## Title
Epoch Mismatch in BlockStore Rebuild Allows Stale Timeout Certificates to Persist

## Summary
The `BlockStore::rebuild()` function bypasses epoch filtering by rolling over the previous timeout certificate instead of using the epoch-filtered certificate from RecoveryData, creating an inconsistent BlockStore state when nodes perform fast-forward sync across epoch boundaries.

## Finding Description

This vulnerability exists in the interaction between `RecoveryData` epoch filtering and `BlockStore::rebuild()` during fast-forward synchronization.

**Step 1: RecoveryData Properly Filters by Epoch**

When RecoveryData is constructed during fast-forward sync, the timeout certificate is explicitly filtered to only retain certificates matching the current epoch. [1](#0-0) 

The epoch filtering uses the epoch from the recovery root block to ensure consistency. [2](#0-1) 

**Step 2: RecoveryData.take() Discards the Filtered TC**

The `take()` method returns only `(root, root_metadata, blocks, quorum_certs)` but NOT the epoch-filtered timeout certificate. [3](#0-2) 

Despite the filtered TC being available via `highest_2chain_timeout_certificate()` method. [4](#0-3) 

**Step 3: rebuild() Rolls Over Stale TC**

During fast-forward sync, `sync_to_highest_quorum_cert()` calls `fast_forward_sync()` which creates RecoveryData, then calls `.take()` and passes the result to `rebuild()`. [5](#0-4) 

The `rebuild()` method retrieves the OLD timeout certificate from the current BlockStore without epoch validation. [6](#0-5) 

This effectively bypasses the epoch filtering that was done in RecoveryData.

**Step 4: Usage Path and Verification**

The stale timeout certificate is passed to SafetyRules during timeout signing. [7](#0-6) 

SafetyRules verifies the timeout certificate against the epoch state's validator verifier. [8](#0-7) 

The `verify_tc()` implementation validates signatures using the epoch state's validator verifier. [9](#0-8) 

The TwoChainTimeoutCertificate verification validates aggregate signatures against the provided validator verifier. [10](#0-9) 

## Impact Explanation

This is a **Medium-High Severity** issue:

1. **State Inconsistency**: The BlockStore operates with blocks from a new epoch but a timeout certificate from a previous epoch, violating the design intent where RecoveryData explicitly performs epoch filtering.

2. **Potential Consensus Participation Issues**: During the window between rebuild completion and epoch transition, the node may encounter verification failures when attempting to sign timeouts or votes if SafetyRules' epoch state has been updated independently.

3. **Automatic Recovery Exists**: Contrary to requiring manual intervention, the system has automatic recovery via epoch change notification sent after rebuild. [11](#0-10) 

The vulnerability window is limited to the time between BlockStore rebuild and epoch transition completion.

## Likelihood Explanation

The likelihood is **Medium**:

**Triggering Conditions:**
- Node falls behind and performs fast-forward sync (common operational scenario)
- Sync crosses an epoch boundary where validator sets have changed (regular occurrence)
- Timing window exists where node operates with inconsistent state

**Realistic Scenario:**
Fast-forward sync can cross epoch boundaries as evidenced by the epoch change broadcast logic. [11](#0-10) 

**Mitigating Factors:**
- Epoch transition creates fresh BlockStores that resolve the inconsistency
- The vulnerability window duration is limited
- Automatic recovery mechanism exists

## Recommendation

Modify `BlockStore::rebuild()` to use the epoch-filtered timeout certificate from RecoveryData instead of rolling over the old one:

```rust
pub async fn rebuild(
    &self,
    root: RootInfo,
    root_metadata: RootMetadata,
    blocks: Vec<Block>,
    quorum_certs: Vec<QuorumCert>,
    highest_2chain_tc: Option<TwoChainTimeoutCertificate>, // Add this parameter
) {
    // Use the provided TC instead of rolling over
    let prev_2chain_htc = highest_2chain_tc.map(Arc::new);
    // ... rest of implementation
}
```

Update the call site in `sync_manager.rs` to pass the filtered TC:

```rust
let recovery_data = Self::fast_forward_sync(...).await?;
let highest_tc = recovery_data.highest_2chain_timeout_certificate();
let (root, root_metadata, blocks, quorum_certs) = recovery_data.take();
self.rebuild(root, root_metadata, blocks, quorum_certs, highest_tc).await;
```

## Proof of Concept

The vulnerability can be demonstrated through code inspection showing the bypass of epoch filtering. A full reproduction would require:

1. Set up a node in epoch N with a timeout certificate
2. Cause the node to fall behind
3. Trigger fast-forward sync that crosses to epoch N+1 with different validator set
4. Observe that `rebuild()` uses the epoch N timeout certificate despite RecoveryData filtering it out
5. Monitor for potential verification issues during the window before epoch transition completes

The code paths are clearly established through the citations provided, demonstrating that the epoch filtering designed in RecoveryData is systematically bypassed during the rebuild process.

## Notes

While this represents a genuine code bug that creates state inconsistency and violates design intent, the actual operational impact may be more limited than initially assessed due to:
- Automatic recovery via epoch change mechanism
- Limited vulnerability window duration
- Timing dependencies for actual verification failures

The core issue remains valid: the system explicitly filters timeout certificates by epoch in RecoveryData, but this filtering is bypassed in the rebuild path, creating potential for consensus participation issues during fast-forward sync across epoch boundaries.

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L386-397)
```rust
        let (root_id, epoch) = match &root.window_root_block {
            None => {
                let commit_root_id = root.commit_root_block.id();
                let epoch = root.commit_root_block.epoch();
                (commit_root_id, epoch)
            },
            Some(window_root_block) => {
                let window_start_id = window_root_block.id();
                let epoch = window_root_block.epoch();
                (window_start_id, epoch)
            },
        };
```

**File:** consensus/src/persistent_liveness_storage.rs (L414-417)
```rust
            highest_2chain_timeout_certificate: match highest_2chain_timeout_cert {
                Some(tc) if tc.epoch() == epoch => Some(tc),
                _ => None,
            },
```

**File:** consensus/src/persistent_liveness_storage.rs (L429-436)
```rust
    pub fn take(self) -> (RootInfo, RootMetadata, Vec<Block>, Vec<QuorumCert>) {
        (
            self.root,
            self.root_metadata,
            self.blocks,
            self.quorum_certs,
        )
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L444-446)
```rust
    pub fn highest_2chain_timeout_certificate(&self) -> Option<TwoChainTimeoutCertificate> {
        self.highest_2chain_timeout_certificate.clone()
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L295-314)
```rust
        let (root, root_metadata, blocks, quorum_certs) = Self::fast_forward_sync(
            &highest_quorum_cert,
            &highest_commit_cert,
            retriever,
            self.storage.clone(),
            self.execution_client.clone(),
            self.payload_manager.clone(),
            self.order_vote_enabled,
            self.window_size,
            Some(self),
        )
        .await?
        .take();
        info!(
            LogSchema::new(LogEvent::CommitViaSync).round(self.ordered_root().round()),
            committed_round = root.commit_root_block.round(),
            block_id = root.commit_root_block.id(),
        );
        self.rebuild(root, root_metadata, blocks, quorum_certs)
            .await;
```

**File:** consensus/src/block_storage/sync_manager.rs (L316-324)
```rust
        if highest_commit_cert.ledger_info().ledger_info().ends_epoch() {
            retriever
                .network
                .send_epoch_change(EpochChangeProof::new(
                    vec![highest_quorum_cert.ledger_info().clone()],
                    /* more = */ false,
                ))
                .await;
        }
```

**File:** consensus/src/block_storage/block_store.rs (L371-373)
```rust
        let prev_2chain_htc = self
            .highest_2chain_timeout_cert()
            .map(|tc| tc.as_ref().clone());
```

**File:** consensus/src/round_manager.rs (L1014-1021)
```rust
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L32-34)
```rust
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```
