# Audit Report

## Title
Reconfiguration Bypass via Missing Parent Block Validation in Optimistic Proposals

## Summary
The `verify_well_formed()` function in `OptBlockData` only validates that the grandparent block does not have a reconfiguration, but fails to check if the parent block has a reconfiguration. This allows validators to propose optimistic blocks immediately after a reconfiguration block, violating epoch transition invariants and reconfiguration suffix rules.

## Finding Description

The Aptos consensus protocol enforces strict reconfiguration suffix rules to ensure safe epoch transitions. After a block with reconfiguration (`next_epoch_state` set), subsequent blocks must have empty payloads and the same timestamp as the reconfiguration block until it's committed. [1](#0-0) [2](#0-1) 

However, optimistic proposals bypass these critical safety checks. The vulnerability exists in `OptBlockData::verify_well_formed()`: [3](#0-2) 

This function only checks if the **grandparent** has reconfiguration (line 94-97), but never validates if the **parent** has reconfiguration.

**Attack Flow:**

1. When a validator votes on Block B (round r) that has reconfiguration, `process_verified_proposal()` calls `start_next_opt_round()`: [4](#0-3) 

2. The parent BlockInfo is extracted from the vote, which could have `next_epoch_state` set: [5](#0-4) [6](#0-5) 

3. The proposal generator's reconfiguration check only examines the HQC (highest quorum cert), which is the grandparent: [7](#0-6) 

4. The optimistic block is created with normal payload and strictly increasing timestamp (line 725-734), with no check on the parent's reconfiguration status.

5. When converted to a regular Block via `Block::new_from_opt()`, the critical `Block::verify_well_formed()` checks are never executed: [8](#0-7) [9](#0-8) 

For comparison, regular proposals properly enforce reconfiguration suffix rules by generating empty blocks with parent timestamps: [10](#0-9) 

## Impact Explanation

**Severity: High**

This vulnerability violates critical protocol invariants designed to ensure safe epoch transitions:

1. **Reconfiguration Suffix Rule Violation**: Optimistic blocks after reconfiguration can carry non-empty payloads and different timestamps, violating the documented safety mechanism that prevents transaction execution during epoch transitions.

2. **Execution Semantics Inconsistency**: The block won't be correctly identified as a reconfiguration suffix during execution, causing incorrect behavior: [11](#0-10) 

This leads to subscribable events being emitted when they shouldn't be. A properly formed reconfiguration suffix block should have `has_reconfiguration() && compute_status_for_input_txns().is_empty()`, returning an empty vector from `subscribable_events()`. However, an optimistic block with transactions will fail this check and incorrectly emit events.

3. **Epoch Transition Safety**: The reconfiguration suffix rules exist to ensure proper epoch transitions. Bypassing them could cause epoch state confusion and incorrect validator set handling.

4. **Protocol Invariant Violation**: The vulnerability allows blocks that violate documented consensus safety rules, creating potential for future consensus issues when these invariants are assumed to hold.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability triggers automatically during normal epoch transitions when:
- A reconfiguration block is proposed (happens at every epoch change)
- The validator voting on it is the next round proposer (probability 1/N where N is validator count)
- Optimistic proposals are enabled (`enable_optimistic_proposal_tx = true`) [12](#0-11) 

No special manipulation is required. The validator follows normal protocol behavior, and the bug is purely in the insufficient validation logic. There are no existing tests covering this scenario, and the code has no protections against this case.

## Recommendation

Add a parent block reconfiguration check in `OptBlockData::verify_well_formed()`:

```rust
pub fn verify_well_formed(&self) -> anyhow::Result<()> {
    let parent = self.parent();
    let grandparent_qc = self.grandparent_qc().certified_block();
    
    // ... existing checks ...
    
    ensure!(
        !grandparent_qc.has_reconfiguration(),
        "Optimistic proposals are disallowed after the reconfiguration block"
    );
    
    // ADD THIS CHECK:
    ensure!(
        !parent.has_reconfiguration(),
        "Optimistic proposals are disallowed when parent has reconfiguration"
    );
    
    // ... rest of validation ...
}
```

Additionally, add validation in the proposal generator's `generate_opt_proposal()` to check the parent BlockInfo before creating the optimistic block.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a validator network with optimistic proposals enabled
2. Triggering an epoch transition by having a reconfiguration block proposed and voted on
3. Observing that if the next round proposer votes on the reconfiguration block, they will generate an optimistic proposal with:
   - Non-empty payload (normal transactions)
   - Strictly increasing timestamp
   - Parent block having `next_epoch_state` set
4. This optimistic block will pass validation but violate reconfiguration suffix rules

The vulnerability is in production code, enabled by default, and triggers automatically during normal epoch transitions with probability 1/N per epoch where N is the validator count.

### Citations

**File:** consensus/consensus-types/src/block.rs (L410-417)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L483-488)
```rust
        if parent.has_reconfiguration() {
            ensure!(
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }
```

**File:** consensus/consensus-types/src/block.rs (L521-525)
```rust
        if self.is_nil_block() || parent.has_reconfiguration() {
            ensure!(
                self.timestamp_usecs() == parent.timestamp_usecs(),
                "Nil/reconfig suffix block must have same timestamp as parent"
            );
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L75-116)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        let parent = self.parent();
        let grandparent_qc = self.grandparent_qc().certified_block();
        ensure!(
            grandparent_qc.round() + 1 == parent.round(),
            "Block's parent's round {} must be one more than grandparent's round {}",
            parent.round(),
            grandparent_qc.round(),
        );
        ensure!(
            parent.round() + 1 == self.round(),
            "Block's round {} must be one more than parent's round {}",
            self.round(),
            parent.round(),
        );
        ensure!(
            grandparent_qc.epoch() == self.epoch() && parent.epoch() == self.epoch(),
            "Block's parent and grantparent should be in the same epoch"
        );
        ensure!(
            !grandparent_qc.has_reconfiguration(),
            "Optimistic proposals are disallowed after the reconfiguration block"
        );

        self.payload().verify_epoch(self.epoch())?;

        ensure!(
            self.timestamp_usecs() > parent.timestamp_usecs()
                && parent.timestamp_usecs() > grandparent_qc.timestamp_usecs(),
            "Blocks must have strictly increasing timestamps"
        );

        let current_ts = duration_since_epoch();

        // we can say that too far is 5 minutes in the future
        const TIMEBOUND: u64 = 300_000_000;
        ensure!(
            self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
            "Blocks must not be too far in the future"
        );
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1382-1424)
```rust
    pub async fn process_verified_proposal(&mut self, proposal: Block) -> anyhow::Result<()> {
        let proposal_round = proposal.round();
        let parent_qc = proposal.quorum_cert().clone();
        let sync_info = self.block_store.sync_info();

        if proposal_round <= sync_info.highest_round() {
            sample!(
                SampleRate::Duration(Duration::from_secs(1)),
                warn!(
                    sync_info = sync_info,
                    proposal = proposal,
                    "Ignoring proposal. SyncInfo round is higher than proposal round."
                )
            );
            return Ok(());
        }

        let vote = self.create_vote(proposal).await?;
        self.round_state.record_vote(vote.clone());
        let vote_msg = VoteMsg::new(vote.clone(), self.block_store.sync_info());

        self.broadcast_fast_shares(vote.ledger_info().commit_info())
            .await;

        if self.local_config.broadcast_vote {
            info!(self.new_log(LogEvent::Vote), "{}", vote);
            PROPOSAL_VOTE_BROADCASTED.inc();
            self.network.broadcast_vote(vote_msg).await;
        } else {
            let recipient = self
                .proposer_election
                .get_valid_proposer(proposal_round + 1);
            info!(
                self.new_log(LogEvent::Vote).remote_peer(recipient),
                "{}", vote
            );
            self.network.send_vote(vote_msg, vec![recipient]).await;
        }

        if let Err(e) = self.start_next_opt_round(vote, parent_qc) {
            debug!("Cannot start next opt round: {}", e);
        };
        Ok(())
```

**File:** consensus/src/round_manager.rs (L1427-1449)
```rust
    fn start_next_opt_round(
        &self,
        parent_vote: Vote,
        grandparent_qc: QuorumCert,
    ) -> anyhow::Result<()> {
        // Optimistic Proposal:
        // When receiving round r block, send optimistic proposal for round r+1 if:
        // 0. opt proposal is enabled
        // 1. it is the leader of the next round r+1
        // 2. voted for round r block
        // 3. the round r block contains QC of round r-1
        // 4. does not propose in round r+1
        if !self.local_config.enable_optimistic_proposal_tx {
            return Ok(());
        };

        ensure!(
            !self.proposal_generator.is_proposal_under_backpressure(),
            "Cannot start next opt round due to backpressure"
        );

        let parent = parent_vote.vote_data().proposed().clone();
        let opt_proposal_round = parent.round() + 1;
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L500-556)
```rust
    ) -> anyhow::Result<BlockData> {
        let maybe_optqs_payload_pull_params = self.opt_qs_payload_param_provider.get_params();

        let hqc = self.ensure_highest_quorum_cert(round)?;

        let (validator_txns, payload, timestamp) = if hqc.certified_block().has_reconfiguration() {
            // Reconfiguration rule - we propose empty blocks with parents' timestamp
            // after reconfiguration until it's committed
            (
                vec![],
                Payload::empty(
                    self.quorum_store_enabled,
                    self.allow_batches_without_pos_in_proposal,
                ),
                hqc.certified_block().timestamp_usecs(),
            )
        } else {
            self.generate_proposal_inner(
                round,
                hqc.certified_block().id(),
                proposer_election.clone(),
                maybe_optqs_payload_pull_params,
            )
            .await?
        };

        let quorum_cert = hqc.as_ref().clone();
        let failed_authors = self.compute_failed_authors(
            round,
            quorum_cert.certified_block().round(),
            false,
            proposer_election,
        );

        let block = if self.vtxn_config.enabled() {
            BlockData::new_proposal_ext(
                validator_txns,
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        } else {
            BlockData::new_proposal(
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
        };

        Ok(block)
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L694-737)
```rust
        proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    ) -> anyhow::Result<OptBlockData> {
        let maybe_optqs_payload_pull_params = self.opt_qs_payload_param_provider.get_params();

        let hqc = self.ensure_highest_quorum_cert(round)?;

        ensure!(
            hqc.certified_block().round() + 2 == round,
            "[OptProposal] Given round {} is not equal to hqc round {} + 2, should generate regular proposal instead of optimistic",
            round,
            hqc.certified_block().round()
        );

        let (validator_txns, payload, timestamp) = if hqc.certified_block().has_reconfiguration() {
            bail!("[OptProposal] HQC has reconfiguration!");
        } else {
            self.generate_proposal_inner(
                round,
                parent.id(),
                proposer_election,
                maybe_optqs_payload_pull_params,
            )
            .await?
        };

        let validator_txns = if self.vtxn_config.enabled() {
            validator_txns
        } else {
            vec![]
        };

        let block = OptBlockData::new(
            validator_txns,
            payload,
            self.author,
            epoch,
            round,
            timestamp,
            parent,
            grandparent_qc,
        );

        Ok(block)
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L402-419)
```rust
    /// Returns an instance of BlockData by converting the OptBlockData to BlockData
    /// and adding QC and failed_authors
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let OptBlockData {
            epoch,
            round,
            timestamp_usecs,
            block_body: proposal_body,
            ..
        } = opt_block_data;
        Self {
            epoch,
            round,
            timestamp_usecs,
            quorum_cert,
            block_type: BlockType::OptimisticProposal(proposal_body),
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L475-491)
```rust
    pub fn subscribable_events(&self) -> Vec<ContractEvent> {
        // reconfiguration suffix don't count, the state compute result is carried over from parents
        if self.is_reconfiguration_suffix() {
            return vec![];
        }
        self.compute_result().subscribable_events().to_vec()
    }

    /// The block is suffix of a reconfiguration block if the state result carries over the epoch state
    /// from parent but has no transaction.
    pub fn is_reconfiguration_suffix(&self) -> bool {
        let state_compute_result = self.compute_result();
        state_compute_result.has_reconfiguration()
            && state_compute_result
                .compute_status_for_input_txns()
                .is_empty()
    }
```

**File:** config/src/config/consensus_config.rs (L375-386)
```rust
                backoff_policy_factor: 100,
                backoff_policy_max_delay_ms: 10000,
                rpc_timeout_ms: 10000,
            },
            num_bounded_executor_tasks: 16,
            enable_pre_commit: true,
            max_pending_rounds_in_commit_vote_cache: 100,
            optimistic_sig_verification: true,
            enable_round_timeout_msg: true,
            enable_optimistic_proposal_rx: true,
            enable_optimistic_proposal_tx: true,
        }
```
