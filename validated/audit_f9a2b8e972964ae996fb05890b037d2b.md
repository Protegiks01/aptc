# Audit Report

## Title
TOCTOU Race Condition and Missing Gas Limit Verification Enable Execution Divergence in Consensus Observers

## Summary
A Time-Of-Check-Time-Of-Use (TOCTOU) race condition in consensus observer payload processing, combined with missing gas limit verification, allows different observers to store and execute blocks with different gas limits for the same consensus-agreed block, causing state divergence.

## Finding Description

This vulnerability consists of two components that combine to enable execution divergence:

**Component 1: TOCTOU Race Condition**

The consensus observer's `process_block_payload_message` performs a non-atomic check-then-insert pattern. The existence check acquires and releases the lock: [1](#0-0) 

Then later, the insertion acquires the lock again: [2](#0-1) 

The underlying `insert_block_payload` uses `BTreeMap::insert()` which overwrites existing entries: [3](#0-2) 

This creates a race window where two concurrent BlockPayload messages for the same `(epoch, round)` can both pass the existence check, with the last insert overwriting the first.

**Component 2: Missing Gas Limit Verification**

The `verify_against_ordered_payload` method verifies transaction limits but explicitly does NOT verify gas limits: [4](#0-3) 

Note the TODO comment on line 697 indicating gas limit verification is not implemented.

**Component 3: Unsigned Gas Limit Field**

The `verify_payload_signatures` method only verifies ProofOfStore signatures, not the gas_limit field: [5](#0-4) 

The gas_limit is stored as a plain field in BlockTransactionPayload, not cryptographically bound to any signatures. This allows a Byzantine publisher to craft a BlockPayload message with arbitrary gas_limit values that will pass signature verification.

**Component 4: Gas Limit Used in Execution**

The stored gas_limit is returned during block execution: [6](#0-5) 

**Attack Scenario:**

1. Consensus observer O subscribes to both honest publisher P2 and Byzantine publisher P1 (observers commonly subscribe to multiple publishers for redundancy)
2. P1 sends BlockPayload for `(epoch 100, round 50)` with `gas_limit = 500,000` 
3. P2 sends BlockPayload for the same block with `gas_limit = 1,000,000` (correct value from consensus)
4. Both messages pass `verify_payload_digests()` and `verify_payload_signatures()` (signatures don't cover gas_limit)
5. Due to the TOCTOU race, both pass the existence check concurrently
6. Whichever insert completes last wins - observer O stores P1's malicious `gas_limit = 500,000`
7. Observer O2 (subscribed only to P2) stores `gas_limit = 1,000,000`
8. Both observers receive the same OrderedBlock
9. `verify_payloads_against_ordered_block` passes for both because gas limits aren't verified: [7](#0-6) 

10. Execution proceeds with different gas limits, producing different state roots

## Impact Explanation

**Severity Assessment: High (State Divergence Among Fullnodes)**

This vulnerability allows a single Byzantine validator (< 1/3 threshold) acting as a publisher to cause consensus observers to compute different state roots for the same consensus-agreed block. While this affects fullnode observers rather than validator consensus directly, it breaks the fundamental blockchain guarantee that all nodes executing identical blocks should produce identical state.

The impact includes:
- **Fullnode State Divergence**: Observers compute different state roots for the same block
- **Data Integrity Violation**: Light clients and applications relying on different fullnodes receive inconsistent data
- **State Sync Failures**: Diverged observers cannot sync with each other
- **Trust Model Breakdown**: Destroys the ability of fullnodes to independently verify chain state

Per Aptos bug bounty criteria, this qualifies as High severity due to state inconsistencies requiring manual intervention to reconcile diverged observers.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

1. **Single Byzantine Validator**: Only requires one malicious validator (< 1/3), well within BFT tolerance
2. **Multiple Subscriptions**: Observers subscribe to multiple publishers for redundancy by design, as evidenced by the `max_concurrent_subscriptions` configuration
3. **Concurrent Processing**: Async message handling creates genuine race conditions in production
4. **No Verification**: Missing gas limit verification (line 697 TODO) is a persistent weakness
5. **Unsigned Field**: Gas limits are not cryptographically protected

The race window is real and exploitable when network conditions cause near-simultaneous message delivery from multiple publishers to the same observer.

## Recommendation

**Fix 1: Make Payload Insertion Atomic**
```rust
// In consensus_observer.rs, process_block_payload_message:
let mut observer_block_data = self.observer_block_data.lock();
if observer_block_data.existing_payload_entry(&block_payload) {
    return; // Already exists, drop
}
// Insert while still holding the lock
observer_block_data.insert_block_payload(block_payload, verified_payload);
drop(observer_block_data);
```

**Fix 2: Verify Gas Limit in verify_against_ordered_payload**
```rust
// In observer_message.rs, add gas limit verification:
Payload::QuorumStoreInlineHybridV2(
    inline_batches,
    proof_with_data,
    execution_limits,
) => {
    self.verify_batches(&proof_with_data.proofs)?;
    self.verify_inline_batches(inline_batches)?;
    self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;
    self.verify_gas_limit(execution_limits.block_gas_limit())?; // ADD THIS
}
```

**Fix 3: Reject Duplicate Payloads**
Consider rejecting subsequent payloads for the same `(epoch, round)` rather than overwriting, and log warnings for investigation.

## Proof of Concept

A complete PoC would require setting up a consensus observer with multiple publisher subscriptions and triggering concurrent message delivery. The key components demonstrated in the codebase are:

1. TOCTOU race window exists between lines 370-373 and 428-430
2. Gas limit verification is missing (line 697 TODO comment)
3. Gas limit is returned for execution without verification

The vulnerability is confirmed by code analysis of the actual implementation paths.

## Notes

- This affects consensus **observers** (fullnodes), not validator consensus directly
- Validators using AptosBFT consensus are not directly affected
- The severity is High rather than Critical because it doesn't break validator consensus safety, but it does break fullnode data integrity
- The TODO comment on line 697 suggests developers are aware gas limit verification is missing but haven't implemented it
- The TOCTOU race could be triggered in production environments with multiple publisher subscriptions and concurrent message processing

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L370-373)
```rust
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L428-430)
```rust
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L106-108)
```rust
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L199-199)
```rust
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L695-697)
```rust
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L962-981)
```rust
    pub fn verify_payload_signatures(&self, epoch_state: &EpochState) -> Result<(), Error> {
        // Create a dummy proof cache to verify the proofs
        let proof_cache = ProofCache::new(1);

        // Verify each of the proof signatures (in parallel)
        let payload_proofs = self.transaction_payload.payload_proofs();
        let validator_verifier = &epoch_state.verifier;
        payload_proofs
            .par_iter()
            .with_min_len(2)
            .try_for_each(|proof| proof.verify(validator_verifier, &proof_cache))
            .map_err(|error| {
                Error::InvalidMessageError(format!(
                    "Failed to verify the payload proof signatures! Error: {:?}",
                    error
                ))
            })?;

        Ok(()) // All proofs are correctly signed
    }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L71-75)
```rust
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
```
