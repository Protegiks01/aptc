# Audit Report

## Title
Duplicate Account Creation Vulnerability in Sharded Block Executor Due to Missing Write Hints

## Summary
The sharded block executor contains a logic vulnerability where the `rw_set_for_create_account` function returns empty write hints, causing the partitioner to fail in detecting write conflicts between account creation transactions. This allows multiple shards to create the same account in parallel, violating state consistency invariants and causing event duplication.

## Finding Description

**Root Cause - Missing Write Hints:**

The `rw_set_for_create_account` function returns empty write hints when it should include the account resource location being created: [1](#0-0) 

In contrast, `rw_set_for_coin_transfer` correctly includes the receiver's account resource in write hints when the receiver doesn't exist: [2](#0-1) 

**Partitioning Failure:**

The partitioner's initialization builds `write_sets` directly from transaction `write_hints`: [3](#0-2) 

With empty write hints, the partitioner cannot detect write conflicts. The conflict detection logic checks for writes in ranges: [4](#0-3) 

However, since write_sets are empty for create_account transactions, the `has_write_in_range` check returns false, allowing conflicting transactions to be assigned to different shards in the same round.

**Missing Cross-Shard Communication:**

During execution, `CrossShardCommitSender` only sends write updates for state keys that exist in `dependent_edges`, which are computed from write hints during partitioning: [5](#0-4) 

At line 115, the check returns `None` for the account resource since it wasn't in write hints, preventing cross-shard communication of the account creation.

**Insufficient Move-Level Protection:**

The Move code includes an existence check to prevent duplicate account creation: [6](#0-5) 

However, this check executes independently on each shard with isolated state views. Without cross-shard updates, both shards see the account as non-existent and proceed with creation.

**No Post-Execution Validation:**

The result aggregation concatenates outputs from all shards without validating for conflicting writes: [7](#0-6) 

When duplicate account creations are applied, the last write wins due to HashMap::insert behavior, but both transactions succeed and emit events.

## Impact Explanation

This vulnerability meets **HIGH** severity criteria:

1. **State Consistency Violation**: The protocol invariant that each address has exactly one Account resource is maintained in state (last-write-wins), but the event stream shows duplicate account creations. This creates an inconsistency between state and events.

2. **Event Stream Corruption**: Multiple account creation events for the same address break event stream consistency, causing indexers and applications relying on events to receive incorrect data.

3. **Protocol Invariant Violation**: The execution layer fails to maintain the expected behavior that duplicate account creation attempts should fail. Both transactions succeed when the second should abort with `EACCOUNT_ALREADY_EXISTS`.

4. **Deterministic but Incorrect**: While this is deterministic (all validators with sharded execution reach the same state), the behavior violates protocol semantics and requires manual intervention to correct downstream systems.

The vulnerability is exploitable through the public entry function: [8](#0-7) 

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH** (conditional on deployment)

1. **Easy to Trigger**: Any user can submit `aptos_account::create_account` transactions through standard APIs. No special privileges required.

2. **Natural Occurrence**: Multiple users might attempt to create the same predetermined or vanity address simultaneously.

3. **No Detection Mechanism**: The system has no runtime validation to detect or prevent this vulnerability.

4. **Deployment-Dependent**: The vulnerability only manifests if sharded execution is enabled via the `num_executor_shards` configuration parameter.

## Recommendation

Modify `rw_set_for_create_account` to include the receiver's account resource in write hints:

```rust
pub fn rw_set_for_create_account(
    sender_address: AccountAddress,
    receiver_address: AccountAddress,
) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
    let read_hints = vec![
        account_resource_location(sender_address),
        coin_store_location(sender_address),
        account_resource_location(receiver_address),
        coin_store_location(receiver_address),
    ];
    let write_hints = vec![
        account_resource_location(receiver_address),
        coin_store_location(receiver_address),
    ];
    (read_hints, write_hints)
}
```

This ensures the partitioner correctly identifies write conflicts and establishes proper cross-shard dependencies.

## Proof of Concept

A PoC would require:
1. Enabling sharded execution with `num_executor_shards > 1`
2. Submitting two transactions: `aptos_account::create_account(0xABC)` from different senders
3. Observing both transactions succeed with duplicate account creation events
4. Verifying final state contains only one Account resource but two creation events

The vulnerability is confirmed through code analysis showing the complete execution path where empty write hints lead to missed conflict detection and parallel execution without cross-shard coordination.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L207-211)
```rust
    if !receiver_exists {
        // If the receiver doesn't exist, we create the receiver account, so we need to write the
        // receiver account resource.
        write_hints.push(account_resource_location(receiver_address));
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L223-234)
```rust
pub fn rw_set_for_create_account(
    sender_address: AccountAddress,
    receiver_address: AccountAddress,
) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
    let read_hints = vec![
        account_resource_location(sender_address),
        coin_store_location(sender_address),
        account_resource_location(receiver_address),
        coin_store_location(receiver_address),
    ];
    (vec![], read_hints)
}
```

**File:** execution/block-partitioner/src/v2/init.rs (L28-38)
```rust
                    let reads = txn.read_hints.iter().map(|loc| (loc, false));
                    let writes = txn.write_hints.iter().map(|loc| (loc, true));
                    reads
                        .chain(writes)
                        .for_each(|(storage_location, is_write)| {
                            let key_idx = state.add_key(storage_location.state_key());
                            if is_write {
                                state.write_sets[ori_txn_idx]
                                    .write()
                                    .unwrap()
                                    .insert(key_idx);
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L119-126)
```rust
                        let write_set = state.write_sets[ori_txn_idx].read().unwrap();
                        let read_set = state.read_sets[ori_txn_idx].read().unwrap();
                        for &key_idx in write_set.iter().chain(read_set.iter()) {
                            if state.key_owned_by_another_shard(shard_id, key_idx) {
                                in_round_conflict_detected = true;
                                break;
                            }
                        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L289-302)
```text
    public(friend) fun create_account(new_address: address): signer {
        // there cannot be an Account resource under new_addr already.
        assert!(!exists<Account>(new_address), error::already_exists(EACCOUNT_ALREADY_EXISTS));
        // NOTE: @core_resources gets created via a `create_account` call, so we do not include it below.
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        if (features::is_default_account_resource_enabled()) {
            create_signer(new_address)
        } else {
            create_account_unchecked(new_address)
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L99-113)
```rust
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }

        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }

        // Lastly append the global output
        aggregated_results.extend(global_output);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L56-59)
```text
    public entry fun create_account(auth_key: address) {
        let account_signer = account::create_account(auth_key);
        register_apt(&account_signer);
    }
```
