# Audit Report

## Title
Peer Health Tracking Bypass via Index Validation Gap in State Values Requests

## Summary
The `validate_request` function in the storage service moderator incorrectly classifies certain invalid `GetStateValuesWithProof` requests as valid, allowing malicious peers to bypass peer health tracking. Invalid index ranges pass validation but fail during processing, without incrementing the peer's `invalid_request_count`, enabling unlimited invalid requests.

## Finding Description
The storage service implements a peer health tracking mechanism where invalid requests increment an `invalid_request_count`, and after exceeding a threshold, public network peers are temporarily ignored. [1](#0-0) 

Validation occurs in `RequestModerator::validate_request`, which calls `StorageServerSummary::can_service` to check if a request can be satisfied: [2](#0-1) 

For `GetStateValuesWithProof` requests, the `can_service` method only validates the version, not the index range: [3](#0-2) 

Unlike transaction-related requests which validate ranges using `CompleteDataRange::new()`: [4](#0-3) 

The state values validation does NOT check if `end_index >= start_index` or if `end_index == u64::MAX`. These validations only occur during processing when `inclusive_range_len` is called: [5](#0-4) 

However, this error occurs AFTER validation has passed, so `invalid_request_count` was never incremented. The error is caught in the handler: [6](#0-5) 

But only increments a generic metrics counter, not the peer-specific counter: [7](#0-6) 

**Attack Path:**
1. Malicious peer sends `GetStateValuesWithProof` with valid `version` but `end_index < start_index`
2. Request passes `can_service` validation (only checks version)
3. `invalid_request_count` is NOT incremented
4. Processing calls `inclusive_range_len` which returns `Error::InvalidRequest`
5. Error is returned to peer, but peer remains unpunished
6. Peer repeats attack indefinitely

## Impact Explanation
This vulnerability bypasses the peer health tracking mechanism, allowing malicious public network peers to send unlimited invalid requests without being temporarily ignored. While each request fails quickly without database queries, this represents a protocol security violation where a protection mechanism designed to defend against misbehaving peers can be completely bypassed.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability is trivial to exploit:
- Any peer can send storage service requests (no special permissions required)
- Attack is deterministic and reliable
- Request structure is defined and documented: [8](#0-7) 
- No timing or race conditions involved
- Works on all nodes running the affected code

## Recommendation
Add index range validation to the `can_service` method for `GetStateValuesWithProof` requests, similar to transaction-related requests. Modify the validation logic to use `CompleteDataRange::new()` or add explicit checks:

```rust
GetStateValuesWithProof(request) => {
    let proof_version = request.version;
    
    // Add index range validation
    let index_range = match CompleteDataRange::new(request.start_index, request.end_index) {
        Ok(range) => range,
        Err(_) => return false,
    };
    
    let can_serve_states = self
        .states
        .map(|range| range.contains(request.version))
        .unwrap_or(false);

    let can_create_proof = self
        .synced_ledger_info
        .as_ref()
        .map(|li| li.ledger_info().version() >= proof_version)
        .unwrap_or(false);

    can_serve_states && can_create_proof
}
```

## Proof of Concept
A Rust test demonstrating the bypass:

```rust
#[tokio::test]
async fn test_invalid_index_range_bypasses_tracking() {
    let (storage_service, mock_storage, _) = setup_test_storage_service();
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Create request with invalid index range (end < start)
    let request = StorageServiceRequest {
        data_request: DataRequest::GetStateValuesWithProof(
            StateValuesWithProofRequest {
                version: 100,
                start_index: 100,
                end_index: 50,  // Invalid: less than start_index
            }
        ),
        use_compression: false,
    };
    
    // Send request multiple times (should trigger ignore after max_invalid_requests)
    for _ in 0..10 {
        let response = storage_service.process_request(&peer_network_id, request.clone(), false);
        assert!(response.is_err());  // Request fails
    }
    
    // Check that peer was NOT marked as ignored (bug!)
    let unhealthy_states = storage_service.get_moderator().get_unhealthy_peer_states();
    if let Some(state) = unhealthy_states.get(&peer_network_id) {
        // Peer should be ignored after many invalid requests, but isn't
        assert!(!state.is_ignored());  // Demonstrates the bypass
    }
}
```

**Notes:**
- The vulnerability is confirmed through code analysis showing the validation gap between `GetStateValuesWithProof` and transaction-related requests
- Only public network peers are affected by the ignore mechanism (validators/VFNs are never ignored regardless of invalid request count)
- Each invalid request consumes minimal resources as it fails before database access
- The primary security concern is the bypass of the peer health tracking mechanism, not resource exhaustion

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L134-185)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }
```

**File:** state-sync/storage-service/types/src/responses.rs (L727-742)
```rust
            GetStateValuesWithProof(request) => {
                let proof_version = request.version;

                let can_serve_states = self
                    .states
                    .map(|range| range.contains(request.version))
                    .unwrap_or(false);

                let can_create_proof = self
                    .synced_ledger_info
                    .as_ref()
                    .map(|li| li.ledger_info().version() >= proof_version)
                    .unwrap_or(false);

                can_serve_states && can_create_proof
            },
```

**File:** state-sync/storage-service/types/src/responses.rs (L833-847)
```rust
    fn can_service_transaction_outputs_with_proof(
        &self,
        start_version: u64,
        end_version: u64,
        proof_version: u64,
    ) -> bool {
        let desired_range = match CompleteDataRange::new(start_version, end_version) {
            Ok(desired_range) => desired_range,
            Err(_) => return false,
        };

        let can_service_outputs = self.can_service_transaction_outputs(&desired_range);
        let can_create_proof = self.can_create_proof(proof_version);
        can_service_outputs && can_create_proof
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1485-1494)
```rust
fn inclusive_range_len(start: u64, end: u64) -> aptos_storage_service_types::Result<u64, Error> {
    // len = end - start + 1
    let len = end.checked_sub(start).ok_or_else(|| {
        Error::InvalidRequest(format!("end ({}) must be >= start ({})", end, start))
    })?;
    let len = len
        .checked_add(1)
        .ok_or_else(|| Error::InvalidRequest(format!("end ({}) must not be u64::MAX", end)))?;
    Ok(len)
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L151-172)
```rust
            match self.validate_and_handle_request(peer_network_id, &request) {
                Err(error) => {
                    // Update the error counter
                    increment_counter(
                        &metrics::STORAGE_ERRORS_ENCOUNTERED,
                        peer_network_id.network_id(),
                        error.get_label().into(),
                    );

                    // Periodically log the failure
                    sample!(
                            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
                            warn!(LogSchema::new(LogEntry::StorageServiceError)
                                .error(&error)
                                .peer_network_id(peer_network_id)
                                .request(&request)
                                .optimistic_fetch_related(optimistic_fetch_related)
                        );
                    );

                    // Return the error
                    Err(error)
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-229)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;

        // Process the request
        match &request.data_request {
            DataRequest::GetServerProtocolVersion => {
                let data_response = self.get_server_protocol_version();
                StorageServiceResponse::new(data_response, request.use_compression)
                    .map_err(|error| error.into())
            },
            DataRequest::GetStorageServerSummary => {
                let data_response = self.get_storage_server_summary();
                StorageServiceResponse::new(data_response, request.use_compression)
                    .map_err(|error| error.into())
            },
            _ => self.process_cachable_request(peer_network_id, request),
        }
    }
```

**File:** state-sync/storage-service/types/src/requests.rs (L344-348)
```rust
pub struct StateValuesWithProofRequest {
    pub version: u64,     // The version to fetch the state values at
    pub start_index: u64, // The index to start fetching state values (inclusive)
    pub end_index: u64,   // The index to stop fetching state values (inclusive)
}
```
