# Audit Report

## Title
Integer Underflow in DKG PVSS Schnorr Batch Verification Causes Validator Denial of Service

## Summary
The `pok_batch_verify` function contains an integer underflow vulnerability when processing empty proof vectors, allowing a Byzantine validator to crash or hang other validators during DKG transcript verification.

## Finding Description

The vulnerability exists in the Schnorr proof batch verification logic used during DKG (Distributed Key Generation) PVSS (Publicly Verifiable Secret Sharing) transcript verification.

**Attack Flow:**

1. A Byzantine validator crafts a malicious PVSS transcript with an empty `soks` (Signatures of Knowledge) vector, correctly sized V/C/R vectors, and the dealt public key `V[W]` set to the identity element.

2. The transcript deserializes successfully with no validation requiring non-empty `soks`. [1](#0-0) 

3. The `check_sizes()` method validates V, V_hat, R, R_hat, and C vector lengths but does NOT validate the `soks` vector. [2](#0-1) 

4. During verification, `batch_verify_soks()` is invoked with the empty `soks` array. [3](#0-2) 

5. In `batch_verify_soks()`, when all three arrays (`soks`, `spks`, `aux`) are empty, the length equality checks pass. [4](#0-3) 

6. The accumulation loop iterates zero times, leaving `c` as identity. If `pk` is also identity, the check passes. [5](#0-4) 

7. An empty `poks` vector is constructed and passed to `pok_batch_verify()`. [6](#0-5) 

8. **Integer underflow occurs**: With `n = 0`, the loop `for _ in 0..(n - 1)` evaluates to `0..(0 - 1)`. [7](#0-6) 

In debug mode, this panics with "attempt to subtract with overflow". In release mode, the subtraction wraps to `usize::MAX` (~18 quintillion), causing an effectively infinite loop that hangs the validator.

The vulnerability is triggered when validators receive and verify peer transcripts during DKG aggregation. [8](#0-7) 

## Impact Explanation

**Severity: HIGH** - Validator Node Slowdowns/Crashes

This vulnerability enables a single Byzantine validator to:
- **Crash debug-mode validators**: Immediate panic and termination
- **Hang release-mode validators**: Validators enter an infinite loop and become unresponsive
- **Disrupt DKG process**: Affects epoch transitions and validator set changes

Per Aptos Bug Bounty categories, this qualifies as HIGH severity:
- "Validator node slowdowns" - release builds hang indefinitely (HIGH)
- "API crashes" - debug builds crash immediately (HIGH)

This breaks Byzantine fault tolerance guarantees by allowing a single validator (<1/3 Byzantine) to incapacitate other validators, potentially affecting network availability during critical DKG phases.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible for a Byzantine validator because:
1. **Simple payload construction**: Only requires empty vectors and identity elements
2. **No cryptographic complexity**: No signature forgery needed
3. **Deterministic trigger**: Bug triggers reliably with crafted input
4. **Affects all node types**: Both debug and release builds vulnerable
5. **Critical attack window**: DKG occurs during epoch transitions

**Important Note**: The attacker must be a validator with network access to send DKG transcripts. This is validated at the transcript aggregation layer where sender authentication is checked. [9](#0-8)  However, this remains within the Byzantine fault tolerance threat model which assumes up to 1/3 of validators may be malicious.

## Recommendation

Add validation to ensure `soks` vector is non-empty before processing:

```rust
// In batch_verify_soks function
if soks.is_empty() {
    bail!("soks vector cannot be empty");
}

// Or in pok_batch_verify function  
if poks.is_empty() {
    return Ok(()); // Empty verification trivially succeeds
}
```

Additionally, add size validation for `soks` in the `check_sizes()` method for weighted transcripts to catch this at deserialization.

## Proof of Concept

```rust
#[test]
fn test_empty_poks_underflow() {
    use aptos_dkg::pvss::schnorr::pok_batch_verify;
    use blstrs::{G1Projective, Scalar};
    
    let empty_poks: Vec<(G1Projective, (G1Projective, Scalar))> = vec![];
    let g = G1Projective::generator();
    let gamma = Scalar::ONE;
    
    // This will panic in debug mode or hang in release mode
    let result = pok_batch_verify(&empty_poks, &g, &gamma);
}
```

## Notes

- The vulnerability is in Aptos Core DKG infrastructure code at `crates/aptos-dkg/src/pvss/schnorr.rs`
- Exploitation requires the attacker to be a validator (not "any network peer" as some might assume)
- Both weighted and unweighted PVSS protocols are affected
- The bug violates Byzantine fault tolerance by allowing a single malicious validator to impact others
- Fix should validate non-empty vectors at multiple layers for defense in depth

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L82-89)
```rust
impl TryFrom<&[u8]> for Transcript {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        // NOTE: The `serde` implementation in `blstrs` already performs the necessary point validation
        // by ultimately calling `GroupEncoding::from_bytes`.
        bcs::from_bytes::<Transcript>(bytes).map_err(|_| CryptoMaterialError::DeserializationError)
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L302-309)
```rust
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L40-54)
```rust
    if soks.len() != spks.len() {
        bail!(
            "Expected {} signing PKs, but got {}",
            soks.len(),
            spks.len()
        );
    }

    if soks.len() != aux.len() {
        bail!(
            "Expected {} auxiliary infos, but got {}",
            soks.len(),
            aux.len()
        );
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L57-68)
```rust
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L70-76)
```rust
    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L77-86)
```rust
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L79-87)
```rust
        let peer_power = self.epoch_state.verifier.get_voting_power(&sender);
        ensure!(
            peer_power.is_some(),
            "[DKG] adding peer transcript failed with illegal dealer"
        );
        ensure!(
            metadata.author == sender,
            "[DKG] adding peer transcript failed with node author mismatch"
        );
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-101)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
        let mut trx_aggregator = self.trx_aggregator.lock();
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }

        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```
