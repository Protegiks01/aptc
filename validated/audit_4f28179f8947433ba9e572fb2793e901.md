# Audit Report

## Title
Mainnet Validator Information Disclosure via Insecure Inspection Service Defaults

## Summary
The `InspectionServiceConfig::default()` implementation sets insecure defaults that expose validator identity, network topology, and system information on a publicly accessible endpoint (0.0.0.0:9101). When mainnet validator operators omit the `inspection_service` section from their configuration file, these insecure defaults are silently applied. The configuration sanitizer only validates `expose_configuration` for mainnet validators but fails to check the other three exposure flags (`expose_identity_information`, `expose_peer_information`, `expose_system_information`), allowing sensitive validator information to be publicly exposed.

## Finding Description

The vulnerability occurs through a logic bug in the configuration sanitizer combined with insecure defaults:

**1. Missing Configuration Section**: Validator operators create configuration files following provided examples, which do not include an `inspection_service` section. [1](#0-0) 

**2. Serde Default Invocation**: During deserialization, the `#[serde(default)]` annotation causes the missing field to use `InspectionServiceConfig::default()`, which sets insecure defaults: [2](#0-1) [3](#0-2) 

These defaults bind to `0.0.0.0` (publicly accessible) and enable three information disclosure endpoints.

**3. Incomplete Sanitizer (Logic Bug)**: The `ConfigSanitizer` implementation only checks `expose_configuration` for mainnet validators, completely ignoring the other three exposure flags: [4](#0-3) 

The sanitizer's existence proves the protocol **intends** to prevent mainnet validators from exposing information (lines 54-64), but the implementation is incomplete - it only validates 1 of 4 exposure flags. This is a clear logic bug in the security control.

**4. Service Exposure**: The inspection service starts with the following endpoints enabled:

- `/identity_information` - Exposes validator network peer ID and fullnode network peer IDs: [5](#0-4) [6](#0-5) 

- `/peer_information` - Exposes complete network topology, trusted peers (validator set), connection metadata, and state sync information: [7](#0-6) [8](#0-7) 

- `/system_information` - Exposes system and build information: [9](#0-8) 

**5. Service Binding**: The service binds to the configured address without additional access controls: [10](#0-9) [11](#0-10) 

## Impact Explanation

This vulnerability represents a **Medium to High Severity** issue as a protocol violation with security implications. The protocol explicitly intends to prevent mainnet validators from exposing sensitive information (evidenced by the sanitizer checking `expose_configuration`), but the incomplete sanitizer implementation creates a security control failure.

The disclosed information enables attackers to:
- Map the complete validator network topology and identify all peers
- Discover the active validator set through trusted peer information
- Monitor connection states and network health in real-time
- Identify validator peer IDs for targeted reconnaissance
- Plan sophisticated attacks (eclipse attacks, targeted network partitioning)
- Gather intelligence for consensus-level attack strategies

While this does not directly cause loss of funds or consensus violations, it represents a **significant security control failure** that exposes critical network infrastructure information, substantially lowering the barrier for subsequent attacks on validator nodes. The combination of:
1. Insecure defaults (binding to 0.0.0.0)
2. Incomplete security validation (logic bug in sanitizer)
3. High likelihood of misconfiguration
4. No runtime warnings

qualifies this as a protocol violation that undermines validator operational security.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to occur because:

1. **Configuration Pattern**: Official example validator configurations do not include an `inspection_service` section, leading operators to create minimal configs [1](#0-0) 

2. **Silent Default Application**: Serde automatically applies defaults for missing fields without any warning to operators [2](#0-1) 

3. **False Sense of Security**: The sanitizer's existence and the check for `expose_configuration` provides operators with a false sense that mainnet validators are protected, while three other exposure flags remain unchecked

4. **No Runtime Detection**: The node provides no warnings at startup that sensitive endpoints are publicly exposed on 0.0.0.0:9101

5. **Infrastructure Assumption**: The only mitigation is external infrastructure controls (firewalls, network policies), which are outside the node software and may not be consistently deployed

## Recommendation

**Fix the incomplete sanitizer** by checking all four exposure flags for mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive information
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, consider changing the default address from `0.0.0.0` to `127.0.0.1` for mainnet nodes to prevent accidental public exposure.

## Proof of Concept

1. Create a minimal validator configuration file without an `inspection_service` section (following the example at `config/src/config/test_data/validator.yaml`)
2. Start the validator node with this configuration
3. The node will apply `InspectionServiceConfig::default()` due to the `#[serde(default)]` annotation
4. The sanitizer will pass because it only checks `expose_configuration` (which defaults to `false`)
5. The inspection service starts on `0.0.0.0:9101` with three information disclosure endpoints enabled
6. Access `http://VALIDATOR_IP:9101/identity_information`, `/peer_information`, and `/system_information` to retrieve sensitive validator information

## Notes

This vulnerability stems from a **logic bug in the security controls** rather than a missing feature. The existence of the sanitizer checking `expose_configuration` for mainnet validators demonstrates the developers' intent to protect sensitive information. However, the incomplete implementation checking only 1 of 4 exposure flags creates a security gap that contradicts the protocol's security intent. Combined with insecure defaults and missing configuration examples, this creates a high-likelihood scenario for information disclosure on production mainnet validators.

### Citations

**File:** config/src/config/test_data/validator.yaml (L1-81)
```yaml
base:
    data_dir: "/opt/aptos/data"
    role: "validator"
    waypoint:
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"

consensus:
    safety_rules:
        service:
            type: process
            server_address: "/ip4/127.0.0.1/tcp/5555"

execution:
    genesis_file_location: "relative/path/to/genesis"

# For validator node we setup two networks, validator_network to allow validator connect to each other,
# and full_node_networks to allow fullnode connects to validator.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"

validator_network:
    discovery_method: "onchain"
    listen_address: "/ip4/0.0.0.0/tcp/6180"
    identity:
        type: "from_storage"
        key_name: "validator_network"
        peer_id_name: "owner_account"
        backend:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
    network_id: "validator"
    ### Load keys from file
    # identity:
    #     type: "from_file"
    #     path: /full/path/to/private-keys.yml
    #
    ### Load keys from secure storage service like vault:
    #
    # identity:
    #     type: "from_storage"
    #     key_name: "validator_network"
    #     peer_id_name: "owner_account"
    #     backend:
    #         type: "vault"
    #         server: "https://127.0.0.1:8200"
    #         ca_certificate: "/full/path/to/certificate"
    #         token:
    #             from_disk: "/full/path/to/token"
    #
    ### Load keys directly from config
    #
    # identity:
    #     type: "from_config"
    #     key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    #     peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
    mutual_authentication: true
    max_frame_size: 4194304 # 4 MiB
api:
    enabled: true
```

**File:** config/src/config/node_config.rs (L64-65)
```rust
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-68)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L34-49)
```rust
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L20-38)
```rust
/// Handles a new peer information request
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L14-29)
```rust
pub fn handle_system_information_request(node_config: NodeConfig) -> (StatusCode, Body, String) {
    // Only return system information if the endpoint is enabled
    if node_config.inspection_service.expose_system_information {
        (
            StatusCode::OK,
            Body::from(get_system_information_json()),
            CONTENT_TYPE_JSON.into(),
        )
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(SYS_INFO_DISABLED_MESSAGE),
            CONTENT_TYPE_TEXT.into(),
        )
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L55-69)
```rust
    // Fetch the service port and address
    let service_port = node_config.inspection_service.port;
    let service_address = node_config.inspection_service.address.clone();

    // Create the inspection service socket address
    let address: SocketAddr = (service_address.as_str(), service_port)
        .to_socket_addrs()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to parse {}:{} as address",
                service_address, service_port
            )
        })
        .next()
        .unwrap();
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L94-96)
```rust
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
```
