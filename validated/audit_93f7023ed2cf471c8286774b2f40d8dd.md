# Audit Report

## Title
Consensus Split Vulnerability Due to Bytecode Version Mismatch During Rolling Validator Upgrades

## Summary
A structural consensus vulnerability exists where the lack of code-level coordination between on-chain feature flags and validator binary versions can cause blockchain forks during rolling upgrades. When governance enables new bytecode version feature flags before all validators upgrade their software, heterogeneous validators will disagree on transaction validity, violating the deterministic execution invariant required for consensus.

## Finding Description

The vulnerability stems from a fundamental architectural issue where bytecode version validation depends on both on-chain feature flags (dynamically controlled) and compile-time constants (static in validator binaries), without any code-level enforcement ensuring these remain synchronized during rolling upgrades.

**Technical Mechanism:**

The deserialization validation logic uses the minimum of two version sources: [1](#0-0) 

Where `max_version` is determined by on-chain feature flags through `get_max_binary_format_version()`: [2](#0-1) 

This feature flag-derived version is integrated into the deserializer configuration: [3](#0-2) 

And `VERSION_MAX` is a compile-time constant in the validator binary: [4](#0-3) 

This validation is invoked during module publishing when the AptosVM deserializes module bundles: [5](#0-4) 

**Attack Scenario:**

1. Network operates with validators running software version N where `VERSION_MAX=9` (compile-time constant in their binaries)
2. Governance proposal enables `VM_BINARY_FORMAT_V10` feature flag, setting on-chain `max_version=10` for all validators
3. Validators begin rolling upgrade to version N+1 where `VERSION_MAX=10` (new compile-time constant)
4. During the upgrade window, the validator set is heterogeneous
5. User publishes module with bytecode version 10, achievable via language version 2.4+: [6](#0-5) 

6. **Consensus divergence occurs:**
   - Upgraded validators (VERSION_MAX=10): `10 > min(10, 10)` evaluates to FALSE → **ACCEPT transaction**
   - Non-upgraded validators (VERSION_MAX=9): `10 > min(10, 9)` evaluates to TRUE → **REJECT transaction with UNKNOWN_VERSION** [7](#0-6) 

7. Validators produce different state roots for the same block, fundamentally breaking consensus determinism

**Lack of Coordination Enforcement:**

The governance system can enable bytecode version feature flags at any time without technical validation that all validators support the new version. The feature flags are defined as simple enum variants: [8](#0-7) [9](#0-8) 

Rolling upgrades demonstrably create heterogeneous validator sets, as documented in the release process: [10](#0-9) 

No validation in the module publishing flow checks whether bytecode versions exceed validator binary capabilities: [11](#0-10) 

## Impact Explanation

**Critical Severity** per Aptos bug bounty criteria:

1. **Consensus Safety Violation**: This is an explicit Critical criterion. Different validators produce divergent state roots for identical block content, preventing the 2/3+ BFT agreement required by AptosBFT consensus protocol. The state root computation is deterministic and any divergence breaks consensus.

2. **Non-recoverable Network Partition**: The blockchain cannot progress past blocks containing the problematic transaction. This requires hardfork-level intervention to resolve—validators cannot self-recover through normal consensus mechanisms.

3. **Total Loss of Liveness**: Once triggered, the network halts as validators cannot reach consensus on subsequent blocks. This is another explicit Critical criterion in the Aptos bug bounty program.

4. **Deterministic Execution Invariant Broken**: The fundamental blockchain guarantee that "all honest validators execute transactions identically" is violated, compromising the entire security model.

The impact directly maps to multiple Critical severity categories in the Aptos bug bounty program, warranting maximum severity classification.

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**

1. **Structural Inevitability**: The vulnerability is not a one-time issue but a recurring pattern. Each new bytecode version (V11, V12, etc.) will create the same vulnerability window unless the coordination mechanism is fixed.

2. **Operational Necessity**: Rolling upgrades are standard practice for maintaining network availability during software updates. The release documentation shows validators upgrade gradually over multiple days.

3. **Feature Flag Accessibility**: Governance proposals can enable feature flags without cryptographic proof that all validators support the new version.

4. **Benign Triggering**: Even non-malicious users compiling with latest language features (2.4+) will inadvertently trigger the issue during upgrade windows, as VERSION_DEFAULT_LANG_V2_4 defaults to bytecode version 10.

**Factors Decreasing Likelihood:**

1. **Operational Procedures**: Aptos operators likely follow careful sequencing (upgrade all validators first, then enable features via governance), as suggested by the release timeline.

2. **Out-of-Band Coordination**: Teams probably use monitoring and communication to prevent premature flag enablement.

3. **Requires Specific Timing**: Exploit window is limited to the duration of rolling upgrades (though this may be hours or days based on the release process).

**Critical Assessment**: While operational procedures reduce likelihood, the **complete absence of code-level enforcement** makes this a latent systemic risk. Defense-in-depth principles demand technical safeguards, not just operational discipline. A single coordination failure—whether due to miscommunication, automation error, or emergency circumstances—could trigger a network-wide consensus failure.

## Recommendation

Implement code-level coordination between binary versions and feature flag activation:

1. **Binary Version Metadata**: Add a binary version field to validator registration that declares supported bytecode versions. Store this in validator configuration on-chain.

2. **Feature Flag Precondition Check**: Modify feature flag activation logic to require cryptographic proof (via validator signatures) that ≥67% of stake supports the new bytecode version before allowing activation.

3. **Epoch-Coordinated Activation**: Tie bytecode version upgrades to epoch boundaries, ensuring all validators have upgraded before the new version becomes active.

4. **Validation Enhancement**: Add explicit checks in `validate_publish_request()` that reject modules with bytecode versions exceeding the validator's compile-time `VERSION_MAX`, providing clear error messages.

Example fix for validation layer:
```rust
fn validate_publish_request(...) -> VMResult<()> {
    // Existing validations
    self.reject_unstable_bytecode(modules)?;
    
    // Add: Validate bytecode version against binary capability
    for module in modules {
        if module.version() > VERSION_MAX {
            return Err(PartialVMError::new(StatusCode::BYTECODE_VERSION_UNSUPPORTED)
                .with_message(format!(
                    "Bytecode version {} exceeds validator capability {}",
                    module.version(),
                    VERSION_MAX
                ))
                .finish(Location::Undefined));
        }
    }
    
    native_validation::validate_module_natives(modules)?;
    // ... rest of validation
}
```

## Proof of Concept

While a full PoC requires a multi-validator testnet setup, the vulnerability can be demonstrated through the following logic:

```rust
// Validator A: Binary with VERSION_MAX = 9
let max_version_from_flags = 10; // VM_BINARY_FORMAT_V10 enabled
let bytecode_version = 10;
let check_a = bytecode_version > u32::min(max_version_from_flags, 9);
// check_a = 10 > 9 = TRUE → REJECT

// Validator B: Binary with VERSION_MAX = 10  
let max_version_from_flags = 10; // Same feature flag
let bytecode_version = 10;
let check_b = bytecode_version > u32::min(max_version_from_flags, 10);
// check_b = 10 > 10 = FALSE → ACCEPT

// Result: Consensus split on same transaction
```

This demonstrates the core issue: identical on-chain state (`max_version_from_flags=10`) produces different validation outcomes based on the validator's binary version (`VERSION_MAX`), breaking consensus determinism.

## Notes

This vulnerability represents a **systemic architectural risk** rather than a traditional bug. The root cause is the dual-source version validation mechanism (on-chain flags + compile-time constants) without coordination enforcement. While current operational procedures likely prevent exploitation, defense-in-depth security principles require technical safeguards to eliminate this latent risk entirely. Each future bytecode version upgrade will recreate this vulnerability window unless the underlying coordination mechanism is strengthened with code-level enforcement.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L565-565)
```rust
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L617-619)
```rust
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
```

**File:** types/src/on_chain_config/aptos_features.rs (L24-24)
```rust
    VM_BINARY_FORMAT_V6 = 5,
```

**File:** types/src/on_chain_config/aptos_features.rs (L165-165)
```rust
    VM_BINARY_FORMAT_V10 = 106,
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L137-142)
```rust
pub fn aptos_prod_deserializer_config(features: &Features) -> DeserializerConfig {
    DeserializerConfig::new(
        features.get_max_binary_format_version(),
        features.get_max_identifier_size(),
    )
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1447-1450)
```rust
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1454-1457)
```rust
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L282-288)
```rust
    pub fn serialize_for_version(
        &self,
        bytecode_version: Option<u32>,
        binary: &mut Vec<u8>,
    ) -> Result<()> {
        let version = bytecode_version.unwrap_or(VERSION_DEFAULT);
        validate_version(version)?;
```

**File:** RELEASE.md (L45-46)
```markdown
* [day 14] Once confirmed that both binary upgrade and framework upgrade stabilized on testnet, a release tag `aptos-node-vx.y.z` will be created, the release version will be deployed to 1% of the stake on **Mainnet**.
* [day 16] Wider announcement will be made for the community to upgrade the binary, `aptos-node-vx.y.z` will be updated with "[Mainnet]" in the release page, Mainnet validators will be slowly upgrading.
```
