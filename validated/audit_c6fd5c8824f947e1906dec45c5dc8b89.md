# Audit Report

## Title
Secret Sharing Aggregation Fails Due to Weight Mismatch Between Threshold Config and Peer Weight Calculation

## Summary
The `SecretShareConfig` uses a weighted threshold configuration that expects validators to have stake-based weights, but the `get_peer_weight()` method always returns 1 for all validators. This causes the share aggregation guard check to never pass, resulting in complete failure of secret reconstruction and randomness beacon functionality when weighted validator configurations are used.

## Finding Description

The vulnerability exists in a critical mismatch between the weighted threshold configuration system and the peer weight calculation used during share aggregation.

**Weighted Configuration Creation:**
The DKG rounding process creates a `WeightedConfigBlstrs` using actual validator stakes converted to weights [1](#0-0) . For example, validators with different stakes result in weights like [100, 200, 50] with a corresponding weighted threshold (e.g., 200 representing ~57% of total weight 350).

This weighted configuration becomes the `config` field in `SecretShareConfig` [2](#0-1) , which is of type `WeightedConfigArkworks<Fr>`.

**Threshold Retrieval:**
The `threshold()` method correctly returns the weighted threshold value from the underlying configuration [3](#0-2) . This returns the weighted threshold (e.g., 200).

**Weight Calculation Always Returns 1:**
The `get_peer_weight()` method ignores the actual validator weight and always returns 1 [4](#0-3) . The `weights` HashMap that should store actual validator weights is initialized empty and never populated [5](#0-4) [6](#0-5) . A comment indicates this struct is "temporary and meant to change in future PRs" [7](#0-6) .

**Aggregation Logic Failure:**
During share aggregation, the system retrieves peer weight via `get_peer_weight()` [8](#0-7) , which returns 1. The `SecretShareAggregator` accumulates total weight by adding these values [9](#0-8) .

The critical guard check in `try_aggregate()` compares the accumulated total weight against the threshold [10](#0-9) . With 3 validators, `total_weight` = 3, but `threshold()` returns 200, so the condition `3 < 200` prevents aggregation from proceeding.

**Exploitation Scenario:**
When randomness is enabled with weighted validator configurations:
1. Three validators with stake-based weights [100, 200, 50] (total 350, threshold 200) generate secret shares
2. Share aggregator receives all 3 shares
3. Each share is counted with weight 1: `total_weight = 1 + 1 + 1 = 3`
4. Guard check: `3 < 200` â†’ aggregation does NOT proceed
5. Secret reconstruction never happens
6. Randomness beacon fails permanently for that round

The weighted share reconstruction logic itself would work correctly if reached [11](#0-10) , as it properly flattens weighted shares into virtual player shares. However, the aggregation guard check prevents this code from ever executing.

## Impact Explanation

This vulnerability represents a **complete functional failure** of the randomness beacon when weighted validator configurations are used. Under the Aptos bug bounty criteria, this qualifies as **HIGH to CRITICAL severity** depending on production deployment status:

**If randomness is enabled in production:**
- **Critical**: Complete failure of advertised randomness beacon functionality
- All validators cannot generate on-chain randomness
- Smart contracts depending on randomness cannot function
- Violates cryptographic correctness guarantees of the weighted threshold scheme

**Impact scope:**
- Randomness unavailable to all on-chain applications
- Leader selection potentially affected if dependent on beacon
- Network reputation damage if feature is advertised as functional
- Deterministic failure (100% reproduction rate when weighted configs are used)

The consensus protocol itself can continue operating without randomness, so this is not a "network halt" scenario. However, it represents a complete failure of a critical cryptographic subsystem that validators are configured to provide.

## Likelihood Explanation

**Likelihood: HIGH (if randomness enabled) / LOW (if disabled)**

This is a deterministic logic bug that will trigger automatically whenever:
1. Randomness is enabled via `OnChainRandomnessConfig` (V1 or V2) [12](#0-11) 
2. Validators have different stake amounts (standard in proof-of-stake)
3. DKG creates weighted configurations from validator stakes
4. Secret sharing is attempted during consensus rounds

The vulnerability requires **no attacker action** - it's a logic bug in the implementation. The SecretShareManager is integrated into the consensus epoch initialization flow [13](#0-12)  and will be activated when randomness is enabled.

**Mitigating factors:**
- The "temporary" comment suggests this may be incomplete/experimental code
- Actual production deployment status of weighted randomness is uncertain
- If randomness is disabled via `ConfigOff`, this code path is not exercised

However, even incomplete code that is deployed and can be enabled constitutes a valid vulnerability.

## Recommendation

**Immediate Fix:**
Populate the `weights` HashMap in `SecretShareConfig::new()` with actual validator weights extracted from the `WeightedConfigArkworks`:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Extract weights from the weighted config
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses()
        .iter()
        .enumerate()
        .map(|(idx, addr)| {
            let player = Player { id: idx };
            let weight = config.get_player_weight(&player) as u64;
            (*addr, weight)
        })
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

And update `get_peer_weight()` to use the HashMap:

```rust
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    self.weights.get(peer).copied().unwrap_or(1)
}
```

**Long-term Fix:**
Remove the "temporary" designation and properly implement the weighted secret sharing system, or clearly mark it as experimental with appropriate safety checks to prevent production use until completed.

## Proof of Concept

While a full runnable PoC would require setting up a test network with weighted validators, the logic bug can be demonstrated through code analysis:

```rust
// Conceptual demonstration of the bug
// Given: 3 validators with weights [100, 200, 50], threshold 200

let config = SecretShareConfig::new(/* weighted config with threshold 200 */);
assert_eq!(config.threshold(), 200); // Returns weighted threshold

let mut aggregator = SecretShareAggregator::new(author);
for share in validator_shares {
    let weight = config.get_peer_weight(&share.author); 
    // weight = 1 for all validators (BUG)
    aggregator.add_share(share, weight);
}
// aggregator.total_weight = 3 (should be 350)

// Guard check fails
assert!(aggregator.total_weight < config.threshold()); // 3 < 200
// Aggregation never proceeds
```

The bug is verifiable through static code analysis of the cited files showing the mismatch between weighted threshold retrieval and constant-1 weight calculation.

## Notes

1. This vulnerability affects the **randomness beacon subsystem specifically**, not the core consensus protocol. The AptosBFT consensus can continue operating without randomness.

2. The severity depends critically on whether randomness is **enabled in production**. If disabled (ConfigOff), this code path is not exercised.

3. The "temporary" comment and uninitialized weights HashMap suggest this is **acknowledged incomplete work**. However, incomplete code in production that can be enabled still constitutes a vulnerability.

4. The **weighted share reconstruction logic itself is correct** [14](#0-13)  - the bug is solely in the aggregation guard check that prevents reconstruction from occurring.

5. This is a **deterministic logic bug**, not a security attack requiring adversarial action. It will fail 100% of the time when weighted validator configurations are used.

### Citations

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** types/src/secret_sharing.rs (L134-134)
```rust
/// This is temporary and meant to change in future PRs
```

**File:** types/src/secret_sharing.rs (L143-143)
```rust
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
```

**File:** types/src/secret_sharing.rs (L145-145)
```rust
    weights: HashMap<Author, u64>,
```

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L188-190)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-35)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L44-44)
```rust
        if self.total_weight < secret_share_config.threshold() {
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L260-260)
```rust
        let weight = self.secret_share_config.get_peer_weight(share.author());
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L418-450)
```rust
impl<F: FftField, SK: Reconstructable<ShamirThresholdConfig<F>>>
    Reconstructable<WeightedConfigArkworks<F>> for SK
{
    type ShareValue = Vec<SK::ShareValue>;

    fn reconstruct(
        sc: &WeightedConfigArkworks<F>,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> anyhow::Result<Self> {
        let mut flattened_shares = Vec::with_capacity(sc.get_total_weight());

        // println!();
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }
        flattened_shares.truncate(sc.get_threshold_weight());

        SK::reconstruct(sc.get_threshold_config(), &flattened_shares)
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L205-210)
```rust
    pub fn randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::V1(_) => true,
            OnChainRandomnessConfig::V2(_) => true,
        }
```

**File:** consensus/src/pipeline/execution_client.rs (L286-302)
```rust
        let secret_share_manager = SecretShareManager::new(
            self.author,
            epoch_state.clone(),
            config,
            secret_ready_block_tx,
            network_sender.clone(),
            self.bounded_executor.clone(),
            &self.consensus_config.rand_rb_config,
        );

        tokio::spawn(secret_share_manager.start(
            ordered_block_rx,
            secret_sharing_msg_rx,
            reset_secret_share_manager_rx,
            self.bounded_executor.clone(),
            highest_committed_round,
        ));
```
