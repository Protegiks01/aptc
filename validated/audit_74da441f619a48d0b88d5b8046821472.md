# Audit Report

## Title
Gas Estimation API Panic Due to Unhandled Empty Transaction Price Data

## Summary
The gas estimation logic in `api/src/context.rs` contains a panic condition that crashes the API server when processing blocks with no parseable user transactions but with block limit flags set. This occurs when calling `.unwrap()` on an empty iterator while computing minimum gas prices.

## Finding Description

The `block_min_inclusion_price()` function attempts to calculate the minimum inclusion price for "full" blocks by finding the minimum gas price across all user transactions. However, it fails to handle the edge case where a block is considered "full" but contains no parseable user transaction data. [1](#0-0) 

The vulnerability manifests through the following execution path:

1. **Data Retrieval**: The `get_gas_prices_and_used()` function collects transaction prices from a block. When transaction info parsing fails for user transactions, errors are silently skipped, causing the `prices_and_used` vector to remain empty. [2](#0-1) 

Specifically, the error handling at line 1192 silently skips failed transaction info parsing: [3](#0-2) 

2. **Full Block Detection**: A block is marked as "full" when `BlockEndInfo.limit_reached()` returns true, indicating block gas or output limits were reached. [4](#0-3) 

The `limit_reached()` method checks block limit flags: [5](#0-4) 

3. **Panic Condition**: When the block is marked full but `prices_and_used` is empty, the code attempts to find the minimum price, calling `.min()` which returns `None`, followed by `.unwrap()` which panics. [6](#0-5) 

**Exploitation Path:**
- Database corruption causes transaction info parsing to fail for all user transactions in a block
- BlockEpilogue is successfully parsed and indicates limits were reached
- The `/estimate_gas_price` API processes this block during historical analysis
- The API thread panics at line 1274, causing service disruption [7](#0-6) 

## Impact Explanation

**Severity: High** (API Crashes)

This vulnerability causes a **Denial of Service** on the gas estimation API endpoint, qualifying as **High Severity** per Aptos bug bounty criteria for "API crashes":

- **Availability Impact**: Users cannot retrieve gas price estimates through the `/estimate_gas_price` endpoint, degrading user experience and potentially causing transaction submission failures due to incorrect gas pricing
- **Scope**: Affects the gas estimation API and any services depending on it for fee recommendations
- **Recovery**: Requires restarting the API server and potentially repairing corrupted database entries or implementing data migration
- **Does NOT Impact**: Consensus layer, blockchain state integrity, or validator operations (API-layer issue only)

The impact aligns with the Aptos bug bounty High Severity category for "API crashes" affecting network participation.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions to trigger:

1. **Database Corruption**: Transaction info data becomes corrupted or unparseable while BlockEpilogue data remains intact
2. **State Sync Edge Cases**: Malformed or incomplete block data received during state synchronization from peers
3. **Schema Evolution**: Serialization format changes causing historical transaction info to fail parsing with current code

While not trivially exploitable by external attackers without node access, the vulnerability can manifest through:
- Operational issues (disk corruption, incomplete writes, filesystem errors)
- Software bugs in transaction serialization/deserialization during upgrades
- State synchronization from peers with inconsistent data formats or schema versions
- Database migration errors affecting transaction info records but not block epilogue data

The separated data retrieval paths (transaction iterator and info iterator) make partial corruption scenarios realistic. The impact is amplified because gas estimation is a critical user-facing API that continuously processes historical blockchain data.

## Recommendation

Add a validation check before calling `.unwrap()` to handle the empty vector case gracefully:

```rust
if is_full_block {
    if let Some(min_price) = prices_and_used
        .iter()
        .map(|(price, _)| *price)
        .min()
    {
        Some(self.next_bucket(min_price))
    } else {
        // Block marked as full but no valid transaction prices available
        // Fall back to minimum gas unit price
        Some(min_gas_unit_price)
    }
} else {
    None
}
```

Alternatively, return early with a default value when `prices_and_used` is empty despite `is_full_block` being true, or log a warning about the data inconsistency for operational monitoring.

## Proof of Concept

While a full PoC would require database corruption simulation, the vulnerability is evident from code analysis. The panic can be triggered when:

1. Database contains a block where all user transaction infos fail to parse (corrupted data)
2. The same block's BlockEpilogue successfully parses with `limit_reached()` returning true
3. The `/estimate_gas_price` endpoint is called, triggering historical block analysis
4. The API thread panics at line 1274 when attempting `.unwrap()` on `None`

The code path is deterministic: empty `prices_and_used` + `is_full_block = true` â†’ guaranteed panic.

## Notes

This vulnerability demonstrates a missing defensive check in the gas estimation logic. The code assumes that "full blocks" will always contain parseable user transaction price data, but this assumption is violated when database corruption or state sync issues cause transaction info parsing to fail while block metadata remains intact. The impact is limited to API availability and does not affect consensus or blockchain state integrity.

### Citations

**File:** api/src/context.rs (L1168-1223)
```rust
    fn get_gas_prices_and_used(
        &self,
        start_version: Version,
        limit: u64,
        ledger_version: Version,
        count_majority_use_case: bool,
    ) -> Result<(Vec<(u64, u64)>, Vec<BlockEndInfo>, Option<f32>)> {
        if start_version > ledger_version || limit == 0 {
            return Ok((vec![], vec![], None));
        }

        // This is just an estimation, so we can just skip over errors
        let limit = std::cmp::min(limit, ledger_version - start_version + 1);
        let txns = self.db.get_transaction_iterator(start_version, limit)?;
        let infos = self
            .db
            .get_transaction_info_iterator(start_version, limit)?;

        let mut gas_prices = Vec::new();
        let mut block_end_infos = Vec::new();
        let mut count_by_use_case = HashMap::new();
        for (txn, info) in txns.zip(infos) {
            match txn.as_ref() {
                Ok(Transaction::UserTransaction(txn)) => {
                    if let Ok(info) = info.as_ref() {
                        gas_prices.push((txn.gas_unit_price(), info.gas_used()));
                        if count_majority_use_case {
                            let use_case_key = txn.parse_use_case();
                            *count_by_use_case.entry(use_case_key).or_insert(0) += 1;
                        }
                    }
                },
                Ok(Transaction::BlockEpilogue(txn)) => {
                    if let Some(block_end_info) = txn.try_as_block_end_info() {
                        block_end_infos.push(block_end_info.clone());
                    }
                },
                _ => {},
            }
        }

        let majority_use_case_fraction = if count_majority_use_case {
            count_by_use_case.iter().max_by_key(|(_, v)| *v).and_then(
                |(max_use_case, max_value)| {
                    if let UseCaseKey::ContractAddress(_) = max_use_case {
                        Some(*max_value as f32 / count_by_use_case.values().sum::<u64>() as f32)
                    } else {
                        None
                    }
                },
            )
        } else {
            None
        };
        Ok((gas_prices, block_end_infos, majority_use_case_fraction))
    }
```

**File:** api/src/context.rs (L1225-1283)
```rust
    fn block_min_inclusion_price(
        &self,
        ledger_info: &LedgerInfo,
        first: Version,
        last: Version,
        gas_estimation_config: &GasEstimationConfig,
        execution_config: &OnChainExecutionConfig,
    ) -> Option<u64> {
        let user_use_case_spread_factor = if gas_estimation_config.incorporate_reordering_effects {
            execution_config
                .transaction_shuffler_type()
                .user_use_case_spread_factor()
        } else {
            None
        };

        match self.get_gas_prices_and_used(
            first,
            last - first,
            ledger_info.ledger_version.0,
            user_use_case_spread_factor.is_some(),
        ) {
            Ok((prices_and_used, block_end_infos, majority_use_case_fraction)) => {
                let is_full_block =
                    if majority_use_case_fraction.is_some_and(|fraction| fraction > 0.5) {
                        // If majority use case is above half of transactions, UseCaseAware block reordering
                        // will allow other transactions to get in the block (AIP-68)
                        false
                    } else if prices_and_used.len() >= gas_estimation_config.full_block_txns {
                        true
                    } else if !block_end_infos.is_empty() {
                        assert_eq!(1, block_end_infos.len());
                        block_end_infos.first().unwrap().limit_reached()
                    } else if let Some(block_gas_limit) =
                        execution_config.block_gas_limit_type().block_gas_limit()
                    {
                        let gas_used = prices_and_used.iter().map(|(_, used)| *used).sum::<u64>();
                        gas_used >= block_gas_limit
                    } else {
                        false
                    };

                if is_full_block {
                    Some(
                        self.next_bucket(
                            prices_and_used
                                .iter()
                                .map(|(price, _)| *price)
                                .min()
                                .unwrap(),
                        ),
                    )
                } else {
                    None
                }
            },
            Err(_) => None,
        }
    }
```

**File:** types/src/transaction/block_epilogue.rs (L86-94)
```rust
    pub fn limit_reached(&self) -> bool {
        match self {
            BlockEndInfo::V0 {
                block_gas_limit_reached,
                block_output_limit_reached,
                ..
            } => *block_gas_limit_reached || *block_output_limit_reached,
        }
    }
```

**File:** api/src/transactions.rs (L817-826)
```rust
    async fn estimate_gas_price(&self, accept_type: AcceptType) -> BasicResult<GasEstimation> {
        fail_point_poem("endpoint_encode_submission")?;
        self.context
            .check_api_output_enabled("Estimate gas price", &accept_type)?;

        let context = self.context.clone();
        api_spawn_blocking(move || {
            let latest_ledger_info = context.get_latest_ledger_info()?;
            let gas_estimation = context.estimate_gas_price(&latest_ledger_info)?;
            Self::log_gas_estimation(&gas_estimation);
```
