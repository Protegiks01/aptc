# Audit Report

## Title
Consensus Divergence via Inconsistent APK Availability During Randomness Aggregation

## Summary
The randomness beacon's share verification and aggregation process is vulnerable to consensus divergence when validators have different sets of augmented public keys (APKs) available at different times. This race condition allows different validators to accept different sets of shares and compute different randomness values for the same round, violating consensus safety.

## Finding Description

The vulnerability exists in the randomness beacon implementation where share verification and APK management occur concurrently without proper synchronization:

**1. Concurrent Share Verification and APK Updates**

The verification task runs concurrently with the main event loop. Incoming shares are verified using the current APK availability before being forwarded to the main loop. [1](#0-0) 

Share verification requires the corresponding validator's APK to be present. If missing, verification fails and the share is permanently dropped: [2](#0-1) [3](#0-2) 

**2. Shared Mutable State Without Atomicity**

The `RandConfig` structure contains `Arc<RandKeys>`, allowing multiple threads to share the same APK storage: [4](#0-3) [5](#0-4) 

When `CertifiedAugData` messages arrive, they asynchronously add APKs to this shared state in the main event loop: [6](#0-5) [7](#0-6) [8](#0-7) 

**3. No Synchronization Barrier**

Validators start processing blocks as soon as their own certified augmented data exists, without waiting for all other validators' augmented data: [9](#0-8) [10](#0-9) 

The `CertifiedAugData` broadcast task runs asynchronously and does not block block processing: [11](#0-10) 

**4. Immediate Aggregation Without Waiting**

Once threshold weight is reached, aggregation spawns immediately and computes randomness using whatever shares are currently available: [12](#0-11) 

The aggregated randomness is immediately sent to the decision channel and cannot be recomputed: [13](#0-12) 

**Attack Scenario:**
1. Validator A receives `CertifiedAugData` from validators {0, 1, 2} but validator 3's message is delayed
2. Validator B receives `CertifiedAugData` from all validators {0, 1, 2, 3}
3. Shares from validator 3 arrive via proactive broadcast
4. Validator A's verification task rejects share from validator 3 (no APK) - permanently dropped
5. Validator B's verification task accepts share from validator 3 (has APK)
6. Validator A reaches threshold with shares {0, 1, 2}, aggregates immediately → randomness R_A
7. Validator B reaches threshold with shares {1, 2, 3}, aggregates immediately → randomness R_B
8. R_A ≠ R_B → **Consensus divergence**

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability directly violates the fundamental consensus invariant that all validators must compute identical randomness values for the same round. Per Aptos bug bounty criteria, this qualifies as Critical severity under "Consensus/Safety violations" because:

1. **Different validators commit different randomness**: Each validator includes the computed randomness in their block's metadata, causing different state roots
2. **State divergence**: Blocks with different randomness values are incompatible, causing validators to diverge
3. **Non-recoverable network partition**: Once validators compute different randomness, they cannot reconcile without a hardfork
4. **Chain split**: The network fragments into subsets with mutually incompatible states

The randomness is used for critical protocol functions including leader selection and on-chain randomness APIs. Divergent randomness values break deterministic execution guarantees.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered without Byzantine validators through natural network conditions:

1. **Network jitter during epoch initialization**: When a new epoch starts, validators broadcast their augmented data simultaneously. Network delays cause these messages to arrive in different orders at different validators. This is a normal distributed systems behavior.

2. **Proactive share broadcasting**: Shares are broadcast proactively when blocks arrive (line 167 in rand_manager.rs), before waiting to ensure all APKs have propagated.

3. **Multiple threshold combinations**: In validator sets with distributed voting power, there are often multiple combinations of validators that can reach the 2/3 threshold. Different APK arrival orders can cause different validators to aggregate different combinations.

4. **Timing window**: The 300ms delay before re-requesting shares provides a window where aggregation can complete with inconsistent share sets if threshold is reached quickly.

The likelihood is not higher because:
- Production networks typically have good connectivity
- The reliable broadcast mechanism attempts to ensure message delivery
- The re-request mechanism provides partial mitigation if aggregation is slower than APK propagation

However, the vulnerability requires no malicious behavior and can occur naturally, especially during epoch transitions when all validators are simultaneously broadcasting augmented data and beginning to process shares.

## Recommendation

Implement a synchronization barrier ensuring all validators have complete APK sets before allowing share aggregation:

1. **Add APK completeness check**: Modify the aggregation condition to verify all APKs are available:
   - In `rand_store.rs`, before calling `try_aggregate`, check that `rand_config.get_certified_apk()` returns `Some` for all shares being aggregated
   - Track which validators' APKs are missing and defer aggregation until all are available

2. **Wait for full APK set**: Change the block processing guard from `my_certified_aug_data_exists()` to check that certified augmented data has been received from all validators (or a supermajority).

3. **Add retry mechanism for failed share verifications**: Store shares that fail verification due to missing APKs in a pending queue, and retry verification when the corresponding APK becomes available.

4. **Synchronize aggregation timing**: Add explicit synchronization between the verification task and main event loop to ensure APK updates are visible before share verification decisions.

## Proof of Concept

The vulnerability can be demonstrated with a consensus test that:
1. Sets up multiple validator nodes in separate processes
2. Introduces network delays causing `CertifiedAugData` messages to arrive in different orders
3. Triggers proactive share broadcasting while some validators are missing APKs
4. Observes different validators computing different randomness values for the same round
5. Verifies resulting consensus divergence

A complete PoC would require integration testing infrastructure to control network message delivery timing between validators, which is beyond the scope of static analysis but demonstrates a realistic attack scenario given the architectural flaws identified.

## Notes

This vulnerability is particularly concerning because:
- It requires no Byzantine behavior or compromised validators
- It can occur naturally with standard network delays
- It affects a critical consensus component (randomness beacon)
- The consequences (network partition) are severe and require hardfork to resolve

The vulnerability stems from an architectural assumption that APK propagation completes before share aggregation begins, which is not enforced in the code.

### Citations

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-261)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L305-346)
```rust
    async fn broadcast_aug_data(&mut self) -> DropGuard {
        let data = self
            .aug_data_store
            .get_my_aug_data()
            .unwrap_or_else(|| D::generate(&self.config, &self.fast_config));
        // Add it synchronously to avoid race that it sends to others but panics before it persists locally.
        self.aug_data_store
            .add_aug_data(data.clone())
            .expect("Add self aug data should succeed");
        let aug_ack = AugDataCertBuilder::new(data.clone(), self.epoch_state.clone());
        let rb = self.reliable_broadcast.clone();
        let rb2 = self.reliable_broadcast.clone();
        let validators = self.epoch_state.verifier.get_ordered_account_addresses();
        let maybe_existing_certified_data = self.aug_data_store.get_my_certified_aug_data();
        let phase1 = async move {
            if let Some(certified_data) = maybe_existing_certified_data {
                info!("[RandManager] Already have certified aug data");
                return certified_data;
            }
            info!("[RandManager] Start broadcasting aug data");
            info!(LogSchema::new(LogEvent::BroadcastAugData)
                .author(*data.author())
                .epoch(data.epoch()));
            let certified_data = rb.broadcast(data, aug_ack).await.expect("cannot fail");
            info!("[RandManager] Finish broadcasting aug data");
            certified_data
        };
        let ack_state = Arc::new(CertifiedAugDataAckState::new(validators.into_iter()));
        let task = phase1.then(|certified_data| async move {
            info!(LogSchema::new(LogEvent::BroadcastCertifiedAugData)
                .author(*certified_data.author())
                .epoch(certified_data.epoch()));
            info!("[RandManager] Start broadcasting certified aug data");
            rb2.broadcast(certified_data, ack_state)
                .await
                .expect("Broadcast cannot fail");
            info!("[RandManager] Finish broadcasting certified aug data");
        });
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        DropGuard::new(abort_handle)
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L378-382)
```rust
        while !self.stop {
            tokio::select! {
                Some(blocks) = incoming_blocks.next(), if self.aug_data_store.my_certified_aug_data_exists() => {
                    self.process_incoming_blocks(blocks);
                }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L452-461)
```rust
                        RandMessage::CertifiedAugData(certified_aug_data) => {
                            info!(LogSchema::new(LogEvent::ReceiveCertifiedAugData)
                                .author(self.author)
                                .epoch(certified_aug_data.epoch())
                                .remote_peer(*certified_aug_data.author()));
                            match self.aug_data_store.add_certified_aug_data(certified_aug_data) {
                                Ok(ack) => self.process_response(protocol, response_sender, RandMessage::CertifiedAugDataAck(ack)),
                                Err(e) => error!("[RandManager] Failed to add certified aug data: {}", e),
                            }
                        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L580-620)
```rust
#[derive(Clone)]
pub struct RandConfig {
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    // public parameters of the weighted VUF
    vuf_pp: WvufPP,
    // key shares for weighted VUF
    keys: Arc<RandKeys>,
    // weighted config for weighted VUF
    wconfig: WeightedConfigBlstrs,
}

impl Debug for RandConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "RandConfig {{ epoch: {}, author: {}, wconfig: {:?} }}",
            self.epoch, self.author, self.wconfig
        )
    }
}

impl RandConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        vuf_pp: WvufPP,
        keys: RandKeys,
        wconfig: WeightedConfigBlstrs,
    ) -> Self {
        Self {
            author,
            epoch,
            validator,
            vuf_pp,
            keys: Arc::new(keys),
            wconfig,
        }
    }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```

**File:** types/src/randomness.rs (L103-136)
```rust
#[derive(Clone, SilentDebug)]
pub struct RandKeys {
    // augmented secret / public key share of this validator, obtained from the DKG transcript of last epoch
    pub ask: ASK,
    pub apk: APK,
    // certified augmented public key share of all validators,
    // obtained from all validators in the new epoch,
    // which necessary for verifying randomness shares
    pub certified_apks: Vec<OnceCell<APK>>,
    // public key share of all validators, obtained from the DKG transcript of last epoch
    pub pk_shares: Vec<PKShare>,
}

impl RandKeys {
    pub fn new(ask: ASK, apk: APK, pk_shares: Vec<PKShare>, num_validators: usize) -> Self {
        let certified_apks = vec![OnceCell::new(); num_validators];

        Self {
            ask,
            apk,
            certified_apks,
            pk_shares,
        }
    }

    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
}
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L98-100)
```rust
    pub fn my_certified_aug_data_exists(&self) -> bool {
        self.certified_data.contains_key(&self.config.author())
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L117-131)
```rust
    pub fn add_certified_aug_data(
        &mut self,
        certified_data: CertifiedAugData<D>,
    ) -> anyhow::Result<CertifiedAugDataAck> {
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
        self.db.save_certified_aug_data(&certified_data)?;
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
        self.certified_data
            .insert(*certified_data.author(), certified_data);
        Ok(CertifiedAugDataAck::new(self.epoch))
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L41-89)
```rust
    pub fn try_aggregate(
        self,
        rand_config: &RandConfig,
        rand_metadata: FullRandMetadata,
        decision_tx: Sender<Randomness>,
    ) -> Either<Self, RandShare<S>> {
        if self.total_weight < rand_config.threshold() {
            return Either::Left(self);
        }
        match self.path_type {
            PathType::Fast => {
                observe_block(
                    rand_metadata.timestamp,
                    BlockStage::RAND_ADD_ENOUGH_SHARE_FAST,
                );
            },
            PathType::Slow => {
                observe_block(
                    rand_metadata.timestamp,
                    BlockStage::RAND_ADD_ENOUGH_SHARE_SLOW,
                );
            },
        }

        let rand_config = rand_config.clone();
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
        tokio::task::spawn_blocking(move || {
            let maybe_randomness = S::aggregate(
                self.shares.values(),
                &rand_config,
                rand_metadata.metadata.clone(),
            );
            match maybe_randomness {
                Ok(randomness) => {
                    let _ = decision_tx.unbounded_send(randomness);
                },
                Err(e) => {
                    warn!(
                        epoch = rand_metadata.metadata.epoch,
                        round = rand_metadata.metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
        Either::Right(self_share)
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L280-312)
```rust
    pub fn add_share(&mut self, share: RandShare<S>, path: PathType) -> anyhow::Result<bool> {
        ensure!(
            share.metadata().epoch == self.epoch,
            "Share from different epoch"
        );
        ensure!(
            share.metadata().round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );
        let rand_metadata = share.metadata().clone();

        let (rand_config, rand_item) = if path == PathType::Fast {
            match (self.fast_rand_config.as_ref(), self.fast_rand_map.as_mut()) {
                (Some(fast_rand_config), Some(fast_rand_map)) => (
                    fast_rand_config,
                    fast_rand_map
                        .entry(rand_metadata.round)
                        .or_insert_with(|| RandItem::new(self.author, path)),
                ),
                _ => anyhow::bail!("Fast path not enabled"),
            }
        } else {
            (
                &self.rand_config,
                self.rand_map
                    .entry(rand_metadata.round)
                    .or_insert_with(|| RandItem::new(self.author, PathType::Slow)),
            )
        };

        rand_item.add_share(share, rand_config)?;
        rand_item.try_aggregate(rand_config, self.decision_tx.clone());
        Ok(rand_item.has_decision())
```
