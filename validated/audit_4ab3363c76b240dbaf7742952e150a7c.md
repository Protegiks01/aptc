# Audit Report

## Title
Non-Deterministic Cache Flush Causes Consensus Failure Through Divergent Type Identity

## Summary
The Move VM's cache flush mechanism can cause consensus failure when validators flush their interned module ID and struct name caches at different times based on non-deterministic local cache sizes. This leads to the same struct types receiving different internal indices, causing type equality comparisons to produce different results and divergent state roots across validators.

## Finding Description

The vulnerability stems from a design flaw where implementation details (interned indices) participate in type identity comparisons, combined with non-deterministic cache flushing across validators.

**Root Cause Chain:**

The `check_ready()` function flushes caches when local size thresholds are exceeded. [1](#0-0) 

Different validators accumulate different cache states over time, as the RuntimeEnvironment persists across blocks via Arc cloning. [2](#0-1) 

When flush is called, all interner mappings are cleared and indices restart from 0. [3](#0-2)  The struct name index map is also cleared. [4](#0-3) 

`InternedModuleId` derives comparison traits that make it participate in equality checks. [5](#0-4) 

**Critical Design Flaw:** `StructIdentifier` contains `interned_module_id` as a field and derives all comparison traits. [6](#0-5)  By Rust's derive semantics, all fields participate in equality - meaning two `StructIdentifier` instances with identical module and name but different `interned_module_id` values are considered UNEQUAL.

This `StructIdentifier` is used as a key in a BTreeMap. [7](#0-6)  Different `interned_module_id` values cause identical structs to map to different `StructNameIndex` values. [8](#0-7) 

The `Type` enum uses `StructNameIndex` and derives equality traits. [9](#0-8)  This causes type equality comparisons to diverge when validators have different index mappings.

**Consensus Failure Scenario:**

When Validator A has 95 interned module IDs and Validator B has 105, and the threshold is 100:
- Validator A: No flush, continues with existing indices
- Validator B: Flushes, restarts indices from 0

Both process an identical transaction referencing `0x1::coin::Coin`:
- Both create `StructIdentifier` via the constructor. [10](#0-9) 
- Validator A gets `InternedModuleId(95)`, Validator B gets `InternedModuleId(0)`
- These create different `StructIdentifier` instances (different `interned_module_id` fields)
- BTreeMap lookups treat these as different keys
- Different `StructNameIndex` assignments result
- Different `Type::Struct` values are created
- Type comparisons during execution diverge
- **Different state roots â†’ CONSENSUS FAILURE**

## Impact Explanation

**Critical Severity** - This vulnerability satisfies the Aptos bug bounty criteria for "Consensus/Safety Violations":

1. **Consensus Safety Violation**: Validators executing identical transactions in identical blocks produce different state roots, violating Byzantine Fault Tolerance assumptions. This breaks the fundamental consensus invariant that honest validators must agree on state.

2. **Non-Recoverable Network Partition**: Once validators diverge on state roots, they cannot reconcile without manual intervention. The network splits into incompatible chains requiring a hardfork to resolve.

3. **Universal Impact**: Any transaction involving struct types (virtually all Move transactions) can trigger divergence once cache states differ. This affects all users and applications.

The vulnerability causes the most severe category of blockchain failure: permanent consensus divergence requiring hardfork intervention.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Passive Occurrence**: Cache divergence happens naturally without any attacker action. Different validators experience different transaction histories due to network delays, node restarts, and timing variations - all normal in distributed systems.

2. **Inevitable Threshold Crossing**: Fixed thresholds (e.g., max_interned_module_ids=100) will be crossed at different blocks by different validators as they process transactions. This is guaranteed to occur over time.

3. **No Attack Required**: Unlike active attacks requiring malicious transactions or validator collusion, this vulnerability manifests from normal network operation. No adversarial action is needed.

4. **Continuous Risk Window**: Once any two validators have divergent cache states (which will happen), every subsequent block execution carries risk of consensus failure whenever struct types are involved.

## Recommendation

Remove `interned_module_id` from `StructIdentifier`'s equality and hash implementations. The interned ID is an optimization detail and should not participate in type identity:

```rust
// In runtime_types.rs
#[derive(Debug, Clone)]
pub struct StructIdentifier {
    module: ModuleId,
    interned_module_id: InternedModuleId,  // Keep for performance
    name: Identifier,
}

// Implement custom Eq/Hash that excludes interned_module_id
impl PartialEq for StructIdentifier {
    fn eq(&self, other: &Self) -> bool {
        self.module == other.module && self.name == other.name
    }
}

impl Eq for StructIdentifier {}

impl Hash for StructIdentifier {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.module.hash(state);
        self.name.hash(state);
    }
}

impl Ord for StructIdentifier {
    fn cmp(&self, other: &Self) -> Ordering {
        (&self.module, &self.name).cmp(&(&other.module, &other.name))
    }
}

impl PartialOrd for StructIdentifier {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
```

This ensures struct identity depends only on logical properties (module address, module name, struct name), not implementation details (interned indices).

## Proof of Concept

```rust
#[test]
fn test_struct_identifier_equality_with_different_interned_ids() {
    use move_core_types::{account_address::AccountAddress, identifier::Identifier, language_storage::ModuleId};
    use move_vm_types::{loaded_data::runtime_types::StructIdentifier, module_id_interner::InternedModuleIdPool};
    
    // Simulate two validators with different cache states
    let pool_a = InternedModuleIdPool::new();
    let pool_b = InternedModuleIdPool::new();
    
    // Validator A has accumulated 95 entries
    for i in 0..95 {
        let module = ModuleId::new(AccountAddress::random(), Identifier::new(format!("m{}", i)).unwrap());
        pool_a.intern(module);
    }
    
    // Validator B has been flushed (starts at 0)
    
    // Both process same transaction with 0x1::coin::Coin
    let module = ModuleId::new(AccountAddress::ONE, Identifier::new("coin").unwrap());
    let name = Identifier::new("Coin").unwrap();
    
    let struct_id_a = StructIdentifier::new(&pool_a, module.clone(), name.clone());
    let struct_id_b = StructIdentifier::new(&pool_b, module, name);
    
    // These should be equal (same module and name) but current implementation makes them unequal
    assert_ne!(struct_id_a.interned_module_id(), struct_id_b.interned_module_id());
    assert_ne!(struct_id_a, struct_id_b);  // BUG: Should be equal!
    
    // This inequality causes different BTreeMap keys, leading to consensus failure
}
```

## Notes

This vulnerability demonstrates a subtle but critical design error: conflating performance optimizations (interning) with semantic identity. The interned module ID is meant solely to reduce memory usage and speed up internal operations, but its inclusion in equality checks makes it part of the type's logical identity. This creates non-determinism across validators that should be deterministic, causing consensus failure.

The fix requires careful implementation to maintain the performance benefits of interning while removing it from identity comparisons. Testing should verify that struct identifiers with the same logical properties but different interned indices are treated as equal in all comparison contexts.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L162-166)
```rust
        if num_interned_module_ids > config.max_interned_module_ids {
            runtime_environment.module_id_pool().flush();
            runtime_environment.struct_name_index_map().flush();
            self.module_cache.flush();
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L430-441)
```rust
impl Clone for RuntimeEnvironment {
    fn clone(&self) -> Self {
        Self {
            vm_config: self.vm_config.clone(),
            natives: self.natives.clone(),
            struct_name_index_map: Arc::clone(&self.struct_name_index_map),
            ty_tag_cache: Arc::clone(&self.ty_tag_cache),
            interned_ty_pool: Arc::clone(&self.interned_ty_pool),
            interned_module_id_pool: Arc::clone(&self.interned_module_id_pool),
        }
    }
}
```

**File:** third_party/move/move-vm/types/src/interner.rs (L66-71)
```rust
    fn flush(&mut self) {
        self.map.clear();
        self.vec.clear();
        self.buffer.clear();
        self.pool.clear();
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L41-44)
```rust
struct IndexMap<T: Clone + Ord> {
    forward_map: BTreeMap<T, u32>,
    backward_map: Vec<Arc<T>>,
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L61-65)
```rust
    pub fn flush(&self) {
        let mut index_map = self.0.write();
        index_map.backward_map.clear();
        index_map.forward_map.clear();
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L70-99)
```rust
    pub fn struct_name_to_idx(
        &self,
        struct_name: &StructIdentifier,
    ) -> PartialVMResult<StructNameIndex> {
        {
            let index_map = self.0.read();
            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }
        }

        // Possibly need to insert, so make the copies outside of the lock.
        let forward_key = struct_name.clone();
        let backward_value = Arc::new(struct_name.clone());

        let idx = {
            let mut index_map = self.0.write();

            if let Some(idx) = index_map.forward_map.get(struct_name) {
                return Ok(StructNameIndex(*idx));
            }

            let idx = index_map.backward_map.len() as u32;
            index_map.backward_map.push(backward_value);
            index_map.forward_map.insert(forward_key, idx);
            idx
        };

        Ok(StructNameIndex(idx))
    }
```

**File:** third_party/move/move-vm/types/src/module_id_interner.rs (L7-8)
```rust
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
pub struct InternedModuleId(usize);
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L262-267)
```rust
#[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StructIdentifier {
    module: ModuleId,
    interned_module_id: InternedModuleId,
    name: Identifier,
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L270-277)
```rust
    pub fn new(module_id_pool: &InternedModuleIdPool, module: ModuleId, name: Identifier) -> Self {
        let interned_module_id = module_id_pool.intern_by_ref(&module);
        Self {
            module,
            interned_module_id,
            name,
        }
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L296-331)
```rust
#[derive(Debug, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Type {
    Bool,
    U8,
    U64,
    U128,
    Address,
    Signer,
    Vector(TriompheArc<Type>),
    Struct {
        idx: StructNameIndex,
        ability: AbilityInfo,
    },
    StructInstantiation {
        idx: StructNameIndex,
        ty_args: TriompheArc<Vec<Type>>,
        ability: AbilityInfo,
    },
    Function {
        args: Vec<Type>,
        results: Vec<Type>,
        abilities: AbilitySet,
    },
    Reference(Box<Type>),
    MutableReference(Box<Type>),
    TyParam(u16),
    U16,
    U32,
    U256,
    I8,
    I16,
    I32,
    I64,
    I128,
    I256,
}
```
