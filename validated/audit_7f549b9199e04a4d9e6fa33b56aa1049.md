> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4)

### Citations

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L140-149)
```rust
        let subst_res = ty_builder.create_ty_with_subst(ty, func.ty_args());
        let ty = subst_res.map_err(|e| e.finish(Location::Undefined).into_vm_status())?;
        let valid = is_valid_txn_arg(loader.runtime_environment(), &ty, allowed_structs);
        if !valid {
            return Err(VMStatus::error(
                StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
                None,
            ));
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L411-500)
```rust
fn validate_and_construct(
    session: &mut SessionExt<impl AptosMoveResolver>,
    loader: &impl Loader,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    expected_type: &Type,
    constructor: &FunctionId,
    allowed_structs: &ConstructorMap,
    cursor: &mut Cursor<&[u8]>,
    initial_cursor_len: usize,
    max_invocations: &mut u64,
) -> Result<Vec<u8>, VMStatus> {
    if *max_invocations == 0 {
        return Err(VMStatus::error(
            StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
            None,
        ));
    }
    // HACK mitigation of performance attack
    // To maintain compatibility with vector<string> or so on, we need to allow unlimited strings.
    // So we do not count the string constructor against the max_invocations, instead we
    // shortcut the string case to avoid the performance attack.
    if constructor.func_name.as_str() == "utf8" {
        let constructor_error = || {
            // A slight hack, to prevent additional piping of the feature flag through all
            // function calls. We know the feature is active when more structs then just strings are
            // allowed.
            let are_struct_constructors_enabled = allowed_structs.len() > 1;
            if are_struct_constructors_enabled {
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
        };
        // Short cut for the utf8 constructor, which is a special case.
        let len = get_len(cursor)?;
        if cursor
            .position()
            .checked_add(len as u64)
            .is_none_or(|l| l > initial_cursor_len as u64)
        {
            // We need to make sure we do not allocate more bytes than
            // needed.
            return Err(VMStatus::error(
                StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT,
                Some("String argument is too long".to_string()),
            ));
        }

        let mut arg = vec![];
        read_n_bytes(len, cursor, &mut arg)?;
        std::str::from_utf8(&arg).map_err(|_| constructor_error())?;
        return bcs::to_bytes(&arg)
            .map_err(|_| VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None));
    } else {
        *max_invocations -= 1;
    }

    let function = load_constructor_function(
        loader,
        gas_meter,
        traversal_context,
        &constructor.module_id,
        constructor.func_name,
        expected_type,
    )?;
    let mut args = vec![];
    let ty_builder = &loader.runtime_environment().vm_config().ty_builder;
    for param_ty in function.param_tys() {
        let mut arg = vec![];
        let arg_ty = ty_builder
            .create_ty_with_subst(param_ty, function.ty_args())
            .unwrap();

        recursively_construct_arg(
            session,
            loader,
            gas_meter,
            traversal_context,
            &arg_ty,
            allowed_structs,
            cursor,
            initial_cursor_len,
            max_invocations,
            &mut arg,
        )?;
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1188-1203)
```rust
    pub fn create_ty_with_subst(&self, ty: &Type, ty_args: &[Type]) -> PartialVMResult<Type> {
        let mut count = 0;
        let check = |c: &mut u64, d: u64| self.check(c, d);
        self.subst_impl(ty, ty_args, &mut count, 1, check)
    }

    #[inline]
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1800-1813)
```rust
    #[test]
    fn test_substitution_large_depth() {
        use Type::*;

        let ty_builder = TypeBuilder::with_limits(11, 5);

        let ty = Vector(TriompheArc::new(Vector(TriompheArc::new(TyParam(0)))));
        let ty_arg = Vector(TriompheArc::new(Vector(TriompheArc::new(Bool))));
        assert_ok!(ty_builder.create_ty_with_subst(&ty, std::slice::from_ref(&ty_arg)));

        let ty_arg = Vector(TriompheArc::new(ty_arg));
        let err = assert_err!(ty_builder.create_ty_with_subst(&ty, &[ty_arg]));
        assert_eq!(err.major_status(), StatusCode::VM_MAX_TYPE_DEPTH_REACHED);
    }
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L210-230)
```rust
                        .local_tys()
                        .iter()
                        .map(|ty| ty_builder.create_ty_with_subst(ty, ty_args))
                        .collect::<PartialVMResult<Vec<_>>>()
                        .map(Rc::from)?;
                    cache_borrow.instantiated_local_tys = Some(local_tys.clone());
                    LocalTys::BorrowFromFunctionGeneric(local_tys)
                }
            } else {
                LocalTys::None
            }
        };

        Ok(Frame {
            pc: 0,
            ty_builder,
            locals,
            function,
            _guard: guard,
            call_type,
            local_tys,
```
