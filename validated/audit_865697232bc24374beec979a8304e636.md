# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Breaks Consensus Determinism

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization that breaks consensus determinism when validators receive semantically identical JWKs with different key orderings from OIDC providers. This prevents signature aggregation and causes total liveness failure for the JWK consensus subsystem.

## Finding Description

The vulnerability exists in the conversion of unsupported JSON Web Keys to the `UnsupportedJWK` type. When validators fetch JWKs from OIDC providers, any JWK that doesn't match the RSA format (checked at kty == "RSA") falls back to creating an `UnsupportedJWK`. [1](#0-0) 

This conversion uses `json_value.to_string()` which does NOT guarantee canonical JSON serialization, as explicitly noted in the TODO comment. [2](#0-1) 

The workspace configuration enables serde_json's `preserve_order` feature, which preserves the insertion order of JSON object keys as they were parsed. [3](#0-2) 

When validators fetch JWKs from OIDC providers, they parse the JSON response and convert each key to a JWK enum. [4](#0-3)  The conversion attempts RSA parsing first, then falls back to UnsupportedJWK for non-RSA keys. [5](#0-4) 

**Critical Consensus Failure Point:**

During reliable broadcast, when validators exchange their observations, the `ObservationAggregationState` performs an equality check between the local view and peer view. [6](#0-5) 

If two validators receive the same JWK with different key orderings (e.g., `{"kty":"EC","kid":"abc"}` vs `{"kid":"abc","kty":"EC"}`), they will:
1. Parse with preserved order
2. Create UnsupportedJWK instances with different payload bytes
3. Compute different SHA3-256 ID hashes
4. Have different `ProviderJWKs` structures (which derive `BCSCryptoHash` and `CryptoHasher`) [7](#0-6) 
5. Fail the equality check at line 82-84
6. Never aggregate signatures
7. Never reach quorum

The multi-signature verification in the VM requires validators to have signed identical data. [8](#0-7) 

## Impact Explanation

**Severity: Critical**

This vulnerability causes **total liveness failure for the JWK consensus subsystem**, which qualifies as Critical severity:

- **Complete subsystem liveness loss**: Validators cannot reach consensus on any JWK update when unsupported key formats are encountered
- **Affects critical authentication mechanism**: Keyless accounts depending on these JWKs cannot authenticate if JWK sets become stale
- **All validators affected simultaneously**: This is not a single-node issue but a determinism break affecting the entire validator set
- **No automatic recovery**: Requires either removing the problematic OIDC provider from on-chain configuration or implementing a code fix
- **Can be triggered accidentally**: Legitimate OIDC providers using different backend servers, load balancers, or CDNs naturally produce different key orderings

The vulnerability can be triggered by:
1. Any OIDC provider serving non-RSA JWK types (EC, OKP, etc.) which are standard in the OIDC ecosystem
2. Different validators receiving responses from different backend servers with different JSON serialization implementations
3. CDN caching with different serialization orders
4. Load balancer routing to different endpoints

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **No attacker privileges required**: Can be triggered by any OIDC provider (Google, Facebook, Apple, Microsoft) serving standard EC or EdDSA keys
2. **Common key types trigger it**: EC keys (P-256, P-384) and EdDSA keys (Ed25519) are increasingly common in OIDC providers and will all fail RSA parsing
3. **Natural occurrence**: Different backend servers, JSON libraries, and CDN implementations naturally produce different key orderings
4. **No mitigations in place**: The code acknowledges the issue with a TODO comment but implements no protective measures
5. **Observable in production**: As soon as any configured OIDC provider rotates to or adds a non-RSA key type, this will trigger

The system has the `preserve_order` feature enabled globally, making it susceptible to insertion-order differences from the source.

## Recommendation

Implement canonical JSON serialization for UnsupportedJWK payload generation. Use a deterministic serialization algorithm that sorts object keys alphabetically:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Canonicalize by re-serializing with sorted keys
        let canonical_payload = canonical_json_bytes(&json_value);
        Self {
            id: HashValue::sha3_256_of(canonical_payload.as_slice()).to_vec(),
            payload: canonical_payload,
        }
    }
}

fn canonical_json_bytes(value: &serde_json::Value) -> Vec<u8> {
    // Convert to BTreeMap to ensure sorted keys, then serialize
    let canonical = canonicalize_value(value);
    serde_json::to_vec(&canonical).expect("serialization cannot fail")
}

fn canonicalize_value(value: &serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::Object(map) => {
            let mut btree: std::collections::BTreeMap<String, serde_json::Value> = map
                .iter()
                .map(|(k, v)| (k.clone(), canonicalize_value(v)))
                .collect();
            serde_json::Value::Object(btree.into_iter().collect())
        }
        serde_json::Value::Array(arr) => {
            serde_json::Value::Array(arr.iter().map(canonicalize_value).collect())
        }
        other => other.clone(),
    }
}
```

Alternatively, follow the pattern used in WebAuthn's `collected_client_data_to_json_bytes` function which implements deterministic serialization. [9](#0-8) 

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_non_canonical_vulnerability() {
    // Two semantically identical JWKs with different key orderings
    let json_a = serde_json::from_str(r#"{"kty":"EC","kid":"abc","crv":"P-256"}"#).unwrap();
    let json_b = serde_json::from_str(r#"{"kid":"abc","kty":"EC","crv":"P-256"}"#).unwrap();
    
    let jwk_a = UnsupportedJWK::from(json_a);
    let jwk_b = UnsupportedJWK::from(json_b);
    
    // These should be equal (same semantic content) but are different
    assert_ne!(jwk_a.payload, jwk_b.payload);
    assert_ne!(jwk_a.id, jwk_b.id);
    
    // This breaks consensus - validators with different orderings
    // will fail the equality check in ObservationAggregationState
    let provider_jwks_a = ProviderJWKs {
        issuer: b"test".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(jwk_a))],
    };
    
    let provider_jwks_b = ProviderJWKs {
        issuer: b"test".to_vec(),
        version: 1,
        jwks: vec![JWKMoveStruct::from(JWK::Unsupported(jwk_b))],
    };
    
    // Consensus check fails
    assert_ne!(provider_jwks_a, provider_jwks_b);
}
```

## Notes

This vulnerability demonstrates a critical consensus determinism break in the JWK update mechanism. The codebase shows awareness of the issue through the TODO comment but has not implemented a fix. The comparison with WebAuthn's canonical serialization implementation shows that the team understands the need for deterministic serialization in consensus-critical paths but has not yet applied it to the JWK system.

### Citations

**File:** types/src/jwks/rsa/mod.rs (L143-146)
```rust
        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );
```

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** Cargo.toml (L789-792)
```text
serde_json = { version = "1.0.81", features = [
    "preserve_order",
    "arbitrary_precision",
] } # Note: arbitrary_precision is required to parse u256 in JSON
```

**File:** crates/jwk-utils/src/lib.rs (L34-36)
```rust
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L139-142)
```rust
        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** types/src/transaction/webauthn.rs (L418-450)
```rust
    /// This is the custom serialization of [`CollectedClientData`](CollectedClientData)
    /// that is performed by the device authenticator, referenced in the WebAuthn spec, under
    /// Section ยง5.8.1.1 Serialization.
    ///
    /// This is helpful for ensuring that the serialization of [`CollectedClientData`](CollectedClientData)
    /// is identical to the device authenticator's output for clientDataJSON in client assertions.
    ///
    /// The serialization of the [`CollectedClientData`](CollectedClientData)
    /// is a subset of the algorithm for JSON-serializing
    /// to bytes. I.e. it produces a valid JSON encoding of the `CollectedClientData` but also provides
    /// additional structure that may be exploited by verifiers to avoid integrating a full JSON parser.
    /// While verifiers are recommended to perform standard JSON parsing, they may use the more
    /// limited algorithm below in contexts where a full JSON parser is too large. This verification
    /// algorithm requires only base64url encoding, appending of bytestrings (which could be
    /// implemented by writing into a fixed template), and three conditional checks (assuming that
    /// inputs are known not to need escaping).
    ///
    /// The serialization algorithm works by appending successive byte strings to an, initially empty,
    /// partial result until the complete result is obtained.
    ///
    /// 1. Let result be an empty byte string.
    /// 2. Append 0x7b2274797065223a ({"type":) to result.
    /// 3. Append CCDToString(type) to result.
    /// 4. Append 0x2c226368616c6c656e6765223a (,"challenge":) to result.
    /// 5. Append CCDToString(challenge) to result.
    /// 6. Append 0x2c226f726967696e223a (,"origin":) to result.
    /// 7. Append CCDToString(origin) to result.
    /// 8. Append 0x2c2263726f73734f726967696e223a (,"crossOrigin":) to result.
    /// 9. If crossOrigin is not present, or is false:
    ///     1. Append 0x66616c7365 (false) to result.
    /// 10. Otherwise:
    ///     1. Append 0x74727565 (true) to result.
    /// 11. Create a temporary copy of the CollectedClientData and remove the fields
```
