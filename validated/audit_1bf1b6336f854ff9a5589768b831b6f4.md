# Audit Report

## Title
Allocator Reentrancy in jemalloc Stats Collection Callback Causes Validator Node Deadlock

## Summary
The `write_cb()` callback function in the admin service's malloc stats endpoint contains a logic error that incorrectly checks total Vec capacity instead of remaining capacity when accumulating jemalloc statistics. This causes Vec reallocation during the callback, triggering recursive jemalloc calls while jemalloc holds internal locks, resulting in deadlock that crashes validator nodes.

## Finding Description

The vulnerability exists in the `write_cb()` unsafe C callback function that accumulates jemalloc statistics into a Rust `Vec<u8>`. [1](#0-0) 

**The Core Bug:**

The callback incorrectly computes the truncation length by checking total capacity (`out.capacity()`) instead of remaining capacity (`out.capacity() - out.len()`). [2](#0-1)  When jemalloc calls this callback multiple times with streaming statistics output, the accumulated data can exceed the pre-allocated capacity, causing `Vec::extend_from_slice()` to reallocate. [3](#0-2) 

**Exploitation Mechanism:**

1. The `/malloc/stats` endpoint is called with the default `malloc_stats_max_len` of 2MB. [4](#0-3) 

2. A Vec with 2MB capacity is created via `Vec::with_capacity(max_len)` but starts with length 0. [5](#0-4) 

3. `malloc_stats_print()` calls `write_cb` multiple times to stream output. [6](#0-5) 

4. **Critical flaw**: Each callback computes `len = min(capacity, incoming_len)`, ignoring how much data is already accumulated. This allows accumulated data to exceed the pre-allocated capacity.

5. When accumulated length exceeds capacity, `extend_from_slice` triggers reallocation.

6. Reallocation invokes the global allocator (jemalloc) via Rust's allocator API. [7](#0-6) 

7. Jemalloc is already executing `malloc_stats_print()` with internal mutexes held.

8. **Reentrancy violation**: Jemalloc attempts to acquire locks it already holds â†’ deadlock or undefined behavior.

The developer comment explicitly acknowledges the reentrancy constraint that this bug violates. [8](#0-7) 

**Access Control Context:**

The admin service exposes this endpoint on port 9102 by default. [9](#0-8) 

The endpoint is routed through the admin service handler. [10](#0-9) 

On testnet/devnet, the admin service is enabled by default without authentication. [11](#0-10) 

On mainnet, authentication is required. [12](#0-11) 

**Jemalloc Configuration:**

Jemalloc is configured as the global allocator with profiling enabled. [13](#0-12) 

With `prof:true` profiling, jemalloc statistics include per-arena details, per-size-class allocations, large allocation tracking with stack traces, and extensive metadata. For long-running validator nodes, profiled statistics can plausibly exceed 2MB.

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria

This vulnerability aligns with the following HIGH severity impacts:

1. **Validator Node Slowdowns**: When Vec reallocation triggers reentrancy, jemalloc deadlocks attempting to acquire locks it already holds. Since jemalloc is the global allocator, the entire validator node process becomes permanently unresponsive and cannot participate in consensus, directly impacting network liveness.

2. **API Crashes**: If jemalloc's internal state is corrupted during reentrancy (rather than clean deadlock), this can lead to heap metadata corruption, use-after-free vulnerabilities, or double-free crashes affecting the entire node process.

3. **Consensus Impact**: Multiple validators calling this endpoint simultaneously (e.g., automated monitoring systems) could deadlock multiple validators concurrently. If sufficient validators are affected, network liveness degrades.

4. **Denial of Service**: Attackers with unauthenticated access on testnet/devnet can reliably trigger validator crashes by calling this endpoint, especially on long-running nodes with accumulated allocation history.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Factors Increasing Likelihood:**
- Jemalloc profiling enabled by default increases stats output size significantly
- Validator nodes run continuously for days/weeks, accumulating allocation history
- The 2MB default buffer size suggests developers anticipated large outputs
- No runtime checks prevent reallocation
- Admin service enabled by default on testnet/devnet without authentication
- Unauthenticated access on testnet/devnet allows any network participant to trigger

**Factors Decreasing Likelihood:**
- Requires statistics output to exceed 2MB across multiple callback invocations (uncertain without real-world testing)
- Requires admin endpoint access on mainnet (authentication barrier)
- Depends on active monitoring or debugging scenarios

The bug itself is a **logic vulnerability** that demonstrably violates the code's explicit safety requirement.

## Recommendation

Fix the capacity check to account for already-accumulated data:

```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let remaining_capacity = out.capacity() - out.len();
    let len = std::cmp::min(remaining_capacity, stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

This ensures that `extend_from_slice` never attempts to add more data than fits in the remaining capacity, preventing reallocation within the callback.

## Proof of Concept

A complete PoC would require empirical testing on a long-running validator node with profiling enabled to demonstrate that jemalloc stats can exceed 2MB. However, the logic vulnerability is demonstrable through code inspection:

1. Deploy a testnet/devnet validator node with default configuration
2. Allow node to accumulate allocation history over time
3. Call `GET http://<validator-ip>:9102/malloc/stats`
4. If accumulated jemalloc profiling stats exceed 2MB across multiple callback invocations, the Vec will reallocate during the callback, triggering the reentrancy deadlock

The vulnerability can be validated by adding instrumentation to log `out.len()` and `out.capacity()` at each callback invocation to confirm when reallocation would occur.

## Notes

This is a demonstrable logic vulnerability that violates the code's documented safety requirements. While the exact triggering conditions require empirical validation, the bug itself is objectively present and creates a realistic attack vector on testnet/devnet deployments where the admin service is exposed without authentication.

### Citations

**File:** crates/aptos-admin-service/src/server/malloc.rs (L14-20)
```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let len = std::cmp::min(out.capacity(), stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L25-25)
```rust
    let mut stats = Vec::with_capacity(max_len);
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L27-31)
```rust
        jemalloc_sys::malloc_stats_print(
            Some(write_cb),
            &mut stats as *mut _ as *mut c_void,
            std::ptr::null(),
        );
```

**File:** config/src/config/admin_service_config.rs (L46-46)
```rust
            port: 9102,
```

**File:** config/src/config/admin_service_config.rs (L48-48)
```rust
            malloc_stats_max_len: 2 * 1024 * 1024,
```

**File:** config/src/config/admin_service_config.rs (L69-76)
```rust
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L94-101)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

```

**File:** aptos-node/src/main.rs (L11-12)
```rust
#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
```

**File:** aptos-node/src/main.rs (L19-19)
```rust
pub static mut malloc_conf: *const c_char = c"prof:true,lg_prof_sample:23".as_ptr().cast();
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L189-191)
```rust
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
```
