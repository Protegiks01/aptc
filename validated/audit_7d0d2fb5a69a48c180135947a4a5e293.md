# Audit Report

## Title
Quorum Store V2 Messages Silently Dropped Due to Unhandled Message Types in NetworkTask

## Summary
The `NetworkTask::start()` function's Event::Message handler does not match the V2 variants of quorum store messages (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2), causing them to fall through to the default case where they are silently dropped with only a warning. This breaks quorum store functionality when V2 batches are enabled.

## Finding Description
The vulnerability exists in the message routing logic of the consensus network layer. The ConsensusMsg enum contains V2 variants for quorum store messages to support the extended BatchInfoExt type: [1](#0-0) 

However, the NetworkTask::start() function's Event::Message handler only matches the V1 variants: [2](#0-1) 

The V2 variants (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2) are not included in this pattern match. When these messages are received, they fall through to the default case which logs a warning and drops the message: [3](#0-2) 

Production code actively sends these V2 messages when the enable_batch_v2 configuration flag is enabled: [4](#0-3) [5](#0-4) [6](#0-5) 

The network sender implementations correctly construct and broadcast these V2 messages: [7](#0-6) [8](#0-7) [9](#0-8) 

**Additional Critical Finding**: Even if NetworkTask were fixed, there is a second failure point in the EpochManager's check_epoch() method, which also does not match V2 variants: [10](#0-9) [11](#0-10) 

**Attack Path**: When enable_batch_v2 is enabled:
1. Batch generator creates V2 batches and broadcasts BatchMsgV2
2. Receiving validators' NetworkTask receives these messages
3. Messages fail to match any pattern in Event::Message handler
4. Messages hit default case and are silently dropped
5. Validators never receive batch data, breaking quorum store protocol
6. Consensus cannot progress without functioning quorum store

## Impact Explanation
This is a **Medium Severity** vulnerability that causes protocol violations when the enable_batch_v2 flag is enabled:

1. **Quorum Store Failure**: Validators cannot exchange batch information, signed batch info, or proofs of store, breaking the quorum store protocol which is critical for consensus operation.

2. **Protocol Violation**: Validators that enable V2 support cannot properly participate in the consensus protocol because they cannot exchange quorum store messages.

3. **Configuration-Dependent Impact**: The issue only manifests when enable_batch_v2 is enabled: [12](#0-11) [13](#0-12) 

While this meets the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations," the impact is conditional upon enabling a configuration flag that defaults to false. This reduces the effective severity to Medium rather than High.

## Likelihood Explanation
**Likelihood: Low-Medium**

This vulnerability triggers when:
1. The `enable_batch_v2` configuration flag is enabled (defaults to false)
2. Validators create and broadcast V2 batches

The configuration flag defaults to false, and there is no evidence of production use. The code appears to be in-progress V2 support that was not fully integrated. However, the likelihood increases if:
- V2 batch support is tested or rolled out
- Validators experiment with the flag
- Future upgrades enable this feature by default

The systematic nature of the bug (affecting multiple message types across two code locations) indicates this was an oversight during V2 implementation rather than an edge case.

## Recommendation
Fix the NetworkTask::start() Event::Message handler to include V2 variants in the pattern match:

```rust
quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::BatchMsg(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::SignedBatchInfoMsgV2(_)  // Add V2 variant
| ConsensusMsg::BatchMsgV2(_)             // Add V2 variant
| ConsensusMsg::ProofOfStoreMsgV2(_)) => { // Add V2 variant
    Self::push_msg(
        peer_id,
        quorum_store_msg,
        &self.quorum_store_messages_tx,
    );
},
```

Additionally, fix the EpochManager::check_epoch() method to handle V2 variants:

```rust
ConsensusMsg::BatchMsg(_)
| ConsensusMsg::BatchRequestMsg(_)
| ConsensusMsg::SignedBatchInfo(_)
| ConsensusMsg::ProofOfStoreMsg(_)
| ConsensusMsg::BatchMsgV2(_)              // Add V2 variant
| ConsensusMsg::SignedBatchInfoMsgV2(_)    // Add V2 variant
| ConsensusMsg::ProofOfStoreMsgV2(_) => {  // Add V2 variant
```

Add integration tests that verify V2 message handling end-to-end before enabling the feature in production.

## Proof of Concept
This can be demonstrated by:
1. Enabling `enable_batch_v2` in QuorumStoreConfig
2. Running a test network with multiple validators
3. Observing that V2 batch messages are sent but never processed
4. Checking logs for "Unexpected direct send msg" warnings
5. Verifying that quorum store fails to function properly

The vulnerability is in production consensus code and can be reproduced by enabling the configuration flag.

## Notes
- This affects production consensus code in the `consensus/` directory
- The bug exists in two locations: NetworkTask and EpochManager
- The V2 message types are fully defined and production code actively sends them
- The configuration flag exists and could be enabled by validators
- No tests currently cover V2 message handling, which allowed this bug to persist
- This represents incomplete implementation of V2 batch support rather than an intentional limitation

### Citations

**File:** consensus/src/network_interface.rs (L97-102)
```rust
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    /// Quorum Store: Send a signed batch digest with BatchInfoExt. This is a vote for the batch and a promise that
    /// the batch of transactions was received and will be persisted until batch expiration.
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    /// Quorum Store: Broadcast a certified proof of store (a digest that received 2f+1 votes) with BatchInfoExt.
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
```

**File:** consensus/src/network.rs (L599-609)
```rust
    async fn send_signed_batch_info_msg_v2(
        &self,
        signed_batch_infos: Vec<SignedBatchInfo<BatchInfoExt>>,
        recipients: Vec<Author>,
    ) {
        fail_point!("consensus::send::signed_batch_info", |_| ());
        let msg = ConsensusMsg::SignedBatchInfoMsgV2(Box::new(SignedBatchInfoMsg::new(
            signed_batch_infos,
        )));
        self.send(msg, recipients).await
    }
```

**File:** consensus/src/network.rs (L617-621)
```rust
    async fn broadcast_batch_msg_v2(&mut self, batches: Vec<Batch<BatchInfoExt>>) {
        fail_point!("consensus::send::broadcast_batch", |_| ());
        let msg = ConsensusMsg::BatchMsgV2(Box::new(BatchMsg::new(batches)));
        self.broadcast(msg).await
    }
```

**File:** consensus/src/network.rs (L629-633)
```rust
    async fn broadcast_proof_of_store_msg_v2(&mut self, proofs: Vec<ProofOfStore<BatchInfoExt>>) {
        fail_point!("consensus::send::proof_of_store", |_| ());
        let msg = ConsensusMsg::ProofOfStoreMsgV2(Box::new(ProofOfStoreMsg::new(proofs)));
        self.broadcast(msg).await
    }
```

**File:** consensus/src/network.rs (L823-831)
```rust
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
                        },
```

**File:** consensus/src/network.rs (L937-940)
```rust
                        _ => {
                            warn!(remote_peer = peer_id, "Unexpected direct send msg");
                            continue;
                        },
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-501)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
                            } else {
                                let batches = batches.into_iter().map(|batch| {
                                    batch.try_into().expect("Cannot send V2 batch with flag disabled")
                                }).collect();
                                network_sender.broadcast_batch_msg(batches).await;
                            }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-110)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-487)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
```

**File:** consensus/src/epoch_manager.rs (L1641-1644)
```rust
            | ConsensusMsg::BatchMsg(_)
            | ConsensusMsg::BatchRequestMsg(_)
            | ConsensusMsg::SignedBatchInfo(_)
            | ConsensusMsg::ProofOfStoreMsg(_) => {
```

**File:** consensus/src/epoch_manager.rs (L1687-1689)
```rust
            _ => {
                bail!("[EpochManager] Unexpected messages: {:?}", msg);
            },
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```
