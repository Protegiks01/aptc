# Audit Report

## Title
Layout Cache TOCTOU Race Condition Enables Consensus Divergence Through Stale Struct Layout Usage

## Summary
A time-of-check-time-of-use (TOCTOU) race condition exists in the Move VM's layout caching mechanism during BlockSTM parallel execution. The non-atomic sequence of retrieving a cached layout and re-reading modules allows another transaction to publish a module upgrade between these operations, causing the first transaction to use a stale layout with incompatible module definitions while capturing reads of the new module version. This breaks deterministic execution and can cause consensus divergence across validators.

## Finding Description

The vulnerability occurs in the layout cache retrieval flow within the Move VM runtime. The critical code path is: [1](#0-0) 

The race condition manifests as follows:

**Step 1**: Transaction T1 calls `load_layout_from_cache()` which retrieves a `LayoutCacheEntry` from the global cache at line 209. This entry contains a struct layout built from module M v0 and a list of defining modules.

**Step 2**: The entry is unpacked at line 210, creating local copies of the layout and module list in variables that exist independently of the cache state.

**Step 3**: Transaction T2 (with lower transaction index in the preset serialization order) completes execution and publishes an upgraded version of module M (v1). The module publishing process calls: [2](#0-1) 

This flushes the entire layout cache: [3](#0-2) 

And marks the old module as overridden: [4](#0-3) 

**Step 4**: T1 continues execution and enters the loop at lines 211-219 to re-read modules for gas charging. The comment claims this ensures "transaction gets invalidated on module publish," but this is incorrect. When T1 calls `charge_module()` for module M, it invokes module resolution: [5](#0-4) 

The global cache check returns `None` because the module was marked as overridden: [6](#0-5) 

**Step 5**: T1 falls through to the per-block cache: [7](#0-6) 

This returns module M v1 (the newly published version), and T1 captures this read as `ModuleRead::PerBlockCache`.

**Step 6**: T1 returns the old layout at line 220 that was built from M v0, but has now captured reads of M v1.

**Step 7**: When T1 is validated, the system checks module read consistency: [8](#0-7) 

The validation passes because T1 correctly captured the new module version and the per-block cache version is consistent. However, **validation does not check whether the cached layout matches the module versions that were read**.

**Consensus Divergence Mechanism**: 

The GlobalModuleCache is shared across all parallel worker threads executing the same block: [9](#0-8) 

Different validators may experience this race with different timing:
- **Validator A**: T1's worker thread retrieves layout BEFORE T2 commits → uses stale layout from M v0
- **Validator B**: T1's worker thread retrieves layout AFTER T2 commits and cache flush → cache miss, computes fresh layout from M v1

Both validators execute the same block with the same transactions in the same preset serialization order, but due to different parallel execution timing, they use different layouts for the same transaction. If the struct definition changed between v0 and v1 (fields added, removed, or reordered), this causes different serialization/deserialization behavior, producing different state roots.

This violates the fundamental deterministic execution invariant documented in BlockSTM: [10](#0-9) 

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability qualifies as Critical under the Aptos Bug Bounty Program for the following reasons:

1. **Consensus/Safety Violation**: The issue directly violates the "Deterministic Execution" invariant. Different validators executing the same block can produce different state roots due to timing variations in the layout cache race condition. This is a consensus safety violation that can cause the network to fail to reach agreement on block commits.

2. **Network-Wide Impact**: Every validator node running BlockSTM parallel execution is affected. Layout caching is enabled by default in production: [11](#0-10) 

3. **Non-Recoverable Divergence**: If validators diverge on state roots, they cannot reach consensus on block commits. This requires manual intervention or a hard fork to resolve, as the consensus layer relies on all validators computing identical state commitments.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability triggers under realistic conditions:

1. **Module Upgrades Common**: Module upgrades with struct definition changes occur regularly in Aptos through governance proposals and DApp updates.

2. **Parallel Execution Default**: BlockSTM parallel execution is the production default, creating the necessary concurrency for the race condition.

3. **Natural Triggering**: The vulnerability can trigger without malicious intent during normal block processing when one transaction publishes a module upgrade and another transaction uses structs from that module.

4. **Wide Race Window**: The race window spans multiple function calls between layout retrieval (line 209) and module re-reading (lines 211-219), providing substantial opportunity for interleaving.

5. **Validator Timing Differences**: Different validators naturally have different CPU scheduling, load characteristics, and hardware, making timing variations likely across the network.

An attacker could deliberately maximize the probability by:
- Publishing module upgrades with struct definition changes
- Submitting many concurrent transactions using those structs in the same block
- Exploiting the fact that different validators will experience different timing

## Recommendation

Implement atomic layout validation by ensuring that layouts are checked against the actual module versions used at validation time, not just at retrieval time. Potential fixes include:

1. **Store Module Versions with Layout**: Modify `LayoutCacheEntry` to include module version information, and validate during `validate_module_reads()` that the layout's source module versions match the captured module reads.

2. **Invalidate Transactions Using Cached Layouts**: When a module is published and the layout cache is flushed, explicitly invalidate any in-flight transactions that retrieved layouts before the flush.

3. **Atomic Layout Retrieval**: Make layout retrieval and module reading atomic by holding a lock or ensuring they read from a consistent snapshot of the cache state.

4. **Sequential Module Publishing**: Ensure module publishing transactions cannot commit while other transactions are in the middle of layout retrieval operations.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Create a Move module with a struct definition (e.g., `struct Data { field1: u64 }`)
2. Deploy transactions to a block where:
   - Transaction at index 3 publishes an upgraded version of the module changing the struct (e.g., `struct Data { field1: u64, field2: u64 }`)
   - Transaction at index 5 uses the struct for serialization/deserialization
3. Execute the block on multiple validator nodes with BlockSTM parallel execution
4. Monitor the layout cache hits/misses and module read captures
5. Observe that depending on thread scheduling:
   - Some validators have T5 retrieve the old layout before T3 commits
   - Other validators have T5 retrieve after T3 commits (cache miss)
6. Verify that both pass validation but produce different serialization results
7. Compare state roots across validators to confirm divergence

The vulnerability is exploitable in production environments where layout caching is enabled by default and BlockSTM parallel execution is active.

## Notes

This vulnerability represents a fundamental design flaw in how layout caching interacts with BlockSTM's validation mechanism. The comment at lines 212-215 in `lazy.rs` claims that re-reading modules will cause transaction invalidation on module publish, but this is demonstrably false—the validation only checks module version consistency, not layout-module version correspondence. The non-atomic nature of the layout cache operations combined with parallel execution creates a timing-dependent consensus bug that violates the core determinism guarantee of the blockchain.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L203-221)
```rust
    fn load_layout_from_cache(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        key: &StructKey,
    ) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
        Some(Ok(layout))
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L572-575)
```rust
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L99-112)
```rust
impl<K, D, V, E> GlobalModuleCache<K, D, V, E>
where
    K: Hash + Eq + Clone,
    V: Deref<Target = Arc<D>>,
    E: WithSize,
{
    /// Returns new empty module cache.
    pub fn empty() -> Self {
        Self {
            module_cache: HashMap::new(),
            size: 0,
            struct_layouts: DashMap::new(),
        }
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L124-128)
```rust
    pub fn mark_overridden(&self, key: &K) {
        if let Some(entry) = self.module_cache.get(key) {
            entry.mark_overridden();
        }
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L130-138)
```rust
    /// Returns the module stored in cache. If the module has not been cached, or it exists but is
    /// overridden, [None] is returned.
    pub fn get(&self, key: &K) -> Option<Arc<ModuleCode<D, V, E>>> {
        self.module_cache.get(key).and_then(|entry| {
            entry
                .is_not_overridden()
                .then(|| Arc::clone(entry.module_code()))
        })
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L163-168)
```rust
    pub fn flush_layout_cache(&self) {
        // TODO(layouts):
        //   Flushing is only needed because of enums. Once we refactor layouts to store a single
        //   variant instead, this can be removed.
        self.struct_layouts.clear();
    }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L155-162)
```rust
                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }
```

**File:** aptos-move/block-executor/src/code_cache.rs (L164-174)
```rust
                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1050-1089)
```rust
    pub(crate) fn validate_module_reads(
        &self,
        global_module_cache: &GlobalModuleCache<K, DC, VC, S>,
        per_block_module_cache: &SyncModuleCache<K, DC, VC, S, Option<TxnIndex>>,
        maybe_updated_module_keys: Option<&BTreeSet<K>>,
    ) -> bool {
        if self.non_delayed_field_speculative_failure {
            return false;
        }

        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };

        match maybe_updated_module_keys {
            Some(updated_module_keys) if updated_module_keys.len() <= self.module_reads.len() => {
                // When updated_module_keys is smaller, iterate over it and lookup in module_reads
                updated_module_keys
                    .iter()
                    .filter(|&k| self.module_reads.contains_key(k))
                    .all(|key| validate(key, self.module_reads.get(key).unwrap()))
            },
            Some(updated_module_keys) => {
                // When module_reads is smaller, iterate over it and filter by updated_module_keys
                self.module_reads
                    .iter()
                    .filter(|(k, _)| updated_module_keys.contains(k))
                    .all(|(key, read)| validate(key, read))
            },
            None => self
                .module_reads
                .iter()
                .all(|(key, read)| validate(key, read)),
        }
    }
```

**File:** aptos-move/block-executor/src/lib.rs (L4-8)
```rust
/**
The high level parallel execution logic is implemented in 'executor.rs'. The
input of parallel executor is a block of transactions, containing a sequence
of n transactions tx_1, tx_2, ..., tx_n (this defines the preset serialization
order tx_1< tx_2< ...<tx_n).
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L205-208)
```rust
    let paranoid_type_checks = get_paranoid_type_checks();
    let paranoid_ref_checks = get_paranoid_ref_checks();
    let enable_layout_caches = get_layout_caches();
    let enable_debugging = get_debugging_enabled();
```
