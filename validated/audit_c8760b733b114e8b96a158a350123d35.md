# Audit Report

## Title
Unverified CommitDecision with Future Epoch Causes Root Corruption and Consensus Observer DoS

## Summary
An attacker can send a `CommitDecision` message with a future epoch and arbitrary round value to corrupt the consensus observer's root state and cause a complete denial of service. The vulnerability exists because future-epoch commit decisions bypass signature verification but are still used to update critical internal state.

## Finding Description

The consensus observer processes `CommitDecision` messages containing commit proofs with epoch and round information. The vulnerability arises from a critical flaw in the message processing flow where unverified future-epoch commits corrupt internal state.

**Vulnerability Flow:**

1. The `epoch()` and `round()` functions extract values directly from the unverified commit proof without any validation [1](#0-0) 

2. In `process_commit_decision_message()`, epoch and round are extracted BEFORE any signature verification occurs [2](#0-1) 

3. These unverified values are immediately used to filter messages by comparing against the highest committed epoch/round, allowing the attacker's fake values to pass the staleness check [3](#0-2) 

4. Signature verification is ONLY performed when the commit epoch matches the current epoch [4](#0-3) 

5. For future-epoch commits (where `commit_epoch > epoch_state.epoch`), the code skips verification entirely and proceeds to state sync handling [5](#0-4) 

6. Most critically, the unverified commit decision is used to update the observer's root BEFORE any state sync validation occurs [6](#0-5) 

7. The root update in `update_blocks_for_state_sync_commit()` directly assigns the unverified commit proof to the root [7](#0-6) [8](#0-7) 

8. After the root is corrupted with fake epoch/round values, `get_highest_committed_epoch_round()` returns these manipulated values for all subsequent message filtering [9](#0-8) 

9. The observer then starts state syncing to the non-existent target. When state sync fails to reach the fake target, it only logs an error and exits without clearing the sync handle or sending a notification [10](#0-9) 

10. The observer becomes permanently stuck because `check_progress()` continuously waits for the failed state sync to complete [11](#0-10) 

11. All normal block processing is blocked while waiting for the failed state sync, and the fallback recovery check is never reached due to the early return [12](#0-11) 

**Attack Scenario:**
1. Attacker sends `CommitDecision` with `epoch = current_epoch + 1` and `round = u64::MAX`
2. Observer extracts these values without validation
3. Values pass staleness check since they're "higher" than current committed epoch/round
4. Signature verification is skipped because `commit_epoch != epoch_state.epoch`
5. Root is updated to the fake commit
6. State sync to non-existent target is initiated and fails
7. Observer is permanently stuck waiting for failed state sync
8. All legitimate messages with "lower" epochs/rounds are now rejected as stale by the corrupted filtering logic

This breaks the **Consensus Safety** invariant by allowing an attacker to corrupt the observer's view of consensus state without any cryptographic validation.

## Impact Explanation

This is a **Critical Severity** vulnerability based on Aptos bug bounty criteria because it causes:

**Total Loss of Liveness/Network Availability** (Critical Impact Category):
- The affected consensus observer node becomes completely non-functional
- All block processing is halted while waiting for the failed state sync
- The observer cannot participate in consensus observation or execution
- Recovery requires manual intervention (node restart and state cleanup)

**Significant Protocol Violations**:
- Corrupts the consensus observer's internal state tracking
- Bypasses all cryptographic signature verification requirements
- Violates the fundamental security assumption that all state updates must be verified

**Wide Attack Surface**:
- Affects all consensus observer nodes in the network
- Can be exploited by any network peer without requiring validator credentials, stake, governance power, or cryptographic key compromise

The vulnerability violates core consensus safety guarantees by allowing unverified data to corrupt critical consensus state, resulting in a non-recoverable denial of service.

## Likelihood Explanation

**Likelihood: Very High**

- **Attack Complexity: Trivial** - A single malformed network message triggers the vulnerability with no complex setup or timing requirements
- **Attacker Requirements: Minimal** - Only requires network access to send messages to consensus observer nodes (any network peer)
- **No Authentication Required** - The attack succeeds before any signature verification occurs, bypassing all cryptographic protections
- **Easily Reproducible** - The vulnerable code path is deterministic and always accessible during normal operations
- **High Impact per Attack** - Each malicious message causes complete and permanent DoS until manual recovery

## Recommendation

Implement verification for all commit decisions regardless of epoch:

1. **Verify all commit decisions**: Remove the epoch-conditional verification logic and verify ALL commit decisions before using them
2. **Add epoch transition validation**: Implement proper validation for future-epoch commits that checks if the epoch transition is legitimate
3. **Implement state sync timeout and recovery**: Add timeout mechanisms for failed state sync operations with automatic cleanup of sync handles
4. **Separate state update from state sync initiation**: Only update the root after successful state sync completion, not before

The fix should ensure that:
- No unverified data is ever used to update critical state
- Failed state sync operations are properly cleaned up
- Automatic recovery mechanisms exist for stuck observers

## Proof of Concept

While a complete PoC would require setting up a test network environment, the attack can be demonstrated by:

1. Creating a `CommitDecision` with `epoch = current_epoch + 1` and `round = u64::MAX`
2. Creating a malformed `LedgerInfoWithSignatures` with invalid/empty signatures
3. Sending this message to a consensus observer node via the network interface
4. Observing that the node's root state is updated without verification
5. Confirming that the node becomes stuck waiting for state sync to an unreachable target

The code path is deterministic and can be traced through the functions cited above, demonstrating that no verification occurs for future-epoch commits before state corruption.

## Notes

This is a **protocol-level logic bug**, not a network DoS attack. The distinction is critical:
- It exploits a flaw in the verification logic where future-epoch commits bypass signature verification
- It corrupts internal state with unverified data
- It causes permanent node failure through a recoverable logic error, not through resource exhaustion or network flooding

The vulnerability demonstrates a fundamental violation of the security principle that all state-modifying operations must be cryptographically verified before being applied.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L351-364)
```rust
    /// Returns the epoch of the commit proof
    pub fn epoch(&self) -> u64 {
        self.commit_proof.ledger_info().epoch()
    }

    /// Returns a reference to the commit proof block info
    pub fn proof_block_info(&self) -> &BlockInfo {
        self.commit_proof.commit_info()
    }

    /// Returns the round of the commit proof
    pub fn round(&self) -> Round {
        self.commit_proof.ledger_info().round()
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L168-214)
```rust
    async fn check_progress(&mut self) {
        debug!(LogSchema::new(LogEntry::ConsensusObserver)
            .message("Checking consensus observer progress!"));

        // If we've fallen back to state sync, we should wait for it to complete
        if self.state_sync_manager.in_fallback_mode() {
            info!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Waiting for state sync to complete fallback syncing!",));
            return;
        }

        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }

        // Check if we need to fallback to state sync
        if let Err(error) = self.observer_fallback_manager.check_syncing_progress() {
            // Log the error and enter fallback mode
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to make syncing progress! Entering fallback mode! Error: {:?}",
                    error
                ))
            );
            self.enter_fallback_mode().await;
            return;
        }

        // Otherwise, check the health of the active subscriptions
        if let Err(error) = self
            .subscription_manager
            .check_and_manage_subscriptions()
            .await
        {
            // Log the failure and clear the pending block state
            warn!(LogSchema::new(LogEntry::ConsensusObserver)
                .message(&format!("Subscription checks failed! Error: {:?}", error)));
            self.clear_pending_block_state().await;
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L449-450)
```rust
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L453-461)
```rust
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-482)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L502-527)
```rust
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L132-141)
```rust
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L300-302)
```rust
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L218-231)
```rust
                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }
```
