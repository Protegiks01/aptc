# Audit Report

## Title
Mempool CPU Exhaustion via Maximum-Signature Transactions Without API-Layer Rate Limiting

## Summary
The Aptos REST API accepts transactions without pre-validating signatures, forwarding them directly to mempool where expensive cryptographic verification occurs. An attacker can exploit this by submitting transactions with the maximum allowed signatures (32), creating significant asymmetry between the cheap HTTP-layer size check and expensive mempool signature verification, potentially causing validator node CPU exhaustion.

## Finding Description

The vulnerability exists in the transaction submission pipeline where signature verification is deferred from the API layer to the mempool validation layer without intermediate rate limiting:

**1. API Layer - Cheap Size Check Only:**

The `PostSizeLimitEndpoint::call()` middleware only validates the Content-Length HTTP header against an 8 MB limit, without verifying transaction signatures or counting signature operations. [1](#0-0) 

**2. No Signature Verification at API Layer:**

The `get_signed_transaction()` function deserializes transactions but does NOT verify signatures before forwarding to mempool. It only calls `validate_signed_transaction_payload()` which validates payload format, not cryptographic signatures. [2](#0-1) 

**3. Expensive Verification in Mempool:**

Signature verification occurs in the mempool's validation phase. The `validate_and_add_transactions()` function calls the validator which performs CPU-intensive signature checks. [3](#0-2) 

The VM validator's `validate_transaction()` method explicitly calls `transaction.check_signature()` to verify cryptographic signatures. [4](#0-3) 

**4. Maximum Signature Exploitation:**

The system allows up to `MAX_NUM_OF_SIGS = 32` signatures per transaction. [5](#0-4) 

**5. Individual Signature Verification Loop:**

MultiEd25519 signatures verify each of the 32 signatures individually in a loop. The code includes a TODO comment acknowledging that batch verification is not yet implemented. [6](#0-5) 

**6. No API Rate Limiting:**

The API configuration only supports content length limits, with no rate limiting middleware. [7](#0-6) 

The API runtime applies only the `PostSizeLimit` middleware for size checking, with no rate limiting layer. [8](#0-7) 

**7. Signature Verification Before Capacity Checks:**

The validation happens BEFORE transactions are added to mempool (where capacity checks occur). The flow shows validation at line 395, then mempool insertion at line 514. [9](#0-8) 

**Attack Execution:**
1. Attacker crafts transactions with 32 signatures (maximum allowed)
2. Submits multiple such transactions simultaneously to API endpoint
3. API performs O(1) Content-Length header check (passes instantly)
4. Transactions are forwarded to mempool
5. Mempool validator performs O(32) individual signature verifications per transaction
6. Each transaction consumes significant CPU cycles before being accepted/rejected
7. Validator nodes experience CPU saturation from signature verification overhead

## Impact Explanation

This constitutes **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns through DoS via resource exhaustion."

**Resource Amplification:**
- API size check cost: O(1) - single header read
- Signature verification cost: O(32) individual Ed25519 signature verifications
- Asymmetric computational cost between submission and verification

**Validator Impact:**
- CPU exhaustion on mempool validator threads
- Delayed processing of legitimate transactions
- Potential consensus delays if validators are slowed
- No effective rate limiting before expensive operation

**Why This Is Not "Network DoS" (excluded scope):**
This is NOT a volumetric network-layer attack (packet flooding, bandwidth exhaustion). This is a protocol-level design flaw where the validation pipeline allows asymmetric resource consumption through expensive cryptographic operations. The Aptos bug bounty explicitly includes "Validator Node Slowdowns" with "DoS through resource exhaustion" as High severity.

**Attack Feasibility:**
- No authentication required for API submission
- No rate limiting at API boundary
- Trivially executable via standard HTTP POST requests
- Multiple concurrent connections amplify the effect
- Attack cost is minimal (HTTP requests) while defense cost is high (signature verification)

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

1. **No API-layer authentication:** Transaction submission endpoint is public
2. **No rate limiting:** Code review confirms no rate limiting middleware exists in the API layer
3. **Signature verification mandatory:** All transactions undergo full signature verification in mempool
4. **Cheap attack cost:** Attacker only needs to generate HTTP POST requests
5. **Parallelizable attack:** Multiple concurrent connections can amplify the effect

The signature verification happens BEFORE mempool capacity checks are enforced, meaning submitted transactions consume CPU resources for validation before being potentially rejected for capacity reasons.

## Recommendation

Implement API-layer rate limiting and signature counting before mempool submission:

1. **Add API Rate Limiting Middleware:**
   - Implement token bucket rate limiter at API layer
   - Limit requests per IP/connection before expensive operations
   - Separate rate limits for transactions with high signature counts

2. **Pre-validate Signature Count:**
   - Check signature count at API layer before forwarding to mempool
   - Apply stricter rate limits for transactions with many signatures
   - Consider rejecting transactions exceeding a lower threshold (e.g., 16 signatures)

3. **Implement Batch Signature Verification:**
   - Complete the TODO in MultiEd25519 to use batch verification
   - Reduce per-transaction CPU cost significantly

4. **Early Capacity Checks:**
   - Check mempool capacity before signature verification
   - Fast-fail transactions when mempool is near capacity

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack pattern
// In practice, craft a SignedTransaction with 32 signatures

use aptos_types::transaction::{
    authenticator::{AccountAuthenticator, TransactionAuthenticator},
    SignedTransaction, RawTransaction,
};

// Create transaction with maximum signatures
let mut signatures = Vec::new();
for _ in 0..32 {
    // Add 32 valid or crafted signatures
    signatures.push(/* Ed25519 signature */);
}

let auth = TransactionAuthenticator::MultiEd25519 {
    public_key: /* 32-key multi-sig public key */,
    signature: /* 32 signatures */,
};

let signed_txn = SignedTransaction::new(raw_txn, auth);

// Submit via API - bypasses signature verification
// POST /v1/transactions
// Content-Type: application/x.aptos.signed_transaction+bcs
// Body: BCS-encoded signed_txn

// Result: API accepts (cheap size check), forwards to mempool
// Mempool performs expensive 32-signature verification
// Attacker repeats from multiple connections to exhaust CPU
```

## Notes

**Key Technical Evidence:**
- The vulnerability is confirmed through direct code inspection of the transaction submission pipeline
- API layer has only size-based middleware, no rate limiting or signature verification
- Mempool validation performs expensive cryptographic operations before capacity checks
- The asymmetric cost creates a resource exhaustion vulnerability

**Mitigation Context:**
While parallel validation (via `VALIDATION_POOL` with `par_iter`) distributes the load across CPU cores, this does not eliminate the vulnerabilityâ€”it only spreads the resource exhaustion. Multiple attackers can still overwhelm the validation thread pool with concurrent requests containing maximum-signature transactions.

### Citations

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** api/src/transactions.rs (L1216-1253)
```rust
    fn get_signed_transaction(
        &self,
        ledger_info: &LedgerInfo,
        data: SubmitTransactionPost,
    ) -> Result<SignedTransaction, SubmitTransactionError> {
        match data {
            SubmitTransactionPost::Bcs(data) => {
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
                        .map_err(|err| {
                            SubmitTransactionError::bad_request_with_code(
                                err,
                                AptosErrorCode::InvalidInput,
                                ledger_info,
                            )
                        })?;
                // Verify the signed transaction
                self.validate_signed_transaction_payload(ledger_info, &signed_transaction)?;
                // TODO: Verify script args?

                Ok(signed_transaction)
            },
            SubmitTransactionPost::Json(data) => self
                .context
                .latest_state_view_poem(ledger_info)?
                .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                .try_into_signed_transaction_poem(data.0, self.context.chain_id())
                .context("Failed to create SignedTransaction from SubmitTransactionRequest")
                .map_err(|err| {
                    SubmitTransactionError::bad_request_with_code(
                        err,
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    )
                }),
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L395-400)
```rust
    validate_and_add_transactions(
        transactions,
        smp,
        timeline_state,
        &mut statuses,
        client_submitted,
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L544-557)
```rust
        let mut bitmap_index = 0;
        // TODO: Eventually switch to deterministic batch verification
        for sig in &self.signatures {
            while !bitmap_get_bit(self.bitmap, bitmap_index) {
                bitmap_index += 1;
            }
            let pk = public_key
                .public_keys
                .get(bitmap_index)
                .ok_or_else(|| anyhow::anyhow!("Public key index {bitmap_index} out of bounds"))?;
            sig.verify_arbitrary_msg(message, pk)?;
            bitmap_index += 1;
        }
        Ok(())
```

**File:** config/src/config/api_config.rs (L29-31)
```rust
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
```

**File:** api/src/runtime.rs (L253-259)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```
