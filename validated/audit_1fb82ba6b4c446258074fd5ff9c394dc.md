# Audit Report

## Title
BlockSTMv2 Partial Delayed Field Application Leads to Panic on Re-execution

## Summary
A critical bug in `process_delayed_field_output()` allows partial application of delayed field changes when `record_change()` fails. The error is captured but the loop continues, allowing subsequent fields to be recorded while failed fields remain in the output metadata. During re-execution, the cleanup attempts to remove fields that were never recorded, causing a panic that crashes validator nodes.

## Finding Description

The vulnerability exists in the delayed field processing and cleanup logic within the BlockSTM parallel execution engine.

**Step 1: Partial Application During Error Handling**

In `process_delayed_field_output()`, when `record_change()` fails with a `PanicOr::Or(_)` error (such as `MVDelayedFieldsError::NotFound`), the function captures the error but continues processing subsequent delayed fields without returning. [1](#0-0) 

The critical issue is that `prev_modified_delayed_fields.remove(&id)` executes at line 353 BEFORE the `record_change()` attempt at lines 358-361. When `record_change()` fails with `PanicOr::Or(_)`, the error is captured at lines 370-373 but the loop continues without returning. This allows partial state where some fields record successfully while others fail, yet all are removed from `prev_modified_delayed_fields`. [2](#0-1) 

The `record_change()` method returns `MVDelayedFieldsError::NotFound` at line 504 when attempting to apply a delta to a non-existent aggregator.

All delayed fields (including those that failed to record) are then recorded in the output metadata when `last_input_output.record()` is called: [3](#0-2) [4](#0-3) 

The `delayed_field_keys()` method extracts ALL keys from the output's `delayed_field_change_set()`, including field B that failed to record.

**Step 2: Validation Failure and Abort Path**

The captured error sets the `delayed_field_speculative_failure` flag: [5](#0-4) 

This flag causes `validate_and_commit_delayed_fields()` to return `Ok(false)`, triggering re-execution: [6](#0-5) 

This triggers `abort_pre_final_reexecution()`: [7](#0-6) 

In BlockSTMv2, this function only calls `scheduler.direct_abort()` without cleaning up the versioned cache state: [8](#0-7) 

BlockSTMv1 calls `update_transaction_on_abort()` which marks delayed fields as estimates, but BlockSTMv2 does not perform this cleanup.

**Step 3: Panic During Cleanup**

During re-execution, `prev_modified_delayed_fields` is populated from the previous incarnation's output metadata, which includes ALL fields (A, B, C): [9](#0-8) 

If re-execution produces different outputs, the cleanup loop attempts to remove fields from the previous incarnation that are not in the new output: [10](#0-9) 

When attempting to remove field B (which failed to record initially), the `remove()` method panics because it expects the field to exist in `values`: [11](#0-10) 

The panic occurs at lines 531-538 when `self.values.get_mut(id)` returns `None`, triggering `code_invariant_error()`.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

- **Validator Node Crashes**: The `code_invariant_error` panic immediately crashes the validator node process, directly qualifying as "Validator node slowdowns" or crashes under High Severity criteria ($50,000 maximum)

- **State Consistency Violation**: The partial application of delayed field changes violates the atomicity guarantee that transaction state changes should be all-or-nothing

- **Deterministic Crash**: The panic is deterministic once the vulnerable state is reached, making this a reliable crash vector

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered in speculative parallel execution scenarios:

**Preconditions:**
1. BlockSTMv2 parallel execution is enabled (current execution model)
2. Concurrent transactions with dependencies on delayed fields (aggregators)
3. Transaction aborts and re-execution that change aggregator creation patterns

**Trigger Mechanism:**
- Transaction B applies a delta to an aggregator created by Transaction A
- Transaction A aborts and re-executes without creating that aggregator
- Transaction B's output references a non-existent aggregator
- The `NotFound` error is triggered during output processing

**Complexity:**
- Does not require attacker privileges
- Occurs naturally in high-concurrency scenarios with transaction dependencies
- More likely during network congestion when transaction re-execution is common

## Recommendation

The fix should ensure that when `record_change()` fails, the field is NOT removed from `prev_modified_delayed_fields` so that cleanup doesn't attempt to remove it. Alternatively, mark failed fields as estimates similar to BlockSTMv1's approach.

Recommended fix in `process_delayed_field_output()`:

```rust
for (id, change) in output_before_guard.delayed_field_change_set().into_iter() {
    let entry = change.into_entry_no_additional_history();
    
    if let Err(e) = versioned_cache.delayed_fields().record_change(id, idx_to_execute, entry) {
        match e {
            PanicOr::CodeInvariantError(m) => {
                return Err(code_invariant_error(format!("Record change failed: {:?}", m)));
            },
            PanicOr::Or(_) => {
                read_set.capture_delayed_field_read_error(&PanicOr::Or(
                    MVDelayedFieldsError::DeltaApplicationFailure,
                ));
                // Do NOT remove from prev_modified_delayed_fields on failure
                continue;
            },
        };
    }
    
    // Only remove if record_change succeeded
    prev_modified_delayed_fields.remove(&id);
}
```

## Proof of Concept

The vulnerability can be triggered through the following sequence:

1. Transaction A creates an aggregator with ID X
2. Transaction B (dependent on A) applies a delta to aggregator X
3. Transaction A is validated and found to have a conflict, triggering abort and re-execution
4. Transaction A re-executes without creating aggregator X
5. Transaction B's execution completes with output referencing aggregator X
6. During `process_delayed_field_output()` for B:
   - Field X is removed from `prev_modified_delayed_fields` (line 353)
   - `record_change()` fails with `NotFound` (aggregator X doesn't exist)
   - Error is captured, loop continues
7. Validation fails, triggering re-execution of B
8. During re-execution cleanup, `remove()` is called for field X
9. Panic: `code_invariant_error("VersionedValue for an (resolved) ID must already exist")`

## Notes

This is a race condition that occurs naturally in parallel execution when transaction dependencies on delayed fields (aggregators) change between incarnations. The root cause is the asymmetry between BlockSTMv1 and BlockSTMv2's abort handling - V1 properly marks estimates while V2 does not clean up the versioned cache state.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L333-335)
```rust
        let mut prev_modified_delayed_fields = last_input_output
            .delayed_field_keys(idx_to_execute)
            .map_or_else(HashSet::new, |keys| keys.collect());
```

**File:** aptos-move/block-executor/src/executor.rs (L352-376)
```rust
            for (id, change) in output_before_guard.delayed_field_change_set().into_iter() {
                prev_modified_delayed_fields.remove(&id);

                let entry = change.into_entry_no_additional_history();

                // TODO[agg_v2](optimize): figure out if it is useful for change to update needs_suffix_validation
                if let Err(e) =
                    versioned_cache
                        .delayed_fields()
                        .record_change(id, idx_to_execute, entry)
                {
                    match e {
                        PanicOr::CodeInvariantError(m) => {
                            return Err(code_invariant_error(format!(
                                "Record change failed with CodeInvariantError: {:?}",
                                m
                            )));
                        },
                        PanicOr::Or(_) => {
                            read_set.capture_delayed_field_read_error(&PanicOr::Or(
                                MVDelayedFieldsError::DeltaApplicationFailure,
                            ));
                        },
                    };
                }
```

**File:** aptos-move/block-executor/src/executor.rs (L380-384)
```rust
        for id in prev_modified_delayed_fields {
            versioned_cache
                .delayed_fields()
                .remove(&id, idx_to_execute, is_v2)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L499-505)
```rust
        last_input_output.record(
            idx_to_execute,
            read_set,
            execution_result,
            block_gas_limit_type,
            txn.user_txn_bytes_len() as u64,
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L846-858)
```rust
    fn validate_and_commit_delayed_fields(
        txn_idx: TxnIndex,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        last_input_output: &TxnLastInputOutput<T, E::Output>,
        is_v2: bool,
    ) -> Result<bool, PanicError> {
        let (read_set, is_speculative_failure) = last_input_output
            .read_set(txn_idx)
            .ok_or_else(|| code_invariant_error("Read set must be recorded"))?;

        if is_speculative_failure {
            return Ok(false);
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1009-1023)
```rust
        if !Self::validate_and_commit_delayed_fields(
            txn_idx,
            versioned_cache,
            last_input_output,
            scheduler.is_v2(),
        )? {
            // Transaction needs to be re-executed, one final time.
            side_effect_at_commit = true;

            scheduler.abort_pre_final_reexecution::<T, E>(
                txn_idx,
                incarnation,
                last_input_output,
                versioned_cache,
            )?;
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L492-513)
```rust
    pub fn record_change(
        &self,
        id: K,
        txn_idx: TxnIndex,
        change: DelayedEntry<K>,
    ) -> Result<(), PanicOr<MVDelayedFieldsError>> {
        match change {
            DelayedEntry::Create(value) => self.initialize_delayed_field(id, txn_idx, value)?,
            DelayedEntry::Apply(apply) => match &apply {
                DelayedApplyEntry::AggregatorDelta { .. } => self
                    .values
                    .get_mut(&id)
                    .ok_or(PanicOr::Or(MVDelayedFieldsError::NotFound))?
                    .insert_speculative_value(txn_idx, VersionEntry::Apply(apply))?,
                DelayedApplyEntry::SnapshotDelta { .. }
                | DelayedApplyEntry::SnapshotDerived { .. } => {
                    self.initialize_dependent_delayed_field(id, txn_idx, apply)?
                },
            },
        };
        Ok(())
    }
```

**File:** aptos-move/mvhashmap/src/versioned_delayed_fields.rs (L525-541)
```rust
    pub fn remove(
        &self,
        id: &K,
        txn_idx: TxnIndex,
        is_blockstm_v2: bool,
    ) -> Result<(), PanicError> {
        self.values
            .get_mut(id)
            .ok_or_else(|| {
                code_invariant_error(format!(
                    "VersionedValue for an (resolved) ID {:?} must already exist",
                    id
                ))
            })?
            .remove(txn_idx, is_blockstm_v2);
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L580-594)
```rust
    pub(crate) fn delayed_field_keys(
        &self,
        txn_idx: TxnIndex,
    ) -> Option<impl Iterator<Item = DelayedFieldID>> {
        with_success_or_skip_rest!(
            self,
            txn_idx,
            |t| Some(
                t.before_materialization()
                    .expect("Output must be set")
                    .delayed_field_change_set()
                    .into_keys()
            ),
            None
        )
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L891-896)
```rust
    pub(crate) fn capture_delayed_field_read_error<E: std::fmt::Debug>(&mut self, e: &PanicOr<E>) {
        match e {
            PanicOr::CodeInvariantError(_) => self.incorrect_use = true,
            PanicOr::Or(_) => self.delayed_field_speculative_failure = true,
        };
    }
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L106-128)
```rust
    pub(crate) fn abort_pre_final_reexecution<T, E>(
        &self,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
        last_input_output: &TxnLastInputOutput<T, E::Output>,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
    ) -> Result<(), PanicError>
    where
        T: BlockExecutableTransaction,
        E: ExecutorTask<Txn = T>,
    {
        match self {
            SchedulerWrapper::V1(_, _) => {
                // Updating the scheduler state not required as the execute method invoked
                // in [executor::execute_txn_after_commit] does not take in the scheduler.
                update_transaction_on_abort::<T, E>(txn_idx, last_input_output, versioned_cache);
            },
            SchedulerWrapper::V2(scheduler, _) => {
                scheduler.direct_abort(txn_idx, incarnation, true)?;
            },
        }
        Ok(())
    }
```
