# Audit Report

## Title
Invariant Violation via Deserialization Bypass in AnalyzedTransaction Leading to Node Crash

## Summary
The `AnalyzedTransaction` struct maintains a critical invariant between `predictable_transaction` and storage location types, which is enforced during construction but can be bypassed through serde deserialization. This allows an attacker to craft malicious messages that cause validator node crashes when processed by the remote executor service.

## Finding Description

The `AnalyzedTransaction` struct enforces an invariant during construction where `predictable_transaction` is set based on whether hints contain wildcards, ensuring that `predictable_transaction=true` implies all storage locations are `Specific` variants. [1](#0-0) 

However, the struct derives both `Serialize` and `Deserialize`, which allows deserialization to bypass this constructor validation entirely. [2](#0-1) 

**Attack Path:**

An attacker crafts a malicious `RemoteExecutionRequest` containing an `AnalyzedTransaction` with `predictable_transaction=true` but wildcard variants in the hints. The remote executor service deserializes this message without validation. [3](#0-2) 

The message structure allows `AnalyzedTransaction` to be nested within the request. [4](#0-3) 

**First Panic Point:** The deserialized transaction is processed by `extract_state_keys()`, which iterates through all storage locations and calls `.state_key()` on each. [5](#0-4) 

The `.state_key()` method explicitly panics when called on wildcard variants with the message "Cannot convert wildcard storage location to state key". [6](#0-5) 

**Second Panic Point:** If the experimental PTX executor were deployed, the `expect_p_txn()` method would be called on the deserialized transaction. [7](#0-6) 

While the assertion on `predictable_transaction()` passes, the subsequent call to `expect_specific_locations()` hits an `unreachable!()` macro when encountering wildcard variants. [8](#0-7) 

The remote executor service's gRPC interface accepts messages without any authentication mechanism, making it vulnerable if exposed to untrusted networks. [9](#0-8) 

## Impact Explanation

**Severity: HIGH (Validator Node Crashes)**

This vulnerability causes immediate node panic and crash through an application-level bug, aligning with the **"API Crashes (High)"** category in the Aptos bug bounty program. If a validator deploys the remote executor service with network exposure, an attacker can crash the validator node by sending a single malicious message.

Impact includes:
- Immediate validator unavailability requiring manual restart
- Potential consensus delays if multiple validators are simultaneously affected
- Service disruption affecting block production participation

This does NOT cause:
- Consensus violations or Byzantine faults
- Fund theft or unauthorized state modifications
- Permanent network damage or chain splits

The crash is deterministic and reproducible with a crafted message.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The vulnerability exists in production code but exploitability depends on deployment configuration:

1. **Remote Executor is Optional:** The remote executor service is conditionally enabled based on configuration, not active by default. [10](#0-9) 

2. **Network Exposure Required:** The service must be network-accessible to external attackers. The design suggests it's intended for internal shard-to-shard communication within validator infrastructure.

3. **No Authentication:** The gRPC service implementation uses plain HTTP connections without authentication checks.

4. **PTX Executor Experimental:** The second panic path exists only in experimental code under the `experimental/` directory, suggesting limited production deployment.

The vulnerability becomes immediately exploitable if validators deploy the remote executor service with external network access, making the effective likelihood dependent on operational security practices.

## Recommendation

1. **Add Post-Deserialization Validation:** Implement a validation method that verifies the invariant after deserialization:

```rust
impl AnalyzedTransaction {
    fn validate_invariant(&self) -> Result<(), String> {
        if self.predictable_transaction {
            for loc in self.read_hints.iter().chain(self.write_hints.iter()) {
                if !matches!(loc, StorageLocation::Specific(_)) {
                    return Err("Invalid state: predictable_transaction=true with wildcard locations".to_string());
                }
            }
        }
        Ok(())
    }
}
```

2. **Add Custom Deserialize Implementation:** Override the derived `Deserialize` to call validation after deserialization.

3. **Add gRPC Authentication:** Implement mutual TLS or token-based authentication for the remote executor service.

4. **Document Security Requirements:** Clearly document that the remote executor service should only be deployed in trusted network environments with proper network segmentation.

## Proof of Concept

```rust
use aptos_types::transaction::analyzed_transaction::{AnalyzedTransaction, StorageLocation};
use move_core_types::language_storage::StructTag;

// Create a malicious AnalyzedTransaction bypassing the constructor
let malicious = AnalyzedTransaction {
    transaction: /* valid transaction */,
    read_hints: vec![StorageLocation::WildCardStruct(/* some struct tag */)],
    write_hints: vec![],
    predictable_transaction: true,  // Violates invariant!
    hash: /* some hash */,
};

// Serialize it
let serialized = bcs::to_bytes(&malicious).unwrap();

// When deserialized on remote executor, this bypasses constructor validation
let deserialized: AnalyzedTransaction = bcs::from_bytes(&serialized).unwrap();

// Calling state_key() on the wildcard location causes panic
deserialized.read_hints[0].state_key();  // PANIC!
```

The PoC demonstrates that serde deserialization creates an `AnalyzedTransaction` in an invalid state that violates the struct's invariant, leading to panic when processed by `extract_state_keys()` in the remote executor service.

## Notes

This vulnerability highlights the danger of deriving `Serialize`/`Deserialize` on structs with constructor-enforced invariants. The remote executor service processes untrusted network input without re-validating deserialized data structures, creating an attack surface for invariant violations. While the service appears designed for internal use, the lack of authentication makes it critically vulnerable if deployed with external network exposure.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L23-24)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
```

**File:** types/src/transaction/analyzed_transaction.rs (L59-64)
```rust
    pub fn state_key(&self) -> &StateKey {
        match self {
            StorageLocation::Specific(state_key) => state_key,
            _ => panic!("Cannot convert wildcard storage location to state key"),
        }
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L68-82)
```rust
    pub fn new(transaction: SignatureVerifiedTransaction) -> Self {
        let (read_hints, write_hints) = transaction.get_read_write_hints();
        let hints_contain_wildcard = read_hints
            .iter()
            .chain(write_hints.iter())
            .any(|hint| !matches!(hint, StorageLocation::Specific(_)));
        let hash = transaction.hash();
        AnalyzedTransaction {
            transaction,
            read_hints,
            write_hints,
            predictable_transaction: !hints_contain_wildcard,
            hash,
        }
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L117-125)
```rust
    fn expect_specific_locations(locations: Vec<StorageLocation>) -> Vec<StateKey> {
        locations
            .into_iter()
            .map(|loc| match loc {
                StorageLocation::Specific(key) => key,
                _ => unreachable!(),
            })
            .collect()
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L52-76)
```rust
    fn extract_state_keys(command: &ExecuteBlockCommand) -> Vec<StateKey> {
        command
            .sub_blocks
            .sub_block_iter()
            .flat_map(|sub_block| {
                sub_block
                    .transactions
                    .par_iter()
                    .map(|txn| {
                        let mut state_keys = vec![];
                        for storage_location in txn
                            .txn()
                            .read_hints()
                            .iter()
                            .chain(txn.txn().write_hints().iter())
                        {
                            state_keys.push(storage_location.state_key().clone());
                        }
                        state_keys
                    })
                    .flatten()
                    .collect::<Vec<StateKey>>()
            })
            .collect::<Vec<StateKey>>()
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L89-89)
```rust
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/lib.rs (L43-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** experimental/execution/ptx-executor/src/sorter.rs (L98-98)
```rust
        let (txn, reads, read_writes) = txn.expect_p_txn();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```
