# Audit Report

## Title
Byzantine Validators Can Cause Unbounded Memory Growth in JWK Consensus via Malicious RPC Requests

## Summary
Byzantine validators can send arbitrary `KeyLevelObservationRequest` RPC messages with fake (issuer, kid) pairs to force victim validators to create unbounded `ConsensusState::NotStarted` entries in the `states_by_key` HashMap, leading to memory exhaustion within an epoch.

## Finding Description

The `KeyLevelConsensusManager` in the JWK consensus subsystem maintains a HashMap that maps `(Issuer, KID)` tuples to `ConsensusState` instances. [1](#0-0) 

When processing incoming RPC requests of type `KeyLevelObservationRequest`, the code unconditionally creates new HashMap entries using `.entry().or_default()` for any requested (issuer, kid) pair without validating whether that pair is legitimate: [2](#0-1) 

The `Issuer` and `KID` types are simple `Vec<u8>` type aliases with no inherent size constraints: [3](#0-2) 

A Byzantine validator can exploit this by sending RPC messages with arbitrary (issuer, kid) pairs. Each unique pair creates a new `ConsensusState::NotStarted` entry that persists in memory. The `ConsensusState::NotStarted` is the default variant: [4](#0-3) 

The cleanup mechanism in `reset_with_on_chain_state()` has a critical flaw. It retains entries where the on-chain version hasn't changed: [5](#0-4) 

For malicious entries with arbitrary issuers not present in the on-chain state, both `new_onchain_jwks.get(issuer)` and `self.onchain_jwks.get(issuer)` return `None`, which default to version 0 via `.unwrap_or_default()`. Since 0 == 0, these malicious entries are incorrectly retained throughout the epoch.

**Attack Flow:**
1. Byzantine validator crafts `JWKConsensusMsg::KeyLevelObservationRequest` messages with arbitrary (issuer, kid) pairs
2. Messages pass through the network layer with only queue size limits (no content validation): [6](#0-5) 
3. EpochManager validates only epoch match, not issuer/kid legitimacy: [7](#0-6) 
4. `process_peer_request()` creates `NotStarted` entries for each unique pair
5. Malicious entries persist until epoch boundary (hours to days in production)
6. Repeated attacks cause unbounded HashMap growth and memory exhaustion

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Resource Exhaustion**: Unbounded memory growth can degrade validator performance or cause node crashes, affecting consensus participation
- **State Inconsistencies**: Memory pressure may affect consensus participation and state processing efficiency
- **Limited Scope**: Requires Byzantine validator capability (< 1/3 validators), not executable by arbitrary network peers
- **Temporal Bound**: Entries are cleared at epoch boundaries when new `KeyLevelConsensusManager` instances are created, though epochs can last hours to days

The impact is not Critical because:
- Does not directly cause consensus safety violations or fund loss
- Does not permanently damage the network (recovers at next epoch)
- Does not enable double-spending or chain splits
- Requires adversarial validator access rather than arbitrary attacker capability

However, sustained attacks across multiple epochs could significantly degrade network performance and availability, affecting validator uptime and consensus efficiency. Memory exhaustion could force validator restarts, impacting network liveness.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is straightforward to execute:
- Byzantine validators have native RPC capabilities within the validator network
- No authentication or authorization checks validate the legitimacy of (issuer, kid) pairs in RPC request contents
- No rate limiting exists beyond fixed channel queue sizes that don't prevent unique pair creation
- Automatic entry creation occurs on any incoming request via `.entry().or_default()`
- Single compromised validator can execute repeatedly with minimal effort

Aptos's security model explicitly assumes < 1/3 Byzantine validators as part of the threat model, making this a realistic attack scenario. The attacker requires no on-chain costs (gas fees) and can sustain attacks across epochs by continuously sending unique (issuer, kid) pairs.

## Recommendation

Implement validation and rate limiting for `KeyLevelObservationRequest` messages:

1. **Validate Issuer Legitimacy**: Check that the requested issuer exists in the on-chain OIDC providers list before creating HashMap entries
2. **Fix Cleanup Logic**: Modify `reset_with_on_chain_state()` to explicitly remove entries for issuers not present in the new on-chain state
3. **Add Rate Limiting**: Implement per-peer limits on unique (issuer, kid) pairs that can be requested within an epoch
4. **Bound HashMap Size**: Add a maximum size limit for `states_by_key` with LRU eviction policy

Example fix for the cleanup logic:
```rust
// Instead of retaining based on version equality:
self.states_by_key.retain(|(issuer, _), _| {
    // Only retain if issuer exists in new on-chain state
    // AND version hasn't changed
    new_onchain_jwks.contains_key(issuer) &&
    new_onchain_jwks.get(issuer).map(|jwks| jwks.version)
        == self.onchain_jwks.get(issuer).map(|jwks| jwks.version)
});
```

## Proof of Concept

The vulnerability is demonstrable through static code analysis showing the logic flaw. A Byzantine validator can execute:

1. Send RPC: `JWKConsensusMsg::KeyLevelObservationRequest { epoch: current_epoch, issuer: b"malicious_issuer".to_vec(), kid: b"fake_kid_1".to_vec() }`
2. Repeat with incrementing kid values: `fake_kid_2`, `fake_kid_3`, etc.
3. Each unique (issuer, kid) creates a new HashMap entry via `.entry().or_default()`
4. Entries persist because cleanup logic evaluates `0 == 0` for non-existent issuers
5. Continue until memory exhaustion occurs

The mathematical flaw in the cleanup logic is provable: for any issuer not in on-chain state, `None.unwrap_or_default() == None.unwrap_or_default()` always evaluates to `true`, causing incorrect retention.

## Notes

This vulnerability affects the JWK consensus subsystem specifically in per-key mode (enabled by `JWK_CONSENSUS_PER_KEY_MODE` feature flag). The similar `IssuerLevelConsensusManager` may have analogous issues that should be reviewed. The vulnerability demonstrates a resource exhaustion attack exploiting insufficient input validation in consensus-critical infrastructure, bounded only by epoch duration rather than proper protocol limits.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L274-277)
```rust
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L167-170)
```rust
impl<T: Debug + Clone + Eq + PartialEq> Default for ConsensusState<T> {
    fn default() -> Self {
        Self::NotStarted
    }
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-169)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L99-104)
```rust
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
```
