# Audit Report

## Title
Inconsistent Feature Flag Fallback Handling Creates Consensus Disagreement Risk During JWK Consensus Migration

## Summary
When `OnChainJWKConsensusConfig` is not yet initialized and the `Features` config fails to load, the consensus layer defaults JWK consensus to "Off" while the JWK manager component assumes it's "On" (via `Features::default()`). This inconsistency can cause validator nodes to reject valid proposals containing `ObservedJWKUpdate` validator transactions, leading to consensus participation failures.

## Finding Description

During the migration period when `OnChainJWKConsensusConfig` is not yet initialized on-chain, the codebase has a fallback mechanism that constructs an equivalent config from the deprecated `Features` flag and `SupportedOIDCProviders`. [1](#0-0) 

However, when `Features` fails to load (due to deserialization errors, storage corruption, or database issues), two different code paths handle this failure inconsistently:

**Path 1: consensus/src/epoch_manager.rs (Round Manager)**

The consensus epoch manager uses `.ok()` to convert the Features loading error to `None` [2](#0-1) , which is then passed to the `From` implementation that defaults to `OnChainJWKConsensusConfig::Off` when Features is None [3](#0-2) . This fallback is invoked when `OnChainJWKConsensusConfig` fails to load [4](#0-3) .

**Path 2: aptos-jwk-consensus/src/epoch_manager.rs (JWK Manager)**

The JWK epoch manager uses `unwrap_or_default()` when loading Features [5](#0-4) , which creates `Features::default()` that includes `JWK_CONSENSUS` enabled [6](#0-5) [7](#0-6) . When the new config fails to load, this fallback path checks if JWK_CONSENSUS is enabled in Features [8](#0-7) .

**Critical Consequence:**

When proposals containing `ObservedJWKUpdate` validator transactions arrive, the round manager validates them using `is_vtxn_expected()` [9](#0-8) . The validation checks whether the validator transaction type is expected based on the configuration [10](#0-9) .

If `jwk_consensus_config` is incorrectly set to `Off` due to Features loading failure, the node will reject valid proposals with "unexpected validator txn" error, causing it to fail consensus participation.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Affected nodes cannot participate in consensus when they reject proposals containing `ObservedJWKUpdate` transactions. The node must wait for epoch transition or manual intervention to recover.

- **Significant protocol violations**: Creates consensus disagreement where some validators (with successful Features loading) accept valid proposals while others (with failed Features loading) reject them, violating the deterministic execution invariant.

- **Network partition risk**: If multiple validators experience Features loading failures simultaneously (e.g., during software upgrades with migration issues or storage corruption), a subset of the validator set could become unable to participate in consensus, potentially affecting network liveness.

The issue breaks the **Deterministic Execution** invariant - validators processing identical blocks should produce identical decisions, but here they diverge based on whether Features loaded successfully.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires two preconditions:
1. System in migration period (OnChainJWKConsensusConfig not yet initialized)
2. Features config fails loading (storage corruption, deserialization error, I/O failure)

While Features failures are uncommon in normal operation, they can occur during:
- Software upgrades with schema changes
- State sync issues causing incomplete config data  
- Storage corruption or hardware failures
- Race conditions during epoch transitions
- Migration deployment where OnChainJWKConsensusConfig rollout is incomplete

The inconsistency is deterministic once triggered - it will reliably cause the affected node to reject proposals. This is a **logic vulnerability** in error handling, not an attacker-exploitable issue.

## Recommendation

Standardize the error handling for Features loading across both components. Both should use the same fallback strategy:

**Option 1**: Use `.ok()` in both places (default to Off when Features unavailable):
```rust
let features = payload.get::<Features>().ok();
```

**Option 2**: Use `unwrap_or_default()` in both places and ensure the consensus epoch manager also respects the default Features:
```rust
let features = payload.get::<Features>().unwrap_or_default();
```

**Recommended approach**: Use Option 1 (`.ok()`) to fail-safe to "Off" state when configs are unavailable, ensuring both components agree that JWK consensus is disabled during error conditions. This prevents the JWK manager from starting when the round manager won't accept its transactions.

Additionally, add logging to clearly indicate when fallback mechanisms are triggered during epoch transitions to aid in debugging migration issues.

## Proof of Concept

While a full end-to-end PoC would require simulating storage corruption during epoch transitions, the logic vulnerability can be demonstrated through code inspection:

1. When `payload.get::<OnChainJWKConsensusConfig>()` returns Err (migration period)
2. And `payload.get::<Features>()` returns Err (storage issue)
3. Consensus epoch manager computes: `Features::get().ok()` → `None` → `OnChainJWKConsensusConfig::Off`
4. JWK epoch manager computes: `Features::get().unwrap_or_default()` → `Features{JWK_CONSENSUS=true}` → JWK manager starts
5. JWK manager produces `ObservedJWKUpdate` transactions
6. Round manager rejects proposals containing them due to `jwk_consensus_config.jwk_consensus_enabled()` returning false

The deterministic code paths are verified in the citations above.

## Notes

This is a **logic vulnerability** in error handling consistency, not an attacker-exploitable bug. It represents a correctness issue that can cause validators to fail during specific error scenarios in the migration period. The impact is real but requires environmental error conditions to trigger.

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L111-132)
```rust
/// Before `JWKConsensusConfig` is initialized, convert from `Features` and `SupportedOIDCProviders` instead.
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1223-1226)
```rust
        let jwk_consensus_config = onchain_jwk_consensus_config.unwrap_or_else(|_| {
            // `jwk_consensus_config` not yet initialized, falling back to the old configs.
            Self::equivalent_jwk_consensus_config_from_deprecated_resources(&payload)
        });
```

**File:** consensus/src/epoch_manager.rs (L1963-1969)
```rust
    fn equivalent_jwk_consensus_config_from_deprecated_resources(
        payload: &OnChainConfigPayload<P>,
    ) -> OnChainJWKConsensusConfig {
        let features = payload.get::<Features>().ok();
        let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
        OnChainJWKConsensusConfig::from((features, oidc_providers))
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L172-172)
```rust
        let features = payload.get::<Features>().unwrap_or_default();
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L188-194)
```rust
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
```

**File:** types/src/on_chain_config/aptos_features.rs (L221-221)
```rust
            FeatureFlag::JWK_CONSENSUS,
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-296)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```
