# Audit Report

## Title
Event API Returns Errors After Database Rollback Due to Stale Event Indices

## Summary
The event retrieval API fails after database rollbacks because event indices (`EventByKeySchema`, `EventByVersionSchema`) are not deleted during truncation operations. This causes API queries to encounter stale indices pointing to non-existent or incorrect events, resulting in errors for affected EventKeys.

## Finding Description

During database truncation/rollback operations (triggered by node crashes or manual recovery), the `delete_event_data` function removes events but explicitly skips index deletion. [1](#0-0) 

The code comment acknowledges this limitation with a TODO note. The `prune_event_indices` function is called with `indices_batch = None`, which causes the index deletion logic to be completely skipped. [2](#0-1) 

After rollback, if new blocks commit different transactions that emit different events, the stale indices remain pointing to:
1. Non-existent events (if the new transaction has no event at that index)
2. Wrong events (if the new transaction has different events)

When the API queries events via `lookup_events_by_key`, it expects continuous sequence numbers and will fail with "DB corruption: Sequence number not continuous" if gaps are detected. [3](#0-2) 

Subsequently, `get_event_by_version_and_index` returns a `NotFound` error when the event doesn't exist at the stale version/index. [4](#0-3) 

This error propagates to the API layer which returns an `InternalError` to clients. [5](#0-4) 

The same issue exists in the sharded database indexer path. [6](#0-5) 

Database rollback occurs during crash recovery when the system detects inconsistent commit progress. [7](#0-6) 

## Impact Explanation

This is a **Medium Severity** issue representing a limited protocol violation:

**API Query Failures**: Event queries fail for specific EventKeys that had events in rolled-back versions, returning internal errors instead of correct data. While the report claims this matches "API crashes," the actual impact is that specific queries fail, not that the entire API service becomes unavailable.

**Infrastructure Impact**: The failure affects block explorers, wallets, indexers, and DeFi protocols that rely on event queries for those specific EventKeys. The issue persists until new events overwrite the stale indices or manual database repair is performed.

**Database Consistency**: The database has indices inconsistent with stored events, violating integrity invariants. However, this is an indexing issue rather than core blockchain state corruption - the consensus state and balances remain correct.

## Likelihood Explanation

**Moderate Likelihood:**

1. **Rollback Trigger**: Database truncation occurs during node crash recovery via `sync_commit_progress`, which is a common operational scenario.

2. **Issue Manifestation**: The vulnerability only manifests when new blocks after rollback contain **different transactions** than the rolled-back blocks. In normal AptosBFT consensus recovery, nodes sync to the canonical chain and re-execute the same transactions, which emit the same events and overwrite stale indices correctly.

3. **Vulnerable Scenarios**: 
   - Manual recovery operations with different chain state
   - Speculative execution that was never canonical
   - Consensus bugs causing different block execution

4. **Persistence**: Once triggered, the issue persists indefinitely for affected EventKeys until overwritten or manually repaired.

## Recommendation

Pass a valid `SchemaBatch` to `prune_event_indices` instead of `None` to ensure index deletion:

```rust
fn delete_event_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut SchemaBatch,  // Use this batch for indices
) -> Result<()> {
    if let Some(latest_version) = ledger_db.event_db().latest_version()? {
        if latest_version >= start_version {
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                Some(batch),  // Changed from None to Some(batch)
            )?;
            ledger_db.event_db().prune_events(
                num_events_per_version,
                start_version,
                latest_version + 1,
                batch,
            )?;
        }
    }
    Ok(())
}
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Committing blocks with events
2. Manually truncating the database to an earlier version
3. Committing new blocks with different transactions
4. Querying events via API and observing internal errors

The code paths are verified through the execution flow: `sync_commit_progress` → `truncate_ledger_db` → `delete_event_data` → `prune_event_indices(None)` → indices not deleted → API query failure.

## Notes

The explicit TODO comment in the code ("TODO: prune data from internal indices") confirms this is a known limitation requiring a fix. While the severity may be Medium rather than High (specific queries fail vs. entire API crash), the vulnerability is real and causes operational issues. The likelihood is moderate because it requires specific conditions (rollback + different transactions) rather than occurring in every rollback scenario.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L532-538)
```rust
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L206-217)
```rust
            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L42-50)
```rust
    pub fn get_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEvent> {
        self.event_db
            .get::<EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-136)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```

**File:** api/src/events.rs (L163-178)
```rust
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** storage/indexer/src/db_indexer.rs (L232-238)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L440-449)
```rust
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```
