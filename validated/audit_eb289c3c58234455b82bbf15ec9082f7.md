# Audit Report

## Title
Integer Underflow in MixedPayloadClient::pull_payload() Leading to Consensus Divergence

## Summary
The `MixedPayloadClient::pull_payload()` function uses non-saturating subtraction when updating transaction constraints after pulling validator transactions. When governance increases the validator transaction limit beyond the minimum enforced `max_txns_after_filtering` value, the code can pull more validator transactions than the filtering limit allows, causing integer underflow that leads to validator panics (debug mode) or constraint corruption (release mode), breaking consensus determinism.

## Finding Description

The vulnerability occurs in the consensus layer's payload pulling mechanism where validator transactions and user transactions are pulled sequentially. The root cause is a missing validation check: the code does not verify that `validator_txns.len() <= max_txns_after_filtering` before performing non-saturating subtraction.

**Vulnerability Execution Path:**

1. **Independent Limit Calculations**: The `ProposalGenerator::calculate_max_block_sizes()` function calculates `max_block_txns` and `max_block_txns_after_filtering` through independent backpressure mechanisms. While backpressure may try to reduce `max_txns_after_filtering` to very low values, a minimum enforcement mechanism raises it to at least `min_max_txns_in_block_after_filtering_from_backpressure` (default: 100). [1](#0-0) 

2. **Governance-Controlled Validator Limit**: The `per_block_limit_txn_count` is a u64 field in `ValidatorTxnConfig::V1` that can be modified through on-chain governance to any value. [2](#0-1) 

3. **Unconstrained Validator Transaction Pulling**: When pulling validator transactions, the limit is `min(params.max_txns.count(), per_block_limit_txn_count)`, which does NOT consider `max_txns_after_filtering`. [3](#0-2) 

4. **Non-Saturating Subtraction Without Validation**: After pulling validator transactions, the code performs non-saturating subtraction on u64 fields without checking if `validator_txns.len() <= max_txns_after_filtering`. [4](#0-3) 

5. **No Validation in RoundManager**: The proposal validation logic checks validator transaction counts against `per_block_limit_txn_count` but not against `max_txns_after_filtering`. [5](#0-4) 

**Corrected Exploit Scenario:**
- Backpressure mechanisms attempt to reduce limits, but minimum enforcement keeps `max_txns_after_filtering` at 100 (default minimum)
- `max_txns.count()` remains at 1000 (determined by byte limits)
- Governance proposal increases `per_block_limit_txn_count` from 2 to 150 to accommodate increased validator transaction needs (DKG, randomness, JWK updates)
- Validator pool returns 110 transactions (within the allowed `min(1000, 150) = 150` limit)
- Line 94 executes: `100 - 110` causing integer underflow
  - **Debug mode**: Panics, validator crashes
  - **Release mode**: Wraps to `u64::MAX - 9`, allowing ~18 quintillion user transactions

## Impact Explanation

**Critical Severity** - This vulnerability violates the **Consensus Determinism** invariant, meeting the "Consensus/Safety Violations (Critical)" category:

1. **Consensus Divergence**: Debug-compiled validators panic and halt, while release-compiled validators continue with corrupted constraints (wrapped to ~u64::MAX). Different validators produce different execution results for the same block proposal, breaking the fundamental consensus safety guarantee.

2. **Validator Unavailability**: Debug-compiled validators crash during proposal generation. If sufficient validators are affected, the network cannot achieve consensus, causing liveness failures.

3. **Block Size Limit Bypass**: In release mode, the wrapped value allows proposers to pull virtually unlimited transactions, completely bypassing calibrated block size limits, potentially causing execution failures and state divergence.

4. **Non-deterministic Network Behavior**: The outcome depends on each validator's compilation profile, creating unpredictable behavior where some validators crash while others process malformed blocks.

## Likelihood Explanation

**Medium-High Likelihood** under realistic operational conditions:

1. **Governance Parameter Changes Are Expected**: The `per_block_limit_txn_count` parameter exists specifically to be adjusted via governance as validator transaction requirements evolve. A proposal to increase this from 2 to 100-200 would seem reasonable to accommodate growing needs.

2. **No Protective Validation**: The code contains no validation ensuring `validator_txns.len() <= max_txns_after_filtering`. The constraint misalignment can occur through normal governance operations.

3. **Backpressure Activates Minimum Enforcement**: When backpressure is active, `max_txns_after_filtering` is held at the minimum (100), making the vulnerability triggerable if governance sets `per_block_limit_txn_count` > 100.

4. **No Malicious Actor Required**: This triggers during normal network operation with legitimate governance proposals and automatic backpressure mechanisms.

## Recommendation

Replace non-saturating subtraction with saturating subtraction and add validation:

```rust
// Validate that validator transactions don't exceed filtering limit
ensure!(
    validator_txns.len() as u64 <= user_txn_pull_params.max_txns_after_filtering,
    "Validator transactions ({}) exceed max_txns_after_filtering ({})",
    validator_txns.len(),
    user_txn_pull_params.max_txns_after_filtering
);

user_txn_pull_params.max_txns_after_filtering = user_txn_pull_params
    .max_txns_after_filtering
    .saturating_sub(validator_txns.len() as u64);
user_txn_pull_params.soft_max_txns_after_filtering = user_txn_pull_params
    .soft_max_txns_after_filtering
    .saturating_sub(validator_txns.len() as u64);
```

Additionally, consider adding a governance constraint validation ensuring `per_block_limit_txn_count <= min_max_txns_in_block_after_filtering_from_backpressure`.

## Proof of Concept

The vulnerability exists in production code. A PoC would require setting up a test environment with:
1. Governance config with `per_block_limit_txn_count` = 150
2. Node config with `min_max_txns_in_block_after_filtering_from_backpressure` = 100
3. Active backpressure keeping `max_txns_after_filtering` at 100
4. Validator transaction pool with 110+ transactions
5. Debug build to observe panic, or release build to observe wrapped value

The integer underflow is mathematically certain when `validator_txns.len() > max_txns_after_filtering` due to the non-saturating subtraction operator on line 94. [6](#0-5) 

## Notes

The original report claimed backpressure could reduce `max_txns_after_filtering` to 5, but this is incomplete. While the pipeline backpressure configuration at 6000ms+ latency specifies an override value of 5, the minimum enforcement mechanism in `calculate_max_block_sizes()` raises this to at least 100 (default). However, the core vulnerability remains valid: if governance sets `per_block_limit_txn_count` above this minimum threshold and sufficient validator transactions are available, the integer underflow will occur. [7](#0-6) [8](#0-7)

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L827-837)
```rust
        let (max_block_txns_after_filtering, max_txns_from_block_to_execute) = if self
            .min_max_txns_in_block_after_filtering_from_backpressure
            > max_block_txns_after_filtering
        {
            (
                self.min_max_txns_in_block_after_filtering_from_backpressure,
                Some(max_block_txns_after_filtering),
            )
        } else {
            (max_block_txns_after_filtering, None)
        };
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-137)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}
```

**File:** consensus/src/payload_client/mixed.rs (L69-71)
```rust
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
```

**File:** consensus/src/payload_client/mixed.rs (L94-95)
```rust
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** consensus/src/round_manager.rs (L1166-1177)
```rust
        ensure!(
            num_validator_txns <= vtxn_count_limit,
            "process_proposal failed with per-block vtxn count limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_txn_count(),
            num_validator_txns
        );
        ensure!(
            validator_txns_total_bytes <= vtxn_bytes_limit,
            "process_proposal failed with per-block vtxn bytes limit exceeded: limit={}, actual={}",
            self.vtxn_config.per_block_limit_total_bytes(),
            validator_txns_total_bytes
        );
```

**File:** config/src/config/consensus_config.rs (L28-28)
```rust
const MIN_BLOCK_TXNS_AFTER_FILTERING: u64 = DEFEAULT_MAX_BATCH_TXNS as u64 * 2;
```

**File:** config/src/config/consensus_config.rs (L309-318)
```rust
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
```
