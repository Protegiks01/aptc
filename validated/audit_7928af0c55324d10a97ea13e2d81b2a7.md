# Audit Report

## Title
Memory Quota Bypass via Resource Group Cache Accumulation Leading to Validator Node Memory Exhaustion

## Summary
The Aptos VM's memory quota mechanism fails to track raw serialized bytes stored in the resource group cache, allowing attackers to bypass the 10 million unit memory limit and cause validator node memory exhaustion. By accessing one small resource from each of many large resource groups, an attacker can accumulate hundreds of MB of untracked cached data while the memory quota only sees the small deserialized resources.

## Finding Description

The Aptos VM implements a memory quota of 10,000,000 abstract value size units to prevent excessive memory consumption during transaction execution. [1](#0-0) 

However, this quota only tracks deserialized Move values on the VM heap through the `use_heap_memory()` method, which is called when resources are loaded and deserialized. [2](#0-1) 

The critical vulnerability lies in the resource group cache implementation. When any resource within a resource group is accessed, the `load_to_cache()` method loads the **entire resource group** into a cache structure as raw serialized bytes (`BTreeMap<StructTag, Bytes>`), regardless of which specific resources are actually accessed. [3](#0-2) 

The cache is defined as: [4](#0-3) 

An attacker can exploit this by:

1. **Setup Phase**: Creating many resource groups (e.g., 1000 groups) across multiple transactions, each containing multiple resources totaling ~500KB per group. This is within write limits since each write can be up to 1MB. [5](#0-4) 

2. **Attack Transaction**: Submitting a single transaction that accesses one small resource (e.g., 1KB) from each of the 1000 groups.

3. **Memory Quota Bypass**: The VM memory quota only tracks the deserialized small resources (~1KB × 1000 = ~1MB), so the quota check passes.

4. **Cache Accumulation**: The resource group cache accumulates entire groups (~500KB × 1000 = ~500MB of raw serialized bytes) that are never accounted for in the memory quota.

5. **Gas Calculation**: While gas is charged for reading the bytes (151 internal gas units per byte), the attack is feasible. Reading 500KB per group costs 75.5M internal gas units, and 1000 groups cost 75.5B internal gas units, which is only ~3.8% of the 2 trillion internal gas limit. [6](#0-5) 

6. **Cache Processing**: When `finish()` is called, `release_resource_group_cache()` drains and processes all cached data. [7](#0-6) 

7. **Validation Gap**: The `check_change_set()` validation only checks write operations and occurs after cache release, not the read cache accumulation. [8](#0-7) 

The key issue is that when a resource from a group is accessed via `get_any_resource_with_layout()`, the returned size for gas charging includes the full group size on first access, but the memory quota tracking in `charge_load_resource()` only tracks the actual deserialized value, not the cached serialized bytes. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category.

An attacker can craft transactions that accumulate hundreds of MB of cached resource group data while:
- Staying within the 2M gas unit limit (only using ~3.8% of gas for 500MB of data)
- Bypassing the 10M unit VM memory quota (which only sees ~1MB of deserialized data)
- Avoiding write size limits (which only apply to writes, not read cache)

This can cause:
- **Memory exhaustion** on validator nodes from holding hundreds of MB of untracked cached data
- **Performance degradation** during cache processing and potential garbage collection pressure  
- **Consensus impact** if multiple validators are affected simultaneously, slowing block production
- **DoS potential** through repeated exploitation across multiple transactions in a block

The attack requires no special privileges - any user can deploy resource groups and submit transactions. The economic cost is minimal given the gas efficiency of the attack.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is highly feasible because:

1. **No Privilege Required**: Any user can deploy Move modules with resource groups and submit transactions
2. **Gas Feasibility**: With 151 internal gas units per byte read cost, an attacker can read 500MB of data using only 75.5 billion out of 2 trillion internal gas units available
3. **Easy Setup**: Attacker creates resource groups across 50-100 transactions (10-20 groups per transaction, staying within 10MB write limit), then executes attack transaction
4. **Reproducible**: The vulnerability is deterministic and can be triggered repeatedly
5. **No Detection**: The memory quota check passes, and change set validation doesn't cover read cache

The main constraint is gas cost, but at 151 internal gas units per byte, the attacker can cause significant memory pressure with reasonable gas expenditure.

## Recommendation

Implement one or more of the following mitigations:

1. **Track Cache Memory**: Extend the memory quota mechanism to track raw serialized bytes in the resource group cache, not just deserialized values. When `load_to_cache()` adds data to the cache, call `use_heap_memory()` with the serialized byte size.

2. **Limit Cache Size**: Implement a maximum cache size limit (e.g., aligned with memory quota) that prevents accumulating excessive cached data in a single transaction.

3. **Granular Cache Loading**: Modify resource group cache behavior to only cache individual resources accessed, not entire groups, when in gas feature versions that support granular operations.

4. **Validate Read Cache**: Extend `check_change_set()` or add a new validation step to check total read cache size before processing.

The recommended fix is option 1, as it preserves the existing cache optimization while properly accounting for memory usage:

```rust
// In load_to_cache(), after inserting into cache:
if self.feature_version >= 3 {
    self.memory_meter.use_heap_memory(blob_len.into())?;
}
```

## Proof of Concept

```move
// Setup: Deploy this module to create resource groups
module attacker::resource_groups {
    use std::vector;
    
    #[resource_group(scope = global)]
    struct LargeResourceGroup has key {}
    
    struct Resource1 has key { data: vector<u8> }
    struct Resource2 has key { data: vector<u8> }
    // ... Resource3 through Resource10
    
    public entry fun create_large_group(account: &signer) {
        // Create group with 10 resources, each 50KB = 500KB total
        move_to(account, Resource1 { data: vector::tabulate(50000, |_| 0u8) });
        move_to(account, Resource2 { data: vector::tabulate(50000, |_| 0u8) });
        // ... move_to for Resource3-10
    }
    
    public entry fun attack_read_all_groups(account: &signer) acquires Resource1 {
        // Access one small resource from each of 1000 groups
        // This loads 500KB * 1000 = 500MB into cache
        // But memory quota only sees deserialized Resource1 values
        let i = 0;
        while (i < 1000) {
            let addr = @0x100 + i; // Assume groups at sequential addresses
            let _r1 = borrow_global<Resource1>(addr);
            // Memory quota: +1KB deserialized
            // Cache: +500KB serialized (untracked!)
            i = i + 1;
        };
    }
}
```

The attack succeeds because the memory quota check passes (~1MB tracked) while validator nodes hold ~500MB of untracked cached data.

## Notes

This vulnerability breaks the Move VM safety invariant that "bytecode execution must respect memory constraints" by allowing memory quota bypass through untracked cache accumulation. The issue affects all gas feature versions >= 3 where memory quota tracking is enabled. The attack is economically viable and requires no special privileges, making it a realistic threat to validator node stability.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L98-104)
```rust
            storage_io_per_state_byte_read: InternalGasPerByte,
            { 0..=9 => "load_data.per_byte", 10.. => "storage_io_per_state_byte_read"},
            // Notice in the latest IoPricing, bytes are charged at 4k intervals (even the smallest
            // read will be charged for 4KB) to reflect the assumption that every roughly 4k bytes
            // might require a separate random IO upon the FS.
            151,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L378-398)
```rust
    fn charge_load_resource(
        &mut self,
        addr: AccountAddress,
        ty: impl TypeView,
        val: Option<impl ValueView>,
        bytes_loaded: NumBytes,
    ) -> PartialVMResult<()> {
        if self.feature_version() != 0 {
            // TODO(Gas): Rewrite this in a better way.
            if let Some(val) = &val {
                self.use_heap_memory(
                    self.vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?,
                )?;
            }
        }

        self.base.charge_load_resource(addr, ty, val, bytes_loaded)
    }
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L118-119)
```rust
    group_cache: RefCell<HashMap<StateKey, (BTreeMap<StructTag, Bytes>, ResourceGroupSize)>>,
}
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L164-197)
```rust
    fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
        let already_cached = self.group_cache.borrow().contains_key(group_key);
        if already_cached {
            return Ok(true);
        }

        let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
        let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
            || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
            |group_data_blob| {
                let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                    PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                        format!(
                            "Failed to deserialize the resource group at {:? }: {:?}",
                            group_key, e
                        ),
                    )
                })?;
                Ok((group_data, group_data_blob.len() as u64))
            },
        )?;

        let group_size = match self.group_size_kind {
            GroupSizeKind::None => ResourceGroupSize::Concrete(0),
            GroupSizeKind::AsBlob => ResourceGroupSize::Concrete(blob_len),
            GroupSizeKind::AsSum => {
                group_size_as_sum(group_data.iter().map(|(t, v)| (t, v.len())))?
            },
        };
        self.group_cache
            .borrow_mut()
            .insert(group_key.clone(), (group_data, group_size));
        Ok(false)
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L347-351)
```rust
        let mut maybe_resource_group_cache = resolver.release_resource_group_cache().map(|v| {
            v.into_iter()
                .map(|(k, v)| (k, v.into_iter().collect::<BTreeMap<_, _>>()))
                .collect::<BTreeMap<_, _>>()
        });
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L86-128)
```rust
    pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {
        let storage_write_limit_reached = |maybe_message: Option<&str>| {
            let mut err = PartialVMError::new(StatusCode::STORAGE_WRITE_LIMIT_REACHED);
            if let Some(message) = maybe_message {
                err = err.with_message(message.to_string())
            }
            Err(err.finish(Location::Undefined).into_vm_status())
        };

        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```
