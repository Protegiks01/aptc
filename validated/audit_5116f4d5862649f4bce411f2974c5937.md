# Audit Report

## Title
Consensus Divergence Due to Backward Incompatible Gas Feature Version Handling in IoPricing

## Summary
Validators running outdated software can participate in consensus with newer on-chain `gas_feature_version` values but will compute different gas costs than updated validators, causing consensus divergence and network partition. The vulnerability stems from the lack of runtime validation ensuring validators only process gas feature versions their software supports.

## Finding Description

The vulnerability exists in the pattern matching logic of `IoPricing::new()` which selects gas pricing implementations based on `gas_feature_version`. [1](#0-0) 

When governance upgrades the on-chain `gas_feature_version` from 11 to 12, validators running software compiled before version 12 support was added would have pattern matching `10.. => V3(...)` that matches any value ≥10 including 12. Validators with updated software have explicit matching `10..=11 => V3` and `12.. => V4`, causing version 12 to use V4 instead.

The `gas_feature_version` is read directly from on-chain `GasScheduleV2` without validation against the software's `LATEST_GAS_FEATURE_VERSION`: [2](#0-1) 

**Critical Difference in Gas Calculations**:

IoPricingV3 charges for actual bytes read: [3](#0-2) 

IoPricingV4 rounds up to 4KB page boundaries (PAGE_SIZE=4096): [4](#0-3) 

For a 1000-byte resource read, V3 charges for 1000 bytes while V4 charges for 4096 bytes—a 4x difference.

**Consensus Impact**: The `gas_used` field is part of `TransactionInfoV0` which derives `CryptoHasher` and `BCSCryptoHash`: [5](#0-4) 

Different `gas_used` values produce different `TransactionInfo` hashes, causing validators to compute different transaction accumulator roots and fail to reach consensus on identical blocks.

**Missing Validation**: The on-chain Move contract only validates that versions don't decrease, not that they're within supported ranges: [6](#0-5) 

The only check for unsupported versions is a warning in the replay-benchmark tool, not in the production validator execution path: [7](#0-6) 

## Impact Explanation

**CRITICAL Severity** - This vulnerability meets multiple Critical severity criteria per the Aptos Bug Bounty program:

1. **Consensus/Safety Violations**: Breaks the fundamental consensus invariant requiring all validators to produce identical state roots for identical blocks. Validators compute different `TransactionInfo` hashes due to different gas calculations, preventing consensus.

2. **Non-recoverable Network Partition**: When validators split between software versions after a gas feature upgrade, they cannot reach consensus. Recovery requires emergency rollback of the on-chain `gas_feature_version`, forced simultaneous upgrade of all validators, or potential hard fork.

3. **Total Loss of Liveness**: The network cannot produce new blocks while validators are split, as they cannot agree on transaction execution results.

The severity is amplified because:
- It affects the entire network, not individual validators
- It's triggered by routine governance operations (gas schedule upgrades)
- No attacker action is required—it occurs naturally during upgrades
- The divergence is deterministic and permanent until administratively resolved

## Likelihood Explanation

**HIGH Likelihood** - This scenario can occur during normal protocol upgrades:

1. **Frequent Gas Schedule Updates**: Version 12 introduced 4KB page-aligned I/O charging specifically. [8](#0-7)  The changelog documents 40+ gas feature versions, indicating regular upgrades.

2. **No Technical Enforcement**: The system lacks validation preventing governance from setting a `gas_feature_version` higher than what validators support. Validators read and use whatever version is on-chain without checking against their `LATEST_GAS_FEATURE_VERSION`.

3. **Governance Independence**: Gas schedule upgrades via `set_for_next_epoch()` are independent governance actions with no coordination mechanism ensuring all validators have upgraded their software first.

4. **Upgrade Window Vulnerability**: Even if operational practices aim to upgrade validators before governance changes, any timing gap, incomplete validator upgrades, or coordination failure creates the vulnerability window.

The likelihood is HIGH because the system relies entirely on operational discipline rather than code-level enforcement to prevent this scenario.

## Recommendation

Implement runtime validation in the validator execution path to reject blocks when `gas_feature_version` exceeds the validator's `LATEST_GAS_FEATURE_VERSION`:

```rust
// In aptos-move/aptos-vm-environment/src/gas.rs
use aptos_gas_schedule::LATEST_GAS_FEATURE_VERSION;

pub fn get_gas_feature_version(state_view: &impl StateView) -> Result<u64, String> {
    let version = GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0);
    
    if version > LATEST_GAS_FEATURE_VERSION {
        return Err(format!(
            "Unsupported gas_feature_version: on-chain version {} exceeds validator's maximum supported version {}. Validator software upgrade required.",
            version,
            LATEST_GAS_FEATURE_VERSION
        ));
    }
    
    Ok(version)
}
```

Additionally, add on-chain validation in `gas_schedule.move` to enforce maximum allowable version jumps or require validator readiness signals before version upgrades can be applied.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Starting with validators running software compiled with version 11 support (pattern: `10.. => V3`)
2. Governance proposal executes `set_for_next_epoch()` with `gas_feature_version = 12`
3. Validators with old software: match 12 to V3, charge 1000 bytes for 1KB read
4. Validators with new software: match 12 to V4, charge 4096 bytes for 1KB read
5. Same transaction produces different `gas_used` values
6. Different `TransactionInfo` hashes computed
7. Consensus fails—validators cannot agree on block execution results

A full PoC would require setting up a multi-validator testnet with mixed software versions and triggering a gas feature version upgrade through governance, which is beyond the scope of this static analysis but the code paths are confirmed through the citations above.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L167-172)
```rust
    fn calculate_read_gas(
        &self,
        loaded: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1) + STORAGE_IO_PER_STATE_BYTE_READ * loaded
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L204-218)
```rust
    fn calculate_read_gas(
        &self,
        loaded: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        // Round up bytes to whole pages
        // TODO(gas): make PAGE_SIZE configurable
        const PAGE_SIZE: u64 = 4096;

        let loaded_u64: u64 = loaded.into();
        let r = loaded_u64 % PAGE_SIZE;
        let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

        STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1)
            + STORAGE_IO_PER_STATE_BYTE_READ * NumBytes::new(rounded_up)
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L250-265)
```rust
        match feature_version {
            0 => V1(IoPricingV1::new(gas_params)),
            1..=9 => match StorageGasSchedule::fetch_config(config_storage) {
                None => V1(IoPricingV1::new(gas_params)),
                Some(schedule) => V2(IoPricingV2::new_with_storage_curves(
                    feature_version,
                    &schedule,
                    gas_params,
                )),
            },
            10..=11 => V3(IoPricingV3 {
                feature_version,
                legacy_free_write_bytes_quota: gas_params.vm.txn.legacy_free_write_bytes_quota,
            }),
            12.. => V4(IoPricingV4),
        }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** types/src/transaction/mod.rs (L2023-2027)
```rust
#[derive(Clone, CryptoHasher, BCSCryptoHash, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L97-100)
```text
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
```

**File:** aptos-move/replay-benchmark/src/overrides.rs (L76-81)
```rust
        if matches!(gas_feature_version, Some(v) if v > LATEST_GAS_FEATURE_VERSION) {
            warn!(
                "Gas feature version is greater than the latest one: {}",
                LATEST_GAS_FEATURE_VERSION
            );
        }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L38-41)
```rust
/// - V12
///   - Added BN254 operations.
///   - IO gas change: 1. read bytes charged at 4KB intervals; 2. ignore free_write_bytes_quota
///   - aggregator v2 gas charges
```
