# Audit Report

## Title
High-Priority Transaction Permanent Starvation Due to Priority Queue Ordering with Sequence Number Dependencies

## Summary
The `get_batch()` function in the mempool can permanently starve legitimate high-priority transactions when lower sequence number transactions from the same account have very low gas prices and the mempool is consistently full with high-priority transactions from other accounts. This violates the gas-price-based priority guarantee and can prevent time-sensitive transactions from being executed.

## Finding Description

The mempool's `get_batch()` function uses a priority queue ordered by `gas_ranking_score` to select transactions for consensus blocks. [1](#0-0)  The priority queue iterator returns transactions in reverse order (highest gas ranking score first). [2](#0-1) 

However, sequence number transactions have a strict ordering requirement enforced at the point of batch selection. [3](#0-2) 

The vulnerability occurs when:

1. An account has transaction `seq=100` with very low `gas_ranking_score` (e.g., 1)
2. The same account has transactions `seq=101, 102, 103` with very high `gas_ranking_score` (e.g., 1000000)
3. The mempool is full with many high-priority transactions from different accounts

**Attack Scenario:**

When `get_batch()` is called with the default `max_txns=50` [4](#0-3) :

1. The priority queue iteration encounters `seq=101, 102, 103` first due to high ranking scores
2. These transactions cannot be included because `seq=100` hasn't been chosen yet and the sequence number check fails
3. They are added to the `skipped` HashSet [5](#0-4) 
4. The batch fills up with 50 high-priority transactions from OTHER accounts before ever reaching `seq=100` in the priority queue
5. The loop breaks when `max_txns` is reached [6](#0-5) 
6. The skipped transaction promotion logic **never executes** for `seq=100` because it only runs after a transaction is successfully included [7](#0-6) 
7. The `skipped` HashSet is local to each `get_batch()` call [8](#0-7) , so it doesn't persist
8. On the next `get_batch()` call, the cycle repeats indefinitely

The code comments explicitly acknowledge this scenario was anticipated and the skipped/promotion mechanism was designed to handle it. [9](#0-8)  However, this mechanism fails when the batch fills before reaching the blocking transaction.

**Broken Invariant:** This violates the fundamental guarantee that higher gas prices result in faster transaction inclusion. Transactions with `gas_ranking_score=1000000` are permanently blocked by a transaction with `gas_ranking_score=1`.

## Impact Explanation

**Severity: MEDIUM** (per Aptos bug bounty criteria)

This vulnerability causes:

1. **State inconsistencies requiring manual intervention** - Users cannot execute their high-priority transactions despite paying high gas fees without manually resubmitting the blocking transaction with higher gas
2. **Limited funds loss or manipulation** - Users may lose arbitrage opportunities, fail to prevent liquidations, or miss time-sensitive DeFi operations
3. **Protocol degradation** - Breaks the gas price priority mechanism, a core blockchain invariant

**Affected Users:**
- Any account that submits transactions with varying gas prices across different sequence numbers
- Users needing urgent transaction execution (liquidations, arbitrage, governance votes)
- Can affect multiple accounts if attackers deliberately create this scenario

**Attack Cost:** Very low - attacker only needs to submit one low-gas transaction followed by high-gas transactions from the same account.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** in congested network conditions

**Factors increasing likelihood:**

1. **Network Congestion**: During high transaction volume, batches consistently fill to `max_txns` with high-priority transactions. The quorum store uses backpressure mechanisms that can result in consistent batch filling. [10](#0-9) 

2. **Deliberate Attack**: Malicious actors can intentionally create this scenario:
   - Submit `seq=N` with `gas_unit_price=1` (minimum)
   - Submit `seq=N+1, N+2, ...` with `gas_unit_price=MAX`
   - Watch high-priority transactions starve indefinitely

3. **Accidental Occurrence**: Users who submit a low-priority transaction first, then urgent high-priority transactions later will experience this

4. **No Automatic Recovery**: Unlike temporary delays, this is **permanent starvation** until:
   - Network congestion decreases significantly
   - The low-priority transaction expires (TTL) and is garbage collected
   - User manually increases gas price on the blocking transaction

**Likelihood is REDUCED when:**
- Network has low transaction volume
- Batches don't consistently reach `max_txns` limit

## Recommendation

Implement one of the following fixes:

**Option 1: Continue iteration after max_txns reached for same-account promotions**
- After breaking at line 475, continue checking for skipped transactions from accounts whose blocking transactions were just included
- This ensures the promotion logic can complete even when the batch is full

**Option 2: Prioritize blocking transactions**
- When a high-priority transaction is skipped due to sequence number dependencies, boost the priority of its blocking predecessor
- This ensures blocking transactions are included earlier in the iteration

**Option 3: Reserve batch slots for blocking transactions**
- Reserve a portion of `max_txns` for transactions that unblock high-priority skipped transactions
- Check the skipped set before finalizing the batch and try to include blocking transactions

## Proof of Concept

While a full executable PoC is not provided, the vulnerability can be reproduced with the following scenario:

1. Deploy a local Aptos testnet
2. Create an account with sufficient funds
3. Submit transaction with `seq=100`, `gas_unit_price=1`
4. Submit transactions with `seq=101-110`, `gas_unit_price=1000000`
5. Flood mempool with 50+ transactions from other accounts with `gas_unit_price > 100`
6. Observe that `seq=101-110` are never included in batches despite their high gas prices
7. Monitor mempool to confirm `seq=100` remains in mempool but is never reached during iteration
8. Verify the starvation persists across multiple `get_batch()` calls

The vulnerability is demonstrated by code analysis showing the iteration breaks before reaching low-priority blocking transactions, and the promotion logic only executes for transactions that are successfully included.

### Citations

**File:** mempool/src/core_mempool/index.rs (L167-169)
```rust
    pub(crate) fn iter(&self) -> PriorityQueueIter<'_> {
        self.data.iter().rev()
    }
```

**File:** mempool/src/core_mempool/index.rs (L192-214)
```rust
impl Ord for OrderedQueueKey {
    fn cmp(&self, other: &OrderedQueueKey) -> Ordering {
        // Higher gas preferred
        match self.gas_ranking_score.cmp(&other.gas_ranking_score) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Lower insertion time preferred
        match self.insertion_time.cmp(&other.insertion_time).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        // Higher address preferred
        match self.address.cmp(&other.address) {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        match self.replay_protector.cmp(&other.replay_protector).reverse() {
            Ordering::Equal => {},
            ordering => return ordering,
        }
        self.hash.cmp(&other.hash)
    }
```

**File:** mempool/src/core_mempool/mempool.rs (L439-444)
```rust
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
```

**File:** mempool/src/core_mempool/mempool.rs (L445-445)
```rust
        let mut skipped = HashSet::new();
```

**File:** mempool/src/core_mempool/mempool.rs (L459-471)
```rust
                ReplayProtector::SequenceNumber(txn_seq) => {
                    let txn_in_sequence = txn_seq > 0
                        && Self::txn_was_chosen(
                            txn.address,
                            txn_seq - 1,
                            &inserted,
                            &exclude_transactions,
                        );
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
```

**File:** mempool/src/core_mempool/mempool.rs (L474-475)
```rust
                        if (result.len() as u64) == max_txns {
                            break;
```

**File:** mempool/src/core_mempool/mempool.rs (L477-494)
```rust
                        // check if we can now include some transactions
                        // that were skipped before for given account
                        let (skipped_txn_sender, mut skipped_txn_seq_num) =
                            (txn.address, txn_seq + 1);
                        while skipped.remove(&(skipped_txn_sender, skipped_txn_seq_num)) {
                            inserted.insert((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            result.push((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            if (result.len() as u64) == max_txns {
                                break 'main;
                            }
                            skipped_txn_seq_num += 1;
                        }
```

**File:** mempool/src/core_mempool/mempool.rs (L495-496)
```rust
                    } else {
                        skipped.insert((txn.address, txn_seq));
```

**File:** config/src/config/quorum_store_config.rs (L13-13)
```rust
pub const DEFEAULT_MAX_BATCH_TXNS: usize = 50;
```

**File:** config/src/config/quorum_store_config.rs (L29-46)
```rust
impl Default for QuorumStoreBackPressureConfig {
    fn default() -> QuorumStoreBackPressureConfig {
        QuorumStoreBackPressureConfig {
            // QS will be backpressured if the remaining total txns is more than this number
            // Roughly, target TPS * commit latency seconds
            backlog_txn_limit_count: 36_000,
            // QS will create batches at the max rate until this number is reached
            backlog_per_validator_batch_limit_count: 20,
            decrease_duration_ms: 1000,
            increase_duration_ms: 1000,
            decrease_fraction: 0.5,
            dynamic_min_txn_per_s: 160,
            dynamic_max_txn_per_s: 12000,
            // When the QS is no longer backpressured, we increase number of txns to be pulled from mempool
            // by this amount every second until we reach dynamic_max_txn_per_s
            additive_increase_when_no_backpressure: 2000,
        }
    }
```
