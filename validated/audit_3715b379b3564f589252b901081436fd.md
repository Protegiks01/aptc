# Audit Report

## Title
Hot State Race Condition in get_persisted_state() Breaks Deterministic Execution Across Validators

## Summary
The `get_persisted_state()` function returns a shared `Arc<HotStateBase>` that background commit threads can modify concurrently during block execution. This allows validators executing the same block to read different hot state values depending on commit timing, breaking consensus determinism and causing validators to produce different state roots for identical blocks.

## Finding Description

The vulnerability exists in the state lookup hierarchy used during transaction execution. When validators execute a block, they create a `CachedStateView` that queries state in three layers: speculative state (in-memory changes), hot state (cached frequently-accessed keys), and cold state (database).

**The Core Issue:**

The `get_persisted_state()` method returns an `Arc` clone of `HotStateBase`, which shares the same underlying `DashMap` with background commit threads: [1](#0-0) 

This Arc clone points to the same `HotStateBase` instance that the background `Committer` thread directly modifies: [2](#0-1) 

The `HotStateBase` uses `DashMap` for concurrent access, allowing interior mutability: [3](#0-2) 

**The Race Condition:**

When `CachedStateView` reads from hot state, it performs no version validation: [4](#0-3) 

At line 239, the hot state lookup returns `StateSlot` values directly without checking if the `value_version` field exceeds the `base_version` of the execution context. In contrast, cold state reads properly use `base_version` as a parameter (line 246).

The `Committer::run()` method updates the HotStateBase before updating the committed State, creating a race window: [5](#0-4) 

At line 196, `commit()` modifies `self.base` (the shared HotStateBase), and at line 197, it updates `self.committed`. If `get_committed()` is called between these operations, it returns the old State but the new HotStateBase contents.

**Concrete Attack Scenario:**

1. All validators receive block N to execute with parent state at version 100
2. Validator A calls `get_persisted_state()` obtaining State{version: 100} and Arc<HotStateBase>
3. Validator A's background Committer updates HotStateBase with version 101 data during execution
4. Validator B's background Committer hasn't updated yet, HotStateBase remains at version 100
5. Both validators read the same key K from hot state:
   - Validator A gets `StateSlot::HotOccupied { value_version: 101, value: Y, ... }`
   - Validator B gets `StateSlot::HotOccupied { value_version: 100, value: X, ... }`
6. Validators produce different execution outputs and state roots for identical block N
7. Consensus fails to reach agreement, causing liveness issues

The `StateSlot` enum structure confirms version tracking in hot state: [6](#0-5) 

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos bug bounty program category "Consensus/Safety Violations":

**Breaks Deterministic Execution Invariant**: The fundamental requirement of blockchain consensus is that all validators must produce identical state roots when executing identical blocks. This vulnerability violates that invariant by allowing different validators to observe different state values during execution of the same block.

**Consensus Safety Violation**: When validators disagree on execution results for the same block, the consensus protocol cannot achieve agreement. This leads to:
- Failed block proposals requiring reproposal and retries
- Potential validator disagreements on state transitions  
- Liveness degradation as consensus stalls
- In severe cases, persistent disagreement requiring manual intervention or hardfork

**Non-Recoverable Architecture Issue**: Unlike transient bugs that can be resolved with restarts, this race condition is inherent to the concurrent architecture. The shared mutable `HotStateBase` combined with asynchronous background commits creates a fundamental synchronization gap.

This aligns with the Critical severity criteria: "Different validators commit different blocks" and "Consensus/Safety violations" in the Aptos bug bounty program.

## Likelihood Explanation

**High Likelihood** - This race condition manifests naturally during normal network operation:

**Continuous Background Commits**: The `BufferedState` system commits snapshots approximately every 100,000 versions: [7](#0-6) 

**Independent Validator Timing**: Each validator's local storage commits independently and asynchronously. When consensus proposes a block, all validators execute it concurrently but their background commit threads complete at different times based on local CPU scheduling, disk I/O, and workload.

**No Synchronization**: The execution path shows no locks or barriers preventing hot state updates during block execution. The `base` Arc is cloned without holding the `committed` mutex: [1](#0-0) 

**Substantial Race Window**: The commit process involves merklization and database writes spanning milliseconds to seconds, providing ample opportunity for the race to manifest.

No attacker intervention is required - the vulnerability triggers through normal concurrent operation of the validator network.

## Recommendation

Implement version validation when reading from hot state to ensure `value_version <= base_version`. Modify the hot state lookup in `CachedStateView::get_unmemorized()` to filter out entries with versions exceeding the base_version:

```rust
} else if let Some(slot) = self.hot.get_state_slot(state_key) {
    // Validate that hot state entry is not newer than base_version
    if let Some(base_ver) = self.base_version() {
        if slot.expect_value_version() > base_ver {
            // Entry is too new, skip hot state and read from cold
            COUNTER.inc_with(&["sv_cold"]);
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_ver)?,
            )
        } else {
            COUNTER.inc_with(&["sv_hit_hot"]);
            slot
        }
    } else {
        COUNTER.inc_with(&["sv_hit_hot"]);
        slot
    }
```

Alternatively, use atomic updates to ensure `HotStateBase` and `committed` State are updated together, or implement a versioned hot state structure that explicitly tracks which version's data it contains.

## Proof of Concept

The vulnerability manifests during normal validator operation and does not require a specific PoC transaction. To observe:

1. Deploy a validator with instrumentation logging `value_version` from hot state reads and `base_version` from execution context
2. Run under normal block execution load
3. Monitor for instances where `value_version > base_version` during hot state reads
4. Compare execution results across validators during periods of active background commits

The race condition is inherent to the architecture and will manifest probabilistically during normal operation when background commits occur during block execution.

## Notes

This vulnerability is architectural and occurs at the storage layer, not requiring Move VM exploitation or transaction manipulation. The fix requires careful synchronization between the hot state cache and the execution base version to maintain the deterministic execution guarantee essential for blockchain consensus.

### Citations

**File:** storage/aptosdb/src/state_store/hot_state.rs (L72-78)
```rust
#[derive(Debug)]
pub struct HotStateBase<K = StateKey, V = StateSlot>
where
    K: Eq + std::hash::Hash,
{
    shards: [Shard<K, V>; NUM_STATE_SHARDS],
}
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L131-136)
```rust
    pub fn get_committed(&self) -> (Arc<dyn HotStateView>, State) {
        let state = self.committed.lock().clone();
        let base = self.base.clone();

        (base, state)
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L172-178)
```rust
impl Committer {
    fn spawn(base: Arc<HotStateBase>, committed: Arc<Mutex<State>>) -> SyncSender<State> {
        let (tx, rx) = std::sync::mpsc::sync_channel(MAX_HOT_STATE_COMMIT_BACKLOG);
        std::thread::spawn(move || Self::new(base, committed, rx).run());

        tx
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L192-205)
```rust
    fn run(&mut self) {
        info!("HotState committer thread started.");

        while let Some(to_commit) = self.next_to_commit() {
            self.commit(&to_commit);
            *self.committed.lock() = to_commit;

            GAUGE.set_with(&["hot_state_items"], self.base.len() as i64);
            GAUGE.set_with(&["hot_state_key_bytes"], self.total_key_bytes as i64);
            GAUGE.set_with(&["hot_state_value_bytes"], self.total_value_bytes as i64);
        }

        info!("HotState committer quitting.");
    }
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L233-253)
```rust
    fn get_unmemorized(&self, state_key: &StateKey) -> Result<StateSlot> {
        COUNTER.inc_with(&["sv_unmemorized"]);

        let ret = if let Some(slot) = self.speculative.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_speculative"]);
            slot
        } else if let Some(slot) = self.hot.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_hot"]);
            slot
        } else if let Some(base_version) = self.base_version() {
            COUNTER.inc_with(&["sv_cold"]);
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_version)?,
            )
        } else {
            StateSlot::ColdVacant
        };

        Ok(ret)
    }
```

**File:** types/src/state_store/state_slot.rs (L34-40)
```rust
    HotOccupied {
        value_version: Version,
        value: StateValue,
        hot_since_version: Version,
        lru_info: LRUEntry<StateKey>,
    },
}
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L28-29)
```rust
pub(crate) const ASYNC_COMMIT_CHANNEL_BUFFER_SIZE: u64 = 1;
pub(crate) const TARGET_SNAPSHOT_INTERVAL_IN_VERSION: u64 = 100_000;
```
