# Audit Report

## Title
Validator Node Panic via Forked Block Certificate in `send_for_execution` - Unhandled None from `path_from_ordered_root`

## Summary
The `send_for_execution` method in the consensus layer incorrectly handles the case where a block is not a descendant of the ordered root, causing validator nodes to panic when processing legitimate QuorumCerts for forked blocks. This vulnerability enables denial-of-service attacks against validators through crafted but validly-signed SyncInfo messages.

## Finding Description

The vulnerability exists in the interaction between multiple consensus components that fail to validate fork ancestry before attempting block execution.

**1. Documented Semantics:**

The `BlockReader` trait explicitly documents that `path_from_ordered_root` returns `None` when "a given block is not the successor of the root." [1](#0-0) 

**2. Implementation Behavior:**

The `path_from_root_to_block` implementation traverses backwards from a target block to the root. When it reaches a block at or below the root round but the block ID doesn't match the root ID (indicating the block is on a different fork), it correctly returns `None`. [2](#0-1) 

**3. Panic in `send_for_execution`:**

The `send_for_execution` method treats the `None` return value as impossible. It uses `unwrap_or_default()` to convert `None` to an empty vector, then immediately asserts the vector is non-empty, causing a panic. [3](#0-2) 

**4. Insufficient Validation:**

The `insert_quorum_cert` method calls `send_for_execution` after only validating that the commit round is greater than the ordered root round—it does NOT verify that the commit block is a descendant of the ordered root. [4](#0-3) 

**5. Fork Support Acknowledgment:**

The codebase explicitly acknowledges that blocks may not be ancestors of each other due to forks, confirming this is a realistic scenario. [5](#0-4) 

**Attack Path:**

1. A validator receives a SyncInfo message via `process_sync_info_msg` [6](#0-5) 

2. The flow proceeds through `add_certs` to `insert_quorum_cert` [7](#0-6) 

3. Since the commit block exists in the block store and has a higher round than the ordered root, `send_for_execution` is called

4. `path_from_ordered_root` correctly returns `None` because the block is on a different fork

5. The assertion fails and the validator panics

This violates the consensus liveness invariant: validators must handle valid network messages without crashing.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria (up to $50,000):

This vulnerability enables **validator node crashes** through validly-signed consensus messages:

- **Consensus Layer Impact**: The crash occurs during certificate processing in the core consensus layer, affecting the validator's ability to participate in consensus

- **Liveness Disruption**: Repeated exploitation can target multiple validators, disrupting consensus rounds and delaying block finalization

- **Temporary Availability Loss**: Validators crash but can recover by restarting, making this a temporary liveness issue rather than a permanent network halt

- **No Safety Violation**: The vulnerability affects liveness only—it doesn't enable double-spending, chain splits, fund theft, or permanent state corruption

This fits the High severity category for "API Crashes" affecting network participation, with additional severity due to its consensus layer location.

## Likelihood Explanation

**High Likelihood:**

1. **Natural Precondition**: Forks occur routinely during normal consensus when validators observe different proposals for the same round or experience transient network partitions

2. **Low Attack Barrier**: 
   - Any network participant can send SyncInfo messages to validators
   - The attack requires a valid QuorumCert with 2f+1 signatures, which exist naturally during consensus forking
   - No validator credentials or special permissions needed

3. **Deterministic Exploitation**: Once a valid QC for a forked block is obtained, the attack succeeds reliably against any validator processing the message

4. **Difficult Detection**: The panic appears as an assertion failure in normal consensus operation, making it hard to distinguish from implementation bugs without detailed investigation

## Recommendation

Add ancestry validation before calling `send_for_execution`:

```rust
pub async fn insert_quorum_cert(
    &self,
    qc: &QuorumCert,
    retriever: &mut BlockRetriever,
) -> anyhow::Result<()> {
    // ... existing code ...
    
    if self.ordered_root().round() < qc.commit_info().round() {
        // Verify the commit block is a descendant of the ordered root
        if self.path_from_ordered_root(qc.commit_info().id()).is_none() {
            // Block is on a different fork - skip execution
            warn!("Skipping execution for forked block: {:?}", qc.commit_info().id());
            return Ok(());
        }
        
        SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
        self.send_for_execution(qc.into_wrapped_ledger_info()).await?;
        // ... rest of code ...
    }
    Ok(())
}
```

Alternatively, handle the `None` case gracefully in `send_for_execution`:

```rust
let blocks_to_commit = self
    .path_from_ordered_root(block_id_to_commit)
    .ok_or_else(|| format_err!("Block not a descendant of ordered root"))?;
```

## Proof of Concept

A complete PoC would require setting up a test consensus network with forked blocks. The vulnerability can be triggered by:

1. Creating a block tree with two forks from a common ancestor
2. Setting the ordered root to a block on Fork A
3. Inserting a QuorumCert with commit_info pointing to a block on Fork B (with round > ordered_root.round())
4. The validator panics when attempting to execute the forked block

The core issue is verifiable by examining the code paths identified above.

## Notes

This vulnerability highlights a mismatch between the documented behavior of `path_from_ordered_root` (which explicitly returns `None` for non-descendant blocks) and the assumptions made by `send_for_execution` (which treats `None` as impossible). The codebase's own acknowledgment that forks can cause blocks to not be ancestors of each other confirms this is a realistic scenario that should be properly handled.

### Citations

**File:** consensus/src/block_storage/mod.rs (L39-46)
```rust
    /// Returns all the blocks between the ordered/commit root and the given block, including the given block
    /// but excluding the root.
    /// In case a given block is not the successor of the root, return None.
    /// For example if a tree is b0 <- b1 <- b2 <- b3, then
    /// path_from_root(b2) -> Some([b2, b1])
    /// path_from_root(b0) -> Some([])
    /// path_from_root(a) -> None
    fn path_from_ordered_root(&self, block_id: HashValue) -> Option<Vec<Arc<PipelinedBlock>>>;
```

**File:** consensus/src/block_storage/block_tree.rs (L519-546)
```rust
    pub(super) fn path_from_root_to_block(
        &self,
        block_id: HashValue,
        root_id: HashValue,
        root_round: u64,
    ) -> Option<Vec<Arc<PipelinedBlock>>> {
        let mut res = vec![];
        let mut cur_block_id = block_id;
        loop {
            match self.get_block(&cur_block_id) {
                Some(ref block) if block.round() <= root_round => {
                    break;
                },
                Some(block) => {
                    cur_block_id = block.parent_id();
                    res.push(block);
                },
                None => return None,
            }
        }
        // At this point cur_block.round() <= self.root.round()
        if cur_block_id != root_id {
            return None;
        }
        // Called `.reverse()` to get the chronically increased order.
        res.reverse();
        Some(res)
    }
```

**File:** consensus/src/block_storage/block_store.rs (L327-331)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/sync_manager.rs (L144-145)
```rust
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L154-157)
```rust
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/round_manager.rs (L938-950)
```rust
    pub async fn process_sync_info_msg(
        &mut self,
        sync_info: SyncInfo,
        peer: Author,
    ) -> anyhow::Result<()> {
        fail_point!("consensus::process_sync_info_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_sync_info_msg"))
        });
        info!(
            self.new_log(LogEvent::ReceiveSyncInfo).remote_peer(peer),
            "{}", sync_info
        );
        self.ensure_round_and_sync_up(checked!((sync_info.highest_round()) + 1)?, &sync_info, peer)
```
