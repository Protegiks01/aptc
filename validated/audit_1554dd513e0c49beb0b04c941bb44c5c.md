# Audit Report

## Title
Division by Zero Panic in Batch Requester Causes Validator Node Crash with Empty Responders

## Summary
The `next_request_peers()` function in the batch requester performs modulo operations on `signers.len()` without validating that the responders set is non-empty. When empty responders are passed to `request_batch()`, the function panics on division by zero, immediately crashing the validator node.

## Finding Description

The vulnerability exists in the batch requester's peer selection logic used during quorum store batch fetching in consensus.

**Critical Flaw Locations:**

The `next_request_peers()` method performs unchecked modulo operations without verifying that `signers.len()` is non-zero: [1](#0-0) [2](#0-1) 

Both lines execute `% signers.len()` operations that panic if the BTreeSet is empty.

**Execution Path:**

1. During payload processing, `process_qs_payload()` calls `shuffled_signers()` to extract responders from ProofOfStore objects: [3](#0-2) 

2. The `shuffled_signers()` method calls `get_signers_addresses()` to extract signer addresses: [4](#0-3) 

3. The `get_signers_addresses()` implementation can return an empty vector if no bitmask bits match indices in the provided array: [5](#0-4) 

4. Empty responders are converted to an empty BTreeSet in `get_or_fetch_batch()`: [6](#0-5) 

5. The empty BTreeSet is passed to `request_batch()` which creates a `BatchRequesterState`: [7](#0-6) [8](#0-7) 

6. When the retry interval triggers and `next_request_peers()` is called, the modulo operation causes an immediate panic.

**Triggering Conditions:**

The vulnerability can be triggered when:
- Validator set initialization produces an empty `ordered_authors` array. ValidatorVerifier explicitly allows empty validator sets: [9](#0-8) 

- Race conditions during epoch transitions where `ordered_authors` becomes temporarily empty or misaligned with ProofOfStore bitmask indices
- Configuration errors resulting in empty or mismatched validator sets

**Lack of Defensive Validation:**

No validation exists anywhere in the code path to check for empty responders before invoking the batch requester. The `ordered_authors` is obtained directly from the validator verifier: [10](#0-9) [11](#0-10) 

Test files consistently use at least one responder, indicating this edge case was never considered: [12](#0-11) [13](#0-12) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program:

**Validator Node Crashes**: When triggered, the panic immediately terminates the validator process, requiring manual restart. This directly matches the "Validator node slowdowns/API crashes" category (up to $50,000).

**Consensus Liveness Impact**: If multiple validators encounter this condition simultaneously during epoch transitions or initialization, it could cause:
- Temporary loss of consensus progress
- Block proposal failures requiring timeouts and leader rotation
- Degraded network performance during recovery
- Validators falling out of sync

**Availability Impact**: Affected validators experience complete downtime until manually restarted, violating availability guarantees expected in production blockchain networks.

The vulnerability breaks the **Consensus Liveness** invariant by causing validator crashes that prevent normal block processing.

## Likelihood Explanation

**Likelihood: LOW**

While the vulnerability is a demonstrable code bug that will cause crashes if triggered, the conditions required are edge cases:

**Factors Decreasing Likelihood:**
- Production networks maintain non-empty validator sets under normal operation
- ProofOfStore verification ensures quorum voting power through `verify_multi_signatures`: [14](#0-13) 

**Factors Increasing Likelihood:**
- ValidatorVerifier explicitly permits empty validator sets, indicating the code should defensively handle this case
- No validation prevents empty responders from reaching the panic point
- Race conditions during validator set initialization could temporarily create invalid state
- This constitutes a logic vulnerability where defensive programming is missing for an explicitly allowed edge case

The primary risk is during system startup, epoch boundaries, or configuration errors rather than normal runtime operation.

## Recommendation

Add validation in `next_request_peers()` to check for empty signers before performing modulo operations:

```rust
fn next_request_peers(&mut self, num_peers: usize) -> Option<Vec<PeerId>> {
    let signers = self.signers.lock();
    
    // Add defensive check for empty signers
    if signers.is_empty() {
        return None;
    }
    
    if self.num_retries == 0 {
        let mut rng = rand::thread_rng();
        self.next_index = rng.gen::<usize>() % signers.len();
        counters::SENT_BATCH_REQUEST_COUNT.inc_by(num_peers as u64);
    } else {
        counters::SENT_BATCH_REQUEST_RETRY_COUNT.inc_by(num_peers as u64);
    }
    // ... rest of function
}
```

Additionally, consider adding validation when extracting responders in `get_or_fetch_batch()` to log warnings when empty responder sets are detected.

## Proof of Concept

```rust
#[tokio::test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
async fn test_batch_request_empty_responders() {
    use consensus::quorum_store::batch_requester::BatchRequester;
    use aptos_infallible::Mutex;
    use std::collections::BTreeSet;
    use std::sync::Arc;
    
    let validator_signer = ValidatorSigner::random(None);
    let batch_requester = BatchRequester::new(
        1,
        AccountAddress::random(),
        1,
        2,
        1_000,
        1_000,
        MockBatchRequester::new(/* mock response */),
        ValidatorVerifier::new_single(validator_signer.author(), validator_signer.public_key()).into(),
    );
    
    let (_, subscriber_rx) = oneshot::channel();
    // Pass empty BTreeSet as responders - this will panic
    let result = batch_requester
        .request_batch(
            HashValue::random(),
            10_000,
            Arc::new(Mutex::new(BTreeSet::new())), // Empty responders
            subscriber_rx,
        )
        .await;
}
```

## Notes

This is a **logic vulnerability** where the code fails to defensively handle an edge case explicitly allowed by the type system. The `ValidatorVerifier::new()` constructor includes special handling for empty validator sets (setting `quorum_voting_power` to 0), which indicates empty sets are a valid system state that all dependent code should handle gracefully. The batch requester's failure to check for empty signers before performing modulo operations represents a defensive programming failure that can crash validator nodes under specific initialization or configuration scenarios.

### Citations

**File:** consensus/src/quorum_store/batch_requester.rs (L45-45)
```rust
            self.next_index = rng.r#gen::<usize>() % signers.len();
```

**File:** consensus/src/quorum_store/batch_requester.rs (L59-59)
```rust
            self.next_index = (self.next_index + num_peers) % signers.len();
```

**File:** consensus/src/quorum_store/batch_requester.rs (L109-109)
```rust
        let mut request_state = BatchRequesterState::new(responders, self.retry_limit);
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L654-654)
```rust
                    proof.shuffled_signers(ordered_authors),
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L654-658)
```rust
    pub fn shuffled_signers(&self, ordered_authors: &[PeerId]) -> Vec<PeerId> {
        let mut ret: Vec<PeerId> = self.multi_signature.get_signers_addresses(ordered_authors);
        ret.shuffle(&mut thread_rng());
        ret
    }
```

**File:** types/src/aggregate_signature.rs (L43-58)
```rust
    pub fn get_signers_addresses(
        &self,
        validator_addresses: &[AccountAddress],
    ) -> Vec<AccountAddress> {
        validator_addresses
            .iter()
            .enumerate()
            .filter_map(|(index, addr)| {
                if self.validator_bitmask.is_set(index as u16) {
                    Some(*addr)
                } else {
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L668-668)
```rust
        let mut responders = responders.into_iter().collect();
```

**File:** consensus/src/quorum_store/batch_store.rs (L696-702)
```rust
                        let payload = requester
                            .request_batch(
                                batch_digest,
                                batch_info.expiration(),
                                responders,
                                subscriber_rx,
                            )
```

**File:** types/src/validator_verifier.rs (L206-213)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
```

**File:** types/src/validator_verifier.rs (L337-339)
```rust
    pub fn get_ordered_account_addresses(&self) -> Vec<AccountAddress> {
        self.get_ordered_account_addresses_iter().collect_vec()
    }
```

**File:** types/src/validator_verifier.rs (L345-363)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L458-458)
```rust
                self.verifier.get_ordered_account_addresses(),
```

**File:** consensus/src/quorum_store/tests/batch_requester_test.rs (L134-134)
```rust
            Arc::new(Mutex::new(btreeset![AccountAddress::random()])),
```

**File:** consensus/src/quorum_store/tests/batch_requester_test.rs (L224-224)
```rust
            Arc::new(Mutex::new(btreeset![AccountAddress::random()])),
```
