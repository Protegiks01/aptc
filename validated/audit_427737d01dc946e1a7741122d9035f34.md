# Audit Report

## Title
Consensus Liveness Failure: SecretShareManager Panics on Blocks Without Encrypted Transactions

## Summary
When secret sharing is enabled at the epoch level, the `SecretShareManager` unconditionally expects all blocks to have encrypted transactions requiring secret share derivation. However, blocks without encrypted transactions cause the decryption pipeline to drop the secret share channel sender without sending, resulting in a panic when `SecretShareManager` awaits the future. This causes validator node crashes and consensus liveness failure.

## Finding Description

The vulnerability occurs through the interaction of four components in the consensus execution pipeline:

**1. Decryption Pipeline Early Exit Without Notification**

When `decrypt_encrypted_txns` processes a block, it partitions transactions into encrypted and unencrypted types. If no encrypted transactions exist, the function returns early without sending any value through the `derived_self_key_share_tx` channel, causing the oneshot sender to be dropped. [1](#0-0) 

**2. Future Awaiting Dropped Channel Receiver**

The `secret_sharing_derive_self_fut` is constructed to await the receiver end of the oneshot channel. When the sender is dropped without sending, the receiver's `await` returns `Err(RecvError)`, which is then mapped to a `TaskError` through the error handler. [2](#0-1) 

**3. Unchecked Panic in SecretShareManager**

The `process_incoming_block` method uses two chained `.expect()` calls on the future result. The first `.expect()` expects the future to succeed, but when it receives the `TaskError` from the dropped channel, it immediately panics with the message "Decryption share computation is expected to succeed". [3](#0-2) 

**4. Unconditional Block Processing**

All blocks received by `SecretShareManager` are unconditionally processed through `process_incoming_blocks`, which calls `process_incoming_block` for each block without checking whether the blocks contain encrypted transactions. [4](#0-3) 

**Attack Scenario:**

1. Secret sharing is enabled at the epoch level via `SecretShareConfig` (legitimate configuration)
2. `SecretShareManager` is instantiated and started during epoch initialization [5](#0-4) 
3. All consensus blocks are routed to the SecretShareManager through the coordinator [6](#0-5) 
4. A block proposer creates a block containing only regular transactions (no encrypted ones)
5. All validators receive this block through consensus
6. Each validator's execution pipeline processes the block:
   - `decrypt_encrypted_txns` detects no encrypted transactions and returns early
   - The `derived_self_key_share_tx` sender is dropped without sending
   - `secret_sharing_derive_self_fut` awaits the receiver and gets `RecvError`
   - This is converted to `TaskError`
7. SecretShareManager awaits this future in `process_incoming_block`
8. The first `.expect()` fails and the validator node **panics**
9. All validators crash simultaneously, causing **total consensus liveness failure**

This breaks the fundamental liveness guarantee of the consensus protocol: the network must be able to make progress under normal operation. The vulnerability requires no Byzantine behavior - it's triggered by a legitimate block that contains only regular transactions, which is the common case.

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the Aptos bug bounty criteria for "Total Loss of Liveness/Network Availability":

- **Complete Network Halt**: When any validator proposes a block without encrypted transactions (the common case), all validators crash simultaneously when processing that block
- **Consensus Liveness Failure**: The network cannot commit any blocks until all nodes are manually restarted and the issue is fixed
- **No Byzantine Requirement**: This is triggered during normal, honest operation - no malicious actors needed
- **Deterministic Failure**: Every validator will crash with 100% certainty when processing such a block
- **Operational Severity**: Requires immediate manual intervention across all validators to restore network operation

The impact aligns with the Critical severity category: "Network halts due to protocol bug, all validators unable to progress".

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will occur with certainty under these conditions:

1. **Secret sharing is enabled**: This is a legitimate feature configuration that can be enabled at the epoch level through on-chain configuration [7](#0-6) 
2. **Any block without encrypted transactions**: Most blocks in normal operation do not contain encrypted transactions, as transaction encryption is an optional feature

The vulnerability is **deterministic and requires no special privileges**:
- Any validator can propose a block without encrypted transactions during their turn
- No Byzantine collusion is needed
- No complex timing or state manipulation is required
- The crash occurs during normal consensus operation with regular transactions
- All validators will crash identically when processing the same block

This makes it an extremely severe operational risk. Even without malicious intent, the network will crash as soon as secret sharing is enabled and any normal block (without encrypted transactions) is proposed.

## Recommendation

The fix is to send `None` through the `derived_self_key_share_tx` channel before returning early when there are no encrypted transactions. This ensures the receiver doesn't await a dropped sender.

In `consensus/src/pipeline/decryption_pipeline_builder.rs`, modify the early return at lines 49-54:

```rust
if encrypted_txns.is_empty() {
    derived_self_key_share_tx
        .send(None)
        .expect("must send properly");
    return Ok((
        unencrypted_txns,
        max_txns_from_block_to_execute,
        block_gas_limit,
    ));
}
```

Additionally, consider modifying `SecretShareManager::process_incoming_block` to handle the `None` case gracefully instead of using `.expect("Must not be None")`, allowing blocks without encrypted transactions to be processed without generating secret shares.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Configure a test network with secret sharing enabled in the epoch configuration
2. Propose a block containing only regular (non-encrypted) transactions
3. Observe that all validators panic with the message "Decryption share computation is expected to succeed" when processing the block
4. The network is unable to make progress until nodes are restarted and the configuration is fixed

The exact panic location is at [8](#0-7) , triggered by the dropped oneshot channel sender at [9](#0-8) .

## Notes

This vulnerability demonstrates a critical oversight in the interaction between the decryption pipeline and the secret share manager. The channel communication protocol assumes that encrypted transactions are always present when secret sharing is enabled, but this assumption is violated in practice since encrypted transactions are optional. The fix requires ensuring the channel sender always sends a value (even if `None`) before being dropped, maintaining the communication contract between pipeline stages.

### Citations

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L44-54)
```rust
        let (encrypted_txns, unencrypted_txns): (Vec<_>, Vec<_>) = input_txns
            .into_iter()
            .partition(|txn| txn.is_encrypted_txn());

        // TODO: figure out handling of
        if encrypted_txns.is_empty() {
            return Ok((
                unencrypted_txns,
                max_txns_from_block_to_execute,
                block_gas_limit,
            ));
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L447-455)
```rust
        let (derived_self_key_share_tx, derived_self_key_share_rx) = oneshot::channel();
        let secret_sharing_derive_self_fut = spawn_shared_fut(
            async move {
                derived_self_key_share_rx
                    .await
                    .map_err(|_| TaskError::from(anyhow!("commit proof tx cancelled")))
            },
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L118-122)
```rust
        for block in blocks.ordered_blocks.iter() {
            let handle = self.process_incoming_block(block).await;
            share_requester_handles.push(handle);
            pending_secret_key_rounds.insert(block.round());
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-138)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
```

**File:** consensus/src/pipeline/execution_client.rs (L335-336)
```rust
                        let _ = rand_manager_input_tx.send(ordered_blocks.clone()).await;
                        let _ = secret_share_manager_input_tx.send(ordered_blocks.clone()).await;
```

**File:** consensus/src/pipeline/execution_client.rs (L399-436)
```rust
        ) = match (rand_config, secret_sharing_config) {
            (Some(rand_config), Some(secret_sharing_config)) => {
                let (rand_manager_input_tx, rand_ready_block_rx, reset_tx_to_rand_manager) = self
                    .make_rand_manager(
                        &epoch_state,
                        fast_rand_config,
                        rand_msg_rx,
                        highest_committed_round,
                        &network_sender,
                        rand_config,
                        consensus_sk,
                    );

                let (
                    secret_share_manager_input_tx,
                    secret_ready_block_rx,
                    reset_tx_to_secret_share_manager,
                ) = self.make_secret_sharing_manager(
                    &epoch_state,
                    secret_sharing_config,
                    secret_sharing_msg_rx,
                    highest_committed_round,
                    &network_sender,
                );

                let (ordered_block_tx, ready_block_rx) = Self::make_coordinator(
                    rand_manager_input_tx,
                    rand_ready_block_rx,
                    secret_share_manager_input_tx,
                    secret_ready_block_rx,
                );

                (
                    ordered_block_tx,
                    ready_block_rx,
                    Some(reset_tx_to_rand_manager),
                    Some(reset_tx_to_secret_share_manager),
                )
```

**File:** consensus/src/pipeline/execution_client.rs (L457-465)
```rust
            (None, Some(secret_sharing_config)) => {
                let (ordered_block_tx, secret_ready_block_rx, reset_tx_to_secret_share_manager) =
                    self.make_secret_sharing_manager(
                        &epoch_state,
                        secret_sharing_config,
                        secret_sharing_msg_rx,
                        highest_committed_round,
                        &network_sender,
                    );
```
