# Audit Report

## Title
Memory Ordering Vulnerability in skip_module_reads_validation Flag Enables Consensus Split

## Summary
The `skip_module_reads_validation` flag in BlockSTM V1 parallel executor uses `Ordering::Relaxed` for both reads and writes, creating a memory ordering race condition that can cause different validators to produce different execution results for identical blocks, leading to consensus splits.

## Finding Description

The vulnerability exists in the memory ordering semantics of the `skip_module_reads_validation` atomic flag used during parallel transaction execution in BlockSTM V1.

The flag is initialized to `true` as an optimization: [1](#0-0) 

When a transaction publishes a module, the flag is set to `false` using `Ordering::Relaxed`: [2](#0-1) 

During validation, the flag is read with `Ordering::Relaxed`: [3](#0-2) 

This flag controls whether module validation is skipped: [4](#0-3) 

**The Critical Issue:**

`Ordering::Relaxed` provides no synchronization guarantees between threads. Although `decrease_validation_idx` is called after setting the flag and uses `Ordering::SeqCst`: [5](#0-4) 

The `SeqCst` operation on `validation_idx` (a different atomic variable) does not establish a happens-before relationship with the `skip_module_reads_validation` flag. According to Rust/C++ memory model semantics, SeqCst operations on one atomic variable do not synchronize Relaxed operations on a different atomic variable.

**Attack Scenario:**

1. Transaction 5 executes speculatively, reads Module M from global cache
2. Transaction 3 publishes Module M version 2:
   - Marks module as overridden: [6](#0-5) 
   - Sets `skip_module_reads_validation = false` (Relaxed)
   - Calls `decrease_validation_idx(4)` triggering re-validation
3. Validation thread picks up Transaction 5 validation task
4. **Race occurs**: Thread may observe stale value `true` due to lack of synchronization
5. If `true`: Skips module validation, commits with stale read
6. If `false`: Validates, detects override via: [7](#0-6) 
   which checks: [8](#0-7) 

**Why this breaks consensus:**

Different validators observe the race differently due to thread scheduling and hardware memory model variations (especially ARM vs x86), producing non-deterministic execution outcomes and different state roots for identical blocks.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability directly violates the fundamental consensus invariant that all validators must produce identical state roots for identical blocks. Per Aptos bug bounty Critical severity criteria:

1. **Consensus/Safety Violations**: Different validators commit blocks with different execution results, breaking BFT safety guarantees with <1/3 Byzantine nodes
2. **Non-recoverable Network Partition**: Validators diverge into incompatible states requiring manual intervention or hard fork
3. **Chain Split**: Network fragments as validators disagree on valid blocks

The vulnerability affects BlockSTM V1, which is the default configuration: [9](#0-8) 

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability triggers during normal network operation:

1. **Common Trigger**: Module publishing occurs regularly (package upgrades, deployments)
2. **Race Window**: Exists on every block with module publishes and dependent transactions
3. **Hardware Dependency**: More likely on ARM/weak memory model hardware than x86
4. **No Attacker Control**: Race manifests naturally due to thread scheduling variations

The commit flow where the race occurs: [10](#0-9) 

Despite the narrow race window, the catastrophic impact (consensus split requiring hard fork) combined with regular module publishing operations makes this a serious production vulnerability.

## Recommendation

Change the memory ordering for `skip_module_reads_validation` from `Relaxed` to use proper synchronization:

**Option 1**: Use `Ordering::Release` for store and `Ordering::Acquire` for load to establish happens-before relationship.

**Option 2**: Use `Ordering::SeqCst` for both operations to ensure total ordering.

**Option 3**: Remove the optimization entirely and always perform module validation in BlockSTM V1, relying on BlockSTM V2's different validation approach for performance.

The comment at line 85-86 incorrectly assumes the subsequent SeqCst provides sufficient synchronization, but this is not guaranteed by the memory model.

## Proof of Concept

A reliable PoC for this vulnerability would require creating specific thread scheduling conditions that expose the race. This is inherently non-deterministic and hardware-dependent. However, the technical analysis demonstrates the vulnerability exists in the code:

1. Memory ordering properties of Relaxed vs SeqCst are well-defined in Rust/C++ memory models
2. SeqCst on one atomic does not synchronize Relaxed operations on different atomics
3. The validation path definitively skips module checks when flag is `true`
4. Module publishing definitively sets flag with Relaxed ordering

The vulnerability can be validated through:
- Stress testing with high module publishing rate on ARM hardware
- Memory model analysis tools (e.g., Loom for Rust)
- Adding instrumentation to detect when validation sees stale flag values

## Notes

This is a subtle memory ordering bug that demonstrates the importance of correct atomic ordering semantics in concurrent blockchain execution engines. The developer comment suggests awareness of synchronization needs but incorrectly assumes SeqCst on a different variable provides sufficient ordering guarantees.

The vulnerability is more likely to manifest on hardware with weaker memory models (ARM, POWER) than on x86, which has a stronger TSO memory model that provides implicit ordering guarantees. This could lead to consensus divergence between validators running on different hardware architectures.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L810-815)
```rust
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1043-1057)
```rust
        // Publish modules before we decrease validation index (in V1) so that validations observe
        // the new module writes as well.
        if last_input_output.publish_module_write_set(
            txn_idx,
            global_module_cache,
            versioned_cache,
            runtime_environment,
            &scheduler,
        )? {
            side_effect_at_commit = true;
        }

        if side_effect_at_commit {
            scheduler.wake_dependencies_and_decrease_validation_idx(txn_idx)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1372-1372)
```rust
                        skip_module_reads_validation.load(Ordering::Relaxed),
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1895)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L85-87)
```rust
                // Relaxed suffices as syncronization (reducing validation index) occurs after
                // setting the module read validation flag.
                skip_module_reads_validation.store(false, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/scheduler.rs (L821-821)
```rust
                .fetch_update(Ordering::SeqCst, Ordering::Acquire, |val_idx| {
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L56-58)
```rust
    fn mark_overridden(&self) {
        self.overridden.store(true, Ordering::Release)
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L61-63)
```rust
    fn is_not_overridden(&self) -> bool {
        !self.overridden.load(Ordering::Acquire)
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1061-1061)
```rust
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```

**File:** types/src/block_executor/config.rs (L73-73)
```rust
            blockstm_v2: false,
```
