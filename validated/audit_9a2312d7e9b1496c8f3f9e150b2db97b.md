# Audit Report

## Title
Pre-Limit-Check CFG Construction Enables Validator Resource Exhaustion via Script Transactions

## Summary
The Move bytecode verifier constructs the complete Control Flow Graph (CFG) before checking the `TOO_MANY_BASIC_BLOCKS` limit. For script transactions, the Aptos production configuration sets no limit (`max_basic_blocks_in_script: None`), allowing attackers to force validators to perform expensive O(V+E) graph operations on bytecode with up to 65,535 basic blocks before any validation occurs.

## Finding Description

The vulnerability exists in a critical ordering issue within the Move bytecode verification pipeline.

**Step 1: CFG Construction Happens First**

When verifying a script transaction, the verifier calls `control_flow::verify_script()` which immediately constructs a `FunctionView`: [1](#0-0) 

The `FunctionView::script()` constructor immediately triggers full CFG construction: [2](#0-1) 

This invokes `VMControlFlowGraph::new()` which performs expensive operations including iterating through all instructions to collect block IDs (BTreeSet insertions), creating BasicBlock structures in an IndexMap, performing depth-first search for loop analysis, and building reverse post-order traversal: [3](#0-2) [4](#0-3) 

**Step 2: Limit Check Happens After CFG Construction**

Only AFTER the expensive CFG construction completes does the verifier check the limit: [5](#0-4) 

**Step 3: Production Configuration Has No Limit for Scripts**

The critical issue is that the actual Aptos production configuration explicitly sets no limit for scripts: [6](#0-5) 

This production config is used throughout the Aptos VM: [7](#0-6) 

With `max_basic_blocks_in_script: None`, the limit check at line 95 never executes, allowing unbounded CFG construction.

**Step 4: Metering Does Not Apply to CFG Construction**

The metering system is initialized but not used during CFG construction: [8](#0-7) 

The meter is only entered AFTER CFG construction completes (line 108), meaning the expensive graph operations occur without any resource tracking.

**Attack Vector**

An attacker can submit a script transaction with maximum bytecode size (64KB = 65,535 bytes) structured with Branch instructions to create up to 65,535 basic blocks. Every validator must process this expensive CFG construction before any limit check occurs, causing resource exhaustion.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria - **Validator Node Slowdowns**.

This vulnerability enables attackers to force every validator to perform O(V+E) graph algorithms on graphs with V=65,535 vertices before any validation occurs. The depth-first search for loop analysis iterates through all blocks and their predecessors, with potentially O(VÂ²) complexity in pathological cases.

Multiple such transactions in a single block compound the effect, causing:
- **Increased block processing time**: Validators spend excessive CPU cycles on malicious verification
- **Delayed transaction finality**: Legitimate transactions experience longer confirmation times
- **Mempool congestion**: Validators struggle to process transactions, leading to backlog
- **Degraded network liveness**: Network responsiveness suffers during attacks

While this does not cause complete network halt (transactions eventually complete after expensive processing), it enables targeted DoS attacks against validator availability during critical periods such as governance votes or high-value transactions.

## Likelihood Explanation

**High likelihood**. The attack requires only:

1. **Trivial to craft**: Bytecode with many Branch instructions can be generated with standard bytecode manipulation tools
2. **Standard transaction type**: Script transactions remain fully supported and valid (NOT deprecated)
3. **No special privileges**: Any user can submit script transactions through normal APIs
4. **Deterministic effect**: Every validator MUST process the expensive CFG construction
5. **No economic barrier**: Transaction size limit (64KB) naturally allows the attack
6. **Continuous exploitation**: Attackers can submit multiple such transactions

The vulnerability is deterministic and affects the production configuration used by all Aptos validators.

## Recommendation

**Immediate Fix**: Set a reasonable limit for `max_basic_blocks_in_script` in the production configuration:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
max_basic_blocks_in_script: Some(1024),  // Changed from None
```

**Long-term Fix**: Refactor the verification pipeline to check limits BEFORE constructing the CFG:

1. Add a fast pre-check that counts potential basic blocks by scanning for branch instructions
2. Validate against the limit before invoking `FunctionView::script()`
3. Apply metering to CFG construction itself, not just subsequent verification steps

## Proof of Concept

A proof of concept would involve:

1. Generate Move bytecode with maximum Branch instructions to create ~65,535 basic blocks
2. Package as a script transaction payload
3. Submit to Aptos network
4. Measure validator CPU time during verification

The vulnerability is demonstrable through code inspection alone - the production configuration and execution order are deterministic and verifiable in the codebase.

## Notes

- This vulnerability affects the actual production configuration (`aptos_prod_verifier_config`), not the generic Move verifier production config
- Script transactions are still valid and fully supported in Aptos (only ModuleBundle payload is deprecated)
- The transaction size limit of 64KB naturally bounds the worst case to ~65,535 basic blocks
- The metering system (`max_per_fun_meter_units`) only applies to verification steps AFTER CFG construction
- This is a protocol-level resource exhaustion issue, not a network-level DoS, making it in-scope per bug bounty rules

### Citations

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L66-67)
```rust
        verify_fallthrough(None, &script.code)?;
        let function_view = FunctionView::script(script);
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L454-467)
```rust
    pub fn script(script: &'a CompiledScript) -> Self {
        let code = &script.code;
        let parameters = script.signature_at(script.parameters);
        let locals = script.signature_at(code.locals);
        let type_parameters = &script.type_parameters;
        Self {
            index: None,
            code,
            parameters,
            return_: EMPTY_SIGNATURE,
            locals,
            type_parameters,
            cfg: VMControlFlowGraph::new(&code.code),
        }
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L84-112)
```rust
    pub fn new(code: &[Bytecode]) -> Self {
        let code_len = code.len() as CodeOffset;
        // First go through and collect block ids, i.e., offsets that begin basic blocks.
        // Need to do this first in order to handle backwards edges.
        let mut block_ids = Set::new();
        block_ids.insert(ENTRY_BLOCK_ID);
        for pc in 0..code.len() {
            VMControlFlowGraph::record_block_ids(pc as CodeOffset, code, &mut block_ids);
        }

        // Create basic blocks
        let mut blocks = Map::new();
        let mut entry = 0;
        let mut exit_to_entry = Map::new();
        for pc in 0..code.len() {
            let co_pc = pc as CodeOffset;

            // Create a basic block
            if Self::is_end_of_block(co_pc, code, &block_ids) {
                let exit = co_pc;
                exit_to_entry.insert(exit, entry);
                let successors = Bytecode::get_successors(co_pc, code);
                let bb = BasicBlock { exit, successors };
                blocks.insert(entry, bb);
                entry = co_pc + 1;
            }
        }
        let blocks = blocks;
        assert_eq!(entry, code_len);
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L114-202)
```rust
        // # Loop analysis
        //
        // This section identifies loops in the control-flow graph, picks a back edge and loop head
        // (the basic block the back edge returns to), and decides the order that blocks are
        // traversed during abstract interpretation (reverse post-order).
        //
        // The implementation is based on the algorithm for finding widening points in Section 4.1,
        // "Depth-first numbering" of Bourdoncle [1993], "Efficient chaotic iteration strategies
        // with widenings."
        //
        // NB. The comments below refer to a block's sub-graph -- the reflexive transitive closure
        // of its successor edges, modulo cycles.

        #[derive(Copy, Clone)]
        enum Exploration {
            InProgress,
            Done,
        }

        let mut exploration: Map<BlockId, Exploration> = Map::new();
        let mut stack = vec![ENTRY_BLOCK_ID];

        // For every loop in the CFG that is reachable from the entry block, there is an entry in
        // `loop_heads` mapping to all the back edges pointing to it, and vice versa.
        //
        // Entry in `loop_heads` implies loop in the CFG is justified by the comments in the loop
        // below.  Loop in the CFG implies entry in `loop_heads` is justified by considering the
        // point at which the first node in that loop, `F` is added to the `exploration` map:
        //
        // - By definition `F` is part of a loop, meaning there is a block `L` such that:
        //
        //     F - ... -> L -> F
        //
        // - `F` will not transition to `Done` until all the nodes reachable from it (including `L`)
        //   have been visited.
        // - Because `F` is the first node seen in the loop, all the other nodes in the loop
        //   (including `L`) will be visited while `F` is `InProgress`.
        // - Therefore, we will process the `L -> F` edge while `F` is `InProgress`.
        // - Therefore, we will record a back edge to it.
        let mut loop_heads: Map<BlockId, Set<BlockId>> = Map::new();

        // Blocks appear in `post_order` after all the blocks in their (non-reflexive) sub-graph.
        let mut post_order = Vec::with_capacity(blocks.len());

        while let Some(block) = stack.pop() {
            match exploration.entry(block) {
                Entry::Vacant(entry) => {
                    // Record the fact that exploration of this block and its sub-graph has started.
                    entry.insert(Exploration::InProgress);

                    // Push the block back on the stack to finish processing it, and mark it as done
                    // once its sub-graph has been traversed.
                    stack.push(block);

                    for succ in &blocks[&block].successors {
                        match exploration.get(succ) {
                            // This successor has never been visited before, add it to the stack to
                            // be explored before `block` gets marked `Done`.
                            None => stack.push(*succ),

                            // This block's sub-graph was being explored, meaning it is a (reflexive
                            // transitive) predecessor of `block` as well as being a successor,
                            // implying a loop has been detected -- greedily choose the successor
                            // block as the loop head.
                            Some(Exploration::InProgress) => {
                                loop_heads.entry(*succ).or_default().insert(block);
                            },

                            // Cross-edge detected, this block and its entire sub-graph (modulo
                            // cycles) has already been explored via a different path, and is
                            // already present in `post_order`.
                            Some(Exploration::Done) => { /* skip */ },
                        };
                    }
                },

                Entry::Occupied(mut entry) => match entry.get() {
                    // Already traversed the sub-graph reachable from this block, so skip it.
                    Exploration::Done => continue,

                    // Finish up the traversal by adding this block to the post-order traversal
                    // after its sub-graph (modulo cycles).
                    Exploration::InProgress => {
                        post_order.push(block);
                        entry.insert(Exploration::Done);
                    },
                },
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L85-99)
```rust
    fn verify_script_impl(
        verifier_config: &VerifierConfig,
        script: &'a CompiledScript,
    ) -> PartialVMResult<()> {
        let mut meter = BoundMeter::new(verifier_config);
        // create `FunctionView` and `BinaryIndexedView`
        let function_view = control_flow::verify_script(verifier_config, script)?;
        let resolver = BinaryIndexedView::Script(script);
        let name_def_map = HashMap::new();

        if let Some(limit) = verifier_config.max_basic_blocks_in_script {
            if function_view.cfg().blocks().len() > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS));
            }
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L144-155)
```rust
/// Returns [VerifierConfig] used by the Aptos blockchain in production.
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L174-174)
```rust
        max_basic_blocks_in_script: None,
```
