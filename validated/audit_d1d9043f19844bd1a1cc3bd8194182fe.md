# Audit Report

## Title
Silent Transaction Deduper Type Divergence Leading to Consensus Failure

## Summary
During epoch initialization, validators retrieve `OnChainExecutionConfig` from on-chain state to determine which transaction deduper implementation to use. When deserialization fails due to unknown enum variants (e.g., during rolling software upgrades), validators silently fall back to a default configuration without validation that all validators successfully deserialized the same configuration. This causes different validators to use different deduper types, executing different transaction sets and computing different state roots during the commit vote phase, resulting in consensus failure.

## Finding Description

The vulnerability occurs across multiple components in the consensus pipeline:

**1. Silent Deserialization Failure Handling:**

During epoch initialization, the on-chain execution config is retrieved and deserialization errors are caught but only logged as warnings: [1](#0-0) [2](#0-1) [3](#0-2) 

**2. Default Fallback Mechanism:**

When deserialization fails, the code falls back to `OnChainExecutionConfig::Missing`: [4](#0-3) 

This `Missing` variant maps to a specific deduper type: [5](#0-4) 

**3. Enum Variant Deserialization:**

The `TransactionDeduperType` enum uses serde with `rename_all = "snake_case"`, which means unknown variants cause deserialization failures: [6](#0-5) 

**4. Deduper Creation:**

The deduper is created based on the potentially divergent configuration: [7](#0-6) [8](#0-7) 

**5. Different Transaction Set Execution:**

During block preparation, different deduper implementations produce different transaction sets: [9](#0-8) 

The `NoOpDeduper` returns all transactions: [10](#0-9) 

While `TxnHashAndAuthenticatorDeduper` filters duplicates: [11](#0-10) 

**6. Consensus Failure in Commit Vote Phase:**

Although Aptos uses decoupled execution where initial votes use dummy state roots: [12](#0-11) [13](#0-12) 

The critical failure occurs during the commit vote phase, where validators sign commit votes with **actual execution state roots**: [14](#0-13) 

The `BlockInfo` structure contains the `executed_state_id` (state root): [15](#0-14) 

**Attack Scenario:**
1. Network runs with a specific `TransactionDeduperType` (e.g., `NoDedup`)
2. New software version adds a new enum variant (e.g., `TxnHashAndAuthenticatorV2`)
3. Governance proposal updates on-chain config to use the new variant
4. During rolling upgrade window:
   - Validators with updated software: Successfully deserialize → use new/configured variant
   - Validators with old software: Deserialization fails → fallback to `Missing` → use `TxnHashAndAuthenticatorV1`
5. Different validators execute different transaction sets (different filtering)
6. Each validator computes a different state root
7. Commit votes contain different state roots and cannot be aggregated into a Commit QC
8. **Consensus failure** - network cannot commit blocks

This breaks the fundamental consensus invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

This is a **Critical Severity** vulnerability aligning with Aptos bug bounty category "Consensus/Safety Violations":

- **Consensus Failure**: Different validators compute different state roots for the same block, preventing commit QC formation
- **Non-recoverable Network Partition**: Once validators diverge during commit voting, they cannot reach consensus on subsequent blocks without manual intervention
- **Requires Hardfork/Coordination**: Recovery requires coordinating all validators to roll back to a common state, upgrade software synchronously, and restart consensus
- **Network-Wide Impact**: Affects all validators during software upgrade windows, causing complete loss of liveness

The vulnerability is particularly severe because:
1. It affects the **commit phase** of consensus, not just block ordering
2. There is **no validation** that all validators successfully deserialized the same configuration
3. The fallback is **silent** (only warning logs) with no consensus-level detection
4. Recovery requires **out-of-band coordination** among all validators

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability will manifest during:

1. **Planned Network Upgrades**: When new `TransactionDeduperType` variants are introduced in software updates:
   - Rolling upgrades create windows where validators run different software versions
   - If governance activates the new config before all validators upgrade, divergence occurs
   - Upgrade windows can last hours to days

2. **Governance Configuration Updates**: When on-chain config is updated to use newer features:
   - Governance proposals can be executed before all validators are ready
   - Even a brief window (5-10 minutes) creates consensus failure risk

3. **Protocol Evolution**: The enum-based configuration system encourages adding new variants for new features, making this a recurring risk vector

The vulnerability is **not externally exploitable** (requires governance process), but represents a **protocol design flaw** that creates high-probability consensus failure during normal operational procedures. The lack of configuration validation at the consensus layer makes this inevitable during upgrades that introduce new enum variants.

## Recommendation

Implement a configuration validation mechanism to ensure all validators use identical deduper configurations:

```rust
// In consensus/src/epoch_manager.rs
pub async fn start_epoch(...) {
    // ... existing code ...
    
    let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
    
    // CRITICAL: Do not silently fall back on deserialization failure
    let execution_config = match onchain_execution_config {
        Ok(config) => config,
        Err(e) => {
            error!("Failed to deserialize OnChainExecutionConfig: {}", e);
            // Halt consensus rather than diverge silently
            panic!("Cannot start epoch with invalid execution config - validators would diverge");
        }
    };
    
    // Add config hash to epoch state for validation
    let config_hash = hash_execution_config(&execution_config);
    verify_config_consensus(epoch_state, config_hash).await?;
    
    // ... rest of epoch initialization ...
}
```

Alternative solutions:
1. **Fail-fast on deserialization**: Halt validator startup if config cannot be deserialized, forcing operators to upgrade
2. **Configuration commitment**: Include hash of parsed configuration in order votes, detecting divergence early
3. **Backward compatibility**: Use extensible enums with `#[serde(other)]` to handle unknown variants gracefully
4. **Upgrade coordination**: Require all validators to acknowledge readiness before governance can activate new config variants

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
#[test]
fn test_deduper_divergence_causes_consensus_failure() {
    // 1. Simulate two validators with different software versions
    let validator_old = create_validator_with_old_software();
    let validator_new = create_validator_with_new_software();
    
    // 2. Governance updates config to new enum variant "TxnHashAndAuthenticatorV2"
    let new_config = OnChainExecutionConfig::V7(ExecutionConfigV7 {
        transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV2, // New variant
        // ... other fields ...
    });
    
    // 3. Old validator fails to deserialize, falls back to Missing
    let config_bytes = bcs::to_bytes(&new_config).unwrap();
    
    // Old validator deserialization fails for unknown variant
    let old_parsed = bcs::from_bytes::<OnChainExecutionConfig>(&config_bytes);
    assert!(old_parsed.is_err()); // Deserialization fails
    
    let old_config = OnChainExecutionConfig::default_if_missing(); // Falls back to Missing
    assert_eq!(old_config, OnChainExecutionConfig::Missing);
    assert_eq!(old_config.transaction_deduper_type(), TransactionDeduperType::TxnHashAndAuthenticatorV1);
    
    // New validator deserializes successfully
    let new_config_parsed = new_config;
    assert_eq!(new_config_parsed.transaction_deduper_type(), TransactionDeduperType::TxnHashAndAuthenticatorV2);
    
    // 4. Create deduplers - different types!
    let old_deduper = create_transaction_deduper(old_config.transaction_deduper_type());
    let new_deduper = create_transaction_deduper(new_config_parsed.transaction_deduper_type());
    
    // 5. Execute same block with duplicate transactions
    let block = create_block_with_duplicate_transactions();
    let txns = block.transactions();
    
    let old_txns = old_deduper.dedup(txns.clone());
    let new_txns = new_deduper.dedup(txns.clone());
    
    // Different transaction sets!
    assert_ne!(old_txns.len(), new_txns.len());
    
    // 6. Execute transactions and compute state roots
    let old_state_root = execute_and_compute_state_root(&validator_old, &old_txns);
    let new_state_root = execute_and_compute_state_root(&validator_new, &new_txns);
    
    // Different state roots!
    assert_ne!(old_state_root, new_state_root);
    
    // 7. Create commit votes with different state roots
    let old_commit_vote = create_commit_vote(&validator_old, block.id(), old_state_root);
    let new_commit_vote = create_commit_vote(&validator_new, block.id(), new_state_root);
    
    // Commit votes have different ledger infos!
    assert_ne!(old_commit_vote.ledger_info(), new_commit_vote.ledger_info());
    
    // 8. Cannot form Commit QC - consensus failure!
    let result = try_aggregate_commit_votes(vec![old_commit_vote, new_commit_vote]);
    assert!(result.is_err()); // Aggregation fails due to mismatched ledger infos
    
    println!("CONSENSUS FAILURE: Validators cannot form Commit QC due to divergent deduper configurations");
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: The deserialization failure only produces a warning log, with no consensus-level alert
2. **Decoupled Execution Masking**: The initial order voting phase succeeds (dummy state roots), masking the problem until the commit phase
3. **Operational Context**: Occurs during legitimate upgrade procedures, not malicious attacks
4. **Recovery Complexity**: Requires out-of-band coordination among all validators to resolve
5. **Design Pattern Risk**: The enum-based configuration pattern encourages adding new variants, creating recurring vulnerability windows

The root cause is the lack of a mechanism to validate that all validators successfully deserialized identical configurations before participating in consensus. The silent fallback to default values breaks the consensus invariant that all validators execute identically.

### Citations

**File:** consensus/src/epoch_manager.rs (L1179-1179)
```rust
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
```

**File:** consensus/src/epoch_manager.rs (L1191-1193)
```rust
        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1202-1203)
```rust
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** types/src/on_chain_config/execution_config.rs (L108-120)
```rust
    pub fn transaction_deduper_type(&self) -> TransactionDeduperType {
        match &self {
            // Note, this behavior was enabled before OnChainExecutionConfig was registered.
            OnChainExecutionConfig::Missing => TransactionDeduperType::TxnHashAndAuthenticatorV1,
            OnChainExecutionConfig::V1(_config) => TransactionDeduperType::NoDedup,
            OnChainExecutionConfig::V2(_config) => TransactionDeduperType::NoDedup,
            OnChainExecutionConfig::V3(config) => config.transaction_deduper_type.clone(),
            OnChainExecutionConfig::V4(config) => config.transaction_deduper_type.clone(),
            OnChainExecutionConfig::V5(config) => config.transaction_deduper_type.clone(),
            OnChainExecutionConfig::V6(config) => config.transaction_deduper_type.clone(),
            OnChainExecutionConfig::V7(config) => config.transaction_deduper_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L137-139)
```rust
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L265-270)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum TransactionDeduperType {
    NoDedup,
    TxnHashAndAuthenticatorV1,
}
```

**File:** consensus/src/pipeline/execution_client.rs (L564-565)
```rust
        let transaction_deduper =
            create_transaction_deduper(onchain_execution_config.transaction_deduper_type());
```

**File:** consensus/src/transaction_deduper.rs (L17-21)
```rust
impl TransactionDeduper for NoOpDeduper {
    fn dedup(&self, txns: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
        txns
    }
}
```

**File:** consensus/src/transaction_deduper.rs (L23-33)
```rust
pub fn create_transaction_deduper(
    deduper_type: TransactionDeduperType,
) -> Arc<dyn TransactionDeduper> {
    match deduper_type {
        TransactionDeduperType::NoDedup => Arc::new(NoOpDeduper {}),
        TransactionDeduperType::TxnHashAndAuthenticatorV1 => {
            info!("Using simple hash set transaction deduper");
            Arc::new(TxnHashAndAuthenticatorDeduper::new())
        },
    }
}
```

**File:** consensus/src/block_preparer.rs (L99-99)
```rust
            let deduped_txns = txn_deduper.dedup(filtered_txns);
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L38-95)
```rust
impl TransactionDeduper for TxnHashAndAuthenticatorDeduper {
    fn dedup(&self, transactions: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
        let _timer = TXN_DEDUP_SECONDS.start_timer();
        let mut seen = HashMap::new();
        let mut is_possible_duplicate = false;
        let mut possible_duplicates = vec![false; transactions.len()];
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
        }
        if !is_possible_duplicate {
            TXN_DEDUP_FILTERED.observe(0 as f64);
            return transactions;
        }

        let num_txns = transactions.len();

        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

        // TODO: Possibly parallelize. See struct comment.
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
                        num_duplicates += 1;
                        None
                    }
                },
            })
            .collect();

        TXN_DEDUP_FILTERED.observe(num_duplicates as f64);
        filtered
    }
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L239-241)
```rust
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L88-101)
```rust
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
        } else {
            let proposed_block = self.block();
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
            Ok(self.vote_data_with_extension_proof(&new_tree))
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1009-1027)
```rust
        let mut block_info = block.gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        );
        if let Some(timestamp) = epoch_end_timestamp {
            info!(
                "[Pipeline] update block timestamp from {} to epoch end timestamp {}",
                block_info.timestamp_usecs(),
                timestamp
            );
            block_info.change_timestamp(timestamp);
        }
        let ledger_info = LedgerInfo::new(block_info, consensus_data_hash);
        info!("[Pipeline] Signed ledger info {ledger_info}");
        let signature = signer.sign(&ledger_info).expect("Signing should succeed");
        let commit_vote = CommitVote::new_with_signature(signer.author(), ledger_info, signature);
        network_sender
            .broadcast_commit_vote(commit_vote.clone())
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```
