# Audit Report

## Title
Incomplete Transaction Index Cleanup During Manual Database Truncation Leads to Stale Index Entries and Transaction Mismatches

## Summary
The manual database truncation command contains a hardcoded 2,000,000 transaction limit when deleting transaction index entries. For truncations exceeding this depth, stale entries in `OrderedTransactionByAccountSchema` persist, causing API queries by account address and sequence number to return incorrect transactions when the blockchain reaches those version numbers again with different content.

## Finding Description

The vulnerability exists in the transaction index cleanup logic during manual database truncation operations. When operators perform disaster recovery truncation, the system must delete all transaction index entries for rolled-back transactions to maintain storage consistency.

The `delete_transaction_index_data` function loads transactions with a hardcoded limit of `MAX_COMMIT_PROGRESS_DIFFERENCE * 2` (2,000,000 transactions): [1](#0-0) 

The constant is defined as 1,000,000: [2](#0-1) 

The manual truncate command explicitly bypasses the safety check that would normally limit truncation depth: [3](#0-2) 

When `crash_if_difference_is_too_large=false`, the system skips the assertion that would prevent deep truncations: [4](#0-3) 

**Exploitation Scenario:**

1. **Initial State**: Blockchain at version 5,000,000. Account X has a transaction with sequence number 10 at version 3,500,000, creating index entry `OrderedTransactionByAccountSchema[(X, 10)] = 3,500,000`.

2. **Truncation**: Operator truncates to version 100. Only versions in range [101, 2,000,101) are processed for index cleanup. The index entry at version 3,500,000 is NOT deleted.

3. **Blockchain Resumes**: Chain progresses from version 101 and eventually reaches version 3,500,000 again with Account Y's transaction.

4. **Transaction Mismatch**: When querying for account X's transaction with sequence number 10, the API returns the stale version 3,500,000 from the index. The query flow retrieves the version from the index without validation: [5](#0-4) 

Then retrieves the transaction at that version: [6](#0-5) 

The `get_transaction_with_proof` function simply retrieves the transaction at the specified version without verifying it matches the requested account and sequence number: [7](#0-6) 

Account Y's transaction is returned to the caller as if it belongs to Account X with sequence number 10.

## Impact Explanation

**Severity: MEDIUM**

This vulnerability qualifies as **MEDIUM severity** under the Aptos bug bounty program's category of "Limited Protocol Violations - State inconsistencies requiring manual intervention."

Impact:

1. **Data Integrity Violation**: APIs return incorrect transactions when queried by account and sequence number, violating storage layer data integrity guarantees.

2. **State Inconsistency**: The storage layer provides incorrect data to higher-level components (REST APIs, wallets, block explorers), breaking the assumption that index queries return correct results.

3. **Manual Intervention Required**: Stale index entries persist until manually cleaned through index rebuilding or database restoration.

**Important Clarifications:**
- This does NOT affect consensus—validators execute transactions deterministically and don't rely on this index for consensus operations.
- This does NOT cause fund loss—the actual transaction data remains correct; only the index mapping is corrupted.
- This does NOT cause permanent liveness issues—the blockchain continues operating normally.
- The API is disabled for sharded deployments, limiting exposure.

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

The vulnerability requires:
1. Operator performing manual truncation (legitimate but infrequent disaster recovery operation)
2. Truncation depth exceeding 2,000,000 versions (rare but possible for major disasters)
3. Blockchain naturally reaching the same version numbers after recovery (inevitable after disaster recovery)

While manual truncations are legitimate disaster recovery procedures, they are relatively infrequent. However, the 2,000,000 version limit becomes increasingly problematic as the blockchain ages and accumulates more versions, making deep truncations more likely during major disaster recovery scenarios.

## Recommendation

Remove the hardcoded limit and process all transactions from the start_version to the end of the database:

```rust
// In delete_transaction_index_data function
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    // Get the latest version in the database
    let mut iter = ledger_db.transaction_db_raw().iter::<TransactionSchema>()?;
    iter.seek_to_last();
    
    if let Some((latest_version, _)) = iter.next().transpose()? {
        if latest_version >= start_version {
            // Process in batches to avoid memory issues
            const BATCH_SIZE: usize = 100_000;
            let mut current_version = start_version;
            
            while current_version <= latest_version {
                let batch_limit = std::cmp::min(
                    BATCH_SIZE,
                    (latest_version - current_version + 1) as usize
                );
                
                let transactions = ledger_db
                    .transaction_db()
                    .get_transaction_iter(current_version, batch_limit)?
                    .collect::<Result<Vec<_>>>()?;
                
                if !transactions.is_empty() {
                    ledger_db
                        .transaction_db()
                        .prune_transaction_by_hash_indices(
                            transactions.iter().map(|txn| txn.hash()),
                            batch
                        )?;
                    
                    let txns_with_versions = (current_version..current_version + transactions.len() as u64)
                        .zip(transactions)
                        .collect::<Vec<_>>();
                    
                    transaction_store.prune_transaction_by_account(&txns_with_versions, batch)?;
                    transaction_store.prune_transaction_summaries_by_account(&txns_with_versions, batch)?;
                }
                
                current_version += batch_limit as u64;
            }
        }
    }
    Ok(())
}
```

Additionally, add validation in the query path to verify returned transactions match requested account/sequence number, providing defense in depth.

## Proof of Concept

A complete PoC would require:
1. Setting up an AptosDB instance with >2M transactions
2. Creating index entries for account transactions beyond version 2,000,100
3. Running manual truncation to version 100
4. Committing new transactions to reach the original version numbers
5. Querying by account/sequence number to demonstrate the mismatch

The vulnerability is evident from code inspection as demonstrated by the citations above, showing the hardcoded limit and lack of validation in the query path.

## Notes

- The affected API (`get_account_ordered_transaction`) is explicitly disabled for sharded database deployments, reducing the scope of impact.
- This is a storage layer consistency bug in operational tooling, not an exploitable attack vector requiring malicious actors.
- The issue becomes more likely as blockchains age and accumulate more versions, making deep disaster recovery truncations more plausible.
- A proper fix should process all transactions beyond the truncation point, regardless of count, using batching to manage memory consumption.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L369-372)
```rust
    let transactions = ledger_db
        .transaction_db()
        .get_transaction_iter(start_version, MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2)?
        .collect::<Result<Vec<_>>>()?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L444-447)
```rust
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L155-160)
```rust
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1068-1100)
```rust
    pub(super) fn get_transaction_with_proof(
        &self,
        version: Version,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<TransactionWithProof> {
        self.error_if_ledger_pruned("Transaction", version)?;

        let proof = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_version,
                self.ledger_db.transaction_accumulator_db(),
            )?;

        let transaction = self.ledger_db.transaction_db().get_transaction(version)?;

        // If events were requested, also fetch those.
        let events = if fetch_events {
            Some(self.ledger_db.event_db().get_events_by_version(version)?)
        } else {
            None
        };

        Ok(TransactionWithProof {
            version,
            transaction,
            events,
            proof,
        })
    }
```
