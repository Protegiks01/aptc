# Audit Report

## Title
Unbounded RSA Modulus Size in Keyless Authentication Enables Validator CPU Exhaustion

## Summary
The Aptos keyless authentication system lacks RSA modulus size validation in the OpenIdSig verification path, allowing attackers to install federated JWKs with extremely large RSA keys and force validators to perform computationally expensive signature verifications without paying proportional gas costs, causing significant CPU exhaustion.

## Finding Description

The Aptos keyless authentication system supports two signature verification paths: ZeroKnowledgeSig (using ZK proofs) and OpenIdSig (using direct RSA signature verification). While the ZK path enforces a 256-byte (2048-bit) RSA modulus size constraint, the OpenIdSig path has no such validation.

**Missing Validation in JWK Parsing:**

When JWKs are parsed, the `TryFrom` implementation extracts the RSA modulus `n` as a raw string without any size bounds checking. [1](#0-0) 

The only RSA modulus size validation exists in `to_poseidon_scalar()`, which checks for exactly 256 bytes (2048-bit keys). [2](#0-1)  However, this function is exclusively used for ZK proof verification via `cached_jwk_hash()` in `get_public_inputs_hash()`. [3](#0-2) 

**Vulnerable Signature Verification Path:**

For OpenIdSig-based keyless transactions, the signature verification path diverges from the ZK path. The ZeroKnowledgeSig path calls `get_public_inputs_hash()` which invokes `to_poseidon_scalar()` and enforces the size check. [4](#0-3) 

However, the OpenIdSig path bypasses this validation entirely, directly calling `verify_jwt_claims()` and `verify_jwt_signature()` without any modulus size checks. [5](#0-4) 

The `verify_jwt_signature()` method reconstructs the JWT and calls `rsa_jwk.verify_signature_without_exp_check()`. [6](#0-5)  This ultimately uses `jsonwebtoken::decode()` to perform full RSA signature verification with no key size constraints. [7](#0-6) 

**Attack Path:**

1. An attacker creates a federated keyless account with a custom OIDC provider
2. The attacker calls the public entry function `update_federated_jwk_set()` to install JWKs with large RSA moduli (e.g., 8192-bit or 12288-bit keys) at their own address. [8](#0-7) 

3. The `patch_federated_jwks()` function only enforces a 2 KiB BCS-serialized size limit on the entire FederatedJWKs resource, with no per-key size validation. [9](#0-8)  The constant `MAX_FEDERATED_JWKS_SIZE_BYTES` is set to 2048 bytes. [10](#0-9) 

4. The attacker creates federated keyless accounts using these large JWKs and submits transactions with OpenIdSig signatures
5. Every validator must verify these expensive RSA signatures during transaction validation in `validate_signed_transaction()`, which occurs before any gas is charged. [11](#0-10) 

The code explicitly preserves the gas meter balance during validation, as evidenced by the assertion that initial gas equals current gas balance after validation. [12](#0-11) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria: "Validator node slowdowns."

RSA signature verification with oversized keys causes severe performance degradation:
- An 8192-bit RSA verification is approximately 64x slower than 2048-bit
- A 12288-bit RSA verification is approximately 216x slower than 2048-bit
- Verification occurs during transaction validation, before the prologue and gas charging
- The attacker pays no proportional cost for the CPU burden they inflict on validators
- Multiple transactions can be submitted to continuously exhaust validator CPU resources
- All validators in the network are affected simultaneously when processing blocks containing such transactions

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The signature verification cost is unbounded and not reflected in gas consumption.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- Requires no special privileges beyond creating a federated keyless account (any user can do this)
- No compromises of trusted OIDC providers needed - attacker controls their own provider
- Attacker has full control over federated JWK installation via the public `update_federated_jwk_set()` function
- The 2 KiB BCS serialization limit is sufficient for impactful attacks (8192-bit or 12288-bit keys)
- Can be repeated arbitrarily by submitting multiple transactions
- Standard cryptographic libraries easily generate large RSA keys

The only barrier is the 2 KiB serialization limit, but a base64url-encoded 8192-bit modulus (~1365 characters) plus other JWK fields fits well within this constraint, allowing for multiple large keys or a single extremely large key.

## Recommendation

Implement RSA modulus size validation in the OpenIdSig verification path:

1. Add a size check in the `verify_jwt_signature()` or `verify_signature_without_exp_check()` methods to enforce the same 256-byte (2048-bit) limit used in the ZK path
2. Alternatively, add validation in `patch_federated_jwks()` to reject JWKs with moduli exceeding the safe threshold
3. Consider adding gas metering that scales with RSA key size during signature verification

Example fix location: In `types/src/jwks/rsa/mod.rs`, add validation before calling `jsonwebtoken::decode()`:

```rust
pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
    // Validate modulus size
    let modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
    if modulus.len() > Self::RSA_MODULUS_BYTES {
        bail!("RSA modulus size {} exceeds maximum {}", modulus.len(), Self::RSA_MODULUS_BYTES);
    }
    
    let mut validation = Validation::new(Algorithm::RS256);
    validation.validate_exp = false;
    let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
    let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
    Ok(claims)
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability:
// 1. Create account and install large RSA JWK
use aptos_framework::jwks;
use std::string::utf8;

// Generate 8192-bit RSA key (1024 bytes modulus)
// Base64url-encode the modulus (results in ~1365 characters)
let large_modulus = utf8(b"<8192-bit-modulus-base64url-encoded>");

// Install the large JWK
jwks::update_federated_jwk_set(
    &jwk_owner,
    b"https://attacker-oidc.example.com",
    vector[utf8(b"large-key-id")],
    vector[utf8(b"RS256")],
    vector[utf8(b"AQAB")],
    vector[large_modulus]
);

// 2. Create federated keyless account with jwk_addr pointing to attacker's address
// 3. Generate valid JWT signed with the large RSA key from attacker's OIDC provider
// 4. Submit transaction with OpenIdSig signature
// 5. All validators perform expensive RSA verification with 8192-bit key
// 6. CPU exhaustion occurs with no proportional gas cost to attacker
```

The PoC demonstrates that an attacker can install arbitrarily large RSA keys (up to the 2 KiB limit) and force validators to verify signatures with these keys, causing CPU exhaustion without paying proportional gas costs.

### Citations

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-125)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }

        // This is done to match the circuit, which requires the modulus in a verify specific format
        // due to how RSA verification is implemented
        modulus.reverse();

        let mut scalars = modulus
            .chunks(24) // Pack 3 64 bit limbs per scalar, so chunk into 24 bytes per scalar
            .map(|chunk| {
                poseidon_bn254::keyless::pack_bytes_to_one_scalar(chunk)
                    .expect("chunk converts to scalar")
            })
            .collect::<Vec<ark_bn254::Fr>>();
        scalars.push(ark_bn254::Fr::from(Self::RSA_MODULUS_BYTES as i32));
        poseidon_bn254::hash_scalars(scalars)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-178)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
}
```

**File:** types/src/keyless/bn254_circom.rs (L268-277)
```rust
pub fn cached_jwk_hash(jwk: &RSA_JWK) -> anyhow::Result<Fr> {
    match JWK_HASH_CACHE.get(jwk) {
        None => {
            let hash = jwk.to_poseidon_scalar()?;
            JWK_HASH_CACHE.insert(jwk.clone(), hash);
            Ok(hash)
        },
        Some(hash) => Ok(hash),
    }
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L292-364)
```rust
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }

                // If an `aud` override was set for account recovery purposes, check that it is
                // in the allow-list on-chain.
                if zksig.override_aud_val.is_some() {
                    config.is_allowed_override_aud(zksig.override_aud_val.as_ref().unwrap())?;
                }
                match &zksig.proof {
                    ZKP::Groth16(groth16proof) => {
                        // let start = std::time::Instant::now();
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
                        // println!("Public inputs hash time: {:?}", start.elapsed());

                        let groth16_and_stmt =
                            Groth16ProofAndStatement::new(*groth16proof, public_inputs_hash);

                        // The training wheels signature is only checked if a training wheels PK is set on chain
                        if training_wheels_pk.is_some() {
                            match &zksig.training_wheels_signature {
                                Some(training_wheels_sig) => {
                                    training_wheels_sig
                                        .verify(
                                            &groth16_and_stmt,
                                            training_wheels_pk.as_ref().unwrap(),
                                        )
                                        .map_err(|_| {
                                            // println!("[aptos-vm][groth16] TW sig verification failed");
                                            invalid_signature!(
                                                "Could not verify training wheels signature"
                                            )
                                        })?;
                                },
                                None => {
                                    // println!("[aptos-vm][groth16] Expected TW sig to be set");
                                    return Err(invalid_signature!(
                                        "Training wheels signature expected but it is missing"
                                    ));
                                },
                            }
                        }

                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
                    },
                }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L368-399)
```rust
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L33-33)
```text
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1810)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2000-2027)
```rust
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));

        if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            let max_aa_gas = unwrap_or_discard!(self.gas_params(log_context))
                .vm
                .txn
                .max_aa_gas;
            if max_aa_gas < txn_data.max_gas_amount() {
                // Reset initial gas after validation with max_aa_gas.
                unwrap_or_discard!(gas_meter
                    .inject_balance(txn_data.max_gas_amount().checked_sub(max_aa_gas).unwrap()));
            }
        } else {
            assert_eq!(initial_gas, gas_meter.balance());
```
