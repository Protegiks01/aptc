# Audit Report

## Title
Move VM Value Deserialization Stack Overflow via Missing Depth Checks

## Summary
The Move VM's value deserialization code lacks depth checking, creating an asymmetry with serialization which does enforce depth limits. This allows attackers to craft deeply nested BCS-encoded transaction arguments that cause stack overflow, crashing validator nodes during argument deserialization.

## Finding Description

The Move VM implements depth checking asymmetrically between serialization and deserialization operations:

**Serialization enforces depth limits**: The `SerializationReadyValue::serialize` method includes a depth field and checks depth limits at the start of serialization. [1](#0-0) 

**Deserialization lacks depth checking**: The `DeserializationSeed` implementation has no depth field and performs no depth checking while recursively deserializing nested structures (structs and vectors). [2](#0-1)  The recursive deserialization for structs and vectors proceeds without any depth validation. [3](#0-2) 

**Attack Vector**: Transaction arguments are BCS-encoded byte vectors supplied by users. When processing transaction arguments, the VM calls `deserialize_arg` which uses `ValueSerDeContext::new(max_value_nest_depth).deserialize()` to convert bytes to values. [4](#0-3) 

Even though the `ValueSerDeContext` is initialized with `max_value_nest_depth = Some(128)`, the `check_depth` method is never called during deserialization. [5](#0-4)  The `check_depth` implementation exists but is only invoked during serialization operations.

**Exploitation Path**:
1. Attacker crafts a transaction with deeply nested BCS-encoded argument bytes (e.g., 1000+ levels of vector-in-vector nesting)
2. Transaction is submitted through normal API and enters mempool
3. When validator processes the transaction, `deserialize_arg` is called to deserialize arguments
4. Deserialization recursively processes all nesting levels without checking depth
5. Stack overflow occurs, crashing the validator process
6. All validators attempting to process this transaction will crash

The code comments acknowledge this risk: "Values can be recursive, and so it is important that we do not use recursive algorithms over deeply nested values as it can cause stack overflow." [6](#0-5) 

## Impact Explanation

**Critical Severity** - Total Loss of Liveness/Network Availability:

This vulnerability enables an attacker to crash all validator nodes in the network by submitting a single malicious transaction. The attack requires no privileged access and can be executed by any transaction sender. The impact meets the Critical category criteria:

- **Network-wide validator crashes**: When any validator attempts to execute a transaction containing deeply nested arguments, stack overflow occurs during deserialization, crashing the validator process
- **Repeatable DoS**: Attacker can continuously submit malicious transactions to maintain network disruption
- **Consensus disruption**: Validators crash at different times creating consensus failures
- **No authentication required**: Any account can submit such transactions through the public API

This violates the Move VM's safety invariant that "bytecode execution must respect gas limits and memory constraints" since the stack overflow occurs outside gas metering during argument processing.

## Likelihood Explanation

**High Likelihood**:

1. **Easy to exploit**: Crafting deeply nested BCS-encoded data is straightforward using standard BCS serialization libraries
2. **No special permissions**: Any user can submit transactions with arbitrary BCS-encoded argument bytes
3. **Direct attack path**: Transaction arguments flow directly from user input to the vulnerable deserialization code without intermediate validation that would prevent deeply nested structures
4. **Predictable behavior**: Stack overflow depth threshold can be determined experimentally, making the attack reliable
5. **No runtime detection**: The vulnerability manifests as a process crash, providing no opportunity for runtime mitigation

The only complexity is determining the exact nesting depth needed for stack overflow (typically 1000+ levels depending on stack size), which can be easily determined through local testing.

## Recommendation

Add depth tracking and checking to the deserialization path, mirroring the serialization implementation:

1. Add a `depth` field to `DeserializationSeed` struct
2. Call `ctx.check_depth(depth)` at the start of `deserialize` implementations
3. Increment depth when recursing into nested structures (vectors, structs, variants)
4. Initialize depth to 1 when creating the seed in `ValueSerDeContext::deserialize`

This would enforce the same `max_value_nest_depth` limit (128) during deserialization that is already enforced during serialization.

## Proof of Concept

```rust
// Create deeply nested BCS-encoded vector
fn create_nested_vector(depth: usize) -> Vec<u8> {
    let mut value = vec![0u8]; // innermost value
    for _ in 0..depth {
        // Wrap in vector: BCS encoding is length (uleb128) + elements
        let mut wrapped = Vec::new();
        wrapped.push(1); // vector length = 1
        wrapped.extend(&value);
        value = wrapped;
    }
    value
}

// Submit transaction with nested argument
// At depth ~1000+, this will cause stack overflow during deserialization
let malicious_arg = create_nested_vector(1500);
let txn = create_transaction_with_args(vec![malicious_arg]);
submit_transaction(txn); // Validator crashes on deserialization
```

**Notes**

While the report's explanation conflates TypeDepthChecker (which checks type definitions) with value depth checking, the core vulnerability is valid. The actual issue is simpler than described: deserialization lacks depth checking entirely, regardless of any TypeDepthChecker behavior. This affects all versions where transaction arguments undergo deserialization, making it a critical security issue that should be addressed immediately.

### Citations

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L50-57)
```rust
/// Values can be recursive, and so it is important that we do not use recursive algorithms over
/// deeply nested values as it can cause stack overflow. Since it is not always possible to avoid
/// recursion, we opt for a reasonable limit on VM value depth. It is defined in Move VM config,
/// but since it is difficult to propagate config context everywhere, we use this constant.
///
/// IMPORTANT: When changing this constant, make sure it is in-sync with one in VM config (it is
/// used there now).
pub const DEFAULT_MAX_VM_VALUE_NESTED_DEPTH: u64 = 128;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4818-4838)
```rust
pub(crate) struct SerializationReadyValue<'c, 'l, 'v, L, V> {
    // Contains the current (possibly custom) serialization context.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout for guiding serialization.
    pub(crate) layout: &'l L,
    // Value to serialize.
    pub(crate) value: &'v V,
    pub(crate) depth: u64,
}

fn invariant_violation<S: serde::Serializer>(message: String) -> S::Error {
    S::Error::custom(
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(message),
    )
}

impl serde::Serialize for SerializationReadyValue<'_, '_, '_, MoveTypeLayout, Value> {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        use MoveTypeLayout as L;

        self.ctx.check_depth(self.depth).map_err(S::Error::custom)?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5085-5090)
```rust
pub(crate) struct DeserializationSeed<'c, L> {
    // Holds extensions external to the deserializer.
    pub(crate) ctx: &'c ValueSerDeContext<'c>,
    // Layout to guide deserialization.
    pub(crate) layout: L,
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5132-5163)
```rust
            L::Struct(struct_layout) => {
                let seed = DeserializationSeed {
                    ctx: self.ctx,
                    layout: struct_layout,
                };
                Ok(Value::struct_(seed.deserialize(deserializer)?))
            },

            // Vectors.
            L::Vector(layout) => Ok(match layout.as_ref() {
                L::U8 => Value::vector_u8(Vec::deserialize(deserializer)?),
                L::U16 => Value::vector_u16(Vec::deserialize(deserializer)?),
                L::U32 => Value::vector_u32(Vec::deserialize(deserializer)?),
                L::U64 => Value::vector_u64(Vec::deserialize(deserializer)?),
                L::U128 => Value::vector_u128(Vec::deserialize(deserializer)?),
                L::U256 => Value::vector_u256(Vec::deserialize(deserializer)?),
                L::I8 => Value::vector_i8(Vec::deserialize(deserializer)?),
                L::I16 => Value::vector_i16(Vec::deserialize(deserializer)?),
                L::I32 => Value::vector_i32(Vec::deserialize(deserializer)?),
                L::I64 => Value::vector_i64(Vec::deserialize(deserializer)?),
                L::I128 => Value::vector_i128(Vec::deserialize(deserializer)?),
                L::I256 => Value::vector_i256(Vec::deserialize(deserializer)?),
                L::Bool => Value::vector_bool(Vec::deserialize(deserializer)?),
                L::Address => Value::vector_address(Vec::deserialize(deserializer)?),
                layout => {
                    let seed = DeserializationSeed {
                        ctx: self.ctx,
                        layout,
                    };
                    let vector = deserializer.deserialize_seq(VectorElementVisitor(seed))?;
                    Value::Container(Container::Vec(Rc::new(RefCell::new(vector))))
                },
```

**File:** third_party/move/move-vm/runtime/src/move_vm.rs (L179-216)
```rust
fn deserialize_arg(
    function_value_extension: &impl FunctionValueExtension,
    layout_converter: &LayoutConverter<impl Loader>,
    gas_meter: &mut impl GasMeter,
    traversal_context: &mut TraversalContext,
    ty: &Type,
    arg: impl Borrow<[u8]>,
) -> PartialVMResult<Value> {
    let deserialization_error = || -> PartialVMError {
        PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
            .with_message("[VM] failed to deserialize argument".to_string())
    };

    // Make sure we do not construct values which might have delayed fields inside. This should be
    // guaranteed by transaction argument validation but because it does not use layouts we better
    // double-check here.
    let layout = layout_converter
        .type_to_type_layout_with_delayed_fields(gas_meter, traversal_context, ty, false)
        .map_err(|err| {
            if layout_converter.is_lazy_loading_enabled() {
                err
            } else {
                // Note: for backwards compatibility, the error code is remapped to this error. We
                // no longer should do it because layout construction may return useful errors such
                // as layout being too large, running out of gas, etc.
                PartialVMError::new(StatusCode::INVALID_PARAM_TYPE_FOR_DESERIALIZATION)
                    .with_message("[VM] failed to get layout from type".to_string())
            }
        })?
        .into_layout_when_has_no_delayed_fields()
        .ok_or_else(deserialization_error)?;

    let max_value_nest_depth = function_value_extension.max_value_nest_depth();
    ValueSerDeContext::new(max_value_nest_depth)
        .with_func_args_deserialization(function_value_extension)
        .deserialize(arg.borrow(), &layout)
        .ok_or_else(deserialization_error)
}
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```
