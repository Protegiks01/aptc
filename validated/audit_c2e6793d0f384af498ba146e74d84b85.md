# Audit Report

## Title
Version Upgrade Proposals Can Skip Versions Due to Config Buffer Overwrite Race Condition During DKG

## Summary
When DKG is enabled, multiple version upgrade governance proposals executed within the same epoch can overwrite each other's buffered version configurations. The `version::set_for_next_epoch()` function validates only against the current active version, not against any already-buffered version, allowing subsequent proposals to silently overwrite previous ones. This causes approved version upgrades to be skipped, violating governance expectations.

## Finding Description

The vulnerability exists in the version configuration buffering mechanism during DKG-based reconfiguration.

**Technical Root Cause:**

The `version::set_for_next_epoch()` function only validates against the current active version: [1](#0-0) 

The validation on line 61-62 checks `old_major < major` where `old_major` is retrieved from the current `Version` resource, not from any buffered pending version. It then directly calls `config_buffer::upsert()` which unconditionally overwrites any existing buffered value: [2](#0-1) 

The `simple_map::upsert()` operation performs an insert-or-update, overwriting any existing entry for the `Version` type.

**DKG Asynchronous Window:**

When DKG is enabled, `reconfiguration_with_dkg::try_start()` initiates DKG but returns immediately: [3](#0-2) 

The protection on lines 26-30 only prevents starting multiple DKG sessions for the same epoch—it does not prevent config buffer modifications. During the DKG completion window (typically 20-80 seconds), multiple blocks execute and governance proposals can be resolved.

**Exploitation Scenario:**

1. **Block N**: Proposal A resolves → `set_for_next_epoch(5)` buffers `Version{major: 5}` → `aptos_governance::reconfigure()` starts DKG via `try_start()`
2. **Block N+M** (same epoch, DKG still running): Proposal B resolves → `set_for_next_epoch(6)` validates `4 < 6` (current version, not buffered) → buffers `Version{major: 6}` **overwriting** `Version{major: 5}` → `reconfigure()` calls `try_start()` which returns early (lines 26-30)
3. **Block N+K**: DKG completes → `finish()` calls `on_new_epoch()` → extracts `Version{major: 6}`
4. **Result**: Version 5 is never applied despite governance approval

The reconfigure flow confirms this pattern: [4](#0-3) 

**Comparison with Correct Implementation:**

Other configuration modules implement the correct pattern. The `features` module extracts any existing buffered value before applying modifications: [5](#0-4) 

Lines 813-816 check for existing `PendingFeatures` and extract it as the baseline before applying the diff. This ensures multiple updates in the same epoch build upon each other rather than overwriting.

The `version` module lacks this extract-before-modify pattern, making it vulnerable to overwrites.

## Impact Explanation

**Severity: Medium** - Aligns with "State inconsistencies requiring manual intervention" in the Aptos bug bounty program.

**Concrete Impacts:**

1. **Governance Integrity Violation**: Approved governance proposals are not executed as voted. Stakeholders who voted for Proposal A (version 5) expect it to be applied, but it is silently skipped.

2. **Protocol Upgrade Risk**: If version 5 contains critical security patches or protocol changes required for compatibility, skipping directly to version 6 could:
   - Leave known vulnerabilities unpatched
   - Create incompatibilities if version 6 assumes version 5's changes were applied
   - Cause unexpected validator behavior

3. **Non-Deterministic Governance**: The execution timing of approved proposals, not their approval order or content, determines which version is applied. This undermines governance predictability.

4. **Manual Intervention Required**: Detecting the skipped version requires off-chain monitoring. Recovery requires submitting and approving a new governance proposal to re-apply the skipped version, consuming governance resources and time.

This does not directly cause fund loss or consensus failure but undermines the governance system's reliability and could indirectly enable security issues if critical versions are skipped.

## Likelihood Explanation

**Likelihood: Medium** when DKG is enabled

**Required Conditions:**
- `RECONFIGURE_WITH_DKG` feature enabled (already active on mainnet)
- Two version upgrade proposals approved by governance (legitimate activity)
- Both proposals executed within the DKG completion window (20-80 seconds)

**Why Realistic:**

1. **Extended Execution Windows**: Approved governance proposals remain valid for days/weeks. Multiple proposals can await execution simultaneously.

2. **Measurable Race Window**: DKG completion takes 20-80 seconds (based on test configurations), during which multiple blocks execute. This provides a realistic exploitation window.

3. **No Technical Barriers**: No mechanism prevents multiple proposals from executing in different blocks within the same epoch. Unlike the `stake` module which checks `reconfiguration_state::is_in_progress()`, the `version` module has no such protection.

4. **Coordination Failures**: Different teams may independently propose version upgrades without awareness of pending proposals, leading to unintentional overwrites.

5. **Deliberate Exploitation**: Malicious governance participants could deliberately time proposal execution to skip critical versions, though this is less likely than coordination failures.

The vulnerability can be triggered through legitimate governance operations without requiring any actor to behave maliciously.

## Recommendation

Implement the extract-before-modify pattern used by the `features` module:

```move
public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
    assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
    
    // Determine baseline: use buffered version if exists, else current version
    let baseline_major = if (config_buffer::does_exist<Version>()) {
        let buffered = config_buffer::extract_v2<Version>();
        let baseline = buffered.major;
        baseline
    } else {
        borrow_global<Version>(@aptos_framework).major
    };
    
    // Validate against baseline, not just current version
    assert!(baseline_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
    
    config_buffer::upsert(Version {major});
}
```

**Alternative**: Add a check to prevent version proposal execution during active reconfiguration:

```move
public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
    assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
    assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
    // ... rest of function
}
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_version_skip_during_dkg(aptos_framework: signer) {
    // Setup: Initialize version at 4, enable DKG
    version::initialize(&aptos_framework, 4);
    features::change_feature_flags_for_next_epoch(&aptos_framework, vector[RECONFIGURE_WITH_DKG], vector[]);
    
    // Proposal A: Set version to 5
    version::set_for_next_epoch(&aptos_framework, 5);
    
    // Simulate DKG start
    aptos_governance::reconfigure(&aptos_framework);
    
    // Verify version 5 is buffered
    assert!(config_buffer::does_exist<Version>(), 0);
    
    // Proposal B: Set version to 6 (same epoch, DKG running)
    version::set_for_next_epoch(&aptos_framework, 6);
    
    // Version 5 is now overwritten by version 6 in buffer
    let buffered = config_buffer::extract_v2<Version>();
    assert!(buffered.major == 6, 1); // Should be 6, not 5
    
    // Complete reconfiguration
    reconfiguration_with_dkg::finish(&aptos_framework);
    
    // Result: Version jumped from 4 to 6, skipping 5
    assert!(version::get() == 6, 2);
}
```

## Notes

This vulnerability is distinct from malicious governance attacks. It represents a **coordination failure vulnerability** in the governance system's implementation, not an attack by governance participants. The flaw allows legitimate, independently-approved proposals to silently interfere with each other due to insufficient validation in the version buffering logic.

The existence of the correct pattern in `features::change_feature_flags_for_next_epoch()` demonstrates this is an implementation oversight in the `version` module, not intended behavior.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-64)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
