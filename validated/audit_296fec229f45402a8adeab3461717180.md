# Audit Report

## Title
Order Vote Validation Uses Incorrect BlockInfo Comparison in Decoupled Execution Mode

## Summary
The safety rules for order vote validation use direct BlockInfo comparison (`!=`) instead of `match_ordered_only()`, causing order votes to be rejected when execution completes before order vote creation. This logic bug prevents validators from creating valid order votes in decoupled execution mode, potentially causing consensus liveness issues.

## Finding Description

Aptos consensus operates in decoupled execution mode where block ordering occurs before execution completes. The vulnerability exists in the safety rules validation logic for order votes.

**Regular Voting Phase**: When validators create votes, the system uses placeholder execution state. The `vote_proposal()` method hardcodes `decoupled_execution=true`, [1](#0-0)  and the `gen_vote_data()` method creates `BlockInfo` with `ACCUMULATOR_PLACEHOLDER_HASH` for ordering-only data. [2](#0-1) 

**Decoupled Execution Default**: Decoupled execution is enabled by default in the consensus configuration. [3](#0-2) 

**Order Vote Creation Flow**: After QC formation, the `broadcast_order_vote()` function creates an order vote proposal. [4](#0-3)  The `order_vote_proposal()` method calls `block_info()` which retrieves the current execution state via `compute_result()`. [5](#0-4)  If execution has completed, this returns the real hash instead of the placeholder.

**The Core Bug**: Safety rules validate order votes using direct BlockInfo comparison with the `!=` operator. [6](#0-5)  Since BlockInfo derives `PartialEq`, [7](#0-6)  the `!=` operator compares ALL fields including `executed_state_id`. When the QC's certified_block has placeholder hash but order_vote_proposal.block_info() has the real hash (because execution completed), they don't match, causing `InvalidOneChainQuorumCertificate` error.

**Correct Pattern Exists**: Other parts of the codebase correctly use `match_ordered_only()` for comparing block info in decoupled execution scenarios. The `match_ordered_only()` method only compares fields that don't change during execution (epoch, round, id, timestamp). [8](#0-7)  This pattern is used in commit vote validation, [9](#0-8)  QC merging with executed state, [10](#0-9)  and block store QC validation with an explicit comment about decoupled execution. [11](#0-10) 

## Impact Explanation

**HIGH Severity** - This qualifies as "Validator Node Slowdowns (High)" per the Aptos bug bounty program.

1. **Order Vote Rejection**: Validators whose execution completes before order vote creation cannot create valid order votes due to the incorrect hash comparison, causing their safety rules to reject otherwise valid order vote proposals.

2. **Potential Quorum Failure**: If sufficient validators (>1/3) complete execution quickly due to hardware advantages or lighter blocks, order certificate formation may fail as these validators cannot contribute order votes.

3. **Consensus Pipeline Impact**: While regular QCs form successfully, the ordering phase could experience delays or stalls, affecting the overall consensus pipeline performance.

4. **Logic Bug**: The code violates the established design pattern used consistently elsewhere in the codebase for handling decoupled execution scenarios, indicating this is an implementation oversight rather than intentional design.

## Likelihood Explanation

**MEDIUM to HIGH Likelihood**:

1. **Always Active**: Decoupled execution is the default and hardcoded in vote proposal creation, so the vulnerable code path is always executed in normal operation.

2. **Natural Timing Variance**: Validators have different execution speeds due to hardware capabilities, network conditions, current load, and block complexity. Some validators will naturally complete execution before order vote creation.

3. **No Synchronization**: The code path from QC formation to order vote creation contains no explicit synchronization with execution completion, allowing the race condition to occur naturally.

4. **Inconsistent Pattern**: The codebase demonstrates awareness of this issue through `match_ordered_only()` usage in three other similar scenarios, indicating the bug at line 97 is an oversight in applying the correct comparison pattern.

## Recommendation

Replace the direct BlockInfo comparison with `match_ordered_only()` to align with the decoupled execution design pattern used elsewhere:

```rust
pub(crate) fn verify_order_vote_proposal(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<(), Error> {
    let proposed_block = order_vote_proposal.block();
    let safety_data = self.persistent_storage.safety_data()?;

    self.verify_epoch(proposed_block.epoch(), &safety_data)?;

    let qc = order_vote_proposal.quorum_cert();
    // Use match_ordered_only for decoupled execution compatibility
    if !qc.certified_block().match_ordered_only(order_vote_proposal.block_info()) {
        return Err(Error::InconsistentExecutionResult(
            qc.certified_block().to_string(),
            order_vote_proposal.block_info().to_string(),
        ));
    }
    if qc.certified_block().id() != proposed_block.id() {
        return Err(Error::InvalidOneChainQuorumCertificate(
            qc.certified_block().id(),
            proposed_block.id(),
        ));
    }
    self.verify_qc(qc)?;
    Ok(())
}
```

This ensures the comparison only checks fields that remain constant between ordering and execution phases (epoch, round, id, timestamp), consistent with the pattern in commit vote validation and QC merging.

## Proof of Concept

While a full PoC would require a multi-validator test environment with controlled execution timing, the bug can be demonstrated by examining the code flow:

1. Block is proposed and voted on with placeholder hash (`ACCUMULATOR_PLACEHOLDER_HASH`)
2. QC is formed with `certified_block.executed_state_id = ACCUMULATOR_PLACEHOLDER_HASH`
3. Block execution completes asynchronously, updating `state_compute_result` with real hash
4. Order vote creation calls `block_info()` which returns `BlockInfo` with real `executed_state_id`
5. Safety rules comparison `qc.certified_block() != order_vote_proposal.block_info()` evaluates to `true` (hashes differ)
6. Order vote creation fails with `InvalidOneChainQuorumCertificate` error

The race condition naturally occurs when execution completes between steps 2 and 4, which is timing-dependent but inevitable given async execution and validator performance variance.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-473)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }

    pub fn vote_proposal(&self) -> VoteProposal {
        let compute_result = self.compute_result();
        VoteProposal::new(
            compute_result.extension_proof(),
            self.block.clone(),
            compute_result.epoch_state().clone(),
            true,
        )
    }

    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-495)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
```

**File:** consensus/src/round_manager.rs (L1653-1689)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
            if !proposed_block.block().is_nil_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED,
                );
            }
            if proposed_block.block().is_opt_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED_OPT_BLOCK,
                );
            }
            let order_vote_msg = OrderVoteMsg::new(order_vote, qc.as_ref().clone());
            info!(
                self.new_log(LogEvent::BroadcastOrderVote),
                "{}", order_vote_msg
            );
            self.network.broadcast_order_vote(order_vote_msg).await;
            if proposed_block.pipeline_futs().is_some() {
                if let Some(tx) = proposed_block.pipeline_tx().lock().as_mut() {
                    let _ = tx.order_vote_tx.take().map(|tx| tx.send(()));
                }
            }
            ORDER_VOTE_BROADCASTED.inc();
        }
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** types/src/block_info.rs (L27-28)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L150-163)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<QuorumCert> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** consensus/src/block_storage/block_store.rs (L525-536)
```rust
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
```
