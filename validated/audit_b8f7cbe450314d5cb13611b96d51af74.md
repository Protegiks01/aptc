# Audit Report

## Title
Resource Group Cache Memory Exhaustion Before Gas Charging Enables Validator Node OOM

## Summary
The `load_to_cache()` function in `ResourceGroupAdapter` deserializes entire resource groups into memory before gas is charged for the read operation. This violates the Move VM safety invariant that bytecode execution must respect gas limits and memory constraints, enabling memory exhaustion attacks against validator nodes.

## Finding Description

The vulnerability exists in the resource group loading mechanism where **deserialization precedes gas charging**.

**Technical Flow:**

When a transaction accesses a resource group member, the execution follows this path:

1. The Move VM interpreter calls `load_resource_mut()` which invokes the data cache [1](#0-0) 

2. This triggers `create_data_cache_entry()` which calls the resource resolver [2](#0-1) [3](#0-2) 

3. For resource groups, `StorageAdapter::get_any_resource_with_layout()` is invoked [4](#0-3) 

4. This calls `ResourceGroupAdapter::load_to_cache()` which **deserializes the entire BTreeMap** via `bcs::from_bytes(&group_data_blob)` [5](#0-4) 

5. **Only after deserialization completes** does the interpreter charge gas [6](#0-5) 

**Block Executor Path Also Vulnerable:**

In parallel execution, the block executor's `LatestView::initialize_mvhashmap_base_group_contents()` also deserializes the entire BTreeMap before gas charging [7](#0-6) 

**No Size Limits on Reads:**

The codebase has write limits for resource group creation [8](#0-7) [9](#0-8)  but no corresponding limits prevent reading arbitrarily large resource groups before deserialization.

The memory tracker only checks limits **after** deserialization [10](#0-9) 

## Impact Explanation

**High Severity** per Aptos Bug Bounty Program - "Validator node slowdowns/API crashes"

This vulnerability enables:

1. **Validator Process Crashes**: Large resource groups deserializing before gas limits trigger causes memory consumption that could exceed available RAM, resulting in OOM kills of validator processes.

2. **Consensus Availability Impact**: When validators crash, network consensus participation degrades. If multiple validators are affected, this can cause transaction processing delays or liveness issues.

3. **Persistent Attack Vector**: Once large resource groups exist on-chain (after paying one-time storage fees), any subsequent transaction reading them triggers the vulnerability. The attack can be repeated indefinitely without additional cost.

4. **Pre-Gas-Accounting Failure**: Unlike normal gas exhaustion which cleanly aborts transactions, memory allocation during BCS deserialization occurs before gas accounting, providing no protective abort mechanism.

## Likelihood Explanation

**High Likelihood**:

1. **Low Complexity**: Attacker creates resource groups using standard `#[resource_group_member]` attributes, adds large members over multiple transactions (subject to write limits per transaction), then waits for or triggers reads.

2. **Economic Viability**: While storage fees apply during creation, write limits can be bypassed by incremental additions across transactions. Once created, perpetual exploitation with no additional cost.

3. **No Privileges Required**: Any account can create resource groups and deploy Move modules using them.

4. **Multiple Vulnerable Paths**: Both the cache-based path and block executor path perform deserialization before gas charging.

## Recommendation

Implement a size check before BCS deserialization of resource groups:

1. Check the serialized size of the resource group blob before calling `bcs::from_bytes()`
2. Enforce a maximum read size limit (e.g., aligned with write limits)
3. Return an error if the size exceeds the limit, preventing deserialization
4. Alternatively, implement streaming/lazy deserialization that respects gas limits incrementally

## Proof of Concept

A complete PoC would require:
1. Deploying Move modules with resource group members
2. Creating a resource group with incremental additions across multiple transactions to bypass per-transaction write limits
3. Submitting a transaction that reads from this resource group
4. Monitoring validator memory usage during block execution

The core vulnerability can be demonstrated by tracing the code execution path showing BCS deserialization occurs before gas metering in both execution paths.

## Notes

The vulnerability affects both execution paths:
- **Non-parallel/legacy path**: Uses `ResourceGroupAdapter::load_to_cache()` with cache-based deserialization
- **Parallel execution path**: Uses `LatestView::initialize_mvhashmap_base_group_contents()` which also deserializes before gas charging

The parallel execution amplification claim depends on the `GroupSizeKind` configuration, but both paths share the fundamental vulnerability: **deserialization before gas limit enforcement**. This violates the core safety invariant of the Move VM that gas limits protect against unbounded resource consumption.

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1310-1333)
```rust
    fn load_resource_mut<'cache>(
        &self,
        data_cache: &'cache mut impl MoveVmDataCache,
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext,
        addr: AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<&'cache mut GlobalValue> {
        let (gv, bytes_loaded) =
            data_cache.load_resource_mut(gas_meter, traversal_context, &addr, ty)?;
        if let Some(bytes_loaded) = bytes_loaded {
            gas_meter.charge_load_resource(
                addr,
                TypeWithRuntimeEnvironment {
                    ty,
                    runtime_environment: self.loader.runtime_environment(),
                },
                gv.view(),
                bytes_loaded,
            )?;
        }

        Ok(gv)
    }
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L125-151)
```rust
    fn load_resource_mut(
        &mut self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        addr: &AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<(&mut GlobalValue, Option<NumBytes>)> {
        let bytes_loaded = if !self.data_cache.contains_resource(addr, ty) {
            let (entry, bytes_loaded) = TransactionDataCache::create_data_cache_entry(
                self.loader,
                &LayoutConverter::new(self.loader),
                gas_meter,
                traversal_context,
                self.loader.unmetered_module_storage(),
                self.resource_resolver,
                addr,
                ty,
            )?;
            self.data_cache.insert_resource(*addr, ty.clone(), entry)?;
            Some(bytes_loaded)
        } else {
            None
        };

        let gv = self.data_cache.get_resource_mut(addr, ty)?;
        Ok((gv, bytes_loaded))
    }
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L255-327)
```rust
    fn create_data_cache_entry(
        metadata_loader: &impl ModuleMetadataLoader,
        layout_converter: &LayoutConverter<impl StructDefinitionLoader>,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_storage: &dyn ModuleStorage,
        resource_resolver: &dyn ResourceResolver,
        addr: &AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<(DataCacheEntry, NumBytes)> {
        let struct_tag = match module_storage.runtime_environment().ty_to_ty_tag(ty)? {
            TypeTag::Struct(struct_tag) => *struct_tag,
            _ => {
                // Since every resource is a struct, the tag must be also a struct tag.
                return Err(PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR));
            },
        };

        let layout_with_delayed_fields = layout_converter.type_to_type_layout_with_delayed_fields(
            gas_meter,
            traversal_context,
            ty,
            false,
        )?;

        let (data, bytes_loaded) = {
            let module = metadata_loader.load_module_for_metadata(
                gas_meter,
                traversal_context,
                &struct_tag.module_id(),
            )?;

            // If we need to process delayed fields, we pass type layout to remote storage. Remote
            // storage, in turn ensures that all delayed field values are pre-processed.
            resource_resolver.get_resource_bytes_with_metadata_and_layout(
                addr,
                &struct_tag,
                &module.metadata,
                layout_with_delayed_fields.layout_when_contains_delayed_fields(),
            )?
        };

        let function_value_extension = FunctionValueExtensionAdapter { module_storage };
        let (layout, contains_delayed_fields) = layout_with_delayed_fields.unpack();
        let value = match data {
            Some(blob) => {
                let max_value_nest_depth = function_value_extension.max_value_nest_depth();
                let val = ValueSerDeContext::new(max_value_nest_depth)
                    .with_func_args_deserialization(&function_value_extension)
                    .with_delayed_fields_serde()
                    .deserialize(&blob, &layout)
                    .ok_or_else(|| {
                        let msg = format!(
                            "Failed to deserialize resource {} at {}!",
                            struct_tag.to_canonical_string(),
                            addr
                        );
                        PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_RESOURCE)
                            .with_message(msg)
                    })?;
                GlobalValue::cached(val)?
            },
            None => GlobalValue::none(),
        };

        let entry = DataCacheEntry {
            struct_tag,
            layout,
            contains_delayed_fields,
            value,
        };
        Ok((entry, NumBytes::new(bytes_loaded as u64)))
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L164-197)
```rust
    fn load_to_cache(&self, group_key: &StateKey) -> PartialVMResult<bool> {
        let already_cached = self.group_cache.borrow().contains_key(group_key);
        if already_cached {
            return Ok(true);
        }

        let group_data = self.resource_view.get_resource_bytes(group_key, None)?;
        let (group_data, blob_len): (BTreeMap<StructTag, Bytes>, u64) = group_data.map_or_else(
            || Ok::<_, PartialVMError>((BTreeMap::new(), 0)),
            |group_data_blob| {
                let group_data = bcs::from_bytes(&group_data_blob).map_err(|e| {
                    PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR).with_message(
                        format!(
                            "Failed to deserialize the resource group at {:? }: {:?}",
                            group_key, e
                        ),
                    )
                })?;
                Ok((group_data, group_data_blob.len() as u64))
            },
        )?;

        let group_size = match self.group_size_kind {
            GroupSizeKind::None => ResourceGroupSize::Concrete(0),
            GroupSizeKind::AsBlob => ResourceGroupSize::Concrete(blob_len),
            GroupSizeKind::AsSum => {
                group_size_as_sum(group_data.iter().map(|(t, v)| (t, v.len())))?
            },
        };
        self.group_cache
            .borrow_mut()
            .insert(group_key.clone(), (group_data, group_size));
        Ok(false)
    }
```

**File:** aptos-move/block-executor/src/view.rs (L1586-1619)
```rust
    fn initialize_mvhashmap_base_group_contents(&self, group_key: &T::Key) -> PartialVMResult<()> {
        let (base_group, metadata_op): (BTreeMap<T::Tag, Bytes>, _) =
            match self.get_raw_base_value(group_key)? {
                Some(state_value) => (
                    bcs::from_bytes(state_value.bytes()).map_err(|e| {
                        PartialVMError::new(StatusCode::UNEXPECTED_DESERIALIZATION_ERROR)
                            .with_message(format!(
                                "Failed to deserialize the resource group at {:?}: {:?}",
                                group_key, e
                            ))
                    })?,
                    TransactionWrite::from_state_value(Some(state_value)),
                ),
                None => (BTreeMap::new(), TransactionWrite::from_state_value(None)),
            };
        let base_group_sentinel_ops = base_group
            .into_iter()
            .map(|(t, bytes)| {
                (
                    t,
                    TransactionWrite::from_state_value(Some(StateValue::new_legacy(bytes))),
                )
            })
            .collect();

        self.latest_view
            .get_resource_group_state()
            .set_raw_group_base_values(group_key.clone(), base_group_sentinel_ops)?;
        self.latest_view.get_resource_state().set_base_value(
            group_key.clone(),
            ValueWithLayout::RawFromStorage(TriompheArc::new(metadata_op)),
        );
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L86-128)
```rust
    pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {
        let storage_write_limit_reached = |maybe_message: Option<&str>| {
            let mut err = PartialVMError::new(StatusCode::STORAGE_WRITE_LIMIT_REACHED);
            if let Some(message) = maybe_message {
                err = err.with_message(message.to_string())
            }
            Err(err.finish(Location::Undefined).into_vm_status())
        };

        if self.max_write_ops_per_transaction != 0
            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction
        {
            return storage_write_limit_reached(Some("Too many write ops."));
        }

        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-177)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
        [
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
        ],
        [
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
        [
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
        [
            max_write_ops_per_transaction: NumSlots,
            { 11.. => "max_write_ops_per_transaction" },
            8192,
        ],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L378-398)
```rust
    fn charge_load_resource(
        &mut self,
        addr: AccountAddress,
        ty: impl TypeView,
        val: Option<impl ValueView>,
        bytes_loaded: NumBytes,
    ) -> PartialVMResult<()> {
        if self.feature_version() != 0 {
            // TODO(Gas): Rewrite this in a better way.
            if let Some(val) = &val {
                self.use_heap_memory(
                    self.vm_gas_params()
                        .misc
                        .abs_val
                        .abstract_heap_size(val, self.feature_version())?,
                )?;
            }
        }

        self.base.charge_load_resource(addr, ty, val, bytes_loaded)
    }
```
