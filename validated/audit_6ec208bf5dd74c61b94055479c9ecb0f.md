# Audit Report

## Title
Version Skipping in Shard Database Queries Due to Empty-Path Seek Mismatch

## Summary
The `find_closest_node_version_at_or_before()` function uses an empty-path NodeKey as the seek key, but shard databases only contain nodes with non-empty paths. Due to lexicographic key ordering, this causes the function to skip valid versions entirely when queried against shard databases, breaking state consistency checks during recovery operations.

## Finding Description

The vulnerability arises from a mismatch between the seek key format and the actual key format stored in shard databases.

**NodeKey Encoding:** [1](#0-0) 

NodeKeys encode as `[version (8 bytes BigEndian)][num_nibbles (1 byte)][nibble_path_bytes]`. An empty-path key encodes as `[version][0x00]`, while shard root nodes encode as `[version][0x01][nibble_byte]`.

**Empty Path Creation:** [2](#0-1) 

**Shard Database Content:** [3](#0-2) [4](#0-3) 

Shard databases only contain nodes where `get_shard_id()` returns `Some(shard_id)`, requiring `num_nibbles >= 1`. Empty-path nodes (roots) are stored only in the metadata database.

**The Bug:** [5](#0-4) 

When `find_closest_node_version_at_or_before(shard_db, version)` seeks for `[version][0x00]` in a shard containing only `[version][0x01][...]` nodes, RocksDB's `seek_for_prev` positions at the largest key less than `[version][0x00]`, which is from an earlier version. The function then returns this earlier version, completely missing the current version's data in the shard.

**Where This Breaks Recovery:** [6](#0-5) [7](#0-6) [8](#0-7) 

During recovery, `get_max_version_in_state_merkle_db()` calls this function on each shard to find the maximum version. Due to the bug, it under-reports the actual maximum version. The divergence check `assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE)` then fails to detect when shards have diverged beyond the 1,000,000 version threshold.

**Root Cause - Batched Commits:** [9](#0-8) 

State merkle commits write shard batches in parallel (lines 157-168) before committing top levels (line 170). A crash between these operations leaves shards at a newer version than the metadata database, creating the vulnerable state that triggers this bug during recovery.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria for "State inconsistencies requiring manual intervention":

1. **State Consistency Violation**: The bug allows shard data to diverge arbitrarily beyond the safety threshold without detection, violating the atomic state transition guarantee.

2. **Failed Safety Checks**: The `MAX_COMMIT_PROGRESS_DIFFERENCE` assertion is designed to crash nodes that have diverged too far, preventing data corruption. This bug bypasses that protection by under-reporting actual divergence.

3. **Incorrect Recovery**: Nodes fail to perform necessary truncation operations, continuing with inconsistent state between shards and metadata database.

4. **Not Critical**: While this breaks state consistency invariants, it does not directly cause fund loss, consensus splits, or network-wide failures, hence Medium rather than High/Critical severity.

## Likelihood Explanation

**High Likelihood** - Triggers automatically during normal operations:

1. **Every Recovery After Partial Commit**: Any node restart after shards commit but before metadata commit hits this path.

2. **Default Configuration**: The 16-shard architecture is production standard.

3. **By Design**: Batched commits for performance optimization naturally create partial commit states.

4. **No Preconditions**: Requires only normal node operation and restart, no attacker action needed.

## Recommendation

Modify `find_closest_node_version_at_or_before()` to use an appropriate seek key when querying shard databases:

```rust
pub(crate) fn find_closest_node_version_at_or_before(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
) -> Result<Option<Version>> {
    let mut iter = db.rev_iter::<JellyfishMerkleNodeSchema>()?;
    
    let seek_key = if let Some(shard_id) = shard_id {
        // For shard databases, seek with a 1-nibble path matching the shard
        let mut nibble_path = NibblePath::new_even(vec![]);
        nibble_path.push(Nibble::from(shard_id as u8));
        NodeKey::new(version, nibble_path)
    } else {
        // For metadata database, use empty path
        NodeKey::new_empty_path(version)
    };
    
    iter.seek_for_prev(&seek_key)?;
    Ok(iter.next().transpose()?.map(|item| item.0.version()))
}
```

Update all call sites to pass the `shard_id` parameter appropriately.

## Proof of Concept

This bug can be demonstrated by:

1. Creating a test shard database with nodes at version V having only 1-nibble paths
2. Calling `find_closest_node_version_at_or_before(shard_db, V)`
3. Observing it returns version < V instead of V
4. Verifying that `get_max_version_in_state_merkle_db()` under-reports the maximum version
5. Confirming the divergence check fails to trigger when it should

A full Rust integration test would involve simulating a crash mid-commit and verifying the recovery behavior exhibits this version skipping.

### Citations

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L66-68)
```rust
    pub fn new_empty_path(version: Version) -> Self {
        Self::new(version, NibblePath::new_even(vec![]))
    }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L103-109)
```rust
    pub fn encode(&self) -> Result<Vec<u8>> {
        let mut out = vec![];
        out.write_u64::<BigEndian>(self.version())?;
        out.write_u8(self.nibble_path().num_nibbles() as u8)?;
        out.write_all(self.nibble_path().bytes())?;
        Ok(out)
    }
```

**File:** types/src/nibble/nibble_path/mod.rs (L222-229)
```rust
    // Returns the shard_id of the NibblePath, or None if it is root.
    pub fn get_shard_id(&self) -> Option<usize> {
        if self.num_nibbles() > 0 {
            Some(usize::from(self.get_nibble(0)))
        } else {
            None
        }
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L147-171)
```rust
    pub(crate) fn commit(
        &self,
        version: Version,
        top_levels_batch: impl IntoRawBatch,
        batches_for_shards: Vec<impl IntoRawBatch + Send>,
    ) -> Result<()> {
        ensure!(
            batches_for_shards.len() == NUM_STATE_SHARDS,
            "Shard count mismatch."
        );
        THREAD_MANAGER.get_io_pool().install(|| {
            batches_for_shards
                .into_par_iter()
                .enumerate()
                .for_each(|(shard_id, batch)| {
                    self.db_shard(shard_id)
                        .write_schemas(batch)
                        .unwrap_or_else(|err| {
                            panic!("Failed to commit state merkle shard {shard_id}: {err}")
                        });
                })
        });

        self.commit_top_levels(version, top_levels_batch)
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L367-367)
```rust
            ensure!(node_key.get_shard_id() == shard_id, "shard_id mismatch");
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L263-284)
```rust
pub(crate) fn get_max_version_in_state_merkle_db(
    state_merkle_db: &StateMerkleDb,
) -> Result<Option<Version>> {
    let mut version = get_current_version_in_state_merkle_db(state_merkle_db)?;
    let num_real_shards = state_merkle_db.hack_num_real_shards();
    if num_real_shards > 1 {
        for shard_id in 0..num_real_shards {
            let shard_version = find_closest_node_version_at_or_before(
                state_merkle_db.db_shard(shard_id),
                Version::MAX,
            )?;
            if version.is_none() {
                version = shard_version;
            } else if let Some(shard_version) = shard_version {
                if shard_version > version.unwrap() {
                    version = Some(shard_version);
                }
            }
        }
    }
    Ok(version)
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L286-293)
```rust
pub(crate) fn find_closest_node_version_at_or_before(
    db: &DB,
    version: Version,
) -> Result<Option<Version>> {
    let mut iter = db.rev_iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek_for_prev(&NodeKey::new_empty_path(version))?;
    Ok(iter.next().transpose()?.map(|item| item.0.version()))
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L469-477)
```rust
            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
```
