# Audit Report

## Title
Memory Exhaustion Vulnerability in aptos_channel Due to Unbounded Message Sizes Leading to Validator OOM Crashes

## Summary
The consensus message handling pipeline queues messages in `aptos_channel` before size validation, allowing malicious validators to exhaust memory on honest validators by sending oversized consensus messages up to the network limit, potentially causing OOM crashes and consensus liveness failures.

## Finding Description

The vulnerability exists in the consensus message handling pipeline where size validation occurs **after** messages are queued rather than before.

**Root Cause:** The `aptos_channel` generic type has no trait bounds constraining message sizes [1](#0-0) , and messages are stored directly in a `VecDeque` without any pre-queuing size validation [2](#0-1) [3](#0-2) .

**Attack Flow:**

1. The network layer allows messages up to 64MB [4](#0-3) 

2. When consensus messages arrive from the network, they are immediately pushed to the `aptos_channel` queue **before** any size validation [5](#0-4) [6](#0-5) 

3. Messages are queued per `(AccountAddress, Discriminant<ConsensusMsg>)` key with max capacities of 10 for consensus messages and 50 for quorum store messages [7](#0-6) [8](#0-7) 

4. Size validation only occurs later when processing the proposal, after the message has been dequeued [9](#0-8) 

5. The consensus config sets max_receiving_block_bytes to 6MB [10](#0-9) 

**Exploitation Scenario:**

A malicious validator can craft `ProposalMsg` containing blocks with transaction payloads exceeding the 6MB consensus limit (up to network's 64MB limit). These messages pass network-layer deserialization and are queued in memory before consensus validation rejects them.

**Memory Calculation:**
- Single malicious validator, consensus messages: 10 messages × 6MB = 60MB per message type
- Single malicious validator, quorum store messages: 50 messages × 6MB = 300MB per message type
- Multiple malicious validators (10): 10 × 300MB = 3GB just for quorum store messages
- With multiple message types, memory consumption multiplies accordingly

This breaks the **Resource Limits** security invariant that all operations must respect memory constraints.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria category 8: "Validator Node Slowdowns (High) - DoS through resource exhaustion":

- **Validator node slowdowns**: Memory pressure causes significant performance degradation affecting consensus
- **Potential validator crashes**: OOM conditions can crash validator processes
- **Consensus liveness impact**: If multiple validators crash or slow down simultaneously, consensus may stall

The impact qualifies as High rather than Critical because:
- It requires compromised validators within the Byzantine threat model (<1/3 malicious validators)
- It doesn't directly cause fund loss or permanent state corruption
- Recovery is possible by restarting affected validators
- It affects availability rather than safety properties

However, in a large validator set with multiple compromised validators coordinating an attack, the impact could be severe enough to temporarily halt network progress.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is likely because:
- AptosBFT is designed to tolerate up to 1/3 Byzantine validators, so malicious validators are explicitly within the threat model
- No special privileges beyond being a validator are required
- The attack is straightforward: craft and send oversized consensus messages
- Detection may be delayed since messages appear structurally valid until processing
- No cryptographic or complex technical barriers exist

Mitigating factors:
- Requires control of one or more validator nodes (higher barrier than arbitrary network peer)
- Network bandwidth limitations may slow the attack rate
- Monitoring systems might detect unusual memory consumption patterns

## Recommendation

Implement size validation **before** queuing messages to prevent unbounded memory accumulation:

1. Add size checking in the network layer before pushing to `aptos_channel`
2. Enforce max_receiving_block_bytes limit at deserialization time
3. Add trait bounds or size limits to `aptos_channel` generic types
4. Consider adding memory backpressure mechanisms to drop oversized messages earlier in the pipeline

Example fix location: In `consensus/src/network.rs` at the `push_msg` function, add size validation before calling `tx.push()`.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability:
// 1. Malicious validator creates ProposalMsg with 10MB payload (exceeds 6MB limit)
// 2. Message passes network deserialization (under 64MB limit)
// 3. Message is queued in aptos_channel consuming memory
// 4. Eventually rejected by consensus validation, but memory already consumed
// 5. Repeat with multiple validators and message types to accumulate 3GB+

// The PoC would require:
// - Setting up a test validator network
// - Creating oversized ProposalMsg instances
// - Sending them through the network layer
// - Monitoring memory consumption as messages queue
// - Demonstrating OOM condition with sufficient message volume
```

**Notes**

This vulnerability represents a protocol-level design flaw where validation order creates a resource exhaustion vector. It is NOT a generic network DoS attack (which is out of scope), but rather exploits a specific gap in the validation pipeline that allows memory exhaustion through protocol messages. The framework explicitly categorizes "DoS through resource exhaustion" as a valid High severity impact when caused by protocol bugs.

### Citations

**File:** crates/channel/src/aptos_channel.rs (L29-31)
```rust
struct SharedState<K: Eq + Hash + Clone, M> {
    /// The internal queue of messages in this channel.
    internal_queue: PerKeyQueue<K, (M, Option<oneshot::Sender<ElementStatus<M>>>)>,
```

**File:** crates/channel/src/message_queues.rs (L51-51)
```rust
    per_key_queue: HashMap<K, VecDeque<T>>,
```

**File:** crates/channel/src/message_queues.rs (L149-149)
```rust
            key_message_queue.push_back(message);
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/src/network.rs (L757-761)
```rust
        let (consensus_messages_tx, consensus_messages) = aptos_channel::new(
            QueueStyle::FIFO,
            10,
            Some(&counters::CONSENSUS_CHANNEL_MSGS),
        );
```

**File:** consensus/src/network.rs (L762-767)
```rust
        let (quorum_store_messages_tx, quorum_store_messages) = aptos_channel::new(
            QueueStyle::FIFO,
            // TODO: tune this value based on quorum store messages with backpressure
            50,
            Some(&counters::QUORUM_STORE_CHANNEL_MSGS),
        );
```

**File:** consensus/src/network.rs (L807-807)
```rust
        if let Err(e) = tx.push((peer_id, discriminant(&msg)), (peer_id, msg)) {
```

**File:** consensus/src/network.rs (L900-900)
```rust
                            Self::push_msg(peer_id, consensus_msg, &self.consensus_messages_tx);
```

**File:** consensus/src/round_manager.rs (L1187-1193)
```rust
        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```

**File:** config/src/config/consensus_config.rs (L231-231)
```rust
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```
