# Audit Report

## Title
Transaction Authenticator Size Excluded from IO Gas Calculation Enables Resource Exhaustion Attack

## Summary
The `charge_change_set()` function charges IO gas based on `txn_data.transaction_size()`, which only includes the `RawTransaction` size and excludes the `TransactionAuthenticator` size. This allows attackers to craft transactions with large authenticators (up to ~128KB with keyless signatures) while only paying IO gas for the raw transaction portion (~64KB), enabling a ~66% IO gas avoidance attack.

## Finding Description

The vulnerability exists in how transaction size is calculated and used throughout the VM execution pipeline.

**Root Cause - Incomplete Transaction Size Calculation:**

When `TransactionMetadata` is initialized, the transaction size is set using only the raw transaction bytes: [1](#0-0) 

This uses `raw_txn_bytes_len()` which only serializes the `RawTransaction` component: [2](#0-1) 

However, a complete `SignedTransaction` consists of both `RawTransaction` AND `TransactionAuthenticator`. The correct full size is available via `txn_bytes_len()`: [3](#0-2) 

**Vulnerable Gas Charging:**

The `charge_change_set()` function charges IO gas using this incomplete size: [4](#0-3) 

**Transaction Size Validation Also Vulnerable:**

The `check_gas()` function validates transaction size limits using the same incomplete size: [5](#0-4) [6](#0-5) 

This allows transactions to bypass size limits by hiding size in the authenticator.

**Exploitation Path:**

An attacker can craft a `FeePayer` or `MultiAgent` transaction with maximum authenticator size. The authenticator can contain up to 32 signatures total: [7](#0-6) 

Using keyless signatures, each can be up to 4000 bytes: [8](#0-7) 

The raw transaction limit is 64KB: [9](#0-8) 

**Maximum exploitation scenario:**
- Raw transaction: 64KB (at regular limit)
- Authenticator with 32 keyless signatures: ~128KB (32 × 4000 bytes)
- Total actual transaction bytes: ~192KB
- IO gas charged for: only 64KB (~33% of actual size)

The IO gas rate is 89 gas per byte: [10](#0-9) 

The transaction passes validation, is accepted into mempool, propagated through consensus, and stored via BCS serialization (which serializes the complete transaction including authenticator), but only ~33% of the appropriate IO gas is charged.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables a resource exhaustion attack that qualifies as HIGH severity under the Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations."

**Attack Vectors:**

1. **Resource Exhaustion**: Attackers can flood the network with underpriced large transactions, consuming validator bandwidth, storage, and processing resources while paying up to 66% less IO gas than appropriate.

2. **Economic Attack**: Breaks the gas metering economic model. Validators process and store ~192KB transactions but only receive compensation for ~64KB, creating an economic denial of service.

3. **Network Congestion**: By submitting many such transactions, an attacker can congest the network at reduced cost, degrading performance for legitimate users.

4. **Storage Bloat**: Full transactions are stored in the database but storage-related fees are calculated based on incomplete size.

**Impact Quantification:**
- IO gas avoided per transaction: ~128KB × 89 gas/byte = ~11.4M gas units
- At typical gas price of 100 octas/gas: ~1.14 APT avoided per transaction
- Attacker submits transactions consuming 3× the bandwidth/storage while paying 1× the price

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Exploit**: No special privileges required. Any user can submit transactions with large authenticators through normal transaction submission APIs.

2. **Production Features**: Keyless authentication and multi-agent/fee payer transactions are already supported production features on mainnet.

3. **No Detection**: There are no current mechanisms to detect or prevent this exploitation pattern.

4. **Immediate Availability**: The attack can be executed immediately against current mainnet.

5. **Scalable**: An attacker can submit multiple such transactions to amplify the impact.

## Recommendation

Fix the root cause by using the complete transaction size (including authenticator) for all gas charging and validation:

1. **Update TransactionMetadata initialization** to use `txn_bytes_len()` instead of `raw_txn_bytes_len()`:
   ```rust
   transaction_size: (txn.txn_bytes_len() as u64).into(),
   ```

2. **Ensure consistency** across all size-related validations and gas charges to use the complete transaction size.

3. **Add validation** to enforce reasonable authenticator size limits if not already present.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a `FeePayer` transaction with:
   - Raw transaction payload near 64KB limit
   - 32 accounts each signing with keyless signatures (each ~4000 bytes)
   
2. Submitting this transaction through the normal API

3. Observing that:
   - Transaction passes `check_gas()` validation (only 64KB checked)
   - Transaction is charged IO gas for only ~64KB
   - Full ~192KB is transmitted through network and stored in database
   - Gas difference: ~11.4M gas units avoided (~1.14 APT at 100 octas/gas price)

This creates a practical economic denial of service where validators bear the cost of processing significantly more data than users pay for.

## Notes

This vulnerability affects the core gas metering system and violates fundamental protocol invariants about resource pricing. The issue is particularly concerning because it uses only supported, production features (keyless signatures and multi-agent transactions) and requires no special privileges to exploit. The economic impact scales linearly with the number of such transactions submitted, making it a practical attack vector for resource exhaustion on the Aptos network.

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```

**File:** types/src/transaction/mod.rs (L1300-1306)
```rust
    pub fn txn_bytes_len(&self) -> usize {
        let authenticator_size = *self.authenticator_size.get_or_init(|| {
            bcs::serialized_size(&self.authenticator)
                .expect("Unable to serialize TransactionAuthenticator")
        });
        self.raw_txn_bytes_len() + authenticator_size
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1120-1120)
```rust
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L81-81)
```rust
    let raw_bytes_len = txn_metadata.transaction_size;
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-109)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
```

**File:** types/src/transaction/authenticator.rs (L34-34)
```rust
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/keyless/mod.rs (L195-195)
```rust
    pub const MAX_LEN: usize = 4000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L138-141)
```rust
            storage_io_per_transaction_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_transaction_byte_write" },
            89,
        ],
```
