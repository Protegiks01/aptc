# Audit Report

## Title
Consensus Sync Request State Corruption via Arc Replacement Pattern Causing Lost Callback Responses

## Summary
The state sync driver uses an incorrect Arc replacement pattern when handling new consensus sync requests, causing previous request callbacks to be dropped without responses. This violates the consensus-state sync protocol invariant that every request receives exactly one response, potentially causing consensus errors and operational degradation.

## Finding Description

The vulnerability exists in how the `ConsensusNotificationHandler` manages consensus sync request state. When a new sync request arrives, the code creates a completely new `Arc<Mutex<Option<ConsensusSyncRequest>>>` instead of updating the contents of the existing Arc.

**Arc Replacement Pattern:**

When initializing sync duration requests, the code creates an entirely new Arc instance: [1](#0-0) 

When initializing sync target requests, the same pattern occurs: [2](#0-1) 

Both directly replace `self.consensus_sync_request`, discarding any existing Arc without responding to its callback.

**Callback Contract:**

Each sync request contains a oneshot channel callback that consensus awaits on: [3](#0-2) 

And for target notifications: [4](#0-3) 

When a oneshot::Sender is dropped without sending, the receiver gets a RecvError, which maps to `UnexpectedErrorEncountered`: [5](#0-4) 

And for target requests: [6](#0-5) 

**Missing Validation:**

The driver handlers accept new sync requests without checking if an active request exists: [7](#0-6) 

And for target notifications: [8](#0-7) 

No guard prevents overlapping requests despite `active_sync_request()` method existing: [9](#0-8) 

**Bug Flow:**

1. Consensus sends Request_A with callback_A → Driver creates Arc_A
2. Node begins syncing toward Request_A's target
3. Before completion, Request_B arrives → Driver creates Arc_B, replacing Arc_A
4. Arc_A is dropped (if no other references exist)
5. callback_A inside Arc_A is dropped without response
6. Consensus receives `UnexpectedErrorEncountered` when receiver is dropped

**Real Exploit Scenarios:**

Consensus observer spawns independent tokio tasks that can overlap. The fallback sync task: [10](#0-9) 

And the commit sync task: [11](#0-10) 

The observer only checks if syncing through an epoch, not for all active syncs: [12](#0-11) 

Epoch transitions call sync_to_target: [13](#0-12) 

Block storage fast-forward sync: [14](#0-13) 

## Impact Explanation

**Medium Severity** - This qualifies as a protocol violation with operational impact:

1. **Protocol Violation**: Breaks the fundamental consensus-state sync contract that every request receives exactly one response
2. **Consensus Operational Impact**: Consensus receives unexpected errors, potentially causing validator slowdowns if errors trigger excessive retries or fallback logic
3. **State Sync Coordination Failure**: Disrupts synchronization mechanism between consensus and state sync during critical operations
4. **Cascading Effects**: During epoch transitions or network stress, multiple validators experiencing this could amplify delays

This does not directly cause fund loss or consensus safety violations, but represents a significant protocol bug that can degrade network performance and validator operations. It aligns with the Aptos bug bounty **Medium Severity** category: "Limited Protocol Violations" and "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Medium Likelihood** - Multiple real code paths enable this:

1. **Consensus Observer Handoffs**: Code spawns independent tokio tasks for sync_for_duration and sync_to_target, which can execute concurrently
2. **Epoch Transitions**: Epoch changes trigger sync_to_target calls that may overlap with ongoing syncs
3. **Block Storage Fast-Forward**: Fast-forward sync operations can issue new requests during active syncs
4. **Network Partition Recovery**: Validators catching up after partitions may receive rapid sync target updates

The vulnerability requires overlapping sync requests, which is not the common case but occurs during network stress, state transitions, and consensus observer operations.

## Recommendation

Before initializing a new sync request, check if an active request exists and respond to it with an error before replacing:

```rust
pub async fn initialize_sync_duration_request(
    &mut self,
    sync_duration_notification: ConsensusSyncDurationNotification,
) -> Result<(), Error> {
    // Check if there's an existing active request
    if let Some(existing_request) = self.consensus_sync_request.lock().take() {
        // Respond to the existing request with an error before replacing
        match existing_request {
            ConsensusSyncRequest::SyncDuration(_, old_notification) => {
                self.respond_to_sync_duration_notification(
                    old_notification,
                    Err(Error::UnexpectedError("Sync request superseded by new request".to_string())),
                    None,
                )?;
            },
            ConsensusSyncRequest::SyncTarget(old_notification) => {
                self.respond_to_sync_target_notification(
                    old_notification,
                    Err(Error::UnexpectedError("Sync request superseded by new request".to_string())),
                )?;
            },
        }
    }
    
    // Now initialize the new request
    let start_time = self.time_service.now();
    let consensus_sync_request =
        ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
    *self.consensus_sync_request.lock() = Some(consensus_sync_request);
    
    Ok(())
}
```

Apply the same pattern to `initialize_sync_target_request`. This ensures all callbacks receive responses while still allowing request superseding when needed.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Consensus observer enters fallback mode, spawning a sync_for_duration task
2. Before fallback completes, a commit decision arrives for a non-epoch-changing block
3. Observer spawns sync_to_commit task (check at line 507 only prevents epoch-changing commits)
4. Driver receives sync_to_target notification, creates new Arc, replacing fallback Arc
5. Fallback task's callback is dropped
6. Fallback task's receiver returns RecvError → UnexpectedErrorEncountered

This scenario occurs naturally during network stress when the observer falls behind and then receives commit decisions before fallback sync completes.

## Notes

The core issue is architectural: the code replaces the entire Arc container instead of updating its contents. The `get_sync_request()` method returns clones of the Arc [15](#0-14)  but these are only used temporarily in functions like `check_sync_request_progress()` [16](#0-15)  and don't prevent the Arc from being dropped when replaced.

### Citations

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L235-238)
```rust
    /// Returns true iff there is a sync request currently blocking consensus
    pub fn active_sync_request(&self) -> bool {
        self.consensus_sync_request.lock().is_some()
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L241-243)
```rust
    pub fn get_sync_request(&self) -> Arc<Mutex<Option<ConsensusSyncRequest>>> {
        self.consensus_sync_request.clone()
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L254-256)
```rust
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_duration(start_time, sync_duration_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L313-315)
```rust
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L174-177)
```rust
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L202-205)
```rust
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync to target failure: {:?}",
                error
            ))),
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L361-365)
```rust
#[derive(Debug)]
pub struct ConsensusSyncDurationNotification {
    duration: Duration,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L382-386)
```rust
#[derive(Debug)]
pub struct ConsensusSyncTargetNotification {
    target: LedgerInfoWithSignatures,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L401-404)
```rust
        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_duration_request(sync_duration_notification)
            .await
```

**File:** state-sync/state-sync-driver/src/driver.rs (L434-441)
```rust
        // Initialize a new sync request
        self.consensus_notification_handler
            .initialize_sync_target_request(
                sync_target_notification,
                latest_pre_committed_version,
                latest_synced_ledger_info,
            )
            .await
```

**File:** state-sync/state-sync-driver/src/driver.rs (L538-539)
```rust
        let consensus_sync_request = self.consensus_notification_handler.get_sync_request();
        match consensus_sync_request.lock().as_ref() {
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L134-152)
```rust
        // Spawn a task to sync for the fallback
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing for the fallback
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );

                // Get the fallback duration
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L207-221)
```rust
        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L507-516)
```rust
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }
```

**File:** consensus/src/epoch_manager.rs (L558-565)
```rust
        self.execution_client
            .sync_to_target(ledger_info.clone())
            .await
            .context(format!(
                "[EpochManager] State sync to new epoch {}",
                ledger_info
            ))
            .expect("Failed to sync to new epoch");
```

**File:** consensus/src/block_storage/sync_manager.rs (L512-514)
```rust
        execution_client
            .sync_to_target(highest_commit_cert.ledger_info().clone())
            .await?;
```
