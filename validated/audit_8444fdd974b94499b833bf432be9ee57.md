# Audit Report

## Title
Integer Underflow in Aggregator Delta History Validation with max_value=0

## Summary
An attacker can create an aggregator with `max_value=0`, trigger overflow history recording, and cause unsigned integer underflow during delta history validation. This leads to validator node panics in debug builds or incorrect validation logic in release builds, violating deterministic execution guarantees.

## Finding Description

The vulnerability exists in the aggregator delta validation system. An attacker can exploit this through the following attack path:

**Step 1: Aggregator Creation with max_value=0**

The `native_create_aggregator` function accepts any `max_value` without validation, including 0. The function extracts the max_value parameter using `pop_value_by_type` which only validates the type (u64 or u128) but performs no bounds checking on the value itself. [1](#0-0) 

**Step 2: Delta Creation Without Validation**

`DeltaWithMax::new()` creates delta operations without validating the max_value parameter, simply storing whatever value is provided. [2](#0-1) 

**Step 3: Overflow History Recording**

When `try_add(1)` is called on an aggregator with max_value=0 and base_value=0, the `BoundedMath::unsigned_add` check detects overflow (since 0 + 1 > 0). The overflow is then recorded in the delta history by calling `history.record_overflow`, which populates `min_overflow_positive_delta` with the value 1. [3](#0-2) 

The `BoundedMath::unsigned_add` check that triggers the overflow: [4](#0-3) 

**Step 4: Unsigned Integer Underflow During Validation**

The critical bug occurs in `validate_against_base_value`. When validating that an overflow should have occurred, the code performs an unchecked subtraction on line 175: `max_value - min_overflow_positive_delta`. [5](#0-4) 

When `max_value = 0` and `min_overflow_positive_delta = Some(1)`, the expression `0 - 1` causes unsigned integer underflow:
- **In debug builds**: Rust panics with an overflow check failure, crashing the validator node
- **In release builds**: The value wraps to `u128::MAX` (340282366920938463463374607431768211455), making the condition `base_value <= u128::MAX` almost always true, leading to incorrect validation that fails to detect the expected overflow

This validation function is called during transaction execution to ensure delta history consistency: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the Aptos bug bounty criteria:

1. **Validator Node Crashes (High Severity)**: Validators running in debug mode will panic when processing transactions with this exploit, causing immediate node crashes. This represents a denial-of-service attack vector against the validator network.

2. **Deterministic Execution Violation**: The behavior differs fundamentally between debug and release builds, violating the critical blockchain invariant that "all validators must produce identical state roots for identical blocks." Validators running debug builds crash while release builds continue with incorrect validation logic, creating potential for consensus divergence.

3. **State Inconsistencies**: In release builds, the wrapped `u128::MAX` value causes the validation logic to incorrectly pass, potentially allowing invalid state transitions that should have been rejected. This breaks the "State Consistency" invariant of the aggregator system.

4. **Consensus Safety Impact**: The ability to cause non-deterministic behavior across the validator set based on their build configuration undermines consensus safety guarantees and could lead to chain splits if validators disagree on transaction validity.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Zero Barrier to Entry**: Any transaction sender can create an aggregator with `max_value=0` through a simple Move transaction - no special privileges, stake, or permissions required.

2. **Trivial Attack Vector**: The attack requires only two operations that any user can perform: (1) `create_aggregator(0)`, (2) `try_add(aggregator, 1)`. Both are normal API operations.

3. **Automatic Trigger**: The validation failure occurs automatically during normal transaction processing when delta histories are validated at commit time. The attacker does not need to time the attack or coordinate with block production.

4. **No Detection Mechanism**: There are no input validation checks to prevent `max_value=0` at any layer - not in the native function, not in the Move level, and not in the delta creation logic.

5. **Production Impact**: If any production validator runs in debug mode or has overflow checks enabled in their build, they will crash immediately upon encountering this transaction, causing network disruption.

## Recommendation

Add validation to reject `max_value=0` in the `native_create_aggregator` function:

```rust
fn native_create_aggregator(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);
    debug_assert_eq!(ty_args.len(), 1);
    context.charge(AGGREGATOR_V2_CREATE_AGGREGATOR_BASE)?;

    let max_value = pop_value_by_type(&ty_args[0], &mut args, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    
    // Add validation to reject max_value=0
    if max_value == 0 {
        return Err(SafeNativeError::Abort {
            abort_code: EINVALID_AGGREGATOR_MAX_VALUE, // New error code
        });
    }
    
    create_aggregator_with_max_value(context, &ty_args[0], max_value)
}
```

Alternatively, use checked subtraction in `validate_against_base_value`:

```rust
if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
    if let Some(threshold) = max_value.checked_sub(min_overflow_positive_delta) {
        if base_value <= threshold {
            return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(min_overflow_positive_delta),
                reason: DeltaApplicationFailureReason::ExpectedOverflow,
            });
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_aggregator_max_value_zero_underflow() {
    use aptos_aggregator::delta_math::DeltaHistory;
    
    // Create history with overflow recorded for delta of 1
    let mut history = DeltaHistory::new();
    history.record_overflow(1);
    
    // This will cause integer underflow: 0 - 1
    // In debug: panic
    // In release: wraps to u128::MAX
    let result = history.validate_against_base_value(0, 0);
    
    // In release builds, this will incorrectly validate
    // because base_value (0) <= u128::MAX is always true
    // Expected: Should return ExpectedOverflow error
    assert!(result.is_err());
}
```

## Notes

This vulnerability affects the core aggregator validation system and has clear security implications. The unsigned integer underflow at line 175 of `delta_math.rs` is a textbook example of an arithmetic safety bug that manifests differently in debug versus release builds, creating a consensus risk for the Aptos blockchain.

The fix should be implemented at the earliest point in the call chain (aggregator creation) to prevent invalid aggregators from being created in the first place. This is preferable to defensive checks in the validation logic, as it follows the principle of failing fast and provides clearer error messages to users.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L138-149)
```rust
fn native_create_aggregator(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert_eq!(args.len(), 1);
    debug_assert_eq!(ty_args.len(), 1);
    context.charge(AGGREGATOR_V2_CREATE_AGGREGATOR_BASE)?;

    let max_value = pop_value_by_type(&ty_args[0], &mut args, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    create_aggregator_with_max_value(context, &ty_args[0], max_value)
}
```

**File:** aptos-move/aptos-aggregator/src/delta_change_set.rs (L23-27)
```rust
impl DeltaWithMax {
    /// Creates a new delta op.
    pub fn new(update: SignedU128, max_value: u128) -> Self {
        Self { max_value, update }
    }
```

**File:** aptos-move/block-executor/src/view.rs (L350-380)
```rust
fn compute_delayed_field_try_add_delta_outcome_first_time(
    delta: &SignedU128,
    max_value: u128,
    base_aggregator_value: u128,
) -> Result<(bool, DelayedFieldRead), PanicOr<DelayedFieldsSpeculativeError>> {
    let math = BoundedMath::new(max_value);
    let mut history = DeltaHistory::new();
    let result = if math
        .unsigned_add_delta(base_aggregator_value, delta)
        .is_err()
    {
        match delta {
            SignedU128::Positive(delta_value) => {
                history.record_overflow(*delta_value);
            },
            SignedU128::Negative(delta_value) => {
                history.record_underflow(*delta_value);
            },
        };
        false
    } else {
        history.record_success(*delta);
        true
    };

    Ok((result, DelayedFieldRead::HistoryBounded {
        restriction: history,
        max_value,
        inner_aggregator_value: base_aggregator_value,
    }))
}
```

**File:** aptos-move/aptos-aggregator/src/bounded_math.rs (L50-56)
```rust
    pub fn unsigned_add(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if self.max_value < base || value > (self.max_value - base) {
            Err(BoundedMathError::Overflow)
        } else {
            Ok(base + value)
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L174-183)
```rust
        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1164-1176)
```rust
                    DelayedFieldRead::HistoryBounded {
                        restriction,
                        max_value,
                        ..
                    } => match restriction.validate_against_base_value(
                        current_value.into_aggregator_value()?,
                        *max_value,
                    ) {
                        Ok(_) => {},
                        Err(_) => {
                            return Ok(false);
                        },
                    },
```
