# Audit Report

## Title
Consensus Observer Denial-of-Service via Unverified Payload Blocking Attack

## Summary
A critical logic flaw in the consensus observer's payload deduplication mechanism allows malicious peers to block legitimate block payloads by preemptively sending unverified payloads for future epochs. The `existing_payload_entry()` function does not distinguish between verified and unverified payloads, causing legitimate verified payloads to be permanently dropped when an attacker's unverified payload already occupies the slot, resulting in consensus observer synchronization failure.

## Finding Description

The vulnerability stems from three interconnected design flaws in the consensus observer's payload management system:

**Flaw 1: Indiscriminate Payload Existence Check**

The `existing_payload_entry()` function only checks if a payload exists for a given epoch and round, without considering verification status: [1](#0-0) 

This returns `true` for both `AvailableAndVerified` and `AvailableAndUnverified` payloads.

**Flaw 2: Early Return Prevents Payload Replacement**

When a block payload message arrives, the observer checks for existing payloads and drops new payloads if any entry exists: [2](#0-1) 

The code returns before calling `insert_block_payload()`, preventing verified payloads from replacing unverified ones.

**Flaw 3: Future Epoch Payloads Stored Unverified**

Payloads for future epochs (where `block_epoch != epoch_state.epoch`) skip signature verification and are stored as unverified: [3](#0-2) 

**Attack Execution Path:**

1. **Attacker sends malicious payload**: While the network is at epoch E, attacker sends a `BlockPayload` message for epoch E+1, round R with crafted (but digest-valid) content
2. **Unverified storage**: Since `block_epoch (E+1) != epoch_state.epoch (E)`, signature verification is skipped and the payload is stored as `AvailableAndUnverified`
3. **Legitimate payload blocked**: When the legitimate verified payload for the same (E+1, R) arrives later from honest validators, `existing_payload_entry()` returns true and the legitimate payload is dropped before reaching `insert_block_payload()`
4. **Epoch transition verification fails**: During epoch transition, `verify_payload_signatures()` is called. The attacker's payload has invalid signatures and is removed, but the legitimate payload was already dropped and cannot be recovered: [4](#0-3) 

5. **Ordered block rejection**: When the ordered block for (E+1, R) arrives, `verify_payloads_against_ordered_block()` finds the payload missing and returns an error: [5](#0-4) 

6. **Synchronization failure**: The ordered block is rejected, preventing the consensus observer from syncing: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program's "Limited Protocol Violations" category:

1. **State inconsistencies requiring manual intervention**: Consensus observers become unable to sync with the network and require operator intervention (restart/reconfiguration) to restore functionality

2. **Availability impact on observer infrastructure**: While not affecting validator consensus directly, this prevents observer nodes from executing blocks and serving blockchain data to applications, indexers, and full nodes

3. **Limited scope**: Only affects consensus observer nodes, not the core consensus protocol, validator operations, or fund security

4. **No fund loss**: Does not directly lead to theft, minting, or freezing of funds

The impact is significant for the Aptos ecosystem as consensus observers are critical infrastructure for applications and services that depend on real-time blockchain data without running full validator nodes.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The attack has high feasibility due to:

1. **Minimal attacker requirements**: Any node can connect as a network peer and send `BlockPayload` messages through the P2P protocolâ€”no validator privileges, stake, or significant computational resources required

2. **Simple execution**: Attacker only needs to monitor epoch transitions and send malformed payloads for upcoming epoch/round combinations before legitimate payloads arrive

3. **Persistent and amplified effect**: A single malicious payload permanently blocks the legitimate payload for that (epoch, round) slot. Attacker can target multiple future rounds simultaneously to maximize disruption

4. **Wide attack surface**: Attacker can preemptively poison many (epoch, round) combinations across epoch boundaries

5. **Difficult detection**: Malicious payloads pass digest verification and appear valid in network traffic until signature verification during epoch transition, making them indistinguishable from legitimate network timing variations

6. **No rate limiting or peer reputation visible**: The code reviewed shows no peer reputation system or rate limiting that would prevent this attack

## Recommendation

Implement a verification-aware payload replacement mechanism:

**Option 1: Prioritize Verified Payloads**
```rust
pub fn existing_payload_entry(&self, block_payload: &BlockPayload) -> bool {
    let epoch_and_round = (block_payload.epoch(), block_payload.round());
    match self.block_payloads.lock().get(&epoch_and_round) {
        Some(BlockPayloadStatus::AvailableAndVerified(_)) => true,
        Some(BlockPayloadStatus::AvailableAndUnverified(_)) => false, // Allow replacement
        None => false,
    }
}
```

**Option 2: Allow Verified to Replace Unverified**
Modify `process_block_payload_message()` to check verification status:
```rust
let should_process = match self.observer_block_data.lock().get_payload_status(&block_payload) {
    Some(BlockPayloadStatus::AvailableAndVerified(_)) => false, // Don't replace verified
    Some(BlockPayloadStatus::AvailableAndUnverified(_)) if verified_payload => true, // Replace with verified
    Some(BlockPayloadStatus::AvailableAndUnverified(_)) => false, // Don't replace unverified with unverified
    None => true, // New payload
};
```

**Option 3: Restrict Future Epoch Payloads**
Only accept payloads for the current epoch or the immediate next epoch:
```rust
if block_epoch > epoch_state.epoch + 1 {
    // Reject payloads too far in the future
    return;
}
```

## Proof of Concept

```rust
#[test]
fn test_unverified_payload_blocks_verified() {
    // Setup consensus observer with epoch E=0
    let mut observer = create_test_observer(0);
    
    // Attacker sends unverified payload for future epoch E=1, round=100
    let malicious_payload = create_payload_with_invalid_signatures(1, 100);
    observer.process_block_payload_message(
        attacker_peer_id,
        Instant::now(),
        malicious_payload.clone()
    ).await;
    
    // Verify unverified payload was stored
    assert!(observer.observer_block_data.lock()
        .existing_payload_entry(&malicious_payload));
    
    // Legitimate verified payload arrives for same epoch/round
    let legitimate_payload = create_valid_verified_payload(1, 100);
    observer.process_block_payload_message(
        validator_peer_id,
        Instant::now(),
        legitimate_payload.clone()
    ).await;
    
    // Legitimate payload was dropped - malicious one still exists
    assert!(observer.observer_block_data.lock()
        .existing_payload_entry(&malicious_payload));
    
    // Transition to epoch 1
    observer.wait_for_epoch_start().await;
    
    // Malicious payload removed during verification
    assert!(!observer.observer_block_data.lock()
        .existing_payload_entry(&malicious_payload));
    
    // When ordered block arrives, verification fails (payload missing)
    let ordered_block = create_ordered_block(1, 100);
    let result = observer.observer_block_data.lock()
        .verify_payloads_against_ordered_block(&ordered_block);
    
    // Ordered block rejected - observer cannot sync
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::InvalidMessageError(_)));
}
```

## Notes

This vulnerability represents a genuine application-level logic flaw in the consensus observer's payload deduplication mechanism, distinct from network-level DoS attacks. The attack exploits the timing window between epochs and the lack of verification-status awareness in the payload existence check. While the scope is limited to consensus observer nodes (not affecting validators or core consensus), the impact is significant for Aptos ecosystem infrastructure that depends on observers for blockchain data access.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L64-71)
```rust
    /// Returns true iff we already have a payload entry for the given block
    pub fn existing_payload_entry(&self, block_payload: &BlockPayload) -> bool {
        // Get the epoch and round of the payload
        let epoch_and_round = (block_payload.epoch(), block_payload.round());

        // Check if a payload already exists in the store
        self.block_payloads.lock().contains_key(&epoch_and_round)
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L176-183)
```rust
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L234-256)
```rust
            if epoch == current_epoch {
                if let Entry::Occupied(mut entry) = self.block_payloads.lock().entry((epoch, round))
                {
                    if let BlockPayloadStatus::AvailableAndUnverified(block_payload) =
                        entry.get_mut()
                    {
                        if let Err(error) = block_payload.verify_payload_signatures(epoch_state) {
                            // Log the verification failure
                            error!(
                                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                                    "Failed to verify the block payload signatures for epoch: {:?} and round: {:?}. Error: {:?}",
                                    epoch, round, error
                                ))
                            );

                            // Remove the block payload from the store
                            entry.remove();
                        } else {
                            // Save the block payload for reinsertion
                            verified_payloads_to_update.push(block_payload.clone());
                        }
                    }
                }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L366-380)
```rust
        // Determine if the payload is behind the last ordered block, or if it already exists
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-430)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };

        // Update the latency metrics for block payload processing
        update_message_processing_latency_metrics(
            message_received_time,
            &peer_network_id,
            metrics::BLOCK_PAYLOAD_LABEL,
        );

        // Update the payload store with the payload
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```
