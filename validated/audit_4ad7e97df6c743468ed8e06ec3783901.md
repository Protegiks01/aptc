# Audit Report

## Title
Message-Agnostic Signature Verification Status Allows Invalid Commit Votes to Bypass Cryptographic Verification

## Summary
The `SignatureWithStatus` structure uses an `Arc<AtomicBool>` to track verification status without binding it to the specific message being verified. When `CommitVotes` are added to a `SignatureAggregator` after the Executed stage, only `BlockInfo` equality is checked rather than full `LedgerInfo` equality. This allows a malicious validator to create a `CommitVote` with matching `BlockInfo` but different `consensus_data_hash`, have it verified against their chosen message, then inject it into an aggregator expecting a different message. The stale verification status causes `filter_invalid_signatures` to skip cryptographic verification, allowing invalid signatures to persist and contribute to quorum calculations.

## Finding Description

This vulnerability stems from three interconnected design flaws in the consensus pipeline's signature verification mechanism:

**Issue 1: Message-Agnostic Verification Status**

The `SignatureWithStatus` struct stores verification status as a simple boolean flag that doesn't track which message was verified against: [1](#0-0) 

Once `verification_status` is set to `true` via `set_verified()`, it remains trusted regardless of the message context. The status is excluded from equality comparisons and persists across different verification contexts.

**Issue 2: Incomplete Validation in add_signature_if_matched**

When commit votes are added to buffer items in Executed or Signed states, only `BlockInfo` equality is checked, not the full `LedgerInfo`: [2](#0-1) 

However, a `LedgerInfo` contains both `commit_info` and `consensus_data_hash`: [3](#0-2) 

Two different `LedgerInfo` instances can have identical `commit_info` but different `consensus_data_hash` values, yet signatures are cryptographically bound to the entire `LedgerInfo` structure.

**Issue 3: Verification Status Short-Circuit in Filtering**

When `filter_invalid_signatures` processes signatures, it checks `is_verified()` first and skips cryptographic verification via short-circuit evaluation: [4](#0-3) 

The short-circuit OR at lines 298-301 means if `signature.is_verified()` returns true, the `verify()` call is never executed, regardless of whether the signature is valid for the current message being verified.

**Attack Execution Path:**

1. Honest node A has a buffer item in Executed state with `LedgerInfo(commit_info: B, consensus_data_hash: H_honest)`

2. Malicious validator M creates a `CommitVote` with `LedgerInfo(commit_info: B, consensus_data_hash: H_malicious)` where `H_malicious â‰  H_honest`

3. M properly signs their vote, creating a valid BLS signature for their malicious `LedgerInfo`

4. The vote undergoes verification in the buffer manager's verification task: [5](#0-4) 

5. The verification calls `CommitVote::verify()` which verifies the signature against the vote's own `self.ledger_info` (M's malicious LedgerInfo): [6](#0-5) 

6. If pessimistic verification is triggered (when `optimistic_sig_verification` is disabled or the validator is in `pessimistic_verify_set`), the signature is cryptographically verified against M's malicious LedgerInfo and `verification_status` is set to `true`: [7](#0-6) 

7. The vote passes the `BlockInfo` equality check in `add_signature_if_matched` and is added to the aggregator expecting the honest LedgerInfo

8. When `aggregate_and_verify` is called and the aggregated signature fails (because it includes M's signature for a different message), `filter_invalid_signatures` is invoked: [8](#0-7) 

9. During filtering at line 512, M's signature bypasses verification because `is_verified()` returns `true` from step 6, even though it's being verified against a different message (the honest LedgerInfo)

10. After filtering, `try_aggregate` is called again at line 532 but crucially **does not verify** the resulting aggregated signature before returning it as successful

11. The caller receives an invalid aggregated signature but believes it to be valid, creating an invalid `LedgerInfoWithSignatures` that is then sent to the persisting phase: [9](#0-8) 

## Impact Explanation

**High to Critical Severity** - This vulnerability enables consensus integrity violations:

1. **Invalid Quorum Certificate Formation**: The vulnerability allows creation of `LedgerInfoWithSignatures` containing cryptographically invalid aggregated signatures that honest nodes incorrectly believe are valid. While these invalid QCs will be rejected by other validators upon verification, the local node may attempt to commit based on this invalid proof.

2. **Consensus Progress Disruption**: Nodes can become stuck with invalid commit proofs that fail verification, preventing legitimate consensus progress. This affects liveness rather than safety, but can impact network availability.

3. **Voting Power Manipulation**: Invalid signatures contribute to voting power calculations in `check_voting_power` before aggregation, potentially allowing a malicious validator to artificially inflate perceived quorum support.

4. **State Synchronization Issues**: Invalid commit proofs may be propagated to consensus observers and state sync mechanisms, causing inconsistencies in network state propagation.

The severity depends on whether downstream components properly verify the commit proof before finalizing commits. The attack requires either globally disabled optimistic verification or the attacker being in the `pessimistic_verify_set`, which limits but does not eliminate exploitability.

## Likelihood Explanation

**Medium Likelihood** with specific preconditions:

1. **Triggering Conditions**: The attack requires pessimistic signature verification to be active for the malicious validator, which occurs when:
   - Optimistic verification is disabled globally (non-default configuration), OR
   - The validator is in the `pessimistic_verify_set` (added after submitting invalid signatures)

2. **Attack Simplicity**: Once preconditions are met, any validator can craft malicious `CommitVotes` with matching `BlockInfo` but arbitrary `consensus_data_hash` values

3. **No Collusion Required**: A single malicious validator can exploit this vulnerability without coordinating with other validators

4. **Deterministic Exploitation**: This is a logical flaw rather than a race condition, making it reliably exploitable whenever the preconditions are satisfied

## Recommendation

Implement message-binding for verification status to ensure signatures verified for one message cannot be reused for different messages:

1. **Option 1 - Message Hash Binding**: Modify `SignatureWithStatus` to store the hash of the message it was verified against, and check this hash before trusting the verification status

2. **Option 2 - Full LedgerInfo Validation**: In `add_signature_if_matched`, validate the complete `LedgerInfo` equality rather than just `BlockInfo`:
   ```rust
   if executed.partial_commit_proof.data() == vote.ledger_info() {
       executed.partial_commit_proof.add_signature(author, signature);
       return Ok(());
   }
   ```

3. **Option 3 - Always Verify During Filtering**: Remove the short-circuit in `filter_invalid_signatures` to always perform cryptographic verification, or clear verification status before filtering

4. **Option 4 - Verify After Filtering**: Add verification of the aggregated signature after `filter_invalid_signatures` returns, before returning from `aggregate_and_verify`

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring a test network with pessimistic verification enabled or triggered
2. Creating two `LedgerInfo` instances with identical `BlockInfo` but different `consensus_data_hash` values  
3. Having a malicious validator sign a `CommitVote` for the malicious `LedgerInfo`
4. Sending this vote to an honest node expecting the correct `LedgerInfo`
5. Observing that the signature passes through `filter_invalid_signatures` despite being invalid for the expected message
6. Verifying that the resulting aggregated signature is cryptographically invalid but accepted by the local node

A full proof of concept would require instrumenting the consensus layer to observe the verification status propagation and demonstrate the invalid signature persisting through the filtering phase.

## Notes

This vulnerability represents a subtle but significant flaw in the optimistic signature verification design. The core issue is the separation between verification status tracking and message context. While the immediate impact may be limited to consensus liveness issues rather than full safety violations (since invalid QCs will eventually be rejected), the ability to bypass cryptographic verification represents a fundamental violation of security invariants.

The vulnerability is most concerning when combined with other potential issues in the commit finalization path. The effectiveness of this attack depends critically on whether downstream components (execution, storage) properly verify commit proofs before finalizing state changes.

### Citations

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L384-392)
```rust
#[derive(Clone, Debug, Derivative)]
#[derivative(PartialEq, Eq)]
pub struct SignatureWithStatus {
    signature: bls12381::Signature,
    #[derivative(PartialEq = "ignore")]
    // false if the signature not verified.
    // true if the signature is verified.
    verification_status: Arc<AtomicBool>,
}
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L523-529)
```rust
                self.persisting_phase_tx
                    .send(self.create_new_request(PersistingRequest {
                        blocks: blocks_to_persist,
                        commit_ledger_info: aggregated_item.commit_proof,
                    }))
                    .await
                    .expect("Failed to send persist request");
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-933)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```
