# Audit Report

## Title
ECDSA Signature Malleability in ethereum_derivable_account Due to Missing Low-S Canonicalization

## Summary
The native `ecdsa_recover()` function used by `ethereum_derivable_account` does not enforce low-s canonicalization, allowing secp256k1 ECDSA signature malleability. This creates transaction hash ambiguity where the same logical transaction can exist with multiple valid signatures, violating protocol consistency guarantees.

## Finding Description

**The Core Issue:**

The `native_ecdsa_recover()` function uses `libsecp256k1::Signature::parse_standard_slice()` to parse signatures without checking for high-s values. [1](#0-0)  In contrast, regular secp256k1 transaction authentication properly enforces low-s canonicalization by checking `if self.0.s.is_high()` and rejecting such signatures. [2](#0-1) 

The `aptos-crypto` implementation correctly rejects high-s signatures in its `verify()` method, but this protection is bypassed when using the native `ecdsa_recover` function through abstract authenticators.

**Attack Mechanism:**

ECDSA signatures have an inherent malleability property: for any valid signature `(r, s)`, there exists a mathematically equivalent signature `(r, n-s)` where `n` is the curve order. Both signatures are cryptographically valid for the same message and recover to the same public key (with adjusted recovery_id).

When a transaction using `ethereum_derivable_account` authentication is submitted:

1. The authentication flow calls `ecdsa_recover()` via Move, specifically in the `recover_public_key()` function. [3](#0-2) 

2. This invokes the native function which accepts both high-s and low-s signatures through `libsecp256k1::recover()`. [4](#0-3) 

3. An attacker observing the transaction can create a malleable variant with the same `RawTransaction` but different signature.

4. Both transactions pass validation but have different transaction hashes since the signature is part of the authenticator. The `AccountAuthenticator::verify()` for abstract authentication only validates the signing message digest, not the signature canonicalization. [5](#0-4) 

**Consensus Impact:**

The consensus deduplication logic uses `(committed_hash, authenticator)` pairs to filter duplicates. [6](#0-5)  The `committed_hash()` method includes the entire `SignedTransaction` (including the authenticator) in the hash calculation. [7](#0-6) 

Since malleable signatures produce different hashes AND different authenticators, they are NOT deduplicated at the consensus level. [8](#0-7)  This means:

- Different validators may see different malleable versions first
- Different validators may propose blocks containing different versions
- Transaction hash becomes non-deterministic for the same logical operation
- Off-chain indexers and APIs may track the same execution under multiple transaction IDs

## Impact Explanation

**Severity: Medium**

This qualifies as **"Limited Protocol Violations"** per Aptos bug bounty criteria:

1. **Protocol Inconsistency**: Creates a discrepancy between regular secp256k1 authentication (which enforces low-s canonicalization) and abstract authentication via `ethereum_derivable_account` (which doesn't). This violates the implicit protocol guarantee that transaction hash uniquely identifies a transaction.

2. **Transaction Hash Ambiguity**: The same logical transaction can exist with multiple valid hashes, breaking assumptions that transaction hash uniquely identifies a transaction execution.

3. **Operational Impact**: 
   - Off-chain indexers may record duplicate executions under different hashes
   - Transaction status tracking becomes ambiguous
   - Mempool implementations across validators may hold different versions
   - Block proposals may include different versions, wasting consensus bandwidth and validator resources

4. **Not Critical Because**:
   - Sequence numbers prevent actual double-execution [9](#0-8) 
   - Consensus safety is not broken (validators still agree on state)
   - No direct funds loss or theft vector
   - Network remains available

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Any attacker can observe ethereum_derivable_account transactions in the mempool and create malleable versions by simply flipping `s` to `n-s` and adjusting the recovery_id.

2. **No Special Privileges Required**: Does not require validator access or special permissions.

3. **Ethereum Derivable Accounts in Use**: The `ethereum_derivable_account` module is actively deployed and used for SIWE (Sign In With Ethereum) authentication, supporting multiple wallets including Metamask, Phantom, Coinbase, OKX, Exodus, and Backpack. [10](#0-9) 

4. **Network Propagation**: Malleable variants would naturally propagate through the P2P network to different validators.

## Recommendation

Implement low-s canonicalization check in the `native_ecdsa_recover()` function to match the behavior of the `aptos-crypto` implementation. Add validation after parsing the signature:

```rust
let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
    Ok(sig) => {
        // Enforce low-s canonicalization to prevent malleability
        if sig.s.is_high() {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        }
        sig
    },
    Err(_) => {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_DESERIALIZE,
        });
    },
};
```

This ensures consistency across all secp256k1 authentication methods in Aptos.

## Proof of Concept

A proof of concept would demonstrate:
1. Creating a transaction using `ethereum_derivable_account` authentication
2. Computing the malleable signature variant `(r, n-s, v')`
3. Submitting both transactions to different validators
4. Observing that both pass validation but have different transaction hashes
5. Confirming that only one executes (due to sequence number) but both occupy mempool/consensus resources

The test would leverage the existing `test_ethereum_derivable_account` infrastructure in the smoke tests to create and submit malleable transaction variants.

## Notes

This vulnerability represents a protocol-level inconsistency where different authentication paths have different guarantees regarding signature canonicalization. While it doesn't directly compromise funds or consensus safety (due to sequence number protection), it violates the assumption that transaction hashes uniquely identify logical operations and creates operational complexity for validators and off-chain infrastructure. The issue is analogous to Bitcoin's pre-BIP146 transaction malleability, though with more limited scope due to its restriction to abstract authentication paths.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L65-72)
```rust
    let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
        Ok(sig) => sig,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        },
    };
```

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L77-83)
```rust
    match libsecp256k1::recover(&msg, &sig, &rid) {
        Ok(pk) => Ok(smallvec![
            Value::vector_u8(pk.serialize()[1..].to_vec()),
            Value::bool(true)
        ]),
        Err(_) => Ok(smallvec![Value::vector_u8([0u8; 0]), Value::bool(false)]),
    }
```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L209-223)
```rust
    fn verify(
        &self,
        message: &libsecp256k1::Message,
        public_key: &libsecp256k1::PublicKey,
    ) -> Result<()> {
        // Prevent malleability attacks, low order only. The library only signs in low
        // order, so this was done intentionally.
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
        } else if libsecp256k1::verify(message, &self.0, public_key) {
            Ok(())
        } else {
            Err(anyhow!("Unable to verify signature."))
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L1-25)
```text
/// Derivable account abstraction that verifies a message signed by
/// SIWE.
/// 1. The message format is as follows:
///
/// <domain> wants you to sign in with your Ethereum account:
/// <ethereum_address>
///
/// Please confirm you explicitly initiated this request from <domain>. You are approving to execute transaction <entry_function_name> on Aptos blockchain (<network_name>).
///
/// URI: <scheme>://<domain>
/// Version: 1
/// Chain ID: <chain_id>
/// Nonce: <digest>
/// Issued At: <issued_at>
///
/// 2. The abstract public key is a BCS serialized `SIWEAbstractPublicKey`.
/// 3. The abstract signature is a BCS serialized `SIWEAbstractSignature`.
/// 4. This module has been tested for the following wallets:
/// - Metamask
/// - Phantom
/// - Coinbase
/// - OKX
/// - Exodus
/// - Backpack

```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L152-176)
```text
    fun recover_public_key(signature_bytes: &vector<u8>, message: &vector<u8>): vector<u8> {
        let rs = signature_bytes.slice(0, 64);
        let v = signature_bytes[64];
        assert!(v == 27 || v == 28, EUNEXPECTED_V);
        let signature = secp256k1::ecdsa_signature_from_bytes(rs);

        let maybe_recovered = secp256k1::ecdsa_recover(*message, v - 27, &signature);

        assert!(
            maybe_recovered.is_some(),
            EINVALID_SIGNATURE
        );

        let pubkey = maybe_recovered.borrow();

        let pubkey_bytes = secp256k1::ecdsa_raw_public_key_to_bytes(pubkey);

        // Add 0x04 prefix to the public key, to match the
        // full uncompressed format from ethers.js
        let full_pubkey = &mut vector[];
        full_pubkey.push_back(4u8);
        full_pubkey.append(pubkey_bytes);

        *full_pubkey
    }
```

**File:** types/src/transaction/authenticator.rs (L779-790)
```rust
            Self::Abstract { authenticator } => {
                let original_signing_message = signing_message(message)?;
                ensure!(
                    authenticator.signing_message_digest()
                        == &AASigningData::signing_message_digest(
                            original_signing_message,
                            authenticator.function_info().clone()
                        )?,
                    "The signing message digest provided in Abstract Authenticator is not expected"
                );
                Ok(())
            },
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-71)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L74-90)
```rust
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
                        num_duplicates += 1;
                        None
                    }
                },
            })
            .collect();
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L1-50)
```text
module aptos_framework::transaction_validation {
    use std::error;
    use std::features;
    use std::option;
    use std::option::Option;
    use std::signer;
    use std::vector;

    use aptos_framework::account;
    use aptos_framework::aptos_account;
    use aptos_framework::account_abstraction;
    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::chain_id;
    use aptos_framework::coin;
    use aptos_framework::create_signer;
    use aptos_framework::permissioned_signer;
    use aptos_framework::system_addresses;
    use aptos_framework::timestamp;
    use aptos_framework::transaction_fee;
    use aptos_framework::nonce_validation;

    friend aptos_framework::genesis;

    // We will advertise to the community that max expiration time for orderless txns is 60 seconds.
    // Adding a 40 second slack here as the client's time and the blockchain's time may drift,
    // and to account for any fallen behind fullnodes that are performing simulation on old blockchain state.
    const MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS: u64 = 100;

    // We need to ensure that a transaction can't be replayed.
    // There are two ways to prevent replay attacks:
    // 1. Use a nonce. Orderless transactions use this.
    // 2. Use a sequence number. Regular transactions use this.
    // A replay protector of a transaction signifies which of the above methods is used.
    enum ReplayProtector {
        Nonce(u64),
        SequenceNumber(u64),
    }

    /// This holds information that will be picked up by the VM to call the
    /// correct chain-specific prologue and epilogue functions
    struct TransactionValidation has key {
        module_addr: address,
        module_name: vector<u8>,
        script_prologue_name: vector<u8>,
        // module_prologue_name is deprecated and not used.
        module_prologue_name: vector<u8>,
        multi_agent_prologue_name: vector<u8>,
        user_epilogue_name: vector<u8>,
    }

```
