Based on my comprehensive technical validation of this security claim against the Aptos Core codebase, I have verified all technical assertions and traced the complete execution path. Here is my final assessment:

# Audit Report

## Title
Consensus Safety Violation via On-Chain Config Deserialization Failure During Mixed-Version Validator Deployments

## Summary
During rolling validator upgrades, if the on-chain consensus configuration is updated to use a new `ProposerElectionType` enum variant that older validators cannot deserialize, old validators silently fall back to `LeaderReputation` proposer election while new validators use the updated algorithm, causing validators to reject each other's block proposals and breaking consensus safety.

## Finding Description

The vulnerability exists in the epoch configuration initialization flow. When validators start a new epoch, they attempt to deserialize the on-chain consensus configuration: [1](#0-0) 

If deserialization fails (e.g., when old validators encounter an unknown `ProposerElectionType` enum variant tag in BCS-encoded data), the code logs a warning but continues execution: [2](#0-1) 

The failed deserialization triggers a silent fallback to the default configuration: [3](#0-2) 

The default configuration uses `LeaderReputation` proposer election: [4](#0-3)  and [5](#0-4) 

The on-chain configuration is stored as raw BCS-encoded bytes without structural validation: [6](#0-5) 

This allows governance to submit configuration bytes encoding new enum variants: [7](#0-6) 

Different proposer election algorithms produce different valid proposers for the same round. `RoundProposer` uses HashMap lookup: [8](#0-7) 

While `LeaderReputation` uses weighted random selection based on historical performance: [9](#0-8) 

The proposer validation logic strictly rejects proposals from validators that are not the computed valid proposer: [10](#0-9) 

This rejection happens in the round manager's proposal processing: [11](#0-10) 

**Attack Scenario:**
1. Network operates with `ProposerElectionType::RoundProposer` configured on-chain
2. New binary version introduces `ProposerElectionType::RoundProposerV2` enum variant
3. Some validators upgrade, others remain on old version
4. Governance proposal updates on-chain config to use `RoundProposerV2`
5. Old validators fail BCS deserialization (unknown variant tag), fall back to `LeaderReputation`
6. New validators successfully deserialize, use `RoundProposerV2`
7. For each round, different validator groups compute different valid proposers
8. Validators reject each other's proposals as coming from invalid proposers
9. Network partition occurs - no group can achieve quorum for block commitments

## Impact Explanation

This represents a **Critical severity** consensus safety violation under the Aptos bug bounty program:

- **Consensus Safety Violation**: The fundamental invariant that all honest validators must agree on which proposals are valid is broken. Different validators deterministically compute different valid proposers for identical rounds and blockchain state.

- **Non-Recoverable Network Partition**: The network splits into incompatible factions that cannot reach consensus. This requires emergency coordination or hard fork to resolve, as the validators are following their code correctly but with incompatible configurations.

- **Total Loss of Liveness**: Neither faction can achieve the 2f+1 quorum required for block commitments, completely halting the blockchain.

- **Deterministic Execution Break**: The same blockchain state produces different behavior based solely on validator software version, violating the deterministic execution guarantee.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability has medium-high likelihood because:

1. **Common Operational Scenario**: Rolling validator upgrades are standard practice for network maintenance and feature deployment.

2. **No Version Compatibility Protection**: The codebase has no explicit checks to prevent configuration version mismatches: [12](#0-11) 

3. **Silent Failure Mode**: The deserialization failure produces only a warning log while validators continue operating with incompatible algorithms, making the issue non-obvious until consensus breaks.

4. **Legitimate Governance Action**: While requiring governance approval, configuration updates are legitimate operational procedures that could inadvertently trigger this issue during coordinated upgrades.

**Mitigating factors:**
- Requires coordination between code release and governance proposal
- Careful upgrade procedures could avoid this scenario
- However, the lack of explicit safeguards means human operational error could trigger it

## Recommendation

Implement version compatibility checks and safe degradation:

1. **Add explicit version/variant validation** in the deserialization path that rejects unknown configuration variants rather than silently falling back to defaults

2. **Implement configuration version negotiation** where validators can detect and refuse to start epochs with incompatible configurations

3. **Add governance guardrails** that prevent configuration updates unless sufficient validator stake has upgraded to support the new variant

4. **Change default behavior** to halt epoch transition on deserialization failure rather than silently using an incompatible algorithm

5. **Add configuration hash to epoch state** so validators can detect and alert on configuration mismatches

## Proof of Concept

This vulnerability can be demonstrated with the following test scenario:

1. Deploy validators running version N with `ProposerElectionType` having 4 variants
2. Update on-chain config to BCS bytes encoding variant tag 4 (new variant not in version N)
3. Version N validators deserialize, fail, log warning, fall back to default (`LeaderReputation`)
4. Deploy validators running version N+1 with 5 variants including the new one
5. Version N+1 validators successfully deserialize variant 4
6. Observe that for the same round, different validators compute different valid proposers
7. Observe that proposals are rejected with "not a valid proposer" errors
8. Network consensus halts as no group achieves quorum

The vulnerability is confirmed by the code paths verified above, demonstrating that this is a genuine protocol-level defensive coding gap that could cause critical consensus failure during legitimate operational procedures.

### Citations

**File:** consensus/src/epoch_manager.rs (L1178-1178)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
```

**File:** consensus/src/epoch_manager.rs (L1187-1189)
```rust
        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-505)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L15-17)
```text
    struct ConsensusConfig has drop, key, store {
        config: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/liveness/round_proposer_election.rs (L27-32)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        match self.proposers.get(&round) {
            None => self.default_proposer,
            Some(round_proposer) => *round_proposer,
        }
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L736-739)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.get_valid_proposer_and_voting_power_participation_ratio(round)
            .0
    }
```

**File:** consensus/src/liveness/proposer_election.rs (L14-16)
```rust
    fn is_valid_proposer(&self, author: Author, round: Round) -> bool {
        self.get_valid_proposer(round) == author
    }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```
