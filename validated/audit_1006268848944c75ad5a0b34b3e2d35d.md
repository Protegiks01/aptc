# Audit Report

## Title
Consensus Observer Pending Block Store Garbage Collection Selection Bias Enables Permanent Memory Exhaustion via Future Epoch Blocks

## Summary
The consensus observer's pending block store uses epoch-round tuple ordering for garbage collection, creating a critical bias where blocks claiming to be from future epochs are never removed. A Byzantine validator can exploit this by sending blocks with arbitrarily high epoch numbers, permanently occupying all 150 storage slots and preventing legitimate blocks from being processed.

## Finding Description

The consensus observer's pending block store maintains a BTreeMap indexed by (epoch, round) tuples for storing blocks awaiting payloads. [1](#0-0) 

When the store reaches its capacity limit (max_num_pending_blocks, defaulting to 150), garbage collection is automatically triggered after each insertion. [2](#0-1) 

The garbage collection mechanism removes blocks using `pop_first()`, which removes entries with the **smallest** (epoch, round) tuple from the BTreeMap. [3](#0-2) 

**The critical flaw exists in the validation logic before block insertion:**

When an ordered block message is received, the epoch-related validation only checks whether the block is **not older** than the last ordered block using `<=` comparison. This check only enforces a lower bound but no upper bound. [4](#0-3) 

The `verify_ordered_blocks()` function only validates block structure and chaining, not epoch bounds. It checks for non-empty blocks, last block ID matching the proof, and correct block chaining, but does not validate epoch numbers. [5](#0-4) 

**Attack Propagation Path:**

1. Byzantine validator (subscribed peer) sends ordered blocks claiming to be from epoch 999,999,999
2. Blocks pass `verify_ordered_blocks()` structural validation
3. Blocks pass `block_out_of_date` check since `(999999999, round) > (current_epoch, round)`
4. Blocks are inserted into `pending_block_store`
5. When garbage collection triggers, `pop_first()` removes blocks with the **lowest** epoch numbers
6. Legitimate blocks from current epoch get removed first because `(current_epoch, round) < (999999999, round)`
7. Attacker's future epoch blocks persist indefinitely

**Why malicious blocks never get removed:**

Epoch validation that would reject non-current-epoch blocks only occurs in `process_ordered_block()` after payloads arrive. This validation checks if the block's epoch matches the current epoch and rejects mismatches. [6](#0-5) 

However, `process_ordered_block()` is only called when all payloads exist for the pending block. Attacker blocks from future epochs never receive payloads (they don't exist), so they never reach this validation stage. [7](#0-6) 

Messages are validated to be from subscribed peers only, preventing arbitrary network participants from exploiting this vulnerability. [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables a Denial of Service attack against consensus observer nodes with the following impacts:

1. **Resource Exhaustion**: Attacker permanently occupies all 150 pending block slots with invalid future epoch blocks
2. **Consensus Observer Unavailability**: Legitimate blocks cannot be stored in the pending block store, preventing the consensus observer from functioning
3. **Degraded Validator Fullnode Performance**: Validator fullnodes (VFNs) have consensus observer enabled by default, so this attack impacts their block processing capability
4. **Network-Wide Impact**: An attacker can target multiple VFNs simultaneously with minimal resources [9](#0-8) 

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring manual intervention" - the pending block store becomes permanently polluted, requiring node restart or fallback mode entry to clear. This does not reach Critical/High severity because it does not affect actual consensus (validators continue producing blocks), does not cause fund loss, and only impacts the observer component which has fallback mechanisms.

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
- **Requires being a subscribed peer**: Attacker must be a validator or VFN that the consensus observer has subscribed to
- **Byzantine validators are realistic**: Consensus observers subscribe to validators, and Byzantine validators (up to 1/3) are expected adversaries in the threat model
- **Low complexity**: Once subscribed, attacker only needs to craft ordered blocks with valid structure but inflated epoch numbers
- **Low cost**: Attack requires minimal bandwidth - sending 150 blocks once permanently occupies the store until manual intervention
- **No cryptographic bypass needed**: Blocks don't need valid signatures until the processing stage, which never occurs for these malicious blocks

The attack is moderately likely because:
1. Consensus observer is enabled by default on validator fullnodes
2. Byzantine validators being selected for subscription is a realistic threat scenario
3. The vulnerability triggers deterministically with any future epoch value
4. No rate limiting or timeout-based expiry prevents accumulation of future-epoch blocks

## Recommendation

Implement an upper bound validation for epoch numbers before inserting blocks into the pending store. The fix should:

1. **Add epoch bound check in `process_ordered_block_message()`**: Before inserting blocks into the pending store, verify that the block's epoch is not more than 1 epoch ahead of the current epoch state:

```rust
// After line 680 in consensus_observer.rs, add:
let epoch_state = self.get_epoch_state();
let first_block_epoch = first_block.epoch();
if first_block_epoch > epoch_state.epoch + 1 {
    warn!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
        "Received ordered block from invalid future epoch! Ignoring: epoch {}, current {}",
        first_block_epoch, epoch_state.epoch
    )));
    increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
    return;
}
```

2. **Consider timeout-based expiry**: In addition to size-based garbage collection, implement time-based expiry for pending blocks to automatically clean up blocks that have been waiting too long for payloads.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_future_epoch_blocks_persist_in_pending_store() {
    // Setup consensus observer with pending block store
    let consensus_observer_config = ConsensusObserverConfig {
        max_num_pending_blocks: 150,
        ..Default::default()
    };
    let pending_block_store = Arc::new(Mutex::new(PendingBlockStore::new(
        consensus_observer_config,
    )));
    
    // Insert 150 legitimate blocks from current epoch (epoch 1)
    let current_epoch = 1;
    let legitimate_blocks = create_and_add_pending_blocks(
        pending_block_store.clone(),
        150,
        current_epoch,
        0,
        1,
    );
    
    // Verify legitimate blocks are stored
    assert_eq!(pending_block_store.lock().blocks_without_payloads.len(), 150);
    
    // Byzantine validator sends blocks claiming to be from future epoch 999999999
    let future_epoch = 999_999_999;
    let malicious_blocks = create_and_add_pending_blocks(
        pending_block_store.clone(),
        150,
        future_epoch,
        0,
        1,
    );
    
    // Garbage collection should have removed the 150 legitimate blocks
    // and kept the 150 malicious future epoch blocks
    assert_eq!(pending_block_store.lock().blocks_without_payloads.len(), 150);
    
    // Verify legitimate blocks were removed (lowest epoch)
    for block in &legitimate_blocks {
        assert!(!pending_block_store.lock().existing_pending_block(block));
    }
    
    // Verify malicious blocks persist (highest epoch)
    for block in &malicious_blocks {
        assert!(pending_block_store.lock().existing_pending_block(block));
    }
    
    // Attempting to add new legitimate blocks fails as store is full of malicious blocks
    let new_legitimate_block = create_and_add_pending_blocks(
        pending_block_store.clone(),
        1,
        current_epoch,
        1000,
        1,
    );
    
    // The new legitimate block gets removed by GC, malicious blocks persist
    assert!(!pending_block_store.lock().existing_pending_block(&new_legitimate_block[0]));
}
```

## Notes

This is a **logic vulnerability** in epoch validation and garbage collection ordering, not a network-layer DoS attack. The vulnerability exploits incorrect assumptions about epoch number bounds in the consensus observer implementation. While mitigations exist (subscription changes trigger cleanup, fallback mode clears state), they require manual intervention or timeouts, and the attacker can repeat the attack if they remain subscribed. The vulnerability affects the default configuration of VFNs which have consensus observer enabled automatically.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L67-67)
```rust
    blocks_without_payloads: BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>,
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L178-179)
```rust
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L679-680)
```rust
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L706-713)
```rust
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L729-752)
```rust
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-266)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```
