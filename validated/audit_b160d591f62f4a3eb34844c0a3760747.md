# Audit Report

## Title
Consensus Divergence Due to Backward Incompatible Gas Feature Version Handling in IoPricing

## Summary
Validators running outdated software can participate in consensus with newer on-chain `gas_feature_version` values but will compute different gas costs than updated validators, causing consensus divergence and network partition.

## Finding Description

The vulnerability exists in how `IoPricing::new()` handles `gas_feature_version` values through pattern matching. When governance upgrades the on-chain `gas_feature_version` (e.g., from 11 to 12), validators running old software will read this new value from blockchain state but use outdated pattern matching that maps it to a different pricing implementation than validators running new software. [1](#0-0) 

The `gas_feature_version` is read from on-chain state without validation against the software's supported versions: [2](#0-1) [3](#0-2) [4](#0-3) 

**The Critical Issue**: Old validator software compiled before version 12 support would have had pattern matching like `10.. => V3(...)`, causing version 12 to match the V3 arm. New software explicitly matches `10..=11 => V3` and `12.. => V4`, causing version 12 to use V4. This version was introduced specifically for 4KB page-aligned I/O charging: [5](#0-4) 

The two pricing implementations calculate **fundamentally different gas costs**:

**IoPricingV3** (no rounding): [6](#0-5) 

**IoPricingV4** (rounds to 4KB pages): [7](#0-6) 

**Example divergence**: For a 1000-byte resource read:
- Validator with V3: charges for 1000 bytes
- Validator with V4: charges for 4096 bytes (rounded up to PAGE_SIZE)

The different `gas_used` values are recorded in `TransactionInfo`, which is cryptographically hashed as part of consensus: [8](#0-7) 

The `gas_used` field is part of the BCS-serialized and hashed structure (note `CryptoHasher` and `BCSCryptoHash` derives). These hashes form the transaction accumulator that validators must agree on for consensus.

**Result**: Validators running different software versions produce different `TransactionInfo` hashes for identical transactions, causing different transaction accumulator roots and **consensus failure**.

## Impact Explanation

**CRITICAL Severity** - This vulnerability meets multiple Critical severity criteria from the Aptos Bug Bounty program:

1. **Consensus/Safety violations**: Breaks the fundamental consensus invariant that all validators must produce identical state roots for identical blocks

2. **Non-recoverable network partition**: When validators split between versions, they cannot reach consensus. Recovery requires emergency rollback of on-chain `gas_feature_version`, forced upgrade of all validators, or hard fork if the split persists

3. **Total loss of liveness/network availability**: The network cannot produce new blocks until the version mismatch is resolved

This violates the critical invariant of deterministic execution. The severity is amplified because:
- It affects the entire network, not individual validators
- It's triggered by normal governance operations (gas schedule upgrades)
- No attacker action is required
- The divergence is deterministic and permanent until resolved

## Likelihood Explanation

**HIGH Likelihood** - This scenario occurs naturally during protocol upgrades:

1. **Governance upgrades are routine**: Gas feature versions are regularly upgraded through on-chain governance proposals, as evidenced by 40+ versions in the changelog

2. **Validator upgrade lag is common**: During network upgrades, validators update their software at different times. A grace period where both versions coexist is normal and expected

3. **No validation prevents this**: The on-chain Move contract only validates that versions don't decrease: [9](#0-8) 

There is no check in the validator execution path that rejects `gas_feature_version` values higher than `LATEST_GAS_FEATURE_VERSION` known to the validator's software. The replay-benchmark tool has a warning but this is not in the production execution path: [10](#0-9) 

4. **Historical precedent**: Version 12 was introduced between releases, creating exactly this scenario if validators weren't all upgraded simultaneously.

The likelihood is HIGH because this isn't a hypothetical attack—it's a natural consequence of the upgrade process without proper version compatibility checks enforced at the protocol level.

## Recommendation

Implement version compatibility validation in the validator execution path:

1. **Add validation in `Environment::new()` or `get_gas_parameters()`** to check if `gas_feature_version > LATEST_GAS_FEATURE_VERSION` and either:
   - Reject block execution with an error
   - Log a critical warning and halt the validator
   - Fall back to the highest supported version with warnings

2. **Add on-chain validation** in `gas_schedule.move` to prevent governance from setting a version that would cause incompatibility (though this requires validators to report their supported versions)

3. **Implement graceful degradation** where unsupported versions map to the highest supported pricing implementation rather than causing pattern match failures

4. **Add monitoring and alerts** to detect when validators are executing with different IoPricing versions

Example fix for immediate validation:
```rust
// In get_gas_parameters() or Environment::new()
let gas_feature_version = get_gas_feature_version(state_view);
if gas_feature_version > LATEST_GAS_FEATURE_VERSION {
    error!("On-chain gas_feature_version {} exceeds supported version {}", 
           gas_feature_version, LATEST_GAS_FEATURE_VERSION);
    // Either panic, return error, or use LATEST_GAS_FEATURE_VERSION
}
```

## Proof of Concept

While a full PoC requires deploying two validator versions simultaneously, the vulnerability can be demonstrated by examining the code path:

1. Deploy validator V1 with code containing `10.. => V3(...)` pattern
2. Deploy validator V2 with code containing `10..=11 => V3(...)` and `12.. => V4(...)` patterns
3. Governance proposal upgrades on-chain `gas_feature_version` to 12
4. Both validators execute the same transaction with 1000-byte state read
5. V1 validator: pattern matches to V3, charges gas for 1000 bytes
6. V2 validator: pattern matches to V4, charges gas for 4096 bytes (4KB page)
7. Different `gas_used` → different `TransactionInfo` hashes → consensus divergence

The technical mechanism is confirmed by code inspection at the cited locations, demonstrating that no validation prevents this scenario during the upgrade window when validators run mixed software versions.

## Notes

This vulnerability represents a **coordination failure in protocol upgrades** rather than a malicious attack vector. The system lacks technical safeguards to enforce upgrade ordering (software upgrade must complete before on-chain version bump). While Aptos likely has operational procedures to prevent this, the absence of protocol-level validation means the system relies entirely on operational discipline. The catastrophic impact (network partition) combined with the realistic likelihood during normal upgrades justifies CRITICAL severity classification.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L167-172)
```rust
    fn calculate_read_gas(
        &self,
        loaded: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1) + STORAGE_IO_PER_STATE_BYTE_READ * loaded
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L204-218)
```rust
    fn calculate_read_gas(
        &self,
        loaded: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        // Round up bytes to whole pages
        // TODO(gas): make PAGE_SIZE configurable
        const PAGE_SIZE: u64 = 4096;

        let loaded_u64: u64 = loaded.into();
        let r = loaded_u64 % PAGE_SIZE;
        let rounded_up = loaded_u64 + if r == 0 { 0 } else { PAGE_SIZE - r };

        STORAGE_IO_PER_STATE_SLOT_READ * NumArgs::from(1)
            + STORAGE_IO_PER_STATE_BYTE_READ * NumBytes::new(rounded_up)
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L250-265)
```rust
        match feature_version {
            0 => V1(IoPricingV1::new(gas_params)),
            1..=9 => match StorageGasSchedule::fetch_config(config_storage) {
                None => V1(IoPricingV1::new(gas_params)),
                Some(schedule) => V2(IoPricingV2::new_with_storage_curves(
                    feature_version,
                    &schedule,
                    gas_params,
                )),
            },
            10..=11 => V3(IoPricingV3 {
                feature_version,
                legacy_free_write_bytes_quota: gas_params.vm.txn.legacy_free_write_bytes_quota,
            }),
            12.. => V4(IoPricingV4),
        }
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L15-19)
```rust
pub fn get_gas_feature_version(state_view: &impl StateView) -> u64 {
    GasScheduleV2::fetch_config(state_view)
        .map(|gas_schedule| gas_schedule.feature_version)
        .unwrap_or(0)
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-247)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
```

**File:** aptos-move/aptos-vm-types/src/storage/mod.rs (L68-68)
```rust
        let io_pricing = IoPricing::new(gas_feature_version, gas_params, config_storage);
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L38-41)
```rust
/// - V12
///   - Added BN254 operations.
///   - IO gas change: 1. read bytes charged at 4KB intervals; 2. ignore free_write_bytes_quota
///   - aggregator v2 gas charges
```

**File:** types/src/transaction/mod.rs (L2023-2027)
```rust
#[derive(Clone, CryptoHasher, BCSCryptoHash, Debug, Eq, PartialEq, Serialize, Deserialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L97-100)
```text
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
```

**File:** aptos-move/replay-benchmark/src/overrides.rs (L76-81)
```rust
        if matches!(gas_feature_version, Some(v) if v > LATEST_GAS_FEATURE_VERSION) {
            warn!(
                "Gas feature version is greater than the latest one: {}",
                LATEST_GAS_FEATURE_VERSION
            );
        }
```
