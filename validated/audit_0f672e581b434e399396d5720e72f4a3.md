Based on my thorough analysis of the Aptos Core codebase, I can confirm this is a **VALID MEDIUM SEVERITY** vulnerability. Here is my validation:

# Audit Report

## Title
Missing Equivocation Detection in Timeout Processing Allows Byzantine Validators to Form Inconsistent Timeout Certificates

## Summary
The timeout processing mechanism in Aptos consensus lacks equivocation detection, unlike vote processing. This allows Byzantine validators to send conflicting timeout messages with different `hqc_round` values to different nodes, causing honest nodes to form structurally different `TwoChainTimeoutCertificate` structures for the same round, creating consensus message inconsistency and enabling undetectable Byzantine behavior.

## Finding Description

**Asymmetric Equivocation Detection:**

The vote processing path explicitly detects equivocation by checking if an author has already voted for a different ledger info digest, returning `VoteReceptionResult::EquivocateVote` and logging a security event. [1](#0-0) 

In contrast, the timeout processing path directly forwards to `TwoChainTimeoutVotes::add()` without any author-based duplicate or equivocation checking. [2](#0-1) 

The underlying storage mechanism uses `entry(validator).or_insert()` semantics, which silently ignores subsequent timeouts from the same validator. [3](#0-2) 

**Exploitation Mechanism:**

1. A Byzantine validator broadcasts timeout messages with different `hqc_round` values (e.g., 50 vs 90) to different node subsets
2. Each node stores only the first timeout received from that validator due to `or_insert()` behavior
3. When forming the TC, each node's timeout field is updated to the timeout with the highest `hqc_round` seen [4](#0-3) 

4. TC verification independently passes at each node by checking `timeout.hqc_round == max(signed_hqc_rounds)` [5](#0-4) 

5. Different nodes form valid TCs with identical round numbers but different `hqc_round` values

**Permanent Inconsistency:**

When nodes exchange TCs via SyncInfo, TCs with the same or lower round number are rejected without replacement. [6](#0-5) 

This means different honest nodes permanently hold structurally different TCs for the same round.

**Safety Rule Impact:**

The safety voting rule checks whether `qc_round >= hqc_round` when validating proposals after timeouts. [7](#0-6) 

Nodes with different `hqc_round` values will make different voting decisions for the same proposals.

**No Detection Mechanism:**

The `TwoChainTimeoutCertificate` struct uses derived `Eq` and `PartialEq`, meaning TCs with different `hqc_round` values are structurally unequal. [8](#0-7) 

There is no `EquivocateTimeout` result type, and the timeout reception handler does not process equivocation cases. [9](#0-8) 

## Impact Explanation

This constitutes a **MEDIUM Severity** protocol violation under Aptos bug bounty criteria:

1. **Consensus Message Inconsistency**: Different honest nodes form structurally different TCs for the same round, violating the fundamental property that consensus messages should be consistent across honest participants

2. **Undetectable Byzantine Behavior**: Byzantine validators can equivocate on timeout messages without any detection, logging, or accountability mechanism—undermining the security monitoring assumptions of BFT protocols

3. **Safety Rule Divergence**: Different `hqc_round` values cause inconsistent safety evaluations, leading to divergent voting behavior for identical proposals across honest validators

4. **Protocol Correctness Violation**: While this does not directly cause funds loss or permanent consensus splits (due to BFT quorum requirements still holding), it represents a significant correctness issue that could be exploited in combination with other attacks

This aligns with MEDIUM severity: "Limited Protocol Violations - State inconsistencies requiring manual intervention"

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Single Byzantine validator within the standard 1/3 BFT fault tolerance assumption
- **Attack Complexity**: Low—simply broadcast different timeout messages to different nodes via normal gossip
- **Network Conditions**: Asynchronous network message delivery naturally enables this attack without special timing
- **Detection**: Zero—no equivocation detection, no security logging, no monitoring alerts, no error returns
- **Trigger Conditions**: Normal timeout scenarios during consensus operation

## Recommendation

Add equivocation detection to timeout processing analogous to vote processing:

1. Maintain an `author_to_timeout` map tracking the first timeout received from each validator
2. Check for conflicting timeouts (same author, same round, different `hqc_round`)
3. Return `VoteReceptionResult::EquivocateTimeout` and log security events when detected
4. Consider adding the ability to replace TCs when a structurally superior one (same round, provably higher `hqc_round`) is received

Example fix in `pending_votes.rs`:
```rust
// Add field to PendingVotes
author_to_timeout: HashMap<Author, TwoChainTimeout>,

// In insert_round_timeout(), add checking before line 227:
if let Some(previous_timeout) = self.author_to_timeout.get(&round_timeout.author()) {
    if previous_timeout.hqc_round() != timeout.hqc_round() {
        error!(SecurityEvent::ConsensusEquivocatingTimeout, ...);
        return VoteReceptionResult::EquivocateTimeout;
    }
}
self.author_to_timeout.insert(round_timeout.author(), timeout.clone());
```

## Proof of Concept

While a full Byzantine validator implementation is beyond scope, the vulnerability can be demonstrated by code inspection:

1. Tracing through `insert_round_timeout()` shows no author-based deduplication
2. The `or_insert()` call in `add_signature()` proves first-received semantics
3. The TC replacement logic in `insert_2chain_timeout_certificate()` confirms same-round TCs are not replaced
4. The safety rule in `safe_to_vote()` confirms different `hqc_round` values cause different voting decisions

A Byzantine validator can trivially exploit this by sending timeout messages with varying `hqc_round` values to different peers during normal timeout scenarios.

---

**Notes:**
This is a valid protocol correctness issue that violates consensus message consistency guarantees. While it doesn't directly cause critical impacts like funds loss or permanent chain splits, it represents a significant weakness in Byzantine fault tolerance that enables undetectable equivocation. The asymmetry between vote and timeout equivocation detection is a design flaw that should be addressed to maintain protocol invariants.

### Citations

**File:** consensus/src/pending_votes.rs (L190-271)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );

        let partial_tc = two_chain_votes.partial_2chain_tc_mut();
        let tc_voting_power =
            match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                Ok(_) => {
                    return match partial_tc.aggregate_signatures(validator_verifier) {
                        Ok(tc_with_sig) => {
                            VoteReceptionResult::New2ChainTimeoutCertificate(Arc::new(tc_with_sig))
                        },
                        Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                    };
                },
                Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,
                Err(error) => {
                    error!(
                        "MUST_FIX: 2-chain timeout vote received could not be added: {}, vote: {}",
                        error, timeout
                    );
                    return VoteReceptionResult::ErrorAddingVote(error);
                },
            };

        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
        }

        //
        // No TC could be formed, return the TC's voting power
        //

        VoteReceptionResult::VoteAdded(tc_voting_power)
    }
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L108-112)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L258-262)
```rust
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/src/block_storage/block_store.rs (L567-568)
```rust
        if tc.round() <= cur_tc_round {
            return Ok(());
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L159-160)
```rust
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
```

**File:** consensus/src/round_manager.rs (L1833-1853)
```rust
    async fn process_timeout_reception_result(
        &mut self,
        timeout: &RoundTimeout,
        result: VoteReceptionResult,
    ) -> anyhow::Result<()> {
        let round = timeout.round();
        match result {
            VoteReceptionResult::New2ChainTimeoutCertificate(tc) => {
                self.new_2chain_tc_aggregated(tc).await
            },
            VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
                self.process_local_timeout(round).await
            },
            VoteReceptionResult::VoteAdded(_) | VoteReceptionResult::EchoTimeout(_) => Ok(()),
            result @ VoteReceptionResult::NewQuorumCertificate(_)
            | result @ VoteReceptionResult::DuplicateVote => {
                bail!("Unexpected result from timeout processing: {:?}", result);
            },
            e => Err(anyhow::anyhow!("{:?}", e)),
        }
    }
```
