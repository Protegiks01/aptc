# Audit Report

## Title
Missing Bounds Validation in Aggregator::add() Allows Recording of Out-of-Range Deltas

## Summary
The `Aggregator::add()` function in the Aptos aggregator v1 implementation fails to validate that resulting positive deltas remain within `max_value` bounds when transitioning from `NegativeDelta` to `PositiveDelta` state. This asymmetric validation allows out-of-range values to be recorded in delta history, causing deterministic validation failures during materialization regardless of the actual base value.

## Finding Description

The aggregator system uses speculative execution to track deltas without knowing the base value from storage. The vulnerability exists in the state transition logic within `Aggregator::add()`.

When transitioning from `NegativeDelta` to `PositiveDelta` state, the `add()` function computes the new positive delta as `value - self.value` but does not validate this result against `max_value`: [1](#0-0) 

The computed value is only checked for underflow by `BoundedMath::unsigned_subtract()`: [2](#0-1) 

This contrasts sharply with the `sub()` function, which explicitly validates that negative delta magnitudes don't exceed `max_value` when transitioning from `PositiveDelta` to `NegativeDelta`: [3](#0-2) 

The asymmetry is evident: `sub()` includes a bounds check with an explicit comment explaining why it's necessary, while `add()` has no corresponding validation.

After the state transition, the `record()` function blindly records the out-of-range value into history without any validation: [4](#0-3) 

During materialization via `read_and_materialize()`, the `validate_history()` function checks that `base_value + max_achieved_positive_delta <= max_value`: [5](#0-4) 

**Attack Scenario:**
1. Create aggregator with `max_value = 100`
2. Call `sub(60)` from initial `PositiveDelta(0)` state - transitions to `NegativeDelta(60)` after passing the bounds check at line 193
3. Call `add(200)` - since `60 <= 200`, line 152 computes `200 - 60 = 140` and transitions to `PositiveDelta(140)` without checking that `140 > 100`
4. History now records `max_achieved_positive_delta = 140`
5. During materialization, validation requires `base_value + 140 <= 100`, which needs `base_value <= -40` (impossible for unsigned integers)
6. Validation fails for ALL possible base values

## Impact Explanation

**Severity: Medium ($10,000)**

This vulnerability breaks the **Deterministic Execution** invariant and causes **State Consistency** violations. It qualifies as Medium Severity per Aptos bug bounty criteria for "State inconsistencies requiring intervention."

The vulnerability allows transactions to succeed during speculative execution but fail deterministically during validation, causing:

1. **State inconsistencies**: Transactions appear valid speculatively but always fail at materialization, creating unpredictable behavior
2. **Aggregator lockup**: Once an out-of-range delta is recorded, the aggregator becomes unusable and must be destroyed and recreated
3. **Transaction rejection**: Valid transaction sequences may be rejected if intermediate states record out-of-range deltas
4. **Consensus safety preserved**: Since validation is deterministic, this doesn't cause chain splits, but affects transaction inclusion and state commitment predictability

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is highly exploitable because it:
- Requires only normal Move API calls (`aggregator::add` and `aggregator::sub`)
- Needs no special privileges, validator access, or complex transaction sequences
- Is deterministic and requires only 2 function calls
- Affects any aggregator with small `max_value` limits (common for counters or rate limiters)

Any transaction sender can trigger this by:
1. Performing a small subtraction to enter `NegativeDelta` state
2. Adding a value that exceeds `max_value`

The attack has no timing dependencies or preconditions beyond normal network operation.

## Recommendation

Add bounds validation in `Aggregator::add()` when transitioning from `NegativeDelta` to `PositiveDelta`, mirroring the check in `sub()`:

```rust
if self.value <= value {
    let result = math.unsigned_subtract(value, self.value)
        .map_err(addition_v1_error)?;
    // Add bounds check: result must not exceed max_value
    if result > self.max_value {
        return Err(addition_v1_error(BoundedMathError::Overflow));
    }
    self.value = result;
    self.state = AggregatorState::PositiveDelta;
}
```

Alternatively, use `BoundedMath::unsigned_add()` to validate the result:
```rust
if self.value <= value {
    self.value = math.unsigned_add(0, math.unsigned_subtract(value, self.value)?)
        .map_err(addition_v1_error)?;
    self.state = AggregatorState::PositiveDelta;
}
```

## Proof of Concept

```rust
#[test]
fn test_add_exceeds_max_value_from_negative_delta() {
    let mut aggregator_data = AggregatorData::default();
    let resolver = FakeAggregatorView::default();

    // Create aggregator with max_value = 100
    let aggregator = aggregator_data
        .get_aggregator(aggregator_v1_id_for_test(100), 100)
        .expect("Get aggregator failed");

    // Step 1: sub(60) to transition to NegativeDelta(60)
    assert_ok!(aggregator.sub(60));
    assert_eq!(aggregator.state, AggregatorState::NegativeDelta);
    assert_eq!(aggregator.value, 60);

    // Step 2: add(200) - should fail but succeeds, creating PositiveDelta(140)
    assert_ok!(aggregator.add(200)); // BUG: This should fail but succeeds!
    assert_eq!(aggregator.state, AggregatorState::PositiveDelta);
    assert_eq!(aggregator.value, 140); // 140 > max_value (100)!

    // Step 3: Validation during materialization always fails
    // For ANY base_value, validation checks: base_value + 140 <= 100
    // This requires base_value <= -40, which is impossible
    assert_err!(aggregator.read_and_materialize(&resolver, &aggregator_v1_id_for_test(100)));
}
```

This test demonstrates that:
1. The `add(200)` call succeeds during speculative execution
2. It creates an out-of-range positive delta (140 > 100)
3. Validation during materialization always fails regardless of base value

### Citations

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L75-89)
```rust
    fn record(&mut self) {
        if let Some(history) = self.history.as_mut() {
            match self.state {
                AggregatorState::PositiveDelta => {
                    history.record_success(SignedU128::Positive(self.value))
                },
                AggregatorState::NegativeDelta => {
                    history.record_success(SignedU128::Negative(self.value))
                },
                AggregatorState::Data => {
                    unreachable!("history is not tracked when aggregator knows its value")
                },
            }
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L151-153)
```rust
                if self.value <= value {
                    self.value = expect_ok(math.unsigned_subtract(value, self.value))?;
                    self.state = AggregatorState::PositiveDelta;
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L190-194)
```rust
                    // Check that we can subtract in general: we don't want to
                    // allow -10000 when max_value is 10.
                    // TODO: maybe `subtraction` should also know about the max_value?
                    math.unsigned_subtract(self.max_value, value)
                        .map_err(subtraction_v1_error)?;
```

**File:** aptos-move/aptos-aggregator/src/bounded_math.rs (L58-64)
```rust
    pub fn unsigned_subtract(&self, base: u128, value: u128) -> BoundedMathResult<u128> {
        if value > base {
            Err(BoundedMathError::Underflow)
        } else {
            Ok(base - value)
        }
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L159-165)
```rust
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
```
