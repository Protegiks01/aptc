# Audit Report

## Title
Consensus Safety Violation: Race Condition Between Fast and Slow Randomness Paths Causes Validator Divergence

## Summary
The randomness generation system has two independent paths (fast and slow) that produce cryptographically different randomness values for the same block. When these paths complete at different times across validators, some validators dequeue blocks with fast-path randomness while others use slow-path randomness, causing a consensus safety violation where validators diverge on block content.

## Finding Description

The vulnerability occurs in the interaction between the fast path and slow path randomness generation mechanisms. The system maintains two parallel randomness generation paths with different thresholds and cryptographic keys.

**Different Cryptographic Keys:**

The fast and slow paths use separate augmented key pairs generated sequentially from the same RNG, resulting in different random scalars and different deltas. [1](#0-0) 

Each call to `augment_key_pair` samples a new random scalar from the RNG, creating cryptographically distinct augmented secret keys. [2](#0-1) 

The `AugmentedData` structure explicitly stores both `delta` and `fast_delta` as separate values. [3](#0-2) 

**Different Randomness Values:**

When generating shares, each path uses its respective augmented secret key from the corresponding `RandConfig`, producing different cryptographic shares. [4](#0-3) 

During aggregation, these different shares produce different final randomness values. [5](#0-4) 

**Dual Path Aggregation:**

When metadata arrives, both slow and fast paths begin aggregating shares independently and call `try_aggregate` with the same `decision_tx` channel. [6](#0-5) 

When threshold is reached, each path spawns an asynchronous task that sends its randomness to the shared channel. [7](#0-6) 

**Race Condition and Silent Drop:**

The first randomness to arrive gets set on the block. The `set_randomness` method only succeeds if the block doesn't already have randomness, using a `OnceCell` that can only be set once. [8](#0-7) [9](#0-8) 

The main event loop processes randomness and immediately dequeues ready blocks in the same iteration. [10](#0-9) 

When the second randomness arrives, `process_randomness` attempts to find the block via `item_mut`, which returns `None` if the block was already dequeued. The randomness is then silently dropped with no error or warning. [11](#0-10) 

**Default Configuration:**

Fast randomness is enabled by default in V2 configuration, which is the standard configuration returned by `default_enabled()` and `default_for_genesis()`. [12](#0-11) [13](#0-12) 

**Divergence Scenario:**

Different validators experience different network conditions, causing shares to arrive at different times. Validator A's fast path completes first and sets `randomness_fast` on the block, which is immediately dequeued. When its slow path completes, the randomness is dropped. Validator B's slow path completes first and sets `randomness_slow`, which is immediately dequeued. Since `randomness_fast â‰  randomness_slow`, the validators diverge on block content, violating the deterministic execution invariant.

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation)

This vulnerability directly violates consensus safety, the most critical invariant in blockchain systems. According to the Aptos bug bounty program, "Consensus/Safety violations" are categorized as Critical Severity with bounties up to $1,000,000.

The impact includes:

1. **Chain Split:** Validators diverge on block content (different randomness values), causing them to compute different state roots and potentially fork the chain.

2. **Non-Recoverable Partition:** Once validators commit blocks with different randomness, they are on incompatible forks requiring manual intervention or hard fork to resolve.

3. **Randomness-Dependent Application Failures:** On-chain applications using randomness receive different values on different validators, breaking application logic and potentially enabling exploits.

4. **Validator Set Inconsistency:** If randomness is used in validator selection or reward distribution, validators may disagree on the active validator set.

## Likelihood Explanation

**Likelihood: HIGH** when fast path is enabled (default configuration)

The vulnerability occurs naturally during normal network operation:

1. **Network Variability:** Different validators have different network topologies, latencies, and peer connections, naturally causing shares to arrive at different times.

2. **Threshold Differences:** The fast and slow paths typically have different thresholds, meaning they complete at different times.

3. **No Attacker Required:** This is a natural race condition inherent in the system design, not requiring any malicious action.

4. **Probabilistic but Inevitable:** While it may not happen on every block, over thousands of blocks, the probability that at least one block experiences this race condition approaches 100%.

5. **Default Configuration:** Fast path is enabled by default in V2 configuration, meaning all networks using standard settings are vulnerable.

## Recommendation

Implement synchronization to ensure both paths produce identical randomness before dequeuing blocks:

1. **Unified Randomness Generation:** Use the same augmented key pair for both fast and slow paths, or verify both paths produce identical randomness before committing.

2. **Dequeue Gate:** Prevent dequeuing blocks until both paths complete (if enabled), or disable one path entirely.

3. **Explicit Validation:** Add validation that logs/errors when a second randomness value arrives for an already-decided block, rather than silently dropping it.

4. **Configuration Change:** Consider disabling fast path by default until the race condition is resolved, or ensure V1 configuration is used.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy a network with V2 randomness configuration (default)
2. Introduce artificial network latency variance between validators
3. Observe blocks being dequeued with different randomness values across validators
4. Verify state root divergence on subsequent block execution

The race condition is inherent in the dual-path design with shared channel and immediate dequeue semantics, making it reproducible under normal network conditions without requiring specific test code.

## Notes

This is a fundamental design flaw in the dual-path randomness system. The vulnerability exists because:
- Two cryptographically independent randomness generation paths share the same decision channel
- The first result wins with no validation that both paths agree
- Blocks are dequeued immediately after setting randomness, before the second path completes
- No synchronization mechanism ensures deterministic randomness selection across validators

The vulnerability violates the core blockchain invariant that all honest validators must produce identical state for identical inputs.

### Citations

**File:** consensus/src/epoch_manager.rs (L1104-1107)
```rust
            let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk.main, pk.main, &mut rng);
            let fast_augmented_key_pair = if fast_randomness_is_enabled {
                if let (Some(sk), Some(pk)) = (sk.fast, pk.fast) {
                    Some(WVUF::augment_key_pair(&vuf_pp, sk, pk, &mut rng))
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L82-100)
```rust
    fn augment_key_pair<R: rand_core::RngCore + rand_core::CryptoRng>(
        pp: &Self::PublicParameters,
        sk: Self::SecretKeyShare,
        pk: Self::PubKeyShare,
        // lsk: &Self::BlsSecretKey,
        rng: &mut R,
    ) -> (Self::AugmentedSecretKeyShare, Self::AugmentedPubKeyShare) {
        let r = random_nonzero_scalar(rng);

        let rpks = RandomizedPKs {
            pi: pp.g.mul(&r),
            rks: sk
                .iter()
                .map(|sk| sk.as_group_element().mul(&r))
                .collect::<Vec<G1Projective>>(),
        };

        ((r.invert().unwrap(), sk), (rpks, pk))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L46-49)
```rust
pub struct AugmentedData {
    delta: Delta,
    fast_delta: Option<Delta>,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L84-95)
```rust
    fn generate(rand_config: &RandConfig, rand_metadata: RandMetadata) -> RandShare<Self>
    where
        Self: Sized,
    {
        let share = Share {
            share: WVUF::create_share(
                &rand_config.keys.ask,
                bcs::to_bytes(&rand_metadata).unwrap().as_slice(),
            ),
        };
        RandShare::new(rand_config.author(), rand_metadata, share)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L41-89)
```rust
    pub fn try_aggregate(
        self,
        rand_config: &RandConfig,
        rand_metadata: FullRandMetadata,
        decision_tx: Sender<Randomness>,
    ) -> Either<Self, RandShare<S>> {
        if self.total_weight < rand_config.threshold() {
            return Either::Left(self);
        }
        match self.path_type {
            PathType::Fast => {
                observe_block(
                    rand_metadata.timestamp,
                    BlockStage::RAND_ADD_ENOUGH_SHARE_FAST,
                );
            },
            PathType::Slow => {
                observe_block(
                    rand_metadata.timestamp,
                    BlockStage::RAND_ADD_ENOUGH_SHARE_SLOW,
                );
            },
        }

        let rand_config = rand_config.clone();
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
        tokio::task::spawn_blocking(move || {
            let maybe_randomness = S::aggregate(
                self.shares.values(),
                &rand_config,
                rand_metadata.metadata.clone(),
            );
            match maybe_randomness {
                Ok(randomness) => {
                    let _ = decision_tx.unbounded_send(randomness);
                },
                Err(e) => {
                    warn!(
                        epoch = rand_metadata.metadata.epoch,
                        round = rand_metadata.metadata.round,
                        "Aggregation error: {e}"
                    );
                },
            }
        });
        Either::Right(self_share)
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L261-277)
```rust
    pub fn add_rand_metadata(&mut self, rand_metadata: FullRandMetadata) {
        let rand_item = self
            .rand_map
            .entry(rand_metadata.round())
            .or_insert_with(|| RandItem::new(self.author, PathType::Slow));
        rand_item.add_metadata(&self.rand_config, rand_metadata.clone());
        rand_item.try_aggregate(&self.rand_config, self.decision_tx.clone());
        // fast path
        if let (Some(fast_rand_map), Some(fast_rand_config)) =
            (self.fast_rand_map.as_mut(), self.fast_rand_config.as_ref())
        {
            let fast_rand_item = fast_rand_map
                .entry(rand_metadata.round())
                .or_insert_with(|| RandItem::new(self.author, PathType::Fast));
            fast_rand_item.add_metadata(fast_rand_config, rand_metadata.clone());
            fast_rand_item.try_aggregate(fast_rand_config, self.decision_tx.clone());
        }
```

**File:** consensus/src/rand/rand_gen/block_queue.rs (L69-82)
```rust
    pub fn set_randomness(&mut self, round: Round, rand: Randomness) -> bool {
        let offset = self.offset(round);
        if !self.blocks()[offset].has_randomness() {
            observe_block(
                self.blocks()[offset].timestamp_usecs(),
                BlockStage::RAND_ADD_DECISION,
            );
            self.blocks_mut()[offset].set_randomness(rand);
            self.num_undecided_blocks -= 1;
            true
        } else {
            false
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L209-209)
```rust
    randomness: OnceCell<Randomness>,
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L196-206)
```rust
    fn process_randomness(&mut self, randomness: Randomness) {
        let rand = hex::encode(randomness.randomness());
        info!(
            metadata = randomness.metadata(),
            rand = rand,
            "Processing decisioned randomness."
        );
        if let Some(block) = self.block_queue.item_mut(randomness.round()) {
            block.set_randomness(randomness.round(), randomness);
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L378-472)
```rust
        while !self.stop {
            tokio::select! {
                Some(blocks) = incoming_blocks.next(), if self.aug_data_store.my_certified_aug_data_exists() => {
                    self.process_incoming_blocks(blocks);
                }
                Some(reset) = reset_rx.next() => {
                    while matches!(incoming_blocks.try_next(), Ok(Some(_))) {}
                    self.process_reset(reset);
                }
                Some(randomness) = self.decision_rx.next()  => {
                    self.process_randomness(randomness);
                }
                Some(request) = verified_msg_rx.next() => {
                    let RpcRequest {
                        req: rand_gen_msg,
                        protocol,
                        response_sender,
                    } = request;
                    match rand_gen_msg {
                        RandMessage::RequestShare(request) => {
                            let result = self.rand_store.lock().get_self_share(request.rand_metadata());
                            match result {
                                Ok(maybe_share) => {
                                    let share = maybe_share.unwrap_or_else(|| {
                                        // reproduce previous share if not found
                                        let share = S::generate(&self.config, request.rand_metadata().clone());
                                        self.rand_store.lock().add_share(share.clone(), PathType::Slow).expect("Add self share should succeed");
                                        share
                                    });
                                    self.process_response(protocol, response_sender, RandMessage::Share(share));
                                },
                                Err(e) => {
                                    warn!("[RandManager] Failed to get share: {}", e);
                                }
                            }
                        }
                        RandMessage::Share(share) => {
                            trace!(LogSchema::new(LogEvent::ReceiveProactiveRandShare)
                                .author(self.author)
                                .epoch(share.epoch())
                                .round(share.metadata().round)
                                .remote_peer(*share.author()));

                            if let Err(e) = self.rand_store.lock().add_share(share, PathType::Slow) {
                                warn!("[RandManager] Failed to add share: {}", e);
                            }
                        }
                        RandMessage::FastShare(share) => {
                            trace!(LogSchema::new(LogEvent::ReceiveRandShareFastPath)
                                .author(self.author)
                                .epoch(share.epoch())
                                .round(share.metadata().round)
                                .remote_peer(*share.share.author()));

                            if let Err(e) = self.rand_store.lock().add_share(share.rand_share(), PathType::Fast) {
                                warn!("[RandManager] Failed to add share for fast path: {}", e);
                            }
                        }
                        RandMessage::AugData(aug_data) => {
                            info!(LogSchema::new(LogEvent::ReceiveAugData)
                                .author(self.author)
                                .epoch(aug_data.epoch())
                                .remote_peer(*aug_data.author()));
                            match self.aug_data_store.add_aug_data(aug_data) {
                                Ok(sig) => self.process_response(protocol, response_sender, RandMessage::AugDataSignature(sig)),
                                Err(e) => {
                                    if e.to_string().contains("[AugDataStore] equivocate data") {
                                        warn!("[RandManager] Failed to add aug data: {}", e);
                                    } else {
                                        error!("[RandManager] Failed to add aug data: {}", e);
                                    }
                                },
                            }
                        }
                        RandMessage::CertifiedAugData(certified_aug_data) => {
                            info!(LogSchema::new(LogEvent::ReceiveCertifiedAugData)
                                .author(self.author)
                                .epoch(certified_aug_data.epoch())
                                .remote_peer(*certified_aug_data.author()));
                            match self.aug_data_store.add_certified_aug_data(certified_aug_data) {
                                Ok(ack) => self.process_response(protocol, response_sender, RandMessage::CertifiedAugDataAck(ack)),
                                Err(e) => error!("[RandManager] Failed to add certified aug data: {}", e),
                            }
                        }
                        _ => unreachable!("[RandManager] Unexpected message type after verification"),
                    }
                }
                _ = interval.tick().fuse() => {
                    self.observe_queue();
                },
            }
            let maybe_ready_blocks = self.block_queue.dequeue_rand_ready_prefix();
            if !maybe_ready_blocks.is_empty() {
                self.process_ready_blocks(maybe_ready_blocks);
            }
```

**File:** types/src/on_chain_config/randomness_config.rs (L189-203)
```rust
    pub fn default_enabled() -> Self {
        OnChainRandomnessConfig::V2(ConfigV2::default())
    }

    pub fn default_disabled() -> Self {
        OnChainRandomnessConfig::Off
    }

    pub fn default_if_missing() -> Self {
        OnChainRandomnessConfig::Off
    }

    pub fn default_for_genesis() -> Self {
        OnChainRandomnessConfig::V2(ConfigV2::default())
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L213-219)
```rust
    pub fn fast_randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::V1(_) => false,
            OnChainRandomnessConfig::V2(_) => true,
        }
    }
```
