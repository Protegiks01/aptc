# Audit Report

## Title
Consensus Observer Incorrectly Rejects Legitimate NIL Blocks Due to Missing Payload Handling

## Summary
The `verify_payloads_against_ordered_block()` function in the consensus observer incorrectly treats blocks with no payload (NIL blocks and Genesis blocks) as errors, causing observer nodes to reject legitimate ordered blocks during normal network timeout scenarios. This breaks observer node functionality and prevents them from maintaining consensus synchronization.

## Finding Description

The consensus observer's payload verification logic fails to distinguish between blocks that legitimately have no payload (NIL blocks, Genesis blocks) and blocks that are missing expected payload data.

**Background on NIL Blocks:**
NIL blocks are special consensus blocks generated during timeout scenarios to fill gaps in rounds. They are created when validators don't receive valid proposals within the round timeout period. [1](#0-0)  NIL blocks are part of the protocol's designed fault tolerance mechanism. [2](#0-1) 

When a block has the `NilBlock` or `Genesis` block type, the `payload()` method correctly returns `None` to indicate the absence of transactions: [3](#0-2) 

**The Vulnerability:**
In the payload verification function, when `ordered_block.block().payload()` returns `None`, the code immediately returns an error "Missing block payload": [4](#0-3) 

**Execution Flow:**
1. Network experiences a timeout in consensus (normal operation)
2. Validators create NIL blocks to fill the round gap [1](#0-0) 
3. NIL blocks can be ordered and are included in execution windows [5](#0-4) 
4. Ordered blocks are published to consensus observers via `OrderedBlock` messages [6](#0-5) 
5. Observer nodes receive and process the `OrderedBlock` [7](#0-6) 
6. The payload verification is called on line 758
7. For NIL blocks, `payload()` returns `None`
8. The verification function returns error "Missing block payload" at line 190-195
9. The entire `OrderedBlock` is rejected as invalid at line 769
10. Observer nodes fail to process legitimate consensus progress and fall behind

This breaks observer node synchronization, as they cannot maintain an accurate view of consensus state when NIL blocks are present.

## Impact Explanation

**Severity Assessment:**

This vulnerability causes **observer node service degradation** affecting the Aptos ecosystem infrastructure. While the report initially classified this as "validator node slowdowns," it's important to clarify that consensus observer nodes are distinct from validator nodes - they observe consensus but don't participate in voting or block production.

**Specific Impacts:**
- **Observer Node Liveness Failure**: Observer nodes cannot process blocks when NIL blocks are present, causing them to fall behind the network
- **Consensus Synchronization Broken**: Observers fail to maintain accurate consensus state visibility
- **Service Degradation**: Applications and users relying on observer nodes for reading blockchain state receive stale or no data
- **Infrastructure Reliability**: Observer infrastructure becomes unreliable during normal network timeout scenarios

While this doesn't affect core consensus validators or consensus safety (validators continue functioning correctly), observer nodes are critical infrastructure for ecosystem participants reading blockchain state. This qualifies as a **Medium severity** issue affecting observer infrastructure reliability and availability.

## Likelihood Explanation

**Likelihood: High**

NIL blocks are created during **normal network operation** whenever timeouts occur: [2](#0-1) 

- Network latency spikes
- Temporary validator connectivity issues
- Round leadership failures
- Any scenario where consensus cannot immediately progress

NIL blocks are not exceptional casesâ€”they are part of the protocol's designed fault tolerance. The consensus observer code is executed by all observer nodes, making this bug widespread and easily triggered during routine network conditions.

The bug **will** trigger whenever:
1. A timeout causes NIL block creation (common during normal operation)
2. The NIL block is ordered (guaranteed if consensus progresses) [8](#0-7) 
3. Observer nodes receive the ordered block (guaranteed by design)

## Recommendation

Modify the `verify_payloads_against_ordered_block()` function to handle NIL blocks and Genesis blocks as legitimate cases that don't require payload verification:

```rust
// Get the ordered block payload
let ordered_block_payload = match ordered_block.block().payload() {
    Some(payload) => payload,
    None => {
        // NIL blocks and Genesis blocks legitimately have no payload
        if ordered_block.block().is_nil_block() || ordered_block.block().is_genesis_block() {
            continue; // Skip payload verification for these block types
        }
        return Err(Error::InvalidMessageError(format!(
            "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
            ordered_block.epoch(),
            ordered_block.round()
        )));
    },
};
```

## Proof of Concept

The vulnerability can be demonstrated through the existing test infrastructure. When an `OrderedBlock` containing a NIL block is processed by a consensus observer, the verification fails at line 190 in `payload_store.rs`, causing the observer to reject the legitimate block and fall behind consensus.

**Notes:**
- NIL blocks are confirmed to be legitimate consensus blocks created during normal timeout scenarios
- The consensus observer pattern is designed to allow nodes to observe consensus without participating in voting
- Observer nodes failing doesn't affect consensus safety or validator operation, but does impact ecosystem infrastructure reliability
- The fix requires distinguishing between legitimately empty blocks (NIL/Genesis) and blocks with missing payload data

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L462-476)
```rust
    pub fn generate_nil_block(
        &self,
        round: Round,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> anyhow::Result<Block> {
        let hqc = self.ensure_highest_quorum_cert(round)?;
        let quorum_cert = hqc.as_ref().clone();
        let failed_authors = self.compute_failed_authors(
            round, // to include current round, as that is what failed
            quorum_cert.certified_block().round(),
            true,
            proposer_election,
        );
        Ok(Block::new_nil(round, quorum_cert, failed_authors))
    }
```

**File:** consensus/src/round_manager_tests/consensus_test.rs (L1012-1053)
```rust
fn nil_vote_on_timeout() {
    let runtime = consensus_runtime();
    let mut playground = NetworkPlayground::new(runtime.handle().clone());
    let mut nodes = NodeSetup::create_nodes(
        &mut playground,
        runtime.handle().clone(),
        1,
        None,
        None,
        None,
        Some(config_with_round_timeout_msg_disabled()),
        None,
        None,
        false,
    );
    let node = &mut nodes[0];
    let genesis = node.block_store.ordered_root();
    timed_block_on(&runtime, async {
        node.next_proposal().await;
        // Process the outgoing vote message and verify that it contains a round signature
        // and that the vote extends genesis.
        node.round_manager
            .process_local_timeout(1)
            .await
            .unwrap_err();
        let vote_msg = node.next_vote().await;

        let vote = vote_msg.vote();

        assert!(vote.is_timeout());
        // NIL block doesn't change timestamp
        assert_eq!(
            vote.vote_data().proposed().timestamp_usecs(),
            genesis.timestamp_usecs()
        );
        assert_eq!(vote.vote_data().proposed().round(), 1);
        assert_eq!(
            vote.vote_data().parent().id(),
            node.block_store.ordered_root().id()
        );
    });
}
```

**File:** consensus/consensus-types/src/block_data.rs (L167-176)
```rust
    pub fn payload(&self) -> Option<&Payload> {
        match &self.block_type {
            BlockType::Proposal { payload, .. } | BlockType::DAGBlock { payload, .. } => {
                Some(payload)
            },
            BlockType::ProposalExt(p) => p.payload(),
            BlockType::OptimisticProposal(p) => Some(p.payload()),
            _ => None,
        }
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L187-196)
```rust
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };
```

**File:** consensus/src/block_storage/execution_pool/block_window_test.rs (L477-480)
```rust
    // Nil block is included in OrderedBlockWindow
    assert_eq!(block_window.get(2).unwrap().id(), b2_r4.id());
    assert!(b2_r4.block().is_nil_block());
    assert_eq!(block_window.len(), 3);
```

**File:** consensus/src/pipeline/buffer_manager.rs (L401-405)
```rust
            let message = ConsensusObserverMessage::new_ordered_block_message(
                ordered_blocks.clone(),
                ordered_proof.clone(),
            );
            consensus_publisher.publish_message(message);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L755-771)
```rust
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L206-227)
```rust
    pub async fn insert_ordered_cert(
        &self,
        ordered_cert: &WrappedLedgerInfo,
    ) -> anyhow::Result<()> {
        if self.ordered_root().round() < ordered_cert.ledger_info().ledger_info().round() {
            if let Some(ordered_block) = self.get_block(ordered_cert.commit_info().id()) {
                if !ordered_block.block().is_nil_block() {
                    observe_block(
                        ordered_block.block().timestamp_usecs(),
                        BlockStage::OC_ADDED,
                    );
                }
                SUCCESSFUL_EXECUTED_WITH_ORDER_VOTE_QC.inc();
                self.send_for_execution(ordered_cert.clone()).await?;
            } else {
                bail!("Ordered block not found in block store when inserting ordered cert");
            }
        } else {
            LATE_EXECUTION_WITH_ORDER_VOTE_QC.inc();
        }
        Ok(())
    }
```
