# Audit Report

## Title
State Merkle Shard Pruner Progress Tracking Failure Causes State Inconsistency After Crash

## Summary
The `StateMerkleShardPruner::prune()` function contains a critical bug where `current_progress` is never updated within the pruning loop. When the pruning process is interrupted after deleting nodes but before completing all iterations, the per-shard progress remains at its original value despite nodes being permanently deleted. This causes the system to claim data availability for versions that have been pruned, leading to `MissingRootError` on queries.

## Finding Description

The vulnerability exists in the main pruning loop where `current_progress` is passed to `get_stale_node_indices()` on every iteration without being updated: [1](#0-0) 

The critical flaw is that:
1. The function receives `current_progress` as a parameter (line 60)
2. Each loop iteration calls `get_stale_node_indices()` with the same `current_progress` value (lines 66-71)
3. Nodes and stale indices are deleted and committed to the database (lines 73-92)
4. Progress is only persisted when `done = true` at the very end (lines 85-89)
5. If the process is interrupted mid-loop after batch commits (line 92), multiple batches of nodes are deleted but progress never advances

**State Inconsistency Scenario:**

1. **Initial State**: Shard progress = 5000, stale nodes exist for versions 5000-6000, batch_size = 100
2. **Iteration 1**: `get_stale_node_indices(5000, 6000, 100)` returns 100 indices. These are deleted and committed. Progress still = 5000.
3. **Iteration 2**: `get_stale_node_indices(5000, 6000, 100)` still uses 5000. Iterator skips deleted nodes, returns next batch. Deleted and committed. Progress still = 5000.
4. **CRASH** occurs before loop completion
5. **On Restart**: Shard progress reads 5000 from database via `get_or_initialize_subpruner_progress`: [2](#0-1) 

During initialization, the shard calls `prune(progress, metadata_progress, usize::MAX)` for catchup: [3](#0-2) 

If `progress == metadata_progress`, the catchup does nothing because `get_stale_node_indices` with `start_version == target_version` returns empty results: [4](#0-3) 

6. **Query Failure**: A query for version 5025 passes the `min_readable_version` check: [5](#0-4) 

The `min_readable_version` is read from the pruner manager: [6](#0-5) 

But when retrieving the actual merkle node, it fails with `MissingRootError` because the root node was deleted: [7](#0-6) 

This violates the **State Consistency** invariant: versions >= min_readable_version must be queryable with complete merkle proofs.

## Impact Explanation

This is **MEDIUM Severity** (up to $10,000) under "State inconsistencies requiring manual intervention":

1. **Data Availability Failure**: Nodes cannot serve legitimate queries for versions they claim to support, breaking the promise that all versions >= min_readable_version are available.

2. **State Sync Failures**: New validators attempting to sync from affected nodes will fail to retrieve merkle proofs for supposedly available versions.

3. **Operational Impact**: Requires manual intervention to identify inconsistent shards, potentially requiring database recovery or re-sync from genesis.

4. **Multi-Node Impact**: The outer `StateMerklePruner` records overall progress after shards complete: [8](#0-7) 

If some shards are inconsistent, the overall progress advances while per-shard state remains corrupted.

## Likelihood Explanation

**HIGH Likelihood** - This bug will manifest naturally during normal operations:

1. **Common Trigger**: Process crashes, OOM kills, restarts, and panics occur regularly in distributed systems
2. **Frequent Operation**: Pruning runs continuously as a background task when enabled
3. **Multiple Iterations**: With batch_size limits and thousands of versions to prune, multi-iteration loops are common
4. **No Prevention**: No safeguards exist to prevent or detect this inconsistency
5. **Silent Failure**: The bug is silent until a query attempts to access the missing range

The parallel execution of shard pruners increases likelihood: [9](#0-8) 

Multiple shards can enter inconsistent states independently.

## Recommendation

Update `current_progress` within the loop after each successful batch commit:

```rust
pub(in crate::pruner) fn prune(
    &self,
    mut current_progress: Version,  // Make mutable
    target_version: Version,
    max_nodes_to_prune: usize,
) -> Result<()> {
    loop {
        let mut batch = SchemaBatch::new();
        let (indices, next_version) = StateMerklePruner::get_stale_node_indices(
            &self.db_shard,
            current_progress,
            target_version,
            max_nodes_to_prune,
        )?;

        indices.into_iter().try_for_each(|index| {
            batch.delete::<JellyfishMerkleNodeSchema>(&index.node_key)?;
            batch.delete::<S>(&index)
        })?;

        let mut done = true;
        if let Some(next_version) = next_version {
            if next_version <= target_version {
                done = false;
                // Update progress after each batch
                batch.put::<DbMetadataSchema>(
                    &S::progress_metadata_key(Some(self.shard_id)),
                    &DbMetadataValue::Version(next_version),
                )?;
                current_progress = next_version;  // Update in-loop progress
            }
        }

        if done {
            batch.put::<DbMetadataSchema>(
                &S::progress_metadata_key(Some(self.shard_id)),
                &DbMetadataValue::Version(target_version),
            )?;
        }

        self.db_shard.write_schemas(batch)?;

        if done {
            break;
        }
    }

    Ok(())
}
```

## Proof of Concept

A proof of concept would require:
1. Setting up a test with state merkle pruning enabled and batch_size = 100
2. Creating stale nodes spanning multiple batches (e.g., versions 5000-6000)
3. Triggering pruning and simulating a crash after the first batch commit
4. Restarting and verifying that:
   - Per-shard progress still shows 5000
   - Nodes for versions 5000-5100 are missing
   - Queries for those versions pass min_readable_version check but fail with MissingRootError

This validates the core vulnerability: progress tracking failure causes state inconsistency after crash.

### Citations

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs (L31-56)
```rust
    pub(in crate::pruner) fn new(
        shard_id: usize,
        db_shard: Arc<DB>,
        metadata_progress: Version,
    ) -> Result<Self> {
        let progress = get_or_initialize_subpruner_progress(
            &db_shard,
            &S::progress_metadata_key(Some(shard_id)),
            metadata_progress,
        )?;
        let myself = Self {
            shard_id,
            db_shard,
            _phantom: PhantomData,
        };

        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up {} shard {shard_id}.",
            S::name(),
        );
        myself.prune(progress, metadata_progress, usize::MAX)?;

        Ok(myself)
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs (L58-100)
```rust
    pub(in crate::pruner) fn prune(
        &self,
        current_progress: Version,
        target_version: Version,
        max_nodes_to_prune: usize,
    ) -> Result<()> {
        loop {
            let mut batch = SchemaBatch::new();
            let (indices, next_version) = StateMerklePruner::get_stale_node_indices(
                &self.db_shard,
                current_progress,
                target_version,
                max_nodes_to_prune,
            )?;

            indices.into_iter().try_for_each(|index| {
                batch.delete::<JellyfishMerkleNodeSchema>(&index.node_key)?;
                batch.delete::<S>(&index)
            })?;

            let mut done = true;
            if let Some(next_version) = next_version {
                if next_version <= target_version {
                    done = false;
                }
            }

            if done {
                batch.put::<DbMetadataSchema>(
                    &S::progress_metadata_key(Some(self.shard_id)),
                    &DbMetadataValue::Version(target_version),
                )?;
            }

            self.db_shard.write_schemas(batch)?;

            if done {
                break;
            }
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L44-60)
```rust
pub(crate) fn get_or_initialize_subpruner_progress(
    sub_db: &DB,
    progress_key: &DbMetadataKey,
    metadata_progress: Version,
) -> Result<Version> {
    Ok(
        if let Some(v) = sub_db.get::<DbMetadataSchema>(progress_key)? {
            v.expect_version()
        } else {
            sub_db.put::<DbMetadataSchema>(
                progress_key,
                &DbMetadataValue::Version(metadata_progress),
            )?;
            metadata_progress
        },
    )
}
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L76-90)
```rust
        while progress < target_version {
            if let Some(target_version_for_this_round) = self
                .metadata_pruner
                .maybe_prune_single_version(progress, target_version)?
            {
                self.prune_shards(progress, target_version_for_this_round, batch_size)?;
                progress = target_version_for_this_round;
                info!(name = S::name(), progress = progress);
                self.record_progress(target_version_for_this_round);
            } else {
                self.prune_shards(progress, target_version, batch_size)?;
                self.record_progress(target_version);
                break;
            }
        }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L168-189)
```rust
    fn prune_shards(
        &self,
        current_progress: Version,
        target_version: Version,
        batch_size: usize,
    ) -> Result<()> {
        THREAD_MANAGER
            .get_background_pool()
            .install(|| {
                self.shard_pruners.par_iter().try_for_each(|shard_pruner| {
                    shard_pruner
                        .prune(current_progress, target_version, batch_size)
                        .map_err(|err| {
                            anyhow!(
                                "Failed to prune state merkle shard {}: {err}",
                                shard_pruner.shard_id(),
                            )
                        })
                })
            })
            .map_err(Into::into)
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L191-217)
```rust
    pub(in crate::pruner::state_merkle_pruner) fn get_stale_node_indices(
        state_merkle_db_shard: &DB,
        start_version: Version,
        target_version: Version,
        limit: usize,
    ) -> Result<(Vec<StaleNodeIndex>, Option<Version>)> {
        let mut indices = Vec::new();
        let mut iter = state_merkle_db_shard.iter::<S>()?;
        iter.seek(&StaleNodeIndex {
            stale_since_version: start_version,
            node_key: NodeKey::new_empty_path(0),
        })?;

        let mut next_version = None;
        while indices.len() < limit {
            if let Some((index, _)) = iter.next().transpose()? {
                next_version = Some(index.stale_since_version);
                if index.stale_since_version <= target_version {
                    indices.push(index);
                    continue;
                }
            }
            break;
        }

        Ok((indices, next_version))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L273-303)
```rust
    pub(super) fn error_if_state_merkle_pruned(
        &self,
        data_type: &str,
        version: Version,
    ) -> Result<()> {
        let min_readable_version = self
            .state_store
            .state_db
            .state_merkle_pruner
            .get_min_readable_version();
        if version >= min_readable_version {
            return Ok(());
        }

        let min_readable_epoch_snapshot_version = self
            .state_store
            .state_db
            .epoch_snapshot_pruner
            .get_min_readable_version();
        if version >= min_readable_epoch_snapshot_version {
            self.ledger_db.metadata_db().ensure_epoch_ending(version)
        } else {
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs (L62-64)
```rust
    fn get_min_readable_version(&self) -> Version {
        self.min_readable_version.load(Ordering::SeqCst)
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L732-741)
```rust
            let next_node = self
                .reader
                .get_node_with_tag(&next_node_key, "get_proof")
                .map_err(|err| {
                    if nibble_depth == 0 {
                        AptosDbError::MissingRootError(version)
                    } else {
                        err
                    }
                })?;
```
