# Audit Report

## Title
Permanent Account Lockout via Unvalidated Key Rotation in `rotate_authentication_key_from_public_key`

## Summary
The `rotate_authentication_key_from_public_key` function accepts cryptographically invalid Ed25519 public keys without validation, enabling permanent account lockout and frozen funds. The function's documentation promises validation but the implementation only checks key length, violating the specification and creating an irreversible security failure.

## Finding Description

The vulnerability exists in the `rotate_authentication_key_from_public_key` entry function, which explicitly documents that it "will abort if the scheme is not recognized or if new_public_key_bytes is not a valid public key for the given scheme." [1](#0-0) 

However, the implementation contradicts this specification. For `ED25519_SCHEME`, it uses `ed25519::new_unvalidated_public_key_from_bytes`, which only validates length: [2](#0-1) 

The `new_unvalidated_public_key_from_bytes` function only checks that the input is exactly 32 bytes, with no cryptographic validation: [3](#0-2) 

This allows users to rotate to invalid Ed25519 public keys (e.g., all zeros, small-order points, or invalid curve points). The authentication key is derived and stored on-chain without validation.

**Attack Path:**

When the user attempts future transactions, signature verification uses strict cryptographic checks. The `verify_arbitrary_msg` function explicitly validates both signature and public key for small subgroup attacks: [4](#0-3) 

The Rust implementation calls `verify_strict`, which validates the public key cryptographically and rejects invalid keys. Test evidence confirms this behavior - `verify_strict` explicitly fails for small-order public keys: [5](#0-4) 

During transaction validation, the prologue requires the transaction's authentication key to match the stored on-chain authentication key: [6](#0-5) 

Since the stored authentication key is derived from the invalid public key, users must provide the same invalid public key in transactions. However, `verify_strict` will always reject signatures with invalid public keys, resulting in permanent account lockout.

**Recovery:** Recovery is only possible if the user previously delegated rotation capability. The `rotate_authentication_key_with_rotation_capability` function properly validates keys because it requires a valid signature from the new key: [7](#0-6) 

This breaks fundamental security guarantees:
- **Specification-Implementation Mismatch**: Function promises validation but doesn't perform it
- **Cryptographic Correctness**: System accepts cryptographically invalid authentication keys
- **Access Control Invariant**: Users permanently lose access to their accounts and funds

## Impact Explanation

This qualifies as **Critical Severity** under the Aptos bug bounty program's "Permanent Freezing of Funds" category.

**Impact:**
- **Permanent Account Lockout**: Users cannot sign any future transactions with the invalid authentication key
- **Frozen Funds**: All assets in the account become permanently inaccessible
- **No Standard Recovery**: Without pre-delegated rotation capability (which most users don't set up), there is no recovery mechanism without a hardfork
- **Protocol Violation**: Violates the documented guarantee that valid public keys are required

While this affects individual accounts rather than network consensus or liveness, it represents a critical failure in the account authentication system that can result in irreversible loss of user funds.

## Likelihood Explanation

**Likelihood: Medium**

While this requires the account owner to call the function with invalid key bytes, several realistic scenarios make this exploitable:

1. **Wallet Implementation Bugs**: A bug in wallet software's key generation or encoding logic could produce invalid 32-byte sequences that pass length checks but fail cryptographic validation

2. **API Misuse**: Developers integrating Aptos APIs might not understand that `ED25519_SCHEME` requires valid Ed25519 public keys, leading to incorrect key bytes being passed

3. **Malicious Temporary Access**: An attacker with temporary access to an account's signer could permanently lock the account as a denial-of-service attack

4. **User Error**: Users manually constructing transactions or copying key bytes could introduce errors

The function was designed to support non-standard key algorithms that cannot produce standard proofs-of-knowledge: [8](#0-7) 

However, this legitimate use case inadvertently created a vulnerability for standard Ed25519 keys by skipping cryptographic validation.

## Recommendation

Replace `ed25519::new_unvalidated_public_key_from_bytes` with `ed25519::new_validated_public_key_from_bytes` for `ED25519_SCHEME` to enforce cryptographic validation: [9](#0-8) 

The validated version uses the native `public_key_validate_internal` function that performs proper cryptographic checks: [10](#0-9) 

This ensures the function's behavior matches its documented specification and prevents permanent account lockout.

## Proof of Concept

A complete PoC would demonstrate:
1. Creating an account
2. Calling `rotate_authentication_key_from_public_key` with invalid Ed25519 public key bytes (e.g., 32 zero bytes)
3. Attempting to sign a subsequent transaction
4. Observing signature verification failure due to `verify_strict` rejecting the invalid public key
5. Confirming the account is permanently locked

The vulnerability is confirmed by the code paths documented above, showing the specification-implementation mismatch and the strict validation during transaction verification that causes permanent lockout.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L452-462)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    ///
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
    /// `set_originating_address()`.
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L464-468)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key from a given public key.
    /// This function will abort if the scheme is not recognized or if new_public_key_bytes is not a valid public key for the given scheme.
    ///
    /// Note: This function does not update the `OriginatingAddress` table.
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L473-476)
```text
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1015-1040)
```text
    fun assert_valid_rotation_proof_signature_and_get_auth_key(
        scheme: u8,
        public_key_bytes: vector<u8>,
        signature: vector<u8>,
        challenge: &RotationProofChallenge
    ): vector<u8> {
        if (scheme == ED25519_SCHEME) {
            let pk = ed25519::new_unvalidated_public_key_from_bytes(public_key_bytes);
            let sig = ed25519::new_signature_from_bytes(signature);
            assert!(
                ed25519::signature_verify_strict_t(&sig, &pk, *challenge),
                std::error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)
            );
            ed25519::unvalidated_public_key_to_authentication_key(&pk)
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let pk = multi_ed25519::new_unvalidated_public_key_from_bytes(public_key_bytes);
            let sig = multi_ed25519::new_signature_from_bytes(signature);
            assert!(
                multi_ed25519::signature_verify_strict_t(&sig, &pk, *challenge),
                std::error::invalid_argument(EINVALID_PROOF_OF_KNOWLEDGE)
            );
            multi_ed25519::unvalidated_public_key_to_authentication_key(&pk)
        } else {
            abort error::invalid_argument(EINVALID_SCHEME)
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L72-76)
```text
    /// Parses the input 32 bytes as an *unvalidated* Ed25519 public key.
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(bytes.length() == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L78-87)
```text
    /// Parses the input 32 bytes as a *validated* Ed25519 public key.
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (public_key_validate_internal(bytes)) {
            option::some(ValidatedPublicKey {
                bytes
            })
        } else {
            option::none<ValidatedPublicKey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L209-212)
```text
    /// Return `true` if the bytes in `public_key` can be parsed as a valid Ed25519 public key: i.e., it passes
    /// points-on-curve and not-in-small-subgroup checks.
    /// Returns `false` otherwise.
    native fun public_key_validate_internal(bytes: vector<u8>): bool;
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L121-140)
```rust
    /// Checks that `self` is valid for an arbitrary &[u8] `message` using `public_key`.
    /// Outside of this crate, this particular function should only be used for native signature
    /// verification in Move.
    ///
    /// This function will check both the signature and `public_key` for small subgroup attacks.
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &Ed25519PublicKey) -> Result<()> {
        // NOTE: ed25519::PublicKey::verify_strict already checks that the s-component of the signature
        // is not mauled, but does so via an optimistic path which fails into a slower path. By doing
        // our own (much faster) checking here, we can ensure dalek's optimistic path always succeeds
        // and the slow path is never triggered.
        Ed25519Signature::check_s_malleability(&self.to_bytes())?;

        // NOTE: ed25519::PublicKey::verify_strict checks that the signature's R-component and
        // the public key are *not* in a small subgroup.
        public_key
            .0
            .verify_strict(message, &self.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
    }
```

**File:** crates/aptos-crypto/src/unit_tests/ed25519_test.rs (L461-499)
```rust
    // Test against known small subgroup public keys.
    #[allow(non_snake_case)]
    #[test]
    fn test_publickey_smallorder((R, A, m) in small_order_pk_with_adversarial_message()) {
        let pk_bytes = A.compress().to_bytes();

        // We expect from_bytes to pass in ed25519_dalek, as it does not validate the PK.
        let pk_dalek = ed25519_dalek::PublicKey::from_bytes(&pk_bytes);
        prop_assert!(pk_dalek.is_ok());
        let pk_dalek = pk_dalek.unwrap();

        // We expect from_bytes_unchecked to pass, as it does not validate the PK.
        let pk = Ed25519PublicKey::from_bytes_unchecked(&pk_bytes);
        prop_assert!(pk.is_ok());
        let pk = pk.unwrap();

        // Ensure the order of the PK is small
        prop_assert!(EIGHT_TORSION.len() <= 8);
        prop_assert!(eight_torsion_order(A) <= EIGHT_TORSION.len());

        // Verification checks sB - hA = R. We set s = 0, and we get R + hA = Identity. We set R to
        // be a small order element, and all we have to do is find a message with any hash h such
        // that R + hA = Identity.
        let s = Scalar::zero();

        let sig_bytes : Vec<u8> = [R.compress().to_bytes(), s.to_bytes()].concat();
        let sig_dalek = ed25519_dalek::Signature::from_bytes(&sig_bytes).unwrap();

        // We expect ed25519-dalek verify to succeed
        prop_assert!(pk_dalek.verify(signing_message(&m).unwrap().as_ref(), &sig_dalek).is_ok());

        // We expect ed25519-dalek verify_strict to fail
        prop_assert!(pk_dalek.verify_strict(signing_message(&m).unwrap().as_ref(), &sig_dalek).is_err());

        // We expect our own validation to fail in Ed25519Signature::verify_arbitrary_msg, since it
        // calls ed25519-dalek's verify_strict
        let sig = Ed25519Signature::from_bytes_unchecked(sig_bytes.as_ref()).unwrap();
        prop_assert!(pk.verify_struct_signature(&m, &sig).is_err());
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L149-167)
```text
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };
```
