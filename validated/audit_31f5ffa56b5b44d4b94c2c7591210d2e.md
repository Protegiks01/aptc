Based on my thorough analysis of the Aptos Core codebase, I have validated this security claim and found it to be **VALID**.

# Audit Report

## Title
Missing Epoch Boundary Validation in Response Processing Allows State Desynchronization via Malicious Peer Responses

## Summary
The epoch ending ledger info response handling in the data streaming service fails to validate that received epochs match the requested range. A malicious network peer can send extra epochs beyond the requested boundary, causing desynchronization between the stream engine's epoch tracking and the bootstrapper's verified epoch state, leading to subsequent verification failures that prevent nodes from completing synchronization.

## Finding Description

The vulnerability exists in the response validation logic where the stream engine and bootstrapper handle epoch ending ledger info responses differently:

The stream engine creates requests with specific epoch ranges defined by `start_epoch` and `end_epoch` parameters [1](#0-0) . While the server validates these parameters [2](#0-1) , a malicious peer running modified software can bypass its own validation and send responses containing more epochs than requested.

When processing responses, the stream engine extracts the last epoch from the response and silently clamps it using `bound_by_range()` [3](#0-2) [4](#0-3) . This function does not reject invalid responses but instead bounds the value to the requested range for tracking purposes.

Meanwhile, the bootstrapper processes **ALL** epoch ending ledger infos present in the response [5](#0-4) . For each ledger info, it performs cryptographic verification using `latest_epoch_state.verify()` [6](#0-5)  and then updates `latest_epoch_state` to the next epoch [7](#0-6) .

The only validation performed on responses is a type check that confirms the payload type matches the request type, with an explicit comment stating "No other sanity checks are done" [8](#0-7) .

**Attack Scenario:**
1. Stream engine requests epochs 6-10, sets `next_stream_epoch = 6`
2. Malicious peer sends epochs 6-13 (4 extra epochs)
3. Stream engine bounds last epoch: `bound_by_range(13, 6, 10) = 10`, updates `next_stream_epoch = 11`
4. Bootstrapper processes all epochs 6-13, advancing `latest_epoch_state` to epoch 14
5. Stream engine creates next request for epochs 11-15
6. When epoch 11 arrives, bootstrapper attempts verification using epoch 14's validator set instead of epoch 10's validators, causing verification failure
7. Stream resets with `PayloadProofFailed` feedback [9](#0-8) 
8. Attack repeatable, preventing successful synchronization

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" and "significant protocol violations" categories because:

- **Prevents Epoch Synchronization**: Affected nodes cannot complete epoch transitions, remaining perpetually stuck in failed verification loops
- **Validator Participation Impact**: Validator nodes unable to sync cannot participate in consensus, degrading network performance
- **Widespread Availability Attack**: Attackers can target multiple nodes simultaneously using different peer identities
- **No Direct Consensus Safety Violation**: While severe, this does not enable double-spending, fund theft, or consensus splits

The impact aligns with High severity rather than Critical because it affects availability and synchronization but does not compromise consensus safety, enable fund theft, or cause permanent state corruption.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is readily exploitable because:

**Low Barrier to Entry:**
- Any actor can run a network peer node
- No special privileges or stake required
- Attacker can bypass server-side validation in their own node software

**Readily Available Attack Materials:**
- Historical epoch ending ledger infos are public blockchain data
- These ledger infos are already cryptographically signed by validators
- No need to forge signatures or break cryptography

**Repeatable Attack Vector:**
- Attack can target any syncing node
- Attacker can use multiple peer identities to evade reputation system
- While peer reputation scoring exists [10](#0-9) , the attack succeeds multiple times before peer banning

**Realistic Attack Scenario:**
- Occurs during normal network operations when nodes sync
- No precise timing requirements
- Can be executed persistently during network adversarial conditions

## Recommendation

Add explicit validation in the stream engine's response handler to verify that all epoch ending ledger infos in the response fall within the requested range:

```rust
// In EpochEndingStreamEngine::transform_client_response_into_notification
let last_received_epoch = match &client_response_payload {
    ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
        // Verify that we received at least one ledger info
        if ledger_infos.is_empty() {
            return Err(Error::AptosDataClientResponseIsInvalid(...));
        }

        // NEW: Validate all epochs are within requested range
        for ledger_info in ledger_infos {
            let epoch = ledger_info.ledger_info().epoch();
            if epoch < request.start_epoch || epoch > request.end_epoch {
                return Err(Error::AptosDataClientResponseIsInvalid(format!(
                    "Received epoch {} outside requested range [{}, {}]",
                    epoch, request.start_epoch, request.end_epoch
                )));
            }
        }

        // Return the last epoch
        ledger_infos.last().map(|ledger_info| ledger_info.ledger_info().epoch())
            .unwrap_or(request.start_epoch)
    },
    _ => invalid_response_type!(client_response_payload),
};
```

Additionally, consider rejecting responses immediately in `sanity_check_client_response_type` or adding a separate validation function for content-level checks beyond type matching.

## Proof of Concept

While a full executable PoC requires setting up a malicious peer node, the vulnerability can be demonstrated through the following conceptual test:

```rust
// Conceptual test demonstrating the desynchronization
#[test]
fn test_epoch_boundary_desynchronization() {
    // 1. Initialize stream engine with next_stream_epoch = 6, end_epoch = 15
    // 2. Create request for epochs 6-10
    // 3. Simulate malicious peer response with epochs 6-13
    // 4. Process response:
    //    - Stream engine bounds last epoch to 10, sets next_stream_epoch = 11
    //    - Bootstrapper processes all epochs 6-13, latest_epoch_state = 14
    // 5. Create next request for epochs 11-15
    // 6. Attempt to verify epoch 11 using latest_epoch_state (epoch 14)
    // Expected: Verification fails with PayloadProofFailed
}
```

The vulnerability is confirmed through code analysis showing the desynchronization between stream engine tracking and bootstrapper state management as documented in the citations above.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L318-322)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct EpochEndingLedgerInfoRequest {
    pub start_epoch: u64,        // The epoch to start at
    pub expected_end_epoch: u64, // The epoch to finish at
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1007-1034)
```rust
    fn check_epoch_ending_ledger_infos_request(
        &self,
        start_epoch: u64,
        end_epoch: u64,
    ) -> Result<()> {
        ensure!(
            start_epoch <= end_epoch,
            "Bad epoch range [{}, {})",
            start_epoch,
            end_epoch,
        );
        // Note that the latest epoch can be the same with the current epoch (in most cases), or
        // current_epoch + 1 (when the latest ledger_info carries next validator set)

        let latest_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info()?
            .ledger_info()
            .next_block_epoch();
        ensure!(
            end_epoch <= latest_epoch,
            "Unable to provide epoch change ledger info for still open epoch. asked upper bound: {}, last sealed epoch: {}",
            end_epoch,
            latest_epoch - 1,  // okay to -1 because genesis LedgerInfo has .next_block_epoch() == 1
        );
        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L1603-1628)
```rust
                // Identify the last received epoch and bound it appropriately
                let last_received_epoch = match &client_response_payload {
                    ResponsePayload::EpochEndingLedgerInfos(ledger_infos) => {
                        // Verify that we received at least one ledger info
                        if ledger_infos.is_empty() {
                            return Err(Error::AptosDataClientResponseIsInvalid(format!(
                                "Received an empty epoch ending ledger info response! Request: {:?}",
                                client_request
                            )));
                        }

                        // Return the last epoch
                        ledger_infos
                            .last()
                            .map(|ledger_info| ledger_info.ledger_info().epoch())
                            .unwrap_or(request.start_epoch)
                    },
                    _ => invalid_response_type!(client_response_payload),
                };
                let last_received_epoch =
                    bound_by_range(last_received_epoch, request.start_epoch, request.end_epoch);

                // Update the local stream notification tracker
                self.next_stream_epoch = last_received_epoch.checked_add(1).ok_or_else(|| {
                    Error::IntegerOverflow("Next stream epoch has overflown!".into())
                })?;
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L2005-2007)
```rust
pub(crate) fn bound_by_range(number: u64, min: u64, max: u64) -> u64 {
    number.clamp(min, max)
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L103-108)
```rust
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L111-115)
```rust
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1094-1106)
```rust
        for epoch_ending_ledger_info in epoch_ending_ledger_infos {
            if let Err(error) = self.verified_epoch_states.update_verified_epoch_states(
                &epoch_ending_ledger_info,
                &self.driver_configuration.waypoint,
            ) {
                self.reset_active_stream(Some(NotificationAndFeedback::new(
                    notification_id,
                    NotificationFeedback::PayloadProofFailed,
                )))
                .await?;
                return Err(error);
            }
        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1290-1302)
```rust
/// Returns true iff the data client response payload type matches the
/// expected type of the original request. No other sanity checks are done.
fn sanity_check_client_response_type(
    data_client_request: &DataClientRequest,
    data_client_response: &Response<ResponsePayload>,
) -> bool {
    match data_client_request {
        DataClientRequest::EpochEndingLedgerInfos(_) => {
            matches!(
                data_client_response.payload,
                ResponsePayload::EpochEndingLedgerInfos(_)
            )
        },
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    global_summary::{AdvertisedData, GlobalDataSummary, OptimalChunkSizes},
    interface::ResponseError,
    logging::{LogEntry, LogEvent, LogSchema},
    metrics,
};
use aptos_config::{
    config::AptosDataClientConfig,
    network_id::{NetworkId, PeerNetworkId},
};
use aptos_logger::prelude::*;
use aptos_storage_service_types::{
    requests::StorageServiceRequest, responses::StorageServerSummary,
};
use aptos_time_service::TimeService;
use dashmap::DashMap;
use std::{
    cmp::min,
    collections::{BTreeMap, HashSet},
    sync::Arc,
    time::Duration,
};

// Useful constants
const LOGS_FREQUENCY_SECS: u64 = 120; // 2 minutes
const METRICS_FREQUENCY_SECS: u64 = 15; // 15 seconds
const NUM_PEER_BUCKETS_FOR_METRICS: u8 = 4; // To avoid metric explosion, we bucket peers into groups

/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
```
