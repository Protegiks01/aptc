# Audit Report

## Title
Batch Retrieval Handler Panic on V2 Batches Causes Validator Service Disruption

## Summary
The batch retrieval RPC handler in the quorum store builder contains a critical flaw where it unconditionally attempts to convert all retrieved batches from V2-compatible format (`Batch<BatchInfoExt>`) to V1-only format (`Batch<BatchInfo>`), causing a panic when V2 batches are encountered. This crashes the batch serving task and prevents validators from serving batches to peers.

## Finding Description
The vulnerability exists in the batch retrieval RPC handler task that processes incoming batch requests from network peers. When a batch request is received, the handler retrieves the batch from local storage and attempts to serve it to the requesting peer.

The critical flaw occurs in the response preparation logic. The handler retrieves batches using `get_batch_from_local()` which returns `PersistedValue<BatchInfoExt>`. The `BatchInfoExt` enum supports both V1 and V2 batch formats, where V2 includes additional metadata. [1](#0-0) 

However, the handler unconditionally converts all batches to V1 format using `.try_into().expect("Batch retieval requests must be for V1 batch")`: [2](#0-1) 

This conversion is implemented with a strict validation that explicitly rejects V2 batches: [3](#0-2) 

When `enable_batch_v2=true` is configured, validators create and store V2 batches locally: [4](#0-3) [5](#0-4) 

These V2 batches are persisted to the database: [6](#0-5) 

When another validator requests such a batch, `get_batch_from_local()` retrieves the V2 batch: [7](#0-6) 

The conversion then fails with error "Batch must be V1 type", causing the `.expect()` to panic. This crashes the `batch_serve` async task, permanently disabling the validator's ability to serve batches to peers until the validator is restarted.

Notably, the codebase already defines a `BatchResponse::BatchV2` variant for proper V2 support: [8](#0-7) 

However, the client-side code marks it as unsupported: [9](#0-8) 

This indicates the infrastructure exists for V2 responses but the server-side implementation incorrectly forces all batches to V1 format instead of using the appropriate response variant.

## Impact Explanation
This vulnerability meets **High Severity** criteria according to Aptos bug bounty guidelines:

**Validator Node Slowdowns/Service Disruption**: The panic directly crashes the batch serving task, which is a critical component of the quorum store protocol. Once crashed, the validator cannot serve batches to other validators, degrading its functionality and consensus participation.

**Significant Protocol Violations**: The quorum store protocol assumes validators can retrieve batches from peers when needed. This vulnerability breaks that assumption, causing protocol-level failures during normal operations.

The impact is particularly severe during:
- Protocol upgrades when V2 batch support is being rolled out
- Mixed-configuration networks where some validators have `enable_batch_v2=true`
- Any scenario where V2 batches have been stored locally

This aligns with the High severity definition of "Validator node slowdowns" and "Significant protocol violations" in the Aptos bug bounty program.

## Likelihood Explanation
The likelihood is **HIGH** because:

1. **Natural Occurrence During Upgrades**: When the network upgrades to enable V2 batch support, validators with `enable_batch_v2=true` will automatically create and store V2 batches. Other validators requesting these batches will trigger the panic.

2. **No Special Privileges Required**: Any validator in the network can trigger this vulnerability simply by requesting a batch that happens to be V2 format. This is part of normal consensus operations.

3. **Mixed-Version Network Scenarios**: In any deployment with mixed configurations (some validators with V2 enabled, others disabled), this will occur during normal batch retrieval operations.

4. **No Protection Mechanisms**: There is no validation or graceful error handling to prevent the panic. The code assumes all batches are V1 format despite V2 batches being stored in the same storage layer.

The developer comment "Batch retieval requests must be for V1 batch" suggests an incorrect assumption that batch retrieval would only handle V1 batches, but there's no enforcement mechanism ensuring this assumption holds in production.

## Recommendation
The batch retrieval handler should properly handle both V1 and V2 batch formats. Two potential fixes:

**Option 1: Support BatchV2 Responses** (Preferred)
```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    if batch.batch_info().is_v2() {
        BatchResponse::BatchV2(batch)
    } else {
        let batch: Batch<BatchInfo> = batch.try_into()
            .expect("V1 batch conversion should succeed");
        BatchResponse::Batch(batch)
    }
} else {
    // ... NotFound case
};
```

And update client-side code to properly handle `BatchV2` responses instead of logging an error.

**Option 2: Graceful Degradation**
```rust
let response = if let Ok(value) = batch_store.get_batch_from_local(&rpc_request.req.digest()) {
    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
    match batch.try_into() {
        Ok(batch) => BatchResponse::Batch(batch),
        Err(_) => {
            // V2 batch - return NotFound for backward compatibility
            match aptos_db_clone.get_latest_ledger_info() {
                Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
                Err(e) => {
                    error!("Failed to get ledger info: {:?}", e);
                    continue;
                }
            }
        }
    }
} else {
    // ... NotFound case
};
```

## Proof of Concept
```rust
// Test demonstrating the panic scenario
#[tokio::test]
async fn test_batch_retrieval_v2_panic() {
    // Setup: Create a validator with enable_batch_v2=true
    let mut config = QuorumStoreConfig::default();
    config.enable_batch_v2 = true;
    
    // Create and store a V2 batch
    let batch = Batch::new_v2(
        batch_id,
        txns,
        epoch,
        expiry_time,
        peer_id,
        bucket_start,
        BatchKind::Normal,
    );
    batch_store.persist(vec![batch.into()]);
    
    // Another validator requests this batch
    let request = BatchRequest::new(requesting_peer, epoch, digest);
    
    // This will panic in the batch_serve task:
    // thread 'batch_serve' panicked at 'Batch retieval requests must be for V1 batch'
    // Expected: Should return BatchResponse::BatchV2 or handle gracefully
}
```

**Notes**
- The vulnerability affects the consensus layer's quorum store component, which is critical for validator operations
- This is a protocol-level bug, not a network DoS attack - it exploits incorrect version handling logic
- The fix requires coordination between server and client implementations to properly support V2 batch responses
- The default configuration has `enable_batch_v2=false`, but enabling it during upgrades will trigger this vulnerability

### Citations

**File:** consensus/consensus-types/src/proof_of_store.rs (L195-203)
```rust
pub enum BatchInfoExt {
    V1 {
        info: BatchInfo,
    },
    V2 {
        info: BatchInfo,
        extra: ExtraBatchInfo,
    },
}
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L408-415)
```rust
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** consensus/src/quorum_store/types.rs (L336-353)
```rust
impl TryFrom<Batch<BatchInfoExt>> for Batch<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(batch: Batch<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(batch.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let Batch {
            batch_info,
            payload,
        } = batch;
        Ok(Self {
            batch_info: batch_info.unpack_info(),
            payload,
        })
    }
}
```

**File:** consensus/src/quorum_store/types.rs (L417-421)
```rust
pub enum BatchResponse {
    Batch(Batch<BatchInfo>),
    NotFound(LedgerInfoWithSignatures),
    BatchV2(Batch<BatchInfoExt>),
}
```

**File:** consensus/src/quorum_store/batch_generator.rs (L190-210)
```rust
        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** consensus/src/quorum_store/batch_store.rs (L508-513)
```rust
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L571-585)
```rust
    pub(crate) fn get_batch_from_local(
        &self,
        digest: &HashValue,
    ) -> ExecutorResult<PersistedValue<BatchInfoExt>> {
        if let Some(value) = self.db_cache.get(digest) {
            if value.payload_storage_mode() == StorageMode::PersistedOnly {
                self.get_batch_from_db(digest, value.batch_info().is_v2())
            } else {
                // Available in memory.
                Ok(value.clone())
            }
        } else {
            Err(ExecutorError::CouldNotGetData)
        }
    }
```

**File:** consensus/src/quorum_store/batch_requester.rs (L153-155)
```rust
                            Ok(BatchResponse::BatchV2(_)) => {
                                error!("Batch V2 response is not supported");
                            }
```
