# Audit Report

## Title
Silent RPC Failure in Secret Share Manager Causes Indefinite Retries and Resource Exhaustion

## Summary
When a validator receives a secret share request (`RequestShare` RPC) but doesn't have the requested share available, it logs a warning but fails to send any response to the requesting validator. This causes the requester's RPC to timeout after 10 seconds and triggers infinite retry attempts with exponential backoff, wasting network bandwidth and potentially delaying consensus progress.

## Finding Description

The vulnerability exists in the `handle_incoming_msg()` function where secret share requests are processed. When a validator cannot find the requested share in its local store, two problematic scenarios occur: [1](#0-0) 

In both the `Ok(None)` case (share not found) and the `Err(e)` case (validation error), only a warning is logged and the `response_sender` oneshot channel is never used to send a response back to the requester. This violates the RPC contract where responses must always be sent.

**When does this occur?**

The most common scenario happens during validator initialization or epoch transitions. When a `SecretShareManager` starts, it receives the `highest_committed_round` parameter and immediately sets its internal `highest_known_round` to this value: [2](#0-1) 

At this point, the `secret_share_map` is empty (new manager instance): [3](#0-2) 

The validator will accept share requests for any round up to `highest_committed_round`. When such a request arrives, the future-round validation check passes: [4](#0-3) 

But the map lookup returns `None`: [5](#0-4) 

The function returns `Ok(None)`, triggering the silent failure path in `handle_incoming_msg()`.

**What happens on the requester's side?**

The requesting validator uses `ReliableBroadcast` to send the RPC with a configured timeout: [6](#0-5) [7](#0-6) 

When no response is received within 10 seconds, the RPC protocol layer times out and returns an error. The `ReliableBroadcast` system treats this as a transient failure and retries indefinitely with exponential backoff: [8](#0-7) 

The `.expect("should produce value")` indicates the backoff iterator never returns `None`, meaning infinite retries. With the configured backoff parameters (base=2ms, factor=100, max_delay=10s), the retry pattern becomes:
- First retry: wait 200ms, timeout after 10s
- Second retry: wait ~400ms, timeout after 10s
- Subsequent retries: eventually capped at 10s delay, timeout after 10s (20s cycle)

This continues until either the target validator processes the block and generates the share, or enough other validators respond to meet the reconstruction threshold: [9](#0-8) 

## Impact Explanation

This issue qualifies as **Medium Severity** per the Aptos bug bounty criteria under "Limited Protocol Violations - Temporary liveness issues":

1. **Resource Exhaustion**: Each failed RPC wastes 10 seconds of waiting time plus network bandwidth. With multiple validators experiencing this issue simultaneously during epoch transitions or coordinated restarts, the cumulative waste is significant.

2. **Consensus Delays**: Secret share aggregation is critical for randomness generation in consensus. Repeated timeouts delay block finalization, reducing network throughput and increasing latency during critical operational periods.

3. **Potential Liveness Impact**: If more than `n - t` validators are missing shares (where `n` is total validators and `t` is threshold), the aggregation can never complete, effectively blocking consensus progress until validators process blocks or are manually recovered.

4. **Silent Failure**: The lack of explicit error responses makes this issue difficult to diagnose and monitor in production environments, compounding operational challenges.

The impact is limited to performance degradation and resource waste under normal conditions, but can escalate to temporary liveness issues under specific circumstances (multiple simultaneous validator restarts, epoch transitions with network delays).

## Likelihood Explanation

**High Likelihood** - This issue will manifest in production with high probability:

1. **Validator Restarts**: Common operational events like upgrades, crashes, or configuration changes trigger the vulnerable code path whenever a `SecretShareManager` is reinitialized with `highest_known_round` set but `secret_share_map` empty.

2. **Epoch Transitions**: Every epoch change creates a new `SecretShareManager` instance, exposing the vulnerability window where incoming requests for recent rounds cannot be fulfilled.

3. **No Attack Required**: This is a protocol bug that occurs during normal operation without any malicious actor involvement.

4. **Deterministic Trigger**: The vulnerability occurs deterministically whenever the specific conditions are met (initialized manager receiving requests for valid but unprocessed rounds).

## Recommendation

Send an explicit error response when a share cannot be found or validation fails. Modify the `handle_incoming_msg()` function:

```rust
SecretShareMessage::RequestShare(request) => {
    let result = self
        .secret_share_store
        .lock()
        .get_self_share(request.metadata());
    match result {
        Ok(Some(share)) => {
            self.process_response(
                protocol,
                response_sender,
                SecretShareMessage::Share(share),
            );
        },
        Ok(None) => {
            warn!(
                "Self secret share could not be found for RPC request {}",
                request.metadata().round
            );
            // Send error response instead of silent failure
            let _ = response_sender.send(Err(RpcError::ApplicationError(
                format!("Share not available for round {}", request.metadata().round).into()
            )));
        },
        Err(e) => {
            warn!("[SecretShareManager] Failed to get share: {}", e);
            // Send error response instead of silent failure
            let _ = response_sender.send(Err(RpcError::ApplicationError(
                format!("Share validation failed: {}", e).into()
            )));
        },
    }
},
```

This allows the requester to immediately know the share is unavailable and avoid unnecessary retries for that specific validator.

## Proof of Concept

The vulnerability can be observed by:

1. Starting a validator node and initializing `SecretShareManager` with `highest_known_round = 100`
2. Before any blocks are processed (so `secret_share_map` is empty)
3. Send a `RequestShare` RPC for round 50 (which is <= 100, so passes validation)
4. Observe that no response is sent (only warning logged)
5. The requesting validator's RPC times out after 10 seconds
6. Monitor network traffic to see repeated retry attempts with exponential backoff
7. Observe resource exhaustion (CPU cycles, network bandwidth, memory for pending RPCs) accumulating over time

A complete integration test would require:
- Multiple validator nodes in a test network
- Coordinated restart scenario to trigger empty `secret_share_map` with non-zero `highest_known_round`
- Network monitoring to capture timeout and retry patterns
- Measurement of consensus delays during the window when shares are unavailable

## Notes

The vulnerability is particularly impactful during epoch transitions when all validators simultaneously create new `SecretShareManager` instances, potentially causing a network-wide slowdown in secret share aggregation until validators catch up on block processing. The issue demonstrates a violation of the RPC contract principle that all requests should receive explicit responses, whether success or error.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L75-86)
```rust
        let rb_backoff_policy = ExponentialBackoff::from_millis(rb_config.backoff_policy_base_ms)
            .factor(rb_config.backoff_policy_factor)
            .max_delay(Duration::from_millis(rb_config.backoff_policy_max_delay_ms));
        let reliable_broadcast = Arc::new(ReliableBroadcast::new(
            author,
            epoch_state.verifier.get_ordered_account_addresses(),
            network_sender.clone(),
            rb_backoff_policy,
            TimeService::real(),
            Duration::from_millis(rb_config.rpc_timeout_ms),
            bounded_executor,
        ));
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L286-308)
```rust
            SecretShareMessage::RequestShare(request) => {
                let result = self
                    .secret_share_store
                    .lock()
                    .get_self_share(request.metadata());
                match result {
                    Ok(Some(share)) => {
                        self.process_response(
                            protocol,
                            response_sender,
                            SecretShareMessage::Share(share),
                        );
                    },
                    Ok(None) => {
                        warn!(
                            "Self secret share could not be found for RPC request {}",
                            request.metadata().round
                        );
                    },
                    Err(e) => {
                        warn!("[SecretShareManager] Failed to get share: {}", e);
                    },
                }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L336-340)
```rust
        {
            self.secret_share_store
                .lock()
                .update_highest_known_round(highest_known_round);
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L217-231)
```rust
    pub fn new(
        epoch: u64,
        author: Author,
        dec_config: SecretShareConfig,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Self {
        Self {
            epoch,
            self_author: author,
            secret_share_config: dec_config,
            secret_share_map: HashMap::new(),
            highest_known_round: 0,
            decision_tx,
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L288-297)
```rust
    pub fn get_self_share(
        &mut self,
        metadata: &SecretShareMetadata,
    ) -> anyhow::Result<Option<SecretShare>> {
        ensure!(
            metadata.round <= self.highest_known_round,
            "Request share from future round {}, highest known round {}",
            metadata.round,
            self.highest_known_round
        );
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L298-303)
```rust
        Ok(self
            .secret_share_map
            .get(&metadata.round)
            .and_then(|item| item.get_self_share())
            .filter(|share| &share.metadata == metadata))
    }
```

**File:** config/src/config/consensus_config.rs (L373-378)
```rust
            rand_rb_config: ReliableBroadcastConfig {
                backoff_policy_base_ms: 2,
                backoff_policy_factor: 100,
                backoff_policy_max_delay_ms: 10000,
                rpc_timeout_ms: 10000,
            },
```

**File:** crates/reliable-broadcast/src/lib.rs (L191-200)
```rust
                            Err(e) => {
                                log_rpc_failure(e, receiver);

                                let backoff_strategy = backoff_policies
                                    .get_mut(&receiver)
                                    .expect("should be present");
                                let duration = backoff_strategy.next().expect("should produce value");
                                rpc_futures
                                    .push(send_message(receiver, Some(duration)));
                            },
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-60)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveSecretShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
        let mut store = self.secret_share_store.lock();
        let aggregated = store.add_share(share)?.then_some(());
        Ok(aggregated)
    }
```
