# Audit Report

## Title
Delta History Merge Creates Impossible Overflow-Underflow Constraint Window

## Summary
The `offset_and_merge_history()` function in `delta_math.rs` can produce a merged delta history where overflow and underflow boundaries create contradictory constraints that no base value can satisfy. This occurs because the function validates overflow and underflow boundaries independently against achieved deltas, but never checks whether the boundaries themselves are mutually compatible.

## Finding Description

The `offset_and_merge_history()` function merges two delta histories from parallel transaction executions in Aptos aggregators. [1](#0-0) 

The function performs two critical validation checks: [2](#0-1) 

These checks ensure:
1. The overflow boundary (`min_overflow_positive_delta`) is strictly greater than the achieved positive delta
2. The underflow boundary (`max_underflow_negative_delta`) is strictly greater than the achieved negative delta

However, these checks are **independent** and do not validate the interaction between overflow and underflow boundaries themselves.

For a merged history to be valid against a base value `B`, the following constraints must be satisfied: [3](#0-2) 

When both `min_overflow` and `max_underflow` exist, the validation imposes:
- From overflow (line 175): `B > max_value - min_overflow`
- From underflow (line 186): `B < max_underflow`

For any valid `B` to exist: **`max_value - min_overflow < max_underflow`**, which is equivalent to **`min_overflow + max_underflow > max_value`**

This condition is **never checked** in `offset_and_merge_history()`, allowing creation of merged histories where no valid base value exists.

**Attack Scenario:**

1. Transaction T1 executes with `prev_delta = Negative(20)` and creates `prev_history` with `max_underflow_negative_delta = Some(30)`
2. Transaction T2 executes speculatively and creates `next_history` with `min_overflow_positive_delta = Some(50)` (for max_value=100)
3. When merged with `prev_delta = Negative(20)`:
   - `new_min_overflow = 50 + (-20) = 30`
   - `new_max_underflow = 30` (from prev_history)
   - Both checks pass: `30 > 0` ✓ and `30 > 0` ✓
4. **Result:** Merged history requires `B > 70` (from `B + 30 > 100`) AND `B < 30` simultaneously - **IMPOSSIBLE!**

The merged history will **always** fail `validate_against_base_value()` for any base value, yet the merge itself succeeds without error.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This vulnerability causes:

1. **Re-execution Overhead**: Failed validations force repeated transaction re-execution, degrading parallel execution throughput
2. **Performance Degradation**: Eventually triggers the incarnation limit check, forcing fallback to sequential execution [4](#0-3) 

3. **Wasted Computational Resources**: Multiple re-execution cycles consume validator resources unnecessarily
4. **Griefing Attack Vector**: Attackers can deliberately trigger this condition to degrade network performance

While this does not cause consensus divergence (all validators experience identical behavior and fall back to sequential execution identically), it creates a denial-of-service vector through performance degradation and represents a logic error in the parallel execution validation system.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability requires:
- Parallel transaction execution on the same aggregator (common in high-throughput scenarios)
- Specific history patterns (one with overflow boundary, one with underflow boundary)
- Appropriate offset delta between transactions

These conditions occur naturally when multiple transactions interact with popular aggregators (e.g., token supply counters, fee accumulators). An attacker could deliberately craft transactions to trigger this condition by:
1. Understanding the current aggregator state
2. Submitting parallel transactions with calculated deltas
3. Exploiting the merge logic during transaction sequencing

The attack is feasible without special privileges and could be automated for repeated exploitation.

## Recommendation

Add a validation check in `offset_and_merge_history()` to ensure that when both overflow and underflow boundaries exist, they are mutually compatible:

```rust
// After computing new_min_overflow and new_max_underflow (around line 289)
if let (Some(min_overflow), Some(max_underflow)) = (new_min_overflow, new_max_underflow) {
    if min_overflow + max_underflow <= max_value {
        return Err(DelayedFieldsSpeculativeError::DeltaHistoryMergeIncompatibleBoundaries {
            min_overflow,
            max_underflow,
            max_value,
        });
    }
}
```

This ensures that merged histories can only be created if a valid base value exists that satisfies both constraints.

## Proof of Concept

```rust
#[test]
fn test_impossible_overflow_underflow_constraints() {
    use crate::bounded_math::SignedU128;
    
    let max_value = 100u128;
    
    // prev_history: valid for B in [0, 30)
    let prev_history = DeltaHistory {
        max_achieved_positive_delta: 0,
        min_achieved_negative_delta: 0,
        min_overflow_positive_delta: None,
        max_underflow_negative_delta: Some(30),
    };
    
    // next_history: valid for B > 50
    let next_history = DeltaHistory {
        max_achieved_positive_delta: 0,
        min_achieved_negative_delta: 0,
        min_overflow_positive_delta: Some(50),
        max_underflow_negative_delta: None,
    };
    
    let prev_delta = SignedU128::Negative(20);
    
    // Merge succeeds (BUG - should fail!)
    let merged = next_history.offset_and_merge_history(
        &prev_delta,
        &prev_history,
        max_value
    ).expect("Merge should succeed");
    
    // Verify merged history has impossible constraints
    assert_eq!(merged.min_overflow_positive_delta, Some(30));
    assert_eq!(merged.max_underflow_negative_delta, Some(30));
    
    // Try all possible base values - all should fail
    for base in 0..=100 {
        assert!(merged.validate_against_base_value(base, max_value).is_err(),
            "Base value {} should fail validation but didn't", base);
    }
}
```

## Notes

The core technical issue is valid: the missing validation allows creation of delta histories with mathematically impossible constraints. The built-in mitigation (incarnation limit triggering sequential fallback) prevents permanent network issues, but the vulnerability still enables performance degradation attacks and represents a logic error in the parallel execution system. The impact on consensus is minimal since all validators behave identically, but the performance implications justify Medium severity classification.

### Citations

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L148-197)
```rust
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
        math.unsigned_subtract(base_value, self.min_achieved_negative_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Negative(self.min_achieved_negative_delta),
                reason: DeltaApplicationFailureReason::Underflow,
            })?;

        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }

        if let Some(max_underflow_negative_delta) = self.max_underflow_negative_delta {
            if base_value >= max_underflow_negative_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Negative(max_underflow_negative_delta),
                    reason: DeltaApplicationFailureReason::ExpectedUnderflow,
                });
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L248-313)
```rust
    pub fn offset_and_merge_history(
        &self,
        prev_delta: &SignedU128,
        prev_history: &Self,
        max_value: u128,
    ) -> Result<DeltaHistory, DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);

        let new_min_overflow = Self::offset_and_merge_min_overflow(
            &self.min_overflow_positive_delta,
            prev_delta,
            &prev_history.min_overflow_positive_delta,
            &math,
        )?;
        // max_underflow is identical to min_overflow, except that we offset in the opposite direction.
        let new_max_underflow = Self::offset_and_merge_min_overflow(
            &self.max_underflow_negative_delta,
            &prev_delta.minus(),
            &prev_history.max_underflow_negative_delta,
            &math,
        )?;

        // new_max_achieved = max(prev_max_achieved, max_achieved + prev_delta)
        // When adjusting max_achieved, if underflow - than the other is bigger,
        // but if overflow - we fail the merge, as we cannot successfully achieve
        // delta larger than max_value.
        let new_max_achieved = Self::offset_and_merge_max_achieved(
            self.max_achieved_positive_delta,
            prev_delta,
            prev_history.max_achieved_positive_delta,
            &math,
        )?;

        // new_min_achieved = max(prev_min_achieved, min_achieved - prev_delta)
        // Same as above, except for offsetting in the opposite direction.
        let new_min_achieved = Self::offset_and_merge_max_achieved(
            self.min_achieved_negative_delta,
            &prev_delta.minus(),
            prev_history.min_achieved_negative_delta,
            &math,
        )?;

        if new_min_overflow.is_some_and(|v| v <= new_max_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Positive(new_max_achieved),
                    overflow: SignedU128::Positive(new_min_overflow.unwrap()),
                },
            );
        }
        if new_max_underflow.is_some_and(|v| v <= new_min_achieved) {
            return Err(
                DelayedFieldsSpeculativeError::DeltaHistoryMergeAchievedAndFailureOverlap {
                    achieved: SignedU128::Negative(new_min_achieved),
                    overflow: SignedU128::Negative(new_max_underflow.unwrap()),
                },
            );
        }

        Ok(Self {
            max_achieved_positive_delta: new_max_achieved,
            min_achieved_negative_delta: new_min_achieved,
            min_overflow_positive_delta: new_min_overflow,
            max_underflow_negative_delta: new_max_underflow,
        })
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1325-1332)
```rust
            if let SchedulerTask::ValidationTask(txn_idx, incarnation, _) = &scheduler_task {
                if *incarnation as usize > num_workers.pow(2) + num_txns + 30 {
                    // Something is wrong if we observe high incarnations (e.g. a bug
                    // might manifest as an execution-invalidation cycle). Break out
                    // to fallback to sequential execution.
                    error!("Observed incarnation {} of txn {txn_idx}", *incarnation);
                    return Err(PanicOr::Or(ParallelBlockExecutionError::IncarnationTooHigh));
                }
```
