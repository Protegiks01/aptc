# Audit Report

## Title
KeyRotation Event Emission Without OriginatingAddress Table Update Causes Permanent Account Recovery Failure

## Summary
Two key rotation functions (`rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account`) update account authentication keys but fail to update the `OriginatingAddress` table, breaking wallet recovery for keyless accounts. Users who rotate keys and subsequently lose their devices cannot recover their accounts through the standard SDK recovery mechanism.

## Finding Description

The Aptos account system maintains a global `OriginatingAddress` resource that maps rotated authentication keys to their original account addresses, enabling wallet recovery after key rotation. [1](#0-0) 

The standard key rotation function `rotate_authentication_key` properly maintains this mapping by calling `update_auth_key_and_originating_address_table`. [2](#0-1)  This function removes the old mapping and adds the new authentication key to original address mapping. [3](#0-2) 

However, two alternative rotation functions designed for non-standard signature schemes do NOT update the `OriginatingAddress` table:

**Vulnerable Function #1: `rotate_authentication_key_from_public_key`**

This function explicitly documents that it does not update the `OriginatingAddress` table. [4](#0-3)  The function calls `rotate_authentication_key_call` which only updates the account's authentication key field. [5](#0-4) [6](#0-5) 

**Vulnerable Function #2: `upsert_ed25519_backup_key_on_keyless_account`**

This function creates a multi-key combining the keyless public key with an ED25519 backup key, validates the backup key via RotationProofChallenge, [7](#0-6)  then calls `rotate_authentication_key_call` to update the authentication key. [8](#0-7)  Despite having proof-of-knowledge, it does NOT update the `OriginatingAddress` table.

**Critical Failure: Remediation Function is Disabled**

The documentation suggests using `set_originating_address()` as a followup. [9](#0-8)  However, this function is permanently disabled and immediately aborts. [10](#0-9)  The error constant documents this is "disabled due to potential poisoning from account abstraction". [11](#0-10) 

**Account Recovery Mechanism Breaks**

The `originating_address()` view function returns `option::none()` when the mapping doesn't exist. [12](#0-11) 

The wallet SDK's `derive_keyless_account` function calls `rest_client.lookup_address()` to find the actual on-chain account address. [13](#0-12) 

The REST client's `lookup_address` function queries the `OriginatingAddress` table. When the table item is not found (because it was never added after rotation), it returns the authentication key itself as the address when `must_exist=false`. [14](#0-13) 

**Attack Scenario:**
1. User creates keyless account at address `0xALICE` with initial authentication key `0xALICE`
2. User calls `upsert_ed25519_backup_key_on_keyless_account` to add backup key
3. Account authentication key rotates to new multi-key `0xNEW_KEY`
4. OriginatingAddress table is NOT updated (no entry `0xNEW_KEY â†’ 0xALICE`)
5. User loses device and attempts recovery with JWT credentials and backup key
6. SDK derives authentication key `0xNEW_KEY` from credentials
7. SDK calls `lookup_address(0xNEW_KEY, false)`
8. OriginatingAddress lookup fails, returns `0xNEW_KEY` as address (fallback behavior)
9. User cannot access account at actual address `0xALICE`
10. **User permanently loses access to account and all funds**

## Impact Explanation

**HIGH Severity** - This qualifies as significant account access loss per Aptos bug bounty criteria:

- Users who rotate keys using these functions lose the ability to recover accounts through the standard wallet recovery mechanism
- The `OriginatingAddress` table is the primary mechanism in the wallet SDK for mapping rotated authentication keys to original addresses
- Without this mapping, wallet recovery fails - the SDK cannot determine the correct account address
- The remediation function `set_originating_address()` is permanently disabled, providing no user-accessible recovery path
- This affects all keyless account users who add backup keys - a feature Aptos actively promotes for security
- Funds become inaccessible at the original address, requiring manual intervention or governance action to restore access
- Notably, `upsert_ed25519_backup_key_on_keyless_account` validates proof-of-knowledge for the backup key but still fails to update the table, indicating this is a design flaw rather than an intentional limitation

## Likelihood Explanation

**HIGH Likelihood:**

- Keyless accounts are actively promoted features in the Aptos ecosystem
- These vulnerable functions are the ONLY way for keyless/passkey users to rotate keys, as they cannot use the standard `rotate_authentication_key` function which requires ED25519/MULTI_ED25519 schemes [15](#0-14) 
- Users naturally rotate keys for legitimate security reasons (adding backup keys, security hardening)
- The vulnerability triggers automatically during legitimate usage - no attacker action required
- Users unknowingly break their recovery capability by performing a security operation that appears to succeed
- Every keyless/passkey user who adds backup keys becomes vulnerable to permanent account loss upon device loss

## Recommendation

For `upsert_ed25519_backup_key_on_keyless_account`, update the function to call `update_auth_key_and_originating_address_table` instead of just updating the authentication key. Since this function already validates proof-of-knowledge via RotationProofChallenge, it has the necessary verification to safely update the OriginatingAddress table.

Modify the function after line 560:
```move
// Instead of just:
rotate_authentication_key_call(account, new_auth_key);

// Call the full update function:
update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);
```

This ensures the OriginatingAddress table is updated correctly, enabling proper account recovery while maintaining all existing security guarantees.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a keyless account on testnet
2. Calling `upsert_ed25519_backup_key_on_keyless_account` to add a backup key
3. Verifying the authentication key changed in the Account resource
4. Querying the OriginatingAddress table and observing no mapping exists for the new authentication key
5. Attempting SDK recovery with the new authentication key and observing it returns the wrong address

This can be tested using the existing Move test framework by verifying that after calling `upsert_ed25519_backup_key_on_keyless_account`, the `originating_address()` view function returns `option::none()` for the new authentication key.

## Notes

This vulnerability is particularly serious because `upsert_ed25519_backup_key_on_keyless_account` validates proof-of-knowledge for the backup key (lines 537-550), giving it the necessary security guarantees to update the OriginatingAddress table. The failure to update the table appears to be an oversight rather than an intentional design decision. The disabled `set_originating_address()` function prevents users from manually correcting this issue, creating a permanent recovery failure for security-conscious users who follow best practices by adding backup keys.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L92-105)
```text
    /// It is easy to fetch the authentication key of an address by simply reading it from the `Account` struct at that address.
    /// The table in this struct makes it possible to do a reverse lookup: it maps an authentication key, to the address of the account which has that authentication key set.
    ///
    /// This mapping is needed when recovering wallets for accounts whose authentication key has been rotated.
    ///
    /// For example, imagine a freshly-created wallet with address `a` and thus also with authentication key `a`, derived from a PK `pk_a` with corresponding SK `sk_a`.
    /// It is easy to recover such a wallet given just the secret key `sk_a`, since the PK can be derived from the SK, the authentication key can then be derived from the PK, and the address equals the authentication key (since there was no key rotation).
    ///
    /// However, if such a wallet rotates its authentication key to `b` derived from a different PK `pk_b` with SK `sk_b`, how would account recovery work?
    /// The recovered address would no longer be 'a'; it would be `b`, which is incorrect.
    /// This struct solves this problem by mapping the new authentication key `b` to the original address `a` and thus helping the wallet software during recovery find the correct address.
    struct OriginatingAddress has key {
        address_map: Table<address, address>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L221-222)
```text
    /// The set_originating_address is disabled due to potential poisoning from account abstraction
    const ESET_ORIGINATING_ADDRESS_DISABLED: u64 = 27;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L395-402)
```text
    public fun originating_address(auth_key: address): Option<address> acquires OriginatingAddress {
        let address_map_ref = &OriginatingAddress[@aptos_framework].address_map;
        if (address_map_ref.contains(auth_key)) {
            option::some(*address_map_ref.borrow(auth_key))
        } else {
            option::none()
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L458-459)
```text
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
    /// `set_originating_address()`.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L460-462)
```text
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L467-467)
```text
    /// Note: This function does not update the `OriginatingAddress` table.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L486-486)
```text
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L537-550)
```text
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: backup_public_key,
        };

        // Assert the challenges signed by the provided backup key is valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            ED25519_SCHEME,
            backup_public_key,
            backup_key_proof,
            &challenge
        );
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L560-560)
```text
        rotate_authentication_key_call(account, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L619-635)
```text
        if (from_scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else if (from_scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else {
            abort error::invalid_argument(EINVALID_SCHEME)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L661-661)
```text
        update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L832-833)
```text
    entry fun set_originating_address(_account: &signer) acquires Account, OriginatingAddress {
        abort error::invalid_state(ESET_ORIGINATING_ADDRESS_DISABLED);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1044-1082)
```text
    fun update_auth_key_and_originating_address_table(
        originating_addr: address,
        account_resource: &mut Account,
        new_auth_key_vector: vector<u8>,
    ) acquires OriginatingAddress {
        let address_map = &mut OriginatingAddress[@aptos_framework].address_map;
        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);
        let new_auth_key = from_bcs::to_address(new_auth_key_vector);
        assert!(
            new_auth_key != curr_auth_key,
            error::invalid_argument(ENEW_AUTH_KEY_SAME_AS_CURRENT)
        );

        // Checks `OriginatingAddress[curr_auth_key]` is either unmapped, or mapped to `originating_address`.
        // If it's mapped to the originating address, removes that mapping.
        // Otherwise, abort if it's mapped to a different address.
        if (address_map.contains(curr_auth_key)) {
            // If account_a with address_a is rotating its keypair from keypair_a to keypair_b, we expect
            // the address of the account to stay the same, while its keypair updates to keypair_b.
            // Here, by asserting that we're calling from the account with the originating address, we enforce
            // the standard of keeping the same address and updating the keypair at the contract level.
            // Without this assertion, the dapps could also update the account's address to address_b (the address that
            // is programmatically related to keypaier_b) and update the keypair to keypair_b. This causes problems
            // for interoperability because different dapps can implement this in different ways.
            // If the account with address b calls this function with two valid signatures, it will abort at this step,
            // because address b is not the account's originating address.
            assert!(
                originating_addr == address_map.remove(curr_auth_key),
                error::not_found(EINVALID_ORIGINATING_ADDRESS)
            );
        };

        // Set `OriginatingAddress[new_auth_key] = originating_address`.
        assert!(
            !address_map.contains(new_auth_key),
            error::invalid_argument(ENEW_AUTH_KEY_ALREADY_MAPPED)
        );
        address_map.add(new_auth_key, originating_addr);

```

**File:** sdk/src/types.rs (L1098-1100)
```rust
    let address = rest_client
        .lookup_address(account.authentication_key().account_address(), false)
        .await?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L299-305)
```rust
            })) => {
                // If the table item wasn't found, we may check if the account exists
                if !must_exist {
                    Ok(Response::new(
                        address_key,
                        originating_address_table.state().clone(),
                    ))
```
