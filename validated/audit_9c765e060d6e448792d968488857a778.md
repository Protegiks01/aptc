# Audit Report

## Title
ElGamal Encryption to Identity Public Key Exposes Plaintexts in Veiled Coin Transactions

## Summary
The Ristretto255 ElGamal encryption implementation in the Aptos stdlib lacks validation that public keys are not the identity element. This allows registration of veiled coin accounts with the identity element (32 zero bytes) as the public key, causing all incoming transfers to leak plaintext amounts directly in the ciphertext, breaking confidentiality guarantees of veiled transactions.

## Finding Description

The ElGamal public key creation function accepts the identity element without validation: [1](#0-0) 

This function only validates that the bytes represent a canonical Ristretto255 point, delegating to: [2](#0-1) 

The native implementation performs canonical point validation but does NOT reject the identity element: [3](#0-2) 

The identity element is explicitly defined as 32 zero bytes: [4](#0-3) 

The veiled coin registration accepts any valid Ristretto255 point without identity validation: [5](#0-4) [6](#0-5) 

According to the ElGamal encryption specification documented in the module: [7](#0-6) 

When `Y` is the identity element, `r*Y = identity`, reducing the ciphertext to `(v*G, r*G)`, which directly exposes `v*G` and enables plaintext recovery through discrete log attacks on small values.

The sigma protocol verification validates algebraic relationships but does not check if public keys are the identity element: [8](#0-7) [9](#0-8) 

When `recipient_pk = identity`, the verification equation `ρ * bar_C + X3 = α1 * G + α2 * recipient_pk` reduces to `ρ * bar_C + X3 = α1 * G`, which the prover can satisfy by constructing appropriate proof values.

**Attack Path:**
1. Attacker calls `veiled_coin::register<CoinType>` with `pk = x"0000000000000000000000000000000000000000000000000000000000000000"`
2. Registration succeeds, storing identity element as the encryption public key
3. Victim performs `fully_veiled_transfer` to attacker's address
4. The deposit ciphertext encrypts amount `v` as `(v*G, r*G)` instead of `(v*G + r*Y, r*G)`
5. The point `v*G` is directly observable on-chain, revealing the transferred amount
6. Zero-knowledge proofs verify successfully as they only validate algebraic consistency

## Impact Explanation

**Severity: Medium**

This constitutes a significant cryptographic correctness violation in the Aptos stdlib. While the currently affected `veiled_coin` module is marked experimental and explicitly warned as unsafe: [10](#0-9) [11](#0-10) 

The underlying vulnerability exists in the production stdlib module `ristretto255_elgamal`, which is NOT marked experimental and resides in `aptos-stdlib`: [12](#0-11) 

The stdlib cryptographic primitives are reusable APIs. Any future production use of these ElGamal primitives for confidential transactions, voting systems, or privacy-preserving protocols would inherit this vulnerability.

This breaks the fundamental security property of ElGamal encryption: semantic security under chosen-plaintext attacks (IND-CPA). When the public key is the identity element, encryption degenerates to plaintext exposure.

The current impact is limited because only experimental code uses these primitives. However, the flaw in reusable stdlib components represents a latent risk for any future confidential transaction implementations. This qualifies as a "Limited Protocol Violation" under Medium severity in the Aptos bug bounty program.

## Likelihood Explanation

**Current Likelihood: Low** (only experimental code affected)

**Future Likelihood: High** (if primitives used in production)

**Technical Feasibility**: Trivial - attacker registers with `pk = x"0000000000000000000000000000000000000000000000000000000000000000"`

**Barrier to Entry**: None - any user can call the public `register` entry function with arbitrary bytes

**Detection Difficulty**: Low - the attack leaves no obvious traces; ciphertexts appear syntactically valid and pass all cryptographic proof verifications

Once these ElGamal primitives are incorporated into production confidential transaction systems, the attack becomes immediately exploitable with no special privileges or advanced cryptographic knowledge required.

## Recommendation

Add identity element validation to the `new_pubkey_from_bytes` function:

```move
public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
    let point = ristretto255::new_compressed_point_from_bytes(bytes);
    if (point.is_some()) {
        let pk = CompressedPubkey {
            point: point.extract()
        };
        // Reject identity element
        let identity = ristretto255::point_identity_compressed();
        if (ristretto255::compressed_point_to_bytes(pk.point) == 
            ristretto255::compressed_point_to_bytes(identity)) {
            return std::option::none<CompressedPubkey>()
        };
        std::option::some(pk)
    } else {
        std::option::none<CompressedPubkey>()
    }
}
```

Alternatively, add a native validation function that checks for identity and small-order points during decompression.

## Proof of Concept

```move
#[test_only]
module test_identity_pk_attack {
    use aptos_std::ristretto255_elgamal as elgamal;
    use aptos_std::ristretto255;
    
    #[test]
    fun test_identity_pk_accepted() {
        // Identity element: 32 zero bytes
        let identity_bytes = x"0000000000000000000000000000000000000000000000000000000000000000";
        
        // This should fail but currently succeeds
        let pk_opt = elgamal::new_pubkey_from_bytes(identity_bytes);
        assert!(pk_opt.is_some(), 1); // PASSES - identity accepted!
        
        let pk = pk_opt.extract();
        
        // Encrypt a small value (e.g., 100) under identity PK
        let value = ristretto255::new_scalar_from_u32(100);
        let randomness = ristretto255::random_scalar();
        let ciphertext = elgamal::new_ciphertext_with_basepoint(&value, &randomness, &pk);
        
        // The ciphertext's left component is just v*G (plaintext exposed)
        // An attacker can recover v by computing discrete log of the left component
        let (left, _right) = elgamal::ciphertext_as_points(&ciphertext);
        let expected_left = ristretto255::basepoint_mul(&value);
        
        // Verify that left component equals v*G (plaintext exposure)
        assert!(ristretto255::point_equals(&left, &expected_left), 2);
    }
}
```

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L1-11)
```text
/// This module implements an ElGamal encryption API, over the Ristretto255 curve, that can be used with the
/// Bulletproofs module.
///
/// An ElGamal *ciphertext* is an encryption of a value `v` under a basepoint `G` and public key `Y = sk * G`, where `sk`
/// is the corresponding secret key, is `(v * G + r * Y, r * G)`, for a random scalar `r`.
///
/// Note that we place the value `v` "in the exponent" of `G` so that ciphertexts are additively homomorphic: i.e., so
/// that `Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')` where `v, v'` are plaintext messages, `Y` is a public key and `r, r'`
/// are the randomness of the ciphertexts.

module aptos_std::ristretto255_elgamal {
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L42-52)
```text
    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
        let point = ristretto255::new_compressed_point_from_bytes(bytes);
        if (point.is_some()) {
            let pk = CompressedPubkey {
                point: point.extract()
            };
            std::option::some(pk)
        } else {
            std::option::none<CompressedPubkey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move (L113-118)
```text
    /// Returns the identity point as a CompressedRistretto.
    public fun point_identity_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move (L160-168)
```text
    public fun new_compressed_point_from_bytes(bytes: vector<u8>): Option<CompressedRistretto> {
        if (point_is_canonical_internal(bytes)) {
            std::option::some(CompressedRistretto {
                data: bytes
            })
        } else {
            std::option::none<CompressedRistretto>()
        }
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L210-223)
```rust
pub(crate) fn native_point_is_canonical(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(ty_args.len(), 0);
    safely_assert_eq!(args.len(), 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let opt_point = decompress_maybe_non_canonical_point_bytes(context, bytes)?;

    Ok(smallvec![Value::bool(opt_point.is_some())])
}
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L1-2)
```text
/// **WARNING:** This is an **experimental, proof-of-concept** module! It is *NOT* production-ready and it will likely
/// lead to loss of funds if used (or misused).
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L50-57)
```text
/// **WARNING:** This module is **experimental**! It is *NOT* production-ready. Specifically:
///
///  1. Deploying this module will likely lead to lost funds.
///  2. This module has not been cryptographically-audited.
///  3. The current implementation is vulnerable to _front-running attacks_ as described in the Zether paper [BAZB20].
///  4. There is no integration with wallet software which, for veiled accounts, must maintain an additional ElGamal
///    encryption keypair.
///  5. There is no support for rotating the ElGamal encryption public key of a veiled account.
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L268-271)
```text
    public entry fun register<CoinType>(user: &signer, pk: vector<u8>) {
        let pk = elgamal::new_pubkey_from_bytes(pk);
        register_internal<CoinType>(user, pk.extract());
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L522-540)
```text
    public fun register_internal<CoinType>(
        user: &signer, pk: elgamal::CompressedPubkey
    ) {
        let account_addr = signer::address_of(user);
        assert!(
            !has_veiled_coin_store<CoinType>(account_addr),
            error::already_exists(EVEILED_COIN_STORE_ALREADY_PUBLISHED)
        );

        // Note: There is no way to find an ElGamal SK such that the `(0_G, 0_G)` ciphertext below decrypts to a non-zero
        // value. We'd need to have `(r * G, v * G + r * pk) = (0_G, 0_G)`, which implies `r = 0` for any choice of PK/SK.
        // Thus, we must have `v * G = 0_G`, which implies `v = 0`.

        let coin_store = VeiledCoinStore<CoinType> {
            veiled_balance: helpers::get_veiled_balance_zero_ciphertext(),
            pk
        };
        move_to(user, coin_store);
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/sigma_protos.move (L169-182)
```text
    public fun verify_transfer_subproof(
        sender_pk: &elgamal::CompressedPubkey,
        recipient_pk: &elgamal::CompressedPubkey,
        withdraw_ct: &elgamal::Ciphertext,
        deposit_ct: &elgamal::Ciphertext,
        comm_amount: &pedersen::Commitment,
        sender_new_balance_comm: &pedersen::Commitment,
        sender_curr_balance_ct: &elgamal::Ciphertext,
        proof: &TransferSubproof
    ) {
        let h = pedersen::randomness_base_for_bulletproof();
        let sender_pk_point = elgamal::pubkey_to_point(sender_pk);
        let recipient_pk_point = elgamal::pubkey_to_point(recipient_pk);
        let (big_c, big_d) = elgamal::ciphertext_as_points(withdraw_ct);
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/sigma_protos.move (L227-235)
```text
        // \rho * \bar{C} + X3 =? \alpha_1 * g + \alpha_2 * \bar{y}
        let big_bar_c_acc = ristretto255::point_mul(bar_big_c, &rho);
        ristretto255::point_add_assign(&mut big_bar_c_acc, &proof.x3);
        let y_bar_alpha2 = ristretto255::point_mul(&recipient_pk_point, &proof.alpha2);
        ristretto255::point_add_assign(&mut y_bar_alpha2, &g_alpha1);
        assert!(
            ristretto255::point_equals(&big_bar_c_acc, &y_bar_alpha2),
            error::invalid_argument(ESIGMA_PROTOCOL_VERIFY_FAILED)
        );
```
