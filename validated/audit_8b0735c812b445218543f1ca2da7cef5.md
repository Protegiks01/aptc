# Audit Report

## Title
Cache Coherency Vulnerability: Layout Cache Missing Module Version Validation in Parallel Block Execution

## Summary
A critical race condition exists in the global layout cache system where Move type layouts cached from old module versions can be incorrectly used with new module versions during parallel transaction execution. This breaks deterministic execution guarantees and can cause consensus failures across validators.

## Finding Description

The vulnerability arises from three architectural components interacting incorrectly during parallel transaction execution:

**1. Global Layout Cache Without Version Information**

The system uses a global `DashMap<StructKey, LayoutCacheEntry>` to cache struct layouts across transactions. [1](#0-0) 

The cache key `StructKey` contains only a struct name index and type arguments, with no module version or bytecode hash: [2](#0-1) 

The `StructNameIndex` is merely a `u32` interned identifier that maps to module address and name without any version information: [3](#0-2) 

**2. Transaction-Level Module Caching**

During execution, transactions cache module reads in `CapturedReads` to maintain consistency within a single execution. The `get_module_or_build_with` method checks `CapturedReads` first before checking global or per-block caches: [4](#0-3) 

**3. Incomplete Layout Cache Validation**

When layouts are retrieved from cache, the `load_layout_from_cache` function re-reads modules only for gas charging, not for version validation: [5](#0-4) 

The `DefiningModules` structure tracks which modules were used to construct a layout but stores only `ModuleId` (address + name) without versions: [6](#0-5) 

**The Attack Sequence:**

1. Transaction T₂ begins parallel execution and reads module M version 1, storing it in `CapturedReads`
2. T₂ computes and globally caches a layout L₁ for struct S from M v1
3. Transaction T₁₀ commits and publishes M version 2 with modified struct layout
4. The `publish_module_write_set` function flushes the layout cache and marks M as overridden: [7](#0-6) 

5. T₂ is still executing (hasn't been validated yet) and needs another layout from M
6. T₂'s `get_module_or_build_with` checks `CapturedReads` first (line 151), retrieves M v1, computes a new layout, and caches it globally
7. Transaction T₁₁ starts execution and finds the cached layout
8. T₁₁'s `load_layout_from_cache` re-reads M to charge gas via `unmetered_get_module_size`: [8](#0-7) 

This captures M v2 in T₁₁'s `CapturedReads`, but T₁₁ uses the cached layout computed from M v1.

**Why Existing Protections Fail:**

The module validation system checks module version consistency but not layout cache coherency: [9](#0-8) 

This validation only ensures that module reads are consistent (GlobalCache not overridden, PerBlockCache versions match), but does NOT validate that cached layouts correspond to the correct module versions. A transaction can pass validation with correct module reads while using an incorrect cached layout.

**Invariant Violation:**

This breaks deterministic execution guarantees. Different validators executing the same block in parallel may have different layouts cached due to timing variations in when transactions execute relative to module publications, leading to:
- Different serialization/deserialization results
- Different transaction execution outcomes
- Different state roots across validators
- Consensus safety violation

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos Bug Bounty "Consensus/Safety Violations" category because:

1. **Consensus Breaking**: Different validators will compute different state roots for identical blocks, breaking Byzantine Fault Tolerant consensus guarantees. Validators with different cached layouts will produce different execution results for the same transactions.

2. **Non-Deterministic Execution**: The same transaction can produce different results depending on which layouts are cached, violating blockchain determinism requirements. This is timing-dependent and unpredictable.

3. **No Detection Mechanism**: Module validation validates module version consistency but not layout-module version coherency. Transactions using incorrect cached layouts will pass validation if they correctly recorded their module reads.

4. **Network-Wide Impact**: All validators running parallel execution (default configuration) are affected. The layout cache is enabled by default and shared globally across parallel workers.

5. **Silent Failure**: No warnings or errors are generated when stale layouts are used, making detection extremely difficult without forensic state root analysis.

## Likelihood Explanation

**Medium to High Likelihood** due to:

1. **Common Trigger**: Module upgrades are a standard Aptos feature used frequently in production. Any module upgrade during parallel execution can trigger this race condition.

2. **Natural Occurrence**: The race condition requires no attacker coordination - it occurs naturally during normal parallel execution when modules are upgraded. The timing window exists from when a module is published until all in-flight transactions are validated.

3. **Default Configuration**: Layout caching is enabled by default with a large cache size. Parallel execution is standard for validators to achieve high throughput.

4. **No Attacker Required**: This is not an attack scenario but a fundamental architectural issue that manifests during legitimate operations.

5. **Dependency on Layout Changes**: Likelihood depends on whether module upgrades actually modify struct layouts, which varies by upgrade.

## Recommendation

**Add version tracking to layout cache:**

1. Include module bytecode hash or version in `StructKey`:
   - Extend `StructKey` to include version information from defining modules
   - Use cryptographic hash of all defining modules' bytecode

2. Invalidate cached layouts more aggressively:
   - When loading from cache, validate that all defining modules match current versions
   - Compare module versions/hashes in `DefiningModules` against currently loaded modules

3. Add validation checks:
   - In `load_layout_from_cache`, verify that modules read for gas charging match the versions used to create the layout
   - Reject cached layouts if any defining module has been upgraded

4. Alternative: Use per-block layout caches instead of global cache during parallel execution to avoid cross-transaction contamination.

## Proof of Concept

The vulnerability requires a complex parallel execution environment to reproduce. The existing test demonstrates partial behavior: [10](#0-9) 

This test shows module publishing affecting subsequent layout usage, but does not explicitly test the race condition where an in-flight transaction re-populates the cache with stale layouts after a flush. A complete PoC would require:

1. Parallel execution framework setup
2. Transaction T₂ with M v1 in CapturedReads executing
3. Concurrent module publish of M v2
4. T₂ computing and caching layout post-flush
5. New transaction T₁₁ using stale cached layout
6. Verification that T₁₁ passes validation despite layout-module version mismatch

## Notes

This vulnerability represents a subtle but critical flaw in the caching architecture where global state (layout cache) is populated based on transaction-local state (CapturedReads) without proper version coordination. The issue is exacerbated by the separation of concerns between module validation (which checks module versions) and layout usage (which doesn't), creating a gap where stale cached data can be used by validated transactions.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global.rs (L86-96)
```rust
/// A global cache for verified code and derived information (such as layouts) that is concurrently
/// accessed during the block execution. Module cache is read-only, and modified safely only at
/// block boundaries. Layout cache can be modified during execution of the block.
pub struct GlobalModuleCache<K, D, V, E> {
    /// Module cache containing the verified code.
    module_cache: HashMap<K, Entry<D, V, E>>,
    /// Sum of serialized sizes (in bytes) of all cached modules.
    size: usize,
    /// Cached layouts of structs or enums. This cache stores roots only and is invalidated when
    /// modules are published.
    struct_layouts: DashMap<StructKey, LayoutCacheEntry>,
```

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L29-57)
```rust
#[derive(Debug, Default)]
pub struct DefiningModules {
    modules: HashSet<ModuleId>,
    seen_modules: Vec<ModuleId>,
}

impl DefiningModules {
    /// Returns a new empty set of modules.
    pub fn new() -> Self {
        Self {
            modules: HashSet::new(),
            seen_modules: vec![],
        }
    }

    /// If module is not in the set, adds it.
    pub fn insert(&mut self, module_id: &ModuleId) {
        if !self.modules.contains(module_id) {
            self.modules.insert(module_id.clone());
            // Preserve the visited order: later traversal over the module set is deterministic.
            self.seen_modules.push(module_id.clone())
        }
    }

    /// Returns an iterator over modules in their insertion order.
    pub fn iter(&self) -> impl Iterator<Item = &ModuleId> {
        self.seen_modules.iter()
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L79-83)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub struct StructKey {
    pub idx: StructNameIndex,
    pub ty_args_id: TypeVecId,
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L20-32)
```rust
/// Represents a unique identifier for the struct name. Note that this index has no public
/// constructor - the only way to construct it is via [StructNameIndexMap].
#[derive(Debug, Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StructNameIndex(u32);

impl StructNameIndex {
    /// Creates a new index for testing purposes only. For production, indices must always be
    /// created by the data structure that uses them to intern struct names.
    #[cfg(any(test, feature = "testing"))]
    pub fn new(idx: u32) -> Self {
        Self(idx)
    }
}
```

**File:** aptos-move/block-executor/src/code_cache.rs (L133-174)
```rust
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    > {
        match &self.latest_view {
            ViewState::Sync(state) => {
                // Check the transaction-level cache with already read modules first.
                if let CacheRead::Hit(read) = state.captured_reads.borrow().get_module_read(key) {
                    return Ok(read);
                }

                // Otherwise, it is a miss. Check global cache.
                if let Some(module) = self.global_module_cache.get(key) {
                    state
                        .captured_reads
                        .borrow_mut()
                        .capture_global_cache_read(key.clone(), module.clone());
                    return Ok(Some((module, Self::Version::default())));
                }

                // If not global cache, check per-block cache.
                let _timer = GLOBAL_MODULE_CACHE_MISS_SECONDS.start_timer();
                let read = state
                    .versioned_map
                    .module_cache()
                    .get_module_or_build_with(key, builder)?;
                state
                    .captured_reads
                    .borrow_mut()
                    .capture_per_block_cache_read(key.clone(), read.clone());
                Ok(read)
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L203-221)
```rust
    fn load_layout_from_cache(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        key: &StructKey,
    ) -> Option<PartialVMResult<LayoutWithDelayedFields>> {
        let entry = self.module_storage.get_struct_layout(key)?;
        let (layout, modules) = entry.unpack();
        for module_id in modules.iter() {
            // Re-read all modules for this layout, so that transaction gets invalidated
            // on module publish. Also, we re-read them in exactly the same way as they
            // were traversed during layout construction, so gas charging should be exactly
            // the same as on the cache miss.
            if let Err(err) = self.charge_module(gas_meter, traversal_context, module_id) {
                return Some(Err(err));
            }
        }
        Some(Ok(layout))
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L539-578)
```rust
    pub(crate) fn publish_module_write_set(
        &self,
        txn_idx: TxnIndex,
        global_module_cache: &GlobalModuleCache<
            ModuleId,
            CompiledModule,
            Module,
            AptosModuleExtension,
        >,
        versioned_cache: &MVHashMap<T::Key, T::Tag, T::Value, DelayedFieldID>,
        runtime_environment: &RuntimeEnvironment,
        scheduler: &SchedulerWrapper<'_>,
    ) -> Result<bool, PanicError> {
        let output_wrapper = self.output_wrappers[txn_idx as usize].lock();
        let output_before_guard = output_wrapper
            .check_success_or_skip_status()?
            .before_materialization()?;

        let mut published = false;
        let mut module_ids_for_v2 = BTreeSet::new();
        for write in output_before_guard.module_write_set().values() {
            published = true;
            if scheduler.is_v2() {
                module_ids_for_v2.insert(write.module_id().clone());
            }
            add_module_write_to_module_cache::<T>(
                write,
                txn_idx,
                runtime_environment,
                global_module_cache,
                versioned_cache.module_cache(),
            )?;
        }
        if published {
            // Record validation requirements after the modules are published.
            global_module_cache.flush_layout_cache();
            scheduler.record_validation_requirements(txn_idx, module_ids_for_v2)?;
        }
        Ok(published)
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L211-220)
```rust
    fn unmetered_get_module_size(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<Option<usize>> {
        let id = ModuleId::new(*address, module_name.to_owned());
        Ok(self
            .get_module_or_build_with(&id, self)?
            .map(|(module, _)| module.extension().bytes().len()))
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1050-1089)
```rust
    pub(crate) fn validate_module_reads(
        &self,
        global_module_cache: &GlobalModuleCache<K, DC, VC, S>,
        per_block_module_cache: &SyncModuleCache<K, DC, VC, S, Option<TxnIndex>>,
        maybe_updated_module_keys: Option<&BTreeSet<K>>,
    ) -> bool {
        if self.non_delayed_field_speculative_failure {
            return false;
        }

        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
            ModuleRead::PerBlockCache(previous) => {
                let current_version = per_block_module_cache.get_module_version(key);
                let previous_version = previous.as_ref().map(|(_, version)| *version);
                current_version == previous_version
            },
        };

        match maybe_updated_module_keys {
            Some(updated_module_keys) if updated_module_keys.len() <= self.module_reads.len() => {
                // When updated_module_keys is smaller, iterate over it and lookup in module_reads
                updated_module_keys
                    .iter()
                    .filter(|&k| self.module_reads.contains_key(k))
                    .all(|key| validate(key, self.module_reads.get(key).unwrap()))
            },
            Some(updated_module_keys) => {
                // When module_reads is smaller, iterate over it and filter by updated_module_keys
                self.module_reads
                    .iter()
                    .filter(|(k, _)| updated_module_keys.contains(k))
                    .all(|(key, read)| validate(key, read))
            },
            None => self
                .module_reads
                .iter()
                .all(|(key, read)| validate(key, read)),
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/layout_caches.rs (L107-154)
```rust
    let mut txns = vec![];
    for i in 0..32 {
        let account =
            h.new_account_at(AccountAddress::from_hex_literal(&format!("0xcafe3{}", i)).unwrap());
        let txn = if i == 15 {
            h.create_publish_package_cache_building(
                &acc,
                &common::test_dir_path("layout_caches.data/p3_upgraded"),
                |_| {},
            )
        } else {
            h.create_transaction_payload(
                &account,
                TransactionPayload::EntryFunction(EntryFunction::new(
                    ModuleId::from_str("0xcafe::m3").unwrap(),
                    ident_str!("load_m3_with_extra_module").to_owned(),
                    vec![],
                    vec![],
                )),
            )
        };
        txns.push(txn);
    }

    let mut success_gas_usage = BTreeSet::new();
    let mut failure_gas_usage = BTreeSet::new();
    let outputs = h.run_block_get_output(txns);
    for (i, output) in outputs.iter().enumerate() {
        if i < 15 {
            assert_success!(output.status().clone());
            success_gas_usage.insert(output.gas_used());
        } else if i == 15 {
            // Publishing succeeds.
            assert_success!(output.status().clone());
        } else {
            // Transactions after publish fail on dependency limit reached (new layout is read).
            assert!(matches!(
                output.status(),
                TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
                    StatusCode::DEPENDENCY_LIMIT_REACHED
                )))
            ));
            failure_gas_usage.insert(output.gas_used());
        }
    }
    assert_eq!(success_gas_usage.len(), 1);
    assert_eq!(failure_gas_usage.len(), 1);
}
```
