# Audit Report

## Title
Consensus Safety Violation: Fast Path Configuration Divergence Enables Randomness Fork

## Summary
Validators with different `randomness_override_seq_num` local configurations will produce divergent randomness values for identical blocks, violating consensus safety and potentially causing a chain split. The vulnerability stems from the protocol's failure to enforce consistent fast path randomness configuration across validators, combined with strict augmented data verification that prevents cross-configuration cryptographic material exchange.

## Finding Description

The vulnerability occurs through a multi-stage mechanism that breaks consensus safety:

**Root Cause - Local Configuration Parameter**: The `randomness_override_seq_num` is a local node configuration parameter that can differ across validators. [1](#0-0) 

**Configuration Divergence**: During epoch transitions, validators use this local parameter to determine the effective randomness configuration. When `local_seqnum > onchain_seqnum`, the configuration is forced to disabled (returns `Off`), otherwise it uses the on-chain configuration. [2](#0-1)  This comparison occurs during epoch start: [3](#0-2) 

**Fast Path Enablement Divergence**: The `fast_randomness_enabled()` method returns `true` only for `ConfigV2`, causing validators with different configurations to have different fast path enablement states. [4](#0-3) 

**Fast Config Initialization**: Validators check `fast_randomness_enabled()` to determine whether to create `fast_rand_config`. [5](#0-4)  Those with fast path enabled get `Some(RandConfig)`, while others get `None`: [6](#0-5) 

**Augmented Data Structure Mismatch**: Validators generate `AugmentedData` with optional `fast_delta` based on their configuration. [7](#0-6) 

**Strict Verification Causing Cross-Rejection**: The augmented data verification enforces exact matching with the strict check `ensure!(self.fast_delta.is_some() == fast_rand_config.is_some())`, causing validators with mismatched configurations to reject each other's augmented data. [8](#0-7) 

**APK Divergence**: Due to augmented data rejection, validators build different sets of certified augmented public keys (APKs). The `augment()` method adds APKs only for accepted data. [9](#0-8) 

**Share Rejection for Missing APKs**: Validators reject shares from peers whose APKs they don't have, further reinforcing the partition. [10](#0-9) 

**Randomness Divergence via Different APK Sets**: During share aggregation, `Share::aggregate()` calls `WVUF::derive_eval()` using `get_all_certified_apk()` as input. [11](#0-10)  The WVUF derive_eval function is deterministic but depends on the APK input set. [12](#0-11)  Different APK sets produce different randomness outputs, as each validator independently computes randomness.

**State Root Divergence**: Each validator independently creates block metadata transactions using their locally computed randomness. [13](#0-12)  Different randomness values lead to different metadata transactions, causing different execution outcomes and different state roots. This breaks consensus safety as validators vote on different state roots for the same block.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability breaks the fundamental consensus safety invariant: "All validators must produce identical state roots for identical blocks." The impact qualifies as **Consensus/Safety Violations (Critical)** under the Aptos bug bounty program because it enables:

1. **Consensus Safety Violation**: Validators processing the same block compute different randomness values, leading to different execution outcomes
2. **Chain Split Risk**: If network partitions occur with different configuration groups each achieving quorum, the network forks permanently  
3. **State Root Divergence**: Different randomness leads to different transaction execution and state transitions
4. **Non-recoverable Network Partition**: Once validators commit different randomness values to their local state, manual intervention or hard fork is required for recovery

The vulnerability affects ALL validators when configuration mismatches occur, making it a network-wide critical issue that can halt the blockchain or cause permanent divergence.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability can be triggered through realistic operational scenarios:

1. **Emergency Recovery Procedure**: The Move framework documentation explicitly describes a recovery procedure where validators set `randomness_override_seq_num` to unblock a stalled chain. [14](#0-13)  The documentation states "Every validator" must set the same value, but the protocol does not enforce this requirement.

2. **Gradual Rollout**: If validator operators update their configurations in phases (common during incident response), early updaters and late updaters will have mismatched configurations.

3. **Operational Error**: During troubleshooting or incident response, operators may independently adjust `randomness_override_seq_num` without coordinating across all validators.

The likelihood is elevated because:
- The parameter is designed for manual intervention during incidents when stress is high
- No protocol-level validation enforces consistency across validators
- The consequence is non-obvious to operators (they may not realize local configuration affects consensus)
- The failure mode is silent until randomness is actually used in block execution
- Configuration divergence is a realistic scenario during emergency procedures

## Recommendation

Implement protocol-level validation to ensure all validators use consistent randomness configuration:

1. **Gossip Configuration Hashes**: During epoch transitions, validators should gossip cryptographic hashes of their effective randomness configuration and verify consistency before processing blocks.

2. **Configuration Checkpoint in Consensus**: Include a hash of the effective randomness configuration in the first block of each epoch, signed by all validators as part of the epoch change certificate.

3. **Fail-Safe Mode**: If configuration mismatches are detected, validators should enter a safe mode that prevents block execution until configuration consistency is restored.

4. **Operational Tooling**: Provide tooling to validate configuration consistency across all validators before applying emergency overrides.

5. **Relaxed Verification During Transition**: Temporarily allow accepting augmented data with mismatched fast_delta during epoch transitions to enable graceful degradation, or ensure all validators transition atomically.

## Proof of Concept

A complete PoC would require:
1. A local testnet with multiple validators
2. Configure subset of validators with `randomness_override_seq_num` > on-chain value
3. Trigger epoch transition with ConfigV2 (fast path enabled) on-chain
4. Observe validators with override get `Off` config while others get `V2`
5. Monitor augmented data exchange - cross-rejection occurs
6. Observe different APK sets building up
7. When randomness generation triggers, validators compute different values
8. Block execution produces different state roots
9. Consensus splits or halts

The vulnerability is demonstrable through configuration and monitoring without requiring custom attack code.

## Notes

This vulnerability is particularly insidious because:
- It affects trusted validator operators, not malicious actors
- The failure mode is non-obvious and occurs during emergency procedures when coordination is most difficult
- The protocol provides no feedback that configuration divergence is occurring until consensus breaks
- Recovery requires manual intervention across all validators simultaneously

The root cause is the design decision to allow local configuration to override consensus-critical protocol behavior without any protocol-level validation or coordination mechanism.

### Citations

**File:** config/src/config/node_config.rs (L78-81)
```rust
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
```

**File:** types/src/on_chain_config/randomness_config.rs (L139-151)
```rust
    pub fn from_configs(
        local_seqnum: u64,
        onchain_seqnum: u64,
        onchain_raw_config: Option<RandomnessConfigMoveStruct>,
    ) -> Self {
        if local_seqnum > onchain_seqnum {
            Self::default_disabled()
        } else {
            onchain_raw_config
                .and_then(|onchain_raw| OnChainRandomnessConfig::try_from(onchain_raw).ok())
                .unwrap_or_else(OnChainRandomnessConfig::default_if_missing)
        }
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L213-219)
```rust
    pub fn fast_randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::V1(_) => false,
            OnChainRandomnessConfig::V2(_) => true,
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L1074-1078)
```rust
        let fast_randomness_is_enabled = onchain_randomness_config.fast_randomness_enabled()
            && sk.fast.is_some()
            && pk.fast.is_some()
            && transcript.fast.is_some()
            && dkg_pub_params.pvss_config.fast_wconfig.is_some();
```

**File:** consensus/src/epoch_manager.rs (L1137-1159)
```rust
        let fast_rand_config = if let (Some((ask, apk)), Some(trx), Some(wconfig)) = (
            fast_augmented_key_pair,
            transcript.fast.as_ref(),
            dkg_pub_params.pvss_config.fast_wconfig.as_ref(),
        ) {
            let pk_shares = (0..new_epoch_state.verifier.len())
                .map(|id| trx.get_public_key_share(wconfig, &Player { id }))
                .collect::<Vec<_>>();

            let fast_keys = RandKeys::new(ask, apk, pk_shares, new_epoch_state.verifier.len());
            let fast_wconfig = wconfig.clone();

            Some(RandConfig::new(
                self.author,
                new_epoch,
                new_epoch_state.verifier.clone(),
                vuf_pp,
                fast_keys,
                fast_wconfig,
            ))
        } else {
            None
        };
```

**File:** consensus/src/epoch_manager.rs (L1217-1221)
```rust
        let onchain_randomness_config = OnChainRandomnessConfig::from_configs(
            self.randomness_override_seq_num,
            onchain_randomness_config_seq_num.seq_num,
            randomness_config_move_struct.ok(),
        );
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L152-176)
```rust
    fn generate(rand_config: &RandConfig, fast_rand_config: &Option<RandConfig>) -> AugData<Self>
    where
        Self: Sized,
    {
        let delta = rand_config.get_my_delta().clone();
        rand_config
            .add_certified_delta(&rand_config.author(), delta.clone())
            .expect("Add self delta should succeed");

        let fast_delta = if let Some(fast_config) = fast_rand_config.as_ref() {
            let fast_delta = fast_config.get_my_delta().clone();
            fast_config
                .add_certified_delta(&rand_config.author(), fast_delta.clone())
                .expect("Add self delta for fast path should succeed");
            Some(fast_delta)
        } else {
            None
        };

        let data = AugmentedData {
            delta: delta.clone(),
            fast_delta,
        };
        AugData::new(rand_config.epoch(), rand_config.author(), data)
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L178-194)
```rust
    fn augment(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) {
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");

        if let (Some(config), Some(fast_delta)) = (fast_rand_config, fast_delta) {
            config
                .add_certified_delta(author, fast_delta.clone())
                .expect("Add delta for fast path should succeed");
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L196-215)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) -> anyhow::Result<()> {
        rand_config
            .derive_apk(author, self.delta.clone())
            .map(|_| ())?;

        ensure!(
            self.fast_delta.is_some() == fast_rand_config.is_some(),
            "Fast path delta should be present iff fast_rand_config is present."
        );
        if let (Some(config), Some(fast_delta)) = (fast_rand_config, self.fast_delta.as_ref()) {
            config.derive_apk(author, fast_delta.clone()).map(|_| ())
        } else {
            Ok(())
        }
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/traits.rs (L66-73)
```rust
    fn derive_eval(
        wc: &WeightedConfigBlstrs,
        pp: &Self::PublicParameters,
        msg: &[u8],
        apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation>;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L803-811)
```rust
        let (rand_result, _has_randomness) = rand_check.await?;

        tracker.start_working();
        // if randomness is disabled, the metadata skips DKG and triggers immediate reconfiguration
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config_seqnum.move (L1-9)
```text
/// Randomness stall recovery utils.
///
/// When randomness generation is stuck due to a bug, the chain is also stuck. Below is the recovery procedure.
/// 1. Ensure more than 2/3 stakes are stuck at the same version.
/// 1. Every validator restarts with `randomness_override_seq_num` set to `X+1` in the node config file,
///    where `X` is the current `RandomnessConfigSeqNum` on chain.
/// 1. The chain should then be unblocked.
/// 1. Once the bug is fixed and the binary + framework have been patched,
///    a governance proposal is needed to set `RandomnessConfigSeqNum` to be `X+2`.
```
