# Audit Report

## Title
Integer Underflow in Mixed Payload Client Causes Soft > Hard Limit Violation and Potential Consensus Divergence

## Summary
The `MixedPayloadClient` performs unchecked integer subtraction when adjusting transaction limits after pulling validator transactions. When on-chain governance increases the validator transaction limit beyond the backpressure-clamped filtering limits, integer underflow occurs, corrupting the limit values and enabling non-deterministic block sizes across validators.

## Finding Description

The vulnerability exists in the payload pulling logic where validator transactions are pulled first, then user transactions. The code performs unchecked subtraction on transaction count limits: [1](#0-0) 

The validator transaction limit is governance-controlled through `ValidatorTxnConfig`, which has a default of 2 transactions but can be increased for protocol upgrades: [2](#0-1) 

Meanwhile, backpressure mechanisms can reduce filtering limits significantly. The minimum floor is defined as: [3](#0-2) [4](#0-3) 

This sets `MIN_BLOCK_TXNS_AFTER_FILTERING = 100`. The backpressure clamping logic ensures `max_block_txns_after_filtering` doesn't go below this minimum: [5](#0-4) 

However, this creates an architectural flaw: when backpressure sets `max_block_txns_after_filtering = 100` and `soft_max_txns_after_filtering = 50`, but governance has set `per_block_limit_txn_count = 150`, the validator transaction pull uses: [6](#0-5) 

This pulls `min(5000, 150) = 150` validator transactions, which then causes underflow when subtracted from the clamped limits (100 and 50). The underflowed values (near `u64::MAX`) are then used in the batch selection logic: [7](#0-6) 

With corrupted limits, the checks at lines 652 and 678 never trigger, causing blocks to be sized only by byte limits and timing, leading to non-deterministic block contents across validators.

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

1. **State Inconsistencies Requiring Intervention**: Different validators may propose blocks with vastly different transaction counts for the same round. If validators disagree on block contents, proposals may be rejected, causing consensus stalls that require manual intervention or waiting for backpressure to clear.

2. **Limited Consensus Impact**: This affects liveness rather than safety. While it doesn't enable double-spending or fund theft, the inability to reach agreement on block contents disrupts network operation and can cause temporary downtime.

3. **Configuration-Dependent**: Requires on-chain governance to increase the validator transaction limit beyond 100, combined with active backpressure conditions. This makes it less immediately exploitable than critical vulnerabilities but still realistic for protocol evolution.

4. **No Direct Fund Loss**: Does not enable theft, minting, or permanent freezing of tokens. The economic impact is indirect through network unavailability.

## Likelihood Explanation

**Likelihood: Medium**

1. **Governance Path**: The `ValidatorTxnConfig.per_block_limit_txn_count` parameter is legitimately modifiable via on-chain governance. As the Aptos protocol evolves to support more validator transactions (additional DKG rounds, randomness beacons, validator set updates), governance would naturally increase this limit. [8](#0-7) 

2. **Backpressure is Common**: The backpressure mechanisms activate regularly under high load or slow execution, making scenarios where limits are reduced to minimums realistic: [9](#0-8) 

3. **Currently Safe**: With the default `per_block_limit_txn_count = 2`, this vulnerability cannot manifest. However, the first governance proposal to increase this above 100 would expose the bug when backpressure activates.

4. **Release Build Behavior**: Validators run release builds where integer underflow wraps silently rather than panicking, so the bug manifests as incorrect behavior rather than crashes.

## Recommendation

Add validation before subtraction to prevent underflow:

```rust
// In consensus/src/payload_client/mixed.rs, lines 91-95
let mut user_txn_pull_params = params;
user_txn_pull_params.max_txns -= vtxn_size;

let validator_txn_count = validator_txns.len() as u64;
user_txn_pull_params.max_txns_after_filtering = user_txn_pull_params
    .max_txns_after_filtering
    .saturating_sub(validator_txn_count);
user_txn_pull_params.soft_max_txns_after_filtering = user_txn_pull_params
    .soft_max_txns_after_filtering
    .saturating_sub(validator_txn_count);
```

Additionally, consider enforcing a constraint that `per_block_limit_txn_count <= MIN_BLOCK_TXNS_AFTER_FILTERING` or adjusting the validator transaction pull to respect the filtering limits:

```rust
// Alternative: Respect filtering limits when pulling validator txns
min(
    min(params.max_txns.count(), params.max_txns_after_filtering),
    self.validator_txn_config.per_block_limit_txn_count(),
),
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a test environment with `ValidatorTxnConfig.per_block_limit_txn_count = 150`
2. Triggering backpressure to reduce `max_block_txns_after_filtering` to 100
3. Having the validator transaction pool return 150 transactions
4. Observing the underflow in `max_txns_after_filtering` and `soft_max_txns_after_filtering`
5. Demonstrating that the corrupted values allow unlimited transaction count in user payload pulling

A full PoC would require modifying consensus configuration and simulating backpressure conditions in a test network.

## Notes

The vulnerability stems from an architectural mismatch between three different limit systems:
1. **Total block limits** (`max_txns.count()`) - defaults to 5000, used for validator txn pulling
2. **Filtering limits** (`max_txns_after_filtering`) - can be reduced to 100 by backpressure
3. **Governance limits** (`per_block_limit_txn_count`) - can be set to any value

The code assumes validator transaction count will always be less than filtering limits, but this assumption breaks when governance legitimately increases the limit for protocol upgrades. The use of unchecked subtraction makes this a silent failure that only manifests under specific conditions, making it particularly dangerous.

### Citations

**File:** consensus/src/payload_client/mixed.rs (L69-72)
```rust
                min(
                    params.max_txns.count(),
                    self.validator_txn_config.per_block_limit_txn_count(),
                ),
```

**File:** consensus/src/payload_client/mixed.rs (L94-95)
```rust
        user_txn_pull_params.max_txns_after_filtering -= validator_txns.len() as u64;
        user_txn_pull_params.soft_max_txns_after_filtering -= validator_txns.len() as u64;
```

**File:** types/src/on_chain_config/consensus_config.rs (L125-177)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT: u64 = 2;
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum ValidatorTxnConfig {
    /// Disabled. In Jolteon, it also means to not use `BlockType::ProposalExt`.
    V0,
    /// Enabled. Per-block vtxn count and their total bytes are limited.
    V1 {
        per_block_limit_txn_count: u64,
        per_block_limit_total_bytes: u64,
    },
}

impl ValidatorTxnConfig {
    pub fn default_for_genesis() -> Self {
        Self::V1 {
            per_block_limit_txn_count: VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT,
            per_block_limit_total_bytes: VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT,
        }
    }

    pub fn default_if_missing() -> Self {
        Self::V0
    }

    pub fn default_disabled() -> Self {
        Self::V0
    }

    pub fn default_enabled() -> Self {
        Self::V1 {
            per_block_limit_txn_count: VTXN_CONFIG_PER_BLOCK_LIMIT_TXN_COUNT_DEFAULT,
            per_block_limit_total_bytes: VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT,
        }
    }

    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }

    pub fn per_block_limit_txn_count(&self) -> u64 {
        match self {
            ValidatorTxnConfig::V0 => 0,
            ValidatorTxnConfig::V1 {
                per_block_limit_txn_count,
                ..
            } => *per_block_limit_txn_count,
        }
    }
```

**File:** config/src/config/quorum_store_config.rs (L13-13)
```rust
pub const DEFEAULT_MAX_BATCH_TXNS: usize = 50;
```

**File:** config/src/config/consensus_config.rs (L28-28)
```rust
const MIN_BLOCK_TXNS_AFTER_FILTERING: u64 = DEFEAULT_MAX_BATCH_TXNS as u64 * 2;
```

**File:** config/src/config/consensus_config.rs (L291-318)
```rust
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 2500,
                    max_sending_block_txns_after_filtering_override: 1000,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 3500,
                    max_sending_block_txns_after_filtering_override: 200,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 4500,
                    max_sending_block_txns_after_filtering_override: 30,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
                PipelineBackpressureValues {
                    back_pressure_pipeline_latency_limit_ms: 6000,
                    // in practice, latencies and delay make it such that ~2 blocks/s is max,
                    // meaning that most aggressively we limit to ~10 TPS
                    // For transactions that are more expensive than that, we should
                    // instead rely on max gas per block to limit latency.
                    max_sending_block_txns_after_filtering_override: 5,
                    max_sending_block_bytes_override: MIN_BLOCK_BYTES_OVERRIDE,
                    backpressure_proposal_delay_ms: 300,
                },
```

**File:** consensus/src/liveness/proposal_generator.rs (L827-837)
```rust
        let (max_block_txns_after_filtering, max_txns_from_block_to_execute) = if self
            .min_max_txns_in_block_after_filtering_from_backpressure
            > max_block_txns_after_filtering
        {
            (
                self.min_max_txns_in_block_after_filtering_from_backpressure,
                Some(max_block_txns_after_filtering),
            )
        } else {
            (max_block_txns_after_filtering, None)
        };
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L651-682)
```rust
                        if cur_all_txns + batch.size() > max_txns
                            || unique_txns > max_txns_after_filtering
                        {
                            // Exceeded the limit for requested bytes or number of transactions.
                            full = true;
                            return false;
                        }
                        cur_all_txns += batch.size();
                        // Add this batch to filtered_txns and calculate the number of
                        // unique transactions added in the result so far.
                        cur_unique_txns +=
                            item.txn_summaries
                                .as_ref()
                                .map_or(batch.num_txns(), |summaries| {
                                    summaries
                                        .iter()
                                        .filter(|summary| {
                                            filtered_txns.insert(**summary)
                                                && block_timestamp.as_secs()
                                                    < summary.expiration_timestamp_secs
                                        })
                                        .count() as u64
                                });
                        assert!(item.proof.is_none() == batches_without_proofs);
                        result.push(item);
                        if cur_all_txns == max_txns
                            || cur_unique_txns == max_txns_after_filtering
                            || cur_unique_txns >= soft_max_txns_after_filtering
                        {
                            full = true;
                            return false;
                        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
