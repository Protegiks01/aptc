# Audit Report

## Title
Unbounded Memory Growth in Mempool Due to Account Sequence Number Map Leak

## Summary
The `account_sequence_numbers` HashMap in the mempool's `TransactionStore` grows unbounded over time. When transactions are committed on-chain, all validator nodes receive commit notifications and unconditionally insert entries into this map, but cleanup only occurs when removing the last transaction for an account from the mempool. This creates a memory leak where accounts that never submitted transactions to a particular node still accumulate entries, eventually causing memory exhaustion and validator node slowdowns.

## Finding Description

The vulnerability exists in the transaction commit handling within `TransactionStore`. The mempool maintains an `account_sequence_numbers` HashMap that tracks sequence numbers for accounts with transactions. [1](#0-0) 

**Problematic Execution Flow:**

1. **Universal Commit Notifications**: When consensus commits a block, state sync notifies ALL mempool nodes via `MempoolCommitNotification`, regardless of whether each node had the transactions in their local mempool. [2](#0-1) 

2. **Notification Processing**: Each node's mempool coordinator receives these notifications and processes them through `handle_commit_notification`. [3](#0-2) 

3. **Unconditional Insert**: For each committed sequence-number-based transaction, `commit_transaction()` unconditionally inserts the account's new sequence number into `account_sequence_numbers`, even if the account has no transactions in this node's mempool. [4](#0-3) 

4. **Inadequate Cleanup**: The subsequent calls to `clean_committed_transactions_below_account_seq_num()` and `process_ready_seq_num_based_transactions()` only operate on accounts that exist in the `transactions` map, leaving entries for accounts without local transactions untouched. [5](#0-4) 

5. **Single Cleanup Path**: The ONLY mechanism that removes entries from `account_sequence_numbers` is `index_remove()`, which is called when removing transactions from the mempool and only clears the entry when it's the last transaction for that account. [6](#0-5) 

6. **GC Cannot Help**: The garbage collection process also relies on having transactions in the mempool to trigger cleanup, so it cannot remove orphaned entries. [7](#0-6) 

**Critical Issue**: If `commit_transaction()` processes a notification for an account that has NO transactions in this node's mempool, an entry is inserted into `account_sequence_numbers` but will NEVER be cleaned up, as all cleanup paths require the account to have transactions present.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program's "Validator Node Slowdowns" category.

**Memory Impact:**
- Each HashMap entry consumes approximately 56+ bytes (32-byte `AccountAddress` + 8-byte `u64` + HashMap overhead)
- Over weeks/months of operation, millions of unique accounts transacting across the network accumulate entries
- Result: Hundreds of MB to multiple GB of leaked memory per validator node
- Progressive degradation: Memory pressure increases over time, impacting node performance
- No natural bounds: Growth continues indefinitely until node restart

**Network-Wide Effects:**
- All validator nodes affected equally (deterministic behavior)
- Consensus performance degrades as nodes experience memory pressure
- Potential for node instability or crashes under extreme memory exhaustion
- Requires periodic node restarts as operational workaround

This violates the fundamental resource management invariant that all operations must respect computational and memory limits. The unbounded growth has no protocol-level mitigation.

## Likelihood Explanation

**Likelihood: HIGH** - This vulnerability triggers automatically during normal blockchain operation without any malicious activity.

**Certainty Factors:**
1. **Guaranteed Occurrence**: Every unique account that commits ANY transaction anywhere in the network adds an entry to ALL validator nodes' mempools
2. **No Attacker Required**: Organic user growth and normal transaction activity naturally trigger the leak
3. **Accelerated by Design**: Aptos's high-throughput architecture means more unique accounts are processed rapidly
4. **No Mitigation Available**: No configuration settings, gas limits, or operational procedures can prevent this accumulation
5. **Monotonic Growth**: Entries never decrease—only node restarts clear the accumulated state

**Timeline Estimation:**
- Mainnet with millions of active accounts: Significant accumulation within months
- High-activity events (airdrops, NFT launches): Accelerated growth with many new accounts
- Production Impact: Observable memory growth over operational timescales

## Recommendation

Implement cleanup logic in `commit_transaction()` that removes `account_sequence_numbers` entries for accounts with no transactions in the mempool:

```rust
pub fn commit_transaction(
    &mut self,
    account: &AccountAddress,
    replay_protector: ReplayProtector,
) {
    match replay_protector {
        ReplayProtector::SequenceNumber(txn_sequence_number) => {
            let current_account_seq_number =
                self.get_account_sequence_number(account).map_or(0, |v| *v);
            let new_account_seq_number =
                max(current_account_seq_number, txn_sequence_number + 1);
            
            // Check if account has transactions in mempool
            if let Some(txns) = self.transactions.get(account) {
                if !txns.is_empty() {
                    self.account_sequence_numbers
                        .insert(*account, new_account_seq_number);
                }
            } else {
                // Account has no transactions - remove any existing entry
                self.account_sequence_numbers.remove(account);
            }
            
            self.clean_committed_transactions_below_account_seq_num(
                account,
                new_account_seq_number,
            );
            self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
        },
        // ... rest unchanged
    }
}
```

Alternatively, only update `account_sequence_numbers` when the account has transactions in the mempool, avoiding insertion entirely for accounts without local transactions.

## Proof of Concept

This vulnerability manifests through normal blockchain operation. To observe:

1. Monitor a validator node's mempool memory usage over time
2. Track the size of `account_sequence_numbers` HashMap through debugging or metrics
3. Observe that as unique accounts commit transactions across the network (even those never submitted to this node), entries accumulate
4. Verify that entries persist indefinitely until node restart
5. Calculate memory growth rate: entries_accumulated × ~56 bytes per entry

A synthetic test demonstrating the leak:

```rust
#[test]
fn test_account_sequence_numbers_leak() {
    let mut store = TransactionStore::new(&MempoolConfig::default());
    
    // Simulate commit notifications for accounts not in mempool
    for i in 0..1000 {
        let account = AccountAddress::random();
        store.commit_transaction(&account, ReplayProtector::SequenceNumber(0));
    }
    
    // Verify entries persist despite no transactions in mempool
    assert_eq!(store.transactions.len(), 0, "No transactions should exist");
    assert_eq!(store.account_sequence_numbers.len(), 1000, "All entries leaked");
}
```

The leak accumulates at the rate of unique accounts transacting on-chain, with no cleanup mechanism.

### Citations

**File:** mempool/src/core_mempool/transaction_store.rs (L55-55)
```rust
    pub(crate) account_sequence_numbers: HashMap<AccountAddress, u64>,
```

**File:** mempool/src/core_mempool/transaction_store.rs (L635-665)
```rust
    fn clean_committed_transactions_below_account_seq_num(
        &mut self,
        address: &AccountAddress,
        account_sequence_number: u64,
    ) {
        // Remove all previous seq number transactions for this account.
        // This can happen if transactions are sent to multiple nodes and one of the
        // nodes has sent the transaction to consensus but this node still has the
        // transaction sitting in mempool.
        if let Some(txns) = self.transactions.get_mut(address) {
            let mut active = txns.seq_num_split_off(account_sequence_number);
            let txns_for_removal = txns.clone();
            txns.clear();
            txns.append(&mut active);

            let mut rm_txns = match aptos_logger::enabled!(Level::Trace) {
                true => TxnsLog::new(),
                false => TxnsLog::new_with_max(10),
            };
            for transaction in txns_for_removal.values() {
                rm_txns.add(transaction.get_sender(), transaction.get_replay_protector());
                self.index_remove(transaction);
            }
            trace!(
                LogSchema::new(LogEntry::CleanCommittedTxn).txns(rm_txns),
                "txns cleaned with committing tx {}:{}",
                address,
                account_sequence_number
            );
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L671-707)
```rust
    pub fn commit_transaction(
        &mut self,
        account: &AccountAddress,
        replay_protector: ReplayProtector,
    ) {
        match replay_protector {
            ReplayProtector::SequenceNumber(txn_sequence_number) => {
                let current_account_seq_number =
                    self.get_account_sequence_number(account).map_or(0, |v| *v);
                let new_account_seq_number =
                    max(current_account_seq_number, txn_sequence_number + 1);
                self.account_sequence_numbers
                    .insert(*account, new_account_seq_number);
                self.clean_committed_transactions_below_account_seq_num(
                    account,
                    new_account_seq_number,
                );
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
            },
            ReplayProtector::Nonce(nonce) => {
                if let Some(txns) = self.transactions.get_mut(account) {
                    if let Some(txn) = txns.remove(&ReplayProtector::Nonce(nonce)) {
                        self.index_remove(&txn);
                        trace!(
                            LogSchema::new(LogEntry::CleanCommittedTxn).txns(TxnsLog::new_txn(
                                txn.get_sender(),
                                txn.get_replay_protector()
                            )),
                            "txns cleaned with committing tx {}:{:?}",
                            txn.get_sender(),
                            txn.get_replay_protector()
                        );
                    }
                }
            },
        }
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L758-765)
```rust
        // Remove account datastructures if there are no more transactions for the account.
        let address = &txn.get_sender();
        if let Some(txns) = self.transactions.get(address) {
            if txns.len() == 0 {
                self.transactions.remove(address);
                self.account_sequence_numbers.remove(address);
            }
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L913-1006)
```rust
    fn gc(&mut self, now: Duration, by_system_ttl: bool) {
        let (metric_label, index, log_event) = if by_system_ttl {
            (
                counters::GC_SYSTEM_TTL_LABEL,
                &mut self.system_ttl_index,
                LogEvent::SystemTTLExpiration,
            )
        } else {
            (
                counters::GC_CLIENT_EXP_LABEL,
                &mut self.expiration_time_index,
                LogEvent::ClientExpiration,
            )
        };
        counters::CORE_MEMPOOL_GC_EVENT_COUNT
            .with_label_values(&[metric_label])
            .inc();

        let mut gc_txns = index.gc(now);
        // sort the expired txns by order of replay protector per account
        gc_txns.sort_by_key(|key| (key.address, key.replay_protector));
        let mut gc_iter = gc_txns.iter().peekable();

        let mut gc_txns_log = match aptos_logger::enabled!(Level::Trace) {
            true => TxnsLog::new(),
            false => TxnsLog::new_with_max(10),
        };
        while let Some(key) = gc_iter.next() {
            if let Some(txns) = self.transactions.get_mut(&key.address) {
                // If a sequence number transaction is garbage collected, then its subsequent transactions are marked as non-ready.
                // As orderless transactions (transactions with nonce) are always ready, they are not affected by this.
                if let ReplayProtector::SequenceNumber(seq_num) = key.replay_protector {
                    let park_range_start = Bound::Excluded(seq_num);
                    let park_range_end = gc_iter
                        .peek()
                        .filter(|next_key| key.address == next_key.address)
                        .map_or(Bound::Unbounded, |next_key| {
                            match next_key.replay_protector {
                                ReplayProtector::SequenceNumber(next_seq_num) => {
                                    Bound::Excluded(next_seq_num)
                                },
                                ReplayProtector::Nonce(_) => Bound::Unbounded,
                            }
                        });
                    // mark all following txns as non-ready, i.e. park them
                    for (_, t) in txns.seq_num_range_mut((park_range_start, park_range_end)) {
                        self.parking_lot_index.insert(t);
                        self.priority_index.remove(t);
                        let sender_bucket = sender_bucket(&t.get_sender(), self.num_sender_buckets);
                        self.timeline_index
                            .get_mut(&sender_bucket)
                            .unwrap_or_else(|| {
                                panic!(
                                    "Unable to get the timeline index for the sender bucket {}",
                                    sender_bucket
                                )
                            })
                            .remove(t);
                        if let TimelineState::Ready(_) = t.timeline_state {
                            t.timeline_state = TimelineState::NotReady;
                        }
                    }
                }

                if let Some(txn) = txns.remove(&key.replay_protector) {
                    let is_active = self.priority_index.contains(&txn);
                    let status = if is_active {
                        counters::GC_ACTIVE_TXN_LABEL
                    } else {
                        counters::GC_PARKED_TXN_LABEL
                    };
                    let account = txn.get_sender();
                    gc_txns_log.add_with_status(account, txn.get_replay_protector(), status);
                    if let Ok(time_delta) =
                        SystemTime::now().duration_since(txn.insertion_info.insertion_time)
                    {
                        counters::CORE_MEMPOOL_GC_LATENCY
                            .with_label_values(&[metric_label, status])
                            .observe(time_delta.as_secs_f64());
                    }

                    // remove txn
                    self.index_remove(&txn);
                }
            }
        }

        if !gc_txns_log.is_empty() {
            debug!(LogSchema::event_log(LogEntry::GCRemoveTxns, log_event).txns(gc_txns_log));
        } else {
            trace!(LogSchema::event_log(LogEntry::GCRemoveTxns, log_event).txns(gc_txns_log));
        }
        self.track_indices();
    }
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L77-116)
```rust
    async fn notify_new_commit(
        &self,
        transactions: Vec<Transaction>,
        block_timestamp_usecs: u64,
    ) -> Result<(), Error> {
        // Get only user transactions from committed transactions
        let user_transactions: Vec<CommittedTransaction> = transactions
            .iter()
            .filter_map(|transaction| match transaction {
                Transaction::UserTransaction(signed_txn) => Some(CommittedTransaction {
                    sender: signed_txn.sender(),
                    replay_protector: signed_txn.replay_protector(),
                    use_case: signed_txn.parse_use_case(),
                }),
                _ => None,
            })
            .collect();

        // Mempool needs to be notified about all transactions (user and non-user transactions).
        // See https://github.com/aptos-labs/aptos-core/issues/1882 for more details.
        let commit_notification = MempoolCommitNotification {
            transactions: user_transactions,
            block_timestamp_usecs,
        };

        // Send the notification to mempool
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(commit_notification)
            .await
        {
            return Err(Error::CommitNotificationError(format!(
                "Failed to notify mempool of committed transactions! Error: {:?}",
                error
            )));
        }

        Ok(())
    }
```

**File:** mempool/src/shared_mempool/coordinator.rs (L229-265)
```rust
fn handle_commit_notification<TransactionValidator>(
    mempool: &Arc<Mutex<CoreMempool>>,
    mempool_validator: &Arc<RwLock<TransactionValidator>>,
    use_case_history: &Arc<Mutex<UseCaseHistory>>,
    msg: MempoolCommitNotification,
    num_committed_txns_received_since_peers_updated: &Arc<AtomicU64>,
) where
    TransactionValidator: TransactionValidation,
{
    debug!(
        block_timestamp_usecs = msg.block_timestamp_usecs,
        num_committed_txns = msg.transactions.len(),
        LogSchema::event_log(LogEntry::StateSyncCommit, LogEvent::Received),
    );

    // Process and time committed user transactions.
    let start_time = Instant::now();
    counters::mempool_service_transactions(
        counters::COMMIT_STATE_SYNC_LABEL,
        msg.transactions.len(),
    );
    num_committed_txns_received_since_peers_updated
        .fetch_add(msg.transactions.len() as u64, Ordering::Relaxed);
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
    mempool_validator.write().notify_commit();
    let latency = start_time.elapsed();
    counters::mempool_service_latency(
        counters::COMMIT_STATE_SYNC_LABEL,
        counters::REQUEST_SUCCESS_LABEL,
        latency,
    );
}
```
