# Audit Report

## Title
Zero Concurrency Panic: Node Crash Due to CPU Detection Failure in Containerized Environments

## Summary
A logic flaw in the multi-stage concurrency level calculation causes validator and full node crashes when `num_cpus::get()` returns 0 in containerized environments. The `min()` operation in `AptosVM::set_concurrency_level_once()` defeats the safety guardrail provided by the earlier `clamp()` operation, resulting in a zero concurrency level that triggers an immediate panic in `BlockExecutor::new()`.

## Finding Description

The vulnerability exists in the concurrency level initialization sequence where two consecutive operations create an exploitable logic flaw:

**Execution Path:**

1. **Default Configuration**: `ExecutionConfig` defaults `concurrency_level` to 0, triggering fallback logic. [1](#0-0) 

2. **First Safeguard - Clamp Operation**: When `concurrency_level == 0`, the code calculates `((num_cpus::get() / 2) as u16).clamp(1, 32)` ensuring a minimum value of 1. [2](#0-1) 

3. **Safeguard Bypass - Min Operation**: The clamped value is passed to `AptosVM::set_concurrency_level_once()` [3](#0-2)  which performs `concurrency_level = min(concurrency_level, num_cpus::get())`. [4](#0-3) 

4. **Zero Value Storage**: If `num_cpus::get()` returns 0, then `min(1, 0) = 0`, storing zero in `EXECUTION_CONCURRENCY_LEVEL`. [5](#0-4) 

5. **Value Retrieval**: When blocks need execution, `get_concurrency_level()` retrieves the stored zero value (not the fallback default of 1, because the value IS set). [6](#0-5)  This zero is used to create `BlockExecutorConfig`. [7](#0-6) 

6. **Panic Trigger**: `BlockExecutor::new()` is called with this config [8](#0-7)  and immediately panics on the assertion `config.local.concurrency_level > 0`. [9](#0-8) 

The sequential execution fallback check at `if self.config.local.concurrency_level > 1` [10](#0-9)  is unreachable because the constructor panics first.

## Impact Explanation

**HIGH Severity** per Aptos Bug Bounty criteria:

- **Validator node crashes**: Complete node failure with immediate panic, preventing all block execution
- **API crashes**: The entire node process terminates, making all APIs unavailable
- **Loss of liveness**: Affected validators cannot participate in consensus, reducing network capacity
- **Protocol violation**: Breaks availability guarantees

This aligns with the HIGH severity category "API Crashes" which explicitly includes crashes affecting network participation and "Validator Node Slowdowns" via DoS through resource exhaustion issues.

The impact is HIGH (not Critical) because:
- No funds are lost or stolen
- No consensus safety violation occurs (only liveness affected)
- Network recovers when nodes are properly configured
- No permanent state corruption

## Likelihood Explanation

**MEDIUM Likelihood:**

**Triggering Conditions:**
1. Node uses default `concurrency_level: 0` configuration (default for all new deployments)
2. `num_cpus::get()` returns 0 in containerized environments with fractional CPU limits (`--cpus=0.5`), Kubernetes CPU limits < 1.0, or restrictive cgroup configurations

**Mitigation Factors:**
- Operators can explicitly set `concurrency_level` to a non-zero value in configuration
- Most production deployments allocate â‰¥1 CPU
- Issue is immediately detectable (node crashes on startup when processing first block)
- Does not affect properly configured deployments

## Recommendation

Fix the logic flaw by ensuring the `min()` operation cannot reduce the concurrency level below the clamped minimum:

```rust
pub fn set_concurrency_level_once(mut concurrency_level: usize) {
    concurrency_level = min(concurrency_level, num_cpus::get()).max(1);
    // Only the first call succeeds, due to OnceCell semantics.
    EXECUTION_CONCURRENCY_LEVEL.set(concurrency_level).ok();
}
```

Alternatively, remove the redundant `min()` operation entirely since the caller already performs proper clamping, or validate that `num_cpus::get() > 0` before using it.

## Proof of Concept

To reproduce in a containerized environment:

```bash
# Run node with fractional CPU allocation
docker run --cpus=0.5 aptos-node:latest

# Node will crash on first block execution with:
# thread 'main' panicked at 'Parallel execution concurrency level 0 should be between 1 and number of CPUs (0)'
```

The panic occurs at the assertion in `BlockExecutor::new()` when attempting to process the first block.

## Notes

This is a genuine logic flaw where the defensive programming intent (the `clamp(1, 32)` operation) is defeated by a subsequent operation (`min()` with potentially zero value). While the scenario requires specific containerization configurations, it represents a real deployment risk for cloud-native Aptos nodes using fractional CPU allocations for cost optimization.

### Citations

**File:** config/src/config/execution_config.rs (L84-84)
```rust
            concurrency_level: 0,
```

**File:** aptos-node/src/utils.rs (L57-61)
```rust
    let effective_concurrency_level = if node_config.execution.concurrency_level == 0 {
        ((num_cpus::get() / 2) as u16).clamp(1, DEFAULT_EXECUTION_CONCURRENCY_LEVEL)
    } else {
        node_config.execution.concurrency_level
    };
```

**File:** aptos-node/src/utils.rs (L62-62)
```rust
    AptosVM::set_concurrency_level_once(effective_concurrency_level as usize);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L427-427)
```rust
        concurrency_level = min(concurrency_level, num_cpus::get());
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L429-429)
```rust
        EXECUTION_CONCURRENCY_LEVEL.set(concurrency_level).ok();
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L436-441)
```rust
    pub fn get_concurrency_level() -> usize {
        match EXECUTION_CONCURRENCY_LEVEL.get() {
            Some(concurrency_level) => *concurrency_level,
            None => 1,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3110-3119)
```rust
        let config = BlockExecutorConfig {
            local: BlockExecutorLocalConfig {
                blockstm_v2: AptosVM::get_blockstm_v2_enabled(),
                concurrency_level: AptosVM::get_concurrency_level(),
                allow_fallback: true,
                discard_failed_blocks: AptosVM::get_discard_failed_blocks(),
                module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
            },
            onchain: onchain_config,
        };
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L545-550)
```rust
        let executor =
            BlockExecutor::<SignatureVerifiedTransaction, E, S, L, TP, AuxiliaryInfo>::new(
                config,
                executor_thread_pool,
                transaction_commit_listener,
            );
```

**File:** aptos-move/block-executor/src/executor.rs (L127-132)
```rust
        assert!(
            config.local.concurrency_level > 0 && config.local.concurrency_level <= num_cpus,
            "Parallel execution concurrency level {} should be between 1 and number of CPUs ({})",
            config.local.concurrency_level,
            num_cpus,
        );
```

**File:** aptos-move/block-executor/src/executor.rs (L2557-2557)
```rust
        if self.config.local.concurrency_level > 1 {
```
