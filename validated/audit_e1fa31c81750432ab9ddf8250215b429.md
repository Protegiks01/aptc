# Audit Report

## Title
Block Tree Window Traversal Bypasses Pruning Boundary Causing Validator Failures

## Summary
The `get_ordered_block_window()` function in `BlockTree` traverses parent blocks without validating against the `window_root` pruning boundary. When `window_size` is configured large enough, the traversal can attempt to access pruned blocks that have been removed from memory, causing validator nodes to fail block insertion.

## Finding Description

The vulnerability exists in the consensus block storage layer where tree traversal and pruning boundaries are not properly synchronized.

When a new block arrives, `BlockStore::insert_block()` validates only against the `ordered_root`: [1](#0-0) 

This validation does NOT check whether the block's execution window would extend below the `window_root` pruning boundary. The function then calls `get_ordered_block_window()`: [2](#0-1) 

The `get_ordered_block_window()` implementation calculates a window start round and traverses backwards through parent blocks: [3](#0-2) 

The `calculate_window_start_round()` function computes: `(current_round + 1).saturating_sub(window_size)` [4](#0-3) 

The traversal loop condition checks only genesis and round constraints, NOT the `window_root_id`: [5](#0-4) 

Meanwhile, the pruning mechanism removes blocks below `window_root`. After the pruned buffer exceeds `max_pruned_blocks_in_mem` (default 100), blocks are permanently removed from the `id_to_block` HashMap: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Window root advances to round 100 after commit via `commit_callback()`
2. Blocks before round 100 are pruned and eventually removed from memory
3. Ordered root is at round 110, `window_size` is configured to 15
4. New block at round 111 arrives
5. Validation passes: `111 > 110` âœ“
6. `window_start_round = (111 + 1) - 15 = 97`
7. Traversal reaches block 100 (window root)
8. Block 100's QC certifies round 99
9. Condition `99 >= 97` evaluates true, continues traversal
10. Attempts `get_block(block_99_id)` which returns `None` (pruned)
11. Function bails with "Parent block not found"
12. Validator fails to insert legitimate block 111

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria:

**Validator Node Slowdowns**: Validators fail to insert blocks when the window calculation attempts to access pruned blocks. The `bail!()` macro causes insertion failure, requiring retries or manual intervention. Multiple validators can be affected simultaneously due to similar pruning states.

**API Crashes**: The error propagates through the consensus pipeline, potentially affecting the ability of validators to process incoming blocks.

**Protocol Violations**: Breaks the tree consistency invariant that blocks reachable through traversal should have accessible parents.

While not causing fund loss, this affects **network liveness** - validators cannot process legitimate blocks, potentially degrading consensus progress and network availability.

## Likelihood Explanation

**Likelihood: Configuration-Dependent**

**With Default Configuration: Very Low**
The default `window_size` is `None` (execution pool disabled) or `Some(1)` when enabled: [8](#0-7) 

With `window_size = 1`, this vulnerability is extremely unlikely to trigger in practice.

**With Large window_size Configuration: Medium**
If operators configure `window_size` to larger values (e.g., 10-50) for performance optimization, the vulnerability becomes exploitable.

**Required Conditions:**
- `window_size` large enough that `block.round() - window_size + 1 < window_root.round()`
- Gap between `window_root` and `ordered_root` less than `window_size`
- More than 100 blocks have been pruned (natural in long-running networks)

**Triggering Scenarios:**
- Normal operation with non-default configuration
- Network delays causing blocks to arrive after pruning
- Byzantine validator crafting blocks to deliberately trigger the condition

## Recommendation

Add validation in `insert_block()` to ensure the block's execution window will not extend below the `window_root`:

```rust
pub async fn insert_block(&self, block: Block) -> anyhow::Result<Arc<PipelinedBlock>> {
    if let Some(existing_block) = self.get_block(block.id()) {
        return Ok(existing_block);
    }
    
    let inner = self.inner.read();
    ensure!(
        inner.ordered_root().round() < block.round(),
        "Block with old round"
    );
    
    // Add window_root validation
    if let Some(window_size) = self.window_size {
        let window_start_round = calculate_window_start_round(block.round(), window_size);
        ensure!(
            window_start_round >= inner.window_root().round(),
            "Block window extends below window_root (window_start: {}, window_root: {})",
            window_start_round,
            inner.window_root().round()
        );
    }
    
    let block_window = inner.get_ordered_block_window(&block, self.window_size)?;
    // ... rest of implementation
}
```

Alternatively, add a boundary check in `get_ordered_block_window()` to stop traversal at `window_root_id`.

## Proof of Concept

```rust
#[tokio::test]
async fn test_window_traversal_below_window_root() {
    // Setup: Create block tree with large window_size
    let window_size = Some(15u64);
    let max_pruned_blocks_in_mem = 100;
    
    // Create 120 blocks: Genesis -> B1 -> ... -> B120
    // After pruning, only keep blocks >= B100
    
    // Prune up to block 100 (simulate commit_callback)
    block_store.prune_tree(b100.id());
    
    // Wait for pruned buffer to fill and blocks to be removed
    // (after 100+ pruned blocks)
    
    // Create new block at round 111
    let b111 = Block::new(..., round: 111, parent: b110.id());
    
    // This should fail with "Parent block not found"
    // because window_start_round = 111 - 15 + 1 = 97
    // which is below window_root (100)
    let result = block_store.insert_block(b111).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Parent block not found"));
}
```

## Notes

This vulnerability is **configuration-dependent** and requires non-default `window_size` values to be exploitable. The default configuration (`window_size = None` or `Some(1)`) makes this extremely unlikely in production environments. However, the vulnerability represents a genuine logic flaw that should be addressed, as operators may legitimately configure larger window sizes for performance tuning without awareness of this edge case.

The issue affects the liveness property of the consensus system rather than safety - it cannot cause fund loss or consensus violations, but can prevent validators from processing blocks under specific timing and configuration conditions.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L416-418)
```rust
        ensure!(
            self.inner.read().ordered_root().round() < block.round(),
            "Block with old round"
```

**File:** consensus/src/block_storage/block_store.rs (L421-424)
```rust
        let block_window = self
            .inner
            .read()
            .get_ordered_block_window(&block, self.window_size)?;
```

**File:** consensus/src/block_storage/block_tree.rs (L282-282)
```rust
        let window_start_round = calculate_window_start_round(round, window_size);
```

**File:** consensus/src/block_storage/block_tree.rs (L290-298)
```rust
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
            if let Some(current_pipelined_block) = self.get_block(&current_block.parent_id()) {
                current_block = current_pipelined_block.block().clone();
                window.push(current_pipelined_block);
            } else {
                bail!("Parent block not found for block {}", current_block.id());
            }
```

**File:** consensus/src/block_storage/block_tree.rs (L502-509)
```rust
        if self.pruned_block_ids.len() > self.max_pruned_blocks_in_mem {
            let num_blocks_to_remove = self.pruned_block_ids.len() - self.max_pruned_blocks_in_mem;
            for _ in 0..num_blocks_to_remove {
                if let Some(id) = self.pruned_block_ids.pop_front() {
                    self.remove_block(id);
                }
            }
        }
```

**File:** consensus/src/util/mod.rs (L26-28)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
```

**File:** config/src/config/consensus_config.rs (L232-232)
```rust
            max_pruned_blocks_in_mem: 100,
```

**File:** types/src/on_chain_config/consensus_config.rs (L12-13)
```rust
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```
