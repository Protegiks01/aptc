# Audit Report

## Title
JWK Ord Trait Contract Violation Enables Potential Consensus Liveness Failure Through Non-Deterministic Sorting

## Summary
The `Ord` implementation for the `JWK` enum violates Rust's trait contract by comparing only by `id()` while `PartialEq` compares all fields. Combined with HashMap usage in the per-key consensus path (enabled by default), this can lead to non-deterministic behavior when JWKs with identical IDs but different cryptographic properties are processed, potentially causing consensus liveness failures in the JWK subsystem.

## Finding Description

**Trait Contract Violation:**

The `JWK` enum implements `Ord` by comparing only the key ID via `id()`: [1](#0-0) 

However, `PartialEq` is derived on the enum and compares all fields: [2](#0-1) 

The `RSA_JWK` structure contains multiple fields beyond `kid` (key ID), including cryptographic properties `n` (modulus), `e` (exponent), and `alg` (algorithm): [3](#0-2) 

This violates Rust's `Ord` trait contract requirement that `a.cmp(b) == Ordering::Equal` implies `a == b` must be true. Two JWKs with identical `kid` but different `n`, `e`, or `alg` values will compare as Equal via `Ord` but return false for `PartialEq`.

**Exploitation Path:**

1. A malicious or compromised OIDC provider returns multiple RSA_JWK entries with identical `kid` values but different cryptographic properties
2. Validators fetch and sort the JWK set using stable sort: [4](#0-3) 

3. Due to the Ord violation, JWKs with the same `kid` compare as Equal, and stable sort preserves their relative input order. Different validators may receive different JSON array orders from the OIDC provider (via CDN routing or intentional manipulation)

4. In per-key consensus mode, the sorted vector is converted to a HashMap where duplicate keys cause only the last value to survive: [5](#0-4) 

5. Different validators end up with different JWKs for the same key ID, leading to divergent consensus proposals that cannot reach quorum

**Invariant Violations:**

The Aptos secure coding guidelines explicitly prohibit HashMap/HashSet in consensus paths due to non-deterministic ordering: [6](#0-5) 

The Move framework expects JWKs to be sorted and unique by ID: [7](#0-6) 

The Move upsert logic assumes JWKs with identical IDs are equivalent and replaces them: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria ("Validator node slowdowns"):

- **Consensus Liveness Failure**: JWK consensus would repeatedly fail to reach quorum for affected issuers, as validators propose different updates based on their different JWK observations
- **Manual Intervention Required**: The consensus manager would be unable to certify updates, requiring provider removal or manual resolution
- **Protocol Violation**: Breaks the deterministic execution guarantee explicitly documented in RUST_SECURE_CODING.md

The per-key consensus mode is **enabled by default** in production: [9](#0-8) 

This makes the vulnerability exploitable on mainnet without requiring feature flag activation.

## Likelihood Explanation

**Likelihood: Medium-Low**

Exploitation requires:
1. **Malicious OIDC Provider**: External third-party services (Google, Facebook, etc.) could be compromised or intentionally malicious - within Aptos threat model as untrusted external actors
2. **Duplicate Key IDs**: While non-standard, nothing in the code validates against duplicate `kid` values in JWK sets
3. **Per-Key Mode Enabled**: Confirmed enabled by default (see above citation)
4. **Different Orderings**: Achievable via CDN routing, load balancers, or intentional provider manipulation

While requiring external system compromise, this does not require insider validator access or >1/3 Byzantine validators, making it more feasible than consensus attacks requiring validator collusion.

## Recommendation

**Immediate Fix**: Align the `Ord` implementation with `PartialEq` by comparing all fields, or implement custom `PartialEq` that only compares by `id()`:

```rust
impl Ord for JWK {
    fn cmp(&self, other: &Self) -> Ordering {
        // Compare by id first, then by full equality for tie-breaking
        match self.id().cmp(&other.id()) {
            Ordering::Equal => {
                // Use serialization or field-by-field comparison
                // to establish total order
                match (self, other) {
                    (JWK::RSA(a), JWK::RSA(b)) => {
                        a.kid.cmp(&b.kid)
                            .then(a.kty.cmp(&b.kty))
                            .then(a.alg.cmp(&b.alg))
                            .then(a.e.cmp(&b.e))
                            .then(a.n.cmp(&b.n))
                    },
                    (JWK::Unsupported(a), JWK::Unsupported(b)) => {
                        a.id.cmp(&b.id).then(a.payload.cmp(&b.payload))
                    },
                    (JWK::RSA(_), _) => Ordering::Less,
                    (_, JWK::RSA(_)) => Ordering::Greater,
                }
            },
            other => other,
        }
    }
}
```

**Additional Safeguards**:
1. Add validation to reject JWK sets with duplicate `kid` values
2. Replace HashMap with BTreeMap in per-key consensus manager for deterministic ordering
3. Add consensus layer validation to detect and reject non-deterministic JWK proposals

## Proof of Concept

While a complete PoC would require setting up a malicious OIDC provider, the trait contract violation can be demonstrated with this unit test:

```rust
#[test]
fn test_jwk_ord_partialeq_inconsistency() {
    let jwk1 = JWK::RSA(RSA_JWK {
        kid: "key1".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: "modulus1".to_string(),
    });
    
    let jwk2 = JWK::RSA(RSA_JWK {
        kid: "key1".to_string(),
        kty: "RSA".to_string(),
        alg: "RS256".to_string(),
        e: "AQAB".to_string(),
        n: "modulus2".to_string(), // Different modulus
    });
    
    // Ord says they are equal
    assert_eq!(jwk1.cmp(&jwk2), Ordering::Equal);
    
    // But PartialEq says they are not equal
    assert_ne!(jwk1, jwk2);
    
    // This violates Rust's Ord trait contract
}
```

## Notes

This vulnerability combines three issues:
1. A fundamental Rust trait contract violation
2. Use of non-deterministic HashMap in consensus-critical code (violating documented guidelines)
3. A feature enabled by default that exposes the attack surface

The trait contract violation is a logic bug that exists regardless of the per-key mode, but the combination with HashMap creates the exploitable consensus failure scenario. OIDC providers are explicitly untrusted external actors in Aptos's threat model, making this attack feasible without requiring compromise of trusted roles.

### Citations

**File:** types/src/jwks/jwk/mod.rs (L53-57)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize, Union)]
pub enum JWK {
    RSA(RSA_JWK),
    Unsupported(UnsupportedJWK),
}
```

**File:** types/src/jwks/jwk/mod.rs (L74-78)
```rust
impl Ord for JWK {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id().cmp(&other.id())
    }
}
```

**File:** types/src/jwks/rsa/mod.rs (L18-25)
```rust
#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize, Object)]
pub struct RSA_JWK {
    pub kid: String,
    pub kty: String,
    pub alg: String,
    pub e: String,
    pub n: String,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L79-79)
```rust
                        jwks.sort();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L115-116)
```rust
        let observed_jwks_by_kid: HashMap<KID, JWK> =
            jwks.into_iter().map(|jwk| (jwk.id(), jwk)).collect();
```

**File:** RUST_SECURE_CODING.md (L121-132)
```markdown
### Data Structures with Deterministic Internal Order

Certain data structures, like HashMap and HashSet, do not guarantee a deterministic order for the elements stored within them. This lack of order can lead to problems in operations that require processing elements in a consistent sequence across multiple executions. In the Aptos blockchain, deterministic data structures help in achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes.

Below is a list of deterministic data structures available in Rust. Please note, this list may not be exhaustive:

- **BTreeMap:** maintains its elements in sorted order by their keys.
- **BinaryHeap:** It maintains its elements in a heap order, which is a complete binary tree where each parent node is less than or equal to its child nodes.
- **Vec**: It maintains its elements in the order in which they were inserted. ⚠️
- **LinkedList:** It maintains its elements in the order in which they were inserted. ⚠️
- **VecDeque:** It maintains its elements in the order in which they were inserted. ⚠️

```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L104-106)
```text
        /// Vector of `JWK`'s sorted by their unique ID (from `get_jwk_id`) in dictionary order.
        jwks: vector<JWK>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L626-654)
```text
    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {
        let found = false;
        let index = 0;
        let num_entries = vector::length(&set.jwks);
        while (index < num_entries) {
            let cur_entry = vector::borrow(&set.jwks, index);
            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));
            if (is_greater_than(&comparison)) {
                index = index + 1;
            } else {
                found = is_equal(&comparison);
                break
            }
        };

        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to
        // where we want to insert.
        let ret = if (found) {
            let entry = vector::borrow_mut(&mut set.jwks, index);
            let old_entry = option::some(*entry);
            *entry = jwk;
            old_entry
        } else {
            vector::insert(&mut set.jwks, index, jwk);
            option::none()
        };

        ret
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L261-261)
```rust
            FeatureFlag::JWK_CONSENSUS_PER_KEY_MODE,
```
