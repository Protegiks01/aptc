# Audit Report

## Title
Resource Group Metadata Validation Bypass Allows Type Parameter Injection Leading to State Inconsistency

## Summary
The `validate_resource_groups` function fails to validate that resource group member attributes specify resource groups without type parameters. This allows attackers to publish modules referencing the same resource group with different type arguments, causing resources to be stored at different StateKeys and breaking resource group co-location invariants.

## Finding Description

The resource group validation system has a critical gap that allows type parameter injection through maliciously crafted module metadata.

The validation in `validate_resource_groups` only checks resource groups by name lookup, not by the full StructTag including type parameters. The lookup occurs at line 91 where it retrieves the group scope using only the name string: [1](#0-0) 

When a `resource_group_member` attribute is parsed during module publishing, it successfully parses StructTags that include type parameters. The parsing occurs via string-to-StructTag conversion: [2](#0-1) 

The validation at module publishing time only verifies that the parsed StructTag is `Some`, without checking if `type_args` is empty: [3](#0-2) 

Resource groups themselves are correctly enforced to have no type parameters through explicit validation: [4](#0-3) 

At runtime, when resources are stored, the StateKey is computed using the full StructTag including type parameters: [5](#0-4) 

**Attack Execution Path:**
1. Attacker identifies a legitimate resource group `Bar` at `0x1::A::Bar` (no type parameters)
2. Attacker crafts module bytecode with metadata containing `#[resource_group_member(group = "0x1::A::Bar<u64>")]`
3. Submits via `publish_package_txn` which accepts raw bytecode: [6](#0-5) 
4. String `"0x1::A::Bar<u64>"` parses into `StructTag { name: "Bar", type_args: [u64] }`
5. Validation looks up "Bar" by name only, finds legitimate group, passes
6. Resources stored at `StateKey::resource_group(address, StructTag("Bar", [u64]))`
7. This differs from legitimate `StateKey::resource_group(address, StructTag("Bar", []))`
8. Resources that should be co-located are fragmented across different StateKeys

## Impact Explanation

**HIGH Severity** - This vulnerability causes multiple critical issues:

1. **State Consistency Violation**: Resources that must be stored together per the resource group invariant are fragmented across different StateKeys, breaking the fundamental guarantee that resource groups provide atomic access to co-located resources.

2. **Gas Calculation Errors**: The gas charging mechanism computes resource group size by serializing each tag including its type parameters. The size calculation includes the full tag: [7](#0-6)  Resources with injected type parameters will be charged based on different tag sizes, disrupting the intended gas model for resource groups.

3. **Protocol Invariant Violation**: The core assumption that all members of a resource group share a single StateKey is violated, which may cause unpredictable behavior in systems relying on this guarantee.

This qualifies as **"Significant protocol violations"** under HIGH Severity criteria, as it breaks fundamental Move VM resource group semantics and state management invariants.

## Likelihood Explanation

**HIGH Likelihood** - The attack is straightforward to execute:

1. **No Special Permissions**: Any user can publish modules to their own address via the `publish_package_txn` entry function which accepts raw bytecode.

2. **Simple Attack Vector**: The attacker only needs to:
   - Identify an existing resource group's StructTag
   - Craft module bytecode with type parameters in the `resource_group_member` metadata attribute
   - Submit a publish transaction

3. **Deterministic Bypass**: The validation gap exists consistently - validation checks by name only at: [8](#0-7)  making the bypass 100% reliable.

4. **No Economic Barriers**: Standard module publishing gas costs apply, with no additional requirements.

## Recommendation

Add validation to ensure `resource_group_member` attributes reference resource groups without type parameters:

```rust
// In verify_module_metadata_for_module_publishing
} else if attr.is_resource_group_member() {
    if let Some(group_tag) = attr.get_resource_group_member() {
        // Add this check:
        if !group_tag.type_args.is_empty() {
            return Err(AttributeValidationError {
                key: struct_.clone(),
                attribute: KnownAttributeKind::ResourceGroupMember as u8,
            }.into());
        }
        is_valid_resource_group_member(&structs, struct_)?;
        continue;
    }
}
```

## Proof of Concept

To demonstrate this vulnerability:

1. Deploy a legitimate resource group module at address `0x1`:
```move
#[resource_group(scope = global)]
struct MyGroup { dummy: u8 }
```

2. Craft bytecode for a malicious module with metadata containing:
```
#[resource_group_member(group = "0x1::module::MyGroup<u64>")]
struct Malicious has key { value: u64 }
```

3. Publish the crafted bytecode via `code::publish_package_txn`

4. Observe that validation passes despite the type parameter

5. At runtime, resources are stored at different StateKeys:
   - Legitimate: `StateKey::resource_group(addr, StructTag { name: "MyGroup", type_args: [] })`
   - Malicious: `StateKey::resource_group(addr, StructTag { name: "MyGroup", type_args: [u64] })`

This breaks the resource group co-location invariant, demonstrating the state consistency violation.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L89-95)
```rust
            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };
```

**File:** types/src/vm/module_metadata.rs (L138-144)
```rust
    pub fn get_resource_group_member(&self) -> Option<StructTag> {
        if self.kind == KnownAttributeKind::ResourceGroupMember as u8 {
            self.args.first()?.parse().ok()
        } else {
            None
        }
    }
```

**File:** types/src/vm/module_metadata.rs (L408-413)
```rust
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
```

**File:** types/src/vm/module_metadata.rs (L500-505)
```rust
                } else if attr.is_resource_group_member()
                    && attr.get_resource_group_member().is_some()
                {
                    is_valid_resource_group_member(&structs, struct_)?;
                    continue;
                }
```

**File:** types/src/state_store/state_key/mod.rs (L160-171)
```rust
    pub fn resource_group(address: &AccountAddress, struct_tag: &StructTag) -> Self {
        Self(
            REGISTRY
                .resource_group(struct_tag, address)
                .get_or_add(struct_tag, address, || {
                    Ok(StateKeyInner::AccessPath(
                        AccessPath::resource_group_access_path(*address, struct_tag.clone()),
                    ))
                })
                .expect("only possible error is resource path serialization"),
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L47-57)
```rust
pub fn group_tagged_resource_size<T: Serialize + Clone + Debug>(
    tag: &T,
    value_byte_len: usize,
) -> PartialVMResult<u64> {
    Ok((bcs::serialized_size(&tag).map_err(|e| {
        PartialVMError::new(StatusCode::VALUE_SERIALIZATION_ERROR).with_message(format!(
            "Tag serialization error for tag {:?}: {:?}",
            tag, e
        ))
    })? + bcs_size_of_byte_array(value_byte_len)) as u64)
}
```
