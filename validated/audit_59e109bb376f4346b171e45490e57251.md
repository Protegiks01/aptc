# Audit Report

## Title
State Sync Deadlock: Unbounded Blocking on Mempool Notification Causes Consensus Liveness Failure

## Summary
The state sync driver blocks indefinitely when sending commit notifications to mempool if the bounded channel (capacity: 100) is full. This occurs within a single-threaded event loop, preventing state sync from processing any other notifications including critical consensus sync requests. When consensus needs to catch up via `sync_to_target`, state sync cannot respond, causing consensus participation failure for the affected validator.

## Finding Description

The vulnerability exists in the mempool commit notification flow within the state sync component, combined with state sync's single-threaded event loop architecture.

**The Critical Architecture:**

State sync operates on a single-threaded event loop that processes notifications sequentially using `::futures::select!` to multiplex between different notification sources. [1](#0-0) 

**The Vulnerable Notification Chain:**

1. Consensus notifies state sync of committed transactions with a timeout configured via `commit_timeout_ms` (default: 5000ms). [2](#0-1) [3](#0-2) 

2. State sync handles the commit notification by calling `utils::handle_committed_transactions`. [4](#0-3) 

3. This calls `handle_transaction_notification` which notifies mempool. [5](#0-4) [6](#0-5) 

4. Mempool notification uses a bounded channel created with default capacity 100. [7](#0-6) [8](#0-7) 

5. The `send()` call blocks indefinitely when the bounded channel is full. [9](#0-8) 

6. A test explicitly confirms indefinite blocking behavior when the channel is full. [10](#0-9) 

**The Deadlock Scenario:**

When mempool stops consuming notifications:
- The bounded channel fills to capacity (100 notifications)
- State sync blocks in `handle_consensus_commit_notification` trying to send to mempool
- State sync's event loop cannot process ANY other notifications due to single-threaded sequential processing
- Consensus needs to call `sync_to_target` to catch up when processing proposals via `ensure_round_and_sync_up`. [11](#0-10) 
- State sync cannot respond to `sync_to_target` because it's blocked on the mempool send
- Critically, `sync_to_target` has NO timeout mechanism and waits indefinitely on the callback receiver. [12](#0-11) 
- Consensus `ensure_round_and_sync_up` never completes, proposal processing fails
- Validator cannot participate in consensus for that round
- This repeats for all subsequent rounds, causing complete validator liveness failure

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program's category "Total Loss of Liveness/Network Availability."

**Single Validator Impact:**
- Complete loss of consensus participation due to inability to sync up and process proposals
- Validator becomes non-functional until restart and resolution of underlying mempool issue
- Breaks the fundamental liveness invariant that validators must make forward progress

**Network Impact:**
If mempool issues affect multiple validators simultaneously (e.g., common bug, resource constraints, or correlated operational issues):
- Multiple validators lose consensus participation
- Network could lose liveness if >1/3 validators are affected
- Requires coordinated restarts and fixes across multiple validators

Unlike commit notifications which use timeouts and only log errors on failure, `sync_to_target` operations are on the critical path for consensus participation and have no timeout protection, making this deadlock scenario unrecoverable without manual intervention.

## Likelihood Explanation

**Likelihood: High**

Triggering conditions include:
1. **Mempool Processing Bugs**: Any bug causing mempool to stop consuming notifications from the bounded channel
2. **Resource Exhaustion**: Memory/CPU exhaustion making the mempool notification handler unresponsive
3. **Sustained High Load**: At 5,000+ TPS, 100 notifications can accumulate in milliseconds during brief mempool processing pauses
4. **Event Subscription Errors**: Blocking in the event notification path (also called in the same transaction handler)

**Attack Complexity: Low** - No sophisticated attack is required; natural component failures or operational issues suffice.

**Attacker Requirements: None** - This vulnerability can be triggered through normal operational conditions without any attacker involvement.

The small channel size (100 notifications) combined with the lack of timeout on mempool sends creates a fragile system where brief mempool delays can cascade into complete validator failure. The architectural decision to use a single-threaded event loop without non-blocking sends or timeout protection exacerbates the issue.

## Recommendation

Implement one or more of the following fixes:

1. **Add timeout to mempool send operations**: Use `tokio::time::timeout()` around the mempool notification send, similar to how consensus commit notifications are handled. Log errors but do not block the event loop indefinitely.

2. **Use non-blocking sends**: Replace the blocking `send().await` with `try_send()` to avoid blocking when the channel is full. Drop notifications with error logging if the channel is full rather than blocking.

3. **Separate event loop for mempool notifications**: Process mempool notifications on a separate task/thread to prevent blocking the main state sync event loop.

4. **Add timeout to sync_to_target**: Implement a timeout mechanism for `sync_to_target` operations to prevent consensus from waiting indefinitely.

5. **Increase channel capacity**: While not a complete fix, increasing the channel capacity beyond 100 would provide more buffer for temporary mempool delays.

Example fix for non-blocking send:
```rust
// In mempool-notifications/src/lib.rs, replace blocking send with try_send:
match self.notification_sender.try_send(commit_notification) {
    Ok(_) => Ok(()),
    Err(error) => {
        warn!("Failed to notify mempool (channel full or closed): {:?}", error);
        Err(Error::CommitNotificationError(format!(
            "Mempool notification channel unavailable: {:?}",
            error
        )))
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a mempool notification channel with capacity 1
2. Sending a notification without consuming it (channel full)
3. Attempting to send a second notification
4. Observing that the send operation blocks indefinitely

The existing test already demonstrates this behavior: [10](#0-9) 

To demonstrate the full validator liveness impact, one would need to:
1. Simulate mempool becoming unresponsive (not consuming from channel)
2. Fill the channel with 100 commit notifications
3. Trigger a consensus proposal that requires `sync_to_target`
4. Observe that state sync cannot respond and consensus fails to process the proposal

This can be reproduced in an integration test environment by injecting delays or failures into the mempool notification handler while consensus attempts to process proposals requiring state synchronization.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L219-239)
```rust
        info!(LogSchema::new(LogEntry::Driver).message("Started the state sync v2 driver!"));
        self.start_time = Some(self.time_service.now());
        loop {
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L334-341)
```rust
        utils::handle_committed_transactions(
            committed_transactions,
            self.storage.clone(),
            self.mempool_notification_handler.clone(),
            self.event_subscription_service.clone(),
            self.storage_service_notification_handler.clone(),
        )
        .await;
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L122-137)
```rust
        if let Ok(response) = timeout(
            Duration::from_millis(self.commit_timeout_ms),
            callback_receiver,
        )
        .await
        {
            match response {
                Ok(consensus_notification_response) => consensus_notification_response.get_result(),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Consensus commit notification failure: {:?}",
                    error
                ))),
            }
        } else {
            Err(Error::TimeoutWaitingForStateSync)
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L200-200)
```rust
        match callback_receiver.await {
```

**File:** config/src/config/state_sync_config.rs (L138-138)
```rust
            commit_notification_timeout_ms: 5000,
```

**File:** config/src/config/state_sync_config.rs (L147-147)
```rust
            max_pending_mempool_notifications: 100,
```

**File:** state-sync/state-sync-driver/src/utils.rs (L356-365)
```rust
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L102-104)
```rust
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L52-53)
```rust
    let (notification_sender, notification_receiver) =
        mpsc::channel(max_pending_mempool_notifications as usize);
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L103-107)
```rust
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(commit_notification)
            .await
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L222-246)
```rust
    async fn test_mempool_channel_blocked() {
        // Create runtime and mempool notifier (with a max of 1 pending notifications)
        let (mempool_notifier, _mempool_listener) = crate::new_mempool_notifier_listener_pair(1);

        // Send a notification and expect no failures
        let notify_result = mempool_notifier
            .notify_new_commit(vec![create_user_transaction()], 0)
            .await;
        assert_ok!(notify_result);

        // Send another notification (which should block!)
        let result = timeout(
            Duration::from_secs(5),
            mempool_notifier.notify_new_commit(vec![create_user_transaction()], 0),
        )
        .await;

        // Verify the channel is blocked
        if let Ok(result) = result {
            panic!(
                "We expected the channel to be blocked, but it's not? Result: {:?}",
                result
            );
        }
    }
```

**File:** consensus/src/round_manager.rs (L743-750)
```rust
        let in_correct_round = self
            .ensure_round_and_sync_up(
                proposal_msg.proposal().round(),
                proposal_msg.sync_info(),
                proposal_msg.proposer(),
            )
            .await
            .context("[RoundManager] Process proposal")?;
```
