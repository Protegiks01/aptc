# Audit Report

## Title
Byzantine Validators Can Equivocate AugData Through Missing Cross-Validation Between Uncertified and Certified Data

## Summary
A Byzantine validator can send different uncertified `AugData` to different honest validators, collect signatures from each subset, then broadcast mismatched `CertifiedAugData`. The `add_certified_aug_data` function fails to cross-validate certified data against previously signed uncertified data, allowing different validators to compute different augmented public keys (APKs) and ultimately different randomness values, causing consensus safety violations with a single Byzantine validator.

## Finding Description

The Aptos randomness generation protocol uses a two-phase reliable broadcast:
- **Phase 1**: Validators broadcast uncertified `AugData` containing delta values and collect `AugDataSignature` responses
- **Phase 2**: Validators broadcast `CertifiedAugData` with aggregated signatures

**Equivocation Detection Exists for Uncertified Data:**
The `add_aug_data` function includes equivocation detection that verifies incoming uncertified data matches any previously received data from the same author. [1](#0-0) 

**Missing Cross-Validation for Certified Data:**
However, `add_certified_aug_data` only checks if certified data already exists from an authorâ€”it does NOT verify the certified data matches the uncertified data previously stored in `self.data`. [2](#0-1) 

**Attack Execution:**

1. Byzantine validator V_byz generates two different `AugData` with different delta values: `AugData_A` and `AugData_B`

2. V_byz bypasses the reliable broadcast mechanism (which is a helper library, not protocol-enforced) and directly sends via network layer:
   - `AugData_A` to validators {V1, V2, V3, ...} (subset 1)  
   - `AugData_B` to validators {V4, V5, V6, ...} (subset 2)

3. Each honest validator receives their respective `AugData`, validates it cryptographically (verifying delta derivation and signature), stores it in their local `self.data` HashMap, and returns an `AugDataSignature`. [3](#0-2) 

4. V_byz collects >2f+1 signatures from subset 1 on `AugData_A` and from subset 2 on `AugData_B`, creating two valid `CertifiedAugData` objects with proper quorum certificates.

5. V_byz sends mismatched certified data:
   - `CertifiedAugData_B` to validators in subset 1 (who originally signed `AugData_A`)
   - `CertifiedAugData_A` to validators in subset 2 (who originally signed `AugData_B`)

6. When validators receive `CertifiedAugData`, verification only validates the aggregated multi-signatures, not the data content. [4](#0-3) [5](#0-4) 

7. The `add_certified_aug_data` function accepts the certified data without cross-checking against `self.data`, then calls `augment()` to add the delta to the `rand_config`. [6](#0-5) 

8. The `augment()` method adds the certified delta (which differs from what the validator signed) to compute the augmented public key. [7](#0-6) 

9. The `add_certified_delta` function derives an APK from the delta and stores it in `certified_apks`. [8](#0-7) 

**Consensus Safety Violation:**

Different validators now have different APKs for V_byz. When aggregating VUF shares for randomness generation, the different APKs cause different randomness outputs. The WVUF aggregation directly depends on the APK values. [9](#0-8) 

Since randomness affects Move execution and state transitions, different randomness values lead to different state roots, causing a consensus split.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** per the Aptos bug bounty program (Category: Consensus/Safety Violations - up to $1,000,000) because:

1. **Consensus Safety Violation**: Different validators produce different randomness for the same round, leading to different state roots and potential chain splits with < 1/3 Byzantine validators, violating the fundamental BFT safety guarantee.

2. **Deterministic Execution Broken**: The core blockchain invariant that all honest validators produce identical state from identical inputs is violated.

3. **Non-recoverable**: Once different APKs are installed via `augment()`, validators permanently disagree on randomness for that epoch. The `OnceCell` structure prevents updates once set. [10](#0-9) 

4. **No Detection Mechanism**: APKs are local consensus state, not committed to the blockchain. No cross-validator comparison or block validation would detect this discrepancy.

## Likelihood Explanation

**Likelihood: HIGH**

- **Single Byzantine Validator**: Attack requires only 1 Byzantine validator, well below the 1/3 BFT threshold
- **No Special Access**: Byzantine validator only needs to modify their node code to bypass reliable broadcast (a helper library, not protocol-enforced) [11](#0-10) 
- **No Complex Timing**: Attacker controls when to send Phase 1 and Phase 2 messages
- **Deterministic Success**: If >2f+1 honest validators respond (guaranteed in normal operation), attack succeeds
- **Undetectable**: Honest validators have no mechanism to detect the equivocation between uncertified and certified data

## Recommendation

Add cross-validation in `add_certified_aug_data` to verify the certified data matches any previously stored uncertified data:

```rust
pub fn add_certified_aug_data(
    &mut self,
    certified_data: CertifiedAugData<D>,
) -> anyhow::Result<CertifiedAugDataAck> {
    if self.certified_data.contains_key(certified_data.author()) {
        return Ok(CertifiedAugDataAck::new(self.epoch));
    }
    
    // Add cross-validation check
    if let Some(existing_uncertified) = self.data.get(certified_data.author()) {
        ensure!(
            existing_uncertified.data() == certified_data.data(),
            "[AugDataStore] certified data does not match previously signed uncertified data from {}",
            certified_data.author()
        );
    }
    
    self.db.save_certified_aug_data(&certified_data)?;
    certified_data
        .data()
        .augment(&self.config, &self.fast_config, certified_data.author());
    self.certified_data
        .insert(*certified_data.author(), certified_data);
    Ok(CertifiedAugDataAck::new(self.epoch))
}
```

## Proof of Concept

The following scenario demonstrates the vulnerability:

1. **Setup**: Network with 4 validators (V1, V2, V3, V4), Byzantine threshold = 1, quorum = 3
2. **Byzantine V1 creates**: `AugData_A` (delta_A) and `AugData_B` (delta_B)
3. **Phase 1 Equivocation**: V1 sends `AugData_A` to {V2, V3} and `AugData_B` to {V4}
4. **Honest Validation**: V2, V3, V4 each validate their received data, store in `self.data`, return signatures
5. **Phase 2 Cross-Send**: V1 creates `CertifiedAugData_A` (signed by V2,V3,V4) and sends it to V4; creates `CertifiedAugData_B` (signed by V2,V3,V4) and sends to V2,V3
6. **Acceptance**: Each validator accepts certified data via `add_certified_aug_data` without cross-checking against their stored uncertified data
7. **APK Divergence**: V2,V3 compute APK from delta_B; V4 computes APK from delta_A
8. **Consensus Break**: When aggregating randomness shares, V2,V3 use different APKs than V4, producing different randomness values and different state roots

## Notes

The vulnerability exploits the semantic gap between Phase 1 (uncertified data + signature collection) and Phase 2 (certified data broadcast). While honest validators correctly implement equivocation detection for uncertified data, they fail to verify that certified data corresponds to what they actually signed. The reliable broadcast mechanism is a helper library without protocol-level enforcement, allowing Byzantine validators to bypass it entirely and send different messages via direct network calls.

### Citations

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L103-108)
```rust
        if let Some(existing_data) = self.data.get(data.author()) {
            ensure!(
                existing_data == &data,
                "[AugDataStore] equivocate data from {}",
                data.author()
            );
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L121-123)
```rust
        if self.certified_data.contains_key(certified_data.author()) {
            return Ok(CertifiedAugDataAck::new(self.epoch));
        }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L125-127)
```rust
        certified_data
            .data()
            .augment(&self.config, &self.fast_config, certified_data.author());
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L47-49)
```rust
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L50-52)
```rust
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
```

**File:** consensus/src/rand/rand_gen/types.rs (L119-130)
```rust
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
```

**File:** consensus/src/rand/rand_gen/types.rs (L184-187)
```rust
        let AugmentedData { delta, fast_delta } = self;
        rand_config
            .add_certified_delta(author, delta.clone())
            .expect("Add delta should succeed");
```

**File:** consensus/src/rand/rand_gen/types.rs (L555-558)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        verifier.verify_multi_signatures(&self.aug_data, &self.signatures)?;
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L661-665)
```rust
    pub fn add_certified_delta(&self, peer: &Author, delta: Delta) -> anyhow::Result<()> {
        let apk = self.derive_apk(peer, delta)?;
        self.add_certified_apk(peer, apk)?;
        Ok(())
    }
```

**File:** types/src/randomness.rs (L128-135)
```rust
    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
```

**File:** crates/reliable-broadcast/src/lib.rs (L92-102)
```rust
    pub fn broadcast<S: BroadcastStatus<Req, Res> + 'static>(
        &self,
        message: S::Message,
        aggregating: S,
    ) -> impl Future<Output = anyhow::Result<S::Aggregated>> + 'static + use<S, Req, TBackoff, Res>
    where
        <<S as BroadcastStatus<Req, Res>>::Response as TryFrom<Res>>::Error: Debug,
    {
        let receivers: Vec<_> = self.validators.clone();
        self.multicast(message, aggregating, receivers)
    }
```
