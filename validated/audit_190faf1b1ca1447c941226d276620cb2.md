# Audit Report

## Title
DKG Transcript Validation Order Vulnerability Causing Validator Node Crashes

## Summary
A validation ordering bug in DKG transcript aggregation allows any validator to crash other validators by sending a malformed transcript with an empty `V_hat` vector. The vulnerability occurs because `verify_transcript_extra()` accesses vector elements via `.unwrap()` before `verify_transcript()` validates the vector size, causing a deterministic panic.

## Finding Description

The DKG transcript validation logic contains a critical ordering vulnerability where cryptographic checks are performed before structural validation. During peer transcript aggregation, validators receive and process DKG transcripts through a specific validation sequence.

**Vulnerable Execution Path:**

When a DKG transcript arrives from a peer validator, the transcript is deserialized via BCS without semantic validation [1](#0-0) , then `verify_transcript_extra()` is called at line 96 before `verify_transcript()` at line 99 [2](#0-1) .

Inside `verify_transcript_extra()`, when a fast path transcript is present (enabled by default in V2 configuration), the code compares dealt public keys between main and fast transcripts [3](#0-2) .

The `get_dealt_public_key()` method unconditionally accesses the last element of `V_hat` without validation [4](#0-3) .

The proper size validation occurs in `check_sizes()` which is only called from `verify()` [5](#0-4) , which itself is invoked through `verify_transcript()` [6](#0-5) . The size check validates that `V_hat.len() == W + 1` [7](#0-6) , but this occurs after the panic.

**Attack Vector:**
1. Malicious validator constructs a `Transcripts` struct with either `main.V_hat = vec![]` or `fast.V_hat = vec![]`
2. Serializes using BCS (which permits empty vectors)
3. Wraps in `DKGTranscript` and broadcasts to peers
4. Victim validators deserialize successfully
5. Basic metadata checks pass (epoch, author, voting power)
6. `verify_transcript_extra()` called
7. Panic occurs on `V_hat.last().unwrap()` with empty vector
8. Validator process crashes before size validation

Fast path randomness is enabled by default in production configurations [8](#0-7) , which means the vulnerable code path comparing public keys is active by default [9](#0-8) .

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria.

This vulnerability enables validator node crashes during DKG sessions, which occur at every epoch transition. The impact aligns with category #8 "Validator Node Slowdowns (High)" and #9 "API Crashes (High)" from the bounty framework:

- **Validator crashes**: Any active validator can deterministically crash other validators by sending a single malformed transcript
- **Network liveness impact**: Repeated crashes during DKG phases disrupt epoch transitions and randomness generation
- **Low attack barrier**: Requires only validator status (Byzantine validators are part of threat model with <1/3 stake)
- **Deterministic exploitation**: The panic always occurs with empty vectors; no race conditions or timing requirements

This is HIGH (not CRITICAL) because:
- Requires validator access (not accessible to general users)
- Affects individual validators, not simultaneous network-wide halt
- Impacts liveness, not consensus safety or fund security
- Network can recover by restarting affected validators

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly exploitable:

1. **Access requirements**: Only requires validator status, which Byzantine validators (<1/3 stake) are assumed to have in the threat model
2. **Execution simplicity**: Trivial to craft - create Transcript with `V_hat: vec![]`, serialize, and broadcast
3. **Frequent attack windows**: DKG sessions occur at every epoch transition (regular intervals)
4. **Deterministic success**: `.unwrap()` on empty vector guarantees panic; no probabilistic elements
5. **No defense mechanisms**: Metadata checks (epoch, author, voting power) don't prevent malformed transcript content
6. **Default configuration vulnerable**: Fast path enabled by default increases attack surface

The only barrier is validator access, which is explicitly part of the Byzantine fault model.

## Recommendation

Fix the validation ordering by either:

**Option 1: Validate sizes before calling `verify_transcript_extra()`**
```rust
// In dkg/src/transcript_aggregation/mod.rs, around line 95
S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
    anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
})?;

S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
    .context("extra verification failed")?;
```

**Option 2: Add safe access in `get_dealt_public_key()`**
```rust
// In crates/aptos-dkg/src/pvss/das/weighted_protocol.rs
fn get_dealt_public_key(&self) -> Self::DealtPubKey {
    Self::DealtPubKey::new(*self.V_hat.last()
        .ok_or_else(|| anyhow!("V_hat is empty"))?)
}
```

**Option 3: Add early size check in `verify_transcript_extra()`**
```rust
// In types/src/dkg/real_dkg/mod.rs, at start of verify_transcript_extra
fn verify_transcript_extra(...) -> anyhow::Result<()> {
    // Early size validation
    ensure!(!trx.main.V_hat.is_empty(), "main transcript V_hat is empty");
    if let Some(fast_trx) = &trx.fast {
        ensure!(!fast_trx.V_hat.is_empty(), "fast transcript V_hat is empty");
    }
    // ... rest of function
}
```

## Proof of Concept

```rust
#[test]
fn test_empty_v_hat_crash() {
    use aptos_types::dkg::real_dkg::Transcripts;
    use crates::aptos_dkg::pvss::das::weighted_protocol::Transcript as WTrx;
    
    // Create a transcript with empty V_hat
    let malicious_transcript = Transcripts {
        main: WTrx {
            soks: vec![],
            R: vec![],
            R_hat: vec![],
            V: vec![],
            V_hat: vec![], // Empty - will cause panic
            C: vec![],
        },
        fast: None,
    };
    
    // Serialize it
    let transcript_bytes = bcs::to_bytes(&malicious_transcript).unwrap();
    
    // When a validator tries to process this transcript,
    // get_dealt_public_key() will be called during verify_transcript_extra()
    // This will panic: V_hat.last().unwrap() on empty vector
    
    // This would normally crash the validator process
    let result = std::panic::catch_unwind(|| {
        malicious_transcript.main.get_dealt_public_key()
    });
    
    assert!(result.is_err(), "Should panic on empty V_hat");
}
```

## Notes

This vulnerability represents a genuine security flaw in the DKG implementation where validation ordering allows a Byzantine validator to crash honest validators during epoch transitions. The fix should prioritize structural validation before any field access that assumes vector contents.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-327)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L288-288)
```rust
        self.check_sizes(sc)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L426-432)
```rust
        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }
```

**File:** types/src/on_chain_config/randomness_config.rs (L189-191)
```rust
    pub fn default_enabled() -> Self {
        OnChainRandomnessConfig::V2(ConfigV2::default())
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L213-219)
```rust
    pub fn fast_randomness_enabled(&self) -> bool {
        match self {
            OnChainRandomnessConfig::Off => false,
            OnChainRandomnessConfig::V1(_) => false,
            OnChainRandomnessConfig::V2(_) => true,
        }
    }
```
