# Audit Report

## Title
Byzantine Validators Can Evade OptQS Accountability Through Timeout Reason Masking During State Synchronization

## Summary
The consensus protocol loses timeout reason information when aggregating timeout certificates, causing validators that sync via `SyncInfo` to default to `RoundTimeoutReason::Unknown` instead of the actual reason. This allows Byzantine validators who intentionally cause `PayloadUnavailable` timeouts to evade OptQS exclusion on syncing validators, creating inconsistent reputation states and enabling sustained performance degradation attacks.

## Finding Description

When a validator receives a timeout certificate through state synchronization (`sync_info`) without having locally collected timeout votes, the system defaults the timeout reason to `Unknown`. This occurs in the `process_certificates()` function: [1](#0-0) 

The root cause is architectural: timeout certificates do not carry timeout reason information. The `TwoChainTimeoutCertificate` structure only contains the timeout object and aggregated signatures, with no field for the reason: [2](#0-1) 

Similarly, `SyncInfo` propagates these certificates without timeout reasons: [3](#0-2) 

The timeout reason is critical because the `ExponentialWindowFailureTracker` uses it to determine OptQS exclusions. Only `PayloadUnavailable` triggers exclusion: [4](#0-3) 

All other reasons including `Unknown` are treated as successes. The test suite explicitly validates this behavior: [5](#0-4) 

**Attack Flow:**

1. Byzantine validator withholds transaction payload batches
2. Online validators detect `PayloadUnavailable`, form timeout certificate, exclude Byzantine validator via failure tracker
3. Validator that was offline/lagging syncs via `SyncInfo`, receives timeout certificate but no individual votes
4. Syncing validator's `pending_votes` is empty, so `drain_votes()` returns `None` for timeout votes
5. Defaults to `Unknown` reason, treats as success, doesn't exclude Byzantine validator
6. When syncing validator proposes, includes Byzantine validator's batches via OptQS
7. Byzantine validator repeats payload withholding attack
8. Network has inconsistent validator reputation states

The timeout reason aggregation logic in individual votes is Byzantine-resistant: [6](#0-5) 

However, this aggregation is bypassed entirely when validators sync from certificates rather than collecting votes directly.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty "Limited Protocol Violations" category:

1. **State Inconsistencies Requiring Intervention**: Different validators maintain divergent OptQS exclusion lists, violating the assumption of consistent Byzantine detection
2. **Sustained Performance Degradation**: Byzantine validators can repeatedly cause timeouts on proposals from validators that haven't excluded them
3. **Liveness Reduction**: Increased timeouts extend block production times
4. **Accountability Evasion**: OptQS exclusion mechanism fails network-wide

This does not break consensus safety, cause fund loss, or enable double-spending. However, it creates exploitable performance degradation requiring manual investigation to identify malicious validators. The impact is concrete and measurable through increased timeout rates and reduced throughput.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high likelihood because:

1. **Normal Operations Trigger It**: Validators routinely sync after brief disconnections, network partitions, or epoch transitions. Any validator that wasn't online during a timeout round will rely on `SyncInfo` without local votes.

2. **No Preconditions Required**: Byzantine validators need only withhold payloads (< 1/3 stake sufficient). No cryptographic breaks, specific network state, or precise timing required.

3. **Persistent Impact**: Once a validator has the wrong timeout reason in its failure tracker, it persists until sufficient subsequent rounds update the window. Meanwhile, Byzantine validators can continue attacks when that validator proposes.

4. **Observable and Exploitable**: Byzantine validators can monitor network participation and time attacks when they identify validators catching up through sync.

The vulnerability is inherent to the protocol design where timeout certificates lack reason metadata.

## Recommendation

**Option 1: Include Timeout Reason in Certificate (Preferred)**

Modify `TwoChainTimeoutCertificate` to include the aggregated timeout reason:

```rust
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
    aggregated_reason: RoundTimeoutReason, // Add this field
}
```

Update certificate formation to compute and include the aggregated reason, and modify `process_certificates()` to use this reason when available.

**Option 2: Conservative Default**

When timeout votes are unavailable, default to `PayloadUnavailable` with empty `missing_authors` rather than `Unknown`. This ensures syncing validators maintain conservative OptQS behavior until they have sufficient data.

**Option 3: Retroactive Sync**

Implement a mechanism for validators to request and verify historical timeout votes when syncing, allowing them to reconstruct accurate timeout reasons.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with 4 validators
2. Having one Byzantine validator withhold payloads in round N
3. Three honest online validators form timeout certificate with `PayloadUnavailable` reason
4. Taking one validator offline then bringing it back
5. Offline validator syncs via `SyncInfo`, receives timeout certificate
6. Verifying offline validator's failure tracker treats round N as success (Unknown) while online validators treat it as failure (PayloadUnavailable)
7. Observing inconsistent OptQS exclusion lists when querying each validator's `OptQSPullParamsProvider`

The existing test at lines 172-231 in `proposal_status_tracker.rs` confirms the tracker behavior, but lacks integration testing of the sync scenario.

## Notes

This vulnerability demonstrates a gap between local vote aggregation (which correctly computes timeout reasons) and state synchronization (which loses this information). The issue affects protocol-level accountability mechanisms rather than consensus safety, making it a Medium rather than Critical severity issue. However, it enables sustained Byzantine attacks on network performance that would otherwise be mitigated by OptQS exclusion.

### Citations

**File:** consensus/src/liveness/round_state.rs (L264-274)
```rust
            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();

            // The new round reason is QCReady in case both QC.round + 1 == new_round, otherwise
            // it's Timeout and TC.round + 1 == new_round.
            let new_round_reason = if sync_info.highest_certified_round() + 1 == new_round {
                NewRoundReason::QCReady
            } else {
                let prev_round_timeout_reason =
                    prev_round_timeout_reason.unwrap_or(RoundTimeoutReason::Unknown);
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L109-112)
```rust
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L14-25)
```rust
#[derive(Deserialize, Serialize, Clone, Eq, PartialEq)]
/// This struct describes basic synchronization metadata.
pub struct SyncInfo {
    /// Highest quorum certificate known to the peer.
    highest_quorum_cert: QuorumCert,
    /// Highest ordered cert known to the peer.
    highest_ordered_cert: Option<WrappedLedgerInfo>,
    /// Highest commit cert (ordered cert with execution result) known to the peer.
    highest_commit_cert: WrappedLedgerInfo,
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L200-202)
```rust
        tracker.push(NewRoundReason::Timeout(RoundTimeoutReason::Unknown));
        assert_eq!(tracker.window, 2);
        assert_eq!(tracker.last_consecutive_success_count, 6);
```

**File:** consensus/src/pending_votes.rs (L119-152)
```rust
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
```
