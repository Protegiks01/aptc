# Audit Report

## Title
State Snapshot Backup Validation Bypass Allows Empty Chunks with Arbitrary Root Hash

## Summary
A state snapshot backup with an empty chunks array can pass validation and be restored, creating database corruption where the actual state tree root hash (SPARSE_MERKLE_PLACEHOLDER_HASH) doesn't match the declared root hash in the manifest. This occurs because StateSnapshotBackup lacks chunk validation present in other backup types, and JellyfishMerkleRestore unconditionally writes Node::Null when no chunks are added without verifying the expected root hash.

## Finding Description

The StateSnapshotBackup struct lacks a verify() method that checks for empty chunks, unlike TransactionBackup and EpochEndingBackup which both enforce this validation: [1](#0-0) 

In contrast, TransactionBackup includes explicit validation: [2](#0-1) 

And EpochEndingBackup also enforces it: [3](#0-2) 

During state snapshot restoration, the manifest is loaded and cryptographic proofs are verified, but no chunk validation occurs: [4](#0-3) 

When chunks is empty, the processing loop doesn't execute, and finish() is eventually called: [5](#0-4) 

The StateSnapshotRestore.finish() delegates to JellyfishMerkleRestore.finish_impl(): [6](#0-5) 

In finish_impl(), when num_children == 0 (no chunks were added), it unconditionally writes Node::Null to storage without validating that expected_root_hash equals SPARSE_MERKLE_PLACEHOLDER_HASH: [7](#0-6) 

Since Node::Null.hash() returns SPARSE_MERKLE_PLACEHOLDER_HASH: [8](#0-7) 

The database now contains a state tree with root hash SPARSE_MERKLE_PLACEHOLDER_HASH, even though the manifest (validated via cryptographic proof) claimed a different root_hash. This violates the State Consistency invariant.

**Attack Path:**
1. Attacker obtains valid TransactionInfoWithProof and LedgerInfoWithSignatures claiming state_root_hash = X (non-empty tree)
2. Creates StateSnapshotBackup JSON with root_hash = X, chunks = [], and the valid proof
3. Distributes malicious backup via backup service or compromised storage
4. Victim node operator restores, passing all cryptographic validation
5. Database is written with root hash = SPARSE_MERKLE_PLACEHOLDER_HASH â‰  X
6. State corruption occurs, requiring manual intervention

## Impact Explanation

This is **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention."

Concrete impacts:
- **Database Corruption**: Node operators restoring from malicious backups will have incorrect state trees with mismatched root hashes
- **Consensus Risk**: If multiple validators restore from the same malformed backup, they'd all have incorrect state, though execution attempts would detect the mismatch
- **Recovery Required**: Manual intervention needed to detect and repair corrupted state
- **Trust Compromise**: Attackers can distribute cryptographically "valid" backups that pass automated checks but contain corrupted state

The vulnerability doesn't directly cause fund loss or network partition, but enables state manipulation requiring intervention to resolve.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites:
1. Attacker provides malicious state snapshot backup (via hosting backup service or compromising storage)
2. Valid TransactionInfoWithProof and LedgerInfoWithSignatures with arbitrary non-empty root hash
3. Empty chunks array in manifest
4. Victim node operator restores from this backup

The attack is straightforward - no complex cryptographic operations or race conditions required. The main barrier is distribution of malicious backups to victims. However:
- Node operators commonly use public backup services for rapid node bootstrapping
- Cryptographic validation provides false sense of security despite incomplete validation
- Once distributed, any operator restoring from the backup is affected
- Attack scales to multiple victims with single malicious backup

## Recommendation

Add a verify() method to StateSnapshotBackup that checks for empty chunks, similar to TransactionBackup and EpochEndingBackup:

```rust
impl StateSnapshotBackup {
    pub fn verify(&self) -> Result<()> {
        ensure!(!self.chunks.is_empty(), "State snapshot chunks cannot be empty.");
        Ok(())
    }
}
```

Call this verification method during restore before initializing the receiver:

```rust
// In StateSnapshotRestoreController::run_impl()
let manifest: StateSnapshotBackup = self.storage.load_json_file(&self.manifest_handle).await?;
manifest.verify()?; // Add validation
```

Additionally, add a safety check in JellyfishMerkleRestore::finish_impl() to validate that when writing Node::Null, the expected_root_hash must equal SPARSE_MERKLE_PLACEHOLDER_HASH:

```rust
0 => {
    ensure!(
        self.expected_root_hash == *SPARSE_MERKLE_PLACEHOLDER_HASH,
        "Cannot write Node::Null when expected root hash is non-empty"
    );
    let node_key = NodeKey::new_empty_path(self.version);
    assert!(self.frozen_nodes.is_empty());
    self.frozen_nodes.insert(node_key, Node::Null);
    self.store.write_node_batch(&self.frozen_nodes)?;
    return Ok(());
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Creates a valid StateSnapshotBackup with legitimate proof
2. Sets chunks to empty array
3. Attempts restoration
4. Verifies that Node::Null is written despite non-empty expected_root_hash

The code inspection above confirms this path executes without validation, resulting in state corruption.

---

## Notes

This vulnerability exploits an asymmetry in validation: TransactionBackup and EpochEndingBackup both validate non-empty chunks, but StateSnapshotBackup does not. The cryptographic verification (LedgerInfoWithSignatures) provides authenticity but not completeness - an attacker can use valid proofs with omitted data. The backup system was designed to accept backups from potentially untrusted sources (hence cryptographic validation), but the validation is incomplete for state snapshots specifically.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L29-51)
```rust
/// State snapshot backup manifest, representing a complete state view at specified version.
#[derive(Deserialize, Serialize)]
pub struct StateSnapshotBackup {
    /// Version at which this state snapshot is taken.
    pub version: Version,
    /// Epoch in which this state snapshot is taken.
    pub epoch: u64,
    /// Hash of the state tree root.
    pub root_hash: HashValue,
    /// All account blobs in chunks.
    pub chunks: Vec<StateSnapshotChunk>,
    /// BCS serialized
    /// `Tuple(TransactionInfoWithProof, LedgerInfoWithSignatures)`.
    ///   - The `TransactionInfoWithProof` is at `Version` above, and carries the same `root_hash`
    /// above; It proves that at specified version the root hash is as specified in a chain
    /// represented by the LedgerInfo below.
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L49-88)
```rust
impl TransactionBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L28-68)
```rust
impl EpochEndingBackup {
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");
        let mut next_epoch = self.first_epoch;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_epoch == next_epoch,
                "Chunk ranges not continuous. Expected first epoch: {}, actual: {}.",
                next_epoch,
                chunk.first_epoch,
            );
            ensure!(
                chunk.last_epoch >= chunk.first_epoch,
                "Chunk range invalid. [{}, {}]",
                chunk.first_epoch,
                chunk.last_epoch,
            );
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );

        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-145)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }

        let receiver = Arc::new(Mutex::new(Some(self.run_mode.get_state_restore_receiver(
            self.version,
            manifest.root_hash,
            self.restore_mode,
        )?)));
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L187-228)
```rust
        let futs_iter = chunks.into_iter().enumerate().map(|(chunk_idx, chunk)| {
            let storage = storage.clone();
            async move {
                tokio::spawn(async move {
                    let blobs = Self::read_state_value(&storage, chunk.blobs.clone()).await?;
                    let proof = storage.load_bcs_file(&chunk.proof).await?;
                    Result::<_>::Ok((chunk_idx, chunk, blobs, proof))
                })
                .await?
            }
        });
        let con = self.concurrent_downloads;
        let mut futs_stream = stream::iter(futs_iter).buffered_x(con * 2, con);
        let mut start = None;
        while let Some((chunk_idx, chunk, mut blobs, proof)) = futs_stream.try_next().await? {
            start = start.or_else(|| Some(Instant::now()));
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["add_state_chunk"]);
            let receiver = receiver.clone();
            if self.validate_modules {
                blobs = tokio::task::spawn_blocking(move || {
                    Self::validate_modules(&blobs);
                    blobs
                })
                .await?;
            }
            tokio::task::spawn_blocking(move || {
                receiver.lock().as_mut().unwrap().add_chunk(blobs, proof)
            })
            .await??;
            leaf_idx.set(chunk.last_idx as i64);
            info!(
                chunk = chunk_idx,
                chunks_to_add = chunks_to_add,
                last_idx = chunk.last_idx,
                values_per_second = ((chunk.last_idx + 1 - start_idx) as f64
                    / start.as_ref().unwrap().elapsed().as_secs_f64())
                    as u64,
                "State chunk added.",
            );
        }

        tokio::task::spawn_blocking(move || receiver.lock().take().unwrap().finish()).await??;
```

**File:** storage/aptosdb/src/state_restore/mod.rs (L260-273)
```rust
    fn finish(self) -> Result<()> {
        match self.restore_mode {
            StateSnapshotRestoreMode::KvOnly => self.kv_restore.lock().take().unwrap().finish()?,
            StateSnapshotRestoreMode::TreeOnly => {
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
            StateSnapshotRestoreMode::Default => {
                // for tree only mode, we also need to write the usage to DB
                self.kv_restore.lock().take().unwrap().finish()?;
                self.tree_restore.lock().take().unwrap().finish_impl()?
            },
        }
        Ok(())
    }
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L765-772)
```rust
            match num_children {
                0 => {
                    let node_key = NodeKey::new_empty_path(self.version);
                    assert!(self.frozen_nodes.is_empty());
                    self.frozen_nodes.insert(node_key, Node::Null);
                    self.store.write_node_batch(&self.frozen_nodes)?;
                    return Ok(());
                },
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L850-856)
```rust
    pub fn hash(&self) -> HashValue {
        match self {
            Node::Internal(internal_node) => internal_node.hash(),
            Node::Leaf(leaf_node) => leaf_node.hash(),
            Node::Null => *SPARSE_MERKLE_PLACEHOLDER_HASH,
        }
    }
```
