# Audit Report

## Title
Block Timestamp Manipulation Allows Inclusion of Expired Transactions via Quorum Store Filtering Bypass

## Summary
A malicious validator selected as block proposer can manipulate their local system clock to create blocks with timestamps in the past (while still satisfying parent timestamp constraints), causing the quorum store to include transactions that have expired in real time. This breaks transaction expiration guarantees and enables time-sensitive transactions to execute outside their intended validity windows.

## Finding Description

The vulnerability exists in the interaction between block timestamp generation, quorum store transaction filtering, and block validation logic.

**Verified Attack Flow:**

1. **Timestamp Source**: When a proposer creates a block, the timestamp is obtained from their local system clock via `time_service.get_current_timestamp()`. [1](#0-0) 

2. **Quorum Store Filtering**: This timestamp is passed as `block_timestamp` to the quorum store's `pull_internal` function, which filters transactions based on expiration by checking `block_timestamp.as_secs() < txn_summary.expiration_timestamp_secs`. [2](#0-1) [3](#0-2) 

3. **Insufficient Validation**: Block validation only enforces two constraints:
   - Timestamp must be strictly greater than parent timestamp [4](#0-3) 
   - Timestamp must not be more than 5 minutes in the future [5](#0-4) 
   
   **There is no lower bound check** preventing timestamps from being arbitrarily far in the past relative to real wall clock time.

4. **Execution Validation**: During execution, `update_global_time` only checks that the new timestamp is greater than the current on-chain timestamp for normal blocks, not that it's close to real time. [6](#0-5) 

5. **Transaction Expiration Check**: During transaction execution, the prologue validates expiration by checking `timestamp::now_seconds() < txn_expiration_time` using the on-chain timestamp (which has been updated to the block's timestamp). [7](#0-6) 

6. **No BlockStore Protection**: The BlockStore insertion logic only waits if the block timestamp is in the FUTURE relative to local time, but does not prevent blocks with timestamps in the PAST from being inserted. [8](#0-7) 

**Attack Scenario:**
- Parent block timestamp: 1000 seconds
- Real current time: 2000 seconds
- User submitted transaction with expiration: 1500 seconds (expired in real time)
- Malicious proposer manipulates system clock to 1100 seconds
- Proposer creates block with timestamp 1100 seconds
- Quorum store includes the transaction (1100 < 1500 ✓)
- Validators accept block (1100 > 1000 ✓, 1100 ≤ 2000 + 300 ✓)
- On-chain timestamp updates to 1100 seconds (1000 < 1100 ✓)
- Transaction executes with prologue check (1100 < 1500 ✓)
- **Expired transaction executes successfully**

## Impact Explanation

This vulnerability qualifies as **Medium to High Severity** under the Aptos bug bounty program:

1. **Significant Protocol Violation**: Breaks the fundamental transaction expiration guarantee that users rely on for time-sensitive operations (DEX trades, auctions, time-locked agreements).

2. **Temporal Manipulation**: Allows malicious validators to manipulate on-chain time progression, causing it to drift behind real time and enabling stale state transitions.

3. **Financial Impact**: Users who submit time-critical transactions (e.g., DEX trades with slippage protection, auction bids with deadlines) could suffer indirect losses when these transactions execute outside their intended validity windows.

4. **Deterministic Execution Preserved**: All validators deterministically execute the same transactions using the block's timestamp, maintaining consensus safety. This is not a consensus safety violation but a protocol guarantee violation.

## Likelihood Explanation

**Likelihood: Medium**

- **Requirements**: Attacker must be a validator selected as proposer and willing to manipulate their system clock
- **Detection**: Subtle - timestamps appear valid (> parent, < validator_time + 5min) but systematically lag behind real time
- **Constraints**: Limited by parent timestamp requirement and 5-minute future bound; effect compounds over multiple malicious proposals
- **Frequency**: Can occur each time a malicious validator is selected as proposer
- **Coordination**: No coordination with other validators needed; single malicious proposer sufficient

## Recommendation

Implement a lower bound check on block timestamps to prevent them from being too far in the past relative to validators' real-world clocks. For example, in `Block::verify_well_formed()`:

```rust
// Add after line 539 in consensus/consensus-types/src/block.rs
const MAX_TIMESTAMP_LAG: u64 = 60_000_000; // 60 seconds in microseconds
ensure!(
    self.timestamp_usecs() >= current_ts.as_micros().as_u64().saturating_sub(MAX_TIMESTAMP_LAG),
    "Block timestamp must not be too far in the past"
);
```

This would prevent proposers from creating blocks with timestamps significantly behind real time while still allowing some tolerance for clock skew.

## Proof of Concept

A PoC would require:
1. Running a modified validator node with manipulated system time
2. Submitting transactions with specific expiration timestamps
3. Observing these transactions execute after their expiration in real time

The vulnerability can be verified by code inspection as demonstrated above, showing the absence of lower bound timestamp validation in the consensus layer.

## Notes

- This vulnerability affects the consensus and execution layers of Aptos Core
- The attack is limited by the requirement that timestamps must still exceed the parent block's timestamp
- For maximum impact, an attacker would need to compound the effect over multiple proposals or wait for network conditions where on-chain time has already fallen behind
- This does not cause consensus divergence (all validators execute deterministically), but does violate transaction expiration protocol guarantees

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L601-601)
```rust
        let timestamp = self.time_service.get_current_timestamp();
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L644-645)
```rust
                                            && block_timestamp.as_secs()
                                                < txn_summary.expiration_timestamp_secs
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L669-670)
```rust
                                                && block_timestamp.as_secs()
                                                    < summary.expiration_timestamp_secs
```

**File:** consensus/consensus-types/src/block.rs (L527-529)
```rust
            ensure!(
                self.timestamp_usecs() > parent.timestamp_usecs(),
                "Blocks must have strictly increasing timestamps"
```

**File:** consensus/consensus-types/src/block.rs (L532-539)
```rust
            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L46-48)
```text
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L139-142)
```text
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
```

**File:** consensus/src/block_storage/block_store.rs (L499-511)
```rust
        // ensure local time past the block time
        let block_time = Duration::from_micros(pipelined_block.timestamp_usecs());
        let current_timestamp = self.time_service.get_current_timestamp();
        if let Some(t) = block_time.checked_sub(current_timestamp) {
            if t > Duration::from_secs(1) {
                warn!(
                    "Long wait time {}ms for block {}",
                    t.as_millis(),
                    pipelined_block
                );
            }
            self.time_service.wait_until(block_time).await;
        }
```
