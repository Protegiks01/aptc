# Audit Report

## Title
ECDSA Signature Malleability in Move Native ecdsa_recover() Enables Transaction Malleability for Ethereum Derivable Accounts

## Summary
The Move native function `ecdsa_recover_internal` does not enforce canonical ECDSA signature encoding (low-s requirement), allowing high-s signatures to pass authentication. This enables transaction malleability for Ethereum-compatible account abstraction, where an attacker can create multiple valid signatures for the same transaction, bypassing deduplication and consuming network resources.

## Finding Description
The Aptos codebase implements two separate ECDSA signature verification paths for secp256k1:

1. **Standard Transaction Authentication Path** (PROTECTED): The Rust implementation in `aptos-crypto` correctly enforces canonical encoding by rejecting high-s signatures through an explicit `is_high()` check. [1](#0-0) 

2. **Move Native ecdsa_recover Path** (VULNERABLE): The native function `native_ecdsa_recover` used by Ethereum derivable accounts parses the signature and directly calls `libsecp256k1::recover()` without checking for canonical encoding. [2](#0-1) 

The vulnerable path is used by Ethereum-compatible account abstraction for authentication. [3](#0-2) 

**Attack Scenario:**

For any ECDSA signature (r, s), a mathematically equivalent signature (r, n-s) exists where n is the curve order. The `libsecp256k1::recover()` function accepts both signatures and recovers them to the same public key, but the Move native implementation lacks the canonical encoding check present in the standard path.

**Exploitation Steps:**
1. User creates an Ethereum derivable account transaction with signature (r, s_low) where s is canonical (s < n/2)
2. Attacker observes the transaction and creates a malleable signature (r, s_high) where s_high = n - s_low
3. Attacker submits the malleable transaction to the network
4. Both signatures successfully pass `ecdsa_recover()` authentication, recovering to the same public key
5. Transaction deduplication uses the pair `(committed_hash, authenticator)` [4](#0-3) , but since the signature bytes in the `abstract_signature` field differ [5](#0-4) , this changes both the authenticator and the committed_hash (which BCS-serializes the entire SignedTransaction including the authenticator [6](#0-5) [7](#0-6) ), causing them NOT to be deduplicated
6. Both transactions enter mempool and may be included in separate blocks, though only the first succeeds (sequence number protection prevents double execution)

## Impact Explanation
This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

**Validator Node Slowdowns (High)**: The vulnerability enables significant performance degradation affecting consensus through DoS via resource exhaustion. By exploiting the missing canonical encoding check, attackers can:

1. **Network Resource Exhaustion**: Pollute the mempool and waste block space by submitting malleable versions of legitimate transactions. Each malleable signature is treated as a distinct transaction by the deduplication system.

2. **Validator Performance Impact**: Force validators to process and validate duplicate transactions that should have been deduplicated, causing slowdowns classified as HIGH severity per bug bounty rules.

3. **Protocol Invariant Violation**: Creates an inconsistency between the standard transaction authentication path (which enforces canonical encoding) and the Move native path (which does not), violating cryptographic correctness invariants.

This is NOT a network-level DoS attack (which would be out of scope), but rather a protocol-level resource exhaustion attack exploiting a cryptographic vulnerability in signature validation.

## Likelihood Explanation
**Likelihood: HIGH**

- **Trivial to Exploit**: Any attacker can observe Ethereum derivable account transactions and compute malleable signatures using basic ECDSA mathematics (s' = n - s)
- **No Special Permissions Required**: Works for any unprivileged transaction sender observing network traffic
- **Affects Active Feature**: Ethereum derivable accounts are a production feature used for cross-chain compatibility
- **Easy to Automate**: Attack can be automated to continuously monitor and create malleable versions of all Ethereum abstraction transactions
- **No Preconditions**: Does not require specific blockchain state, epoch, or governance conditions

## Recommendation
Add canonical signature encoding validation to the `native_ecdsa_recover` function before calling `libsecp256k1::recover()`:

```rust
// After parsing the signature (line 65-71)
let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
    Ok(sig) => sig,
    Err(_) => {
        return Err(SafeNativeError::Abort {
            abort_code: abort_codes::NFE_DESERIALIZE,
        });
    },
};

// ADD THIS CHECK:
// Prevent malleability attacks - only accept low-s signatures
if sig.s.is_high() {
    return Err(SafeNativeError::Abort {
        abort_code: abort_codes::NFE_DESERIALIZE, // or a new error code
    });
}
```

This brings the Move native path in line with the standard signature verification path and prevents signature malleability attacks.

## Proof of Concept
The vulnerability can be demonstrated by:

1. Creating an Ethereum derivable account transaction with a low-s signature
2. Computing the malleable high-s signature (r, n-s) 
3. Submitting both transactions to the network
4. Observing that both pass authentication and enter mempool as distinct transactions
5. Verifying that deduplication does not identify them as duplicates

The core issue is evident from code inspection: the native function lacks the `is_high()` check present in the standard path, allowing both canonical and non-canonical signatures to authenticate successfully.

## Notes
- The standard secp256k1 ECDSA signature verification path correctly implements malleability protection, as verified by the test suite. [8](#0-7) 
- This vulnerability only affects Ethereum derivable accounts and other account abstraction mechanisms using the `ecdsa_recover` native function, not standard Ed25519 transactions
- The sequence number mechanism prevents actual double-spending, but the vulnerability still enables resource exhaustion attacks

### Citations

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L209-223)
```rust
    fn verify(
        &self,
        message: &libsecp256k1::Message,
        public_key: &libsecp256k1::PublicKey,
    ) -> Result<()> {
        // Prevent malleability attacks, low order only. The library only signs in low
        // order, so this was done intentionally.
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
        } else if libsecp256k1::verify(message, &self.0, public_key) {
            Ok(())
        } else {
            Err(anyhow!("Unable to verify signature."))
        }
    }
```

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L65-77)
```rust
    let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
        Ok(sig) => sig,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        },
    };

    context.charge(SECP256K1_ECDSA_RECOVER * NumArgs::one())?;

    // NOTE(Gas): O(1) cost: a size-2 multi-scalar multiplication
    match libsecp256k1::recover(&msg, &sig, &rid) {
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L152-176)
```text
    fun recover_public_key(signature_bytes: &vector<u8>, message: &vector<u8>): vector<u8> {
        let rs = signature_bytes.slice(0, 64);
        let v = signature_bytes[64];
        assert!(v == 27 || v == 28, EUNEXPECTED_V);
        let signature = secp256k1::ecdsa_signature_from_bytes(rs);

        let maybe_recovered = secp256k1::ecdsa_recover(*message, v - 27, &signature);

        assert!(
            maybe_recovered.is_some(),
            EINVALID_SIGNATURE
        );

        let pubkey = maybe_recovered.borrow();

        let pubkey_bytes = secp256k1::ecdsa_raw_public_key_to_bytes(pubkey);

        // Add 0x04 prefix to the public key, to match the
        // full uncompressed format from ethers.js
        let full_pubkey = &mut vector[];
        full_pubkey.push_back(4u8);
        full_pubkey.append(pubkey_bytes);

        *full_pubkey
    }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-82)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

        // TODO: Possibly parallelize. See struct comment.
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
```

**File:** types/src/transaction/authenticator.rs (L603-610)
```rust
    DerivableV1 {
        #[serde(with = "serde_bytes")]
        signing_message_digest: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_signature: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_public_key: Vec<u8>,
    },
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** types/src/transaction/mod.rs (L2945-2951)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),
```

**File:** crates/aptos-crypto/src/unit_tests/secp256k1_ecdsa_test.rs (L95-112)
```rust
        secp256k1_ecdsa::Signature::try_from(&signature_bytes[..]).unwrap();
    assert_eq!(signature, signature_deserialized);

    let mut high_signature = signature.clone();
    high_signature.0.s = -high_signature.0.s;
    let high_signature_bytes = high_signature.to_bytes();

    // We can load
    secp256k1_ecdsa::Signature::try_from(&high_signature_bytes[..]).unwrap();

    // Ensure this is now high.
    assert!(!signature.0.s.is_high());
    assert!(high_signature.0.s.is_high());
    assert!(high_signature.0.s != signature.0.s);
    high_signature
        .verify_arbitrary_msg(message, &key_pair.public_key)
        .unwrap_err();
}
```
