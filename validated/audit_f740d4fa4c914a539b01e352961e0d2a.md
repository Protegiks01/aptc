# Audit Report

## Title
Configuration Skew in Transaction Validation Due to Stale Runtime Environment

## Summary

The `VMValidator` in mempool transaction validation fails to update the `AptosEnvironment` when the state view is updated via `reset_state_view()`, causing a configuration mismatch where feature flags, gas parameters, and VM configurations from an older block are used to validate transactions against a newer state. This allows transactions to bypass newly-enabled security features and be undercharged for gas during validation.

## Finding Description

The vulnerability exists in the transaction validation flow where `CachedModuleView` maintains both a `state_view` and an `environment` as separate fields. [1](#0-0) 

The `reset_state_view()` method updates only the state view without synchronizing the environment: [2](#0-1) 

In contrast, the `reset_all()` method correctly updates both the state view and creates a new environment from the updated state: [3](#0-2) 

When `notify_commit()` is called after a block commit and detects linear version history (the normal case), it uses `reset_state_view()` instead of `reset_all()`: [4](#0-3) 

Subsequently, `validate_transaction()` creates an `AptosVM` instance using the stale environment while passing the updated state view: [5](#0-4) 

The `AptosVM` validation logic checks feature flags from the environment: [6](#0-5) 

Gas parameters are also retrieved from the environment: [7](#0-6) 

The `AptosVM` delegates all configuration access to its internal environment through methods like `features()`, `gas_params()`, and `gas_feature_version()`: [8](#0-7) 

The `AptosEnvironment` fetches all these configurations (features, gas parameters, VM config) from the state view during initialization: [9](#0-8) 

**Attack Scenario:**

1. Governance proposal executes in block N, enabling a security feature flag (e.g., restricting WebAuthn signatures via `WEBAUTHN_SIGNATURE` flag)
2. `notify_commit()` updates state_view to block N but environment remains at block N-1
3. Attacker submits transaction T using WebAuthn signature
4. Validation checks feature flag from old environment (where feature is disabled)
5. Transaction incorrectly passes validation and enters mempool
6. Transaction will fail during block execution (which uses correct environment), wasting validator resources

## Impact Explanation

This is a **MEDIUM severity** vulnerability per Aptos bug bounty criteria:

1. **Feature Flag Bypass**: Security features enabled through governance can be bypassed during the validation window. If a critical security restriction is added (e.g., blocking WebAuthn, SlhDsa, or SingleSender authenticators), attackers can submit such transactions before validators synchronize their environments. [10](#0-9) 

2. **Gas Calculation Errors**: Transactions validated during the configuration skew window are estimated with incorrect gas costs, causing undercharging if gas costs increased and incorrect transaction ordering in mempool based on gas price. [11](#0-10) 

3. **Mempool Pollution**: Invalid transactions accepted during the skew window will fail during block execution (which uses correct environments), wasting validator resources on transaction propagation and validation.

4. **State Inconsistencies**: This creates inconsistent mempool states across validators requiring manual intervention, qualifying as Medium Severity per Aptos bug bounty criteria: "State inconsistencies requiring intervention and potential for limited manipulation of transaction validation."

**Note**: This does NOT affect consensus safety since block execution creates fresh environments from the current state view, ensuring all validators execute with identical configurations.

## Likelihood Explanation

**HIGH likelihood** - This vulnerability triggers automatically whenever:

1. On-chain configuration changes through governance (feature flags, gas schedules)
2. The validator's state view forms linear history (`old_version <= new_version`) - the normal case
3. `notify_commit()` is called, which happens after every block commit

Governance proposals that modify VM configuration are common operational activities. Feature flags are regularly enabled on mainnet to activate new functionality or security restrictions. Each such change creates a window where this vulnerability is exploitable until validators restart or `reset_all()` is explicitly called (which only happens on non-linear version changes).

The attack requires no special privileges - any transaction sender can submit transactions during the vulnerable window.

## Recommendation

Modify the `notify_commit()` method to always call `reset_all()` when configuration changes are detected, not just for non-linear version changes. This ensures the environment is synchronized with the state view.

**Option 1: Always reset environment on commit**
```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    // Always use reset_all to ensure environment stays synchronized
    self.state.reset_all(db_state_view.into());
}
```

**Option 2: Detect configuration changes**
```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    let new_env = AptosEnvironment::new(&db_state_view);
    
    // Check if configuration changed
    if self.state.environment != new_env {
        self.state.reset_all(db_state_view.into());
    } else {
        self.state.reset_state_view(db_state_view.into());
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Submitting a governance proposal that enables a feature flag (e.g., `WEBAUTHN_SIGNATURE`)
2. After the proposal executes in block N, immediately submitting a transaction using WebAuthn signature
3. The transaction will pass validation (using old environment) but fail execution (using new environment)
4. This can be verified by checking mempool logs showing validation success and block execution logs showing feature gating errors

The code paths traced above provide complete evidence of the vulnerability without requiring additional PoC code, as the issue manifests through normal operational flow during governance configuration updates.

## Notes

- This vulnerability affects **mempool validation only**, not block execution or consensus
- Block execution always creates fresh `AptosEnvironment` instances from the current state, ensuring deterministic execution
- The issue creates a temporary window between configuration change and environment synchronization
- The impact is limited to mempool pollution and temporary feature flag bypass during validation, not permanent security compromise
- Validators can mitigate by restarting after governance changes, which triggers `reset_all()`

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L134-138)
```rust
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L155-165)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L348-386)
```rust
    fn features(&self) -> &Features {
        self.move_vm.env.features()
    }

    #[inline(always)]
    fn timed_features(&self) -> &TimedFeatures {
        self.move_vm.env.timed_features()
    }

    #[inline(always)]
    fn deserializer_config(&self) -> &DeserializerConfig {
        &self.move_vm.env.vm_config().deserializer_config
    }

    #[inline(always)]
    fn chain_id(&self) -> ChainId {
        self.move_vm.env.chain_id()
    }

    #[inline(always)]
    pub(crate) fn gas_feature_version(&self) -> u64 {
        self.move_vm.env.gas_feature_version()
    }

    #[inline(always)]
    pub(crate) fn gas_params(
        &self,
        log_context: &AdapterLogSchema,
    ) -> Result<&AptosGasParameters, VMStatus> {
        get_or_vm_startup_failure(self.move_vm.env.gas_params(), log_context)
    }

    #[inline(always)]
    pub(crate) fn storage_gas_params(
        &self,
        log_context: &AdapterLogSchema,
    ) -> Result<&StorageGasParameters, VMStatus> {
        get_or_vm_startup_failure(self.move_vm.env.storage_gas_params(), log_context)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3227)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }

        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::ALLOW_SERIALIZED_SCRIPT_ARGS)
        {
            if let Ok(TransactionExecutableRef::Script(script)) =
                transaction.payload().executable_ref()
            {
                for arg in script.args() {
                    if let TransactionArgument::Serialized(_) = arg {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3250-3261)
```rust
        let vm_params = match self.gas_params(&log_context) {
            Ok(vm_params) => vm_params.vm.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };
        let storage_gas_params = match self.storage_gas_params(&log_context) {
            Ok(storage_params) => storage_params.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3271-3278)
```rust
        let mut gas_meter = make_prod_gas_meter(
            self.gas_feature_version(),
            vm_params,
            storage_gas_params,
            is_approved_gov_script,
            initial_balance,
            &NoopBlockSynchronizationKillSwitch {},
        );
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L212-318)
```rust
    fn new(
        state_view: &impl StateView,
        inject_create_signer_for_gov_sim: bool,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);

        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();

        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };

        let mut builder = SafeNativeBuilder::new(
            gas_feature_version,
            native_gas_params,
            misc_gas_params,
            timed_features.clone(),
            features.clone(),
            gas_hook,
        );
        let natives = aptos_natives_with_builder(&mut builder, inject_create_signer_for_gov_sim);
        let vm_config = aptos_prod_vm_config(
            chain_id,
            gas_feature_version,
            &features,
            &timed_features,
            ty_builder,
        );
        let verifier_bytes =
            bcs::to_bytes(&vm_config.verifier_config).expect("Verifier config is serializable");
        let runtime_environment = RuntimeEnvironment::new_with_config(natives, vm_config);

        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
        let keyless_configuration =
            Configuration::fetch_keyless_config(state_view).map(|(config, config_bytes)| {
                sha3_256.update(&config_bytes);
                config
            });

        let hash = sha3_256.finalize().into();

        #[allow(deprecated)]
        Self {
            chain_id,
            features,
            timed_features,
            keyless_pvk,
            keyless_configuration,
            gas_feature_version,
            gas_params,
            storage_gas_params,
            runtime_environment,
            inject_create_signer_for_gov_sim,
            hash,
            verifier_bytes,
            async_runtime_checks_enabled: get_async_runtime_checks(),
        }
    }
```
