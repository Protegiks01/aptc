# Audit Report

## Title
JWK Version Rollback Attack via Issuer Removal and Replay

## Summary
A critical vulnerability exists in the JWK (JSON Web Key) consensus mechanism that allows an attacker to roll back JWK versions to previous states containing potentially revoked or outdated keys. When an issuer is removed from `ObservedJWKs` via governance and subsequently re-added through validator consensus, the version counter resets to 0, allowing old `QuorumCertifiedUpdate` transactions with version 1 to be replayed, reintroducing previously superseded or revoked cryptographic keys.

## Finding Description

The vulnerability exists in the interaction between three components that create a replay attack vector:

**1. Version Reset on Issuer Removal**

When governance removes an issuer from `ObservedJWKs`, the version history is lost. The `remove_issuer_from_observed_jwks()` function removes the issuer entirely from on-chain state [1](#0-0) , and the JWK consensus manager subsequently removes it from local state [2](#0-1) . When queried for a removed issuer, `on_chain_version()` returns 0 [3](#0-2) .

**2. Rust VM Accepts Version 1 for Non-Existent Issuers**

When processing a `QuorumCertifiedUpdate`, the Rust VM creates a new `ProviderJWKs` with version 0 if the issuer doesn't exist on-chain [4](#0-3) . The version validation check `on_chain.version + 1 != observed.version` then evaluates to `0 + 1 != 1`, which passes [5](#0-4) .

**3. No Epoch-Based Replay Protection**

The `QuorumCertifiedUpdate` structure contains only the update and multi-signature, with no epoch number or nonce [6](#0-5) . The `ValidatorTransaction::ObservedJWKUpdate` variant similarly lacks epoch binding [7](#0-6) , unlike `DKGResult` which includes epoch metadata.

**4. Insufficient Move-Level Validation**

In per-issuer mode, the Move contract performs no additional version validation beyond the Rust VM checks, directly upserting the provided JWKs [8](#0-7) . In per-key mode, while version validation exists, it creates a new `ProviderJWKs` with version 0 for removed issuers and accepts version 1 updates [9](#0-8) .

**Attack Scenario:**

1. Issuer "alice" progresses from version 1 to version 5, with key rotations due to compromises
2. Governance legitimately removes "alice" via `remove_issuer_from_observed_jwks()`
3. Attacker obtains the historical `QuorumCertifiedUpdate` for version 1 from blockchain data
4. Attacker submits this transaction to the network
5. Rust validation creates version 0 state, accepts version 1 update, and verifies the multi-sig against current validator set (passes if sufficient overlap exists) [10](#0-9) 
6. Move contract applies the update without additional checks
7. Previously revoked cryptographic keys are reintroduced

**Broken Invariants:**
- **Cryptographic Correctness**: Revoked cryptographic keys can be re-enabled
- **State Monotonicity**: Version progression can be violated through issuer removal
- **Authentication Security**: Keyless account users are vulnerable to compromised keys

## Impact Explanation

**Critical Severity (up to $1,000,000)**

This vulnerability enables:

1. **Authentication Bypass**: Revoked JWKs that were rotated due to compromise can be reintroduced, allowing attackers possessing the compromised private keys to forge valid JWT signatures and access keyless accounts.

2. **Cryptographic Vulnerabilities**: This meets the Critical severity criterion of enabling signature forgery capabilities through the reintroduction of compromised cryptographic material.

3. **Potential Loss of Funds**: Through unauthorized access to keyless authentication accounts, attackers could steal funds.

4. **Consensus Safety Risk**: Different validators could have inconsistent views of valid JWKs if the replay occurs during epoch transitions, potentially causing state divergence.

This aligns with the Aptos bug bounty Critical severity categories for "Cryptographic Vulnerabilities" and "Consensus/Safety Violations."

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Required conditions:
1. **Governance Removal**: An issuer must be legitimately removed (MEDIUM likelihood - happens during provider rotations, security incidents, or policy changes)
2. **Validator Set Overlap**: Sufficient validators from the original signing set must remain in the current validator set with adequate voting power (HIGH likelihood - validator sets maintain significant stability over time)
3. **Historical Data Access**: Attacker needs old `QuorumCertifiedUpdate` transactions (HIGH likelihood - all blockchain data is publicly accessible)
4. **No Epoch Binding**: Confirmed through code analysis - no replay protection exists beyond version numbers

The attack requires no validator collusion or privileged access. Any network participant can submit validator transactions. The validators who signed the original update did so legitimately; the attack exploits a protocol-level design flaw rather than Byzantine behavior.

## Recommendation

Implement epoch-based replay protection by:

1. **Add Epoch to QuorumCertifiedUpdate**: Include an epoch number in the `QuorumCertifiedUpdate` structure to bind updates to specific epochs.

2. **Epoch Validation**: In `process_jwk_update_inner()`, verify that the update's epoch matches or is appropriately related to the current epoch before processing.

3. **Track Update History**: Maintain a persistent record of processed `QuorumCertifiedUpdate` hashes across epochs to prevent replay.

4. **Alternative**: Do not reset version to 0 on issuer removal. Instead, maintain version history even for removed issuers, or implement a monotonically increasing global version counter.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Deploy a test network with JWK consensus enabled
2. Add issuer "test-issuer" with version 1 containing key K1
3. Progress to version 5 through normal consensus
4. Use governance to call `remove_issuer_from_observed_jwks()` for "test-issuer"
5. Capture the historical `QuorumCertifiedUpdate` for version 1 from blockchain data
6. Resubmit this transaction as a `ValidatorTransaction::ObservedJWKUpdate`
7. Observe that the version 1 keys are reintroduced despite being previously superseded

The vulnerability is evident from code analysis showing version reset to 0 upon issuer removal and acceptance of version 1 updates for non-existent issuers, combined with the lack of epoch binding in the transaction structure.

## Notes

This vulnerability affects both per-issuer and per-key consensus modes. While the report focuses on per-issuer mode, the per-key mode is equally vulnerable due to the same version reset mechanism when issuers don't exist on-chain. The attack relies on natural validator set stability rather than active collusion, making it within the valid threat model for the Aptos bug bounty program.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L468-478)
```text
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L496-500)
```text
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L507-520)
```text
    /// Only used by governance to delete an issuer from `ObservedJWKs`, if it exists.
    ///
    /// Return the potentially existing `ProviderJWKs` of the given issuer.
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L252-253)
```rust
        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L117-119)
```rust
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L132-142)
```rust
        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** types/src/jwks/mod.rs (L303-307)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct QuorumCertifiedUpdate {
    pub update: ProviderJWKs,
    pub multi_sig: AggregateSignature,
}
```

**File:** types/src/validator_txn.rs (L17-17)
```rust
    ObservedJWKUpdate(jwks::QuorumCertifiedUpdate),
```
