# Audit Report

## Title
BlockInfo Equality Check Causes Valid Order Votes to Be Rejected Due to Execution Result Differences

## Summary
The `verify_order_vote_proposal()` function in safety rules incorrectly uses full equality comparison instead of `match_ordered_only()` to validate BlockInfo instances. In decoupled execution mode, this causes all order votes to be rejected because the QC's certified block contains ordered-only BlockInfo (with placeholder execution values) while the OrderVoteProposal's block_info contains executed BlockInfo (with real execution results), making them unequal despite representing the same logical block.

## Finding Description
The vulnerability exists in the order vote validation logic within the consensus safety rules. The issue manifests in how BlockInfo instances are compared during order vote proposal verification.

The `BlockInfo` struct contains both immutable block identifiers and execution-dependent fields: [1](#0-0) 

In decoupled execution mode, when validators create regular votes, they generate VoteData with ordered-only BlockInfo that contains placeholder execution values: [2](#0-1) [3](#0-2) 

These votes aggregate into a QuorumCert containing the ordered-only BlockInfo. Later, when creating an OrderVoteProposal, a fresh BlockInfo is generated from the block's current execution state: [4](#0-3) [5](#0-4) 

The critical flaw is in the verification logic, which uses full equality comparison: [6](#0-5) 

Since `BlockInfo` derives `PartialEq`, this comparison checks ALL fields including execution-dependent ones (`executed_state_id`, `version`, `next_epoch_state`). The QC's certified_block has placeholder values while the proposal's block_info has real execution results, causing them to never match even though they represent the same logical block.

**The codebase correctly handles this scenario elsewhere** using `match_ordered_only()`, which only compares immutable fields: [7](#0-6) 

This method is used in similar scenarios throughout the codebase:

1. In `guarded_sign_commit_vote()` when comparing ordered and executed BlockInfo: [8](#0-7) 

2. In `create_merged_with_executed_state()` when merging QC with executed state: [9](#0-8) 

3. In buffer item validation for ordered blocks: [10](#0-9) [11](#0-10) 

The codebase also acknowledges that re-execution can occur: [12](#0-11) 

## Impact Explanation
**Severity: Medium** (per Aptos bug bounty criteria: "State inconsistencies requiring intervention")

When this bug triggers:
- Validators incorrectly reject valid order votes with `InvalidOneChainQuorumCertificate` error
- Order vote aggregation fails for legitimately certified blocks in decoupled execution mode
- The ordering phase of the consensus pipeline cannot progress properly
- Validators may need to disable `order_vote_enabled` to recover
- Network experiences liveness degradation in the ordering phase

This qualifies as Medium severity because:
- It causes state inconsistencies requiring manual intervention (disabling the feature)
- No funds are lost and consensus safety (fork prevention) is not violated
- Not Critical: doesn't cause permanent liveness failure or safety violations
- Not High: validators can recover by configuration change

## Likelihood Explanation
**Likelihood: High** (when the feature is enabled)

This bug triggers whenever:
1. The `order_vote_enabled` configuration flag is true
2. Decoupled execution is enabled (standard for the feature)
3. Order votes are attempted after QC aggregation

In decoupled execution mode, the mismatch is **deterministic and consistent**:
- Regular votes always use ordered-only BlockInfo (placeholder execution values)
- QCs formed from these votes contain ordered-only BlockInfo
- OrderVoteProposal always uses current execution results from `block.block_info()`
- The execution fields (`executed_state_id`, `version`) will always differ between placeholder and real values
- Full equality comparison will always fail

The bug should trigger on **every** order vote attempt when the feature is enabled. The fact that it hasn't been widely reported suggests the `order_vote_enabled` feature may not be extensively deployed, or there are workarounds in place.

Evidence from test code shows the tests don't exercise the real code path: [13](#0-12) 

The tests artificially use `quorum_cert().certified_block().clone()` as the block_info, making them match by construction. This doesn't reflect how production code creates OrderVoteProposals via `block.order_vote_proposal(qc)`.

## Recommendation
Replace the full equality check with `match_ordered_only()` in `verify_order_vote_proposal()`:

```rust
// In consensus/safety-rules/src/safety_rules.rs, replace lines 97-102 with:
if !qc.certified_block().match_ordered_only(order_vote_proposal.block_info()) {
    return Err(Error::InvalidOneChainQuorumCertificate(
        qc.certified_block().id(),
        order_vote_proposal.block_info().id(),
    ));
}
```

This change aligns with the pattern used throughout the codebase for comparing ordered and executed BlockInfo instances, allowing execution-dependent fields to differ while ensuring the logical block identity (epoch, round, id, timestamp) matches.

## Proof of Concept
The vulnerability can be demonstrated by examining the execution flow when `order_vote_enabled` is true:

1. A block is proposed and execution begins
2. Validators vote using `VoteProposal::gen_vote_data()` which returns ordered-only BlockInfo
3. Votes aggregate into a QC with ordered-only certified_block
4. `broadcast_order_vote()` is called: [14](#0-13) 

5. This creates OrderVoteProposal with `block.block_info()` (executed BlockInfo) and the QC (ordered-only certified_block)
6. `verify_order_vote_proposal()` compares them with full equality
7. Comparison fails because `executed_state_id` differs (placeholder vs real value)
8. Order vote is rejected with `Error::InvalidOneChainQuorumCertificate`

The test suite doesn't catch this because tests artificially create OrderVoteProposals with matching BlockInfo rather than using the production code path that generates fresh BlockInfo from execution results.

## Notes
This is a logic vulnerability in the consensus ordering phase. While the feature may not be widely deployed (explaining why it hasn't been caught), the bug is real and would prevent order votes from functioning correctly when enabled. The fix is straightforward: use the same `match_ordered_only()` pattern that the rest of the codebase already uses for comparing ordered and executed BlockInfo instances.

### Citations

**File:** types/src/block_info.rs (L27-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L87-101)
```rust
    /// Generate vote data depends on the config.
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
        } else {
            let proposed_block = self.block();
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
            Ok(self.vote_data_with_extension_proof(&new_tree))
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L309-324)
```rust
        // We might be retrying execution, so it might have already been set.
        // Because we use this for statistics, it's ok that we drop the newer value.
        if let Some(previous) = self.execution_summary.get() {
            if previous.root_hash == execution_summary.root_hash
                || previous.root_hash == *ACCUMULATOR_PLACEHOLDER_HASH
            {
                warn!(
                    "Skipping re-inserting execution result, from {:?} to {:?}",
                    previous, execution_summary
                );
            } else {
                error!(
                    "Re-inserting execution result with different root hash: from {:?} to {:?}",
                    previous, execution_summary
                );
            }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L97-102)
```rust
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L156-161)
```rust
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
```

**File:** consensus/src/pipeline/buffer_item.rs (L274-277)
```rust
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
```

**File:** consensus/src/pipeline/buffer_item.rs (L380-384)
```rust
                if ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(target_commit_info)
                {
```

**File:** consensus/safety-rules/src/tests/suite.rs (L124-138)
```rust
    let ov1 = OrderVoteProposal::new(
        p0.block().clone(),
        p1.block().quorum_cert().certified_block().clone(),
        Arc::new(p1.block().quorum_cert().clone()),
    );
    let ov2 = OrderVoteProposal::new(
        p1.block().clone(),
        p2.block().quorum_cert().certified_block().clone(),
        Arc::new(p2.block().quorum_cert().clone()),
    );
    let ov3 = OrderVoteProposal::new(
        p2.block().clone(),
        p3.block().quorum_cert().certified_block().clone(),
        Arc::new(p3.block().quorum_cert().clone()),
    );
```

**File:** consensus/src/round_manager.rs (L1626-1639)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;
```
