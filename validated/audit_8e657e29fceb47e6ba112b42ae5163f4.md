# Audit Report

## Title
Governance Vote Direction Manipulation via Partial Voting - Stake Pools Can Vote Both YES and NO on Same Proposal

## Summary
The `partial_vote()` function in Aptos Governance allows a stake pool to vote multiple times on the same proposal in different directions (both YES and NO), violating the fundamental governance invariant that each stake pool should commit to a single voting position. This enables manipulation of proposal outcomes by simultaneously boosting both yes and no vote counts.

## Finding Description

The vulnerability exists in how `VotingRecordsV2` tracks voting power usage. The system only records the total amount of voting power used by each stake pool per proposal, without tracking the direction (yes/no) of those votes. [1](#0-0) 

The `RecordKey` structure used to index voting records contains only the stake pool address and proposal ID, with no direction field: [2](#0-1) 

The `vote_internal` function calculates remaining voting power and updates used voting power without any direction tracking: [3](#0-2) 

Specifically, line 574 simply adds to the total used voting power regardless of direction. The `get_remaining_voting_power` function returns total remaining power without considering previous vote directions: [4](#0-3) 

The underlying `voting::vote` function adds votes to either `yes_votes` or `no_votes` based solely on the `should_pass` parameter: [5](#0-4) 

**Attack Path:**
1. Attacker controls a stake pool with 100 voting power
2. Calls `partial_vote(stake_pool, proposal_id, 50, true)` → adds 50 to yes_votes, records 50 power as used
3. `get_remaining_voting_power` returns 50 (100 - 50)
4. Calls `partial_vote(stake_pool, proposal_id, 50, false)` → adds 50 to no_votes, records 100 total power as used
5. Both votes are counted: proposal has +50 YES and +50 NO from the same stake pool

The existing test suite only verifies voting multiple times in the same direction: [6](#0-5) 

No test exists that validates prevention of voting in opposite directions.

## Impact Explanation

**Severity: MEDIUM** - This constitutes a governance protocol violation that undermines governance integrity.

**Attack Scenarios:**
1. **Early Resolution Manipulation**: Attacker votes both YES and NO to artificially inflate total vote counts, potentially triggering early resolution thresholds prematurely
2. **Proposal Outcome Manipulation**: Near voting deadlines, attacker votes both ways to prevent clear majority formation or manipulate the yes/no ratio
3. **Governance Deadlock**: Multiple attackers voting both ways can create artificial contention on critical governance proposals
4. **Vote Count Inflation**: Absolute vote counts are manipulated, affecting governance metrics and participation tracking

This affects critical governance decisions including network parameter updates, framework upgrades, validator set changes, feature flag modifications, and staking configuration changes.

Per Aptos Bug Bounty categories, this falls under **MEDIUM severity** as a "Limited Protocol Violation" - it creates state inconsistencies and undermines governance integrity but does not directly cause fund loss, consensus failure, or network halt. While governance controls critical network operations, the direct impact is manipulation of the voting process rather than immediate critical system compromise.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is trivially exploitable:

**Attacker Requirements:**
- Control or be the delegated voter for any stake pool (common for validators and token holders)
- No special privileges beyond normal governance participation
- Attack executed via standard transaction submission

**Complexity: LOW**
- Two simple function calls to `partial_vote()` with opposite `should_pass` values
- No sophisticated timing or state manipulation required
- Works on any active proposal during voting period

The attack has no technical barriers and requires only basic governance participation rights that many network participants already possess.

## Recommendation

Modify `VotingRecordsV2` to track voting direction alongside voting power. The structure should record not just how much voting power was used, but also in which direction:

```move
struct VoteRecord has copy, drop, store {
    voting_power: u64,
    voted_yes: bool,
}

struct VotingRecordsV2 has key {
    votes: SmartTable<RecordKey, VoteRecord>
}
```

Update `vote_internal` to check if a stake pool has already voted in a different direction and prevent such votes, or alternatively, ensure that once a stake pool votes in one direction, all subsequent votes from that stake pool on the same proposal must be in the same direction.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter_1 = @0x234, voter_2 = @0x345)]
public entry fun test_stake_pool_can_vote_both_directions(
    aptos_framework: signer,
    proposer: signer,
    voter_1: signer,
    voter_2: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
    let voter_1_addr = signer::address_of(&voter_1);
    
    create_proposal_for_test(&proposer, true);
    
    // Vote YES with 10 voting power
    partial_vote(&voter_1, voter_1_addr, 0, 10, true);
    
    // Vote NO with 10 voting power from same stake pool - should fail but doesn't
    partial_vote(&voter_1, voter_1_addr, 0, 10, false);
    
    // Both votes are counted - governance invariant violated
    let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, 0);
    assert!(proposal_state == PROPOSAL_STATE_PENDING, 0); // Proposal is still pending with conflicting votes
}
```

This test demonstrates that a single stake pool can vote both YES and NO on the same proposal, with both votes being counted, violating the governance integrity invariant.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L93-96)
```text
    struct RecordKey has copy, drop, store {
        stake_pool: address,
        proposal_id: u64,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L104-106)
```text
    struct VotingRecordsV2 has key {
        votes: SmartTable<RecordKey, u64>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L318-348)
```text
    /// Return remaining voting power of a stake pool on a proposal.
    /// Note: a stake pool's voting power on a proposal could increase over time(e.g. rewards/new stake).
    public fun get_remaining_voting_power(
        stake_pool: address,
        proposal_id: u64
    ): u64 acquires VotingRecords, VotingRecordsV2 {
        assert_voting_initialization();

        let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(
            @aptos_framework,
            proposal_id
        );
        let lockup_until = stake::get_lockup_secs(stake_pool);
        // The voter's stake needs to be locked up at least as long as the proposal's expiration.
        // Also no one can vote on a expired proposal.
        if (proposal_expiration > lockup_until || timestamp::now_seconds() > proposal_expiration) {
            return 0
        };

        // If a stake pool has already voted on a proposal before partial governance voting is enabled, the stake pool
        // cannot vote on the proposal even after partial governance voting is enabled.
        if (has_entirely_voted(stake_pool, proposal_id)) {
            return 0
        };
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = *VotingRecordsV2[@aptos_framework].votes.borrow_with_default(record_key, &0);
        get_voting_power(stake_pool) - used_voting_power
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L539-604)
```text
    fun vote_internal(
        voter: &signer,
        stake_pool: address,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        permissioned_signer::assert_master_signer(voter);
        let voter_address = signer::address_of(voter);
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));

        assert_proposal_expiration(stake_pool, proposal_id);

        // If a stake pool has already voted on a proposal before partial governance voting is enabled,
        // `get_remaining_voting_power` returns 0.
        let staking_pool_voting_power = get_remaining_voting_power(stake_pool, proposal_id);
        voting_power = min(voting_power, staking_pool_voting_power);

        // Short-circuit if the voter has no voting power.
        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));

        voting::vote<GovernanceProposal>(
            &governance_proposal::create_empty_proposal(),
            @aptos_framework,
            proposal_id,
            voting_power,
            should_pass,
        );

        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                Vote {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        } else {
            let events = &mut GovernanceEvents[@aptos_framework];
            event::emit_event(
                &mut events.vote_events,
                VoteEvent {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        };

        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1074-1097)
```text
    public entry fun test_stake_pool_can_vote_on_partial_voting_proposal_many_times(
        aptos_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
        let execution_hash = vector[1];
        let proposer_addr = signer::address_of(&proposer);
        let voter_1_addr = signer::address_of(&voter_1);
        let voter_2_addr = signer::address_of(&voter_2);

        create_proposal_for_test(&proposer, true);

        partial_vote(&voter_1, voter_1_addr, 0, 5, true);
        partial_vote(&voter_1, voter_1_addr, 0, 3, true);
        partial_vote(&voter_1, voter_1_addr, 0, 2, true);

        assert!(get_remaining_voting_power(proposer_addr, 0) == 100, 0);
        assert!(get_remaining_voting_power(voter_1_addr, 0) == 10, 1);
        assert!(get_remaining_voting_power(voter_2_addr, 0) == 10, 2);

        test_resolving_proposal_generic(aptos_framework, true, execution_hash);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L405-409)
```text
        if (should_pass) {
            proposal.yes_votes = proposal.yes_votes + (num_votes as u128);
        } else {
            proposal.no_votes = proposal.no_votes + (num_votes as u128);
        };
```
