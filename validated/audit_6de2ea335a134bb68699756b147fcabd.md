# Audit Report

## Title
Resource Group Metadata Validation Bypass Allows Type Parameter Injection Leading to State Inconsistency

## Summary
The `validate_resource_groups` function fails to validate that resource group member attributes specify resource groups without type parameters. This allows attackers to publish modules referencing the same resource group with different type arguments, causing resources to be stored at different StateKeys and breaking state consistency invariants.

## Finding Description

The resource group validation system has a critical gap that allows type parameter injection through maliciously crafted module metadata.

The validation in `validate_resource_groups` only checks resource groups by name lookup, not by the full StructTag including type parameters. [1](#0-0) 

When a `resource_group_member` attribute is parsed, it successfully parses StructTags that include type parameters via the `FromStr` implementation. [2](#0-1) 

However, the validation at module publishing time only verifies that the parsed StructTag is `Some`, without checking if `type_args` is empty. [3](#0-2) 

Resource groups themselves are correctly enforced to have no type parameters. [4](#0-3) 

At runtime, when resources are stored, the StateKey is computed using the full StructTag including type parameters. [5](#0-4) 

**Attack Execution Path:**
1. Attacker observes legitimate Module A with resource group `Bar` (no type parameters)
2. Attacker publishes Module B with `#[resource_group_member(group = 0x1::A::Bar<u64>)]`
3. The string `"0x1::A::Bar<u64>"` parses successfully into a StructTag with `type_args=[TypeTag::U64]`
4. Validation looks up "Bar" by name only, finds it, and passes
5. At runtime, resources are stored at `StateKey::resource_group(address, StructTag("Bar", [u64]))`
6. This is a DIFFERENT StateKey than `StateKey::resource_group(address, StructTag("Bar", []))`
7. Resources that should be co-located are now fragmented across multiple storage locations

## Impact Explanation

**HIGH Severity** - This vulnerability causes multiple critical issues:

1. **State Consistency Violation**: Resources that must be stored together per the resource group invariant are fragmented across different StateKeys, breaking the fundamental guarantee that resource groups provide atomic access to co-located resources.

2. **Gas Calculation Errors**: The gas charging mechanism computes resource group size by serializing each tag including its type parameters. [6](#0-5)  Resources with injected type parameters will be charged based on incorrect tag sizes, leading to gas miscalculations.

3. **Protocol Invariant Violation**: The core assumption that all members of a resource group share a single StateKey is violated, which may cause unpredictable behavior in systems relying on this guarantee.

This qualifies as **"Significant protocol violations"** under HIGH Severity ($50,000) criteria, as it breaks fundamental Move VM resource group semantics and state management invariants.

## Likelihood Explanation

**HIGH Likelihood** - The attack is trivially executable:

1. **No Special Permissions**: Any user can publish modules to their own address via the `publish_package_txn` entry function. [7](#0-6) 

2. **Simple Attack Vector**: The attacker only needs to:
   - Identify an existing resource group's StructTag
   - Craft module bytecode with type parameters in the `resource_group_member` attribute
   - Submit a publish transaction

3. **Deterministic Bypass**: The validation gap exists consistently - the check only validates by name, making the bypass 100% reliable.

4. **No Economic Barriers**: Standard module publishing gas costs apply, with no additional requirements.

## Recommendation

Add explicit validation in `validate_resource_groups` to ensure that all StructTags in `resource_group_member` attributes have empty `type_args`:

```rust
// In validate_resource_groups, after line 58:
for group_tag in inner_members.values() {
    // Validate that the group tag has no type parameters
    if !group_tag.type_args.is_empty() {
        return Err(metadata_validation_error(
            "resource_group_member attribute cannot reference groups with type parameters"
        ));
    }
    
    let group_module_id = group_tag.module_id();
    // ... rest of validation
}
```

Additionally, add a check in `verify_module_metadata_for_module_publishing`:

```rust
// In module_metadata.rs, enhance the validation at line 500-504:
} else if attr.is_resource_group_member() {
    if let Some(group_tag) = attr.get_resource_group_member() {
        if !group_tag.type_args.is_empty() {
            return Err(AttributeValidationError {
                key: struct_.clone(),
                attribute: attr.kind,
            }.into());
        }
        is_valid_resource_group_member(&structs, struct_)?;
        continue;
    }
}
```

## Proof of Concept

```move
// Module A (legitimate resource group)
module 0x1::resource_group_container {
    #[resource_group(scope = global)]
    struct MyResourceGroup has key {}
}

// Module B (malicious - craft bytecode with metadata containing type parameters)
// In the compiled bytecode metadata, the attribute would be:
// #[resource_group_member(group = 0x1::resource_group_container::MyResourceGroup<u64>)]
module 0xBAD::attacker {
    use 0x1::resource_group_container;
    
    #[resource_group_member(group = 0x1::resource_group_container::MyResourceGroup<u64>)]
    struct MaliciousResource has key {
        value: u64
    }
}

// When MaliciousResource is stored:
// - StateKey will be: resource_group(address, MyResourceGroup<u64>)
// - Other members use: resource_group(address, MyResourceGroup)
// - These are DIFFERENT keys, breaking co-location!
```

**Notes:**
- The PoC requires manually crafting bytecode metadata since the Move compiler would prevent this during normal compilation (extended_checks.rs validates at compile time)
- However, attackers can publish pre-compiled bytecode with arbitrary metadata
- The runtime validation (`validate_resource_groups`) would accept this malformed module
- All validators would process this identically (deterministic), so no consensus split occurs, but state corruption is real and persists

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L89-95)
```rust
            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };
```

**File:** types/src/vm/module_metadata.rs (L138-144)
```rust
    pub fn get_resource_group_member(&self) -> Option<StructTag> {
        if self.kind == KnownAttributeKind::ResourceGroupMember as u8 {
            self.args.first()?.parse().ok()
        } else {
            None
        }
    }
```

**File:** types/src/vm/module_metadata.rs (L408-413)
```rust
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
```

**File:** types/src/vm/module_metadata.rs (L500-504)
```rust
                } else if attr.is_resource_group_member()
                    && attr.get_resource_group_member().is_some()
                {
                    is_valid_resource_group_member(&structs, struct_)?;
                    continue;
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L105-110)
```rust
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L47-57)
```rust
pub fn group_tagged_resource_size<T: Serialize + Clone + Debug>(
    tag: &T,
    value_byte_len: usize,
) -> PartialVMResult<u64> {
    Ok((bcs::serialized_size(&tag).map_err(|e| {
        PartialVMError::new(StatusCode::VALUE_SERIALIZATION_ERROR).with_message(format!(
            "Tag serialization error for tag {:?}: {:?}",
            tag, e
        ))
    })? + bcs_size_of_byte_array(value_byte_len)) as u64)
}
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```
