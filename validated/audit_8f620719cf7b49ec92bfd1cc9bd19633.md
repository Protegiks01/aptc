# Audit Report

## Title
Bytecode Verifier Gap: Unchecked LocalIndex in Access Specifier Parameters Causes Runtime Verifier Invariant Violation

## Summary
The Move bytecode verifier contains a gap in bounds checking that allows malicious bytecode with out-of-bounds parameter indices in access specifiers to pass verification and trigger `VERIFIER_INVARIANT_VIOLATION` errors at runtime, violating the Move VM's fundamental guarantee that verified bytecode should never fail with verifier errors during execution.

## Finding Description

This vulnerability exists due to incomplete bounds checking in the bytecode verifier, specifically affecting the validation of `LocalIndex` values within access specifier parameters.

**1. Missing Verification in Bounds Checker**

The `check_function_handle` method validates function handles but does not check the `access_specifiers` field: [1](#0-0) 

The method validates module handles, identifiers, parameter signatures, return signatures, and type parameters, but the `access_specifiers` field is never validated for parameter index bounds.

**2. Unchecked Loading in Access Specifier Loader**

The loader creates `AddressSpecifier::Eval` directly from the file format without validating that the parameter index is within bounds: [2](#0-1) 

At line 109, `AddressSpecifier::Eval(fun, *param)` is constructed with the raw parameter index from bytecode without any bounds validation against the function's parameter count.

**3. Runtime Failure Path**

When a function with an out-of-bounds access specifier parameter is called, the following execution path triggers the error:

a) Function entry triggers access specifier specialization: [3](#0-2) 

b) Specialization evaluates address specifiers: [4](#0-3) 

c) Frame's implementation attempts to copy the local at the invalid index: [5](#0-4) 

d) The `copy_loc` method returns an error for out-of-bounds access: [6](#0-5) 

e) The error is explicitly `VERIFIER_INVARIANT_VIOLATION`: [7](#0-6) 

**4. Verification Pipeline Confirmation**

The bytecode verifier is called during module publishing, but the bounds checker gap allows the invalid bytecode through: [8](#0-7) 

The `BoundsChecker::verify_module` is explicitly called first, but it does not validate access specifier parameter indices.

**5. Feature Enablement**

The resource access control feature is enabled by default on mainnet: [9](#0-8) [10](#0-9) 

**Attack Scenario:**
1. Attacker crafts bytecode (using tools like move-asm) with a function having N parameters
2. The function's access specifier contains `AddressSpecifier::Parameter(N, None)` where N is out of bounds (valid range: 0 to N-1)
3. The bytecode passes verification because the bounds checker has this gap
4. Module is successfully published on-chain
5. When any transaction calls this function, `enter_function` triggers specialization
6. Runtime error with `VERIFIER_INVARIANT_VIOLATION` occurs, making the function uncallable

Note: The standard Move compiler validates parameter indices during code generation: [11](#0-10) 

However, manual bytecode manipulation tools can bypass this compiler-level validation, exploiting the verifier gap.

## Impact Explanation

**Severity: MEDIUM**

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria for the following reasons:

1. **Protocol Violation**: The occurrence of `VERIFIER_INVARIANT_VIOLATION` at runtime violates the Move VM's fundamental guarantee that verified bytecode should never fail with verifier errors during execution. This represents a genuine gap in the bytecode verifier's completeness.

2. **Limited Denial of Service**: Functions containing malicious access specifiers become permanently uncallable, requiring manual intervention (republishing corrected modules). However, the impact is limited to those specific functions rather than affecting the entire network.

3. **No Consensus Impact**: All validators encounter the same error deterministically when executing transactions that call affected functions. There is no consensus divergence riskâ€”all nodes fail identically and produce the same state root, maintaining blockchain consistency.

4. **No Fund Loss**: This vulnerability does not enable theft of funds, unauthorized minting, bypass of transfer restrictions, or any financial exploitation.

This aligns with the Aptos bug bounty MEDIUM severity category of "Limited Protocol Violations" that require manual intervention but do not cause validator slowdowns, consensus failures, or fund loss.

## Likelihood Explanation

**Likelihood: MEDIUM**

1. **Moderate Barrier to Entry**: While any user can publish Move modules on Aptos, exploiting this vulnerability requires using bytecode manipulation tools (such as move-asm) rather than the standard Move compiler, which correctly validates parameter indices. This creates a moderate but not insurmountable barrier.

2. **Detection Difficulty**: Malicious modules pass all bytecode verification checks, making it difficult for defenders to prevent deployment through automated means. The vulnerability only manifests at runtime when the function is called.

3. **Limited Current Exposure**: The resource access control feature is relatively new and not yet widely adopted in production Move code. Most existing modules do not use access specifiers, limiting the immediate attack surface.

4. **Deterministic Behavior**: The bug triggers consistently and deterministically when affected functions are called, but all validators fail identically, preventing any consensus-level exploitation or validator-specific attacks.

## Recommendation

Add parameter index bounds validation to the bytecode verifier's bounds checker. Specifically, modify `check_function_handle` to validate all `LocalIndex` values in access specifiers:

```rust
fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
    check_bounds_impl(self.view.module_handles(), function_handle.module)?;
    check_bounds_impl(self.view.identifiers(), function_handle.name)?;
    check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
    check_bounds_impl(self.view.signatures(), function_handle.return_)?;
    
    // Existing type parameter validation
    let type_param_count = function_handle.type_parameters.len();
    self.check_type_parameters_in_signature(function_handle.parameters, type_param_count)?;
    self.check_type_parameters_in_signature(function_handle.return_, type_param_count)?;
    
    // NEW: Validate access specifier parameter indices
    if let Some(access_specifiers) = &function_handle.access_specifiers {
        let param_count = self.view.signatures()
            .get(function_handle.parameters.into_index())
            .map(|sig| sig.0.len())
            .unwrap_or(0);
            
        for spec in access_specifiers {
            if let AddressSpecifier::Parameter(local_idx, _) = &spec.address {
                if (*local_idx as usize) >= param_count {
                    return Err(bounds_error(
                        StatusCode::INDEX_OUT_OF_BOUNDS,
                        IndexKind::LocalPool,
                        *local_idx,
                        param_count,
                    ));
                }
            }
        }
    }
    
    Ok(())
}
```

This fix ensures that all parameter indices in access specifiers are validated during the bounds checking phase, preventing invalid bytecode from passing verification.

## Proof of Concept

While a complete PoC requires bytecode manipulation tools, the vulnerable execution path can be demonstrated conceptually:

1. Create a function with N parameters (e.g., N=2)
2. Add an access specifier with `Parameter(2, None)` (out of bounds)
3. Use move-asm or similar tool to generate the binary module
4. Publish the module (will pass verification due to the gap)
5. Call the function in a transaction
6. Observe `VERIFIER_INVARIANT_VIOLATION` error at runtime

The technical analysis demonstrates that all components of this attack path exist and are exploitable, with all code references verified against the Aptos Core codebase.

## Notes

This vulnerability represents a genuine gap in the Move bytecode verifier's completeness. While the standard Move compiler prevents this issue through its own validation, the bytecode verifier should be defense-in-depth and catch all invalid bytecode regardless of how it was generated. The ability to trigger `VERIFIER_INVARIANT_VIOLATION` at runtime for verified bytecode violates a core Move VM invariant and represents a protocol-level bug that should be addressed.

### Citations

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L238-248)
```rust
    fn check_function_handle(&self, function_handle: &FunctionHandle) -> PartialVMResult<()> {
        check_bounds_impl(self.view.module_handles(), function_handle.module)?;
        check_bounds_impl(self.view.identifiers(), function_handle.name)?;
        check_bounds_impl(self.view.signatures(), function_handle.parameters)?;
        check_bounds_impl(self.view.signatures(), function_handle.return_)?;
        // function signature type parameters must be in bounds to the function type parameters
        let type_param_count = function_handle.type_parameters.len();
        self.check_type_parameters_in_signature(function_handle.parameters, type_param_count)?;
        self.check_type_parameters_in_signature(function_handle.return_, type_param_count)?;
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L89-110)
```rust
        Parameter(param, fun) => {
            let fun = if let Some(idx) = fun {
                let fun_inst = access_table(module.function_instantiations(), idx.0)?;
                let fun_handle = access_table(module.function_handles(), fun_inst.handle.0)?;
                let mod_handle = access_table(module.module_handles(), fun_handle.module.0)?;
                let mod_id = module
                    .safe_module_id_for_handle(mod_handle)
                    .ok_or_else(index_out_of_range)?;
                let mod_name = mod_id.short_str_lossless();
                let fun_name = access_table(module.identifiers(), fun_handle.name.0)?;
                AddressSpecifierFunction::parse(&mod_name, fun_name.as_str()).ok_or_else(|| {
                    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)
                        .with_message(format!(
                            "function `{}::{}` not supported for address specifier",
                            mod_name, fun_name
                        ))
                })?
            } else {
                AddressSpecifierFunction::Identity
            };
            Ok(AddressSpecifier::Eval(fun, *param))
        },
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L26-48)
```rust
    pub(crate) fn enter_function(
        &mut self,
        env: &impl AccessSpecifierEnv,
        fun: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if matches!(fun.access_specifier(), AccessSpecifier::Any) {
            // Shortcut case that no access is specified
            return Ok(());
        }
        if self.specifier_stack.len() >= ACCESS_STACK_SIZE_LIMIT {
            Err(
                PartialVMError::new(StatusCode::ACCESS_STACK_LIMIT_EXCEEDED).with_message(format!(
                    "access specifier stack overflow (limit = {})",
                    ACCESS_STACK_SIZE_LIMIT
                )),
            )
        } else {
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
            self.specifier_stack.push(fun_specifier);
            Ok(())
        }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L231-237)
```rust
    /// Specializes this specifier, resolving `Eval` variants.
    fn specialize(&mut self, env: &impl AccessSpecifierEnv) -> PartialVMResult<()> {
        if let AddressSpecifier::Eval(fun, arg) = self {
            *self = AddressSpecifier::Literal(env.eval_address_specifier_function(*fun, *arg)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L79-87)
```rust
impl AccessSpecifierEnv for Frame {
    fn eval_address_specifier_function(
        &self,
        fun: AddressSpecifierFunction,
        local: LocalIndex,
    ) -> PartialVMResult<AccountAddress> {
        fun.eval(self.locals.copy_loc(local as usize)?)
    }
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2352-2362)
```rust
    pub fn copy_loc(&self, idx: usize) -> PartialVMResult<Value> {
        let locals = self.0.borrow();
        match locals.get(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot copy invalid value at index {}", idx))),
            Some(v) => Ok(v.copy_value(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))?),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2421-2427)
```rust
    #[cold]
    fn local_index_out_of_bounds(idx: usize, num_locals: usize) -> PartialVMError {
        PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION).with_message(format!(
            "local index out of bounds: got {}, len: {}",
            idx, num_locals
        ))
    }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-145)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
```

**File:** types/src/on_chain_config/aptos_features.rs (L245-245)
```rust
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-297)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
    }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L1083-1095)
```rust
                    let param_index = fun_env
                        .get_parameters()
                        .iter()
                        .position(|Parameter(n, _ty, _)| n == name)
                        .expect("parameter defined") as u8;
                    FF::AddressSpecifier::Parameter(param_index, None)
                },
                AddressSpecifier::Call(fun, name) => {
                    let param_index = fun_env
                        .get_parameters()
                        .iter()
                        .position(|Parameter(n, _ty, _)| n == name)
                        .expect("parameter defined") as u8;
```
