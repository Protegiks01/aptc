# Audit Report

## Title
Version Check Bypass in Metadata Extraction Allows Version 5 Modules to Bypass Resource Group Validation

## Summary
The `get_metadata_from_compiled_code()` function clears struct and function attributes for version 5 modules during publishing validation, but the `get_metadata()` function used at runtime does not perform this clearing. This allows version 5 modules to bypass resource group validation checks during publishing while having those attributes become active at runtime, violating the protocol requirement that V1 metadata features should only exist in version 6+ modules.

## Finding Description

The Aptos codebase defines `METADATA_V1_MIN_FILE_FORMAT_VERSION = 6`, indicating that V1 metadata (including struct and function attributes) should only exist in modules with bytecode version 6 or higher. [1](#0-0) 

However, there are two separate functions that extract metadata with different behaviors:

**During Publishing Validation**: `get_metadata_from_compiled_code()` explicitly clears `struct_attributes` and `fun_attributes` for version 5 modules, with a comment noting "this should have been gated in the verify module metadata." [2](#0-1) 

This function is called during module publishing validation: [3](#0-2) 

And during resource group validation: [4](#0-3) 

**At Runtime**: `get_metadata()` deserializes and caches metadata without any version-based clearing: [5](#0-4) 

This function is used at runtime for resource group membership detection: [6](#0-5) 

And for determining storage location: [7](#0-6) 

**Exploitation Path:**

1. An attacker crafts a version 5 module with V1 metadata containing resource group attributes (e.g., `#[resource_group_member]`)
2. During publishing, `get_metadata_from_compiled_code()` clears the attributes before validation
3. Resource group validation checks see empty attributes and pass
4. The raw bytecode (with uncleared metadata) is stored on-chain
5. At runtime, `get_metadata()` deserializes the attributes without clearing
6. Resources are incorrectly accessed from resource group storage instead of regular storage

Critical validation checks that are bypassed include scope validation, container existence checks, and upgrade consistency validation: [8](#0-7) 

## Impact Explanation

This constitutes a **HIGH severity** issue per Aptos bug bounty criteria as a "Significant protocol violation":

1. **Protocol Invariant Violation**: Version 5 modules explicitly should not have V1 metadata features. The constant `METADATA_V1_MIN_FILE_FORMAT_VERSION = 6` documents this constraint, yet the implementation allows this violation.

2. **Validation Bypass**: Critical safety checks for resource groups are skipped:
   - Scope validation (ensuring members and groups are in correct scope relationships)
   - Container existence verification
   - Upgrade consistency checks (preventing invalid attribute changes)

3. **Storage Location Mismatch**: Resources marked with `#[resource_group_member]` in version 5 modules will be stored/retrieved from resource group storage instead of regular storage, causing:
   - Incorrect storage access patterns
   - Potential gas charging discrepancies (resource groups have different costs)
   - Runtime failures if resource group containers don't exist

4. **Inconsistent State**: The same module behaves differently during validation vs. runtime execution, violating deterministic execution principles.

Note: The claim about consensus divergence is **not valid** - all validators run the same code version within an epoch, so they would process identically. The claim about view function bypass is also **not accurate** - runtime validation for view functions still checks all requirements.

## Likelihood Explanation

**HIGH Likelihood** - The attack is straightforward:
- Any user can publish Move modules (no special privileges required)
- Bytecode can be manually crafted or compiled with modified tools to set version=5 with V1 metadata
- The vulnerability is deterministic and reproducible
- No complex preconditions or timing dependencies
- The code comment explicitly acknowledges validation should have prevented this

## Recommendation

Add explicit validation in `check_metadata_format()` to reject V1 metadata keys for version 5 modules:

```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    // ... existing code ...
    
    if data.key == *APTOS_METADATA_KEY_V1 {
        // Enforce version requirement for V1 metadata
        if module.version < METADATA_V1_MIN_FILE_FORMAT_VERSION {
            return Err(MalformedError::InvalidMetadataVersion);
        }
        bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
            .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
    }
    // ... rest of code ...
}
```

Alternatively, modify `get_metadata()` to also perform version-based clearing for consistency with `get_metadata_from_compiled_code()`.

## Proof of Concept

A complete PoC would require:
1. Compiling a Move module with resource group attributes
2. Modifying the compiled bytecode to set version=5 while keeping V1 metadata intact
3. Publishing the module via the transaction submission API
4. Demonstrating that runtime resource access uses the wrong storage location

The vulnerability can be confirmed by code inspection of the metadata extraction functions and their usage patterns during validation vs. runtime.

## Notes

The core vulnerability mechanism is valid - version 5 modules can bypass resource group validation. However, the report's claims about view function bypass and consensus divergence are not accurate. The primary security concern is the protocol violation and validation bypass for resource groups, which could lead to storage misconfigurations and incorrect gas charging, though not direct fund loss or consensus failure.

### Citations

**File:** types/src/vm/module_metadata.rs (L40-40)
```rust
pub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;
```

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L36-104)
```rust
pub(crate) fn validate_resource_groups(
    features: &Features,
    module_storage: &impl ModuleStorage,
    traversal_context: &mut TraversalContext,
    gas_meter: &mut impl GasMeter,
    new_modules: &[CompiledModule],
) -> Result<(), VMError> {
    let mut groups = BTreeMap::new();
    let mut members = BTreeMap::new();

    for new_module in new_modules {
        let (new_groups, new_members) = validate_module_and_extract_new_entries(
            module_storage,
            new_module,
            features,
            traversal_context,
        )?;
        groups.insert(new_module.self_id(), new_groups);
        members.insert(new_module.self_id(), new_members);
    }

    for (module_id, inner_members) in members {
        for group_tag in inner_members.values() {
            let group_module_id = group_tag.module_id();
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }

            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };

            if !scope.are_equal_module_ids(&module_id, &group_module_id) {
                metadata_validation_err("Scope mismatch")?;
            }
        }
    }

    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L119-124)
```rust
    let (new_groups, mut new_members) =
        if let Some(metadata) = get_metadata_from_compiled_code(new_module) {
            extract_resource_group_metadata(&metadata)?
        } else {
            (BTreeMap::new(), BTreeMap::new())
        };
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```
