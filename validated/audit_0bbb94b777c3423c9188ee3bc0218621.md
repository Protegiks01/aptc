# Audit Report

## Title
Race Condition in sync_info() Allows Inconsistent Certificate Combination Leading to Message Rejection and Validator Isolation

## Summary
The `sync_info()` method in `BlockStore` suffers from a Time-of-Check-Time-of-Use (TOCTOU) race condition where it reads four separate certificates without holding a consistent lock, allowing the underlying state to change between reads. This produces invalid `SyncInfo` objects that violate critical invariants, causing honest validators' messages to be rejected by peers and triggering false positive security events.

## Finding Description

The vulnerability exists in the `sync_info()` implementation which constructs a `SyncInfo` object by calling four separate methods sequentially without holding a consistent lock across all reads. [1](#0-0) 

Each of these four method calls independently acquires and releases a read lock on `self.inner` (the `BlockTree`). [2](#0-1)  The BlockTree getter methods simply clone the Arc references after acquiring the read lock. [3](#0-2) 

Between any two getter calls, another thread can acquire a write lock and update the tree state. The critical write operation is `insert_quorum_cert`, which updates BOTH `highest_quorum_cert` AND `highest_ordered_cert` simultaneously under a single write lock. [4](#0-3)  The write lock is acquired when calling this method. [5](#0-4) 

**Race Condition Scenario:**

1. Thread A calls `sync_info()` and acquires a read lock to call `highest_quorum_cert()` → gets QC(round=100) → releases read lock
2. Thread B acquires a write lock and calls `insert_quorum_cert` with QC(round=101), updating both `highest_quorum_cert` (line 370) and `highest_ordered_cert` (line 382) → releases write lock
3. Thread A acquires a read lock again to call `highest_ordered_cert()` → gets HOC(round=101) → releases read lock
4. Thread A creates SyncInfo with HQC(round=100), HOC(round=101)

This violates the critical invariant enforced during `SyncInfo` verification that requires `highest_quorum_cert.certified_block().round() >= highest_ordered_cert().commit_info().round()`. [6](#0-5) 

The invalid `SyncInfo` is attached to consensus messages. When creating vote messages, the code calls `self.block_store.sync_info()`. [7](#0-6) 

When recipients process the message through `ensure_round_and_sync_up`, the call to `sync_up` performs verification. [8](#0-7)  When verification fails, it logs a security event and rejects the message. [9](#0-8)  The error propagates up causing the entire message to be dropped in both proposal processing [10](#0-9)  and vote processing. [11](#0-10) 

## Impact Explanation

This qualifies as **HIGH severity** under the Aptos bug bounty program's "Validator Node Slowdowns" category:

1. **Degraded Consensus Participation**: When validators' messages are repeatedly rejected due to this race condition, their votes and proposals are dropped, directly impacting their consensus participation and slowing block production.

2. **Critical Invariant Violations**: The bug causes `SyncInfo` objects to violate the documented invariant (HQC.round >= HOC.round) that is fundamental to the consensus protocol's certificate ordering guarantees.

3. **False Positive Security Events**: Honest validators are incorrectly flagged with `SecurityEvent::InvalidSyncInfoMsg`, which could trigger automated reputation systems or monitoring alerts, potentially leading to unnecessary operator intervention.

4. **Liveness Impact**: During high-load periods when concurrent certificate updates are most frequent, multiple validators could experience this simultaneously, significantly impairing the network's ability to reach consensus efficiently.

5. **No Recovery Mechanism**: Messages rejected due to failed SyncInfo verification are simply dropped with no retry logic, maximizing the impact of each race condition occurrence.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurring:

1. **Frequent Certificate Updates**: During normal consensus operation, `insert_quorum_cert` is called for every new block that receives a quorum certificate, creating continuous opportunities for the race.

2. **High Concurrency**: Validators process messages from multiple peers concurrently, and the write lock acquisition in `insert_quorum_cert` creates natural interleaving opportunities with the independent read locks in `sync_info()`.

3. **Continuous Execution**: Every vote and proposal message includes a `SyncInfo`, so the vulnerable `sync_info()` code path is executed for every consensus message sent.

4. **High-Load Amplification**: Under network stress or high transaction throughput, the frequency of concurrent certificate updates increases dramatically, making race condition windows overlap more frequently.

## Recommendation

The fix is to acquire a single read lock for the entire duration of `sync_info()` construction:

```rust
fn sync_info(&self) -> SyncInfo {
    let inner = self.inner.read();
    SyncInfo::new_decoupled(
        inner.highest_quorum_cert().as_ref().clone(),
        inner.highest_ordered_cert().as_ref().clone(),
        inner.highest_commit_cert().as_ref().clone(),
        inner.highest_2chain_timeout_cert().map(|tc| tc.as_ref().clone()),
    )
}
```

This ensures all four certificate reads happen atomically under a single consistent view of the BlockTree state, preventing the TOCTOU race condition.

## Proof of Concept

While a complete PoC would require setting up a multi-threaded consensus test environment, the race condition can be demonstrated conceptually:

1. Set up two threads accessing the same BlockStore
2. Thread A: Continuously calls `sync_info()` in a loop
3. Thread B: Continuously calls `insert_single_quorum_cert()` with incrementing rounds
4. Monitor for SyncInfo objects where HQC.round < HOC.round (violating the invariant)
5. Observe that such invalid SyncInfo objects are produced during concurrent execution

The vulnerability is inherent in the design where four independent lock acquisitions allow state changes to occur between reads.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L555-556)
```rust
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/src/block_storage/block_store.rs (L664-678)
```rust
    fn highest_quorum_cert(&self) -> Arc<QuorumCert> {
        self.inner.read().highest_quorum_cert()
    }

    fn highest_ordered_cert(&self) -> Arc<WrappedLedgerInfo> {
        self.inner.read().highest_ordered_cert()
    }

    fn highest_commit_cert(&self) -> Arc<WrappedLedgerInfo> {
        self.inner.read().highest_commit_cert()
    }

    fn highest_2chain_timeout_cert(&self) -> Option<Arc<TwoChainTimeoutCertificate>> {
        self.inner.read().highest_2chain_timeout_cert()
    }
```

**File:** consensus/src/block_storage/block_store.rs (L680-688)
```rust
    fn sync_info(&self) -> SyncInfo {
        SyncInfo::new_decoupled(
            self.highest_quorum_cert().as_ref().clone(),
            self.highest_ordered_cert().as_ref().clone(),
            self.highest_commit_cert().as_ref().clone(),
            self.highest_2chain_timeout_cert()
                .map(|tc| tc.as_ref().clone()),
        )
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L213-232)
```rust
    pub(super) fn highest_quorum_cert(&self) -> Arc<QuorumCert> {
        Arc::clone(&self.highest_quorum_cert)
    }

    pub(super) fn highest_2chain_timeout_cert(&self) -> Option<Arc<TwoChainTimeoutCertificate>> {
        self.highest_2chain_timeout_cert.clone()
    }

    /// Replace highest timeout cert with the given value.
    pub(super) fn replace_2chain_timeout_cert(&mut self, tc: Arc<TwoChainTimeoutCertificate>) {
        self.highest_2chain_timeout_cert.replace(tc);
    }

    pub(super) fn highest_ordered_cert(&self) -> Arc<WrappedLedgerInfo> {
        Arc::clone(&self.highest_ordered_cert)
    }

    pub(super) fn highest_commit_cert(&self) -> Arc<WrappedLedgerInfo> {
        Arc::clone(&self.highest_commit_cert)
    }
```

**File:** consensus/src/block_storage/block_tree.rs (L349-386)
```rust
    pub(super) fn insert_quorum_cert(&mut self, qc: QuorumCert) -> anyhow::Result<()> {
        let block_id = qc.certified_block().id();
        let qc = Arc::new(qc);

        // Safety invariant: For any two quorum certificates qc1, qc2 in the block store,
        // qc1 == qc2 || qc1.round != qc2.round
        // The invariant is quadratic but can be maintained in linear time by the check
        // below.
        precondition!({
            let qc_round = qc.certified_block().round();
            self.id_to_quorum_cert.values().all(|x| {
                (*(*x).ledger_info()).ledger_info().consensus_data_hash()
                    == (*(*qc).ledger_info()).ledger_info().consensus_data_hash()
                    || x.certified_block().round() != qc_round
            })
        });

        match self.get_block(&block_id) {
            Some(block) => {
                if block.round() > self.highest_certified_block().round() {
                    self.highest_certified_block_id = block.id();
                    self.highest_quorum_cert = Arc::clone(&qc);
                }
            },
            None => bail!("Block {} not found", block_id),
        }

        self.id_to_quorum_cert
            .entry(block_id)
            .or_insert_with(|| Arc::clone(&qc));

        if self.highest_ordered_cert.commit_info().round() < qc.commit_info().round() {
            // Question: We are updating highest_ordered_cert but not highest_ordered_root. Is that fine?
            self.highest_ordered_cert = Arc::new(qc.into_wrapped_ledger_info());
        }

        Ok(())
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L152-156)
```rust
        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );
```

**File:** consensus/src/round_manager.rs (L743-750)
```rust
        let in_correct_round = self
            .ensure_round_and_sync_up(
                proposal_msg.proposal().round(),
                proposal_msg.sync_info(),
                proposal_msg.proposer(),
            )
            .await
            .context("[RoundManager] Process proposal")?;
```

**File:** consensus/src/round_manager.rs (L888-896)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/src/round_manager.rs (L916-935)
```rust
    pub async fn ensure_round_and_sync_up(
        &mut self,
        message_round: Round,
        sync_info: &SyncInfo,
        author: Author,
    ) -> anyhow::Result<bool> {
        if message_round < self.round_state.current_round() {
            return Ok(false);
        }
        self.sync_up(sync_info, author).await?;
        ensure!(
            message_round == self.round_state.current_round(),
            "After sync, round {} doesn't match local {}. Local Sync Info: {}. Remote Sync Info: {}",
            message_round,
            self.round_state.current_round(),
            self.block_store.sync_info(),
            sync_info,
        );
        Ok(true)
    }
```

**File:** consensus/src/round_manager.rs (L1401-1401)
```rust
        let vote_msg = VoteMsg::new(vote.clone(), self.block_store.sync_info());
```

**File:** consensus/src/round_manager.rs (L1703-1709)
```rust
            .ensure_round_and_sync_up(
                vote_msg.vote().vote_data().proposed().round(),
                vote_msg.sync_info(),
                vote_msg.vote().author(),
            )
            .await
            .context("[RoundManager] Stop processing vote")?
```
