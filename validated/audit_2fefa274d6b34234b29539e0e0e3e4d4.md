# Audit Report

## Title
TOCTOU Race Condition in BlockExecutor Causes Validator Panic During Block Execution

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) race condition exists in `BlockExecutor::execute_and_update_state()` where the `inner` state can be set to `None` by a concurrent `finish()` call between the initialization check and actual usage, causing a panic that crashes the validator node during critical block execution.

## Finding Description

The vulnerability exists in the `BlockExecutor<V>` implementation where the `execute_and_update_state()` method follows a dangerous pattern: [1](#0-0) 

The race condition occurs because:

1. **Initialization check without lock protection**: The `maybe_initialize()` call checks if `inner` is `None` and initializes it if needed, but releases all locks after returning: [2](#0-1) 

2. **Gap window for race**: Between the completion of `maybe_initialize()` and the reading of `inner`, no lock prevents concurrent modification.

3. **execution_lock provides false security**: The `execution_lock` acquired at line 107 only prevents concurrent block executions but does NOT prevent `finish()` from being called.

4. **finish() sets inner to None without coordination**: The `finish()` method can be called concurrently and only acquires the write lock on `inner` itself, not the `execution_lock`: [3](#0-2) 

5. **Panic on expect**: When `inner` is `None`, the `expect()` call at line 111 panics with "BlockExecutor is not reset", crashing the validator.

**Concurrent Execution Scenario:**

State synchronization operations call `finish()` to free memory before syncing: [4](#0-3) [5](#0-4) 

This is triggered during normal validator operations, such as fast forward sync: [6](#0-5) 

**Execution Flow:**

- **Thread A (Block Execution)**: Enters `execute_and_update_state()`, calls `maybe_initialize()` which sets `inner = Some(...)`, begins waiting to acquire `execution_lock` or already executing
- **Thread B (State Sync)**: Triggers fast forward sync or fallback sync, attempts to abort pipeline (but cannot abort `spawn_blocking` tasks), calls `finish()` which sets `inner = None`
- **Thread A**: Acquires or holds `execution_lock` (provides no protection against `finish()`), attempts to read `inner`, gets `None`, panics

The race window is significant because block execution occurs in `spawn_blocking` tasks that cannot be aborted once started: [7](#0-6) 

**Other Affected Methods:**

The same vulnerability pattern exists in:
- `committed_block_id()` [8](#0-7) 
- `pre_commit_block()` [9](#0-8) 
- `commit_ledger()` [10](#0-9) 
- `state_view()` [11](#0-10) 

## Impact Explanation

**Severity: Critical**

This vulnerability meets the critical severity criteria:

1. **Validator Node Crash**: The panic immediately terminates the validator process during block execution, a critical consensus phase.

2. **Total Loss of Liveness/Network Availability**: When validators crash during block execution, they cannot participate in consensus voting. If multiple validators experience this simultaneously (e.g., during network instability triggering state synchronization), it could approach or exceed the 1/3 Byzantine threshold, causing consensus to stall.

3. **Remote Code Execution on Validator Node**: The panic constitutes forced process termination, equivalent to crashing the validator node.

4. **Non-recoverable without manual intervention**: The validator requires restart and re-synchronization, during which it cannot participate in consensus.

5. **Timing**: The crash occurs during active block processing, maximizing disruption to consensus operations.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is likely to occur in production because:

1. **Natural Trigger Conditions**: State synchronization (including fast forward sync) is triggered during normal network operations when validators fall behind, experience network latency, or need to catch up.

2. **Concurrent Operations**: Block execution and state synchronization are independent concurrent operations with no coordination between `execution_lock` and the `write_mutex` used by state sync in ExecutionProxy.

3. **Significant Race Window**: The race window is not just a few lines of code, but the entire duration that one thread holds `execution_lock` while another thread waits to acquire it. Since block execution can take seconds to complete, this creates a substantial window during which `finish()` can be called.

4. **Unabrortable Execution**: Block execution runs in `spawn_blocking` tasks that cannot be aborted once started, even when the pipeline attempts to abort pending operations before state sync.

5. **No Mitigation**: There are no retry mechanisms or panic recovery handlers that would prevent the validator crash.

## Recommendation

The vulnerability can be fixed by ensuring proper synchronization between `finish()` and execution methods. Recommended solutions:

1. **Acquire execution_lock in finish()**: Modify `finish()` to also acquire `execution_lock` before setting `inner = None`, ensuring mutual exclusion with block execution.

2. **Use atomic state management**: Replace the separate `inner` and `execution_lock` with a single synchronized state management mechanism.

3. **Add validation after lock acquisition**: After acquiring `execution_lock`, re-check that `inner` is not `None` before proceeding, returning an error instead of panicking.

Example fix:
```rust
fn finish(&self) {
    let _exec_guard = self.execution_lock.lock(); // Acquire execution_lock first
    let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "finish"]);
    *self.inner.write() = None;
}
```

## Proof of Concept

While a complete PoC would require setting up concurrent threads with precise timing, the vulnerability can be demonstrated by examining the code structure:

1. The `execute_and_update_state()` method acquires `execution_lock` but reads `inner` without holding the write lock
2. The `finish()` method sets `inner = None` without acquiring `execution_lock`
3. These two locks are independent and provide no mutual exclusion
4. Block execution in `spawn_blocking` cannot be aborted once started, allowing the race to occur even with pipeline abort attempts

The vulnerability is evident from the code structure and the lack of coordination between state synchronization (which calls `finish()`) and block execution operations.

## Notes

This vulnerability affects regular validators, not just consensus observer fullnodes. The fast forward sync mechanism used by validators during normal catch-up operations triggers the vulnerable code path. The `spawn_blocking` execution model prevents proper cancellation of in-flight block executions, making the race condition exploitable during normal network operations.

### Citations

**File:** execution/executor/src/block_executor/mod.rs (L67-72)
```rust
    fn maybe_initialize(&self) -> Result<()> {
        if self.inner.read().is_none() {
            self.reset()?;
        }
        Ok(())
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L79-88)
```rust
    fn committed_block_id(&self) -> HashValue {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "committed_block_id"]);

        self.maybe_initialize().expect("Failed to initialize.");
        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .committed_block_id()
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L97-113)
```rust
    fn execute_and_update_state(
        &self,
        block: ExecutableBlock,
        parent_block_id: HashValue,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "execute_and_state_checkpoint"]);

        self.maybe_initialize()?;
        // guarantee only one block being executed at a time
        let _guard = self.execution_lock.lock();
        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .execute_and_update_state(block, parent_block_id, onchain_config)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L131-139)
```rust
    fn pre_commit_block(&self, block_id: HashValue) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "pre_commit_block"]);

        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .pre_commit_block(block_id)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L141-149)
```rust
    fn commit_ledger(&self, ledger_info_with_sigs: LedgerInfoWithSignatures) -> ExecutorResult<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "commit_ledger"]);

        self.inner
            .read()
            .as_ref()
            .expect("BlockExecutor is not reset")
            .commit_ledger(ledger_info_with_sigs)
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L151-155)
```rust
    fn finish(&self) {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["block", "finish"]);

        *self.inner.write() = None;
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L157-160)
```rust
    fn state_view(&self, block_id: HashValue) -> ExecutorResult<CachedStateView> {
        self.maybe_initialize()?;
        self.inner.read().as_ref().unwrap().state_view(block_id)
    }
```

**File:** consensus/src/state_computer.rs (L139-141)
```rust
        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by the BlockExecutor to prevent a memory leak.
        self.executor.finish();
```

**File:** consensus/src/state_computer.rs (L183-185)
```rust
        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by BlockExecutor to prevent a memory leak.
        self.executor.finish();
```

**File:** consensus/src/block_storage/sync_manager.rs (L504-514)
```rust
        // abort any pending executor tasks before entering state sync
        // with zaptos, things can run before hitting buffer manager
        if let Some(block_store) = maybe_block_store {
            monitor!(
                "abort_pipeline_for_state_sync",
                block_store.abort_pipeline_for_state_sync().await
            );
        }
        execution_client
            .sync_to_target(highest_commit_cert.ledger_info().clone())
            .await?;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L857-867)
```rust
        tokio::task::spawn_blocking(move || {
            executor
                .execute_and_update_state(
                    (block.id(), txns, auxiliary_info).into(),
                    block.parent_id(),
                    onchain_execution_config,
                )
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
```
