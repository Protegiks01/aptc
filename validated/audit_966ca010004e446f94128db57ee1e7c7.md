# Audit Report

## Title
Epoch Transition Deadlock and State Inconsistency When DKG Fails During Version Upgrade

## Summary
When DKG (Distributed Key Generation) is enabled, a failed DKG session creates a deadlock that prevents all future epoch transitions. Configuration changes staged by governance proposals never activate because the epoch mechanism becomes permanently blocked until manual intervention via `force_end_epoch()`.

## Finding Description

The vulnerability exists in the DKG-based reconfiguration flow within the Aptos Framework. The core issue is an early return condition in `try_start()` that creates an unbreakable deadlock when DKG fails to complete.

**The Critical Deadlock Logic:**

When `try_start()` detects an incomplete DKG session where the dealer epoch matches the current epoch, it returns early without starting a new DKG session or completing any epoch transition. [1](#0-0) 

**The Failure Scenario:**

1. **Configuration Staging**: A governance proposal calls `set_for_next_epoch()` which buffers the configuration change without applying it immediately. [2](#0-1) [3](#0-2) 

2. **DKG Initiation**: The proposal triggers `reconfigure()` which conditionally starts DKG when both validator transactions and randomness are enabled. [4](#0-3) 

3. **DKG Session Start**: The `dkg::start()` function creates an in-progress session with the current epoch recorded. [5](#0-4) 

4. **DKG Failure**: The DKG session fails to complete due to network issues, insufficient validator participation, or coordination failures. The session remains in the `in_progress` state indefinitely.

5. **Deadlock**: All subsequent calls to `try_start()` (from block prologues checking for epoch timeout or new governance proposals) detect the incomplete session for the current epoch and return early at line 29, preventing any new DKG attempt or epoch transition. [6](#0-5) 

**No Timeout Mechanism:**

The `DKGSessionState` records `start_time_us` but no code exists to check this value for timeout detection or automatic recovery. [7](#0-6) 

**Buffered Configurations Never Activate:**

Staged configurations only activate when `on_new_epoch()` is called during `finish()`, which applies buffered configs and then increments the epoch counter. [8](#0-7) [9](#0-8) 

The epoch counter is only incremented in `reconfiguration::reconfigure()`, which is called from `finish()` but never from `try_start()`. [10](#0-9) 

**Recovery Requires Manual Governance Intervention:**

The only recovery path is for governance to pass a proposal calling `force_end_epoch()`, which directly invokes `finish()` to clear the incomplete session and force the epoch transition. [11](#0-10) 

The `try_clear_incomplete_session()` function that clears stuck sessions requires the `aptos_framework` signer, making it inaccessible except through governance. [12](#0-11) 

## Impact Explanation

This vulnerability qualifies as **MEDIUM to HIGH severity** per Aptos bug bounty criteria:

**State Inconsistencies Requiring Manual Intervention**: A critical divergence exists between governance proposal records (showing successful execution) and actual on-chain configuration state (unchanged). Staged configurations accumulate in buffers but never activate, undermining governance integrity and creating operational confusion.

**Epoch Transition Liveness Failure**: The epoch transition mechanism—a core protocol component—becomes completely deadlocked. This prevents:
- Configuration updates from activating (version upgrades, gas schedules, consensus configs)
- Validator set changes based on staking operations
- Reward distribution at epoch boundaries
- Any protocol upgrades requiring epoch transitions

**Partial Liveness**: Block production continues and transactions process normally, preventing this from reaching CRITICAL severity. The network does not halt completely, and no funds are lost or stolen. However, epoch-dependent operations are frozen indefinitely.

**Recovery Cost**: Manual intervention through governance requires creating a new proposal, multi-day voting periods, and coordination among stakeholders—a costly and slow process during a protocol deadlock.

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH**:

**Natural Failure Mode**: DKG is a distributed cryptographic protocol requiring coordination among validators with a quorum threshold (typically 2/3 voting power). Realistic failure scenarios include network partitions, validator downtime, insufficient participation, state synchronization issues, or validator software bugs. This is not a malicious attack—DKG can fail through normal operational issues.

**No Automatic Recovery**: The codebase lacks any timeout mechanism or automatic retry logic. The `start_time_us` field is recorded but never checked against current time. Once a DKG session fails, it remains stuck until manual governance intervention.

**Production Environment Complexity**: Real-world validator networks have diverse geographic distribution, varying network conditions, and operational variability that increase the probability of coordination failures during DKG.

**Detection Lag**: If the initial DKG failure goes unnoticed, multiple governance proposals could execute before the deadlock is discovered, compounding the problem with accumulated staged configurations.

## Recommendation

Implement automatic timeout detection and recovery mechanisms:

1. **Add Timeout Check**: In `try_start()`, check if `start_time_us` of the incomplete session exceeds a threshold (e.g., 2x expected DKG duration). If timeout detected, clear the stale session and start a new DKG attempt.

2. **Automatic Session Cleanup**: Modify the early return logic to allow recovery after timeout rather than indefinite blocking.

3. **Alternative Recovery**: Allow block prologue to detect and clear timed-out DKG sessions without requiring governance intervention.

4. **Monitoring**: Emit events when DKG sessions fail to complete within expected timeframes to enable prompt detection.

## Proof of Concept

While a full end-to-end PoC would require a multi-validator testnet setup to simulate DKG failure, the vulnerability can be verified through code inspection:

1. The early return at line 28-29 of `reconfiguration_with_dkg.move` creates the deadlock condition
2. No code path exists to clear `in_progress` sessions except through `try_clear_incomplete_session()` which requires `aptos_framework` signer
3. The `start_time_us` field is set but never checked for timeout anywhere in the codebase (verified via grep search)
4. Block prologues and governance reconfigurations both route through `try_start()`, meaning all epoch transition attempts hit the same early return

The logical flow verification demonstrates that once DKG fails, the protocol enters an unrecoverable state without governance intervention.

## Notes

The deprecated synchronous configuration functions (`version::set_version()`, `gas_schedule::set_gas_schedule()`, etc.) include `chain_status::assert_genesis()` checks, restricting them to genesis-only use and preventing them from serving as alternative recovery paths in production environments.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L59-64)
```text
    public entry fun set_for_next_epoch(account: &signer, major: u64) acquires Version {
        assert!(exists<SetVersionCapability>(signer::address_of(account)), error::permission_denied(ENOT_AUTHORIZED));
        let old_major = borrow_global<Version>(@aptos_framework).major;
        assert!(old_major < major, error::invalid_argument(EINVALID_MAJOR_VERSION_NUMBER));
        config_buffer::upsert(Version {major});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/version.move (L67-77)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires Version {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<Version>()) {
            let new_value = config_buffer::extract_v2<Version>();
            if (exists<Version>(@aptos_framework)) {
                *borrow_global_mut<Version>(@aptos_framework) = new_value;
            } else {
                move_to(framework, new_value);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L700-703)
```text
    public entry fun force_end_epoch(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        reconfiguration_with_dkg::finish(aptos_framework);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L33-37)
```text
    struct DKGSessionState has copy, store, drop {
        metadata: DKGSessionMetadata,
        start_time_us: u64,
        transcript: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L61-85)
```text
    public(friend) fun start(
        dealer_epoch: u64,
        randomness_config: RandomnessConfig,
        dealer_validator_set: vector<ValidatorConsensusInfo>,
        target_validator_set: vector<ValidatorConsensusInfo>,
    ) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        let new_session_metadata = DKGSessionMetadata {
            dealer_epoch,
            randomness_config,
            dealer_validator_set,
            target_validator_set,
        };
        let start_time_us = timestamp::now_microseconds();
        dkg_state.in_progress = std::option::some(DKGSessionState {
            metadata: new_session_metadata,
            start_time_us,
            transcript: vector[],
        });

        emit(DKGStartEvent {
            start_time_us,
            session_metadata: new_session_metadata,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L100-106)
```text
    public fun try_clear_incomplete_session(fx: &signer) acquires DKGState {
        system_addresses::assert_aptos_framework(fx);
        if (exists<DKGState>(@aptos_framework)) {
            let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
            dkg_state.in_progress = option::none();
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L244-246)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L106-159)
```text
    public(friend) fun reconfigure() acquires Configuration {
        // Do not do anything if genesis has not finished.
        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {
            return
        };

        let config_ref = borrow_global_mut<Configuration>(@aptos_framework);
        let current_time = timestamp::now_microseconds();

        // Do not do anything if a reconfiguration event is already emitted within this transaction.
        //
        // This is OK because:
        // - The time changes in every non-empty block
        // - A block automatically ends after a transaction that emits a reconfiguration event, which is guaranteed by
        //   VM spec that all transactions comming after a reconfiguration transaction will be returned as Retry
        //   status.
        // - Each transaction must emit at most one reconfiguration event
        //
        // Thus, this check ensures that a transaction that does multiple "reconfiguration required" actions emits only
        // one reconfiguration event.
        //
        if (current_time == config_ref.last_reconfiguration_time) {
            return
        };

        reconfiguration_state::on_reconfig_start();

        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
        storage_gas::on_reconfig();

        assert!(current_time > config_ref.last_reconfiguration_time, error::invalid_state(EINVALID_BLOCK_TIME));
        config_ref.last_reconfiguration_time = current_time;
        spec {
            assume config_ref.epoch + 1 <= MAX_U64;
        };
        config_ref.epoch = config_ref.epoch + 1;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                NewEpoch {
                    epoch: config_ref.epoch,
                },
            );
        };
        event::emit_event<NewEpochEvent>(
            &mut config_ref.events,
            NewEpochEvent {
                epoch: config_ref.epoch,
            },
        );

        reconfiguration_state::on_reconfig_finish();
    }
```
