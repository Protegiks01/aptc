# Audit Report

## Title
Cross-Column Family Deletion Bug in Quorum Store Epoch Garbage Collection

## Summary
The `gc_previous_epoch_batches_from_db_v2()` function in `batch_store.rs` incorrectly deletes batches from the `batch` column family instead of the `batch_v2` column family during epoch transitions, causing V2 batches to accumulate indefinitely and leading to storage exhaustion. A similar bug exists in `update_certified_timestamp()` where expired V2 batches are not properly deleted from persistent storage.

## Finding Description

The Quorum Store maintains two separate column families for batch storage: `batch` (for V1 batches using `BatchInfo`) and `batch_v2` (for V2 batches using `BatchInfoExt`). [1](#0-0) 

During epoch transitions, `BatchStore::new()` spawns garbage collection tasks to clean up batches from previous epochs. [2](#0-1) 

**Bug #1: Incorrect Column Family Deletion in Epoch GC**

The `gc_previous_epoch_batches_from_db_v2()` function reads V2 batches from the `batch_v2` column family [3](#0-2)  but then incorrectly calls `db.delete_batches()` instead of `db.delete_batches_v2()` to delete them. [4](#0-3) 

The database implementation clearly distinguishes these methods: `delete_batches()` operates on `BatchSchema` [5](#0-4)  while `delete_batches_v2()` operates on `BatchV2Schema`. [6](#0-5) 

This is a clear copy-paste error, as evidenced by comparing with the correct implementation in `populate_cache_and_gc_expired_batches_v2()`, which properly calls `delete_batches_v2()`. [7](#0-6) 

**Bug #2: Missing V2 Deletion in Expiration Cleanup**

The `db_cache` stores `PersistedValue<BatchInfoExt>` entries [8](#0-7) , which can contain both V1 and V2 batches. However, `update_certified_timestamp()` only calls `db.delete_batches()` when clearing expired entries, [9](#0-8)  failing to delete V2 batches from the `batch_v2` column family.

**Breaking State Consistency Invariant:**

When epoch N+1 begins with V2 batches enabled:
1. All validators execute `gc_previous_epoch_batches_from_db_v2()`
2. Function reads expired V2 batch digests from `batch_v2` CF
3. Function attempts deletion from `batch` CF instead (wrong CF)
4. Result: V2 batches from epoch N-1 remain in `batch_v2` CF indefinitely
5. Storage accumulates unbounded across epochs

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty criteria ("State inconsistencies requiring manual intervention"):

1. **Storage Exhaustion**: V2 batches are never garbage collected from the database, leading to unbounded storage growth over time as validators transition through epochs. This violates storage resource constraints.

2. **Validator State Divergence**: Different validators may have different storage states depending on their batch history and V2 enablement timing, breaking deterministic storage guarantees. This could cause operational issues during state sync or recovery scenarios.

3. **Manual Intervention Required**: Cleaning up accumulated V2 batches requires manual database maintenance or migration scripts, as the automated garbage collection is broken.

The bug does **not** reach Critical severity because:
- It does not directly enable fund theft or unauthorized minting
- It does not break consensus safety or voting rules
- It does not cause immediate network-wide liveness failures
- It does not create irrecoverable network partitions

## Likelihood Explanation

**High Likelihood** if V2 batches are enabled in production:

1. **Automatic Trigger**: The bug triggers automatically on every epoch transition when `enable_batch_v2` configuration is enabled. [2](#0-1)  No attacker action is required.

2. **Compounding Effect**: Storage bloat accumulates with each epoch transition. If epochs occur daily, validators would accumulate V2 batches indefinitely.

3. **Configuration-Dependent**: The `enable_batch_v2` flag controls whether this bug is active. If disabled (the default), only V1 batches are used and the bug does not trigger.

4. **Migration Risk**: During V1â†’V2 migration periods when both formats coexist, the inconsistency between storage and cleanup is most problematic.

## Recommendation

**Fix for Bug #1**: Change line 241 in `gc_previous_epoch_batches_from_db_v2()`:

```rust
// Before (incorrect):
db.delete_batches(expired_keys)

// After (correct):
db.delete_batches_v2(expired_keys)
```

**Fix for Bug #2**: Modify `update_certified_timestamp()` to handle both V1 and V2 batches:

```rust
pub fn update_certified_timestamp(&self, certified_time: u64) {
    trace!("QS: batch reader updating time {:?}", certified_time);
    self.last_certified_time
        .fetch_max(certified_time, Ordering::SeqCst);

    let expired_keys = self.clear_expired_payload(certified_time);
    
    // Separate V1 and V2 keys based on cache entries
    let (v1_keys, v2_keys): (Vec<_>, Vec<_>) = expired_keys
        .into_iter()
        .partition(|k| {
            self.db_cache.get(k)
                .map(|v| !v.batch_info().is_v2())
                .unwrap_or(true)
        });
    
    if let Err(e) = self.db.delete_batches(v1_keys) {
        debug!("Error deleting v1 batches: {:?}", e)
    }
    
    if let Err(e) = self.db.delete_batches_v2(v2_keys) {
        debug!("Error deleting v2 batches: {:?}", e)
    }
}
```

## Proof of Concept

The bug can be demonstrated by:
1. Enabling `enable_batch_v2` configuration in a test environment
2. Creating V2 batches during epoch N
3. Transitioning to epoch N+1
4. Querying the `batch_v2` column family for epoch N batches
5. Observing that batches from epoch N remain in storage despite GC execution

Expected: V2 batches from previous epochs should be deleted  
Actual: V2 batches accumulate indefinitely across epoch transitions

**Notes:**
- The bug is evident from code inspection without requiring runtime testing
- Impact severity depends on whether V2 batches are enabled in production
- The fix is straightforward: use the correct delete method for V2 batches
- Storage monitoring would detect this issue as unbounded growth over time

### Citations

**File:** consensus/src/quorum_store/schema.rs (L14-16)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";
```

**File:** consensus/src/quorum_store/batch_store.rs (L116-116)
```rust
    db_cache: DashMap<HashValue, PersistedValue<BatchInfoExt>>,
```

**File:** consensus/src/quorum_store/batch_store.rs (L156-160)
```rust
        if is_new_epoch {
            tokio::task::spawn_blocking(move || {
                Self::gc_previous_epoch_batches_from_db_v1(db_clone.clone(), epoch);
                Self::gc_previous_epoch_batches_from_db_v2(db_clone, epoch);
            });
```

**File:** consensus/src/quorum_store/batch_store.rs (L213-215)
```rust
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
```

**File:** consensus/src/quorum_store/batch_store.rs (L241-242)
```rust
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
```

**File:** consensus/src/quorum_store/batch_store.rs (L332-335)
```rust
        tokio::task::spawn_blocking(move || {
            db.delete_batches_v2(expired_keys)
                .expect("Deletion of expired keys should not fail");
        });
```

**File:** consensus/src/quorum_store/batch_store.rs (L535-538)
```rust
        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```
