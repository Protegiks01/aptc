# Audit Report

## Title
Reflection Type Matching Gas Undercharging Enables Validator CPU Exhaustion

## Summary
The `reflect.resolve_base` gas parameter charges a fixed 4096 gas units regardless of type signature complexity, while the underlying type matching operation performs computational work proportional to the number of type nodes. An attacker can deploy modules with maximally complex type signatures (up to 128 type nodes) and repeatedly invoke reflection to consume validator CPU time disproportionate to gas charged, potentially causing validator slowdowns.

## Finding Description

The reflection feature enables dynamic function resolution at runtime through the `std::reflect::resolve` function. This vulnerability exists in how gas is charged for type matching operations during function resolution.

**Gas Charging:**
The reflection native function charges only a fixed base cost of 4096 internal gas units when resolving functions: [1](#0-0) 

This cost is charged immediately at the start of the native function: [2](#0-1) 

**Type Matching Without Gas:**
After charging the base cost, the function calls `resolve_function` which loads the module and then invokes `verify_function` to perform type matching: [3](#0-2) 

The `verify_function` method performs recursive type matching by calling `match_tys` on parameter and return types: [4](#0-3) 

The underlying `match_ty` function performs recursive traversal for complex types including nested vectors, struct instantiations, and function types, with NO gas charging: [5](#0-4) 

**Undercharging Comparison:**
Other comparable type-complexity operations charge gas proportionally:
- Type substitution charges 400 gas per type node: [6](#0-5) 
- Generic function calls charge 367 gas per type argument: [7](#0-6) 

For a function with the maximum allowed 128 type nodes, reflection charges 4096 gas while comparable type operations would charge approximately 51,200 gas (128 × 400), representing a 12.5x undercharging.

**Production Type Limits:**
The production configuration allows type signatures with up to 128 nodes at depth 20: [8](#0-7) 

These limits are enforced when function values are enabled: [9](#0-8) 

**Feature Enablement:**
The reflection feature is enabled by default in production: [10](#0-9) 

The feature check is present but passes in production environments: [11](#0-10) 

**Attack Execution:**
1. Attacker deploys a module with a public function having a maximally complex type signature (128 type nodes within allowed limits)
2. Submits transactions repeatedly calling `reflect::resolve` on this function
3. Each call charges only 4096 gas + one-time module loading cost
4. Validators must perform O(128) recursive type matching operations per call
5. With transaction gas limits, hundreds of resolve operations can be packed per transaction
6. Validators experience disproportionate CPU load during block execution

This breaks the fundamental gas metering invariant that computational cost should be proportional to gas charged.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program under category 8: "Validator Node Slowdowns (High): Significant performance degradation affecting consensus; DoS through resource exhaustion."

The specific impact is validator CPU exhaustion through gas undercharging:
- Validators must execute all transactions in proposed blocks
- Each reflection call performs significant CPU work (recursive type matching with up to 128 nodes)
- The gas charged (4096 units) does not reflect the actual computational cost (equivalent to ~51,200 units for comparable operations)
- Sustained exploitation could degrade validator performance during block execution
- This could affect consensus timing, increase block production times, or impact network liveness

This is NOT a network-level DoS attack (which would be out of scope), but rather a gas calculation bug that enables resource exhaustion—explicitly listed as a valid High severity impact in the framework.

The vulnerability breaks **Invariant #9** (Resource Limits): All operations must respect gas, storage, and computational limits in proportion to resources consumed.

## Likelihood Explanation

**Likelihood: Medium-High**

Prerequisites for exploitation:
1. ✅ Function reflection feature must be enabled - **Satisfied**: Enabled by default in production
2. ✅ Attacker can deploy arbitrary modules - **Satisfied**: Any user can deploy modules to their account
3. ✅ No special privileges required - **Satisfied**: Standard transaction submission

The attack is straightforward to execute:
- Attack complexity: **Low** - Deploy module with complex types, call reflect::resolve repeatedly
- Attacker cost: **Modest** - Normal transaction fees only
- Amplification factor: **Significant** - 12.5x undercharging
- Detection difficulty: **High** - Appears as normal reflection usage

Mitigating factors provide only partial protection:
- Module loading charges gas based on module size (one-time per transaction), not type complexity
- Function caching may reduce repeated costs within a transaction but doesn't prevent the attack across transactions
- No rate limiting or complexity-based gas adjustments exist

The combination of default feature enablement, zero privilege requirements, straightforward execution, and significant amplification factor makes this vulnerability readily exploitable.

## Recommendation

Implement gas charging proportional to type matching complexity in the reflection native function:

1. **Add complexity-based gas metering**: Before or during type matching in `verify_function`, count the number of type nodes being matched and charge gas accordingly (e.g., 400 gas per node to align with type substitution costs).

2. **Track type matching depth**: During recursive `match_ty` calls, track traversal depth and charge gas for each level of recursion.

3. **Consider caching with gas refunds**: If function resolution results are cached, provide partial gas refunds for cache hits while still ensuring minimum gas costs reflect the initial type matching work.

4. **Update gas schedule**: Modify `reflect_resolve_base` to include a per-type-node component or add a new `reflect_resolve_per_type_node` parameter.

Example fix location: In `native_resolve` function at [12](#0-11) , add gas charging after type matching completes based on the complexity of the matched types.

## Proof of Concept

While a complete executable PoC is not provided, the attack vector can be demonstrated through the following steps:

1. **Module Deployment**: Create a Move module with a public function having a deeply nested generic type signature approaching the 128-node limit (e.g., `public fun complex<T1, T2, ...>(arg: vector<vector<Struct<T1, T2, ...>>>) {}`)

2. **Reflection Call**: Submit transactions calling `std::reflect::resolve(@attacker, b"module", b"complex")` repeatedly

3. **Gas Observation**: Monitor gas charged (4096 per call) versus validator CPU usage during type matching operations

4. **Amplification**: Pack maximum number of resolve calls per transaction using complex type signatures to maximize the gas-to-CPU-work ratio

The technical feasibility is confirmed by the code analysis showing that type matching work is performed without proportional gas charging, and the production type limits explicitly allow the construction of such complex signatures.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L363-363)
```rust
        [reflect_resolve_base: InternalGas, { RELEASE_V1_39.. => "reflect.resolve_base" }, 4096],
```

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L26-67)
```rust
fn native_resolve(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Charge base cost before anything else.
    context.charge(REFLECT_RESOLVE_BASE)?;

    // Process arguments
    debug_assert!(ty_args.len() == 1);
    let Some(fun_ty) = ty_args.first() else {
        return Err(SafeNativeError::InvariantViolation(
            PartialVMError::new_invariant_violation("wrong number of type arguments"),
        ));
    };

    debug_assert!(args.len() == 3);
    let Some(fun_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
    let Some(mod_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
    let addr = safely_pop_arg!(args, AccountAddress);
    let mod_id = ModuleId::new(addr, mod_name);

    // Resolve function and return closure. Notice the loader context function
    // takes care of gas metering and type checking.
    match context
        .loader_context()
        .resolve_function(&mod_id, &fun_name, fun_ty)?
    {
        Ok(fun) => {
            // Return as a closure with no captured arguments
            Ok(smallvec![result::ok_result(Value::closure(
                fun,
                iter::empty()
            ))])
        },
        Err(e) => Ok(smallvec![result::err_result(pack_err(e as u16))]),
    }
}
```

**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L367-391)
```rust
    pub fn resolve_function(
        &mut self,
        module_id: &ModuleId,
        fun_id: &IdentStr,
        expected_ty: &Type,
    ) -> PartialVMResult<Result<Box<dyn AbstractFunction>, FunctionResolutionError>> {
        use FunctionResolutionError::*;
        dispatch_loader!(&self.module_storage, loader, {
            match loader.load_function_definition(
                &mut self.gas_meter,
                self.traversal_context,
                module_id,
                fun_id,
            ) {
                Ok((module, function)) => self.verify_function(module, function, expected_ty),
                Err(e)
                    if e.major_status() == StatusCode::FUNCTION_RESOLUTION_FAILURE
                        || e.major_status() == StatusCode::LINKER_ERROR =>
                {
                    Ok(Err(FunctionNotFound))
                },
                Err(e) => Err(e.to_partial()),
            }
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L418-420)
```rust
        if !subst.match_tys(func_ref.param_tys.iter(), args.iter())
            || !subst.match_tys(func_ref.return_tys.iter(), results.iter())
        {
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1560-1669)
```rust
    pub fn match_ty(&mut self, ty: &Type, expected_ty: &'a Type) -> bool {
        match (ty, expected_ty) {
            // The important case, deduce the type params.
            (Type::TyParam(idx), _) => {
                use btree_map::Entry::*;
                match self.map.entry(*idx) {
                    Occupied(occupied_entry) => *occupied_entry.get() == expected_ty,
                    Vacant(vacant_entry) => {
                        vacant_entry.insert(expected_ty);
                        true
                    },
                }
            },
            // Recursive types we need to recurse the matching types.
            (Type::Reference(inner), Type::Reference(expected_inner))
            | (Type::MutableReference(inner), Type::MutableReference(expected_inner)) => {
                self.match_ty(inner, expected_inner)
            },
            (Type::Vector(inner), Type::Vector(expected_inner)) => {
                self.match_ty(inner, expected_inner)
            },
            // Function types, the expected abilities need to be equal to the provided ones,
            // and recursively argument and result types need to match.
            (
                Type::Function {
                    args,
                    results,
                    abilities,
                },
                Type::Function {
                    args: exp_args,
                    results: exp_results,
                    abilities: exp_abilities,
                },
            ) if abilities == exp_abilities
                && args.len() == exp_args.len()
                && results.len() == exp_results.len() =>
            {
                args.iter().zip(exp_args).all(|(t, e)| self.match_ty(t, e))
                    && results
                        .iter()
                        .zip(exp_results)
                        .all(|(t, e)| self.match_ty(t, e))
            },
            // Abilities should not contribute to the equality check as they just serve for caching
            // computations. For structs the both need to be the same struct.
            (
                Type::Struct { idx, .. },
                Type::Struct {
                    idx: expected_idx, ..
                },
            ) => *idx == *expected_idx,
            // For struct instantiations we need to additionally match all type arguments.
            (
                Type::StructInstantiation { idx, ty_args, .. },
                Type::StructInstantiation {
                    idx: expected_idx,
                    ty_args: expected_ty_args,
                    ..
                },
            ) => {
                *idx == *expected_idx
                    && ty_args.len() == expected_ty_args.len()
                    && ty_args
                        .iter()
                        .zip(expected_ty_args.iter())
                        .all(|types| self.match_ty(types.0, types.1))
            },
            // For primitive types we need to assure the types match.
            (Type::U8, Type::U8)
            | (Type::U16, Type::U16)
            | (Type::U32, Type::U32)
            | (Type::U64, Type::U64)
            | (Type::U128, Type::U128)
            | (Type::U256, Type::U256)
            | (Type::I8, Type::I8)
            | (Type::I16, Type::I16)
            | (Type::I32, Type::I32)
            | (Type::I64, Type::I64)
            | (Type::I128, Type::I128)
            | (Type::I256, Type::I256)
            | (Type::Bool, Type::Bool)
            | (Type::Address, Type::Address)
            | (Type::Signer, Type::Signer) => true,
            // Otherwise the types do not match, and we can't match return type to the expected type.
            // Note we don't use the _ pattern but spell out all cases, so that the compiler will
            // bark when a case is missed upon future updates to the types.
            (Type::U8, _)
            | (Type::U16, _)
            | (Type::U32, _)
            | (Type::U64, _)
            | (Type::U128, _)
            | (Type::U256, _)
            | (Type::I8, _)
            | (Type::I16, _)
            | (Type::I32, _)
            | (Type::I64, _)
            | (Type::I128, _)
            | (Type::I256, _)
            | (Type::Bool, _)
            | (Type::Address, _)
            | (Type::Signer, _)
            | (Type::Struct { .. }, _)
            | (Type::StructInstantiation { .. }, _)
            | (Type::Function { .. }, _)
            | (Type::Vector(_), _)
            | (Type::MutableReference(_), _)
            | (Type::Reference(_), _) => false,
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L84-84)
```rust
        [call_generic_per_ty_arg: InternalGasPerArg, "call_generic.per_ty_arg", 367],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/instr.rs (L166-166)
```rust
        [subst_ty_per_node: InternalGasPerTypeNode, { 14.. => "subst_ty_per_node" }, 400],
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L133-133)
```rust
    TypeBuilder::with_limits(128, 20)
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** types/src/on_chain_config/aptos_features.rs (L273-273)
```rust
            FeatureFlag::ENABLE_FUNCTION_REFLECTION,
```

**File:** aptos-move/framework/move-stdlib/sources/reflect.move (L34-36)
```text
        assert!(
            features::is_function_reflection_enabled(),
            error::invalid_state(E_FEATURE_NOT_ENABLED)
```
