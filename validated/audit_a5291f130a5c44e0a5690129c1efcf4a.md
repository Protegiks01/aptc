# Audit Report

## Title
Memory Ordering Vulnerability in Block-STM Parallel Execution Allows Validation with Stale Read-Sets

## Summary
The `record()` function in `TxnLastInputOutput` uses `Ordering::Relaxed` when clearing the `speculative_failures` flag, creating a race condition where validator threads can observe the cleared flag before observing updated transaction inputs. This allows validation to proceed with stale read-sets from previous incarnations, potentially causing consensus divergence across validators executing the same block.

## Finding Description

In Aptos's Block-STM parallel execution engine, transactions undergo speculative execution and validation with multiple incarnations. The vulnerability exists in the synchronization between recording a successful execution and validators observing this update.

**The Race Condition:**

When `record()` stores a new execution result, it performs operations without proper synchronization: [1](#0-0) 

The `speculative_failures` flag is cleared using `Ordering::Relaxed`, which provides NO happens-before relationship with the subsequent input store: [2](#0-1) 

Validator threads retrieve this data via `read_set()`: [3](#0-2) 

Due to `Ordering::Relaxed`, a validator thread can observe:
1. `speculative_failures[txn_idx] = false` (NEW value from cleared flag)
2. `inputs[txn_idx]` = OLD read-set (from before the update)

**Critical Missing Validation:**

The `validate()` function checks `is_speculative_failure` but does NOT verify the incarnation number for data/group reads: [4](#0-3) [5](#0-4) 

Only `module_validation_v2()` checks incarnation numbers, but data and group validation proceed without this check: [6](#0-5) 

**Consensus Safety Violation:**

Different validators executing the same block in parallel may observe different memory orderings:
- Validator A: Observes (stale_read_set, false) → validates stale read-set → may commit
- Validator B: Observes (new_read_set, false) → validates new read-set → different validation result

If the stale and new read-sets have different validation outcomes, validators produce different commit decisions, leading to divergent state roots and consensus failure.

## Impact Explanation

**Severity: Critical (Consensus/Safety Violation)**

This vulnerability directly violates the **Deterministic Execution** invariant required by Aptos consensus. The consensus layer requires validators to collectively sign the resulting state root of a block: [7](#0-6) 

The race allows validators to:

1. **Produce divergent state roots**: Validators validating different read-sets for the same transaction can make different commit decisions, leading to different execution results and state roots
2. **Break consensus safety**: Without agreeing on state roots, validators cannot achieve consensus, causing network stalls or requiring manual intervention
3. **Violate Block-STM correctness**: The parallel execution algorithm's fundamental guarantee that committed transactions have validated read-sets matching their execution is broken

**Impact Category**: Critical - Consensus/Safety violations (up to $1,000,000 per Aptos Bug Bounty)

## Likelihood Explanation

**Likelihood: Medium-High**

This race condition occurs naturally during normal parallel execution when:
1. Transactions experience speculative failures (common under high contention)
2. Multiple worker threads execute and validate concurrently (always true in Block-STM)
3. CPU/cache timing allows memory reordering (architecture-dependent but possible on all platforms)

**Factors increasing likelihood:**
- High transaction throughput increases speculative failure rate
- Multi-core validator hardware enables true concurrent execution
- Weak memory models (ARM, RISC-V) make reordering more frequent
- No explicit synchronization primitives prevent the race

**Factors decreasing likelihood:**
- x86-64 TSO memory model provides stronger ordering (but not guaranteed)
- Short time window between flag clear and input store

The vulnerability occurs as a timing-dependent race during normal operation without attacker control.

## Recommendation

Change `Ordering::Relaxed` to establish proper synchronization:

**In `record()` (line 250):**
```rust
self.speculative_failures[txn_idx as usize].store(false, Ordering::Release);
```

**In `read_set()` (line 296):**
```rust
let speculative_failure = self.speculative_failures[txn_idx as usize].load(Ordering::Acquire);
```

This establishes a happens-before relationship ensuring that when a validator observes the cleared flag (false), it also observes the updated inputs stored on line 257.

**Alternative solution:** Add incarnation number validation in `validate()` function to match the check in `module_validation_v2()`, rejecting stale read-sets even if the race occurs.

## Proof of Concept

A complete proof of concept would require a multi-threaded test that:
1. Executes a transaction with multiple incarnations (success → speculative failure → success)
2. Races `record()` calls with concurrent `read_set()` calls
3. Demonstrates observing (stale_input, false) state
4. Shows different validation results based on timing

This is difficult to reproduce reliably due to its timing-dependent nature but can be demonstrated through:
- Memory model simulation tools
- Stress testing on weak memory order architectures (ARM/RISC-V)
- Adding delays between line 250 and 257 to widen the race window

**Notes:**

The vulnerability is architecture and timing dependent. While x86-64's TSO model provides stronger guarantees than required by Rust's `Relaxed` ordering, it does not guarantee prevention. ARM and RISC-V validators are more susceptible. The correct fix uses `Release`/`Acquire` ordering to ensure proper synchronization across all architectures.

### Citations

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L250-250)
```rust
        self.speculative_failures[txn_idx as usize].store(false, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L257-257)
```rust
        self.inputs[txn_idx as usize].store(Some(Arc::new(input)));
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L294-296)
```rust
        let input = self.inputs[txn_idx as usize].load_full()?;
        let speculative_failure =
            self.speculative_failures[txn_idx as usize].load(Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/executor.rs (L499-505)
```rust
        last_input_output.record(
            idx_to_execute,
            read_set,
            execution_result,
            block_gas_limit_type,
            txn.user_txn_bytes_len() as u64,
        )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L745-755)
```rust
        let blockstm_v2_incarnation = read_set.blockstm_v2_incarnation().ok_or_else(|| {
            code_invariant_error(
                "BlockSTMv2 must be enabled in CapturedReads when validating module reads",
            )
        })?;
        if blockstm_v2_incarnation > incarnation_to_validate || is_speculative_failure {
            // No need to validate as a newer incarnation has already been executed
            // and recorded its output, or the incarnation has resulted in a speculative
            // failure, which means there will be a further re-execution.
            return Ok(true);
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L788-794)
```rust
        let (read_set, is_speculative_failure) = last_input_output
            .read_set(idx_to_validate)
            .expect("[BlockSTM]: Prior read-set must be recorded");

        if is_speculative_failure {
            return false;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L808-809)
```rust
        read_set.validate_data_reads(versioned_cache.data(), idx_to_validate)
            && read_set.validate_group_reads(versioned_cache.group_data(), idx_to_validate)
```
