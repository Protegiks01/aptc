# Audit Report

## Title
Unvalidated Author Field in SecretShare Verification Causes Validator Node Crash via Panic

## Summary
A missing validation check in the SecretShare verification path allows a Byzantine validator to crash honest validator nodes by sending messages with author addresses not in the validator set. The vulnerability exploits an unguarded `.expect()` call that panics and terminates the validator process, violating Byzantine fault tolerance guarantees.

## Finding Description

The `SecretShareManager::verification_task()` receives incoming secret share messages from the consensus network and verifies them without validating that the `author` field in the message matches the authenticated `sender`. [1](#0-0) 

The verification task deserializes incoming messages at line 218 and calls `msg.verify()` at line 220, which for `Share` messages delegates to `SecretShare::verify()`. [2](#0-1) 

The `SecretShare::verify()` method calls `config.get_id(self.author())` at line 76 without any prior validation that the author exists in the validator set. [3](#0-2) 

The `get_id()` implementation contains an unguarded `.expect()` that panics if the author is not found in the validator index. [4](#0-3) 

Notably, there is a TODO comment at line 78 explicitly acknowledging the missing bounds check: `// TODO(ibalajiarun): Check index out of bounds`. [5](#0-4) 

The `IncomingSecretShareRequest` struct contains a `sender` field that identifies the authenticated peer, but this field is marked `#[allow(unused)]` at line 157 and is never validated against the message's author field. [6](#0-5) 

In contrast, the reliable broadcast aggregation path **does** perform this validation explicitly at line 45, ensuring `share.author() == &peer` before calling `share.verify()`. [7](#0-6) 

When the panic occurs in the spawned verification task, it triggers the global panic handler which calls `process::exit(12)` at line 57. [8](#0-7) 

The panic only bypasses process termination if it occurs in Move verifier/deserializer contexts (lines 52-54), which is not the case for consensus message verification.

## Impact Explanation

This vulnerability constitutes **HIGH severity** under the Aptos Bug Bounty criteria as "API Crashes" / validator node crashes:

1. **Complete Node Termination**: The validator process exits entirely via `process::exit(12)`, not just a thread or task crash
2. **Byzantine Fault Tolerance Violation**: A single Byzantine validator can crash honest validators, violating the < 1/3 Byzantine fault tolerance assumption that consensus protocols rely on
3. **Coordinated Attack Potential**: An attacker could simultaneously crash multiple validators by sending malformed messages to each, potentially causing network-wide liveness failure if enough validators (>1/3) are affected
4. **No Recovery Mechanism**: Crashed nodes remain vulnerable after restart with no rate limiting or defensive measures

The code inconsistency—validation present in the reliable broadcast path but missing in the verification task path—combined with the explicit TODO comment, confirms this is a genuine security bug rather than intentional design. Byzantine validators should not be able to crash honest validators with a single malformed message.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Simple Exploitation**: Requires only crafting a single `SecretShare` message with an author field set to an address not in the validator set—no cryptographic capabilities or complex state manipulation needed
2. **Wide Attack Surface**: All validators participating in secret sharing are vulnerable when they receive such messages
3. **No Defensive Measures**: No bounds checking before the panic, no rate limiting on message processing, and no recovery mechanism
4. **Code Evidence of Bug**: The TODO comment and inconsistent validation patterns clearly indicate this is an unintentional vulnerability

While the attacker must be a validator (or compromise one) to send consensus messages, this is within the Byzantine fault tolerance threat model where we assume < 1/3 validators can be malicious. However, malicious validators should not be able to crash honest validators with a single message—this breaks fundamental consensus safety requirements.

## Recommendation

Add validation that the message author matches the authenticated sender before calling `verify()`:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender; // Use the sender field
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        // Validate author matches sender before verify
                        if let SecretShareMessage::Share(ref share) = msg {
                            if share.author() != &sender {
                                warn!("Author does not match sender");
                                return;
                            }
                        }
                        if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Additionally, implement bounds checking in `get_id()` to return a Result instead of panicking, and remove the `#[allow(unused)]` attribute from the `sender` field.

## Proof of Concept

```rust
#[test]
fn test_invalid_author_crash() {
    use aptos_types::secret_sharing::{SecretShare, SecretShareMetadata, SecretShareConfig};
    use aptos_consensus_types::common::Author;
    
    // Setup: Create a SecretShareConfig with a validator set
    let config = create_test_secret_share_config();
    
    // Attack: Create a SecretShare with an author NOT in the validator set
    let invalid_author = Author::from_hex_literal("0xDEADBEEF").unwrap();
    let metadata = SecretShareMetadata::new(1, 1, 0, HashValue::zero(), test_digest());
    let malicious_share = SecretShare::new(
        invalid_author,
        metadata,
        create_dummy_key_share(),
    );
    
    // This will panic with "Peer should be in the index!"
    // In production, this terminates the validator process via process::exit(12)
    let result = std::panic::catch_unwind(|| {
        malicious_share.verify(&config)
    });
    
    assert!(result.is_err(), "Should panic on invalid author");
}
```

The test demonstrates that calling `verify()` with an author not in the validator set causes a panic that would terminate a validator node in production.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/network.rs (L154-161)
```rust
#[derive(Debug)]
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-52)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
