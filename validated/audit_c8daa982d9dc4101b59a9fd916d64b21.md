# Audit Report

## Title
Cross-Epoch Quorum Certificate Acceptance in TwoChainTimeout Verification Allows Consensus State Corruption

## Summary
The `TwoChainTimeout::verify()` function fails to validate that the embedded quorum certificate's epoch matches the timeout's epoch, allowing cross-epoch QCs to be accepted during timeout aggregation. This can cause epoch boundary confusion in consensus round comparisons and safety rule evaluations.

## Finding Description

The `TwoChainTimeout` structure contains both an `epoch` field and an embedded `quorum_cert` field that certifies a `BlockInfo` which also contains its own `epoch` field. [1](#0-0) [2](#0-1) 

However, the `TwoChainTimeout::verify()` function only validates that the QC's round is less than the timeout's round and verifies the QC's signatures, but does NOT check that the QC's epoch matches the timeout's epoch. [3](#0-2) 

The `QuorumCert::verify()` function also does not verify the epoch of the certified block, only checking signature validity and internal consistency. [4](#0-3) 

**Attack Scenario:**
When there is validator set overlap between epochs (common in practice with 70-90% overlap), a Byzantine validator can create a `TwoChainTimeout` with:
- `epoch: N` (current epoch)
- `round: R` (current round in epoch N)
- `quorum_cert: <QC from epoch N-1>` (certified block from previous epoch)

Since validators typically use the same cryptographic keys across epochs, the QC's signatures from epoch N-1 will successfully verify against epoch N's validator set due to the overlap. The timeout passes verification at the message level because the epoch filter only checks the timeout's `epoch` field, not the embedded QC's epoch. [5](#0-4) 

When the timeout is processed and aggregated into a `TwoChainTimeoutCertificate`, the TC's embedded QC references a block from epoch N-1 while operating in epoch N. The `SyncInfo::verify()` function checks that `tc.epoch()` matches the HQC's epoch, but this only validates the TC's epoch field, not the epoch of the QC embedded within the TC. [6](#0-5) 

The critical issue manifests in safety rule evaluations where the TC's `highest_hqc_round()` is used for round comparisons. This method returns the round from the embedded QC, which comes from a different epoch context. [7](#0-6) 

Since rounds are per-epoch (each epoch starts from round 0 or 1), comparing round numbers across epochs creates nonsensical comparisons. For example, if epoch N-1 reached round 100 but epoch N is at round 10, the safety rule check `qc_round >= hqc_round` would incorrectly require epoch N blocks to have round >= 100, which is impossible.

## Impact Explanation

**High to Critical Severity - Consensus Confusion and Safety Rule Violations**

This vulnerability qualifies as High to Critical severity because:

1. **Safety Rule Bypass**: The `safe_to_vote()` function compares rounds from different epochs, potentially causing validators to make incorrect voting decisions. This could lead to different validators voting on incompatible blocks, violating consensus safety properties.

2. **Liveness Degradation**: Validators may be unable to vote on valid blocks when the cross-epoch round comparison prevents them from satisfying safety rules, causing rounds to timeout unnecessarily.

3. **Consensus State Confusion**: Validators operate with inconsistent views of the "highest certified round" when mixing rounds from different epochs, potentially causing divergent consensus states.

4. **Silent Propagation**: Once a cross-epoch QC is aggregated into a TC and broadcast, all receiving validators accept it due to the missing validation, propagating the corrupted state network-wide without detection.

5. **Epoch Boundary Vulnerability**: The attack surface is maximized during epoch transitions when validators naturally have both old and new epoch state in memory.

## Likelihood Explanation

**High Likelihood**

This vulnerability is highly likely to be exploitable because:

1. **Validator Set Overlap**: Production blockchains typically maintain 70-90% validator overlap between epochs to ensure continuity. This makes cross-epoch signature verification highly likely to succeed.

2. **Same Keys Across Epochs**: Validators use the same cryptographic keys across epoch transitions, meaning signatures from epoch N-1 will verify against epoch N's validator set.

3. **No Detection Mechanism**: The missing epoch check means honest validators accept these timeouts without any error or warning, making the attack completely silent.

4. **Single Byzantine Validator**: Only one Byzantine validator (well under the 1/3 threshold) is needed to create and broadcast the malformed timeout. Honest validators will accept and aggregate it.

5. **Natural Occurrence Window**: During epoch transitions, validators naturally have QCs from the previous epoch in memory. Even a validator with network delays or stale state could inadvertently trigger this condition.

6. **No Additional Prerequisites**: The attack requires no special network conditions, specific block states, or coordinated timing beyond waiting for an epoch transition.

## Recommendation

Add explicit epoch validation in `TwoChainTimeout::verify()` to ensure the embedded quorum certificate's epoch matches the timeout's epoch:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    ensure!(
        self.hqc_round() < self.round(),
        "Timeout round should be larger than the QC round"
    );
    // Add epoch validation
    ensure!(
        self.epoch == self.quorum_cert.certified_block().epoch(),
        "Timeout epoch {} must match embedded QC's epoch {}",
        self.epoch,
        self.quorum_cert.certified_block().epoch()
    );
    self.quorum_cert.verify(validators)?;
    Ok(())
}
```

Additionally, consider adding a similar check in `TwoChainTimeoutCertificate::verify()` as defense-in-depth.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a `TwoChainTimeout` with epoch N and a `QuorumCert` certifying a block from epoch N-1
2. Calling `verify()` with a `ValidatorVerifier` for epoch N
3. Observing that verification succeeds when there is validator overlap
4. Aggregating this into a `TwoChainTimeoutCertificate` and observing it passes all validation
5. Using this TC in safety rule evaluations and observing incorrect round comparisons

The test would need to be added to `consensus/consensus-types/src/timeout_2chain.rs` test module, creating validators that overlap between epochs and demonstrating that a cross-epoch timeout incorrectly passes verification.

**Notes**

This vulnerability exploits the missing epoch consistency check between a timeout's epoch field and its embedded quorum certificate's certified block epoch. While the `SyncInfo` validates epoch consistency across multiple certificates, it only checks the TC's epoch field value, not the epoch of the block certified by the QC embedded within the TC. The safety rules then use this embedded QC's round for comparisons, mixing round numbers from different epoch contexts and potentially causing consensus safety violations or liveness failures.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L24-32)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TwoChainTimeout {
    /// Epoch number corresponds to the set of validators that are active for this round.
    epoch: u64,
    /// The consensus protocol executes proposals (blocks) in rounds, which monotonically increase per epoch.
    round: Round,
    /// The highest quorum cert the signer has seen.
    quorum_cert: QuorumCert,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L74-81)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.hqc_round() < self.round(),
            "Timeout round should be larger than the QC round"
        );
        self.quorum_cert.verify(validators)?;
        Ok(())
    }
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/src/epoch_manager.rs (L1645-1647)
```rust
                let event: UnverifiedEvent = msg.into();
                if event.epoch()? == self.epoch() {
                    return Ok(Some(event));
```

**File:** consensus/consensus-types/src/sync_info.rs (L138-150)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
