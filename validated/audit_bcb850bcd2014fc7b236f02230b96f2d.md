# Audit Report

## Title
DKG Sigma Protocol Verification Panic Enables Validator Denial-of-Service via Malformed Proof Type

## Summary
The sigma protocol verification logic in the DKG subsystem panics when encountering Challenge-type proofs instead of gracefully rejecting them. A malicious validator can exploit this by crafting a DKG transcript containing a Challenge-type proof and broadcasting it to other validators, causing them to crash during transcript verification.

## Finding Description

The `prove_homomorphism()` function accepts a `store_prover_commitment` boolean parameter that determines whether the proof stores a Commitment (tag=0) or Challenge (tag=1) as the first proof item. [1](#0-0) 

While legitimate code paths always use `store_prover_commitment = true`, the serialization format accepts both types during deserialization: [2](#0-1) 

However, the verification logic only handles Commitment-type proofs and **panics** on Challenge-type proofs: [3](#0-2) 

The same panic occurs in PairingTupleHomomorphism verification: [4](#0-3) 

**Attack Path:**

1. A malicious validator constructs a DKG transcript with a SharingProof containing a Challenge-type proof (manually setting tag=1 during serialization)
2. The malicious validator broadcasts this transcript to other validators via DKG network messages
3. When validators receive the transcript in `TranscriptAggregationState::add()`, authentication checks pass (sender is a valid validator): [5](#0-4) 

4. Verification is triggered on the main transcript: [6](#0-5) 

5. This calls verification on the SharingProof's SoK: [7](#0-6) 

6. The verification logic extracts the first proof item and panics on Challenge type, crashing the validator node

## Impact Explanation

**High Severity** - This vulnerability enables a Denial-of-Service attack against validator nodes during Distributed Key Generation:

- **Validator node crashes**: The panic is unhandled and causes the validator process to terminate
- **DKG protocol disruption**: Repeated attacks can prevent successful DKG completion, blocking randomness generation for the epoch
- **Affects critical protocol**: DKG is essential for on-chain randomness in Aptos
- **Byzantine fault tolerance violation**: A single malicious validator (< 1/3) can crash other validators

Per the Aptos bug bounty program, this qualifies as **High severity** under "Validator Node Slowdowns (High): DoS through resource exhaustion" and "API Crashes (High): REST API crashes affecting network participation."

## Likelihood Explanation

**Medium-High Likelihood**:

- **Requires validator access**: The attacker must be a validator in the active validator set, which provides some barrier to entry
- **Easy to exploit once inside**: Attacker only needs to flip a single byte (tag from 0 to 1) in a serialized proof
- **Reliable crash**: The panic is deterministic and will crash any validator that attempts verification
- **Low detection risk**: The malformed transcript appears syntactically valid until verification
- **BFT assumption**: The Byzantine Fault Tolerance model assumes up to 1/3 of validators can be malicious, making this a realistic threat scenario

The attack requires validator privileges but can be executed by any single malicious validator without coordination.

## Recommendation

Replace the panic with proper error handling to gracefully reject Challenge-type proofs:

```rust
let prover_first_message = match &proof.first_proof_item {
    FirstProofItem::Commitment(A) => A,
    FirstProofItem::Challenge(_) => {
        return Err(anyhow::anyhow!(
            "Challenge-type proofs are not supported in this verification context"
        ));
    },
};
```

Apply this fix in both locations:
- `crates/aptos-dkg/src/sigma_protocol/traits.rs` (line 115-117)
- `crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs` (line 339-341)

Additionally, consider documenting why Challenge-type proofs exist in the serialization format if they are not currently supported in verification paths.

## Proof of Concept

A malicious validator can craft a malformed DKG transcript by:

1. Creating a valid DKG transcript using the standard `deal()` method
2. Serializing the transcript to bytes
3. Locating the `FirstProofItem` tag byte in the SharingProof's SoK
4. Changing the tag from `0x00` (Commitment) to `0x01` (Challenge)
5. Broadcasting the modified transcript through the DKG network

When other validators receive and attempt to verify this transcript, they will panic at the verification stage, causing process termination.

**Notes**

The vulnerability is confirmed to exist in the current codebase. All legitimate code paths use `store_prover_commitment = true` and create Commitment-type proofs, as verified by searching for usage patterns. The Challenge variant appears to be planned for future batch verification support but is not yet implemented in verification logic. The panic indicates incomplete implementation rather than intentional design, making this a valid security issue that should be addressed with proper error handling.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L113-118)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L308-340)
```rust
impl<F: PrimeField, H: homomorphism::Trait> CanonicalDeserialize for FirstProofItem<F, H>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement + CanonicalDeserialize + Valid,
{
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: Validate,
    ) -> Result<Self, SerializationError> {
        // Read the discriminant tag
        let tag = u8::deserialize_with_mode(&mut reader, compress, validate)?;

        let item = match tag {
            0 => {
                let c = H::Codomain::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Commitment(c)
            },
            1 => {
                let f = F::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Challenge(f)
            },
            _ => return Err(SerializationError::InvalidData),
        };

        // Run validity check if requested
        if validate == Validate::Yes {
            item.check()?;
        }

        Ok(item)
    }
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L467-510)
```rust
pub fn prove_homomorphism<Ct: Serialize, F: PrimeField, H: homomorphism::Trait, R>(
    homomorphism: &H,
    witness: &H::Domain,
    statement: &H::Codomain,
    cntxt: &Ct,
    store_prover_commitment: bool, // true = store prover's commitment, false = store Fiat-Shamir challenge
    rng: &mut R,
    dst: &[u8],
) -> Proof<F, H>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement,
    R: RngCore + CryptoRng,
{
    // Step 1: Sample randomness. Here the `witness` is only used to make sure that `r` has the right dimensions
    let r = witness.rand(rng);

    // Step 2: Compute commitment A = Î¨(r)
    let A = homomorphism.apply(&r);

    // Step 3: Obtain Fiat-Shamir challenge
    let c = fiat_shamir_challenge_for_sigma_protocol::<_, F, H>(
        cntxt,
        homomorphism,
        statement,
        &A,
        dst,
    );

    // Step 4: Compute prover response
    let z = r.scaled_add(&witness, c);

    // Step 5: Pick first **recorded** item
    let first_proof_item = if store_prover_commitment {
        FirstProofItem::Commitment(A)
    } else {
        FirstProofItem::Challenge(c)
    };

    Proof {
        first_proof_item,
        z,
    }
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L337-342)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** dkg/src/transcript_aggregation/mod.rs (L79-86)
```rust
        let peer_power = self.epoch_state.verifier.get_voting_power(&sender);
        ensure!(
            peer_power.is_some(),
            "[DKG] adding peer transcript failed with illegal dealer"
        );
        ensure!(
            metadata.author == sender,
            "[DKG] adding peer transcript failed with node author mismatch"
```

**File:** dkg/src/transcript_aggregation/mod.rs (L99-101)
```rust
        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
