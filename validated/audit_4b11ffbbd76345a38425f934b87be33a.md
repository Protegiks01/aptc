# Audit Report

## Title
ElGamal Encryption to Identity Public Key Exposes Plaintexts in Veiled Coin Transactions

## Summary
The Ristretto255 ElGamal encryption implementation in the Aptos stdlib lacks validation that public keys are not the identity element. This allows registration of veiled coin accounts with the identity element (32 zero bytes) as the public key, causing all incoming transfers to leak plaintext amounts directly in the ciphertext, breaking confidentiality guarantees of veiled transactions.

## Finding Description

The ElGamal public key creation function accepts the identity element without validation: [1](#0-0) 

This function only validates that the bytes represent a canonical Ristretto255 point, delegating to: [2](#0-1) 

The native implementation performs canonical point validation but does NOT reject the identity element: [3](#0-2) 

The veiled coin registration accepts any valid Ristretto255 point without identity validation: [4](#0-3) [5](#0-4) 

According to the ElGamal encryption specification, a ciphertext encrypting value `v` under public key `Y` is computed as `(v*G + r*Y, r*G)`: [6](#0-5) 

When `Y` is the identity element, `r*Y = identity`, reducing the ciphertext to `(v*G, r*G)`, which directly exposes `v*G` and enables plaintext recovery through discrete log attacks on small values.

The sigma protocol verification validates algebraic relationships but does not check if public keys are the identity element: [7](#0-6) 

When `recipient_pk = identity`, the verification equation `ρ * bar_C + X3 = α1 * G + α2 * recipient_pk` reduces to `ρ * bar_C + X3 = α1 * G`, which the prover can satisfy by constructing appropriate proof values.

**Attack Path:**
1. Attacker calls `veiled_coin::register<CoinType>` with `pk = x"0000...0000"` (32 zero bytes representing identity)
2. Registration succeeds, storing identity element as the encryption public key
3. Victim performs `fully_veiled_transfer` to attacker's address
4. The deposit ciphertext encrypts amount `v` as `(v*G, r*G)` instead of `(v*G + r*Y, r*G)`
5. The point `v*G` is directly observable on-chain, revealing the transferred amount
6. Zero-knowledge proofs verify successfully as they only validate algebraic consistency

## Impact Explanation

**Severity: Medium**

This constitutes a significant cryptographic correctness violation in the Aptos stdlib. While the currently affected `veiled_coin` module is marked experimental and explicitly warned as unsafe, the underlying vulnerability exists in the production stdlib module `ristretto255_elgamal`, which is NOT marked experimental: [8](#0-7) 

The stdlib cryptographic primitives are reusable APIs. Any future production use of these ElGamal primitives for confidential transactions, voting systems, or privacy-preserving protocols would inherit this vulnerability.

This breaks the fundamental security property of ElGamal encryption: semantic security under chosen-plaintext attacks (IND-CPA). When the public key is the identity element, encryption degenerates to plaintext exposure.

Other Aptos cryptographic modules (Ed25519, BLS12-381) properly implement identity/small-order validation checks, indicating this is an oversight rather than intentional design.

The current impact is limited because only experimental code uses these primitives. However, the flaw in reusable stdlib components represents a latent risk for any future confidential transaction implementations.

## Likelihood Explanation

**Current Likelihood: Low** (only experimental code affected)

**Future Likelihood: High** (if primitives used in production)

**Technical Feasibility**: Trivial - attacker registers with `pk = x"0000000000000000000000000000000000000000000000000000000000000000"`

**Barrier to Entry**: None - any user can call the public `register` entry function with arbitrary bytes

**Detection Difficulty**: Low - the attack leaves no obvious traces; ciphertexts appear syntactically valid and pass all cryptographic proof verifications

Once these ElGamal primitives are incorporated into production confidential transaction systems, the attack becomes immediately exploitable with no special privileges or advanced cryptographic knowledge required.

## Recommendation

Add identity element validation to the ElGamal public key creation:

```move
public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
    let point = ristretto255::new_compressed_point_from_bytes(bytes);
    if (point.is_some()) {
        let pk_point = ristretto255::point_decompress(&point.borrow());
        let identity = ristretto255::point_identity();
        
        // Reject identity element
        if (ristretto255::point_equals(&pk_point, &identity)) {
            return std::option::none<CompressedPubkey>()
        };
        
        let pk = CompressedPubkey {
            point: point.extract()
        };
        std::option::some(pk)
    } else {
        std::option::none<CompressedPubkey>()
    }
}
```

Additionally, consider adding a proof-of-knowledge requirement during veiled coin registration to ensure users actually possess the secret key corresponding to their public key, as suggested by the TODO comment: [9](#0-8) 

## Proof of Concept

```move
#[test_only]
module test_identity_attack {
    use aptos_std::ristretto255_elgamal as elgamal;
    use aptos_std::ristretto255;
    
    #[test]
    fun test_identity_element_accepted() {
        // Identity element: 32 zero bytes
        let identity_bytes = x"0000000000000000000000000000000000000000000000000000000000000000";
        
        // This should fail but currently succeeds
        let pk_opt = elgamal::new_pubkey_from_bytes(identity_bytes);
        assert!(pk_opt.is_some(), 0); // VULNERABILITY: identity accepted
        
        let pk = pk_opt.extract();
        let pk_point = elgamal::pubkey_to_point(&pk);
        let identity = ristretto255::point_identity();
        
        // Verify it's actually the identity element
        assert!(ristretto255::point_equals(&pk_point, &identity), 1);
    }
    
    #[test]
    fun test_encryption_to_identity_leaks_plaintext() {
        let identity_bytes = x"0000000000000000000000000000000000000000000000000000000000000000";
        let pk = elgamal::new_pubkey_from_bytes(identity_bytes).extract();
        
        let value = ristretto255::new_scalar_from_u32(42);
        let randomness = ristretto255::new_scalar_from_u32(123);
        
        // Encrypt to identity public key
        let ct = elgamal::new_ciphertext_with_basepoint(&value, &randomness, &pk);
        
        // Extract ciphertext components
        let (left, right) = elgamal::ciphertext_as_points(&ct);
        
        // Left component should be v*G (plaintext leaked!)
        let expected_left = ristretto255::basepoint_mul(&value);
        assert!(ristretto255::point_equals(left, &expected_left), 2);
        
        // Right component is r*G
        let expected_right = ristretto255::basepoint_mul(&randomness);
        assert!(ristretto255::point_equals(right, &expected_right), 3);
        
        // VULNERABILITY: Plaintext value directly exposed in ciphertext
    }
}
```

**Notes:**

This vulnerability demonstrates a cryptographic correctness flaw in the Aptos stdlib's ElGamal implementation. The identity element is the Ristretto255 point represented by 32 zero bytes, which is a valid canonical point that passes all current validation checks. The comparison to Ed25519 and BLS12-381 validation (which properly reject identity/small-order points) confirms this is an oversight in the Ristretto255 ElGamal module design.

### Citations

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L1-9)
```text
/// This module implements an ElGamal encryption API, over the Ristretto255 curve, that can be used with the
/// Bulletproofs module.
///
/// An ElGamal *ciphertext* is an encryption of a value `v` under a basepoint `G` and public key `Y = sk * G`, where `sk`
/// is the corresponding secret key, is `(v * G + r * Y, r * G)`, for a random scalar `r`.
///
/// Note that we place the value `v` "in the exponent" of `G` so that ciphertexts are additively homomorphic: i.e., so
/// that `Enc_Y(v, r) + Enc_Y(v', r') = Enc_Y(v + v', r + r')` where `v, v'` are plaintext messages, `Y` is a public key and `r, r'`
/// are the randomness of the ciphertexts.
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L11-11)
```text
module aptos_std::ristretto255_elgamal {
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L42-52)
```text
    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
        let point = ristretto255::new_compressed_point_from_bytes(bytes);
        if (point.is_some()) {
            let pk = CompressedPubkey {
                point: point.extract()
            };
            std::option::some(pk)
        } else {
            std::option::none<CompressedPubkey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move (L160-168)
```text
    public fun new_compressed_point_from_bytes(bytes: vector<u8>): Option<CompressedRistretto> {
        if (point_is_canonical_internal(bytes)) {
            std::option::some(CompressedRistretto {
                data: bytes
            })
        } else {
            std::option::none<CompressedRistretto>()
        }
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L210-223)
```rust
pub(crate) fn native_point_is_canonical(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(ty_args.len(), 0);
    safely_assert_eq!(args.len(), 1);

    let bytes = safely_pop_arg!(args, Vec<u8>);

    let opt_point = decompress_maybe_non_canonical_point_bytes(context, bytes)?;

    Ok(smallvec![Value::bool(opt_point.is_some())])
}
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L268-271)
```text
    public entry fun register<CoinType>(user: &signer, pk: vector<u8>) {
        let pk = elgamal::new_pubkey_from_bytes(pk);
        register_internal<CoinType>(user, pk.extract());
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L521-521)
```text
    /// TODO: Do we want to require a PoK of the SK here?
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L522-540)
```text
    public fun register_internal<CoinType>(
        user: &signer, pk: elgamal::CompressedPubkey
    ) {
        let account_addr = signer::address_of(user);
        assert!(
            !has_veiled_coin_store<CoinType>(account_addr),
            error::already_exists(EVEILED_COIN_STORE_ALREADY_PUBLISHED)
        );

        // Note: There is no way to find an ElGamal SK such that the `(0_G, 0_G)` ciphertext below decrypts to a non-zero
        // value. We'd need to have `(r * G, v * G + r * pk) = (0_G, 0_G)`, which implies `r = 0` for any choice of PK/SK.
        // Thus, we must have `v * G = 0_G`, which implies `v = 0`.

        let coin_store = VeiledCoinStore<CoinType> {
            veiled_balance: helpers::get_veiled_balance_zero_ciphertext(),
            pk
        };
        move_to(user, coin_store);
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/sigma_protos.move (L227-235)
```text
        // \rho * \bar{C} + X3 =? \alpha_1 * g + \alpha_2 * \bar{y}
        let big_bar_c_acc = ristretto255::point_mul(bar_big_c, &rho);
        ristretto255::point_add_assign(&mut big_bar_c_acc, &proof.x3);
        let y_bar_alpha2 = ristretto255::point_mul(&recipient_pk_point, &proof.alpha2);
        ristretto255::point_add_assign(&mut y_bar_alpha2, &g_alpha1);
        assert!(
            ristretto255::point_equals(&big_bar_c_acc, &y_bar_alpha2),
            error::invalid_argument(ESIGMA_PROTOCOL_VERIFY_FAILED)
        );
```
