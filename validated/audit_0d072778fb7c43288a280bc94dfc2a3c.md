# Audit Report

## Title
Missing HQC Consistency Validation in TwoChainTimeoutCertificate Verification Enables State Inconsistency Attacks

## Summary
The `SyncInfo::verify()` function in the consensus layer fails to validate that the highest quorum certificate round is consistent with the timeout certificate's embedded HQC round, allowing Byzantine validators to inject semantically inconsistent consensus state into victim nodes, which causes their proposals to be rejected by honest validators and reduces effective validator participation.

## Finding Description

The verification logic in `SyncInfo::verify()` performs epoch consistency checks, round ordering validation, and signature verification, but omits a critical semantic consistency check between the `highest_quorum_cert` and the `highest_2chain_timeout_cert`. [1](#0-0) 

The function validates:
- Epoch consistency across all certificates (HQC, HOC, HCC, TC)
- Round ordering: HQC round ≥ HOC round ≥ HCC round  
- Non-empty block info in certificates
- Cryptographic signatures via `tc.verify(validator)`

**However, it never validates that** `self.highest_quorum_cert.certified_block().round() >= tc.highest_hqc_round()`.

The `TwoChainTimeoutCertificate::verify()` validates internal consistency (ensuring `hqc_round == max(signed_rounds)`) but has no knowledge of the surrounding SyncInfo context. [2](#0-1) 

Notably, this validation DOES exist in `RoundTimeoutMsg::verify()` which checks that the timeout's HQC round is ≤ SyncInfo's highest certified round. [3](#0-2)  This inconsistency creates vulnerable code paths.

**Attack Execution:**

A Byzantine validator crafts a SyncInfo with:
- `highest_quorum_cert` at round 5
- `highest_2chain_timeout_cert` at round 11 with `highest_hqc_round()` = 10

When processed by `BlockStore::add_certs()`: [4](#0-3) 

1. The victim syncs to HQC round 5 via `sync_to_highest_quorum_cert()`
2. The victim then inserts the TC via `insert_2chain_timeout_certificate()` which only validates `tc.round() > cur_tc_round` without checking TC's HQC consistency [5](#0-4) 

The victim now has inconsistent state: HQC at round 5, but a TC claiming the highest QC was at round 10.

When the victim broadcasts proposals, `BlockStore::sync_info()` includes this inconsistent TC. [6](#0-5) 

When honest validators receive the victim's proposal and check voting safety, `SafetyRules::safe_to_vote()` validates `qc_round >= hqc_round`. [7](#0-6)  With QC=5 and TC.HQC=10, this check fails (5 ≥ 10 = false), causing honest validators to **reject the victim's proposals**.

## Impact Explanation

**Medium Severity** - This vulnerability creates state inconsistencies that degrade validator participation, aligning with the "Limited Protocol Violations" category in the Aptos bug bounty program.

The attack creates nodes with divergent internal state where:
1. The victim's HQC references round R1 (e.g., round 5)
2. The victim's TC claims HQC was at round R2 where R2 > R1 (e.g., round 10)
3. The victim lacks blocks for rounds [R1+1, R2]

**Concrete Impact:**
- **Reduced Validator Participation**: Victims cannot successfully propose blocks because honest validators reject their proposals due to safety rule failures
- **Inconsistency Propagation**: The malicious TC spreads to other nodes through SyncInfo broadcast
- **Network Health Degradation**: Multiple affected validators reduce the effective validator set participation

This does NOT break consensus safety—the SafetyRules correctly prevent unsafe votes. However, it creates operational issues requiring intervention through receiving newer consistent SyncInfo or manual state inspection.

## Likelihood Explanation

**Medium Likelihood** - Requires Byzantine validator access but is straightforward to execute.

**Requirements:**
- Attacker must control a validator (within BFT threat model for <1/3 validators)
- Attacker collects legitimate timeout signatures from 2f+1 honest validators (occurs during normal timeout rounds)
- Attacker identifies victim nodes lagging behind (common during network partitions)

**Execution Complexity: Low**
- No cryptographic forgery required (all signatures are legitimate)
- Simple message crafting with valid but semantically inconsistent components
- Triggered passively through normal sync protocols

**Real-world Scenario:**
During network partitions, some validators lag behind. A Byzantine validator can target these lagging nodes with crafted SyncInfo messages containing legitimate TCs paired with older HQCs, causing victims to accept inconsistent state and subsequently fail when attempting to propose.

## Recommendation

Add HQC consistency validation to `SyncInfo::verify()`:

```rust
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing validation code ...
    
    // Add this check before TC signature verification
    if let Some(tc) = &self.highest_2chain_timeout_cert {
        ensure!(
            epoch == tc.epoch(), 
            "Multi epoch in SyncInfo - TC and HQC"
        );
        
        // NEW: Validate TC's HQC is consistent with SyncInfo's HQC
        ensure!(
            self.highest_quorum_cert.certified_block().round() >= tc.highest_hqc_round(),
            "SyncInfo HQC round {} is lower than TC's HQC round {}",
            self.highest_quorum_cert.certified_block().round(),
            tc.highest_hqc_round()
        );
        
        tc.verify(validator)?;
    }
    
    // ... rest of validation ...
}
```

This mirrors the validation already present in `RoundTimeoutMsg::verify()` and ensures semantic consistency across all SyncInfo usages.

## Proof of Concept

The report does not include a runnable PoC. However, the vulnerability can be demonstrated by:

1. Creating a test validator with HQC at round 5
2. Crafting a SyncInfo with legitimate TC at round 11 with HQC=10 (using real signatures from timeout aggregation)
3. Sending this SyncInfo to the victim via ProposalMsg or standalone sync message
4. Observing that `SyncInfo::verify()` passes without the consistency check
5. Verifying the victim stores the inconsistent TC
6. Attempting to have the victim propose, which will fail SafetyRules validation

## Notes

**Critical Context:**
- This validation already exists in `RoundTimeoutMsg::verify()` but is missing from `SyncInfo::verify()`
- ProposalMsg verification explicitly postpones SyncInfo verification (see comment), creating the vulnerable code path
- Automatic recovery is possible when receiving newer consistent SyncInfo, but the issue can persist if the Byzantine validator continues sending inconsistent TCs
- The SafetyRules provide defense-in-depth by rejecting unsafe proposals, preventing consensus safety violations despite the state inconsistency

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L162-166)
```rust
        ensure!(
            self.round_timeout.two_chain_timeout().hqc_round()
                <= self.sync_info.highest_certified_round(),
            "2-chain Timeout hqc should be less or equal than the sync info hqc"
        );
```

**File:** consensus/src/block_storage/sync_manager.rs (L116-173)
```rust
    pub async fn add_certs(
        &self,
        sync_info: &SyncInfo,
        mut retriever: BlockRetriever,
    ) -> anyhow::Result<()> {
        // When the local ordered round is very old than the received sync_info, this function will
        // (1) resets the block store with highest commit cert = sync_info.highest_quorum_cert()
        // (2) insert all the blocks between (inclusive) highest_commit_cert.commit_info().id() to
        // highest_quorum_cert.certified_block().id() into the block store and storage
        // (3) insert the quorum cert for all the above blocks into the block store and storage
        // (4) executes all the blocks that are ordered while inserting the above quorum certs
        self.sync_to_highest_quorum_cert(
            sync_info.highest_quorum_cert().clone(),
            sync_info.highest_commit_cert().clone(),
            &mut retriever,
        )
        .await?;

        self.sync_to_highest_commit_cert(
            sync_info.highest_commit_cert().ledger_info(),
            retriever.network.clone(),
        )
        .await;

        // The insert_ordered_cert(order_cert) function call expects that order_cert.commit_info().id() block
        // is already stored in block_store. So, we first call insert_quorum_cert(highest_quorum_cert).
        // This call will ensure that the highest ceritified block along with all its ancestors are inserted
        // into the block store.
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;

        // Even though we inserted the highest_quorum_cert (and its ancestors) in the above step,
        // we still need to insert ordered cert explicitly. This will send the highest ordered block
        // to execution.
        if self.order_vote_enabled {
            self.insert_ordered_cert(&sync_info.highest_ordered_cert())
                .await?;
        } else {
            // When order votes are disabled, the highest_ordered_cert().certified_block().id() need not be
            // one of the ancestors of highest_quorum_cert.certified_block().id() due to forks. So, we call
            // insert_quorum_cert instead of insert_ordered_cert as in the above case. This will ensure that
            // highest_ordered_cert().certified_block().id() is inserted the block store.
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
        }

        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
        Ok(())
    }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/src/block_storage/block_store.rs (L680-688)
```rust
    fn sync_info(&self) -> SyncInfo {
        SyncInfo::new_decoupled(
            self.highest_quorum_cert().as_ref().clone(),
            self.highest_ordered_cert().as_ref().clone(),
            self.highest_commit_cert().as_ref().clone(),
            self.highest_2chain_timeout_cert()
                .map(|tc| tc.as_ref().clone()),
        )
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
