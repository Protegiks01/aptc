# Audit Report

## Title
Unmetered Computational Cost in DelayedFieldValue Conversions Enables Validator Resource Exhaustion

## Summary
The conversion of `DelayedFieldValue` to Move values during post-execution materialization is not gas-metered, allowing attackers to force validators to perform expensive computation without paying for it. This occurs because materialization happens after the gas fee is finalized, creating an attack vector for validator resource exhaustion.

## Finding Description

The Aptos blockchain uses delayed fields (aggregators v2) to enable parallel transaction execution. During execution, delayed field values are stored as lightweight `DelayedFieldID` identifiers. After execution completes and gas fees are finalized, these identifiers must be converted back to concrete values for storage commitment.

**The Critical Flaw**: This conversion occurs in the post-execution materialization phase, completely outside the gas-metered execution context.

The code explicitly acknowledges this issue: [1](#0-0) 

The system imposes only a hardcoded limit of 10 delayed fields per resource with no gas charges for conversion computation.

**Attack Vector**:

1. During transaction execution, an attacker creates multiple resources containing delayed field values, particularly `Derived` types with large byte arrays (up to 1024 bytes maximum as defined in the framework). [2](#0-1) 

2. These values are stored as `DelayedFieldID` during execution while gas is being metered.

3. After execution completes and gas fees are finalized: [3](#0-2) 

4. The system calls materialization functions in a post-commit phase: [4](#0-3) 

5. These functions trigger conversions that perform expensive operations without gas metering: [5](#0-4) 

6. For `Derived` types, the conversion performs computationally expensive operations: [6](#0-5) 

7. This calls `bytes_and_width_to_derived_string_struct` which allocates vectors, performs BCS size calculations, creates padding vectors, and packs struct values: [7](#0-6) 

**Why This Breaks Security Invariants**:

The conversion operations happen in `replace_identifiers_with_values`: [8](#0-7) 

This function performs deserialization-serialization round trips WITHOUT any gas metering. An attacker can create a transaction that:
- Uses most/all of its gas budget during normal execution
- Creates N resources (limited by the 8192 write operations per transaction)
- Each resource contains up to 10 `Derived` delayed fields of 1024 bytes each
- Forces validators to perform `10 × N` expensive conversions post-execution
- Each conversion involves ~1KB of vector allocations + BCS calculations + struct packing

## Impact Explanation

This is a **High severity** vulnerability under the Aptos bug bounty program:

**High Severity criteria met**: "Validator node slowdowns" - Attackers can force validators to perform significant unmetered computation during block execution, causing slowdowns.

The computational impact per transaction:
- Maximum 8192 write operations containing resources with delayed fields
- Each resource: up to 10 delayed fields × 1024 bytes = ~10KB processing per resource
- Worst case: 81,920 conversion operations per transaction
- Each conversion involves non-trivial computation (vector allocations, BCS calculations, struct operations)

An attacker can amplify the attack by:
- Submitting many such transactions per block
- Validators must materialize all delayed fields for all transactions
- The computational cost accumulates across all transactions in a block
- Only the transaction gas and storage fees are charged, not the materialization cost

The impact is bounded but still significant:
- Maximum 10 delayed fields per resource (hardcoded limit)
- Maximum 1024 bytes per derived string (protocol limit)
- Maximum 8192 write operations per transaction (gas schedule limit)
- However, these limits still allow substantial unmetered computation

## Likelihood Explanation

**High likelihood** - This vulnerability is easily exploitable:

1. **No special privileges required**: Any user can submit transactions with delayed field values
2. **Direct API access**: Native functions like `create_snapshot` and `derive_string_concat` are publicly accessible through the `aggregator_v2` module
3. **Predictable behavior**: The conversion always happens post-execution for any transaction using delayed fields
4. **Low cost to attacker**: Only pays for transaction gas and storage, not conversion computation
5. **Acknowledged issue**: The TODO comment explicitly confirms this is a known limitation awaiting proper implementation: "until proper charges are implemented"

The attack can be executed by any user through normal transaction submission using publicly available aggregator_v2 APIs.

## Recommendation

Implement proper gas charges for delayed field conversions during materialization. The recommended approach:

1. **Extend Gas Metering to Post-Execution Phase**: Create a post-execution gas accounting mechanism that charges for materialization operations based on:
   - Number of delayed fields being converted
   - Size of each delayed field value
   - Computational complexity of BCS operations

2. **Charge During Execution**: Alternatively, charge gas during execution based on estimated materialization costs when delayed fields are created

3. **Implement in Gas Schedule**: Add materialization cost parameters to the gas schedule:
   ```rust
   // In gas schedule
   pub delayed_field_materialization: GasExpression,
   pub per_byte_materialization_cost: GasExpression,
   ```

4. **Deduct from Transaction Gas Budget**: Ensure materialization costs are included in the transaction's overall gas budget calculation before finalization

The TODO comment should be resolved by implementing proper gas charges as indicated.

## Proof of Concept

```move
module attacker::exploit {
    use aptos_framework::aggregator_v2;
    use std::string;
    
    // Resource with maximum allowed delayed fields
    struct ExploitResource has key {
        field1: aggregator_v2::DerivedStringSnapshot,
        field2: aggregator_v2::DerivedStringSnapshot,
        field3: aggregator_v2::DerivedStringSnapshot,
        field4: aggregator_v2::DerivedStringSnapshot,
        field5: aggregator_v2::DerivedStringSnapshot,
        field6: aggregator_v2::DerivedStringSnapshot,
        field7: aggregator_v2::DerivedStringSnapshot,
        field8: aggregator_v2::DerivedStringSnapshot,
        field9: aggregator_v2::DerivedStringSnapshot,
        field10: aggregator_v2::DerivedStringSnapshot,
    }
    
    public entry fun exploit_unmetered_conversion(account: &signer) {
        // Create large derived string (1024 bytes - maximum allowed)
        let large_string = string::utf8(b"A..."); // 1024 'A' characters
        
        // Create snapshot from the large string (done during execution, metered)
        let snapshot = aggregator_v2::create_derived_string(large_string);
        
        // Create resource with 10 delayed fields (maximum allowed)
        // Storage gas is charged, but conversion computation is NOT
        move_to(account, ExploitResource {
            field1: snapshot,
            field2: snapshot,
            field3: snapshot,
            field4: snapshot,
            field5: snapshot,
            field6: snapshot,
            field7: snapshot,
            field8: snapshot,
            field9: snapshot,
            field10: snapshot,
        });
        
        // After this transaction completes:
        // - Attacker paid for execution gas and storage
        // - Validators must perform 10 expensive conversions during materialization
        // - Each conversion: BCS calculations + vector allocations + struct packing
        // - Total: ~10KB of processing per resource, completely unmetered
        
        // Attacker can create many such resources (limited by write op limit)
        // or submit many such transactions to amplify the attack
    }
}
```

The proof of concept demonstrates how an attacker can force validators to perform unmetered computation by creating resources with maximum delayed fields, each containing large derived strings. The materialization cost is not charged to the transaction despite the computational burden on validators.

### Citations

**File:** third_party/move/move-vm/types/src/value_serde.rs (L50-54)
```rust
    // Temporarily limit the number of delayed fields per resource, until proper charges are
    // implemented.
    // TODO[agg_v2](clean):
    //   Propagate up, so this value is controlled by the gas schedule version.
    const MAX_DELAYED_FIELDS_PER_RESOURCE: usize = 10;
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L53-54)
```rust
/// If we want to increase this, we need to modify BITS_FOR_SIZE in types/src/delayed_fields.rs.
pub const DERIVED_STRING_INPUT_MAX_LENGTH: usize = 1024;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1098-1098)
```rust
        // ============= Gas fee cannot change after this line =============
```

**File:** aptos-move/block-executor/src/executor.rs (L1131-1137)
```rust
    fn materialize_txn_commit(
        &self,
        txn_idx: TxnIndex,
        scheduler: SchedulerWrapper,
        environment: &AptosEnvironment,
        shared_sync_params: &SharedSyncParams<T, E, S>,
    ) -> Result<(), PanicError> {
```

**File:** aptos-move/block-executor/src/executor.rs (L1209-1210)
```rust
        let materialized_resource_write_set =
            map_id_to_values_in_write_set(resource_writes_to_materialize, &latest_view)?;
```

**File:** aptos-move/aptos-aggregator/src/types.rs (L138-173)
```rust
    pub fn try_into_move_value(
        self,
        layout: &MoveTypeLayout,
        width: u32,
    ) -> Result<Value, PartialVMError> {
        use DelayedFieldValue::*;
        use MoveTypeLayout::*;

        Ok(match (self, layout) {
            (Aggregator(v) | Snapshot(v), U64) => {
                if width != 8 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 8 for U64, got {}", width)));
                }
                Value::u64(v as u64)
            },
            (Aggregator(v) | Snapshot(v), U128) => {
                if width != 16 {
                    return Err(PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
                        .with_message(format!("Expected width 16 for U128, got {}", width)));
                }
                Value::u128(v)
            },
            (Derived(bytes), layout) if is_derived_string_struct_layout(layout) => {
                bytes_and_width_to_derived_string_struct(bytes, width as usize)?
            },
            (value, layout) => {
                return Err(
                    PartialVMError::new(StatusCode::VM_EXTENSION_ERROR).with_message(format!(
                        "Failed to convert {:?} into Move value with {} layout",
                        value, layout
                    )),
                )
            },
        })
    }
```

**File:** third_party/move/move-vm/types/src/delayed_values/derived_string_snapshot.rs (L72-100)
```rust
pub fn bytes_and_width_to_derived_string_struct(
    bytes: Vec<u8>,
    width: usize,
) -> PartialVMResult<Value> {
    // We need to create DerivedStringSnapshot struct that serializes to exactly match given `width`.

    let value_width = bcs_size_of_byte_array(bytes.len());
    // padding field takes at list 1 byte (empty vector)
    if value_width + 1 > width {
        return Err(code_invariant_error(format!(
            "DerivedStringSnapshot size issue: no space left for padding: value_width: {value_width}, width: {width}"
        )));
    }

    // We assume/assert that padding never exceeds length that requires more than 1 byte for size:
    // (otherwise it complicates the logic to fill until the exact width, as padding can never be serialized into 129 bytes
    // (vec[0; 127] serializes into 128 bytes, and vec[0; 128] serializes into 130 bytes))
    let padding_len = width - value_width - 1;
    if size_u32_as_uleb128(padding_len) > 1 {
        return Err(code_invariant_error(format!(
            "DerivedStringSnapshot size issue: padding expected to be too large: value_width: {value_width}, width: {width}, padding_len: {padding_len}"
        )));
    }

    Ok(Value::struct_(Struct::pack(vec![
        bytes_to_string(bytes),
        Value::vector_u8(vec![0; padding_len]),
    ])))
}
```

**File:** aptos-move/block-executor/src/view.rs (L1269-1335)
```rust
    pub(crate) fn replace_identifiers_with_values(
        &self,
        bytes: &Bytes,
        layout: &MoveTypeLayout,
    ) -> anyhow::Result<(Bytes, HashSet<DelayedFieldID>)> {
        // Cfg due to deserialize_to_delayed_field_id use.
        #[cfg(test)]
        fail_point!("delayed_field_test", |_| {
            assert_eq!(
                layout,
                &mock_layout(),
                "Layout does not match expected mock layout"
            );

            // Replicate the logic of identifier_to_value.
            let (delayed_field_id, txn_idx) = deserialize_to_delayed_field_id(bytes)
                .expect("Mock deserialization failed in delayed field test.");
            let delayed_field = match &self.latest_view {
                ViewState::Sync(state) => state
                    .versioned_map
                    .delayed_fields()
                    .read_latest_predicted_value(
                        &delayed_field_id,
                        self.txn_idx,
                        ReadPosition::AfterCurrentTxn,
                    )
                    .expect("Committed value for ID must always exist"),
                ViewState::Unsync(state) => state
                    .read_delayed_field(delayed_field_id)
                    .expect("Delayed field value for ID must always exist in sequential execution"),
            };

            // Note: Test correctness relies on the fact that current proptests use the
            // same layout for all values ever stored at any key, given that some value
            // at the key contains a delayed field.
            Ok((
                serialize_from_delayed_field_u128(
                    delayed_field.into_aggregator_value().unwrap(),
                    txn_idx,
                ),
                HashSet::from([delayed_field_id]),
            ))
        });

        // This call will replace all occurrences of aggregator / snapshot
        // identifiers with values with the same type layout.
        let function_value_extension = self.as_function_value_extension();
        let value = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(&function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
            .ok_or_else(|| {
                anyhow::anyhow!(
                    "Failed to deserialize resource during id replacement: {:?}",
                    bytes
                )
            })?;

        let mapping = TemporaryValueToIdentifierMapping::new(self, self.txn_idx);
        let patched_bytes = ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_delayed_fields_replacement(&mapping)
            .with_func_args_deserialization(&function_value_extension)
            .serialize(&value, layout)?
            .ok_or_else(|| anyhow::anyhow!("Failed to serialize resource during id replacement"))?
            .into();
        Ok((patched_bytes, mapping.into_inner()))
    }
```
