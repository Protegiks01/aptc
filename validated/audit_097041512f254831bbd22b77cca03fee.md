# Audit Report

## Title
Storage Fee Bypass for Orderless Transaction Nonce Insertions on Failed Transactions

## Summary
When orderless transactions fail during execution, nonces inserted into the global `NonceHistory` table during prologue validation are persisted to blockchain state without charging storage fees, enabling attackers to bloat state at zero cost.

## Finding Description

This vulnerability exploits a critical discrepancy in how storage fees are charged for failed orderless transactions versus failed sequence-number-based transactions in the Aptos VM.

**Vulnerability Chain:**

The `ReplayProtector` enum has two variants: `Nonce(u64)` for orderless transactions and `SequenceNumber(u64)` for regular transactions. [1](#0-0) 

During prologue validation, orderless transactions call `check_for_replay_protection_orderless_txn` which invokes `nonce_validation::check_and_insert_nonce` to insert nonces into the NonceHistory table. [2](#0-1) 

The `check_and_insert_nonce` function performs state modifications by inserting the nonce into two BigOrderedMaps within the NonceHistory resource. [3](#0-2) 

The prologue executes with an `UnmeteredGasMeter`, so no gas is charged during this phase. [4](#0-3) 

When `gas_feature_version >= 1`, prologue state changes are captured in a `SystemSessionChangeSet` and a new `UserSession` is spawned with these changes as the base state. [5](#0-4) 

**The Critical Bug:**

When a transaction fails during execution, `failed_transaction_cleanup` is invoked with the `prologue_session_change_set`. [6](#0-5) 

Inside `finish_aborted_transaction`, the code checks `should_create_account_resource` to determine the cleanup path. [7](#0-6) 

The `should_create_account_resource` function returns `true` ONLY when the replay protector is exactly `ReplayProtector::SequenceNumber(0)`. For orderless transactions using `Nonce`, this check returns `false`. [8](#0-7) 

When `should_create_account_resource` returns `false`, the else branch is taken which does NOT call `charge_change_set`. Instead, it simply creates a fee statement from the gas meter and returns the `prologue_session_change_set` unchanged. [9](#0-8) 

In contrast, when `should_create_account_resource` returns `true`, the code creates an `AbortHookSession` with the prologue changes and explicitly calls `charge_change_set` to charge storage fees. [10](#0-9) 

The `charge_change_set` function processes storage fees by calling `process_storage_fee_for_all` which iterates through write operations and charges appropriate fees. [11](#0-10) 

The uncharged prologue changes are then passed to the `EpilogueSession` and included in the final `VMOutput`. [12](#0-11)  The epilogue session squashes these changes into the final output without any additional charging. [13](#0-12) 

**Attack Scenario:**
1. Attacker creates an account (one-time cost)
2. Submits orderless transactions with unique nonces designed to fail (e.g., entry function that aborts immediately)
3. Prologue inserts nonce into NonceHistory (state modification)
4. Transaction fails during user session execution
5. Since replay_protector is `Nonce`, `should_create_account_resource` returns `false`
6. `charge_change_set` is never called on prologue changes
7. Nonce insertion is committed to state without storage fee
8. Attacker repeats with new nonces, bloating state for free

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability violates the fundamental blockchain security invariant that "All operations must respect gas, storage, and computational limits" by allowing state modifications without corresponding storage fees.

**Concrete Impacts:**

1. **State Bloat Attack**: Attackers can insert unlimited nonces into the global `NonceHistory` table at zero storage cost, consuming blockchain storage resources without payment. While nonces expire, the garbage collection is rate-limited to 5 entries per call, allowing sustained bloat.

2. **Limited Funds Loss**: The network loses storage fees that should be collected for each nonce insertion. This represents "Limited funds loss or manipulation" under the Medium severity criteria, as the loss per transaction is bounded but can accumulate through repeated exploitation.

3. **State Inconsistencies**: Unmetered state growth creates inconsistencies between expected and actual storage costs, requiring potential manual intervention to address bloated state.

This does NOT constitute Critical severity because:
- It does not enable direct fund theft from users
- It does not cause consensus violations or network partition
- It does not freeze funds or halt the network
- The impact is bounded to the NonceHistory table and nonces eventually expire

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is readily exploitable under these conditions:

1. **Feature Flag**: Orderless transactions must be enabled (governance-controlled feature flag)
2. **Account Existence**: Attacker must have an existing account (trivial to create)
3. **Transaction Failure**: Transaction must fail during execution, not prologue (attacker fully controls)
4. **Gas Feature Version**: Must be >= 1 (standard in production)

**Exploitation Analysis:**
- Any user can create an account with minimal cost
- Attacker controls transaction logic and can craft transactions that fail predictably (e.g., call `abort()`)
- Once orderless transactions are enabled via governance, exploitation requires no special privileges
- Attack cost is minimal: only execution gas for prologue, user session abort, and epilogue
- Attack can be fully automated and repeated indefinitely with different nonces
- No race conditions or timing requirements

The primary gating factor is whether orderless transactions are enabled. Once enabled, this becomes a high-likelihood vulnerability.

## Recommendation

**Fix: Always charge storage fees for prologue changes in failed transactions**

Modify `finish_aborted_transaction` to ensure `charge_change_set` is called on prologue changes regardless of whether account creation is needed:

```rust
let (previous_session_change_set, fee_statement) = if should_create_account_resource {
    // Existing account creation logic with charge_change_set
    ...
} else {
    // NEW: Charge storage fees for prologue changes even when no account creation
    let mut prologue_change_set_to_charge = prologue_session_change_set.clone();
    if let Err(err) = self.charge_change_set(
        &mut prologue_change_set_to_charge,
        gas_meter,
        txn_data,
        resolver,
        module_storage,
    ) {
        info!(*log_context, "Failed to charge prologue storage fees: {:?}", err);
    }
    
    let fee_statement = AptosVM::fee_statement_from_gas_meter(
        txn_data, 
        gas_meter, 
        ZERO_STORAGE_REFUND
    );
    (prologue_session_change_set, fee_statement)
};
```

This ensures that nonce insertions and any other prologue state modifications are properly charged storage fees, maintaining the invariant that all state modifications must be paid for.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating an orderless transaction with a unique nonce
2. Ensuring the transaction payload aborts during execution
3. Observing that the nonce is inserted into NonceHistory without storage fees being charged
4. Monitoring gas meter state to confirm storage fees are not deducted

A complete PoC would require:
- Enabling orderless transaction feature flag
- Submitting a transaction with `ReplayProtector::Nonce(unique_value)`
- Transaction payload that calls `abort()`
- Verification that storage fees in the fee statement do not include the nonce insertion cost
- Confirmation that the nonce exists in NonceHistory after transaction failure

The exploit is deterministic and reproducible on any Aptos network with orderless transactions enabled.

### Citations

**File:** types/src/transaction/mod.rs (L113-116)
```rust
pub enum ReplayProtector {
    Nonce(u64),
    SequenceNumber(u64),
}
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L252-263)
```text
    fun check_for_replay_protection_orderless_txn(
        sender: address,
        nonce: u64,
        txn_expiration_time: u64,
    ) {
        // prologue_common already checks that the current_time > txn_expiration_time
        assert!(
            txn_expiration_time <= timestamp::now_seconds() + MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE),
        );
        assert!(nonce_validation::check_and_insert_nonce(sender, nonce, txn_expiration_time), error::invalid_argument(PROLOGUE_ENONCE_ALREADY_USED));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L195-203)
```text
        // Insert the (address, nonce) pair in the bucket.
        let nonce_key_with_exp_time = NonceKeyWithExpTime {
            txn_expiration_time,
            sender_address,
            nonce,
        };
        bucket.nonces_ordered_by_exp_time.add(nonce_key_with_exp_time, true);
        bucket.nonce_to_exp_time_map.add(nonce_key, txn_expiration_time);
        true
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L123-123)
```rust
    let mut gas_meter = UnmeteredGasMeter;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L59-80)
```rust
        if vm.gas_feature_version() >= 1 {
            // Create a new session so that the data cache is flushed.
            // This is to ensure we correctly charge for loading certain resources, even if they
            // have been previously cached in the prologue.
            //
            // TODO(Gas): Do this in a better way in the future, perhaps without forcing the data cache to be flushed.
            // By releasing resource group cache, we start with a fresh slate for resource group
            // cost accounting.

            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

            resolver.release_resource_group_cache();
            Ok((
                prologue_session_change_set,
                UserSession::new(vm, txn_meta, resolver, change_set),
            ))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L611-613)
```rust
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-706)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L741-754)
```rust
            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L787-791)
```rust
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L793-797)
```rust
        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1128-1134)
```rust
        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3457-3460)
```rust
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L115-126)
```rust
        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, true)?;
        let epilogue_session_change_set =
            UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)?;

        let (change_set, module_write_set) = epilogue_session_change_set.unpack();
        Ok(VMOutput::new(
            change_set,
            module_write_set,
            fee_statement,
            TransactionStatus::Keep(execution_status),
        ))
```
