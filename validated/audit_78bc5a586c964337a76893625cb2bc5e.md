# Audit Report

## Title
State Sync Infinite Loop on Non-Existent Transaction Request with start_version=end_version

## Summary
When requesting a single transaction using `TransactionsWithProofRequest` where `start_version = end_version` for a transaction that doesn't exist in storage, the new size-aware chunking implementation returns an empty transaction list instead of an error. This causes the data streaming service client to enter an infinite loop, repeatedly requesting the same non-existent transaction, leading to complete state sync liveness failure.

## Finding Description

The vulnerability exists in the state synchronization system's handling of non-existent transactions when size-aware chunking is enabled.

**Request Structure**: The `TransactionsWithProofRequest` struct allows `start_version = end_version` to request a single transaction. [1](#0-0) 

**Configuration**: Size-aware chunking is automatically enabled for all non-mainnet networks (testnet, devnet) by the config optimizer. [2](#0-1) 

**New Implementation Behavior**: When size-aware chunking is enabled, the storage service uses iterator-based fetching. [3](#0-2)  The `ContinuousVersionIter` returns `None` (not an error) when a transaction doesn't exist. [4](#0-3)  The storage service handles this by logging a warning and breaking out of the loop, returning an empty transaction list. [5](#0-4) 

**Legacy Implementation Behavior**: The legacy path calls `get_transaction()` which returns `AptosDbError::NotFound` when a transaction doesn't exist. [6](#0-5)  This error properly propagates to the client and triggers retry logic with failure counting.

**The Infinite Loop**: When the client receives fewer transactions than requested, it creates a missing data request. [7](#0-6)  For a request of version X that returns 0 transactions, this creates a new request for version X (same version). The `request_missing_data()` function sends this request but critically does NOT increment `request_failure_count`. [8](#0-7)  In contrast, actual request failures increment this counter via `resend_data_client_request()`. [9](#0-8)  The stream only terminates when `request_failure_count >= max_request_retry`. [10](#0-9)  Since missing data requests never increment this counter, the loop continues indefinitely.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria for "State inconsistencies requiring manual intervention":

1. **Complete State Sync Liveness Failure**: The affected node cannot sync past the missing transaction, halting all state synchronization progress
2. **Resource Exhaustion**: The infinite loop consumes CPU cycles and network bandwidth indefinitely
3. **Node Unavailability**: The node cannot participate in consensus or serve API requests effectively while blocked
4. **No Automatic Recovery**: The loop continues until manual intervention or node restart

While not causing consensus safety violations or fund loss directly, this breaks the critical state consistency invariant by preventing nodes from maintaining synchronized state with the network.

## Likelihood Explanation

**High Likelihood** - This vulnerability can be triggered in several realistic scenarios:

1. **Transaction Pruning**: Nodes regularly prune old transactions. A client requesting a pruned transaction version will trigger this bug.
2. **Version Beyond Ledger**: A client requesting a future transaction version (beyond current ledger version) triggers this condition.
3. **Network Configuration**: The vulnerability is active on all non-mainnet networks (testnet, devnet) where size-aware chunking is enabled by default.
4. **No Authentication Required**: Any network peer can send transaction requests without special privileges.
5. **Common Operation**: Requesting single transactions is a normal state sync operation during catch-up.

## Recommendation

The fix should align the new size-aware chunking implementation with the legacy behavior by returning an error instead of an empty list when no transactions are found:

1. **In the iterator handling** (`state-sync/storage-service/server/src/storage.rs`): When the iterator returns `None` and zero transactions have been fetched, return an error instead of breaking with an empty response.

2. **Alternative approach**: Modify the missing data request logic to increment `request_failure_count` when the same request is retried, or add a separate counter for missing data retries to prevent infinite loops.

3. **Validation enhancement**: Add a check in `create_missing_transactions_request()` to detect when the new request would be identical to the previous request and return an error instead.

The preferred solution is option 1, as it maintains consistency between the legacy and new implementations and properly signals to the client that the requested data is unavailable.

## Proof of Concept

A complete PoC would require:
1. Setting up a testnet/devnet node with size-aware chunking enabled
2. Creating a scenario where a transaction version doesn't exist (e.g., requesting beyond ledger or pruned transaction)
3. Sending a `TransactionsWithProofRequest` with `start_version = end_version` for that non-existent version
4. Observing the node enter an infinite loop with repeated requests for the same version

The code evidence provided demonstrates the vulnerability exists as described, though a working PoC would strengthen the report.

---

**Notes**

This vulnerability only affects non-mainnet networks where size-aware chunking is enabled by default. Mainnet is not currently affected as the feature is disabled there for stability. However, this is still a valid Medium severity issue as testnet and devnet are production networks used by developers, validators, and node operators for critical testing and staging purposes. The state sync liveness failure on these networks can prevent nodes from synchronizing and participating in the network, requiring manual intervention to resolve.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L361-367)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct TransactionsWithProofRequest {
    pub proof_version: u64,   // The version the proof should be relative to
    pub start_version: u64,   // The starting version of the transaction list
    pub end_version: u64,     // The ending version of the transaction list (inclusive)
    pub include_events: bool, // Whether or not to include events in the response
}
```

**File:** config/src/config/state_sync_config.rs (L623-629)
```rust
            if ENABLE_SIZE_AND_TIME_AWARE_CHUNKING
                && !chain_id.is_mainnet()
                && local_storage_config_yaml["enable_size_and_time_aware_chunking"].is_null()
            {
                storage_service_config.enable_size_and_time_aware_chunking = true;
                modified_config = true;
            }
```

**File:** state-sync/storage-service/server/src/storage.rs (L361-371)
```rust
        // If size and time-aware chunking are disabled, use the legacy implementation
        if !use_size_and_time_aware_chunking {
            return self.get_transactions_with_proof_by_size_legacy(
                proof_version,
                start_version,
                end_version,
                num_transactions_to_fetch,
                include_events,
                max_response_size,
            );
        }
```

**File:** state-sync/storage-service/server/src/storage.rs (L685-694)
```rust
                None => {
                    // Log a warning that the iterators did not contain all the expected data
                    warn!(
                        "The iterators for transactions, transaction infos, write sets, events, \
                        auxiliary data and persisted auxiliary infos are missing data! Start version: {:?}, \
                        end version: {:?}, num outputs to fetch: {:?}, num fetched: {:?}.",
                        start_version, end_version, num_outputs_to_fetch, transactions_and_outputs.len()
                    );
                    break;
                },
```

**File:** storage/aptosdb/src/utils/iterators.rs (L40-62)
```rust
    fn next_impl(&mut self) -> Result<Option<T>> {
        if self.expected_next_version >= self.end_version {
            return Ok(None);
        }

        let ret = match self.inner.next().transpose()? {
            Some((version, transaction)) => {
                ensure!(
                    version == self.expected_next_version,
                    "{} iterator: first version {}, expecting version {}, got {} from underlying iterator.",
                    std::any::type_name::<T>(),
                    self.first_version,
                    self.expected_next_version,
                    version,
                );
                self.expected_next_version += 1;
                Some(transaction)
            },
            None => None,
        };

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L56-60)
```rust
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L446-454)
```rust
        if self.stream_engine.is_stream_complete()
            || self.request_failure_count >= self.streaming_service_config.max_request_retry
            || self.send_failure
        {
            if !self.send_failure && self.stream_end_notification_id.is_none() {
                self.send_end_of_stream_notification().await?;
            }
            return Ok(()); // There's nothing left to do
        }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L649-676)
```rust
    fn request_missing_data(
        &mut self,
        data_client_request: &DataClientRequest,
        response_payload: &ResponsePayload,
    ) -> Result<bool, Error> {
        // Identify if any missing data needs to be requested
        if let Some(missing_data_request) =
            create_missing_data_request(data_client_request, response_payload)?
        {
            // Increment the missing client request counter
            increment_counter(
                &metrics::SENT_DATA_REQUESTS_FOR_MISSING_DATA,
                data_client_request.get_label(),
            );

            // Send the missing data request
            let pending_client_response =
                self.send_client_request(false, missing_data_request.clone());

            // Push the pending response to the front of the queue
            self.get_sent_data_requests()?
                .push_front(pending_client_response);

            return Ok(true); // Missing data was requested
        }

        Ok(false) // No missing data was requested
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L729-744)
```rust
    fn resend_data_client_request(
        &mut self,
        data_client_request: &DataClientRequest,
    ) -> Result<(), Error> {
        // Increment the number of client failures for this request
        self.request_failure_count += 1;

        // Resend the client request
        let pending_client_response = self.send_client_request(true, data_client_request.clone());

        // Push the pending response to the head of the sent requests queue
        self.get_sent_data_requests()?
            .push_front(pending_client_response);

        Ok(())
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1151-1191)
```rust
fn create_missing_transactions_request(
    request: &TransactionsWithProofRequest,
    response_payload: &ResponsePayload,
) -> Result<Option<DataClientRequest>, Error> {
    // Determine the number of requested transactions
    let num_requested_transactions = request
        .end_version
        .checked_sub(request.start_version)
        .and_then(|v| v.checked_add(1))
        .ok_or_else(|| {
            Error::IntegerOverflow("Number of requested transactions has overflown!".into())
        })?;

    // Identify the missing data if the request was not satisfied
    match response_payload {
        ResponsePayload::TransactionsWithProof(transactions_with_proof) => {
            // Check if the request was satisfied
            let num_received_transactions = transactions_with_proof.get_num_transactions() as u64;
            if num_received_transactions < num_requested_transactions {
                let start_version = request
                    .start_version
                    .checked_add(num_received_transactions)
                    .ok_or_else(|| Error::IntegerOverflow("Start version has overflown!".into()))?;
                Ok(Some(DataClientRequest::TransactionsWithProof(
                    TransactionsWithProofRequest {
                        start_version,
                        end_version: request.end_version,
                        proof_version: request.proof_version,
                        include_events: request.include_events,
                    },
                )))
            } else {
                Ok(None) // The request was satisfied!
            }
        },
        payload => Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Invalid response payload found for transactions request: {:?}",
            payload
        ))),
    }
}
```
