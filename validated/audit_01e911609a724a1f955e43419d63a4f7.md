> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3)

### Citations

**File:** aptos-move/block-executor/src/scheduler_status.rs (L363-405)
```rust
    pub(crate) fn add_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
        let status = &self.statuses[txn_idx as usize];
        if status.num_stalls.fetch_add(1, Ordering::SeqCst) == 0 {
            // Acquire write lock for (non-monitor) shortcut modifications.
            let status_guard = status.status_with_incarnation.lock();

            let dependency_status =
                DependencyStatus::from_u8(status.dependency_shortcut.load(Ordering::Relaxed))?;

            match (status_guard.pending_scheduling(), dependency_status) {
                (Some(0), DependencyStatus::ShouldDefer) => {
                    // Adding a stall requires being recorded in aborted dependencies in scheduler_v2,
                    // which in turn only happens in the scheduler after a successful abort (that must
                    // increment the incarnation of the status).
                    return Err(code_invariant_error("0-th incarnation in add_stall"));
                },
                (Some(_), DependencyStatus::ShouldDefer) => {
                    self.execution_queue_manager.remove_from_schedule(txn_idx);
                    // Shortcut not affected.
                },
                (Some(_), DependencyStatus::IsSafe | DependencyStatus::WaitForExecution) => {
                    return Err(code_invariant_error(
                        "Inconsistent status and dependency shortcut in add_stall",
                    ));
                },
                (None, DependencyStatus::IsSafe) => {
                    // May not update IsSafe dependency status at an incorrect time in the future
                    // (i.e. ABA), as observing num_stalls = 0 under status is required to set
                    // IsSafe status, but impossible until the corresponding remove_stall (that
                    // starts only after add_stall finishes).
                    status
                        .dependency_shortcut
                        .store(DependencyStatus::ShouldDefer as u8, Ordering::Relaxed);
                },
                (None, DependencyStatus::WaitForExecution | DependencyStatus::ShouldDefer) => {
                    // Executing or aborted: shortcut not affected.
                },
            }

            return Ok(true);
        }
        Ok(false)
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L417-461)
```rust
    pub(crate) fn remove_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
        let status = &self.statuses[txn_idx as usize];
        let prev_num_stalls = status.num_stalls.fetch_sub(1, Ordering::SeqCst);

        if prev_num_stalls == 0 {
            return Err(code_invariant_error(
                "remove_stall called when num_stalls == 0",
            ));
        }

        if prev_num_stalls == 1 {
            // Acquire write lock for (non-monitor) shortcut modifications.
            let status_guard = status.status_with_incarnation.lock();

            // num_stalls updates are not under the lock, so need to re-check (otherwise
            // a different add_stall might have already incremented the count).
            if status.is_stalled() {
                return Ok(false);
            }

            if let Some(incarnation) = status_guard.pending_scheduling() {
                if incarnation == 0 {
                    // Invariant due to scheduler logic: for a successful remove_stall there
                    // must have been an add_stall for incarnation 0, which is impossible.
                    return Err(code_invariant_error("0-th incarnation in remove_stall"));
                }
                self.execution_queue_manager
                    .add_to_schedule(incarnation == 1, txn_idx);
            } else if status_guard.is_executed() {
                // TODO(BlockSMTv2): Here, when waiting is supported, if inner status is executed,
                // would need to notify waiting workers.

                // Status is Executed so the dependency status may not be WaitForExecution
                // (finish_execution sets ShouldDefer or IsSafe dependency status).
                status.swap_dependency_status_any(
                    &[DependencyStatus::ShouldDefer, DependencyStatus::IsSafe],
                    DependencyStatus::IsSafe,
                    "remove_stall",
                )?;
            }

            return Ok(true);
        }
        Ok(false)
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L527-626)
```rust
    /// # Returns
    /// - `Ok(true)` if this call successfully marked the incarnation for abort
    /// - `Ok(false)` if the incarnation was already marked for abort
    /// - `Err` if the provided incarnation is invalid (greater than the current value)
    pub(crate) fn start_abort(
        &self,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
    ) -> Result<bool, PanicError> {
        let prev_value = self.statuses[txn_idx as usize]
            .next_incarnation_to_abort
            .fetch_max(incarnation + 1, Ordering::Relaxed);
        match incarnation.cmp(&prev_value) {
            cmp::Ordering::Less => Ok(false),
            cmp::Ordering::Equal => {
                // Increment the counter and clear speculative logs (from the aborted execution).
                counters::SPECULATIVE_ABORT_COUNT.inc();
                clear_speculative_txn_logs(txn_idx as usize);

                Ok(true)
            },
            cmp::Ordering::Greater => Err(code_invariant_error(format!(
                "Try abort incarnation {} > self.next_incarnation_to_abort = {}",
                incarnation, prev_value,
            ))),
        }
    }

    /// Marks a transaction's execution as completed.
    ///
    /// Called when a transaction finishes executing, whether successfully or after being aborted.
    /// Updates the transaction's status based on its current state:
    /// - If Executing → Executed (successful execution)
    /// - If Aborted → PendingScheduling with incremented incarnation (ready for re-execution)
    ///
    /// # Parameters
    /// - `finished_incarnation`: The incarnation that has finished execution
    ///
    /// # Returns
    /// - 'Ok(Some(deferred module validation requirements))' if the execution is still valid at
    ///   the time finish was recorded (empty vec if no requirements), in particular:
    ///     - `Ok(Some(vec of requirements))` if transitioned from Executing to Executed
    ///     - `Ok(None)` if transitioned from Aborted to PendingScheduling.
    /// - `Err` if the current state doesn't allow finishing execution.
    pub(crate) fn finish_execution(
        &self,
        txn_idx: TxnIndex,
        finished_incarnation: Incarnation,
    ) -> Result<Option<BTreeSet<ModuleId>>, PanicError> {
        // TODO(BlockSMTv2): Handle waiting workers when supported (defer waking up).

        let status = &self.statuses[txn_idx as usize];
        let status_guard = &mut *status.status_with_incarnation.lock();

        // An incarnation of a transaction can only increase when both finish_execution and
        // start_abort take effect for the prior incarnation. However, finish_execution is
        // invoked once per incarnation, and thus incarnations must always match.
        if status_guard.incarnation() != finished_incarnation {
            return Err(code_invariant_error(format!(
                "Finish execution of incarnation {}, but inner status {:?}",
                finished_incarnation, status_guard,
            )));
        }

        match status_guard.status {
            SchedulingStatus::Executing(_) => {
                let requirements = if let SchedulingStatus::Executing(requirements) =
                    std::mem::replace(&mut status_guard.status, SchedulingStatus::Executed)
                {
                    requirements
                } else {
                    unreachable!("In Executing variant match arm");
                };

                let new_status_flag = if status.is_stalled() {
                    DependencyStatus::ShouldDefer
                } else {
                    DependencyStatus::IsSafe
                };
                status.swap_dependency_status_any(
                    &[DependencyStatus::WaitForExecution],
                    new_status_flag,
                    "finish_execution",
                )?;

                Ok(Some(requirements))
            },
            SchedulingStatus::Aborted => {
                self.to_pending_scheduling(txn_idx, status_guard, finished_incarnation + 1, true);
                Ok(None)
            },
            SchedulingStatus::PendingScheduling | SchedulingStatus::Executed => {
                Err(code_invariant_error(format!(
                    "Status update to Executed failed, previous inner status {:?}",
                    status_guard
                )))
            },
        }
    }

```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L913-963)
```rust
impl ExecutionStatus {
    pub(crate) fn new() -> Self {
        Self {
            status_with_incarnation: CachePadded::new(Mutex::new(StatusWithIncarnation::new())),
            next_incarnation_to_abort: CachePadded::new(AtomicU32::new(0)),
            dependency_shortcut: CachePadded::new(AtomicU8::new(
                DependencyStatus::ShouldDefer as u8,
            )),
            num_stalls: CachePadded::new(AtomicU32::new(0)),
        }
    }

    /// Performs an atomic swap operation on the dependency status and checks
    /// that the previous value matches one of the expected values.
    /// Note that in our implementation, all updates to the status are performed
    /// while holding the lock on InnerStatus, which is the responsibility
    /// of the caller.
    ///
    /// # Parameters
    /// - `expected_values`: Array of possible expected current status flags
    /// - `new_value`: The new status flag to set
    /// - `context`: A string describing the context for error messages
    ///
    /// # Returns
    /// - `Ok(prev)` if the swap was successful, returning the previous value
    /// - `Err(PanicError)` if the previous value didn't match any expected value
    fn swap_dependency_status_any(
        &self,
        expected_values: &[DependencyStatus],
        new_value: DependencyStatus,
        context: &'static str,
    ) -> Result<DependencyStatus, PanicError> {
        let prev = DependencyStatus::from_u8(
            self.dependency_shortcut
                .swap(new_value as u8, Ordering::Relaxed),
        )?;
        // Note: can avoid a lookup by optimizing expected values representation.
        if !expected_values.contains(&prev) {
            return Err(code_invariant_error(format!(
                "Incorrect dependency status in {}: expected one of {:?}, found {:?}",
                context, expected_values, prev,
            )));
        }
        Ok(prev)
    }

    pub(crate) fn is_stalled(&self) -> bool {
        self.num_stalls.load(Ordering::Relaxed) > 0
    }
}

```
