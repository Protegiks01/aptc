# Audit Report

## Title
Non-Deterministic JSON Serialization in UnsupportedJWK Causes JWK Consensus Failures

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization via `to_string()`, which produces different byte representations when OIDC providers return JSON with varying key orderings. This causes validators to compute different hashes for the same JWK, preventing JWK updates from reaching consensus as the observation aggregation layer rejects mismatched views.

## Finding Description
When validators independently fetch JWKs from OIDC providers through the JWK consensus protocol, non-RSA keys are converted to `UnsupportedJWK` structures using non-canonical JSON serialization. [1](#0-0) 

The implementation uses `json_value.to_string().into_bytes()` which preserves the original JSON key ordering from the HTTP response. The TODO comment explicitly acknowledges this is non-canonical and violates Aptos secure coding guidelines. [2](#0-1) 

These guidelines explicitly state that deterministic data structures are required "for achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes."

The JWK conversion flow processes JSON responses from OIDC providers: [3](#0-2) 

Non-RSA keys fall back to `UnsupportedJWK`: [4](#0-3) 

The `UnsupportedJWK` instances are embedded in `ProviderJWKs` structures that are cryptographically hashed: [5](#0-4) 

**Critical Consensus Failure Mechanism**: When validators receive different JSON key orderings and create different `ProviderJWKs`, the observation aggregation layer performs an equality check: [6](#0-5) 

This check rejects peer observations that don't match `local_view`, preventing signature aggregation and consensus achievement. Without 2f+1 validators agreeing on identical `ProviderJWKs` content, the multi-signature verification fails: [7](#0-6) 

**Attack Path:**
1. OIDC provider serves non-RSA JWKs (EC keys with kty="EC") or malformed RSA keys
2. Provider's HTTP server returns JSON with HashMap-based non-deterministic key ordering
3. Validator A fetches JWK at time T1, receives: `{"kty":"EC","kid":"key1","crv":"P-256"}`
4. Validator B fetches JWK at time T2, receives: `{"kid":"key1","kty":"EC","crv":"P-256"}`
5. Both create `UnsupportedJWK` with different payload bytes (different key ordering preserved)
6. Both compute different SHA3-256 hashes for the `id` field
7. Observation aggregation rejects mismatched views (line 82-84 check fails)
8. Consensus cannot be reached, JWK update rejected

## Impact Explanation
This vulnerability breaks the **Deterministic Execution** invariant for the JWK consensus subsystem documented in Aptos security guidelines.

**Impact Classification: Medium Severity**

The vulnerability causes state inconsistencies requiring manual intervention, matching the Aptos bug bounty Medium severity category:
- JWK updates for affected OIDC providers cannot reach consensus
- Keyless accounts depending on those providers become inaccessible  
- Users cannot authenticate or sign transactions with affected keyless accounts
- Requires manual intervention (provider reconfiguration or code fix) to restore functionality
- Users lose access to funds held in keyless accounts (limited funds loss/manipulation)

This does NOT meet Critical severity because:
- Core blockchain consensus remains unaffected (only JWK subsystem impacted)
- No direct fund theft mechanism
- Network remains operational for non-keyless transactions

This exceeds Low severity because:
- Affects user fund access through keyless accounts
- Requires operational intervention
- Impacts production keyless infrastructure

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability can manifest through natural system behavior without attacker action:

1. **Common Server Behavior**: Many HTTP servers and JSON libraries use HashMap-based serialization with non-deterministic key ordering (Go's `encoding/json`, Python's json library pre-3.7, Node.js older versions)

2. **Legitimate Use Cases**: OIDC providers may use:
   - ES256 algorithm (ECDSA with P-256 curve, kty="EC")
   - Malformed RSA keys that fail parsing
   - Key rotation from RSA to EC keys

3. **No Attack Required**: Natural HTTP server behavior causes different responses across requests

4. **Developer Awareness**: TODO comment indicates known limitation but unfixed

Factors reducing immediate likelihood:
- Most major OIDC providers (Google, Facebook, Microsoft) currently use RSA keys
- Issue only affects non-RSA or malformed keys failing RSA parsing
- Requires HTTP server with non-deterministic JSON ordering

## Recommendation
Implement canonical JSON serialization for `UnsupportedJWK` payload generation. Use a deterministic serialization approach that sorts JSON object keys alphabetically:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Serialize with sorted keys for canonical representation
        let payload = serde_json::to_string(&json_value)
            .expect("JSON value serialization should not fail")
            .into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Alternatively, use a library like `canonical_json` or implement custom serialization that guarantees deterministic key ordering. This ensures all validators compute identical hashes regardless of input JSON key ordering.

## Proof of Concept
A PoC would require:
1. Set up local test network with multiple validators
2. Deploy dummy OIDC provider serving EC keys with non-deterministic JSON key ordering
3. Configure JWK consensus to observe this provider
4. Verify validators create different `UnsupportedJWK` payloads
5. Confirm consensus failure with "mismatched view" errors
6. Check that JWK update never reaches on-chain state

The smoke test infrastructure in `testsuite/smoke-test/src/jwks/` provides the framework, but would need modification to simulate non-deterministic JSON ordering rather than deliberate equivocation.

## Notes
- This vulnerability is a logic flaw in consensus protocol design, not requiring attacker exploitation
- The TODO comment at line 53 confirms developer awareness of the canonical serialization requirement
- The issue violates documented Aptos secure coding guidelines for deterministic data structures
- Impact limited to JWK consensus subsystem; core blockchain consensus unaffected
- Fix requires canonical JSON serialization implementation for `UnsupportedJWK` conversion

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-58)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
```

**File:** RUST_SECURE_CODING.md (L121-132)
```markdown
### Data Structures with Deterministic Internal Order

Certain data structures, like HashMap and HashSet, do not guarantee a deterministic order for the elements stored within them. This lack of order can lead to problems in operations that require processing elements in a consistent sequence across multiple executions. In the Aptos blockchain, deterministic data structures help in achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes.

Below is a list of deterministic data structures available in Rust. Please note, this list may not be exhaustive:

- **BTreeMap:** maintains its elements in sorted order by their keys.
- **BinaryHeap:** It maintains its elements in a heap order, which is a complete binary tree where each parent node is less than or equal to its child nodes.
- **Vec**: It maintains its elements in the order in which they were inserted. ⚠️
- **LinkedList:** It maintains its elements in the order in which they were inserted. ⚠️
- **VecDeque:** It maintains its elements in the order in which they were inserted. ⚠️

```

**File:** crates/jwk-utils/src/lib.rs (L34-36)
```rust
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L140-142)
```rust
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```
