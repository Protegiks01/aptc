# Audit Report

## Title
Resource Exhaustion in Fast Sync Mode: Dual Database Instances Cause Memory and File Descriptor Depletion Leading to Node Crashes

## Summary
The `FastSyncStorageWrapper::initialize_dbs()` function creates two complete AptosDB instances with identical resource configurations during fast sync bootstrap. This causes critical resource duplication (48GB RAM for block caches, tens of thousands of file descriptors, 12 background threads) that can exhaust node resources and trigger crashes. The secondary database is never cleaned up after fast sync completes, causing permanent resource leakage that persists for the node's entire lifetime.

## Finding Description

When a fresh node starts with fast sync enabled, the system creates two complete AptosDB instances during bootstrap:

**Primary Database Creation:**
The first database (`db_main`) is opened with full resource allocation. [1](#0-0) 

**Secondary Database Creation:**
When fast sync is enabled and the database is empty, a second complete database (`secondary_db`) is created with identical resource configurations in the `fast_sync_secondary` subdirectory. [2](#0-1) 

**Resource Duplication:**
Each `AptosDB::open()` call creates separate resource allocations including a dedicated RocksDB environment and block cache. [3](#0-2) 

The default block cache size is 24GB per instance. [4](#0-3) 

Each database instance creates multiple RocksDB instances (LedgerDb, StateKvDb, StateMerkleDb with potential hot state variants). [5](#0-4) 

With default configurations, each RocksDB instance uses 5,000 max open files. [6](#0-5) 

**Critical Issue - No Cleanup:**
After fast sync completes and status changes to `FINISHED`, all read and write operations switch to the primary database, but the secondary database Arc reference is never dropped. [7](#0-6) 

The `FastSyncStorageWrapper` is wrapped and stored for the node's entire lifetime with no Drop implementation to clean up the secondary database. [8](#0-7) 

The wrapper is returned from bootstrap and persists throughout node operation. [9](#0-8) 

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty criteria - "Validator Node Slowdowns: DoS through resource exhaustion"

This vulnerability causes:

1. **Memory Exhaustion**: 48GB consumed by block caches alone (24GB Ã— 2), plus additional memory for RocksDB instances, leaving insufficient memory for consensus, networking, and other critical components. On nodes with 60GB RAM limits (common in deployments), this causes severe memory pressure triggering OOM kills.

2. **File Descriptor Exhaustion**: With storage sharding enabled (default), each AptosDB creates 4 RocksDB instances (LedgerDb, StateKvDb, StateMerkleDb hot and cold), each with 5,000 max open files. Two AptosDB instances consume approximately 40,000 file descriptors. While mainnet/testnet nodes set ulimits to 999,999, this significantly reduces available headroom for consensus, networking, and API operations. [10](#0-9) 

3. **Node Crashes During Bootstrap**: Resource exhaustion during the critical fast sync period causes node failures, preventing new validators from joining the network and affecting network availability.

4. **Permanent Resource Leakage**: Resources remain allocated indefinitely even after fast sync completes, degrading node performance for its entire lifetime and increasing operational costs.

5. **Network Decentralization Impact**: Makes it harder to run nodes on standard hardware configurations, reducing network participation and affecting decentralization.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is automatically triggered when:
- A node starts with fast sync enabled (checked via `bootstrapping_mode.is_fast_sync()`)
- The database is empty (synced version equals 0) [11](#0-10) 

This is the **standard bootstrap scenario** for fresh nodes, as fast sync is the recommended mode for new node setup. No malicious input or special conditions are required - it occurs during normal node operation. Every new node joining the network with fast sync enabled experiences this resource duplication.

## Recommendation

Implement automatic cleanup of the secondary database after fast sync completes:

1. **Add Drop Implementation**: Implement the `Drop` trait for `FastSyncStorageWrapper` to explicitly drop the `temporary_db_with_genesis` Arc and remove the secondary database directory when fast sync status is `FINISHED`.

2. **Immediate Cleanup**: After `finalize_state_snapshot()` sets status to `FINISHED`, explicitly drop the secondary database Arc and clean up the `fast_sync_secondary` directory.

3. **Configuration Option**: Alternatively, allow operators to configure the secondary database with reduced resource allocations (smaller block cache, fewer file descriptors) since it only needs to serve genesis data temporarily.

The test cleanup code demonstrates the manual approach but needs to be automated for production: [12](#0-11) 

## Proof of Concept

This vulnerability can be observed by:

1. Starting a fresh node with fast sync enabled and empty database
2. Monitoring resource usage during bootstrap - observe 48GB+ RAM allocation and 40K+ file descriptor usage
3. After fast sync completes (status = FINISHED), observe that secondary database resources remain allocated
4. Check `/proc/<pid>/fd` count and memory usage - secondary database resources persist indefinitely

The vulnerability is evident in the code structure itself: two complete AptosDB instances are created with identical configurations, but only the secondary database cleanup exists in test utilities, not in production code paths.

## Notes

This is a DoS vulnerability through resource exhaustion that affects network availability, not merely a performance optimization issue. The automatic triggering during normal node bootstrap, combined with the permanent resource leakage and potential for node crashes, qualifies this as HIGH severity under Aptos Bug Bounty criteria for "Validator Node Slowdowns" and potential "API Crashes" affecting network participation.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L30-38)
```rust
/// This is a wrapper around [AptosDB] that is used to bootstrap the node for fast sync mode
pub struct FastSyncStorageWrapper {
    // Used for storing genesis data during fast sync
    temporary_db_with_genesis: Arc<AptosDB>,
    // Used for restoring fast sync snapshot and all the read/writes afterwards
    db_for_fast_sync: Arc<AptosDB>,
    // This is for reading the fast_sync status to determine which db to use
    fast_sync_status: Arc<RwLock<FastSyncStatus>>,
}
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L48-59)
```rust
        let mut db_main = AptosDB::open(
            config.storage.get_dir_paths(),
            /*readonly=*/ false,
            config.storage.storage_pruner_config,
            config.storage.rocksdb_configs,
            config.storage.enable_indexer,
            config.storage.buffered_state_target_items,
            config.storage.max_num_nodes_per_lru_cache_shard,
            internal_indexer_db,
            config.storage.hot_state_config,
        )
        .map_err(|err| anyhow!("fast sync DB failed to open {}", err))?;
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L66-90)
```rust
        if config
            .state_sync
            .state_sync_driver
            .bootstrapping_mode
            .is_fast_sync()
            && (db_main
                .ledger_db
                .metadata_db()
                .get_synced_version()?
                .map_or(0, |v| v)
                == 0)
        {
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L126-140)
```rust
    pub(crate) fn get_aptos_db_read_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }

    pub(crate) fn get_aptos_db_write_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_started() || self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L129-136)
```rust
        let mut env =
            Env::new().map_err(|err| AptosDbError::OtherRocksDbError(err.into_string()))?;
        env.set_high_priority_background_threads(rocksdb_configs.high_priority_background_threads);
        env.set_low_priority_background_threads(rocksdb_configs.low_priority_background_threads);
        let block_cache = Cache::new_hyper_clock_cache(
            rocksdb_configs.shared_block_cache_size,
            /* estimated_entry_charge = */ 0,
        );
```

**File:** config/src/config/storage_config.rs (L167-169)
```rust
        Self {
            // Allow db to close old sst files, saving memory.
            max_open_files: 5000,
```

**File:** config/src/config/storage_config.rs (L211-213)
```rust
    /// Default block cache size is 24GB.
    pub const DEFAULT_BLOCK_CACHE_SIZE: usize = 24 * (1 << 30);
}
```

**File:** config/src/config/storage_config.rs (L654-658)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["ensure_rlimit_nofile"].is_null()
            {
                config.ensure_rlimit_nofile = 999_999;
                modified_config = true;
```

**File:** storage/aptosdb/src/db/mod.rs (L114-155)
```rust
    ) -> Result<(LedgerDb, Option<StateMerkleDb>, StateMerkleDb, StateKvDb)> {
        let ledger_db = LedgerDb::new(
            db_paths.ledger_db_root_path(),
            rocksdb_configs,
            env,
            block_cache,
            readonly,
        )?;
        let state_kv_db = StateKvDb::new(
            db_paths,
            rocksdb_configs,
            env,
            block_cache,
            readonly,
            ledger_db.metadata_db_arc(),
        )?;
        let hot_state_merkle_db = if !readonly && rocksdb_configs.enable_storage_sharding {
            Some(StateMerkleDb::new(
                db_paths,
                rocksdb_configs,
                env,
                block_cache,
                readonly,
                max_num_nodes_per_lru_cache_shard,
                /* is_hot = */ true,
                reset_hot_state,
            )?)
        } else {
            None
        };
        let state_merkle_db = StateMerkleDb::new(
            db_paths,
            rocksdb_configs,
            env,
            block_cache,
            readonly,
            max_num_nodes_per_lru_cache_shard,
            /* is_hot = */ false,
            /* delete_on_restart = */ false,
        )?;

        Ok((ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db))
```

**File:** aptos-node/src/storage.rs (L63-78)
```rust
    let (aptos_db_reader, db_rw, backup_service) = match FastSyncStorageWrapper::initialize_dbs(
        node_config,
        internal_indexer_db.clone(),
        update_sender,
    )? {
        Either::Left(db) => {
            let (db_arc, db_rw) = DbReaderWriter::wrap(db);
            let db_backup_service =
                start_backup_service(node_config.storage.backup_service_address, db_arc.clone());
            maybe_apply_genesis(&db_rw, node_config)?;
            (db_arc as Arc<dyn DbReader>, db_rw, Some(db_backup_service))
        },
        Either::Right(fast_sync_db_wrapper) => {
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
            let (db_arc, db_rw) = DbReaderWriter::wrap(fast_sync_db_wrapper);
```

**File:** testsuite/forge/src/backend/local/node.rs (L345-350)
```rust
        // Remove the secondary DB files
        if secondary_db_path.as_path().exists() {
            fs::remove_dir_all(secondary_db_path)
                .map_err(anyhow::Error::from)
                .context("Failed to delete secondary_db_path")?;
        }
```
