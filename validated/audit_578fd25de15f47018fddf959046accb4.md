# Audit Report

## Title
Byzantine Validator Can Prevent Batch Retrieval via Stale LedgerInfo Injection in Quorum Store

## Summary
A Byzantine validator can prevent honest nodes from retrieving available batches by responding with `BatchResponse::NotFound` containing an old but valid `LedgerInfoWithSignatures`. The requester validates only epoch, timestamp, and cryptographic signatures without verifying freshness or requiring consensus from multiple validators, causing immediate request termination and breaking Byzantine fault tolerance guarantees.

## Finding Description
The vulnerability exists in the Quorum Store batch retrieval protocol. When a node requests a batch, it sends requests to multiple validators and processes responses as they arrive using `FuturesUnordered`. [1](#0-0) 

When processing `BatchResponse::NotFound` responses, the validation performs only three checks: epoch match, timestamp exceeds batch expiration, and signature validity. [2](#0-1) 

The code does NOT verify:
- That the ledger info represents the LATEST blockchain state
- The round or version number to ensure freshness
- That multiple validators agree on batch unavailability

When these minimal checks pass, the requester immediately returns an error without waiting for other validators. [3](#0-2) 

**Attack Mechanism:**

The honest implementation retrieves the latest ledger info when a batch is not found. [4](#0-3) 

However, a Byzantine validator can:
1. Store old `LedgerInfoWithSignatures` from earlier in the same epoch (which contain valid signatures from 2f+1 validators)
2. When requested for a batch it possesses, lie by sending `BatchResponse::NotFound(old_ledger_info)`
3. Use an old ledger info where `old_ledger_info.timestamp > batch.expiration`
4. The requester validates the old ledger info and immediately terminates
5. Honest validators' responses are never awaited

**Why This Works:**

Batches are created with a 60-second expiration period. [5](#0-4) 

Batches remain in storage for an additional 60-second buffer after expiration to help slow nodes catch up. [6](#0-5) 

**Attack Timeline:**
1. T1: Batch B created with expiration = T1 + 60s
2. T2 (T1+65s): Ledger info L2 committed with timestamp T2
3. T3 (T1+70s): Current latest ledger info L3 committed
4. T4 (T1+75s): Requester asks for batch B
5. Byzantine validator has batch B (not yet garbage collected) but sends `NotFound(L2)`
6. Requester validates L2 (epoch matches, T2 > T1+60s, signatures valid) and immediately errors
7. Honest validators' responses are discarded

The `BlockInfo` structure contains `round` and `version` fields that monotonically increase, but these are never checked. [7](#0-6) 

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty categories:

**Validator Node Slowdowns (High)**: Affected nodes cannot retrieve batches needed for consensus execution, causing them to fall behind and degrading network performance.

**Significant Protocol Violation**: This breaks Byzantine fault tolerance guarantees. The Aptos consensus protocol is designed to tolerate up to 1/3 Byzantine validators, but this vulnerability allows a single Byzantine validator (< 1/3 threshold) to cause denial of service for batch retrieval. This violates the fundamental BFT assumption that < 1/3 Byzantine actors should not prevent progress.

**Consensus Impact**: When nodes cannot retrieve required batches, they cannot execute blocks, causing them to fall behind in consensus. If multiple nodes are targeted simultaneously, this can cause network-wide slowdowns.

The signature verification confirms cryptographic validity but not temporal freshness. [8](#0-7) 

## Likelihood Explanation
**High Likelihood:**
- Any validator in the active set can execute this attack
- No sophisticated exploit required - simply store and replay old but valid ledger infos
- Attack works during normal operations whenever batch expiration < old_ledger_timestamp < current_ledger_timestamp
- No detection mechanism exists - appears as legitimate NotFound response  
- Single Byzantine validator sufficient (no collusion needed)
- Can target specific nodes or all requesters indiscriminately
- Zero economic cost to attacker beyond normal validator operation

## Recommendation
Implement one or more of the following mitigations:

1. **Freshness Verification**: Check that the `LedgerInfo` round/version is recent by comparing against the requester's known latest state
2. **Quorum Requirement**: Require multiple validators (>f+1) to agree on batch unavailability before short-circuiting
3. **Continue on Expired**: Do not immediately return on expired batch indication; continue waiting for at least f+1 validators to respond
4. **Round/Version Checking**: Compare the `BlockInfo.round` or `BlockInfo.version` in the received `LedgerInfo` against the requester's latest known state

Example fix (add to validation checks):
```rust
// After line 146, add:
&& ledger_info.commit_info().round() >= self.latest_known_round
```

## Proof of Concept
**Note**: While the vulnerability is clearly demonstrated through code analysis above, a complete PoC test should be added that:
1. Sets up a batch requester with multiple mock validators
2. Configures one Byzantine validator to respond with an old but valid `LedgerInfo`
3. Demonstrates that the batch request fails immediately despite honest validators having the batch
4. Shows the test succeeds in `consensus/src/quorum_store/tests/batch_requester_test.rs`

The existing test at `test_batch_request_not_exists_expired` demonstrates the short-circuit behavior but uses the same mock response for all validators. [9](#0-8)  A proper PoC would show divergent behavior between Byzantine and honest validators.

## Notes
This vulnerability is particularly concerning because:
1. The `LedgerInfoWithSignatures` is cryptographically valid (contains real 2f+1 signatures), making it indistinguishable from a legitimate response without checking freshness
2. The attack exploits an optimization (short-circuiting on expired batches) that was designed to improve performance
3. The 60-second garbage collection buffer creates a consistent time window where this attack is viable
4. No logging or metrics would detect this as suspicious behavior since it appears as a normal NotFound response

### Citations

**File:** consensus/src/quorum_store/batch_requester.rs (L119-119)
```rust
            let mut futures = FuturesUnordered::new();
```

**File:** consensus/src/quorum_store/batch_requester.rs (L142-152)
```rust
                            Ok(BatchResponse::NotFound(ledger_info)) => {
                                counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
                                if ledger_info.commit_info().epoch() == epoch
                                    && ledger_info.commit_info().timestamp_usecs() > expiration
                                    && ledger_info.verify_signatures(&validator_verifier).is_ok()
                                {
                                    counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
                                    debug!("QS: batch request expired, digest:{}", digest);
                                    return Err(ExecutorError::CouldNotGetData);
                                }
                            }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L417-418)
```rust
                    match aptos_db_clone.get_latest_ledger_info() {
                        Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
```

**File:** config/src/config/quorum_store_config.rs (L131-131)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
```

**File:** consensus/src/quorum_store/batch_store.rs (L263-263)
```rust
        let gc_timestamp = last_certified_time.saturating_sub(expiration_buffer_usecs);
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/src/quorum_store/tests/batch_requester_test.rs (L235-277)
```rust
async fn test_batch_request_not_exists_expired() {
    let retry_interval_ms = 1_000;
    let expiration = 10_000;

    // Batch has expired according to the ledger info that will be returned
    let (ledger_info_with_signatures, validator_verifier) =
        create_ledger_info_with_timestamp(expiration + 1);

    let batch = Batch::new(
        BatchId::new_for_test(1),
        vec![],
        1,
        expiration,
        AccountAddress::random(),
        0,
    );
    let batch_response = BatchResponse::NotFound(ledger_info_with_signatures);
    let batch_requester = BatchRequester::new(
        1,
        AccountAddress::random(),
        1,
        2,
        retry_interval_ms,
        1_000,
        MockBatchRequester::new(batch_response),
        validator_verifier.into(),
    );

    let request_start = Instant::now();
    let (_, subscriber_rx) = oneshot::channel();
    let result = batch_requester
        .request_batch(
            *batch.digest(),
            batch.expiration(),
            Arc::new(Mutex::new(btreeset![AccountAddress::random()])),
            subscriber_rx,
        )
        .await;
    let request_duration = request_start.elapsed();
    assert_err!(result);
    // No retry because of short-circuiting of expired batch
    assert!(request_duration < Duration::from_millis(retry_interval_ms as u64));
}
```
