# Audit Report

## Title
Peer Role Inference Bypass Allows Unauthenticated Peers to Poison Network Monitoring Data on Validator VFN Networks

## Summary
Validators using MaybeMutual authentication on VFN networks incorrectly trust role information inferred from network context rather than cryptographic authentication. This allows unknown peers to inject poisoned network topology data by claiming to be Validator Full Nodes (VFNs), which affects peer selection decisions in mempool, state sync, and consensus observer components.

## Finding Description

The vulnerability exists through three interconnected components:

**1. VFN Network Authentication Default**

Validators default to `MaybeMutual` authentication on VFN networks because `mutual_authentication` is set based on `network_id.is_validator_network()`, which returns `false` for `NetworkId::Vfn`: [1](#0-0) [2](#0-1) 

This `mutual_authentication = false` configuration maps to `AuthenticationMode::MaybeMutual`: [3](#0-2) 

Which then maps to `HandshakeAuthMode::MaybeMutual`: [4](#0-3) 

**2. Unauthenticated Peer Role Inference**

When an unknown peer connects to a validator on the VFN network under `MaybeMutual` mode, the handshake logic infers their role as `ValidatorFullNode` based solely on network context without cryptographic verification: [5](#0-4) 

Specifically, the inference occurs at lines 407-410 where inbound connections to validators on VFN networks are automatically assigned the VFN role.

**3. Monitoring Service Validation Trusts Inferred Role**

The `NetworkInfoState` validation logic accepts `distance_from_validators = 1` if the peer's role indicates VFN status, which was assigned through unauthenticated inference: [6](#0-5) 

**Attack Execution Path:**

1. Attacker connects to validator's VFN network port
2. Handshake completes with `MaybeMutual` authentication
3. Role is inferred as `PeerRole::ValidatorFullNode` without cryptographic verification
4. Validator sends `GetNetworkInformation` request to attacker
5. Attacker's monitoring service responds with `distance_from_validators = 1`
6. Validation passes because `role.is_vfn()` returns true (from inferred role)
7. Poisoned data is stored in validator's peer metadata

**Impact on Critical Systems:**

The poisoned `distance_from_validators` metric is subsequently used in peer selection decisions across multiple critical systems:

- **Mempool transaction forwarding prioritization:** [7](#0-6) [8](#0-7) 

- **State sync peer selection:** [9](#0-8) [10](#0-9) 

- **Consensus observer subscription ordering:** [11](#0-10) [12](#0-11) 

## Impact Explanation

**Medium Severity** - Limited Protocol Violation

This vulnerability allows attackers to:

1. **Inject False Topology Data**: Submit false `distance_from_validators` claims that pass validation
2. **Manipulate Peer Selection**: Influence mempool, state sync, and consensus observer peer prioritization
3. **Degrade Service Quality**: Cause suboptimal peer selection decisions affecting network performance

**Important Limitations:**
- Does NOT affect validator-to-validator consensus (which uses Mutual authentication on `NetworkId::Validator`)
- Does NOT cause fund loss or consensus violations
- Impact is limited to VFN network operations
- Production deployments typically firewall VFN ports to trusted nodes only

This meets the criteria for Medium severity as a "Limited Protocol Violation" - the vulnerability allows poisoning of peer selection metadata without cryptographic verification, but does not compromise core consensus or cause direct fund loss.

## Likelihood Explanation

**Medium Likelihood** - Exploitable with network access:

1. **No Cryptographic Authentication Required**: Attacker needs no trusted credentials
2. **Default Configuration Vulnerable**: VFN networks use `MaybeMutual` by default
3. **Network Access Requirement**: Attacker must reach validator's VFN port
4. **Production Mitigation**: VFN ports typically firewalled in proper deployments

While the code vulnerability exists by default, practical exploitation requires network access to VFN ports, which are typically restricted in production environments.

## Recommendation

Implement role authentication for VFN connections or add explicit marking of inferred-vs-authenticated roles:

1. **Option 1**: Require mutual authentication for VFN networks when peer monitoring data will be used for critical decisions
2. **Option 2**: Add a flag to distinguish authenticated roles from inferred roles, and validate `distance_from_validators` only for authenticated VFN peers
3. **Option 3**: Add additional validation that cross-references `distance_from_validators` claims with actual network topology

The fix should ensure that critical peer selection metadata cannot be poisoned by unauthenticated peers.

## Proof of Concept

A PoC would involve:
1. Running a modified node that connects to a validator's VFN port
2. Allowing the handshake to complete (role will be inferred as VFN)
3. Implementing a monitoring service that responds to `GetNetworkInformation` with `distance_from_validators = 1`
4. Observing that the validator accepts this value and uses it in peer selection decisions

The implementation requires access to validator VFN ports and the ability to run a custom monitoring service implementation.

## Notes

This vulnerability represents a trust boundary violation where unauthenticated role inference is used to validate critical network topology data. While the impact is limited to peer selection optimization rather than consensus safety, it allows attackers to manipulate validator behavior in ways that could degrade network performance or facilitate other attacks.

### Citations

**File:** config/src/network_id.rs (L168-170)
```rust
    pub fn is_validator_network(&self) -> bool {
        self == &NetworkId::Validator
    }
```

**File:** config/src/config/network_config.rs (L136-136)
```rust
        let mutual_authentication = network_id.is_validator_network();
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/peer_manager/builder.rs (L254-257)
```rust
            AuthenticationMode::MaybeMutual(key) => (
                key,
                HandshakeAuthMode::maybe_mutual(transport_context.peers_and_metadata),
            ),
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L128-135)
```rust
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L507-516)
```rust
fn get_distance_from_validators(
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> Option<u64> {
    monitoring_metadata.and_then(|metadata| {
        metadata
            .latest_network_info_response
            .as_ref()
            .map(|network_info_response| network_info_response.distance_from_validators)
    })
}
```

**File:** state-sync/aptos-data-client/src/utils.rs (L23-64)
```rust
/// Chooses peers weighted by distance from the validator set
/// and latency. We prioritize distance over latency as we want
/// to avoid close but not up-to-date peers.
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** state-sync/aptos-data-client/src/utils.rs (L231-260)
```rust
fn get_distance_and_latency_for_peer(
    peers_and_metadata: &Arc<PeersAndMetadata>,
    peer: PeerNetworkId,
) -> Option<(u64, f64)> {
    if let Some(peer_metadata) = get_metadata_for_peer(peers_and_metadata, peer) {
        // Get the distance and latency for the peer
        let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
        let distance = peer_monitoring_metadata
            .latest_network_info_response
            .as_ref()
            .map(|response| response.distance_from_validators);
        let latency = peer_monitoring_metadata.average_ping_latency_secs;

        // Return the distance and latency if both were found
        if let (Some(distance), Some(latency)) = (distance, latency) {
            return Some((distance, latency));
        }
    }

    // Otherwise, no distance and latency was found
    log_warning_with_sample(
        LogSchema::new(LogEntry::PeerStates)
            .event(LogEvent::PeerSelectionError)
            .message(&format!(
                "Unable to get distance and latency for peer! Peer: {:?}",
                peer
            )),
    );
    None
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L196-218)
```rust
fn get_distance_for_peer(
    peer_network_id: &PeerNetworkId,
    peer_metadata: &PeerMetadata,
) -> Option<u64> {
    // Get the distance for the peer
    let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
    let distance = peer_monitoring_metadata
        .latest_network_info_response
        .as_ref()
        .map(|response| response.distance_from_validators);

    // If the distance is missing, log a warning
    if distance.is_none() {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Unable to get distance for peer! Peer: {:?}",
                peer_network_id
            ))
        );
    }

    distance
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```
