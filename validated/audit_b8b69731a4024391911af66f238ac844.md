# Audit Report

## Title
Genesis Block Handling Inconsistency Between V1 and V2 Block Retrieval Causes Sync Failures and Node Crashes

## Summary
A critical inconsistency exists between V1 and V2 block retrieval protocols in how they handle genesis blocks. The V2 protocol filters out genesis blocks from responses but still marks them as successfully found, while the `fetch_quorum_cert()` function lacks protection against requesting genesis blocks (round 0). This causes nodes with execution pool enabled to crash with assertion failures when syncing blocks that trace back to genesis.

## Finding Description

The vulnerability stems from three interconnected issues in the consensus block retrieval implementation:

**Issue 1: V2 Genesis Block Filtering Creates Empty Responses**

The V2 block retrieval handler explicitly filters out genesis blocks but still sets success status when genesis is the target. [1](#0-0) 

When processing a V2 request where the target round is 0 (genesis):
1. The responder iterates to the genesis block
2. Line 570: Genesis block is NOT added to the blocks vector due to `is_genesis_block()` check
3. Line 573: Status is set to `SucceededWithTarget` because `is_window_start_block()` returns true for round 0
4. The response contains an empty blocks vector with `SucceededWithTarget` status

**Issue 2: Missing Genesis Round Protection in fetch_quorum_cert()**

Unlike other code paths that explicitly use `.max(1)` to avoid genesis round, the `fetch_quorum_cert()` function directly uses the certified block's round without protection. [2](#0-1) 

At line 247, when execution pool is enabled (`window_size` is `Some`), the code creates `TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round())` without any `.max(1)` protection. During backwards iteration to fetch missing blocks, when the loop reaches a QuorumCert certifying genesis (round 0), it will create a V2 request with `target_round = 0`.

Compare this to the protected version: [3](#0-2) 

Line 354 explicitly uses `.max(1)` with the comment "Never retrieve genesis block".

**Issue 3: Requester Expects Non-Empty Block Responses**

The block retrieval code contains multiple assertions that expect at least one block in the response. [4](#0-3) 

Lines 865, 879, and 885 all use `.expect("blocks are empty")` or similar, which will panic if the result_blocks vector is empty. This occurs when the responder returns an empty blocks vector with `SucceededWithTarget` status.

Additionally, the V2 verification logic expects the last block to exist and satisfy `is_window_start_block()` when status is `SucceededWithTarget`. [5](#0-4) 

**Complete Exploitation Path:**

1. Node A has execution pool enabled (`window_size` configured)
2. Node A needs to fetch blocks via `fetch_quorum_cert()` during sync operations
3. During backwards iteration (lines 240-262), the function fetches each block and uses its QC for the next iteration
4. Eventually reaches a block whose QC certifies genesis (round 0)
5. Line 247 creates `TargetBlockRetrieval::TargetRound(0)` without `.max(1)` protection
6. Node A sends V2 request to Node B with `target_round = 0`
7. Node B processes the request:
   - Iterates to genesis block
   - Skips adding genesis to blocks vector (line 570)
   - Detects genesis as window start block (line 573)
   - Sets status to `SucceededWithTarget` and breaks
   - Returns empty blocks vector with `SucceededWithTarget` status
8. Node A receives the response and crashes at line 865, 879, or 885 with "blocks are empty" panic

**When Genesis QCs Occur:**

Genesis QuorumCerts with round 0 are legitimate and created during epoch transitions. [6](#0-5) 

Lines 115-118 show that when storage has an end-epoch LedgerInfo, a genesis QC is created with round 0 using `QuorumCert::certificate_for_genesis_from_ledger_info()`. [7](#0-6) 

Line 93 confirms genesis QCs have round 0, and lines 128-141 show special verification logic for round 0 QCs.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node crashes**: Assertion failures cause node panics, directly impacting validator availability
- **Consensus liveness impact**: Multiple nodes encountering this bug during epoch transitions or sync operations could cause network-wide synchronization failures
- **State inconsistencies requiring intervention**: Affected nodes cannot sync properly and require manual intervention or restart

The impact is particularly severe during:
- **Epoch transitions**: When genesis QCs with round 0 are created and propagated
- **New validator onboarding**: Validators syncing from early blocks may trace back to genesis
- **Recovery scenarios**: Nodes recovering after downtime need to sync historical blocks
- **Development environments**: Testnet/devnet with frequent epoch changes or resets

This meets the bug bounty criteria for High severity validator node crashes and potential consensus liveness issues.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability occurs naturally without any malicious actors when:

1. **Execution pool is enabled**: `window_size` is configured (increasingly standard in production)
2. **Block fetching during sync**: The `fetch_quorum_cert()` path is taken during normal consensus sync operations
3. **Backwards iteration reaches genesis**: When fetching blocks, the backwards iteration eventually reaches a QC certifying genesis (round 0)

The likelihood is increased by:
- Execution pool adoption is growing in production deployments
- Epoch transitions regularly create genesis QCs with round 0
- The `.max(1)` protection exists in other code paths but is missing from `fetch_quorum_cert()`
- Tests don't cover the genesis edge case for V2, suggesting low developer awareness

The bug is **NOT** triggered by malicious validators but by legitimate consensus operations, making it a reliability/availability issue that naturally occurs during normal network operation.

## Recommendation

Apply the same `.max(1)` protection used in other code paths to the `fetch_quorum_cert()` function:

**In `consensus/src/block_storage/sync_manager.rs` at line 247, change:**

```rust
Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
```

**To:**

```rust
Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round().max(1)),
```

This ensures that even when backwards iteration reaches a genesis QC (round 0), the target round will be 1, preventing the empty block response issue. This matches the protection already implemented at line 354 in `generate_target_block_retrieval_payload_and_num_blocks()`.

**Additional safeguard**: Consider adding an early return in the V2 response handler to detect and handle the case where all blocks are filtered out, returning `IdNotFound` or `NotEnoughBlocks` status instead of `SucceededWithTarget` when the blocks vector is empty.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configure a node with execution pool enabled (`window_size = Some(n)`)
2. Create a scenario where the node needs to fetch blocks during an epoch transition
3. Ensure the backwards iteration in `fetch_quorum_cert()` reaches a QC certifying genesis
4. Observe that the node crashes with assertion failure "blocks are empty" at line 865, 879, or 885

The key evidence is in the code structure itself:
- Line 247 lacks `.max(1)` protection that exists at line 354
- Lines 570-574 create empty responses with `SucceededWithTarget` status for genesis blocks
- Lines 865, 879, 885 assert non-empty blocks and will panic

This vulnerability is inherent in the code logic and will trigger during normal operations when the specific conditions are met.

## Notes

- This is a **protocol-level bug**, not a security exploit requiring adversarial behavior
- The vulnerability affects consensus availability and node liveness, not fund security
- The fix is straightforward: add `.max(1)` protection to match existing patterns
- Genesis blocks (round 0) are legitimate and created during epoch transitions, so this is not about malicious genesis blocks but about handling them correctly in V2 protocol
- The inconsistency between V1 (which includes genesis) and V2 (which filters genesis) was not fully accounted for in the request generation logic

### Citations

**File:** consensus/src/block_storage/sync_manager.rs (L233-270)
```rust
    async fn fetch_quorum_cert(
        &self,
        qc: QuorumCert,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        let mut pending = vec![];
        let mut retrieve_qc = qc.clone();
        loop {
            if self.block_exists(retrieve_qc.certified_block().id()) {
                break;
            }
            BLOCKS_FETCHED_FROM_NETWORK_WHILE_INSERTING_QUORUM_CERT.inc_by(1);
            let target_block_retrieval_payload = match &self.window_size {
                None => TargetBlockRetrieval::TargetBlockId(retrieve_qc.certified_block().id()),
                Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
            };
            let mut blocks = retriever
                .retrieve_blocks_in_range(
                    retrieve_qc.certified_block().id(),
                    1,
                    target_block_retrieval_payload,
                    qc.ledger_info()
                        .get_voters(&retriever.validator_addresses()),
                )
                .await?;
            // retrieve_blocks_in_range guarantees that blocks has exactly 1 element
            let block = blocks.remove(0);
            retrieve_qc = block.quorum_cert().clone();
            pending.push(block);
        }
        // insert the qc <- block pair
        while let Some(block) = pending.pop() {
            let block_qc = block.quorum_cert().clone();
            self.insert_single_quorum_cert(block_qc)?;
            self.insert_block(block).await?;
        }
        self.insert_single_quorum_cert(qc)
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L349-354)
```rust
            Some(window_size) => {
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
                .max(1); // Never retrieve genesis block
```

**File:** consensus/src/block_storage/sync_manager.rs (L567-583)
```rust
            BlockRetrievalRequest::V2(req) => {
                while (blocks.len() as u64) < req.num_blocks() {
                    if let Some(executed_block) = self.get_block(id) {
                        if !executed_block.block().is_genesis_block() {
                            blocks.push(executed_block.block().clone());
                        }
                        if req.is_window_start_block(executed_block.block()) {
                            status = BlockRetrievalStatus::SucceededWithTarget;
                            break;
                        }
                        id = executed_block.parent_id();
                    } else {
                        status = BlockRetrievalStatus::NotEnoughBlocks;
                        break;
                    }
                }
            },
```

**File:** consensus/src/block_storage/sync_manager.rs (L863-895)
```rust
        // Confirm retrieval hit the first block we care about
        assert_eq!(
            result_blocks.first().expect("blocks are empty").id(),
            block_id,
            "Expecting in the retrieval response, first block should be {}, but got {}",
            block_id,
            result_blocks.first().expect("blocks are empty").id(),
        );

        // Confirm retrieval hit the last block/round we care about
        // Slightly different logic if using execution pool and not
        match target_block_retrieval_payload {
            TargetBlockRetrieval::TargetBlockId(target_block_id) => {
                ensure!(
                    result_blocks
                        .last()
                        .expect("Expected at least a result_block")
                        .id()
                        == target_block_id
                );
            },
            TargetBlockRetrieval::TargetRound(target_round) => {
                let last_block = result_blocks.last().expect("blocks are empty");
                ensure!(
                    last_block.round() == target_round || last_block.quorum_cert().certified_block().round() < target_round,
                    "Expecting in the retrieval response, last block should be == {} or its parent should be < {}, but got {} and parent {}",
                    target_round,
                    target_round,
                    last_block.round(),
                    last_block.quorum_cert().certified_block().round(),
                );
            },
        }
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L245-253)
```rust
                ensure!(
                    self.status != BlockRetrievalStatus::SucceededWithTarget
                        || self
                            .blocks
                            .last()
                            .is_some_and(|block| retrieval_request.is_window_start_block(block)),
                    "target not found in blocks returned, expect {},",
                    retrieval_request.target_round(),
                );
```

**File:** consensus/src/persistent_liveness_storage.rs (L112-123)
```rust
            if self.storage_ledger.ledger_info().ends_epoch() {
                let genesis =
                    Block::make_genesis_block_from_ledger_info(self.storage_ledger.ledger_info());
                let genesis_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
                    self.storage_ledger.ledger_info(),
                    genesis.id(),
                );
                let genesis_ledger_info = genesis_qc.ledger_info().clone();
                let genesis_id = genesis.id();
                blocks.push(genesis);
                quorum_certs.push(genesis_qc);
                (genesis_id, genesis_ledger_info)
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L84-117)
```rust
    pub fn certificate_for_genesis_from_ledger_info(
        ledger_info: &LedgerInfo,
        genesis_id: HashValue,
    ) -> QuorumCert {
        let ancestor = BlockInfo::new(
            ledger_info
                .epoch()
                .checked_add(1)
                .expect("Integer overflow when creating cert for genesis from ledger info"),
            0,
            genesis_id,
            ledger_info.transaction_accumulator_hash(),
            ledger_info.version(),
            ledger_info.timestamp_usecs(),
            None,
        );

        let vote_data = VoteData::new(ancestor.clone(), ancestor.clone());
        let li = LedgerInfo::new(ancestor, vote_data.hash());

        let validator_set_size = ledger_info
            .next_epoch_state()
            .expect("Next epoch state not found in ledger info")
            .verifier
            .len();

        QuorumCert::new(
            vote_data,
            LedgerInfoWithSignatures::new(
                li,
                AggregateSignature::new(BitVec::with_num_bits(validator_set_size as u16), None),
            ),
        )
    }
```
