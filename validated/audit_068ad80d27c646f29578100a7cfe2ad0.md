# Audit Report

## Title
Unbounded RSA Modulus Size in Keyless Authentication Enables Validator CPU Exhaustion

## Summary
The Aptos keyless authentication system lacks RSA modulus size validation in the OpenIdSig verification path, allowing attackers to install federated JWKs with extremely large RSA keys (8192-bit or larger) and force validators to perform computationally expensive signature verifications without paying proportional gas costs, causing significant CPU exhaustion across all validators.

## Finding Description

The Aptos keyless authentication system supports two signature verification paths: **ZeroKnowledgeSig** (using ZK proofs) and **OpenIdSig** (using direct RSA signature verification). While the ZK path enforces a strict 256-byte (2048-bit) RSA modulus size constraint, the OpenIdSig path completely bypasses this validation.

### Missing Validation in JWK Parsing

When JWKs are parsed from JSON, the `TryFrom` implementation extracts the RSA modulus `n` field as a raw string without any size bounds checking: [1](#0-0) 

The **only** RSA modulus size validation in the entire codebase exists in the `to_poseidon_scalar()` method, which strictly enforces exactly 256 bytes (2048-bit keys): [2](#0-1) 

However, this validation function is **exclusively** used for ZK proof verification through the call chain: `get_public_inputs_hash()` → `hash_public_inputs()` → `cached_jwk_hash()` → `to_poseidon_scalar()`: [3](#0-2) [4](#0-3) 

### Vulnerable OpenIdSig Verification Path

For **ZeroKnowledgeSig**, the verification path calls `get_public_inputs_hash()` which enforces the size constraint: [5](#0-4) 

However, for **OpenIdSig**, the verification path completely bypasses `to_poseidon_scalar()` and directly verifies JWT claims and signatures without any modulus size checks: [6](#0-5) 

The `verify_jwt_signature()` method reconstructs the JWT and calls `verify_signature_without_exp_check()`: [7](#0-6) 

This ultimately uses `jsonwebtoken::decode()` to perform full RSA signature verification with **no key size constraints whatsoever**: [8](#0-7) 

### Attack Execution Path

1. Attacker creates a federated keyless account with a custom OIDC provider (any user can do this)

2. Attacker calls the public entry function `update_federated_jwk_set()` to install JWKs with large RSA moduli at their own address: [9](#0-8) 

3. The `patch_federated_jwks()` function only enforces a 2 KiB BCS-serialized size limit on the entire `FederatedJWKs` resource, with **no per-key size validation**: [10](#0-9) 

The size constant is set to 2048 bytes, which is sufficient for 8192-bit RSA keys (~1365 characters base64-encoded + overhead = ~1515 bytes): [11](#0-10) 

4. Attacker submits transactions with OpenIdSig signatures using these oversized keys

5. Every validator must verify these expensive RSA signatures during transaction validation in `validate_signed_transaction()`, which occurs **before any gas is charged**: [12](#0-11) 

6. The code explicitly preserves the gas meter balance during validation (unless account abstraction is enabled): [13](#0-12) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty category: **"Validator node slowdowns."**

### Technical Impact

RSA signature verification complexity grows cubically with modulus size. The computational cost differences are dramatic:
- **8192-bit RSA**: ~64x slower than 2048-bit
- **12288-bit RSA**: ~216x slower than 2048-bit

The attack's impact is severe because:
1. **Verification occurs before gas charging**: All validators perform expensive RSA verification during `validate_signed_transaction()`, which happens before the transaction prologue and any gas deduction
2. **All validators affected simultaneously**: When a block containing such transactions is proposed, every validator must verify these signatures
3. **No proportional cost**: Attacker pays only normal transaction gas (~20-100 gas units for intrinsic cost + fixed keyless base cost), not proportional to the actual CPU burden inflicted
4. **Repeatable attack**: Attacker can submit multiple transactions continuously to sustain validator CPU exhaustion
5. **No mitigation at validation layer**: There is no rate limiting or throttling for expensive signature verifications

This breaks the fundamental **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The signature verification cost is unbounded and not reflected in gas consumption.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute with no significant barriers:

### Prerequisites (All Easily Satisfied)
- **No special privileges**: Any user can create a federated keyless account
- **No trusted OIDC provider compromise**: Attacker uses their own OIDC provider (free services like Auth0, Keycloak available)
- **Public API access**: `update_federated_jwk_set()` is a public entry function callable by anyone
- **Sufficient size budget**: 2 KiB limit easily accommodates 8192-bit keys (~1365 base64 characters + ~150 bytes overhead)
- **Standard tooling**: All crypto libraries support generating large RSA keys

### Attack Steps
1. Generate 8192-bit or 12288-bit RSA keypair (trivial with OpenSSL/any crypto library)
2. Set up custom OIDC provider endpoint (free tier services available)
3. Call `update_federated_jwk_set()` with large JWK (single transaction, ~$0.01)
4. Create federated keyless account pointing to attacker's JWK address
5. Submit transactions with OpenIdSig signatures using oversized key
6. Repeat to continuously exhaust validator CPU resources

### Cost-Benefit Analysis
- **Attacker cost**: ~$0.01-0.10 per transaction (normal gas fees)
- **Validator cost**: 64x-216x normal CPU time per transaction × number of validators
- **Attack sustainability**: Unlimited repetition possible

## Recommendation

Implement RSA modulus size validation in the OpenIdSig verification path before performing signature verification:

1. **Add size check in `verify_jwt_signature()`**: Before calling `verify_signature_without_exp_check()`, validate that the RSA modulus is exactly 256 bytes (2048 bits)

2. **Enforce validation in `patch_federated_jwks()`**: When JWKs are installed via `update_federated_jwk_set()`, validate each RSA key's modulus size

3. **Add size validation during JWK parsing**: In the `TryFrom<&serde_json::Value>` implementation for `RSA_JWK`, validate modulus size immediately after extraction

Example fix location in `types/src/keyless/openid_sig.rs`:

```rust
pub fn verify_jwt_signature(
    &self,
    rsa_jwk: &RSA_JWK,
    jwt_header_json: &str,
) -> anyhow::Result<()> {
    // Add validation here
    let modulus = base64::decode_config(&rsa_jwk.n, URL_SAFE_NO_PAD)?;
    ensure!(
        modulus.len() == RSA_JWK::RSA_MODULUS_BYTES,
        "RSA modulus must be exactly {} bytes, got {}",
        RSA_JWK::RSA_MODULUS_BYTES,
        modulus.len()
    );
    
    // Existing verification logic
    let jwt_b64 = format!(...);
    rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
    Ok(())
}
```

## Proof of Concept

The attack can be demonstrated with the following steps:

1. **Generate large RSA key**:
```bash
openssl genrsa -out large_key.pem 8192
openssl rsa -in large_key.pem -pubout -outform PEM -out large_key_pub.pem
# Extract n and e values for JWK
```

2. **Install JWK via Move transaction**:
```move
script {
    use aptos_framework::jwks;
    use std::string::utf8;
    
    fun install_large_jwk(account: &signer) {
        jwks::update_federated_jwk_set(
            account,
            b"https://attacker-oidc.example.com",
            vector[utf8(b"attack_key_id")],
            vector[utf8(b"RS256")],
            vector[utf8(b"AQAB")],
            vector[utf8(b"<8192-bit-modulus-base64>")] // ~1365 characters
        );
    }
}
```

3. **Submit OpenIdSig transaction**: Create and submit a transaction with OpenIdSig certificate using the oversized key

4. **Observe validator impact**: Monitor validator CPU usage during block processing - validators will experience 64x slowdown per transaction compared to normal 2048-bit RSA verification

The vulnerability is confirmed by the code paths shown above where OpenIdSig verification never calls `to_poseidon_scalar()` and thus never validates key size.

## Notes

This vulnerability affects the zkless keyless feature (OpenIdSig path) which requires the `KEYLESS_BUT_ZKLESS_ACCOUNTS` feature flag to be enabled. However, this feature is expected to be enabled in production for zkless keyless accounts to function, making the vulnerability exploitable on live networks.

The 2 KiB size limit was intended to prevent validators from wasting work on invalid transactions, but it fails to account for the computational complexity difference between storing a JWK (linear in size) and verifying RSA signatures (cubic in modulus size). An 8192-bit key fits within the size limit but causes 64x computational overhead.

### Citations

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** types/src/jwks/rsa/mod.rs (L102-110)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }
```

**File:** types/src/jwks/rsa/mod.rs (L132-177)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
```

**File:** types/src/keyless/bn254_circom.rs (L268-277)
```rust
pub fn cached_jwk_hash(jwk: &RSA_JWK) -> anyhow::Result<Fr> {
    match JWK_HASH_CACHE.get(jwk) {
        None => {
            let hash = jwk.to_poseidon_scalar()?;
            JWK_HASH_CACHE.insert(jwk.clone(), hash);
            Ok(hash)
        },
        Some(hash) => Ok(hash),
    }
}
```

**File:** types/src/keyless/bn254_circom.rs (L371-393)
```rust
pub fn get_public_inputs_hash(
    sig: &KeylessSignature,
    pk: &KeylessPublicKey,
    jwk: &RSA_JWK,
    config: &Configuration,
) -> anyhow::Result<Fr> {
    if let EphemeralCertificate::ZeroKnowledgeSig(proof) = &sig.cert {
        hash_public_inputs(
            config,
            &sig.ephemeral_pubkey,
            &pk.idc,
            sig.exp_date_secs,
            proof.exp_horizon_secs,
            &pk.iss_val,
            proof.extra_field.as_deref(),
            &sig.jwt_header_json,
            jwk,
            proof.override_aud_val.as_deref(),
        )
    } else {
        bail!("Can only call `get_public_inputs_hash` on keyless::Signature with Groth16 ZK proof")
    }
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L292-316)
```rust
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
            JWK::RSA(rsa_jwk) => {
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }

                // If an `aud` override was set for account recovery purposes, check that it is
                // in the allow-list on-chain.
                if zksig.override_aud_val.is_some() {
                    config.is_allowed_override_aud(zksig.override_aud_val.as_ref().unwrap())?;
                }
                match &zksig.proof {
                    ZKP::Groth16(groth16proof) => {
                        // let start = std::time::Instant::now();
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L368-399)
```rust
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
```

**File:** types/src/keyless/openid_sig.rs (L126-139)
```rust
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L33-33)
```text
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-203)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );

        let jwk_addr = signer::address_of(jwk_owner);
        if (!exists<FederatedJWKs>(jwk_addr)) {
            move_to(jwk_owner, FederatedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        };

        let fed_jwks = borrow_global_mut<FederatedJWKs>(jwk_addr);
        vector::for_each_ref(&patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut fed_jwks.jwks, *patch);
        });

        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-277)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));

        let remove_all_patch = new_patch_remove_all();
        let patches = vector[remove_all_patch];
        while (!vector::is_empty(&kid_vec)) {
            let kid = vector::pop_back(&mut kid_vec);
            let alg = vector::pop_back(&mut alg_vec);
            let e = vector::pop_back(&mut e_vec);
            let n = vector::pop_back(&mut n_vec);
            let jwk = new_rsa_jwk(kid, alg, e, n);
            let patch = new_patch_upsert_jwk(iss, jwk);
            vector::push_back(&mut patches, patch)
        };
        patch_federated_jwks(jwk_owner, patches);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1811)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2000-2028)
```rust
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));

        if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            let max_aa_gas = unwrap_or_discard!(self.gas_params(log_context))
                .vm
                .txn
                .max_aa_gas;
            if max_aa_gas < txn_data.max_gas_amount() {
                // Reset initial gas after validation with max_aa_gas.
                unwrap_or_discard!(gas_meter
                    .inject_balance(txn_data.max_gas_amount().checked_sub(max_aa_gas).unwrap()));
            }
        } else {
            assert_eq!(initial_gas, gas_meter.balance());
        }
```
