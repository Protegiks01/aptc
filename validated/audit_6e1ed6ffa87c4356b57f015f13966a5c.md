# Audit Report

## Title
Control Flow Graph Construction DoS via Unbounded Resource Consumption During Bytecode Verification

## Summary
The Move bytecode verifier constructs Control Flow Graphs (CFGs) for functions without enforcing resource limits beforehand, enabling attackers to cause validator node slowdowns through module publishing transactions containing pathologically large functions with maximized basic block counts.

## Finding Description

The vulnerability exists in the bytecode verification pipeline where expensive CFG construction occurs before the `max_basic_blocks` limit is enforced.

**Verification Flow Analysis:**

1. Module deserialization enforces `BYTECODE_COUNT_MAX = 65535` [1](#0-0) 

2. Complexity checking via `check_module_complexity` meters binary format elements (signatures, instantiations) but does NOT construct or check the CFG [2](#0-1) [3](#0-2) 

3. Module verification invokes `verify_module_with_config` [4](#0-3)  which calls `CodeUnitVerifier::verify_module` [5](#0-4) 

4. `CodeUnitVerifier::verify_function` calls `control_flow::verify_function` [6](#0-5) 

5. This creates a `FunctionView` which immediately constructs the CFG via `VMControlFlowGraph::new(&code.code)` [7](#0-6) [8](#0-7) 

6. **Only AFTER** the CFG is fully constructed does the verifier check `max_basic_blocks` [9](#0-8) 

**Resource Consumption Analysis:**

The CFG construction algorithm in `VMControlFlowGraph::new` performs:
- O(n) iteration to identify block boundaries
- O(n) block creation with memory allocation
- O(V + E) depth-first search for loop analysis allocating exploration maps, DFS stacks, and post-order traversal vectors [10](#0-9) 

**Critical Gap:** The meter parameter passed to `verify_function` is explicitly unused during CFG construction [11](#0-10) 

**Attack Vector:**

An attacker can craft a function with 65,535 instructions (max allowed) structured to maximize basic blocks (e.g., alternating branch instructions). The complexity budget of `2048 + blob.code().len() * 20` [12](#0-11)  allows this (budget = 1,312,748 for 65K instructions), but the CFG construction cost is NOT included in this budget. While production limits `max_basic_blocks` to 1024 [13](#0-12) , this check occurs after thousands of basic blocks have been constructed and processed through expensive DFS algorithms.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns - Significant performance degradation affecting consensus, DoS through resource exhaustion."

Each malicious module submission forces every validator to:
- Allocate memory for potentially thousands of basic blocks and associated data structures
- Execute expensive O(V+E) DFS traversals for loop analysis
- Only then reject the module after resource exhaustion

An attacker can repeatedly submit such modules at minimal cost (gas proportional only to bytecode size, not verification complexity), causing sustained CPU and memory pressure across all validators, degrading consensus performance.

## Likelihood Explanation

**High likelihood** of exploitation:
- Attack requires only crafting modules with many sequential branch instructions (trivially achievable)
- No special permissions required - any account can publish modules
- Gas cost is asymmetric: attacker pays for module size, validators pay for verification cost
- Attack can be repeated continuously to sustain DoS
- Affects all validators simultaneously

## Recommendation

**Immediate Fix:** Enforce `max_basic_blocks` limit BEFORE CFG construction by adding an upfront block count estimation pass, or meter CFG construction operations.

**Code Changes:**
1. Add metering to `VMControlFlowGraph::new` using the meter parameter
2. Or perform a lightweight pre-check to estimate basic block count before full CFG construction
3. Consider reducing complexity budget or adding CFG-specific cost factors

## Proof of Concept

```rust
// Malicious module with maximum branches to create excessive basic blocks
module 0x1::dos_attack {
    public entry fun exhaust_verifier() {
        // Craft 65,535 instructions arranged as:
        // Branch(1), Branch(2), ..., Branch(n), Ret
        // Creates maximum basic blocks before max_basic_blocks check
        // Each validator must construct full CFG with DFS before rejection
    }
}
```

The attack vector is constructing bytecode with alternating branch instructions and branch targets to maximize the number of basic blocks while staying under `BYTECODE_COUNT_MAX`, forcing expensive CFG construction before the `max_basic_blocks` validation rejects it.

## Notes

This vulnerability represents a classic "check-after-use" pattern where expensive operations occur before limit enforcement. The separation between complexity budgeting (which doesn't cover CFG construction) and bytecode verification (which constructs the CFG) creates an exploitable gap in resource protection.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L158-158)
```rust
        CodeUnitVerifier::verify_module(config, module)?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L138-145)
```rust
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L147-152)
```rust
        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L41-41)
```rust
    _meter: &mut impl Meter, // TODO: metering
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L50-50)
```rust
        let function_view = FunctionView::function(module, index, code, function_handle);
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L449-449)
```rust
            cfg: VMControlFlowGraph::new(&code.code),
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L84-225)
```rust
    pub fn new(code: &[Bytecode]) -> Self {
        let code_len = code.len() as CodeOffset;
        // First go through and collect block ids, i.e., offsets that begin basic blocks.
        // Need to do this first in order to handle backwards edges.
        let mut block_ids = Set::new();
        block_ids.insert(ENTRY_BLOCK_ID);
        for pc in 0..code.len() {
            VMControlFlowGraph::record_block_ids(pc as CodeOffset, code, &mut block_ids);
        }

        // Create basic blocks
        let mut blocks = Map::new();
        let mut entry = 0;
        let mut exit_to_entry = Map::new();
        for pc in 0..code.len() {
            let co_pc = pc as CodeOffset;

            // Create a basic block
            if Self::is_end_of_block(co_pc, code, &block_ids) {
                let exit = co_pc;
                exit_to_entry.insert(exit, entry);
                let successors = Bytecode::get_successors(co_pc, code);
                let bb = BasicBlock { exit, successors };
                blocks.insert(entry, bb);
                entry = co_pc + 1;
            }
        }
        let blocks = blocks;
        assert_eq!(entry, code_len);

        // # Loop analysis
        //
        // This section identifies loops in the control-flow graph, picks a back edge and loop head
        // (the basic block the back edge returns to), and decides the order that blocks are
        // traversed during abstract interpretation (reverse post-order).
        //
        // The implementation is based on the algorithm for finding widening points in Section 4.1,
        // "Depth-first numbering" of Bourdoncle [1993], "Efficient chaotic iteration strategies
        // with widenings."
        //
        // NB. The comments below refer to a block's sub-graph -- the reflexive transitive closure
        // of its successor edges, modulo cycles.

        #[derive(Copy, Clone)]
        enum Exploration {
            InProgress,
            Done,
        }

        let mut exploration: Map<BlockId, Exploration> = Map::new();
        let mut stack = vec![ENTRY_BLOCK_ID];

        // For every loop in the CFG that is reachable from the entry block, there is an entry in
        // `loop_heads` mapping to all the back edges pointing to it, and vice versa.
        //
        // Entry in `loop_heads` implies loop in the CFG is justified by the comments in the loop
        // below.  Loop in the CFG implies entry in `loop_heads` is justified by considering the
        // point at which the first node in that loop, `F` is added to the `exploration` map:
        //
        // - By definition `F` is part of a loop, meaning there is a block `L` such that:
        //
        //     F - ... -> L -> F
        //
        // - `F` will not transition to `Done` until all the nodes reachable from it (including `L`)
        //   have been visited.
        // - Because `F` is the first node seen in the loop, all the other nodes in the loop
        //   (including `L`) will be visited while `F` is `InProgress`.
        // - Therefore, we will process the `L -> F` edge while `F` is `InProgress`.
        // - Therefore, we will record a back edge to it.
        let mut loop_heads: Map<BlockId, Set<BlockId>> = Map::new();

        // Blocks appear in `post_order` after all the blocks in their (non-reflexive) sub-graph.
        let mut post_order = Vec::with_capacity(blocks.len());

        while let Some(block) = stack.pop() {
            match exploration.entry(block) {
                Entry::Vacant(entry) => {
                    // Record the fact that exploration of this block and its sub-graph has started.
                    entry.insert(Exploration::InProgress);

                    // Push the block back on the stack to finish processing it, and mark it as done
                    // once its sub-graph has been traversed.
                    stack.push(block);

                    for succ in &blocks[&block].successors {
                        match exploration.get(succ) {
                            // This successor has never been visited before, add it to the stack to
                            // be explored before `block` gets marked `Done`.
                            None => stack.push(*succ),

                            // This block's sub-graph was being explored, meaning it is a (reflexive
                            // transitive) predecessor of `block` as well as being a successor,
                            // implying a loop has been detected -- greedily choose the successor
                            // block as the loop head.
                            Some(Exploration::InProgress) => {
                                loop_heads.entry(*succ).or_default().insert(block);
                            },

                            // Cross-edge detected, this block and its entire sub-graph (modulo
                            // cycles) has already been explored via a different path, and is
                            // already present in `post_order`.
                            Some(Exploration::Done) => { /* skip */ },
                        };
                    }
                },

                Entry::Occupied(mut entry) => match entry.get() {
                    // Already traversed the sub-graph reachable from this block, so skip it.
                    Exploration::Done => continue,

                    // Finish up the traversal by adding this block to the post-order traversal
                    // after its sub-graph (modulo cycles).
                    Exploration::InProgress => {
                        post_order.push(block);
                        entry.insert(Exploration::Done);
                    },
                },
            }
        }

        let traversal_order = {
            // This reverse post order is akin to a topological sort (ignoring cycles) and is
            // different from a pre-order in the presence of diamond patterns in the graph.
            post_order.reverse();
            post_order
        };

        // build a mapping from a block id to the next block id in the traversal order
        let traversal_successors = traversal_order
            .windows(2)
            .map(|window| {
                debug_assert!(window.len() == 2);
                (window[0], window[1])
            })
            .collect();

        VMControlFlowGraph {
            blocks,
            traversal_successors,
            loop_heads,
        }
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```
