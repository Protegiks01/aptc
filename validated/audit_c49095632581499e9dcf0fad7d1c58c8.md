# Audit Report

## Title
Unbounded Memory Exhaustion via Byzantine Validator JWK Consensus Request Flooding in Per-Key Mode

## Summary
Byzantine validators can exhaust validator node memory by flooding the system with arbitrary (issuer, kid) pairs through `KeyLevelObservationRequest` messages. The vulnerability stems from two protocol bugs: (1) unconditional HashMap entry creation without validation, and (2) incorrect cleanup logic that fails to remove malicious entries.

## Finding Description

The JWK consensus system in per-key mode maintains a `states_by_key` HashMap to track consensus state for each (issuer, kid) pair. [1](#0-0) 

When a `KeyLevelObservationRequest` arrives, the `process_peer_request()` function unconditionally creates a HashMap entry using `entry().or_default()`. [2](#0-1) 

The `Issuer` and `KID` types are defined as `Vec<u8>` with no inherent length restrictions. [3](#0-2)  While a `MAX_ISSUER_UTF8_BYTES_LENGTH` constant (120 bytes) exists in the Move layer [4](#0-3) , this validation is not enforced in the Rust consensus layer when processing these RPC requests.

For requests where consensus is `NotStarted`, the function returns early without sending a response, but the HashMap entry persists. [5](#0-4) 

The critical bug lies in the cleanup logic within `reset_with_on_chain_state()`. The retain operation evaluates to `true` for non-existent issuers (both versions return 0 via `unwrap_or_default()`), causing arbitrary entries to persist indefinitely. [6](#0-5) 

**Attack Path:**
1. Byzantine validator sends `KeyLevelObservationRequest` with arbitrary (issuer, kid) pairs
2. Each request creates a persistent HashMap entry with `ConsensusState::NotStarted`
3. Function returns early, but entries persist in memory
4. Cleanup logic incorrectly retains these malicious entries (0 == 0 comparison)
5. Network rate limiting (100 concurrent RPCs) [7](#0-6)  only prevents concurrent requests, not sequential batches
6. Attacker repeats with unique pairs, causing unbounded HashMap growth

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's category of "Validator Node Slowdowns" caused by "DoS through resource exhaustion."

- **Memory Exhaustion**: Unbounded HashMap growth degrades validator performance and affects consensus participation
- **Validator Slowdowns**: Memory pressure causes processing delays impacting block production
- **Potential Node Crashes**: Severe memory exhaustion could crash validator nodes
- **Network Impact**: If multiple validators are targeted simultaneously, network performance degrades or liveness could be impacted

This is a protocol-level resource exhaustion bug (missing validation and incorrect cleanup logic), distinct from out-of-scope network-level DoS attacks.

## Likelihood Explanation

**High Likelihood:**
- Byzantine validators (up to 1/3 of validator set) are part of the standard BFT adversary model and considered untrusted actors
- Attack execution is trivial: send RPC messages with random byte sequences
- No length validation exists in the Rust consensus layer for issuer/kid fields
- No per-session or total resource limits are enforced on `states_by_key`
- Network layer rate limiting (100 concurrent RPCs) provides minimal protection as attackers can send sequential batches indefinitely
- Cleanup logic bug ensures malicious entries persist across epoch changes
- No authentication beyond validator set membership is required

## Recommendation

Implement three defensive layers:

1. **Input Validation**: Enforce maximum length limits on Issuer and KID fields in `process_peer_request()` before creating HashMap entries. Reject requests exceeding reasonable bounds (e.g., 120 bytes for issuer, 256 bytes for kid).

2. **Fix Cleanup Logic**: Modify `reset_with_on_chain_state()` to properly remove entries for non-existent issuers:
```rust
self.states_by_key.retain(|(issuer, _), _| {
    let new_version = new_onchain_jwks.get(issuer).map(|jwks| jwks.version);
    let old_version = self.onchain_jwks.get(issuer).map(|jwks| jwks.version);
    
    // Only retain if issuer exists in new state AND versions match
    new_version.is_some() && new_version == old_version
});
```

3. **Resource Bounds**: Add a maximum size limit on `states_by_key` HashMap (e.g., 10,000 entries) and reject new requests when the limit is reached.

## Proof of Concept

While a complete PoC would require a multi-validator testnet setup, the vulnerability can be verified by:
1. Examining the unconditional `entry().or_default()` call in process_peer_request()
2. Confirming the cleanup logic bug where `0 == 0` evaluates to `true` for non-existent issuers
3. Verifying no length validation exists on Issuer/KID types in the RPC handler

The code evidence provided conclusively demonstrates that Byzantine validators can create persistent HashMap entries without bounds, and the cleanup mechanism fails to remove them.

## Notes

The distinction between this vulnerability and out-of-scope "Network DoS attacks" is critical. This is a **protocol-level resource exhaustion bug** caused by missing validation and incorrect cleanup logic in the implementation, not a network infrastructure attack. The Aptos bug bounty explicitly includes "Validator Node Slowdowns" from "DoS through resource exhaustion" as a valid HIGH severity impact, which this vulnerability directly matches.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L244-254)
```rust
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L274-277)
```rust
                let consensus_state = self
                    .states_by_key
                    .entry((issuer.clone(), kid.clone()))
                    .or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L279-285)
```rust
                    ConsensusState::NotStarted => {
                        debug!(
                            issuer = String::from_utf8(issuer.clone()).ok(),
                            kid = String::from_utf8(kid.clone()).ok(),
                            "key-level jwk consensus not started"
                        );
                        return Ok(());
```

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/keyless.move (L33-34)
```text
    /// The maximum length of the issuer string in bytes in a Keyless public key.
    const MAX_ISSUER_UTF8_BYTES_LENGTH: u64 = 120;
```

**File:** network/framework/src/constants.rs (L15-15)
```rust
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```
