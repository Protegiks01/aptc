# Audit Report

## Title
DKG Transcript Aggregation Memory Exhaustion via Unbounded Deserialization

## Summary
Byzantine validators can craft malicious DKG transcripts with oversized `soks` vectors that bypass size validation, causing honest validators to exhaust memory during transcript aggregation. The vulnerability exists because BCS deserialization allocates memory before validation checks can reject malformed transcripts.

## Finding Description

During the DKG process, validators broadcast transcripts for aggregation. The aggregation logic deserializes incoming transcripts without size limits before performing validation. [1](#0-0) 

A Byzantine validator can craft a malicious `Transcript` with an extremely large `soks` vector. The PVSS transcript structure contains multiple vector fields including `soks`, `V`, `V_hat`, `R`, `R_hat`, and `C`. [2](#0-1) 

The `check_sizes()` function validates the lengths of `V`, `V_hat`, `R`, `R_hat`, and `C` vectors but critically **does NOT validate the `soks` vector size**. [3](#0-2) 

**Attack Flow:**

1. Byzantine validator creates a `Transcript` with 300,000+ sok entries (~200 bytes each = ~60 MB total)
2. Other vectors are correctly sized to pass `check_sizes()`
3. Serializes into `transcript_bytes` and wraps in `DKGTranscript`
4. Network layer accepts the message (within the 64 MiB limit) [4](#0-3) 
5. Honest validator receives and deserializes `transcript_bytes` without size checks [1](#0-0) 
6. BCS allocates ~60 MB for the malicious soks vector
7. Validation executes AFTER memory allocation:
   - `verify_transcript_extra()` calls `get_dealers()` which iterates through all soks [5](#0-4) 
   - Builds `dealer_set` HashSet by iterating through all dealers [6](#0-5) 
   - Duplicate check fails (300,000 dealers != 1 unique dealer) [7](#0-6) 
8. Transcript rejected, but ~60 MB was already allocated and processed

With 10 colluding Byzantine validators, honest nodes experience 600 MB memory spikes, GC pressure, and potential OOM conditions on memory-constrained validator nodes.

## Impact Explanation

**Severity: High** (Validator node slowdowns - up to $50,000)

This vulnerability enables Byzantine validators to cause memory exhaustion on honest validator nodes during DKG transcript aggregation. While memory is eventually freed after validation rejection, the temporary spike can:

1. **Slow down validator nodes** through excessive memory allocation and GC pressure
2. **Crash nodes with limited memory** via OOM conditions
3. **Degrade DKG performance** across the network
4. **Be repeated every epoch** as DKG runs at epoch boundaries [8](#0-7) 

Per the Aptos bug bounty criteria, this constitutes "Validator node slowdowns" through "DoS via resource exhaustion", which falls under **High Severity** (up to $50,000). This is distinct from network DoS attacks (which are out of scope) because it exploits a specific protocol-level bug where validation occurs after expensive deserialization operations.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly exploitable because:

1. **Low barrier to entry**: Any validator can participate in DKG
2. **No pre-validation**: No size checks before deserialization [1](#0-0) 
3. **Reliable broadcast**: Ensures all validators receive malicious transcripts
4. **Recurring opportunity**: DKG runs at every epoch transition
5. **No soks size validation**: `check_sizes()` omits soks validation [3](#0-2) 

The attack requires only Byzantine validator status and ability to craft malicious BCS-serialized transcriptsâ€”no special privileges or complex coordination needed.

## Recommendation

Add size validation for the `soks` vector before deserialization:

**Option 1**: Validate `transcript_bytes` size before deserialization in `TranscriptAggregationState::add()`:
```rust
const MAX_TRANSCRIPT_SIZE: usize = 10 * 1024 * 1024; // 10 MB
ensure!(
    transcript_bytes.len() <= MAX_TRANSCRIPT_SIZE,
    "Transcript size exceeds maximum allowed"
);
```

**Option 2**: Add `soks.len()` validation to `check_sizes()`:
```rust
fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
    let W = sc.get_total_weight();
    let n = sc.get_total_num_players();
    
    if self.soks.len() > n {
        bail!("Expected at most {} soks, but got {}", n, self.soks.len());
    }
    // ... existing checks
}
```

**Option 3**: Perform lightweight pre-validation before full deserialization by checking the first few bytes of `transcript_bytes` to estimate vector sizes.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a malicious `Transcript` with 300,000 duplicate sok entries
2. Serializing with BCS into `transcript_bytes`
3. Wrapping in `DKGTranscript` and sending via reliable broadcast
4. Observing memory allocation spike on receiving validators before rejection

While a complete PoC requires validator setup, the code analysis confirms that deserialization occurs before validation, enabling the described memory exhaustion attack.

---

**Notes:**
- This is a protocol-level vulnerability exploiting missing validation, NOT a network flooding attack
- The distinction from "Network DoS" is that it exploits a specific bug where expensive operations occur before validation
- Each Byzantine validator can only send one malicious transcript per DKG session, but multiple validators amplify the impact
- The vulnerability is particularly concerning because DKG runs at every epoch transition, providing recurring attack opportunities

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L50-72)
```rust
pub struct Transcript {
    /// Proofs-of-knowledge (PoKs) for the dealt secret committed in $c = g_2^{p(0)}$.
    /// Since the transcript could have been aggregated from other transcripts with their own
    /// committed secrets in $c_i = g_2^{p_i(0)}$, this is a vector of PoKs for all these $c_i$'s
    /// such that $\prod_i c_i = c$.
    ///
    /// Also contains BLS signatures from each player $i$ on that player's contribution $c_i$, the
    /// player ID $i$ and auxiliary information `aux[i]` provided during dealing.
    soks: Vec<SoK<G1Projective>>,
    /// Commitment to encryption randomness $g_1^{r_j} \in G_1, \forall j \in [W]$
    R: Vec<G1Projective>,
    /// Same as $R$ except uses $g_2$.
    R_hat: Vec<G2Projective>,
    /// First $W$ elements are commitments to the evaluations of $p(X)$: $g_1^{p(\omega^i)}$,
    /// where $i \in [W]$. Last element is $g_1^{p(0)}$ (i.e., the dealt public key).
    V: Vec<G1Projective>,
    /// Same as $V$ except uses $g_2$.
    V_hat: Vec<G2Projective>,
    /// ElGamal encryption of the $j$th share of player $i$:
    /// i.e., $C[s_i+j-1] = h_1^{p(\omega^{s_i + j - 1})} ek_i^{r_j}, \forall i \in [n], j \in [w_i]$.
    /// We sometimes denote $C[s_i+j-1]$ by C_{i, j}.
    C: Vec<G1Projective>,
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-455)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** types/src/dkg/real_dkg/mod.rs (L302-302)
```rust
        let main_trx_dealers = trx.main.get_dealers();
```

**File:** types/src/dkg/real_dkg/mod.rs (L303-310)
```rust
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L311-311)
```rust
        ensure!(main_trx_dealers.len() == dealer_set.len());
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L1-1)
```text
/// Reconfiguration with DKG helper functions.
```
