# Audit Report

## Title
ObjectCore Deletion Race Condition Causes Indexer Event Data Corruption and Sequence Number Collisions

## Summary
The `TransferTranslator` in the internal event indexer uses `latest_state_checkpoint_view()` to look up `ObjectCore` resources when translating V2 Transfer events to V1 format. This creates a race condition where an object can be transferred and then deleted before the indexer processes the transfer event. When ObjectCore is not found, the translator falls back to a deterministic creation number with sequence 0, causing multiple transfer events for the same object to overwrite each other in the database, resulting in event data loss and sequence number corruption.

## Finding Description

The vulnerability exists in the event V2-to-V1 translation system within the internal indexer. The critical flaw is in the `TransferTranslator::translate_event_v2_to_v1` implementation.

**The Race Condition:**

When the indexer processes V2 Transfer events, it looks up the `ObjectCore` resource to determine the correct event key and sequence number: [1](#0-0) 

The lookup uses `get_state_value_bytes_for_object_group_resource()` which internally calls `latest_state_checkpoint_view()`: [2](#0-1) 

**The Critical Issue:** `latest_state_checkpoint_view()` returns the state at the **latest committed version**, not at the version when the event was emitted. This means if an object is transferred at version V and deleted at version V+1, when the indexer processes the transfer event later, it will look up ObjectCore at a version where it has already been deleted.

**The Unsafe Fallback:**

When ObjectCore is not found, the `TransferTranslator` falls back to a deterministic creation number with sequence 0, unlike other translators which properly error out: [3](#0-2) 

Compare this to `TokenMutationTranslator` which correctly returns an error: [4](#0-3) 

**Object Deletion is Supported:**

The Move framework allows objects with `can_delete=true` to be permanently deleted from storage: [5](#0-4) [6](#0-5) 

**Data Corruption Mechanism:**

Events are stored in `EventByKeySchema` with `(EventKey, sequence_number)` as the composite key: [7](#0-6) 

When multiple Transfer events for the same object all map to sequence 0, subsequent writes overwrite previous entries in RocksDB, permanently losing event data.

**Attack Scenario:**

1. **Version V**: Attacker transfers a deletable object (emits Transfer event, ObjectCore exists)
2. **Version V+1**: Optionally transfer again (emits another Transfer event)
3. **Version V+2**: Attacker deletes the object using `delete()`, removing ObjectCore from storage
4. **Version V+3+**: Indexer processes the Transfer events from versions V and V+1
5. The indexer looks up ObjectCore at the **latest** state (V+3+) where ObjectCore has been deleted
6. Lookup fails, translator falls back to `(EventKey::new(0x4000000000000, object_address), 0)` for ALL events
7. All events are written with the same key `(EventKey, 0)`, causing overwrites in the database

**Query Failures:**

When clients query events, the validation code detects sequence number gaps and throws errors: [8](#0-7) [9](#0-8) 

**Indexer Processing Context:**

The indexer processes transactions asynchronously in batches, translating V2 events during batch processing: [10](#0-9) 

This asynchronous processing creates the timing window where state can change between event emission and indexer processing.

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

**1. API Crashes (High Severity - $50,000):**
When clients query events for affected objects, the indexer returns "DB corruption: Sequence number not continuous" errors, causing API query failures. This directly impacts applications relying on event data for NFT transfers, marketplace transactions, and object lifecycle tracking.

**2. Indexer Data Corruption:**
Event history becomes permanently corrupted with missing events (overwritten in database). The first Transfer events are silently lost, making the blockchain's queryable state inconsistent with the actual ledger state.

**3. Ecosystem Impact:**
- External indexers and analytics platforms relying on event data receive corrupted information
- NFT marketplaces cannot track transfer history correctly
- Audit trails for object ownership are incomplete
- Monitoring and compliance systems fail

**Scope Validation:**
- Affects `storage/indexer/` (in-scope storage subsystem)
- Does not require trusted role compromise
- Does not affect consensus or validator operation directly
- Falls under "API Crashes" and "Limited Protocol Violations" categories

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable:

**Attacker Requirements:**
- Ability to create deletable objects (standard Move framework feature available to all users)
- Ability to submit transactions (any user)
- No special permissions, governance participation, or validator access needed

**Complexity:** Low
- Attack requires only 2-3 simple transactions
- No precise timing required - any deletion after transfer triggers the bug
- No coordination with other actors needed
- Deterministically reproducible

**Triggering Conditions:**
- Objects with `can_delete=true` are standard in:
  - NFT and gaming applications (temporary items, burned tokens)
  - Marketplace listings (cleanup after sale)
  - DeFi protocols (temporary escrow objects)
- Indexer naturally processes events with a lag due to batch processing
- The race window is large - spans multiple block times

**Economic Cost:**
- Only standard gas fees for 2-3 transactions
- No staking or capital requirements
- High impact vs. minimal cost

**Realistic Attack Scenarios:**
- NFT marketplace: List item → Transfer to buyer → Burn listing object
- Gaming: Create temporary object → Transfer to player → Delete after use
- Any protocol with object lifecycle: Create → Transfer → Cleanup/Delete

The vulnerability is **systemic** - it occurs naturally whenever objects follow a transfer-then-delete pattern, which is common in blockchain applications.

## Recommendation

**Fix Option 1: Error on Missing ObjectCore (Recommended)**

Modify `TransferTranslator` to match the behavior of other translators - return an error instead of falling back to sequence 0:

```rust
let (key, sequence_number) = if let Some(state_value_bytes) = engine
    .get_state_value_bytes_for_object_group_resource(transfer.object(), &struct_tag)?
{
    let object_core_resource: ObjectCoreResource = bcs::from_bytes(&state_value_bytes)?;
    let key = *object_core_resource.transfer_events().key();
    let sequence_number = engine
        .get_next_sequence_number(&key, object_core_resource.transfer_events().count())?;
    (key, sequence_number)
} else {
    // Object has been deleted - skip translation to avoid corruption
    return Err(AptosDbError::from(anyhow::format_err!(
        "ObjectCore resource not found - object may have been deleted"
    )));
};
```

**Fix Option 2: Version-Aware State Lookup**

Modify the translation engine to look up state at the transaction version when the event was emitted, not the latest version. This requires passing the version context through the translation pipeline.

**Fix Option 3: Special Handling for Deleted Objects**

Maintain a separate index of deleted object addresses and skip translation for events involving deleted objects, or use a special marker in the event data.

## Proof of Concept

```move
// File: test_transfer_delete_race.move
#[test_only]
module test_addr::transfer_delete_race_poc {
    use std::signer;
    use aptos_framework::object;
    
    #[test(creator = @0x123)]
    fun test_transfer_then_delete(creator: &signer) {
        // Step 1: Create a deletable object
        let constructor_ref = object::create_object(signer::address_of(creator));
        let delete_ref = object::generate_delete_ref(&constructor_ref);
        let transfer_ref = object::generate_transfer_ref(&constructor_ref);
        let obj = object::object_from_constructor_ref<object::ObjectCore>(&constructor_ref);
        
        // Step 2: Transfer the object (emits Transfer V2 event)
        let recipient = @0x456;
        object::transfer_with_ref(object::generate_linear_transfer_ref(&transfer_ref), recipient);
        
        // Step 3: Transfer again (emits another Transfer V2 event)
        let transfer_ref2 = object::generate_transfer_ref(&constructor_ref);
        let recipient2 = @0x789;
        object::transfer_with_ref(object::generate_linear_transfer_ref(&transfer_ref2), recipient2);
        
        // Step 4: Delete the object - removes ObjectCore from storage
        object::delete(delete_ref);
        
        // Result: When indexer processes transfer events from steps 2-3,
        // it will look up ObjectCore at latest state (after deletion).
        // Both events will be indexed with sequence 0, causing the second
        // to overwrite the first. Queries will fail with "DB corruption".
    }
}
```

**Testing the Vulnerability:**

1. Deploy and execute the above Move test
2. Enable the internal indexer with V2 event translation
3. Let the indexer process the transactions
4. Query events for the object address using the indexer API
5. Observe: "DB corruption: Sequence number not continuous" error
6. Verify: First transfer event is missing from the database (overwritten)

## Notes

This vulnerability is unique to the `TransferTranslator` implementation. Other event translators (`TokenMutationTranslator`, `CollectionMutationTranslator`, etc.) correctly handle missing resources by returning errors rather than falling back to default values. The inconsistency suggests the fallback in `TransferTranslator` was added without fully considering the collision implications when multiple events exist before deletion.

The vulnerability only affects nodes running the internal indexer with V2 event translation enabled. However, this includes most fullnodes serving API requests, making the impact significant for the ecosystem.

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L207-214)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L392-428)
```rust
struct TransferTranslator;
impl EventV2Translator for TransferTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let transfer = Transfer::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x1::object::ObjectCore".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(transfer.object(), &struct_tag)?
        {
            let object_core_resource: ObjectCoreResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_core_resource.transfer_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_core_resource.transfer_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of TransferEvent is deterministically 0x4000000000000
            // because the INIT_GUID_CREATION_NUM in the Move module is 0x4000000000000.
            static TRANSFER_EVENT_CREATION_NUMBER: u64 = 0x4000000000000;
            (
                EventKey::new(TRANSFER_EVENT_CREATION_NUMBER, *transfer.object()),
                0,
            )
        };
        let transfer_event =
            TransferEvent::new(*transfer.object(), *transfer.from(), *transfer.to());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TRANSFER_EVENT_TYPE.clone(),
            bcs::to_bytes(&transfer_event)?,
        )?)
    }
}
```

**File:** storage/indexer/src/event_v2_translator.rs (L451-456)
```rust
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L134-143)
```text
    struct ConstructorRef has drop {
        self: address,
        /// True if the object can be deleted. Named objects are not deletable.
        can_delete: bool,
    }

    /// Used to remove an object from storage.
    struct DeleteRef has drop, store {
        self: address,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L414-428)
```text
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L23-29)
```rust
define_pub_schema!(EventByKeySchema, Key, Value, EVENT_BY_KEY_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, SeqNum);

type Index = u64;
type Value = (Version, Index);
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-137)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** storage/indexer/src/db_indexer.rs (L232-239)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```

**File:** storage/indexer/src/db_indexer.rs (L448-484)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
```
