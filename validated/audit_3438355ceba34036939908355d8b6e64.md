Audit Report

## Title
WriteSet Validation Bypass in Backup Restore Allows Modification of System-Protected Resources

## Summary
During the restore operation, the Aptos Core backup system directly commits WriteSets to the database without validating their contents through the Move VM or enforcing system resource access controls. This allows backups to be crafted or tampered such that protected on-chain resources (e.g., `@core_resources`, `@aptos_framework`) are modified, bypassing all normal consensus, VM, and access control protections.

## Finding Description
Aptos' normal transaction execution path rigorously enforces access controls on critical system resources (`@core_resources`, `@aptos_framework`) using mechanisms such as the Move `system_addresses` module and VM-level checks. However, the database backup/restore mechanism includes a bypass:

- The restore process invokes `save_transactions()` [1](#0-0) , which calls directly into logic that persists transactions and their corresponding WriteSets to the database.
- Critically, these WriteSets are not validated by the Move VM or subjected to any module-based access controls—they are written as-is via `put_write_set()` [2](#0-1) .
- There is no check in the restore path to restrict modifications to objects or code belonging to system addresses, which are otherwise only accessible by privileged modules/accounts under VM enforcement.

**Attack path:** If an attacker can compromise or modify backup data (e.g., S3/GCS or in-transit), they can inject WriteSets that:

- Directly alter or overwrite Move resources (such as validators, governance, mint modules, etc.)
- Bypass all checks and controls that would prevent this in the normal transaction processing path.

Upon restore, the node commits the state reflected in the WriteSets—resulting in unauthorized, potentially catastrophic on-chain state changes (minting, slashing, governance manipulation, or consensus failure).

This clearly breaks the critical Aptos invariant: "System addresses (@aptos_framework, @core_resources) must be protected," as it allows their modification outside of any controlled mechanism.

## Impact Explanation
This bug is a **HIGH** severity vulnerability, as per Aptos bug bounty categories:

- **Access Control Bypass**: Enables modification of critical chain resources by anyone able to manipulate backup data, defeating system address protections.
- **State Manipulation**: Allows arbitrary writes to validator configs, coin minting, staking, and governance parameters.
- **Consensus Impact**: Different nodes restoring differently-modified backups will end up in irreconcilable states, potentially splitting the consensus.
- **Fund Security**: Enables minting of assets, unauthorized fund movement, or altering economic/consensus behavior—direct risk of theft and catastrophic protocol loss.

Although it does require backup compromise, backup storage is a realistic, high-value target and is often not subject to strong cryptographic integrity checks beyond waypoints (which do not protect against valid, but malicious, WriteSet state).

## Likelihood Explanation
**Medium-to-High Likelihood** due to:

- Backup stores are frequent targets, often vulnerable to accidental misconfiguration or direct attack.
- The backup/restore process is a standard administrative operation—restores are not rare.
- There is no defense in depth: a successful backup compromise is sufficient for exploit.
- Restoration does not enforce or certify the legitimacy of WriteSets beyond cryptographic hashes, not their semantic/authz correctness.
- Attack complexity is moderate: attacker needs only to craft a WriteSet and compromise the backup data before restore.

## Recommendation

- Implement strict validation of WriteSets on restore, using the same access control and state invariant checks as the Move VM does during normal transaction execution.
- Prevent any modifications via restore to protected system addresses except under extremely strict, explicitly-audited administrative procedures.
- Add cryptographic attestation of acceptable WriteSets/bulk data for restore, ideally verified under quorum.

Example fix: introduce a validation stage that re-executes WriteSets in a dry-run VM mode or cross-checks resource access against system address policies before committing to storage in restore path.

## Proof of Concept

1. Craft a backup transaction in which the WriteSet includes a direct modification to a protected resource, e.g., grant coin minting to a non-privileged account by altering a resource under `@aptos_framework`.
2. Replace the WriteSet file in S3/backup location with the malicious file.
3. Restore a test node from this backup.
4. Observe that the state change is present: the account is now able to mint despite having never passed through the normal Move module/VM access control logic.

This results in unauthorized state transition that would be impossible via the public transaction APIs.

--- [1](#0-0) [2](#0-1) 

Notes:
- The proof-of-concept above conceptually illustrates the exploit; for mainnet reproducibility, the move and replace steps must use realistically formatted WriteSets and backups compatible with the current restore logic.
- This attack is not a network-layer DoS and requires no trusted-role compromise, so fits bounty scope.
- The severity may rise to "Critical" if chain splits or unrecoverable loss are demonstrated.
- If recent code/tree changes mitigate this (by, e.g., validating WriteSets), then this report would no longer be valid; this assessment covers code as cited.

### Citations

**File:** storage/backup/backup-cli/src/restore/restore_utils.rs (L242-303)
```rust

```

**File:** storage/aptosdb/src/write_set_db.rs (L87-100)
```rust

```
