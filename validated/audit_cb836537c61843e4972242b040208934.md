# Audit Report

## Title
Equivocation Detection Failure After Node Restart Due to Non-Persisted State in UnequivocalProposerElection

## Summary
The `UnequivocalProposerElection` component fails to persist its `already_proposed` state, causing equivocation detection to fail after node restarts. This allows Byzantine proposers to insert multiple conflicting blocks for the same round into the BlockStore, violating the stated contract of preventing duplicate proposals.

## Finding Description

The `UnequivocalProposerElection` wrapper is designed to detect and reject equivocating proposals by maintaining an `already_proposed` field that tracks the last valid proposal per round. [1](#0-0) 

However, this state is initialized to `(0, HashValue::zero())` in the constructor and is never persisted or restored from storage: [2](#0-1) 

The validation logic accepts proposals when the block's round is greater than the stored round: [3](#0-2) 

The `PersistentLivenessStorage` trait has no methods to persist or restore the `already_proposed` state: [4](#0-3) 

**Attack Flow:**
1. Proposer sends block B1 for round R, which passes `is_valid_proposal()` validation at: [5](#0-4) 

2. Block B1 is inserted into BlockStore: [6](#0-5) 

3. Node restarts, `already_proposed` resets to `(0, HashValue::zero())`
4. Node recovers blocks from storage via `RecoveryData`: [7](#0-6) 

5. Proposer sends equivocating block B2 for same round R
6. Since R > 0, `is_valid_proposal()` accepts B2
7. BlockTree inserts B2 despite B1 existing, only logging a warning: [8](#0-7) 

Note that SafetyRules prevents voting on B2 because voting state IS persisted: [9](#0-8) 

However, both conflicting blocks remain in BlockStore, violating the design contract.

## Impact Explanation

**Medium Severity** - This qualifies as a "Limited Protocol Violation" under the Aptos Bug Bounty program because:

1. **State Inconsistency**: Different nodes will have inconsistent views of valid blocks for a given round after restarts, directly violating the stated contract that the system "rejects if the same leader proposes multiple blocks" [10](#0-9) 

2. **Defense-in-Depth Failure**: While SafetyRules provides the ultimate protection against voting on equivocating blocks, the equivocation detection layer completely fails its intended purpose after restarts

3. **Resource Exhaustion**: A malicious proposer can force nodes to store multiple equivocating blocks per round after restart events, leading to storage bloat

**NOT Critical** because:
- Consensus safety is maintained by SafetyRules (persisted voting state prevents double-voting)
- No direct fund loss occurs
- No chain split or permanent liveness failure
- System can continue operating

## Likelihood Explanation

**Medium-High Likelihood**:

1. **Natural Occurrence**: Node restarts happen regularly in production environments (software upgrades, crashes, maintenance operations)
2. **Low Prerequisites**: Attack requires only being a proposer for specific rounds (within standard Byzantine fault model of < 1/3 validators)
3. **No Coordination**: Exploit doesn't require collusion with other validators
4. **Observable but Tolerated**: The BlockTree logs warnings but continues to accept and store equivocating blocks, allowing the attack to succeed

## Recommendation

Persist the `already_proposed` state to durable storage and restore it during node initialization:

1. Add methods to `PersistentLivenessStorage` trait:
   - `save_last_proposed(round: Round, block_id: HashValue) -> Result<()>`
   - `recover_last_proposed() -> Option<(Round, HashValue)>`

2. Update `UnequivocalProposerElection::new()` to accept optional recovery state:
   - Restore `already_proposed` from persisted state if available
   - Otherwise, initialize from the highest block round in recovered `RecoveryData`

3. Call `save_last_proposed()` whenever `is_valid_proposal()` updates the state

This ensures equivocation detection works correctly across restarts while maintaining the defense-in-depth model.

## Proof of Concept

The vulnerability can be verified by examining the test that demonstrates the expected behavior: [11](#0-10) 

This test confirms that duplicate proposals should be rejected. However, after a simulated restart (creating a new `UnequivocalProposerElection` instance), the same validation would accept equivocating blocks because the state resets to `(0, HashValue::zero())`.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L14-21)
```rust
// Wrapper around ProposerElection.
//
// Provides is_valid_proposal that remembers, and rejects if
// the same leader proposes multiple blocks.
pub struct UnequivocalProposerElection {
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    already_proposed: Mutex<(Round, HashValue)>,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L35-40)
```rust
    pub fn new(proposer_election: Arc<dyn ProposerElection + Send + Sync>) -> Self {
        Self {
            proposer_election,
            already_proposed: Mutex::new((0, HashValue::zero())),
        }
    }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L63-68)
```rust
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
```

**File:** consensus/src/persistent_liveness_storage.rs (L33-47)
```rust
pub trait PersistentLivenessStorage: Send + Sync {
    /// Persist the blocks and quorum certs into storage atomically.
    fn save_tree(&self, blocks: Vec<Block>, quorum_certs: Vec<QuorumCert>) -> Result<()>;

    /// Delete the corresponding blocks and quorum certs atomically.
    fn prune_tree(&self, block_ids: Vec<HashValue>) -> Result<()>;

    /// Persist consensus' state
    fn save_vote(&self, vote: &Vote) -> Result<()>;

    /// Construct data that can be recovered from ledger
    fn recover_from_ledger(&self) -> LedgerRecoveryData;

    /// Construct necessary data to start consensus.
    fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData;
```

**File:** consensus/src/persistent_liveness_storage.rs (L332-345)
```rust
pub struct RecoveryData {
    // The last vote message sent by this validator.
    last_vote: Option<Vote>,
    root: RootInfo,
    root_metadata: RootMetadata,
    // 1. the blocks guarantee the topological ordering - parent <- child.
    // 2. all blocks are children of the root.
    blocks: Vec<Block>,
    quorum_certs: Vec<QuorumCert>,
    blocks_to_prune: Option<Vec<HashValue>>,

    // Liveness data
    highest_2chain_timeout_certificate: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/round_manager.rs (L1256-1259)
```rust
        self.block_store
            .insert_block(proposal.clone())
            .await
            .context("[RoundManager] Failed to insert the block into BlockStore")?;
```

**File:** consensus/src/block_storage/block_tree.rs (L326-335)
```rust
            // Note: the assumption is that we have/enforce unequivocal proposer election.
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election_test.rs (L92-98)
```rust
    assert!(pe.is_valid_proposal(&good_proposal));
    assert!(!pe.is_valid_proposal(&bad_author_proposal));

    // another proposal from the valid proposer should fail
    assert!(!pe.is_valid_proposal(&bad_duplicate_proposal));
    // good proposal still passes
    assert!(pe.is_valid_proposal(&good_proposal));
```
