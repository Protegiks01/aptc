# Audit Report

## Title
Race Condition in Reconfiguration Notification Processing Causes Validators to Use Wrong On-Chain Configs for Epochs

## Summary
A race condition exists where state sync fetches the latest pre-committed storage version instead of the version corresponding to reconfiguration events being processed. This allows validators to receive on-chain configuration data from an incorrect epoch, potentially causing consensus safety violations.

## Finding Description

The vulnerability stems from a critical design flaw in the notification flow between consensus and state sync:

**Missing Version Information in Notifications:**

The `ConsensusCommitNotification` struct contains only transactions and subscribable events, with no version field. [1](#0-0) 

**Independent Version Query by State Sync:**

When processing commit notifications, state sync independently queries storage for the latest pre-committed version through `handle_committed_transactions`: [2](#0-1) 

This function calls `fetch_pre_committed_version` to get the current storage version: [3](#0-2) 

**Pre-Committed Version Returns Latest State Store Version:**

The `fetch_pre_committed_version()` function returns the current version from the state store: [4](#0-3) 

This calls the underlying storage implementation: [5](#0-4) 

**Wrong Version Used for Config Reads:**

When a reconfiguration event is detected, this independently-fetched version is used to read on-chain configs: [6](#0-5) 

The event subscription service then reads configs at the specified version: [7](#0-6) 

The `read_on_chain_configs` function reads `ConfigurationResource` at the specified version to extract the epoch and configs: [8](#0-7) 

**Race Condition Mechanism:**

The pipeline architecture allows this race because Block B2's `pre_commit_fut` only waits for Block B1's `pre_commit_fut`, NOT for B1's `notify_state_sync_fut`: [9](#0-8) [10](#0-9) 

When pre-commit completes, it updates the state store version: [11](#0-10) 

The notification is sent asynchronously without waiting for processing: [12](#0-11) 

**Execution Flow:**

1. Block B1 (version 100) with reconfiguration event R1 pre-commits → state store updated to v100
2. B1's `notify_state_sync` sends notification N1 asynchronously
3. Block B2 (version 105) with reconfiguration event R2 pre-commits → state store updated to v105
4. State sync processes N1:
   - Fetches pre-committed version → gets 105
   - Detects R1 reconfiguration event
   - Reads `ConfigurationResource` at version 105 → gets configs from wrong epoch
   - Sends wrong epoch configs to validators

This violates the invariant that reconfiguration notifications must contain configs from the version where the reconfiguration event occurred.

## Impact Explanation

**Critical Severity** - This constitutes a consensus safety violation per Aptos bug bounty criteria:

1. **Validator Set Mismatch**: Validators receive the wrong validator set for an epoch, breaking quorum formation requirements
2. **Epoch Confusion**: Validators may skip epochs entirely
3. **Block Signature Verification Failures**: Blocks signed with one epoch's validator set would fail verification by validators using another epoch's validator set
4. **Consensus Liveness Loss**: Validators operating with mismatched epoch configurations cannot reach consensus on blocks
5. **Potential Chain Split**: Different validators processing notifications at different timing could end up on different epoch states

The vulnerability affects all validators network-wide and requires no attacker action - it can occur naturally during rapid epoch transitions or back-to-back governance proposals.

## Likelihood Explanation

**Medium Likelihood:**

1. **No Synchronization**: The pipeline architecture explicitly allows B2's pre-commit to proceed while B1's notification is in flight
2. **Natural Trigger**: Rapid epoch changes from governance proposals or validator set updates can trigger this without malicious intent
3. **Async Channel Buffering**: Notifications are sent via unbounded async channels, creating a timing window where commits can outpace notification processing

While the timing window for this race condition is small and epochs typically last days/weeks, the catastrophic impact when it occurs justifies classification as a critical vulnerability requiring immediate remediation.

## Recommendation

Add version information to `ConsensusCommitNotification` and use that version (rather than independently querying storage) when reading on-chain configs for reconfiguration events. This ensures notifications always reference the correct epoch's configuration data.

Alternatively, ensure that `notify_state_sync` completes processing before the next block's pre-commit can update the state store version.

## Proof of Concept

The race condition can be observed by examining the execution flow during back-to-back epoch changes. A reproduction would require:
1. Two consecutive blocks with reconfiguration events
2. Monitoring state sync notification processing
3. Observing that configs read during notification processing correspond to a different version than the notification's events

## Notes

This vulnerability represents a fundamental design flaw in the notification flow architecture where version information is decoupled from the events being processed. The fix requires either adding version information to notifications or implementing stronger synchronization guarantees between consensus and state sync.

### Citations

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L293-298)
```rust
#[derive(Debug)]
pub struct ConsensusCommitNotification {
    transactions: Vec<Transaction>,
    subscribable_events: Vec<ContractEvent>,
    callback: oneshot::Sender<ConsensusNotificationResponse>,
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L334-341)
```rust
        utils::handle_committed_transactions(
            committed_transactions,
            self.storage.clone(),
            self.mempool_notification_handler.clone(),
            self.event_subscription_service.clone(),
            self.storage_service_notification_handler.clone(),
        )
        .await;
```

**File:** state-sync/state-sync-driver/src/utils.rs (L280-284)
```rust
pub fn fetch_pre_committed_version(storage: Arc<dyn DbReader>) -> Result<Version, Error> {
    storage.ensure_pre_committed_version().map_err(|e| {
        Error::StorageError(format!("Failed to get latest version from storage: {e:?}"))
    })
}
```

**File:** state-sync/state-sync-driver/src/utils.rs (L325-353)
```rust
pub async fn handle_committed_transactions<
    M: MempoolNotificationSender,
    S: StorageServiceNotificationSender,
>(
    committed_transactions: CommittedTransactions,
    storage: Arc<dyn DbReader>,
    mempool_notification_handler: MempoolNotificationHandler<M>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    storage_service_notification_handler: StorageServiceNotificationHandler<S>,
) {
    // Fetch the latest synced version and ledger info from storage
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L106-110)
```rust
        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L281-307)
```rust
    fn read_on_chain_configs(
        &self,
        version: Version,
    ) -> Result<OnChainConfigPayload<DbBackedOnChainConfig>, Error> {
        let db_state_view = &self
            .storage
            .read()
            .reader
            .state_view_at_version(Some(version))
            .map_err(|error| {
                Error::UnexpectedErrorEncountered(format!(
                    "Failed to create account state view {:?}",
                    error
                ))
            })?;
        let epoch = ConfigurationResource::fetch_config(&db_state_view)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Configuration resource does not exist!".into())
            })?
            .epoch();

        // Return the new on-chain config payload (containing all found configs at this version).
        Ok(OnChainConfigPayload::new(
            epoch,
            DbBackedOnChainConfig::new(self.storage.read().reader.clone(), version),
        ))
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L316-325)
```rust
        // Notify event subscribers and check if a reconfiguration event was processed
        let reconfig_event_processed = self.notify_event_subscribers(version, events)?;

        // If a reconfiguration event was found, also notify the reconfig subscribers
        // of the new configuration values.
        if reconfig_event_processed {
            self.notify_reconfiguration_subscribers(version)
        } else {
            Ok(())
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L535-546)
```rust
        let pre_commit_fut = spawn_shared_fut(
            Self::pre_commit(
                ledger_update_fut.clone(),
                parent.pre_commit_fut.clone(),
                order_proof_fut.clone(),
                commit_proof_fut.clone(),
                self.executor.clone(),
                block.clone(),
                self.pre_commit_status(),
            ),
            None,
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L567-576)
```rust
        let notify_state_sync_fut = spawn_shared_fut(
            Self::notify_state_sync(
                pre_commit_fut.clone(),
                commit_ledger_fut.clone(),
                parent.notify_state_sync_fut.clone(),
                self.state_sync_notifier.clone(),
                block.clone(),
            ),
            None,
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1147-1177)
```rust
    async fn notify_state_sync(
        pre_commit_fut: TaskFuture<PreCommitResult>,
        commit_ledger_fut: TaskFuture<CommitLedgerResult>,
        parent_notify_state_sync_fut: TaskFuture<PostCommitResult>,
        state_sync_notifier: Arc<dyn ConsensusNotificationSender>,
        block: Arc<Block>,
    ) -> TaskResult<NotifyStateSyncResult> {
        let mut tracker = Tracker::start_waiting("notify_state_sync", &block);
        let compute_result = pre_commit_fut.await?;
        parent_notify_state_sync_fut.await?;
        // if commit ledger is aborted, it's typically an abort caused by reset to fall back to state sync
        // we want to finish notifying already pre-committed txns before go into state sync
        // so only return if there's internal error from commit ledger
        if let Err(e @ TaskError::InternalError(_)) = commit_ledger_fut.await {
            return Err(TaskError::PropagatedError(Box::new(e)));
        }

        tracker.start_working();
        let txns = compute_result.transactions_to_commit().to_vec();
        let subscribable_events = compute_result.subscribable_events().to_vec();
        if let Err(e) = monitor!(
            "notify_state_sync",
            state_sync_notifier
                .notify_new_commit(txns, subscribable_events)
                .await
        ) {
            error!(error = ?e, "Failed to notify state synchronizer");
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L68-72)
```rust
            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;
```
