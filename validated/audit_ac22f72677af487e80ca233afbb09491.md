# Audit Report

## Title
JWK Observer Lifecycle Race Condition Enables Governance Bypass

## Summary
The JWK consensus system maintains a fixed set of observers per epoch that cannot be modified during runtime. When governance removes an issuer mid-epoch via `remove_issuer_from_observed_jwks()`, the corresponding observer continues running and immediately recreates the removed state, completely bypassing the governance action until the next epoch boundary.

## Finding Description

The JWK consensus manager maintains two critical data structures with mismatched lifecycles:

1. **`jwk_observers: Vec<JWKObserver>`** - Spawned once per epoch at the start of the `run()` method and stored as an immutable vector field [1](#0-0) . Observers are created from on-chain OIDC provider configuration [2](#0-1) .

2. **`states_by_issuer: HashMap<Issuer, PerProviderState>`** - Can change mid-epoch via on-chain events [3](#0-2) .

Each observer runs independently in a separate tokio task, periodically fetching JWKs every 10 seconds [4](#0-3) . Observers are only torn down when the epoch ends [5](#0-4)  via a close signal from the epoch manager [6](#0-5) .

When governance calls `remove_issuer_from_observed_jwks()` to remove a compromised OIDC provider [7](#0-6) , it removes the issuer from on-chain state and emits an `ObservedJWKsUpdated` event [8](#0-7) .

This event triggers `reset_with_on_chain_state()` in all validators [9](#0-8) , which removes the issuer from the local `states_by_issuer` HashMap [10](#0-9) .

**The Race Condition:** The observer for the removed issuer continues running. When it sends a new observation, `process_new_observation()` recreates the state using `.or_default()` [11](#0-10) .

The default `PerProviderState` has `on_chain: None` [12](#0-11) , causing `on_chain_version()` to return 0 [13](#0-12) .

A new observation with version 1 is created [14](#0-13) , reaches quorum, and is submitted as a validator transaction.

The validator transaction validation also uses `.or_insert_with()` to create a version 0 entry if the issuer doesn't exist [15](#0-14) . The version check `if on_chain.version + 1 != observed.version` passes because 0 + 1 == 1 [16](#0-15) , allowing the removed issuer to be immediately re-added to on-chain state, completely bypassing governance's removal action.

## Impact Explanation

This vulnerability breaks the **Governance Integrity** invariant and constitutes a **Medium Severity** issue per Aptos bug bounty criteria:

**Medium Severity Factors:**
- State inconsistencies requiring manual intervention (must wait for epoch boundary)
- Governance decisions can be bypassed until next epoch
- Security incident response is delayed (cannot immediately remove compromised OIDC providers)
- Resource waste as validators continue processing unwanted issuers

**Potential High Severity in Real Scenarios:**
- If a compromised OIDC provider is discovered, governance cannot immediately stop its JWKs from being used
- The system continues accepting authentication tokens from the compromised provider
- Could lead to unauthorized access if the provider's keys are compromised

This meets the Medium Severity criteria: "State inconsistencies requiring intervention" and governance bypass requiring epoch-level recovery to resolve.

## Likelihood Explanation

**Likelihood: High**

This occurs automatically and deterministically whenever governance attempts to remove an issuer mid-epoch:
- No special attacker actions required beyond normal governance operations
- The race condition is deterministic: observers always continue running until epoch end
- Affects all validators simultaneously
- Reproducible with standard governance calls

The issue manifests during legitimate operational scenarios:
- Emergency removal of compromised OIDC providers
- Decommissioning deprecated authentication providers  
- Security incident response requiring immediate issuer removal

## Recommendation

Implement one of the following fixes:

**Option 1: Stop observers when issuer removed**
When `reset_with_on_chain_state()` removes an issuer from `states_by_issuer`, also shut down the corresponding observer in `jwk_observers`. This requires making observers individually controllable.

**Option 2: Check on-chain state before processing observation**
In `process_new_observation()`, verify the issuer still exists in the on-chain configuration before creating a new proposal. Reject observations for removed issuers.

**Option 3: Track removed issuers**
Maintain a separate set of explicitly removed issuers that prevents `.or_default()` from recreating their state. Clear this set at epoch boundaries.

Recommended fix (Option 2):
```rust
pub fn process_new_observation(&mut self, issuer: Issuer, jwks: Vec<JWKMoveStruct>) -> Result<()> {
    // Check if issuer was explicitly removed
    if !self.is_issuer_in_on_chain_config(&issuer) {
        return Ok(()); // Silently ignore observations for removed issuers
    }
    let state = self.states_by_issuer.entry(issuer.clone()).or_default();
    // ... rest of function
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following sequence:

1. Start epoch N with issuer "test.provider.com" in configuration
2. Observer spawned for "test.provider.com" 
3. Mid-epoch: Governance calls `remove_issuer_from_observed_jwks(fx, b"test.provider.com")`
4. All validators remove "test.provider.com" from `states_by_issuer`
5. Observer continues running, fetches JWKs after ~10 seconds
6. `process_new_observation()` called with "test.provider.com"
7. Line 194 uses `.or_default()`, recreating state with version 0
8. New proposal created with version 1
9. Proposal reaches quorum and submitted to validators
10. Validator validation creates version 0 entry, check passes (0+1==1)
11. "test.provider.com" re-added to on-chain state with version 1
12. Governance removal completely bypassed until epoch N+1

## Notes

This is a logic vulnerability in the state management design where two subsystems (observer lifecycle and state management) have mismatched lifecycles. The governance system assumes issuer removal is immediate, but the observer continues producing updates that recreate the removed state. The validation layer compounds this by also treating missing issuers as new issuers with version 0, making the bypass automatic and deterministic.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L54-54)
```rust
    states_by_issuer: HashMap<Issuer, PerProviderState>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L61-61)
```rust
    jwk_observers: Vec<JWKObserver>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-143)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L170-181)
```rust
    async fn tear_down(&mut self, ack_tx: Option<oneshot::Sender<()>>) -> Result<()> {
        self.stopped = true;
        let futures = std::mem::take(&mut self.jwk_observers)
            .into_iter()
            .map(JWKObserver::shutdown)
            .collect::<Vec<_>>();
        join_all(futures).await;
        if let Some(tx) = ack_tx {
            let _ = tx.send(());
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L194-194)
```rust
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-201)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L252-253)
```rust
        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L361-366)
```rust
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct PerProviderState {
    pub on_chain: Option<ProviderJWKs>,
    pub observed: Option<Vec<JWKMoveStruct>>,
    pub consensus_state: ConsensusState<ObservedUpdate>,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L51-90)
```rust
    async fn start(
        fetch_interval: Duration,
        my_addr: AccountAddress,
        issuer: String,
        open_id_config_url: String,
        observation_tx: aptos_channel::Sender<(), (Issuer, Vec<JWK>)>,
        close_rx: oneshot::Receiver<()>,
    ) {
        let mut interval = tokio::time::interval(fetch_interval);
        interval.set_missed_tick_behavior(MissedTickBehavior::Delay);
        let mut close_rx = close_rx.into_stream();
        let my_addr = if cfg!(feature = "smoke-test") {
            // Include self validator address in JWK request,
            // so dummy OIDC providers in smoke tests can do things like "key A for validator 1, key B for validator 2".
            Some(my_addr)
        } else {
            None
        };

        loop {
            tokio::select! {
                _ = interval.tick().fuse() => {
                    let timer = Instant::now();
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
                    } else {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "err"]).observe(secs);
                    }
                },
                _ = close_rx.select_next_some() => {
                    break;
                }
            }
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L259-274)
```rust
    async fn on_new_epoch(&mut self, reconfig_notification: ReconfigNotification<P>) -> Result<()> {
        self.shutdown_current_processor().await;
        self.start_new_epoch(reconfig_notification.on_chain_configs)
            .await?;
        Ok(())
    }

    async fn shutdown_current_processor(&mut self) {
        if let Some(tx) = self.jwk_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            let _ = tx.send(ack_tx);
            let _ = ack_rx.await;
        }

        self.jwk_updated_event_txs = None;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L117-119)
```rust
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```
