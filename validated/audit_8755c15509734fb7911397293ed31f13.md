# Audit Report

## Title
Metadata Validation Bypass for Version 5 Modules via Inconsistent Attribute Clearing

## Summary
Module metadata validation can be bypassed for version 5 modules due to an inconsistency between two metadata extraction functions. `get_metadata_from_compiled_code()` clears attributes during validation while `get_metadata()` preserves them at runtime, allowing invalid metadata to be stored on-chain and used during execution.

## Finding Description

The vulnerability exists due to inconsistent handling of version 5 module metadata between validation and runtime phases.

During module publishing validation, `verify_module_metadata_for_module_publishing()` calls `get_metadata_from_compiled_code()` which contains special handling for version 5 modules: [1](#0-0) 

This code clears `struct_attributes` and `fun_attributes` for version 5 modules before validation occurs. As a result, the subsequent validation logic that checks attribute validity never executes: [2](#0-1) 

The module is stored on-chain with its original metadata intact, as confirmed by the publishing flow storing the original `module_bytes` without modification: [3](#0-2) 

At runtime, when metadata is accessed for resource group determination, the system uses `get_metadata()` which does NOT clear version 5 attributes: [4](#0-3) 

This runtime metadata is used to determine resource group membership and storage paths: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a version 5 module with invalid resource group member metadata (struct without the `Key` ability)
2. During publishing, `get_metadata_from_compiled_code()` clears the attributes  
3. Validation finds no attributes to validate and passes
4. Module is stored on-chain with original invalid metadata
5. At runtime, `get_metadata()` extracts the invalid attributes without clearing
6. Invalid metadata determines incorrect storage access paths for resource groups

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

**State Inconsistencies:** Invalid resource group metadata could cause incorrect state access patterns, potentially leading to state inconsistencies that require manual intervention to resolve. The validation that ensures resource group members have the `Key` ability is bypassed: [6](#0-5) 

**Validation Bypass:** The core security guarantee of metadata validation is circumvented, allowing structs to be marked as resource group members without meeting the required constraints.

**Potential Consensus Impact:** If invalid metadata causes different execution paths on different validators, this could lead to consensus divergence where validators produce different state roots for the same block.

The impact is limited to Medium rather than Critical because:
- Only affects version 5 modules (though version 5 is the minimum supported version)
- View function validation has runtime checks that mitigate that attack vector
- Does not directly enable fund theft or network partition
- Impact is primarily state inconsistencies requiring manual intervention

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **No special privileges required:** Any user can publish modules
2. **Version 5 is supported:** It remains the minimum supported version: [7](#0-6) 

3. **Fallback to version 5:** When no VM_BINARY_FORMAT feature flags are enabled, the system defaults to version 5: [8](#0-7) 

4. **Simple to execute:** Attacker needs to compile a module as version 5 with invalid metadata attributes
5. **No detection during publishing:** The validation silently passes due to cleared attributes
6. **Guaranteed storage on-chain:** The invalid metadata will be stored and accessible at runtime

The main barrier is that attackers must explicitly compile modules with version 5 bytecode rather than using the default version 9.

## Recommendation

Apply consistent metadata handling across validation and runtime by either:

1. **Remove version 5 attribute clearing** in `get_metadata_from_compiled_code()` and enforce proper validation for all versions
2. **Apply version 5 clearing in both functions** - clear attributes in `get_metadata()` as well to maintain consistency
3. **Deprecate version 5 support** and increase VERSION_MIN to VERSION_6 where metadata was properly supported

The preferred solution is option 1 - remove the special-case clearing and ensure validation works correctly for version 5 modules.

## Proof of Concept

```move
// Compile this module with bytecode version 5
module attacker::exploit {
    use std::string::String;
    
    // Struct WITHOUT Key ability but marked as resource_group_member
    #[resource_group_member(group = 0x1::some_group::Container)]
    struct InvalidMember {
        value: u64
    }
    
    // During publishing:
    // - get_metadata_from_compiled_code() clears the resource_group_member attribute
    // - Validation passes because no attributes to check
    // - Module stored with original metadata
    
    // At runtime:
    // - get_metadata() extracts resource_group_member attribute
    // - System attempts to use InvalidMember as resource group member
    // - Incorrect storage paths computed despite lacking Key ability
}
```

**Notes:**
- This vulnerability affects resource group member validation specifically
- View function validation has runtime checks that mitigate the view function aspect
- The inconsistency between validation-time and runtime metadata extraction creates a validation bypass
- Version 5 remains supported as VERSION_MIN, making this exploitable on current networks

### Citations

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L423-439)
```rust
pub fn is_valid_resource_group_member(
    structs: &BTreeMap<&IdentStr, (&StructHandle, &StructDefinition)>,
    struct_: &str,
) -> Result<(), AttributeValidationError> {
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, _struct_def)) = structs.get(ident_struct.as_ident_str()) {
            if struct_handle.abilities.has_ability(Ability::Key) {
                return Ok(());
            }
        }
    }

    Err(AttributeValidationError {
        key: struct_.to_string(),
        attribute: KnownAttributeKind::ViewFunction as u8,
    })
}
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L202-205)
```rust
            let prev = account_module_storage.insert(
                compiled_module.self_name().to_owned(),
                (module_bytes, compiled_module.clone()),
            );
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L562-562)
```rust
pub const VERSION_MIN: u32 = VERSION_5;
```

**File:** types/src/on_chain_config/aptos_features.rs (L496-498)
```rust
        } else {
            file_format_common::VERSION_5
        }
```
