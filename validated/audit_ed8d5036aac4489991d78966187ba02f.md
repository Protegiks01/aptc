# Audit Report

## Title
Non-Deterministic Layout Validation Causes Consensus Split Vulnerability

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic randomness (`rand::thread_rng()`) to perform layout validation only 1% of the time during transaction execution. This creates a consensus vulnerability where different validators executing identical transactions can produce different outcomes, violating the fundamental deterministic execution invariant required for blockchain consensus safety.

## Finding Description

The vulnerability exists in the `randomly_check_layout_matches()` function which performs critical layout validation during change set squashing operations in consensus-critical transaction execution paths.

**Non-Deterministic Implementation:**

The function uses `rand::thread_rng()` to generate random numbers independently on each validator, checking layout equality only when `random_number == 1` (1% probability): [1](#0-0) 

**Consensus-Critical Execution Paths:**

This non-deterministic check is invoked during transaction execution in multiple critical paths:

1. **Change Set Squashing** - Called when squashing resource write operations: [2](#0-1) 

2. **Delayed Fields Squashing** - Called when combining WriteWithDelayedFields operations: [3](#0-2) 

3. **Session Finalization** - Used in prologue, user, and epilogue session finalization: [4](#0-3) [5](#0-4) [6](#0-5) 

4. **Block Executor** - Used during delayed field materialization: [7](#0-6) 

**Failure Propagation:**

When the layout check detects a mismatch, it returns an error that propagates as `UNKNOWN_INVARIANT_VIOLATION_ERROR`: [8](#0-7) 

**Attack Scenario:**

When any condition causes mismatched layouts during change set squashing (whether due to bugs, edge cases, or malicious transaction crafting):

- **Validator A** (99% probability): Generates random number ≠ 1 → no validation → transaction succeeds → produces state root A
- **Validator B** (1% probability): Generates random number = 1 → validation runs → detects mismatch → transaction fails with error → produces different state root B

The Aptos consensus protocol requires validators to collectively sign "the resulting state of a block rather than just the sequence of transactions": [9](#0-8) 

When 99% of validators produce state root A and reach 2f+1 quorum, they commit the block. The remaining 1% of validators have divergent state, creating a network partition.

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability meets the **Critical Severity** criteria per Aptos Bug Bounty for **Consensus/Safety Violations**:

1. **Different validators execute identical transactions to different results** - The non-deterministic check causes validators to produce different state roots for the same block input
2. **Non-recoverable network partition** - Validators with divergent state cannot reconcile without manual intervention or hard fork
3. **Violates fundamental consensus invariant** - Aptos architecture documentation explicitly states that deterministic execution is required for all validators to maintain identical databases

**Scope of Damage:**
- Network partition when ~1% of validators reject transactions that ~99% accept
- Loss of consensus finality for affected validators
- Potential chain halt requiring emergency coordination
- State inconsistency requiring manual recovery procedures

The probabilistic nature (1% detection rate) makes this particularly dangerous as it may not manifest during testing but can cause production failures under real-world conditions.

## Likelihood Explanation

**Likelihood: Medium**

The likelihood depends on whether layout mismatches can occur during normal operation:

1. **Defensive Check Indicates Known Risk** - The presence of this check with the comment "layouts are supposed to match" suggests developers anticipated potential mismatches as an edge case or bug scenario

2. **Trigger Conditions** exist for layout mismatches:
   - Module upgrade timing during transaction execution
   - Resource group layout computation edge cases  
   - Delayed field materialization inconsistencies
   - Parallel execution race conditions

3. **Test Coverage Gaps** - Test comments indicate incomplete layout testing: [10](#0-9) 

4. **No Privilege Required** - Affects normal transaction execution; any transaction that triggers layout mismatches can cause the vulnerability

5. **Detection Difficulty** - The 99% pass rate means bugs causing layout mismatches may go undetected in testing, only manifesting rarely in production when the 1% check triggers

## Recommendation

**Immediate Fix: Remove Non-Determinism**

Replace `rand::thread_rng()` with deterministic validation. Since this is a defensive check for invariant violations, options include:

1. **Always validate** (safest but performance impact):
```rust
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

2. **Remove check entirely** if layouts are guaranteed to match by construction (requires careful analysis)

3. **Deterministic sampling** based on block height or transaction hash (still maintains determinism across validators)

## Proof of Concept

While a complete PoC would require constructing a scenario that causes layout mismatches, the vulnerability can be demonstrated by:

1. Observing that `rand::thread_rng()` generates different random values on different validator nodes
2. Constructing a transaction that causes layout mismatches during change set squashing
3. Executing the same transaction on multiple validator instances
4. Observing that ~1% of validators fail with `UNKNOWN_INVARIANT_VIOLATION_ERROR` while ~99% succeed
5. Verifying different validators produce different state roots for the identical block

The core issue is the non-deterministic randomness in consensus-critical code, which is evident from the code citations above without requiring a full executable PoC.

## Notes

This vulnerability represents a fundamental violation of blockchain consensus safety guarantees. The use of non-deterministic randomness (`rand::thread_rng()`) in any consensus-critical execution path is inherently unsafe for distributed systems requiring Byzantine fault tolerance. Even if layout mismatches are rare in practice, the non-deterministic behavior creates a permanent risk of consensus splits that could manifest under unexpected conditions in production.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L64-71)
```rust
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L534-537)
```rust
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L588-588)
```rust
                            randomly_check_layout_matches(Some(layout), Some(additional_layout))?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L68-72)
```rust
            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L188-192)
```rust
        let change_set = session.finish_with_squashed_change_set(
            change_set_configs,
            &staging_module_storage,
            false,
        )?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L115-116)
```rust
        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, true)?;
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L64-64)
```rust
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L100-107)
```rust
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
```

**File:** consensus/README.md (L23-24)
```markdown
In AptosBFT, validators receive transactions from clients and share them with each other through a shared mempool protocol. The AptosBFT protocol then proceeds in a sequence of rounds. In each round, a validator takes the role of leader and proposes a block of transactions to extend a certified sequence of blocks (see quorum certificates below) that contain the full previous transaction history. A validator receives the proposed block and checks their voting rules to determine if it should vote for certifying this block. These simple rules ensure the safety of AptosBFT — and their implementation can be cleanly separated and audited. If the validator intends to vote for this block, it executes the block’s transactions speculatively and without external effect. This results in the computatio ... (truncated)

```

**File:** aptos-move/aptos-vm-types/src/tests/test_change_set.rs (L875-875)
```rust
        // TODO[agg_v2](test): Hardcoding type layout to None. Test with layout = Some(..)
```
