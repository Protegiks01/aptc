# Audit Report

## Title
OnDiskStorage Lacks Durability Guarantees Enabling Consensus Double-Voting via Safety Data Reversion

## Summary

The `OnDiskStorage` implementation used for consensus safety data persistence lacks durability guarantees. The `write()` method performs file writes without calling `fsync`, allowing validator crashes to revert `last_voted_round` to older states. This enables double-voting that violates AptosBFT consensus safety guarantees.

## Finding Description

The vulnerability exists in the consensus safety rules persistence layer. SafetyRules enforces the first voting rule: validators can only vote on rounds strictly greater than their `last_voted_round`. [1](#0-0) 

Production validator configurations use OnDiskStorage as the safety rules backend. [2](#0-1) [3](#0-2) 

Despite README warnings about production use, the ConfigSanitizer explicitly allows OnDiskStorage for mainnet validators (only forbidding InMemoryStorage). [4](#0-3) 

The critical flaw is in the `write()` method which never calls `file.sync_all()` or `file.sync_data()` before the rename operation. [5](#0-4)  This means file contents may remain in OS buffers and not be flushed to disk before the operation completes.

**Attack Scenario:**

1. Validator votes on proposal at round 10
2. SafetyRules calls `set_safety_data()` to persist the updated state with `last_voted_round = 10` [6](#0-5) [7](#0-6) 
3. OnDiskStorage writes to temp file without fsync
4. **Crash/power loss** occurs before OS flushes data to disk
5. On restart, validator reads old `last_voted_round = 5` from disk
6. Validator receives proposal for round 8
7. The verification check `round > last_voted_round` evaluates to `8 > 5` which passes
8. Validator votes on round 8
9. **DOUBLE VOTE**: Validator has now voted on both round 10 and round 8 in the same epoch

The deduplication check only prevents voting on the same round twice, not voting on different rounds. [8](#0-7)  It checks if `vote.round() == proposed_block.round()`, which would be false for round 8 vs round 10.

## Impact Explanation

This is **CRITICAL** severity per Aptos bug bounty criteria:

**Consensus Safety Violation**: This directly violates AptosBFT's fundamental safety guarantee. The first voting rule requires validators to only vote on strictly increasing rounds. By voting on round 10 then round 8, the validator equivocates, breaking the monotonicity assumption that underpins consensus safety.

**Byzantine Behavior Without Malice**: The validator exhibits Byzantine behavior (equivocation) due to a software bug rather than malicious intent. This undermines the protocol's 1/3 Byzantine fault tolerance assumption, as honest validators are supposed to follow the voting rules correctly.

**Potential Chain Split**: If different validators observe different votes from the same validator across rounds, this could lead to divergent views of consensus state, potentially requiring manual intervention to resolve.

The vulnerability affects ALL validators using OnDiskStorage, which includes default validator configurations as evidenced by production YAML files.

## Likelihood Explanation

**MEDIUM to HIGH** likelihood:

1. **Confirmed Production Usage**: OnDiskStorage is used in official validator configurations [9](#0-8) 
2. **Natural Occurrence**: Validator crashes are expected in production environments (OOM conditions, kernel panics, power failures, software upgrades)
3. **No Compensating Controls**: No fsync, checksums, version checks, or write-ahead logging to prevent data loss
4. **File System Behavior**: Modern file systems buffer writes for performance, creating a timing window where crashes lose unflushed data

The vulnerability cannot be exploited by an attacker but occurs naturally through operational crashes, which are realistic in production validator environments.

## Recommendation

Implement durability guarantees in OnDiskStorage:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    file.sync_all()?;  // Add fsync before rename
    fs::rename(&self.temp_path, &self.file_path)?;
    // Optionally sync directory for rename atomicity
    Ok(())
}
```

Additionally, consider:
- Implementing write-ahead logging for crash recovery
- Adding version/sequence numbers to detect stale reads
- Updating ConfigSanitizer to require VaultStorage for production mainnet validators
- Updating documentation to clearly warn about durability issues

## Proof of Concept

While a full PoC would require simulating crashes, the vulnerability is demonstrable through code analysis:

1. **No fsync in write path**: Confirmed in code [5](#0-4) 
2. **Production usage**: Confirmed in configs [10](#0-9) 
3. **Safety rules enforcement**: Confirmed monotonicity check would pass after state reversion [11](#0-10) 
4. **Deduplication limitation**: Confirmed check only catches same-round duplicates [12](#0-11) 

The complete execution path from voting through persistence to restart is verifiable in the codebase.

## Notes

The README warns against production use but primarily cites lack of encryption and concurrent access support. [13](#0-12)  However, the durability issue (lack of fsync) is not explicitly documented, and production configurations actively use OnDiskStorage despite these warnings, suggesting this specific durability vulnerability may not be widely recognized.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L8-19)
```yaml
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-17)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-80)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L92-92)
```rust
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L621-623)
```rust
        let mut storage = OnDiskStorageConfig::default();
        storage.set_data_dir(validator.dir.clone());
        config.consensus.safety_rules.backend = SecureBackend::OnDiskStorage(storage);
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```
