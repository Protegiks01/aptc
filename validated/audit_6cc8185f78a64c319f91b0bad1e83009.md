# Audit Report

## Title
Consensus Divergence Due to Unimplemented get_usage() in RemoteStateViewClient

## Summary
The `RemoteStateViewClient` used in remote sharded execution has an unimplemented `get_usage()` method that panics, while `CachedStateView` used in local execution implements it properly. Since every block's prologue transaction calls this method via the native function `state_storage::get_state_storage_usage_only_at_epoch_beginning()`, validators configured for remote execution will panic on every block, causing consensus divergence.

## Finding Description

The sharded block executor supports two execution modes based on configuration:

**Local Execution Path:**
- Uses `LocalExecutorClient` which sends `ExecutorShardCommand` containing `Arc<CachedStateView>` to local executor shards [1](#0-0) 

- `CachedStateView` properly implements `TStateView::get_usage()` by returning the current state usage [2](#0-1) 

**Remote Execution Path:**
- Uses `RemoteExecutorClient` where remote shards create `ExecutorShardCommand` with `Arc<RemoteStateViewClient>` [3](#0-2) 

- **Critical Issue**: `RemoteStateViewClient::get_usage()` is unimplemented and panics [4](#0-3) 

**The Trigger:**

Every block's prologue transaction calls `block::block_prologue_common()` which invokes `state_storage::on_new_block()` [5](#0-4) 

This calls the native function `get_state_storage_usage_only_at_epoch_beginning()` when the epoch changes [6](#0-5) 

The native implementation calls `ctx.resolver.get_usage()` on the state storage view [7](#0-6) 

During VM execution, this delegates through `StorageAdapter` to the underlying executor view's `get_usage()` method [8](#0-7) 

**Result:** Validators using remote execution panic on every block's prologue at epoch boundaries, while validators using local execution succeed, breaking the deterministic execution invariant required for consensus.

## Impact Explanation

This is a **Critical Severity** vulnerability meeting the "Consensus/Safety Violations" and "Non-recoverable Network Partition" categories:

1. **Consensus Safety Violation**: Different validators produce different execution results (panic vs success) for identical blocks, violating the fundamental deterministic execution guarantee.

2. **Configuration-Based Network Partition**: Validators are split into two groups:
   - Validators with remote execution enabled: Crash on every block's prologue at epoch changes
   - Validators with local execution: Continue normally

3. **Requires Hardfork**: The divergence occurs at the protocol level in mandatory system transactions (block prologue), requiring a code fix and hardfork to resolve.

4. **Total Loss of Liveness** for affected validators: Remote execution validators cannot progress past epoch boundaries.

The remote execution feature can be enabled via `set_remote_addresses()` configuration [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment:

- The vulnerability triggers **automatically** at epoch boundaries for any validator configured with remote execution
- No attacker action required - this is a configuration-dependent deterministic bug  
- The feature exists in production code with configuration support [10](#0-9) 

- If any validator enables remote execution in production (via `--remote_executor_addresses` CLI flag), they will diverge from the network at the next epoch boundary

The only mitigating factor is if remote execution is not yet enabled in production deployments. However, the code path is production-ready and can be activated through standard configuration.

## Recommendation

Implement the `get_usage()` method in `RemoteStateViewClient` to fetch state storage usage from the coordinator's state view service, similar to how other state values are fetched:

```rust
fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
    // Fetch usage from the coordinator's RemoteStateViewService
    // This requires extending the RemoteKVRequest/Response protocol
    // to support usage queries, or returning a tracked/untracked
    // usage based on the remote execution model requirements
    Ok(StateStorageUsage::new_untracked())
}
```

Alternatively, if usage tracking is critical for remote shards, extend the `RemoteStateViewService` protocol to support querying usage information from the coordinator's state view.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring a validator node with remote execution enabled via `--remote_executor_addresses` 
2. Running the validator through an epoch boundary
3. Observing the panic when `RemoteStateViewClient::get_usage()` is called during the block prologue's `state_storage::on_new_block()` execution

The execution path is deterministic and requires no special transactions - it triggers automatically on the first block of a new epoch when `state_storage::on_new_block()` calls `get_state_storage_usage_only_at_epoch_beginning()`.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L193-200)
```rust
            self.command_txs[i]
                .send(ExecutorShardCommand::ExecuteSubBlocks(
                    state_view.clone(),
                    sub_blocks_for_shard,
                    concurrency_level_per_shard,
                    onchain_config.clone(),
                ))
                .unwrap();
```

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L299-301)
```rust
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        Ok(self.speculative.current.usage())
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L102-107)
```rust
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
```

**File:** execution/executor-service/src/remote_state_view.rs (L206-208)
```rust
    fn get_usage(&self) -> StateViewResult<StateStorageUsage> {
        unimplemented!("get_usage is not implemented for RemoteStateView")
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L196-196)
```text
        state_storage::on_new_block(reconfiguration::current_epoch());
```

**File:** aptos-move/framework/aptos-framework/sources/state_storage.move (L45-48)
```text
        if (epoch != usage.epoch) {
            usage.epoch = epoch;
            usage.usage = get_state_storage_usage_only_at_epoch_beginning();
        }
```

**File:** aptos-move/framework/src/natives/state_storage.rs (L70-73)
```rust
    let usage = ctx.resolver.get_usage().map_err(|err| {
        PartialVMError::new(StatusCode::VM_EXTENSION_ERROR)
            .with_message(format!("Failed to get state storage usage: {}", err))
    })?;
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L291-293)
```rust
    fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
        self.executor_view.get_usage()
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** execution/executor-benchmark/src/main.rs (L632-638)
```rust
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
```
