# Audit Report

## Title
Reserved Address as Royalty Payee Causes Permanent Token Sale Denial of Service

## Summary
The Token V1 framework allows token creators to set reserved system addresses (@vm_reserved/0x0, @aptos_framework/0x1, @aptos_token/0x3) as royalty payee addresses. This creates invalid state that causes permanent denial of service for all marketplace sales, as account creation at reserved addresses is forbidden by the Aptos account system.

## Finding Description

The vulnerability exists in the Token V1 royalty validation logic where address validation was intentionally removed to support "stateless accounts" but was implemented too broadly, inadvertently allowing reserved addresses.

The `create_royalty` function contains a commented-out validation check that would have prevented non-existent addresses from being set as royalty payees: [1](#0-0) 

The commented question at line 1003 ("Is it okay to remove this check to accommodate stateless accounts?") reveals this validation was intentionally removed, but the implementation failed to distinguish between:
1. **Stateless accounts** (regular addresses without Account resources yet) - valid use case
2. **Reserved addresses** (0x0, 0x1, 0x3) - can NEVER have accounts created

The error constant `EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST` still exists but is unused: [2](#0-1) 

**Attack Propagation Path:**

Token creators can set reserved addresses through either creation or mutation:

1. During token creation via `create_tokendata`, the `royalty_payee_address` parameter is passed directly to `create_royalty` without validation: [3](#0-2) 

2. Post-creation mutation via `mutate_tokendata_royalty` also allows setting any address as the royalty payee: [4](#0-3) 

3. When a buyer attempts to purchase the token, marketplace implementations call `listing::compute_royalty` which extracts the payee address from the token: [5](#0-4) 

4. The payment settlement process then calls `aptos_account::deposit_coins` to transfer royalties: [6](#0-5) 

5. The `deposit_coins` function attempts to auto-create accounts that don't exist: [7](#0-6) 

6. However, the `create_account` function explicitly forbids account creation at reserved addresses: [8](#0-7) 

7. This calls the underlying `account::create_account` which enforces the same restriction: [9](#0-8) 

8. The transaction aborts with error code `ECANNOT_RESERVED_ADDRESS` (error code 5): [10](#0-9) 

**Result:** All subsequent sale attempts for tokens with reserved addresses as royalty payees fail permanently. If `mutability_config.royalty = false`, this state cannot be corrected without governance intervention.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

**State Inconsistencies Requiring Manual Intervention:** The Token V1 framework allows creation of invalid state where reserved addresses serve as royalty payees. These addresses fundamentally cannot receive payments in Aptos by design, yet the framework permits their configuration. For tokens with immutable royalty settings, this requires governance intervention to resolve.

**Limited Funds Loss/Manipulation:** While no direct theft occurs, token holders experience effective economic loss through complete denial of liquidity. Tokens become unsellable through any marketplace implementation that properly pays royalties, resulting in permanent illiquidity. This constitutes "limited funds loss" as defined in the Medium severity criteria.

**Application-Layer Denial of Service:** This vulnerability creates complete blockage of marketplace sales for affected tokens. Importantly, this is an application-layer vulnerability where core framework logic allows invalid state that breaks ecosystem functionality - distinct from network-level DoS which is out of scope.

This breaks the security guarantee that token metadata should maintain valid, functional configurations that enable ecosystem interoperability.

## Likelihood Explanation

**Likelihood: Medium to High**

**Ease of Exploitation:**
- Requires only token creator privileges (universally available to any network participant)
- Single transaction execution to set malicious royalty payee
- Works on both token creation and post-creation mutation (if royalty is mutable)
- No special tooling, complex transaction choreography, or privileged access required
- Reserved addresses are publicly documented (0x0, 0x1, 0x3)

**Realistic Scenarios:**
1. **Accidental Misconfiguration:** Developers using placeholder addresses (0x0) or test addresses during development that accidentally deploy to mainnet
2. **Griefing Attack:** Malicious creator intentionally denies secondary market liquidity to harm token holders
3. **Copy-Paste Errors:** Developers copying example code containing reserved addresses

**Critical Factor:** The validation was explicitly removed (commented out) without proper replacement logic to handle the distinction between stateless accounts (valid) and reserved addresses (invalid). The comment questioning whether removal was appropriate indicates this was a known concern that was not adequately addressed.

## Recommendation

Restore address validation in `create_royalty` with logic that distinguishes between stateless accounts and reserved addresses:

```move
public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
    assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
    
    // Allow stateless accounts but forbid reserved addresses
    assert!(
        payee_address != @vm_reserved && payee_address != @aptos_framework && payee_address != @aptos_token,
        error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST)
    );
    
    Royalty {
        royalty_points_numerator,
        royalty_points_denominator,
        payee_address
    }
}
```

This preserves support for stateless accounts while preventing invalid configurations that break marketplace functionality.

## Proof of Concept

```move
#[test_only]
module test_reserved_royalty {
    use aptos_framework::account;
    use aptos_token::token;
    use std::string;
    
    #[test(creator = @0xCAFE)]
    #[expected_failure(abort_code = 0x50005, location = aptos_framework::account)]
    fun test_reserved_address_royalty_breaks_sale(creator: &signer) {
        // Setup: Create token with reserved address as royalty payee
        account::create_account_for_test(signer::address_of(creator));
        
        token::create_collection(
            creator,
            string::utf8(b"Collection"),
            string::utf8(b"Description"),
            string::utf8(b"uri"),
            1,
            vector[false, false, false]
        );
        
        // Create token with reserved address @aptos_framework (0x1) as royalty payee
        let token_data_id = token::create_tokendata(
            creator,
            string::utf8(b"Collection"),
            string::utf8(b"Token"),
            string::utf8(b"Description"),
            1,
            string::utf8(b"uri"),
            @aptos_framework, // Reserved address as royalty payee
            100,
            5, // 5% royalty
            token::create_token_mutability_config(&vector[false, false, false, false, false]),
            vector[],
            vector[],
            vector[]
        );
        
        // Mint token
        let token_id = token::mint_token(creator, token_data_id, 1);
        
        // Simulate marketplace royalty payment
        // This will fail with ECANNOT_RESERVED_ADDRESS (0x50005)
        aptos_account::deposit_coins(@aptos_framework, coin::withdraw<AptosCoin>(creator, 5));
    }
}
```

## Notes

This vulnerability represents a logic flaw in framework design where validation removal was implemented too broadly. The distinction between stateless accounts (which should be supported) and reserved addresses (which should be forbidden) was not properly handled. The commented-out validation with an unanswered question indicates this was a known consideration that required more careful analysis. While this may appear as user misconfiguration, the framework's responsibility is to prevent invalid state that breaks fundamental ecosystem functionality, especially when such validation previously existed and was explicitly removed.

### Citations

**File:** aptos-move/framework/aptos-token/sources/token.move (L136-137)
```text
    /// Royalty payee account does not exist
    const EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST: u64 = 35;
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L831-850)
```text
    public fun mutate_tokendata_royalty(creator: &signer, token_data_id: TokenDataId, royalty: Royalty) acquires Collections {
        assert_tokendata_exists(creator, token_data_id);

        let all_token_data = &mut Collections[token_data_id.creator].token_data;
        let token_data = all_token_data.borrow_mut(token_data_id);
        assert!(token_data.mutability_config.royalty, error::permission_denied(EFIELD_NOT_MUTABLE));

        token_event_store::emit_token_royalty_mutate_event(
            creator,
            token_data_id.collection,
            token_data_id.name,
            token_data.royalty.royalty_points_numerator,
            token_data.royalty.royalty_points_denominator,
            token_data.royalty.payee_address,
            royalty.royalty_points_numerator,
            royalty.royalty_points_denominator,
            royalty.payee_address
        );
        token_data.royalty = royalty;
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1001-1010)
```text
    public fun create_royalty(royalty_points_numerator: u64, royalty_points_denominator: u64, payee_address: address): Royalty {
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));
        // Question[Orderless]: Is it okay to remove this check to accommodate stateless accounts?
        // assert!(account::exists_at(payee_address), error::invalid_argument(EROYALTY_PAYEE_ACCOUNT_DOES_NOT_EXIST));
        Royalty {
            royalty_points_numerator,
            royalty_points_denominator,
            payee_address
        }
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1249-1310)
```text
    public fun create_tokendata(
        account: &signer,
        collection: String,
        name: String,
        description: String,
        maximum: u64,
        uri: String,
        royalty_payee_address: address,
        royalty_points_denominator: u64,
        royalty_points_numerator: u64,
        token_mutate_config: TokenMutabilityConfig,
        property_keys: vector<String>,
        property_values: vector<vector<u8>>,
        property_types: vector<String>
    ): TokenDataId acquires Collections {
        assert!(name.length() <= MAX_NFT_NAME_LENGTH, error::invalid_argument(ENFT_NAME_TOO_LONG));
        assert!(collection.length() <= MAX_COLLECTION_NAME_LENGTH, error::invalid_argument(ECOLLECTION_NAME_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::invalid_argument(EURI_TOO_LONG));
        assert!(royalty_points_numerator <= royalty_points_denominator, error::invalid_argument(EINVALID_ROYALTY_NUMERATOR_DENOMINATOR));

        let account_addr = signer::address_of(account);
        assert!(
            exists<Collections>(account_addr),
            error::not_found(ECOLLECTIONS_NOT_PUBLISHED),
        );
        let collections = &mut Collections[account_addr];

        let token_data_id = create_token_data_id(account_addr, collection, name);

        assert!(
            collections.collection_data.contains(token_data_id.collection),
            error::not_found(ECOLLECTION_NOT_PUBLISHED),
        );
        assert!(
            !collections.token_data.contains(token_data_id),
            error::already_exists(ETOKEN_DATA_ALREADY_EXISTS),
        );

        let collection = collections.collection_data.borrow_mut(token_data_id.collection);

        // if collection maximum == 0, user don't want to enforce supply constraint.
        // we don't track supply to make token creation parallelizable
        if (collection.maximum > 0) {
            collection.supply += 1;
            assert!(
                collection.maximum >= collection.supply,
                error::invalid_argument(ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM),
            );
        };

        let token_data = TokenData {
            maximum,
            largest_property_version: 0,
            supply: 0,
            uri,
            royalty: create_royalty(royalty_points_numerator, royalty_points_denominator, royalty_payee_address),
            name,
            description,
            default_properties: property_map::new(property_keys, property_values, property_types),
            mutability_config: token_mutate_config,
        };

```

**File:** aptos-move/move-examples/marketplace/sources/listing.move (L244-259)
```text
    public fun compute_royalty(
        object: Object<Listing>,
        amount: u64,
    ): (address, u64) acquires Listing, TokenV1Container {
        let listing = borrow_listing(object);
        let obj_addr = object::object_address(&listing.object);
        if (exists<TokenV1Container>(obj_addr)) {
            let token_container = borrow_global<TokenV1Container>(obj_addr);
            let token_id = tokenv1::get_token_id(&token_container.token);
            let royalty = tokenv1::get_royalty(token_id);

            let payee_address = tokenv1::get_royalty_payee(&royalty);
            let numerator = tokenv1::get_royalty_numerator(&royalty);
            let denominator = tokenv1::get_royalty_denominator(&royalty);
            let royalty_amount = bounded_percentage(amount, numerator, denominator);
            (payee_address, royalty_amount)
```

**File:** aptos-move/move-examples/marketplace/sources/coin_listing.move (L485-511)
```text
    inline fun complete_purchase<CoinType>(
        completer: &signer,
        purchaser_addr: address,
        object: Object<Listing>,
        coins: Coin<CoinType>,
        type: String,
    ) {
        let token_metadata = listing::token_metadata(object);

        let price = coin::value(&coins);
        let (royalty_addr, royalty_charge) = listing::compute_royalty(object, price);
        let (seller, fee_schedule) = listing::close(completer, object, purchaser_addr);

        // Take royalty first
        if (royalty_charge != 0) {
            let royalty = coin::extract(&mut coins, royalty_charge);
            aptos_account::deposit_coins(royalty_addr, royalty);
        };

        // Take commission of what's left, creators get paid first
        let commission_charge = fee_schedule::commission(fee_schedule, price);
        let actual_commission_charge = math64::min(coin::value(&coins), commission_charge);
        let commission = coin::extract(&mut coins, actual_commission_charge);
        aptos_account::deposit_coins(fee_schedule::fee_address(fee_schedule), commission);

        // Seller gets what is left
        aptos_account::deposit_coins(seller, coins);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L56-59)
```text
    public entry fun create_account(auth_key: address) {
        let account_signer = account::create_account(auth_key);
        register_apt(&account_signer);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L128-148)
```text
    public fun deposit_coins<CoinType>(
        to: address, coins: Coin<CoinType>
    ) acquires DirectTransferConfig {
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
        };
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L177-178)
```text
    /// Cannot create account because address is reserved
    const ECANNOT_RESERVED_ADDRESS: u64 = 5;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L289-302)
```text
    public(friend) fun create_account(new_address: address): signer {
        // there cannot be an Account resource under new_addr already.
        assert!(!exists<Account>(new_address), error::already_exists(EACCOUNT_ALREADY_EXISTS));
        // NOTE: @core_resources gets created via a `create_account` call, so we do not include it below.
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        if (features::is_default_account_resource_enabled()) {
            create_signer(new_address)
        } else {
            create_account_unchecked(new_address)
        }
    }
```
