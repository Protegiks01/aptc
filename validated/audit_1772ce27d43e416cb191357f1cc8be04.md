# Audit Report

## Title
Stack Overflow DoS via Deeply Nested BooleanTransactionFilter in Indexer-gRPC Service

## Summary
The indexer-grpc service is vulnerable to a stack overflow attack through deeply nested `BooleanTransactionFilter` structures. An attacker can craft a malicious filter with thousands of nested `LogicalNot` operations that passes size validation but causes stack exhaustion during protobuf-to-Rust conversion, triggering a global panic handler that crashes the entire indexer-grpc process.

## Finding Description

The vulnerability exists in the `BooleanTransactionFilter::new_from_proto()` conversion logic, which validates the protobuf message size but does not enforce any recursion depth limit. [1](#0-0) 

The `parse_transaction_filter()` function calls `new_from_proto()` with a maximum size check of 10,000 bytes by default. [2](#0-1) [3](#0-2) 

The size validation only occurs when `max_filter_size` is `Some(...)` at the top level. However, during recursive conversion of nested structures, all subsequent calls pass `None`, completely bypassing the size check:

- LogicalAnd conversion passes None: [4](#0-3) 
- LogicalOr conversion passes None: [5](#0-4) 
- LogicalNot conversion passes None: [6](#0-5) 

The protobuf schema allows arbitrary nesting depth through self-referential message definitions: [7](#0-6) 

**Attack Path:**
1. Attacker constructs a deeply nested protobuf message: `Not(Not(Not(...Not(APIFilter)...)))` with 3,000+ levels
2. Each nesting level adds only ~3 bytes to the protobuf encoding, staying well under the 10KB limit
3. Attacker sends malicious `GetTransactionsRequest` to any indexer-grpc endpoint (localnet, historical, or live data service)
4. The service calls `parse_transaction_filter()` which invokes `new_from_proto()`
5. Size check passes (under 10KB), but recursive conversion creates 3,000+ stack frames
6. Stack overflow occurs, causing a panic in the request handler
7. The global panic handler catches the panic and terminates the entire process: [8](#0-7) 

All three indexer-grpc data services use the same vulnerable parsing logic:
- Localnet data service: [9](#0-8) 
- Historical data service: [10](#0-9) 
- Live data service: [11](#0-10) 

Notably, other parts of the Aptos codebase implement recursion depth limits to prevent exactly this type of attack (e.g., `MAX_RECURSIVE_TYPES_ALLOWED = 8`), but `BooleanTransactionFilter` lacks this protection. [12](#0-11) 

## Impact Explanation

**Severity: High** - This qualifies as "API crashes" per the Aptos bug bounty criteria.

- **Complete Service Crash**: The panic triggers `process::exit(12)`, crashing the entire indexer-grpc service, not just an individual request thread
- **Service Availability**: Complete denial of service for the indexer-grpc API with a single malicious request
- **Ecosystem Impact**: All applications depending on indexer-grpc for transaction data will fail until manual service restart
- **No Authentication Required**: Any client can exploit this without credentials or special permissions
- **Trivial Exploitation**: Crafting the malicious protobuf message requires minimal effort - just nested structure generation
- **All Endpoints Affected**: Historical data service, live data service, and localnet data service all use the same vulnerable parsing logic

While this doesn't directly affect consensus or validator operations, the indexer-grpc service is critical infrastructure for the Aptos ecosystem, providing the official API for blockchain data access.

## Likelihood Explanation

**Likelihood: High**

- **Easy to Exploit**: Attacker only needs to construct a nested protobuf message and send it via gRPC
- **No Prerequisites**: No authentication, stake, or special permissions required  
- **Reliable**: Stack overflow will occur deterministically with sufficient nesting depth
- **Publicly Exposed**: Indexer-grpc services are typically public-facing APIs
- **Low Cost**: Single malicious request causes crash, no sustained attack needed
- **Deterministic**: With Rust's typical 2MB default stack size and ~1-2KB stack frame overhead per recursive call, approximately 1,000-2,000 nesting levels will cause overflow. The 10KB size limit allows for 3,000+ levels at ~3 bytes per level.

## Recommendation

Implement a recursion depth limit for `BooleanTransactionFilter` conversion, similar to the protections used elsewhere in the Aptos codebase:

1. Add a `max_depth` parameter to `new_from_proto()` and track recursion depth
2. Set a reasonable limit (e.g., 8-16 levels, following the pattern of `MAX_RECURSIVE_TYPES_ALLOWED = 8`)
3. Propagate the depth counter through all recursive calls (LogicalAnd, LogicalOr, LogicalNot)
4. Return an error when the depth limit is exceeded

Example fix pattern (based on `MoveType::verify()`):
- Add depth tracking: Pass `recursion_depth: u8` parameter through conversion
- Check limit: `if recursion_depth > MAX_FILTER_DEPTH { bail!("Filter nesting too deep") }`
- Increment on recursive calls: Pass `recursion_depth + 1` to nested conversions

## Proof of Concept

A malicious client can create a deeply nested filter programmatically:

```rust
// Pseudocode for generating the malicious filter
let mut filter = create_simple_api_filter(); // Base case
for _ in 0..3000 {
    filter = BooleanTransactionFilter {
        filter: Some(boolean_transaction_filter::Filter::LogicalNot(
            Box::new(filter)
        ))
    };
}

// Send GetTransactionsRequest with this filter
let request = GetTransactionsRequest {
    transaction_filter: Some(filter),
    starting_version: Some(0),
    transactions_count: Some(10),
};

// This will pass size validation (under 10KB) but cause stack overflow
// during new_from_proto() conversion, crashing the service via process::exit(12)
```

The attack succeeds because:
1. Each `LogicalNot` wrapper adds only ~3 bytes to the protobuf encoding
2. 3000 levels Ã— 3 bytes = 9KB, which passes the 10KB size check
3. During conversion, each level creates a new stack frame (~1-2KB)
4. At ~1000-2000 levels, stack overflow occurs
5. Panic handler terminates the entire process

## Notes

This vulnerability demonstrates a classic recursion depth attack that exploits the difference between serialized size (bounded) and stack depth (unbounded). The Aptos codebase already has precedent for protecting against this pattern with depth limits in `MoveType`, `TypeTag`, and `VMValue` conversions, but `BooleanTransactionFilter` was overlooked. The impact is severe because the global panic handler ensures any panic crashes the entire service process, not just an individual request handler.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L268-276)
```rust
    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalAndFilters) -> Result<Self> {
        Ok(Self {
            and: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L308-316)
```rust
    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalOrFilters) -> Result<Self> {
        Ok(Self {
            or: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-358)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** config/src/config/indexer_grpc_config.rs (L21-21)
```rust
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L64-71)
```rust
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L83-95)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["historical_data_service_invalid_filter"])
                                .inc();
                            continue;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L98-110)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["live_data_service_invalid_filter"])
                                .inc();
                            continue;
```

**File:** api/types/src/move_types.rs (L688-698)
```rust
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;

impl VerifyInputWithRecursion for MoveType {
    fn verify(&self, recursion_count: u8) -> anyhow::Result<()> {
        if recursion_count > MAX_RECURSIVE_TYPES_ALLOWED {
            bail!(
                "Move type {} has gone over the limit of recursive types {}",
                self,
                MAX_RECURSIVE_TYPES_ALLOWED
            );
        }
```
