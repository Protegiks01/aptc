# Audit Report

## Title
Consensus Safety Violation: OnChainConsensusConfig Schema Upgrade Breaks Deterministic Execution via Silent Deserialization Fallback

## Summary
During protocol upgrades that introduce new `OnChainConsensusConfig` schema versions, validators running older binaries fail to deserialize the new format and silently fall back to a default configuration where validator transactions are disabled. This causes different validators to execute governance transactions differently, producing different state roots and triggering consensus failure.

## Finding Description

The vulnerability exists in the native Rust implementation of `validator_txn_enabled_internal()` which uses `.unwrap_or_default()` when deserializing on-chain consensus configuration bytes [1](#0-0) . When BCS deserialization encounters an unknown enum variant (e.g., V6 on a node that only knows V1-V5), it fails and returns the default configuration.

The default `OnChainConsensusConfig` has validator transactions disabled [2](#0-1) , specifically returning `ValidatorTxnConfig::V0` via `default_if_missing()` [3](#0-2) , which has `enabled()` returning false [4](#0-3) .

The `OnChainConsensusConfig` enum has evolved from V1 to V5 [5](#0-4) , with each version adding new fields. Future schema versions are inevitable as the protocol evolves.

**The Attack Scenario:**

During a protocol upgrade introducing V6, when `aptos_governance::reconfigure()` executes [6](#0-5) , it calls `consensus_config::validator_txn_enabled()` [7](#0-6)  which invokes the native function to deserialize the config bytes.

**On upgraded validators (know V1-V6)**: Deserialization succeeds, returns actual config value (e.g., `true`), executes `reconfiguration_with_dkg::try_start()` which modifies `ReconfigurationState` [8](#0-7)  and starts a DKG session [9](#0-8) .

**On old validators (know V1-V5)**: Deserialization fails, returns default (vtxn disabled, returns `false`), executes `reconfiguration_with_dkg::finish()` which clears DKG session and applies epoch configs [10](#0-9) .

These different code paths produce **different state roots**, breaking the deterministic execution invariant that all validators must produce identical state for identical blocks.

The same vulnerability pattern exists in the consensus `EpochManager` [11](#0-10) .

## Impact Explanation

This is **Critical Severity** per the Aptos bug bounty "Consensus/Safety Violations" category (up to $1,000,000).

**Broken Invariant**: Deterministic Execution - All validators must produce identical state roots for identical blocks.

**Concrete Impact**:
- **Consensus split**: Validators on different software versions cannot agree on the correct state root for blocks containing governance transactions
- **Network partition**: The blockchain splits into two incompatible chains
- **Requires hard fork**: Recovery requires manual coordination to roll back or fast-forward all validators to a common state
- **Complete loss of liveness**: No new blocks can be committed while validators disagree on state, as confirmed by fork detection logic [12](#0-11) 

**Affected transactions**: Any transaction calling `consensus_config::validator_txn_enabled()`, most critically `aptos_governance::reconfigure()` which executes for every governance proposal affecting on-chain configuration.

## Likelihood Explanation

**Likelihood: High** - This will occur during protocol upgrades that add new `OnChainConsensusConfig` variants.

**Evidence**:
1. The enum has already evolved from V1 to V5, with V3 adding vtxn config, V4 adding window_size, and V5 adding rand_check_enabled. Future V6, V7, etc. are inevitable.
2. Aptos explicitly supports and tests rolling validator upgrades where validators run different binary versions simultaneously [13](#0-12) .
3. The `set_for_next_epoch()` function only validates that config bytes are non-empty [14](#0-13) , with no deserialization validation to ensure all validators can parse the new format.
4. There is always a window where some validators run old binaries and some run new binaries during routine protocol upgrades.

**No attack required**: This occurs naturally during legitimate protocol upgrades performed by governance.

## Recommendation

Implement strict deserialization validation:

1. **Fail-fast on deserialization errors**: Replace `.unwrap_or_default()` with explicit error handling that aborts the transaction if deserialization fails, ensuring all validators either succeed or fail together.

2. **Add validation to `set_for_next_epoch()`**: Before accepting new config bytes, attempt deserialization to ensure they can be parsed. This prevents incompatible configs from being written on-chain.

3. **Version compatibility checks**: Add a minimum supported config version to the binary and reject configs above that version during deserialization.

4. **Coordinated upgrade process**: Implement a two-phase upgrade where (1) all validators upgrade binaries to support new schema version, (2) governance proposal updates on-chain config to use new version.

## Proof of Concept

While a full executable PoC requires setting up a multi-validator testnet with mixed binary versions, the vulnerability can be demonstrated through code analysis:

1. Deploy framework with V6 support to half the validators
2. Execute governance proposal: `consensus_config::set_for_next_epoch(&framework, v6_bytes)`
3. Execute `aptos_governance::reconfigure(&framework)`
4. Observe validators with V6 support call `try_start()` while validators without V6 support call `finish()`
5. Verify different state roots produced by querying `get_ledger_information()` on different validators
6. Observe consensus failure when validators cannot agree on block commits

The execution path is deterministic and guaranteed to occur during real protocol upgrades due to the explicit use of rolling deployments in Aptos' upgrade process.

## Notes

This vulnerability is particularly critical because:

1. **No attack required**: It occurs naturally during routine protocol maintenance
2. **High frequency**: Every schema evolution triggers this risk
3. **Complete network failure**: Unlike partial failures, this breaks fundamental consensus safety
4. **Historical evidence**: The config has already evolved 5 times, proving ongoing schema evolution is routine
5. **Explicit support for trigger condition**: Aptos tests and supports mixed-version deployments, creating the exact conditions that trigger this vulnerability

The fix requires careful coordination between binary upgrades and on-chain config updates to ensure all validators can parse configs before they're applied.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L19-19)
```rust
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-166)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
```

**File:** types/src/on_chain_config/consensus_config.rs (L192-213)
```rust
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-76)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }

    native fun validator_txn_enabled_internal(config_bytes: vector<u8>): bool;
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_state.move (L67-77)
```text
    public(friend) fun on_reconfig_start() acquires State {
        if (exists<State>(@aptos_framework)) {
            let state = borrow_global_mut<State>(@aptos_framework);
            let variant_type_name = *string::bytes(copyable_any::type_name(&state.variant));
            if (variant_type_name == b"0x1::reconfiguration_state::StateInactive") {
                state.variant = copyable_any::pack(StateActive {
                    start_time_secs: timestamp::now_seconds()
                });
            }
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L61-85)
```text
    public(friend) fun start(
        dealer_epoch: u64,
        randomness_config: RandomnessConfig,
        dealer_validator_set: vector<ValidatorConsensusInfo>,
        target_validator_set: vector<ValidatorConsensusInfo>,
    ) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        let new_session_metadata = DKGSessionMetadata {
            dealer_epoch,
            randomness_config,
            dealer_validator_set,
            target_validator_set,
        };
        let start_time_us = timestamp::now_microseconds();
        dkg_state.in_progress = std::option::some(DKGSessionState {
            metadata: new_session_metadata,
            start_time_us,
            transcript: vector[],
        });

        emit(DKGStartEvent {
            start_time_us,
            session_metadata: new_session_metadata,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** testsuite/forge/src/interface/swarm.rs (L228-229)
```rust
        if !Self::are_root_hashes_equal_at_version(&clients, min_version).await? {
            return Err(anyhow!("Fork check failed"));
```

**File:** testsuite/testcases/src/compatibility_test.rs (L111-148)
```rust
        batch_update_gradually(
            ctxa.clone(),
            &[first_node],
            &new_version,
            upgrade_wait_for_healthy,
            upgrade_node_delay,
            upgrade_max_wait,
        )
        .await?;
        // Generate some traffic
        {
            let mut ctx_locker = ctxa.ctx.lock().await;
            let ctx = ctx_locker.deref_mut();
            let txn_stat_one = generate_traffic(ctx, &[first_node], duration).await?;
            ctx.report.report_txn_stats(
                format!("{}::single-validator-upgrade", self.name()),
                &txn_stat_one,
            );

            // Update the rest of the first batch
            let msg = format!(
                "3. Upgrading rest of first batch to new version: {}",
                new_version
            );
            info!("{}", msg);
            ctx.report.report_text(msg);
        }

        // upgrade the rest of the first half
        batch_update_gradually(
            ctxa.clone(),
            &first_batch,
            &new_version,
            upgrade_wait_for_healthy,
            upgrade_node_delay,
            upgrade_max_wait,
        )
        .await?;
```
