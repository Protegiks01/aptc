# Audit Report

## Title
DKG Sessions Complete with Outdated Security Parameters When Randomness Config Changes Between Epochs

## Summary
When governance changes the randomness configuration during an epoch, in-flight DKG sessions complete using outdated security parameters. The completed session is then used in the next epoch without validating that its security parameters match the current configuration, allowing randomness to operate with weaker or incorrect security guarantees than intended.

## Finding Description

The vulnerability exists in the epoch transition logic where DKG sessions capture randomness configuration at session start but are not invalidated or re-validated when the configuration changes.

**Attack Flow:**

**1. DKG Session Initialization (Epoch N):** When a DKG session starts, it captures the current randomness configuration by calling `randomness_config::current()`. [1](#0-0)  The configuration including secrecy and reconstruction thresholds is stored in the session metadata. [2](#0-1) 

**2. Configuration Change (During Epoch N):** Governance legitimately changes the randomness configuration for increased security. The new configuration is buffered via the config_buffer mechanism. [3](#0-2)  The in-flight DKG session continues with the old configuration captured in its metadata.

**3. DKG Session Completion (Still Epoch N):** Before the epoch transition, validators complete the DKG session. The validator transaction processing validates the transcript against parameters derived from the in-progress session's metadata. [4](#0-3)  The public parameters are constructed from the old configuration stored in the session metadata. [5](#0-4)  The completed session is then stored with the old configuration intact. [6](#0-5) 

**4. Epoch Transition (Epoch N → N+1):** During reconfiguration, the incomplete session clearing only affects `in_progress`, not `last_completed`. [7](#0-6)  The new randomness configuration is then applied from the buffer. [8](#0-7)  The epoch transition orchestrates these steps in sequence. [9](#0-8) 

**5. Vulnerability Trigger (Epoch N+1):** When setting up randomness for the new epoch, the system retrieves the completed DKG session and validates only the epoch number, **not the configuration parameters**. [10](#0-9)  The code explicitly states "No need to verify the transcript" and derives public parameters from the metadata containing the old security parameters. [11](#0-10) 

**Security Invariant Broken:**

The system violates the randomness security guarantee that validator subsets with voting power ≤ `secrecy_threshold` cannot reconstruct randomness. If governance increases the threshold from 33% to 50% but a DKG session completes with 33%, then validator coalitions with 34-49% voting power can break randomness in epoch N+1 despite the active configuration requiring 50%.

## Impact Explanation

**Severity: HIGH** (Significant Protocol Violation per Aptos Bug Bounty)

This vulnerability allows randomness security parameters to be bypassed, violating cryptographic security guarantees. The impact manifests in two scenarios:

1. **Security Downgrade (More Critical):** When governance increases security parameters (e.g., secrecy_threshold from 33% to 50%), the next epoch operates with the weaker old threshold. Validator coalitions with voting power between the old and new thresholds can break randomness security, compromising applications that depend on randomness (e.g., validator selection, lottery systems, fair ordering).

2. **Availability Impact:** When governance decreases thresholds (e.g., from 50% to 33%), the next epoch operates with the stronger old threshold. Validator subsets that should be able to reconstruct randomness cannot, potentially causing randomness generation failures and affecting protocol liveness.

This meets the **High Severity** criteria per Aptos bug bounty guidelines for "significant protocol violations" that compromise security guarantees without requiring a hardfork to resolve. The vulnerability breaks the fundamental security property that the active randomness configuration defines the cryptographic security level of the system.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability triggers automatically when:
1. Governance proposes a randomness configuration change (legitimate governance operation)
2. The proposal passes and is executed during an epoch
3. A DKG session is in progress or completes before the epoch transition

Given that:
- Randomness configuration changes are legitimate governance operations expected to occur for security improvements
- DKG sessions run continuously for each epoch transition
- The vulnerable window spans the entire epoch duration (typically hours to days)
- No validation exists to prevent the configuration mismatch [12](#0-11) 

The vulnerability will occur naturally whenever governance updates randomness parameters during normal operations, making it a systematic issue rather than a rare edge case.

## Recommendation

Add validation in `try_get_rand_config_for_new_epoch` to verify that the completed DKG session's randomness configuration matches the current on-chain configuration. If a mismatch is detected, reject the completed session and either:

1. Wait for a new DKG session with the correct parameters, or
2. Fall back to operating without randomness until the next epoch

Additionally, consider invalidating incomplete DKG sessions when randomness configuration changes are buffered, forcing a new DKG session to start with the updated parameters.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Starting an epoch with a DKG session using ConfigV1(secrecy=33%, reconstruct=50%)
2. Submitting a governance proposal to change to ConfigV1(secrecy=50%, reconstruct=66%) 
3. Allowing the DKG session to complete before epoch transition
4. Observing that the next epoch uses the completed session with 33% threshold despite the active configuration being 50%

A complete Move test would require setting up a multi-validator testnet with governance capabilities, which is beyond a simple unit test but can be verified by code inspection showing the lack of configuration validation at the cited locations.

## Notes

The core issue is architectural: the DKG session "freezes" the randomness configuration at session start by storing it in `DKGSessionMetadata`, but there is no validation that this frozen configuration matches the active configuration when the session is used in the next epoch. This creates a temporal inconsistency where governance believes a new configuration is active, but the cryptographic system operates under the old configuration for one epoch.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L34-39)
```text
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L68-73)
```text
        let new_session_metadata = DKGSessionMetadata {
            dealer_epoch,
            randomness_config,
            dealer_validator_set,
            target_validator_set,
        };
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L93-95)
```text
        let session = option::extract(&mut dkg_state.in_progress);
        session.transcript = transcript;
        dkg_state.last_completed = option::some(session);
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L100-105)
```text
    public fun try_clear_incomplete_session(fx: &signer) acquires DKGState {
        system_addresses::assert_aptos_framework(fx);
        if (exists<DKGState>(@aptos_framework)) {
            let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
            dkg_state.in_progress = option::none();
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L53-56)
```text
    public fun set_for_next_epoch(framework: &signer, new_config: RandomnessConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(new_config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L59-68)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires RandomnessConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<RandomnessConfig>()) {
            let new_config = config_buffer::extract_v2<RandomnessConfig>();
            if (exists<RandomnessConfig>(@aptos_framework)) {
                *borrow_global_mut<RandomnessConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            }
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L105-112)
```rust
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-224)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
        RealDKGPublicParams {
            session_metadata: dkg_session_metadata.clone(),
            pvss_config,
            verifier: verifier.into(),
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L1040-1046)
```rust
        let dkg_session = dkg_state
            .last_completed
            .ok_or_else(|| NoRandomnessReason::DKGCompletedSessionResourceMissing)?;
        if dkg_session.metadata.dealer_epoch + 1 != new_epoch_state.epoch {
            return Err(NoRandomnessReason::CompletedSessionTooOld);
        }
        let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
```

**File:** consensus/src/epoch_manager.rs (L1063-1063)
```rust
        // No need to verify the transcript.
```
