# Audit Report

## Title
Memory Exhaustion via Malicious PVSS Transcript Deserialization During DKG Broadcast

## Summary
A malicious validator can craft PVSS transcripts with excessively large vector length claims encoded in ULEB128 format. When honest validators deserialize these transcripts, BCS deserialization may attempt to allocate memory based on claimed vector lengths before size validation occurs, potentially causing memory exhaustion and validator node crashes.

## Finding Description

The vulnerability exists in the DKG transcript processing pipeline where BCS deserialization occurs before any size validation.

**Primary Vulnerability Point - Peer Transcript Aggregation:**

In the transcript aggregation flow, deserialization happens before validation. The `add` method receives a `DKGTranscript` from a peer and immediately deserializes the `transcript_bytes` without checking its size: [1](#0-0) 

The validation checks (epoch verification, voting power checks, and transcript verification) only occur AFTER successful deserialization: [2](#0-1) 

**Vulnerable Data Structures:**

The PVSS transcript contains deeply nested vector structures with elliptic curve points. The `Subtranscript` structure includes a 3-dimensional vector: [3](#0-2) 

**Size Validation Occurs Post-Deserialization:**

The critical size validation that should protect against oversized vectors only happens during the verify phase. The verification checks the outer vector length matches expected players: [4](#0-3) 

However, this check occurs AFTER BCS has already deserialized the entire structure and allocated memory.

**Network Message Size Limit:**

The network layer enforces a 64 MiB maximum message size: [5](#0-4) 

However, this limit applies to the serialized message size, not the claimed vector lengths. ULEB128 encoding allows claiming billions of elements in just a few bytes.

**VM Processing Path Also Vulnerable:**

The same deserialization-before-validation pattern exists in validator transaction processing: [6](#0-5) 

Followed by verification only after deserialization completes: [7](#0-6) 

**Attack Mechanism:**

1. Byzantine validator crafts a malicious transcript where ULEB128-encoded length prefixes claim millions of elements
2. For the nested structure `Cs: Vec<Vec<Vec<E::G1>>>`, this creates multiplicative memory requirements
3. The serialized message stays under the 64 MiB network limit (ULEB128 can encode 10^9 in ~5 bytes)
4. When honest validators receive and deserialize via `bcs::from_bytes`, the deserializer may allocate based on claimed lengths
5. For deeply nested structures claiming billions of total elements, this could trigger excessive memory allocation
6. Validators may crash from OOM before reaching verification logic

## Impact Explanation

This vulnerability qualifies as **High severity** under the Aptos bug bounty criteria.

**High Severity Indicators:**
- "Validator Node Slowdowns (High): DoS through resource exhaustion" - Directly applicable if validators crash from memory exhaustion
- Significant performance degradation affecting consensus during DKG sessions
- Temporary liveness issues if sufficient validators crash simultaneously

**Not Critical Because:**
- No funds are lost or stolen
- No consensus safety violation (liveness issue, not safety violation)
- Network can recover once validators restart
- Requires manual intervention but no hardfork
- No permanent state corruption

The vulnerability represents a potential DoS vector through resource exhaustion, which is explicitly listed as a valid High severity impact in the bug bounty framework.

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
- Attacker must be a validator in the current epoch (single Byzantine validator sufficient, <1/3 threshold)
- Requires understanding of PVSS transcript structure and BCS ULEB128 encoding
- No collusion with other validators needed

**Feasibility:**
- Byzantine validators are within the BFT threat model for Aptos
- Attack is straightforward once validator access is obtained
- Can be executed repeatedly in each DKG session
- Network-level 64 MiB limit doesn't prevent the attack (serialized size remains small)

**Mitigating Factors:**
- Actual exploitability depends on the external `bcs` crate's memory allocation behavior
- Malicious validators can be identified and removed from validator set
- Requires validator access (higher barrier than general network peers)

## Recommendation

Implement size validation before BCS deserialization:

1. **Add maximum transcript size constant:**
   ```rust
   const MAX_TRANSCRIPT_BYTES: usize = 10 * 1024 * 1024; // 10 MiB
   ```

2. **Validate size before deserialization in transcript aggregation:**
   ```rust
   ensure!(
       transcript_bytes.len() <= MAX_TRANSCRIPT_BYTES,
       "[DKG] transcript_bytes too large: {} bytes",
       transcript_bytes.len()
   );
   let transcript = bcs::from_bytes(transcript_bytes.as_slice())?;
   ```

3. **Use `bcs::from_bytes_with_limit` if available:**
   ```rust
   let transcript = bcs::from_bytes_with_limit(
       transcript_bytes.as_slice(), 
       MAX_TRANSCRIPT_BYTES
   )?;
   ```

4. **Apply same validation in VM processing path** at: [6](#0-5) 

## Proof of Concept

A complete PoC would require testing the actual memory allocation behavior of the `bcs` crate, which is outside the scope of code review. However, the vulnerability pattern is demonstrable:

```rust
// Conceptual PoC (not executable without full test harness)
// This demonstrates how a malicious validator could craft the attack

use bcs;

fn craft_malicious_transcript() -> Vec<u8> {
    let mut bytes = Vec::new();
    
    // ULEB128 encoding claiming 1 billion outer elements (5 bytes)
    bytes.extend_from_slice(&[0x80, 0x80, 0x80, 0x80, 0x07]); // 1,000,000,000
    
    // For each claimed element, claim another billion (multiplicative)
    // This would cause massive memory allocation during deserialization
    // while keeping serialized size small
    
    bytes
}

// When honest validator calls:
// bcs::from_bytes::<Transcript>(&malicious_bytes)
// The deserializer may attempt to allocate gigabytes before validation
```

## Notes

The vulnerability depends on the external `bcs` crate's implementation details. However, from a defense-in-depth perspective, the Aptos codebase should not rely on external library protections. Adding explicit size validation before deserialization is a security best practice that should be implemented regardless of `bcs` crate behavior. This protects against current and future deserialization vulnerabilities.

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L87-87)
```rust
    pub Cs: Vec<Vec<Vec<E::G1>>>, // TODO: maybe make this and the other fields affine? The verifier will have to do it anyway... and we are trying to speed that up
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-145)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
