# Audit Report

## Title
Missing Quorum Verification for First Epoch Ending in Backup Restore Without Trusted Waypoint

## Summary
The epoch ending backup restore logic fails to verify signatures for the first ledger info when no trusted waypoint is provided and no previous epoch ending ledger info exists. This allows attackers to inject malicious epoch endings with insufficient validator signatures, bypassing the fundamental consensus safety requirement that epoch changes must be approved by 2/3+ validators.

## Finding Description

The vulnerability exists in `preheat_impl()` where verification logic has two conditional branches but neither executes when specific conditions are met: [1](#0-0) 

**Branch A (lines 129-135)**: If a trusted waypoint exists, verify the waypoint hash matches (signature verification intentionally skipped).

**Branch B (lines 136-147)**: If a previous ledger info exists, verify signatures using the previous epoch's validator set.

**Critical Gap**: When neither condition is met (no trusted waypoint AND `previous_li` is `None`), no verification occurs. The ledger info is pushed to the list at line 148 without any signature or quorum validation.

This occurs specifically when:
- The backup starts from a non-genesis epoch (N > 0)
- No trusted waypoint is provided for the first ledger info's version
- `previous_li` is `None` during the first loop iteration
- The restore is invoked with `previous_epoch_ending_ledger_info = None`

The entry point through `aptos-db-tool` always passes `None`: [2](#0-1) 

An additional verification opportunity in `run_impl()` is also bypassed: [3](#0-2) 

Since `previous_epoch_ending_ledger_info` is `None`, this verification block is skipped entirely.

When `verify()` IS called, it properly enforces quorum verification: [4](#0-3) [5](#0-4) 

The quorum calculation correctly implements 2f+1: [6](#0-5) 

However, the logic gap prevents `verify()` from being called at all for the first ledger info in non-genesis restores without waypoints.

**Exploitation Path**:
1. Attacker creates malicious backup starting from epoch N > 0
2. First `LedgerInfoWithSignatures` has < 2/3 validator signatures
3. Node operator runs restore without trusted waypoints
4. In `preheat_impl()`: `previous_li = None`, no waypoint → no verification
5. In `run_impl()`: `previous_epoch_ending_ledger_info = None` → no verification  
6. Malicious first ledger info accepted without validation
7. Subsequent ledger infos verify correctly against the malicious first one
8. Node operates on forked chain with arbitrary validator set

## Impact Explanation

This is **Critical Severity** per Aptos bug bounty criteria:

1. **Consensus/Safety Violation**: The fundamental consensus invariant requiring 2/3+ validator approval for epoch changes is completely bypassed. This breaks the core AptosBFT security model.

2. **Validator Set Manipulation**: Attackers can inject arbitrary validator sets by forging epoch ending ledger infos, allowing them to control who signs future blocks and epoch changes.

3. **Chain Fork Attack**: Nodes restoring from malicious backups operate on a different chain than the canonical network, creating permanent forks requiring hard forks to resolve.

4. **Loss of Byzantine Fault Tolerance**: Once a node accepts the malicious epoch ending, all subsequent state transitions are built on a foundation that never achieved proper consensus, violating BFT guarantees.

This qualifies as Critical Severity ($1,000,000 category) under "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors increasing likelihood**:
- Accessible via public `aptos-db-tool` CLI without special privileges
- Node operators regularly perform backup/restore during disaster recovery, node migration, and network joining
- Only requires crafting a malicious backup file - no validator keys or insider access needed
- Documentation presents trusted waypoints as optional: [7](#0-6) 

The documentation says "When provided" suggesting waypoints are optional, not required for security.

**Factors decreasing likelihood**:
- Best practices likely recommend using trusted waypoints
- Experienced operators may understand the security requirement
- Normal flow expects genesis epoch starts

The test suite demonstrates awareness of this gap: [8](#0-7) 

The test explicitly creates ledger infos with empty signatures and sets `should_fail_without_waypoints = true`, indicating awareness that verification should fail without waypoints, but this protection is not enforced in the actual restore code.

## Recommendation

Enforce that either a trusted waypoint OR a previous epoch ending ledger info must be provided for verification. Reject restores that cannot be properly verified:

```rust
// In preheat_impl(), after line 128:
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
} else if let Some(pre_li) = previous_li {
    pre_li
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| {
            anyhow!(
                "Next epoch state not found from LI at epoch {}.",
                pre_li.ledger_info().epoch()
            )
        })?
        .verify(&li)?;
} else {
    // NEW: Reject unverifiable ledger infos
    bail!(
        "Cannot verify epoch ending at epoch {} version {}: \
        No trusted waypoint provided and no previous epoch ending available. \
        Provide a trusted waypoint using --trust-waypoint for security.",
        li.ledger_info().epoch(),
        li.ledger_info().version()
    );
}
```

Additionally, in `run_impl()`, enforce verification when no previous_epoch_ending_ledger_info is provided:

```rust
// After line 217, before existing check:
if previous_epoch_ending_ledger_info.is_none() 
    && self.controller.trusted_waypoints.get(&first_li.ledger_info().version()).is_none() 
{
    bail!(
        "Cannot verify first epoch ending without either a previous epoch ending \
        or a trusted waypoint. This is required for security."
    );
}
```

## Proof of Concept

```rust
// Create a malicious backup starting from epoch 5 with invalid signatures
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_types::aggregate_signature::AggregateSignature;

// Attacker creates malicious epoch ending with empty signatures
let malicious_li = LedgerInfoWithSignatures::new(
    create_epoch_ending_ledger_info(5, /* ... */),
    AggregateSignature::empty() // No validator signatures!
);

// Save to backup manifest starting at epoch 5
// When restored without --trust-waypoint, this will be accepted
// without any signature verification, allowing arbitrary validator set injection
```

Run with: `aptos-db-tool restore oneoff epoch-ending --epoch-ending-manifest malicious.manifest --target-db-dir /tmp/victim-db`

The malicious epoch ending is accepted without verification, compromising consensus safety.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-149)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/db-tool/src/restore.rs (L75-81)
```rust
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
```

**File:** types/src/epoch_state.rs (L40-50)
```rust
impl Verifier for EpochState {
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-346)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L143-158)
```rust
                if overwrite && li.ledger_info().epoch() != 0 {
                    li = LedgerInfoWithSignatures::new(
                        li.ledger_info().clone(),
                        AggregateSignature::empty(),
                    );
                    should_fail_without_waypoints = true;
                }
                if overwrite || trusted {
                    res_waypoints.push(Waypoint::new_epoch_boundary(li.ledger_info()).unwrap())
                }
                res_lis.push(li);

            }
        }
        (res_lis, res_waypoints, should_fail_without_waypoints)
    }
```
