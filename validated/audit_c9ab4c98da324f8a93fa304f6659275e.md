# Audit Report

## Title
Feature Flag Downgrade Allows Cached Modules to Bypass Re-verification, Breaking Deterministic Execution Invariant

## Summary
The Move bytecode verifier caches verified modules using only the module hash as the cache key, without including the `VerifierConfig` state. When feature flags are disabled through governance after modules have been verified and cached, those modules can continue executing with now-disabled features, causing consensus divergence between nodes with warm vs. cold caches.

## Finding Description

The vulnerability exists in the interaction between three critical components:

**1. Verification Cache Design**: The `VERIFIED_MODULES_CACHE` uses a 32-byte module hash as the sole cache key, with no inclusion of verifier configuration state. [1](#0-0) 

**2. Feature-Dependent Verification**: The `FeatureVerifier` performs bytecode verification checks that depend on feature flags such as `enable_function_values`, `enable_enum_types`, and `enable_resource_access_control`. When these features are disabled, modules using those features are rejected during verification. [2](#0-1) [3](#0-2) 

The `VerifierConfig` struct contains these feature flags that control verification behavior: [4](#0-3) 

**3. Cache Bypass Logic**: During module loading, if the module hash exists in the cache, verification is completely skipped. If not found, verification runs with the current `VerifierConfig` and can fail if features are disabled. [5](#0-4) 

**4. Governance Feature Control**: Feature flags are derived from on-chain `Features` configuration, which can be modified through governance proposals. [6](#0-5) 

**5. Incomplete Mitigation**: Cache flushing on verifier config changes only occurs for `gas_feature_version >= RELEASE_V1_34` (version 38), leaving earlier versions completely vulnerable. Even with this mitigation, the flush only occurs in the `check_ready` path during module cache manager initialization. [7](#0-6) [8](#0-7) 

**Attack Scenario:**

1. Feature `ENABLE_FUNCTION_VALUES` is enabled via governance
2. Attacker publishes a module using function values (e.g., `PackClosure`, `CallClosure` bytecodes)
3. Module is verified with `enable_function_values = true` and module hash is cached in `VERIFIED_MODULES_CACHE`
4. Governance discovers critical vulnerability in function values feature
5. Emergency proposal disables `ENABLE_FUNCTION_VALUES`
6. For networks with `gas_feature_version < 38`: Cache is never flushed
7. When a transaction attempts to load the module:
   - **Nodes with warm cache**: Cache hit at line 184, verification skipped, module loads successfully, transaction executes
   - **Nodes with cold cache** (due to restart, LRU eviction, or different execution history): Cache miss, verification runs at line 192-195 with new config, fails because module uses disabled feature, transaction fails
8. **Result**: Different validators produce different transaction outcomes and state roots for the same block, breaking consensus

The system explicitly tracks verifier configuration changes through serialization: [9](#0-8) [10](#0-9) 

This indicates the system recognizes verifier config changes are critical, but the cache invalidation is incomplete and version-gated.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations that directly threaten network integrity:

1. **Consensus Safety Violations**: Different validators executing identical blocks produce different state roots, violating the fundamental consensus guarantee that all honest nodes must agree on state transitions. This breaks AptosBFT's safety properties and can cause chain splits.

2. **Governance Bypass**: Emergency feature disablement through governance (intended as a security mechanism to disable vulnerable features) can be circumvented by cached modules. This defeats the entire purpose of feature flags as a security control.

3. **Non-deterministic State Transitions**: Transaction outcomes depend on ephemeral cache state rather than blockchain state, violating the deterministic execution invariant that is foundational to blockchain consensus.

4. **Network Partition Risk**: Validators with different cache states may permanently diverge, requiring manual intervention or hard fork to recover consensus.

This qualifies as **Critical** under the Aptos bug bounty program's "Consensus/Safety Violations" category: "Different validators commit different blocks" and "Chain splits without hardfork requirement."

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger whenever:

1. A feature is disabled after being enabled (common during emergency security responses)
2. Modules using that feature were previously published and cached
3. Those modules are executed after the feature is disabled
4. Validators have different cache states (due to restarts, LRU eviction, or different sync patterns)

The likelihood is elevated by:
- Feature flags are routinely changed through governance for security and functionality updates
- Emergency responses to discovered vulnerabilities naturally trigger feature disablement
- The mitigation only exists for `gas_feature_version >= 38`, leaving networks at earlier versions completely vulnerable
- Cache state divergence naturally occurs in distributed systems due to restarts, memory pressure, and different execution histories
- The cache is a static LRU with fixed size (100,000 entries), making eviction patterns unpredictable

## Recommendation

**Immediate Fix**: Include `VerifierConfig` state in the cache key by computing a composite key from both the module hash and the serialized verifier configuration bytes.

```rust
// In verified_module_cache.rs
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<([u8; 32], Vec<u8>), ()>>);

// In environment.rs
pub fn build_locally_verified_module(
    &self,
    compiled_module: Arc<CompiledModule>,
    module_size: usize,
    module_hash: &[u8; 32],
) -> VMResult<LocallyVerifiedModule> {
    let cache_key = (*module_hash, self.vm_config().verifier_config_bytes().clone());
    if !VERIFIED_MODULES_CACHE.contains(&cache_key) {
        // ... verification logic
        VERIFIED_MODULES_CACHE.put(cache_key);
    }
    Ok(LocallyVerifiedModule(compiled_module, module_size))
}
```

**Alternative Fix**: Remove the version gate and unconditionally flush the cache whenever verifier configuration changes:

```rust
// In code_cache_global_manager.rs - Remove version check
let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
});
if flush_verifier_cache {
    RuntimeEnvironment::flush_verified_module_cache();
}
```

## Proof of Concept

While a complete end-to-end PoC requires setting up a multi-validator network with governance, the vulnerability mechanism can be demonstrated:

1. Deploy module M with function values when `ENABLE_FUNCTION_VALUES` is enabled
2. Module M is verified and cached with hash H
3. Governance disables `ENABLE_FUNCTION_VALUES`
4. Node A (warm cache): Loading M checks cache for H → cache hit → verification skipped → success
5. Node B (cold cache): Loading M checks cache for H → cache miss → runs verification with disabled feature → fails with `FEATURE_NOT_ENABLED`
6. Transaction calling M succeeds on Node A, fails on Node B → different state roots

The code paths confirm this behavior through the cache check logic and feature verification enforcement shown in the citations above.

## Notes

The vulnerability is particularly severe because:
- It affects a fundamental invariant (deterministic execution)
- The mitigation is incomplete and version-gated
- Governance actions intended to improve security can inadvertently trigger consensus failures
- The static global cache persists across block boundaries, making divergence persistent

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L13-13)
```rust
pub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L19-42)
```rust
pub struct FeatureVerifier<'a> {
    config: &'a VerifierConfig,
    code: BinaryIndexedView<'a>,
}

impl<'a> FeatureVerifier<'a> {
    pub fn verify_module(config: &'a VerifierConfig, module: &'a CompiledModule) -> VMResult<()> {
        Self::verify_module_impl(config, module)
            .map_err(|e| e.finish(Location::Module(module.self_id())))
    }

    fn verify_module_impl(
        config: &'a VerifierConfig,
        module: &'a CompiledModule,
    ) -> PartialVMResult<()> {
        let verifier = Self {
            config,
            code: BinaryIndexedView::Module(module),
        };
        verifier.verify_signatures()?;
        verifier.verify_function_handles()?;
        verifier.verify_struct_defs()?;
        verifier.verify_function_defs()
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L142-153)
```rust
                if matches!(
                    bc,
                    Bytecode::PackClosure(..)
                        | Bytecode::PackClosureGeneric(..)
                        | Bytecode::CallClosure(..)
                ) {
                    let mut err = PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED);
                    if let Some(idx) = idx {
                        err = err.at_index(IndexKind::FunctionDefinition, idx);
                    }
                    return Err(err.with_message("function value feature not enabled".to_string()));
                }
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L30-35)
```rust
/// Configuration for the bytecode verifier.
///
/// Always add new fields to the end, as we rely on the hash or serialized bytes of config to
/// detect if it has changed (e.g., new feature flag was enabled). Also, do not delete existing
/// fields, or change the type of existing field.
#[derive(Debug, Clone, Eq, PartialEq, Serialize)]
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L57-59)
```rust
    pub enable_enum_types: bool,
    pub enable_resource_access_control: bool,
    pub enable_function_values: bool,
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-152)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-125)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L104-104)
```rust
    pub const RELEASE_V1_34: u64 = 38;
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L135-138)
```rust
    /// Returns bytes corresponding to the verifier config in this environment.
    pub fn verifier_config_bytes(&self) -> &Vec<u8> {
        &self.0.verifier_bytes
    }
```
