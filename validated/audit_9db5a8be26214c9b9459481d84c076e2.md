# Audit Report

## Title
Resource Exhaustion via Unmetered Storage Reads in Federated Keyless Signature Validation

## Summary
An attacker can cause validator node slowdown by submitting transactions with federated keyless authenticators that reference non-existent or unique `jwk_addr` values. Each transaction triggers up to 3 expensive uncached database reads during mempool validation before gas is charged, allowing resource exhaustion of the storage layer.

## Finding Description

The vulnerability exists in the keyless signature validation flow where federated keyless authenticators trigger expensive storage reads during transaction validation in the mempool, prior to gas metering.

**Attack Flow:**

1. **Transaction Submission to Mempool**: Transactions submitted via API flow to mempool where validation occurs through `PooledVMValidator`, which randomly selects from a pool of VM validators for parallel transaction validation. [1](#0-0) 

2. **Validation Calls Keyless Authenticator Check**: During validation, `validate_signed_transaction` extracts keyless authenticators and calls `keyless_validation::validate_authenticators` without passing a gas meter parameter, despite the gas meter being available. [2](#0-1) 

3. **Per-Authenticator Storage Reads**: For each federated keyless authenticator, the validation first checks the main JWK registry at `0x1`. If the JWK is not found there, and the public key is a `Federated` variant, validation attempts to fetch JWKs from the custom `jwk_addr` specified in the authenticator. [3](#0-2) 

4. **Expensive Database I/O**: The `get_federated_jwks_onchain` function calls `get_resource_on_chain_at_addr`, which performs an expensive `get_resource_bytes_with_metadata_and_layout` call that reads from the database. Critically, the `addr` parameter (attacker-controlled `jwk_addr`) is passed directly to the database read without validation beyond checking that the struct type is defined at a special address. [4](#0-3) 

5. **No Gas Metering**: The `validate_authenticators` function signature confirms it does not take a gas meter parameter, meaning all storage reads occur without gas accounting. [5](#0-4) 

**Attacker Control:**

The attacker fully controls the `jwk_addr` field in `FederatedKeylessPublicKey`, which is part of the authenticator's public key structure and can be set to any arbitrary address.

**Attack Parameters:**

The maximum number of keyless signatures per transaction defaults to 3, enforced during validation. [6](#0-5) [7](#0-6) 

**Cache Ineffectiveness:**

The `PooledVMValidator` maintains multiple VM validators, each with its own `CachedModuleView<CachedDbStateView>` state cache. [8](#0-7) 

Since validators are randomly selected and each maintains separate caches, attackers using unique addresses for each transaction effectively bypass caching, forcing fresh database reads across different validator instances in the pool.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "Validator Node Slowdowns" - significant performance degradation affecting consensus through DoS via resource exhaustion.

The impact is amplified because:
1. **Storage reads for non-existent resources require Jellyfish Merkle tree traversals** - expensive cryptographic operations to prove non-existence
2. **Parallel validation means multiple expensive reads occur simultaneously** - the validator pool processes transactions concurrently
3. **No gas is charged for failed validations** - making the attack completely cost-free for the attacker
4. **Each transaction can trigger 3 database reads** - the max_signatures_per_txn limit
5. **Cache bypass via unique addresses** - random validator selection and unique jwk_addr values prevent effective caching

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely because:

1. **Low barrier to entry**: Attacker only needs the ability to submit transactions via the public API endpoint
2. **No resource cost**: Failed validations don't charge gas, making sustained attacks economically viable
3. **Simple execution**: Creating transactions with custom `jwk_addr` values requires only standard transaction construction
4. **Amplification factor**: 3 storage reads per transaction Ã— parallel validation across multiple validator instances
5. **Feature enabled by default**: The federated keyless feature flag is included in the default enabled features list. [9](#0-8) 

## Recommendation

Implement gas metering for keyless authenticator validation by:

1. **Pass gas meter to validation functions**: Modify `validate_authenticators` to accept and use a gas meter parameter for storage operations
2. **Charge gas for storage reads**: Apply gas charges to `get_resource_bytes_with_metadata_and_layout` calls during validation
3. **Add address allowlisting**: Restrict `jwk_addr` to a set of approved addresses or require addresses to be registered on-chain before use
4. **Implement validation rate limiting**: Add explicit rate limiting for failed keyless validations per sender/IP
5. **Consider validation caching**: Implement a global validation cache for failed jwk_addr lookups with TTL to prevent repeated expensive reads for the same non-existent addresses

## Proof of Concept

```rust
// PoC demonstrating unmetered storage reads during federated keyless validation
// This would be implemented as a Rust test in aptos-move/aptos-vm/src/

#[test]
fn test_federated_keyless_unmetered_storage_reads() {
    // 1. Create transaction with federated keyless authenticator
    // 2. Set jwk_addr to non-existent address (e.g., 0xDEADBEEF...)
    // 3. Submit transaction for validation
    // 4. Observe that get_resource_bytes_with_metadata_and_layout is called
    // 5. Verify no gas is charged for the failed validation
    // 6. Repeat with unique addresses to bypass caching
    // 7. Monitor database I/O to confirm expensive Merkle tree traversals
    
    // Expected: Expensive storage reads occur without gas charges,
    // enabling resource exhaustion attacks
}
```

## Notes

This vulnerability is distinct from network-level DoS attacks (which are out of scope). It exploits application-level logic where expensive computational work (database reads and Merkle tree operations) occurs before any gas accounting, allowing untrusted actors to consume validator resources without cost. The federated keyless feature, while providing valuable functionality for dApp-specific authentication, inadvertently creates an unmetered resource consumption vector during the validation phase.

### Citations

**File:** vm-validator/src/vm_validator.rs (L42-62)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}

impl Clone for VMValidator {
    fn clone(&self) -> Self {
        Self::new(self.db_reader.clone())
    }
}

impl VMValidator {
    fn new(db_reader: Arc<dyn DbReader>) -> Self {
        let db_state_view = db_reader
            .latest_state_checkpoint_view()
            .expect("Get db view cannot fail");
        VMValidator {
            db_reader,
            state: CachedModuleView::new(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L136-140)
```rust
    fn get_next_vm(&self) -> Arc<Mutex<VMValidator>> {
        let mut rng = thread_rng(); // Create a thread-local random number generator
        let random_index = rng.gen_range(0, self.vm_validators.len()); // Generate random index
        self.vm_validators[random_index].clone() // Return the VM at the random index
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1810)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L36-71)
```rust
fn get_resource_on_chain_at_addr<T: MoveStructType + for<'a> Deserialize<'a>>(
    addr: &AccountAddress,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> anyhow::Result<T, VMStatus> {
    let struct_tag = T::struct_tag();
    if !struct_tag.address.is_special() {
        let msg = format!(
            "[keyless-validation] Address {} is not special",
            struct_tag.address
        );
        return Err(VMStatus::error(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            Some(msg),
        ));
    }

    // INVARIANT:
    //   The struct should be defined at core (0x1) address, so we do not require metering for any
    //   module loading.
    let module = module_storage
        .unmetered_get_existing_deserialized_module(&struct_tag.address, &struct_tag.module)
        .map_err(|e| e.into_vm_status())?;

    let bytes = resolver
        .get_resource_bytes_with_metadata_and_layout(addr, &struct_tag, &module.metadata, None)
        .map_err(|e| e.finish(Location::Undefined).into_vm_status())?
        .0
        .ok_or_else(|| {
            value_deserialization_error!(format!(
                "get_resource failed on {}::{}::{}",
                addr.to_hex_literal(),
                T::struct_tag().module,
                T::struct_tag().name
            ))
        })?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L152-160)
```rust
/// Ensures that **all** keyless authenticators in the transaction are valid.
pub(crate) fn validate_authenticators(
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
    configuration: Option<&Configuration>,
    authenticators: &Vec<(AnyKeylessPublicKey, KeylessSignature)>,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> Result<(), VMStatus> {
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L202-205)
```rust
    if authenticators.len() > config.max_signatures_per_txn as usize {
        // println!("[aptos-vm][groth16] Too many keyless authenticators");
        return Err(invalid_signature!("Too many keyless authenticators"));
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L237-260)
```rust
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** types/src/keyless/configuration.rs (L62-72)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L219-219)
```rust
            FeatureFlag::FEDERATED_KEYLESS,
```
