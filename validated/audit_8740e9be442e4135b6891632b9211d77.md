# Audit Report

## Title
Keyless Account Groth16 Proof Verification Enables Unmetered DoS Attacks on Validators

## Summary
Groth16 zero-knowledge proof verification for keyless accounts occurs during transaction prologue validation before gas is charged. Attackers can submit transactions with valid ephemeral signatures but invalid Groth16 proofs, forcing validators to perform expensive cryptographic operations without paying gas fees, enabling resource exhaustion attacks against validator nodes.

## Finding Description

The keyless authentication system performs signature verification in two distinct stages, creating an exploitable asymmetry in computational cost:

**Stage 1 - Mempool Admission:** During `check_signature()`, only the ephemeral signature is verified. The code explicitly defers expensive verification: [1](#0-0) 

The comment at lines 1323-1331 explicitly states: "Verifies the ephemeral signature on (TXN [+ ZKP]). The rest of the verification, i.e., [ZKPoK of] OpenID signature verification is done in `AptosVM::run_prologue`."

This allows transactions with valid ephemeral signatures but invalid Groth16 proofs to enter the mempool.

**Stage 2 - Prologue Validation:** During transaction execution, `validate_signed_transaction` calls `validate_authenticators`: [2](#0-1) 

This performs the expensive Groth16 proof verification: [3](#0-2) [4](#0-3) 

The Groth16 verification involves point deserialization with subgroup checks and pairing operations: [5](#0-4) 

**Critical Vulnerability:** When Groth16 verification fails, it returns `INVALID_SIGNATURE` error via the `invalid_signature!` macro: [6](#0-5) 

The `unwrap_or_discard!` macro catches this and discards the transaction: [7](#0-6) [8](#0-7) 

Discarded transactions do NOT charge gas because `INVALID_SIGNATURE` is a validation error (StatusCode = 1): [9](#0-8) [10](#0-9) 

Validation errors return `Err()` in `keep_or_discard()`, resulting in `TransactionStatus::Discard`: [11](#0-10) 

The `charge_keyless()` function that would charge gas is only called AFTER successful prologue validation: [12](#0-11) 

**Attack Flow:**
1. Attacker generates ephemeral keypairs and signs transactions (fast operation)
2. Attacker crafts invalid Groth16 proofs or reuses the same malformed proof bytes
3. Transactions pass `check_signature()` because only ephemeral signature is verified
4. Transactions enter mempool with valid signatures
5. During block execution, each validator performs expensive Groth16 verification
6. Verification fails, transaction receives `INVALID_SIGNATURE` status code
7. Transaction is discarded with no gas charged
8. Attacker repeats with multiple accounts to bypass per-account mempool limits

## Impact Explanation

This constitutes **High Severity** per Aptos bug bounty criteria under "Validator Node Slowdowns: Significant performance degradation affecting consensus, DoS through resource exhaustion."

**Computational Cost Disparity:**
- Ephemeral signature verification: ~50 microseconds  
- Groth16 proof verification: Significantly more expensive, involving G1/G2 point deserialization (lines 221-225 in groth16_sig.rs) and pairing operations (line 229)

**Resource Exhaustion Scenario:**
An attacker controlling multiple keyless accounts can bypass per-account mempool limits: [13](#0-12) [14](#0-13) 

With 100 accounts Ã— 100 transactions each = 10,000 transactions that:
- Pass mempool admission (cheap ephemeral signature check)
- Force validators to perform expensive Groth16 verification during block execution
- Get discarded without gas payment
- Can be continuously resubmitted

Each validator must independently verify these transactions, consuming significant CPU resources without any cost to the attacker beyond minimal balance requirements for gas estimation.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal resources and complexity:
1. **Creating keyless accounts** - publicly available feature requiring only OIDC provider interaction
2. **Generating ephemeral signatures** - trivial cryptographic operation using standard libraries
3. **Crafting invalid proofs** - attacker can reuse the same malformed proof bytes across all transactions
4. **Bypassing rate limits** - attacker can create multiple keyless accounts to distribute the load

**No Economic Deterrent:** Unlike normal transaction spam which incurs gas costs even on failure, this attack imposes zero cost on the attacker while forcing validators to perform expensive cryptographic operations. The cost asymmetry makes this attack economically viable and sustainable.

## Recommendation

Implement one or more of the following mitigations:

1. **Move Groth16 verification to mempool admission**: Perform full keyless validation including Groth16 proof verification during `check_signature()` before transactions enter the mempool. This prevents invalid proofs from reaching validators.

2. **Charge minimum gas for validation failures**: Modify the transaction status handling to charge a minimum gas amount for validation errors that result from expensive cryptographic operations, even when transactions are discarded.

3. **Rate limiting by computational cost**: Track computational cost of validation operations per sender and enforce stricter rate limits for transactions requiring expensive verification operations.

4. **Groth16 verification caching**: Cache failed Groth16 proof verification results to avoid re-verifying the same invalid proof multiple times.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a keyless account with valid ephemeral keypair
2. Constructing a transaction with valid ephemeral signature
3. Attaching an invalid or malformed Groth16 proof (e.g., all zeros or random bytes)
4. Submitting via REST API - transaction will pass mempool admission
5. Observing validator logs showing Groth16 verification failure during block execution
6. Confirming transaction status is `Discard` with `INVALID_SIGNATURE` and no gas charged
7. Repeating with multiple accounts to demonstrate resource exhaustion potential

The attack is trivially reproducible given the explicit code path separation between ephemeral signature verification (mempool) and Groth16 verification (prologue), combined with the validation error handling that discards transactions without charging gas.

### Citations

**File:** types/src/transaction/authenticator.rs (L1319-1347)
```rust
    fn verify_keyless_ephemeral_signature<T: Serialize + CryptoHash>(
        message: &T,
        signature: &KeylessSignature,
    ) -> Result<()> {
        // Verifies the ephemeral signature on (TXN [+ ZKP]). The rest of the verification,
        // i.e., [ZKPoK of] OpenID signature verification is done in
        // `AptosVM::run_prologue`.
        //
        // This is because the JWK, under which the [ZKPoK of an] OpenID signature verifies,
        // can only be fetched from on chain inside the `AptosVM`.
        //
        // This deferred verification is what actually ensures the `signature.ephemeral_pubkey`
        // used below is the right pubkey signed by the OIDC provider.

        let mut txn_and_zkp = TransactionAndProof {
            message,
            proof: None,
        };

        // Add the ZK proof into the `txn_and_zkp` struct, if we are in the ZK path
        match &signature.cert {
            EphemeralCertificate::ZeroKnowledgeSig(proof) => txn_and_zkp.proof = Some(proof.proof),
            EphemeralCertificate::OpenIdSig(_) => {},
        }

        signature
            .ephemeral_signature
            .verify(&txn_and_zkp, &signature.ephemeral_pubkey)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L176-189)
```rust
macro_rules! unwrap_or_discard {
    ($res:expr) => {
        match $res {
            Ok(s) => s,
            Err(e) => {
                // covers both VMStatus itself and VMError which can convert to VMStatus
                let s: VMStatus = e.into();

                let o = discarded_output(s.status_code());
                return (s, o);
            },
        }
    };
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1040-1043)
```rust
        gas_meter.charge_intrinsic_gas_for_transaction(txn_data.transaction_size())?;
        if txn_data.is_keyless() {
            gas_meter.charge_keyless()?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1811)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2000-2012)
```rust
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L261-270)
```rust
        verify_keyless_signature_without_ephemeral_signature_check(
            pk,
            sig,
            &jwk,
            onchain_timestamp_obj.microseconds,
            &training_wheels_pk,
            config,
            pvk,
        )?;
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-362)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());

                        result.map_err(|_| {
                            // println!("[aptos-vm][groth16] ZKP verification failed");
                            // println!("[aptos-vm][groth16] PIH: {}", public_inputs_hash);
                            // match zksig.proof {
                            //     ZKP::Groth16(proof) => {
                            //         println!("[aptos-vm][groth16] ZKP: {}", proof.hash());
                            //     },
                            // }
                            // println!(
                            //     "[aptos-vm][groth16] PVK: {}",
                            //     Groth16VerificationKey::from(pvk).hash()
                            // );
                            invalid_signature!("Proof verification failed")
                        })?;
```

**File:** types/src/keyless/groth16_sig.rs (L215-235)
```rust
    pub fn verify_proof(
        &self,
        public_inputs_hash: Fr,
        pvk: &PreparedVerifyingKey<Bn254>,
    ) -> anyhow::Result<()> {
        // let start = std::time::Instant::now();
        let proof: Proof<Bn254> = Proof {
            a: self.a.deserialize_into_affine()?,
            b: self.b.deserialize_into_affine()?,
            c: self.c.deserialize_into_affine()?,
        };
        // println!("Deserialization time: {:?}", start.elapsed());

        // let start = std::time::Instant::now();
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
        Ok(())
    }
```

**File:** types/src/keyless/mod.rs (L110-113)
```rust
macro_rules! invalid_signature {
    ($message:expr) => {
        VMStatus::error(StatusCode::INVALID_SIGNATURE, Some($message.to_owned()))
    };
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L18-21)
```rust
pub static VALIDATION_STATUS_MIN_CODE: u64 = 0;

/// The maximum status code for validation statuses
pub static VALIDATION_STATUS_MAX_CODE: u64 = 999;
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L295-297)
```rust
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L575-575)
```rust
    INVALID_SIGNATURE = 1,
```

**File:** config/src/config/mempool_config.rs (L123-123)
```rust
            capacity_per_user: 100,
```

**File:** mempool/src/core_mempool/transaction_store.rs (L324-332)
```rust
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
```
