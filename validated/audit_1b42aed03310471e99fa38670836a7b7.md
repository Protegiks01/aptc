# Audit Report

## Title
SAFER_RESOURCE_GROUPS Protection Bypass via Empty Metadata Module Upgrade

## Summary
The `SAFER_RESOURCE_GROUPS` feature flag protection can be bypassed when upgrading from a module without metadata. The `extract_resource_group_metadata_from_module()` function incorrectly returns an empty structs set when the old module lacks metadata, allowing attackers to add resource group attributes to existing structs without validation.

## Finding Description

The `SAFER_RESOURCE_GROUPS` feature flag is enabled by default and designed to prevent adding resource_group or resource_group_member attributes to existing structs during module upgrades. [1](#0-0) 

The validation logic in `validate_module_and_extract_new_entries()` checks if new resource group attributes are being added to existing structs by testing if struct names exist in the `structs` set extracted from the old module. [2](#0-1) 

The critical flaw exists in `extract_resource_group_metadata_from_module()`: when the old module has metadata, it correctly extracts struct names from `old_module.struct_defs()` into the structs set. [3](#0-2) 

However, when metadata doesn't exist, the function returns an empty structs set instead of extracting struct names. [4](#0-3) 

Modules can be published without Aptos runtime metadata, as confirmed by the validation function which returns Ok when metadata is None. [5](#0-4) 

**Attack Execution Path:**
1. Module publishing transaction is submitted to the network
2. `validate_publish_request()` is called during transaction execution [6](#0-5) 
3. Resource groups validation is invoked as part of the validation pipeline [7](#0-6) 
4. For module upgrades, the old module is retrieved and its metadata extracted [8](#0-7) 
5. When the old module has no metadata, an empty structs set is returned
6. The SAFER_RESOURCE_GROUPS validation checks `structs.remove(member)` which always returns false for an empty set, bypassing the protection

The test suite explicitly demonstrates that adding resource_group_member attributes to existing structs should fail when SAFER_RESOURCE_GROUPS is enabled, but succeeds when disabled. [9](#0-8) [10](#0-9) 

## Impact Explanation

This is a **HIGH Severity** vulnerability (up to $50,000 bounty) under the "Significant protocol violations" category because:

1. **Security Feature Bypass**: Circumvents the SAFER_RESOURCE_GROUPS protection mechanism that is enabled by default and expected to prevent unsafe upgrades
2. **Storage Model Corruption Risk**: Resource groups fundamentally change the storage layout from individual resources to grouped resources. Retroactively adding these semantics to existing structs can cause storage inconsistencies
3. **Move Upgrade Guarantees Violation**: Breaks Move's compatibility rules that existing struct instances must remain valid and accessible after upgrades
4. **Protocol-Level Impact**: This affects the core module publishing mechanism that all users rely on for safe upgrades

## Likelihood Explanation

**MEDIUM-HIGH likelihood** because:

1. **Simple Attack Requirements**: Only requires (1) publishing a module without metadata, then (2) upgrading it with resource group attributes added
2. **High Feasibility**: Modules without Aptos runtime metadata are explicitly allowed and can be created through older compilers, manually crafted bytecode, or modules with no attributes/error maps
3. **Unprivileged Attacker**: Any module publisher can execute this attack without special permissions
4. **False Security Expectation**: The SAFER_RESOURCE_GROUPS flag is enabled by default, creating the expectation that this class of unsafe upgrades is prevented

## Recommendation

Fix the `extract_resource_group_metadata_from_module()` function to extract struct names regardless of whether metadata exists:

```rust
pub(crate) fn extract_resource_group_metadata_from_module(
    old_module: &CompiledModule,
) -> VMResult<(
    BTreeMap<String, ResourceGroupScope>,
    BTreeMap<String, StructTag>,
    BTreeSet<String>,
)> {
    // Always extract struct names from the module
    let structs = old_module
        .struct_defs()
        .iter()
        .map(|struct_def| {
            let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
            old_module.identifier_at(struct_handle.name).to_string()
        })
        .collect::<BTreeSet<_>>();
    
    if let Some(metadata) = get_metadata_from_compiled_code(old_module) {
        let (groups, members) = extract_resource_group_metadata(&metadata)?;
        Ok((groups, members, structs))
    } else {
        Ok((BTreeMap::new(), BTreeMap::new(), structs))
    }
}
```

## Proof of Concept

```move
// Step 1: Publish module V1 without resource group attributes
// Compile this with an older compiler or manually strip metadata
module 0xCAFE::TestModule {
    struct MyResource has key {
        value: u64
    }
}

// Step 2: Upgrade to V2, adding resource_group_member attribute
module 0xCAFE::TestModule {
    #[resource_group(scope = address)]
    struct ResourceGroup { }
    
    #[resource_group_member(group = 0xCAFE::TestModule::ResourceGroup)]
    struct MyResource has key {
        value: u64
    }
}

// With SAFER_RESOURCE_GROUPS enabled, this upgrade should fail
// but succeeds if V1 was published without metadata
```

## Notes

The vulnerability exists because the struct names extraction logic (lines 201-208) is inside the metadata existence check, when it should be outside. This causes the validation at lines 176-186 to operate on an empty set when upgrading from modules without metadata, effectively disabling the SAFER_RESOURCE_GROUPS protection for such upgrades. The fix is straightforward but critical for maintaining Move's upgrade safety guarantees.

### Citations

**File:** types/src/on_chain_config/aptos_features.rs (L205-205)
```rust
            FeatureFlag::SAFER_RESOURCE_GROUPS,
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L136-141)
```rust
    let (original_groups, original_members, mut structs) = module_storage
        .unmetered_get_deserialized_module(new_module.address(), new_module.name())?
        .map_or_else(
            || Ok((BTreeMap::new(), BTreeMap::new(), BTreeSet::new())),
            |old_module| extract_resource_group_metadata_from_module(&old_module),
        )?;
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L176-186)
```rust
    for group in new_groups.keys() {
        if structs.remove(group) {
            metadata_validation_err("Invalid addition of resource_group attribute")?;
        }
    }

    for member in new_members.keys() {
        if structs.remove(member) {
            metadata_validation_err("Invalid addition of resource_group_member attribute")?;
        }
    }
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L199-209)
```rust
    if let Some(metadata) = get_metadata_from_compiled_code(old_module) {
        let (groups, members) = extract_resource_group_metadata(&metadata)?;
        let structs = old_module
            .struct_defs()
            .iter()
            .map(|struct_def| {
                let struct_handle = old_module.struct_handle_at(struct_def.struct_handle);
                old_module.identifier_at(struct_handle.name).to_string()
            })
            .collect::<BTreeSet<_>>();
        Ok((groups, members, structs))
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L210-212)
```rust
    } else {
        Ok((BTreeMap::new(), BTreeMap::new(), BTreeSet::new()))
    }
```

**File:** types/src/vm/module_metadata.rs (L452-456)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1689)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1719-1725)
```rust
        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L404-470)
```rust
fn verify_resource_group_member_upgrades() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct ResourceGroupMember has key { }

            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct ResourceGroupExtra { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible change of ResourceGroupMember::group
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroupExtra)]
            struct ResourceGroupMember has key { }

            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct ResourceGroupExtra { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct ResourceGroupMember has key { }

            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }

            #[resource_group(scope = address)]
            struct ResourceGroupExtra { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);
```

**File:** aptos-move/e2e-move-tests/src/tests/resource_groups.rs (L474-508)
```rust
fn verify_unsafe_resource_group_member_upgrades() {
    let mut h = MoveHarness::new_with_features(vec![], vec![FeatureFlag::SAFER_RESOURCE_GROUPS]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    // Initial code
    let source = r#"
        module 0xf00d::M {
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);

    // Incompatible addition of ResourceGroupMember
    let source = r#"
        module 0xf00d::M {
            #[resource_group_member(group = 0xf00d::M::ResourceGroup)]
            struct NotResourceGroupMember has key { }

            #[resource_group(scope = address)]
            struct ResourceGroup { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_success!(result);
}
```
