# Audit Report

## Title
Depth Check Bypass via Feature Flag Disablement Enables Stack Overflow Resource Exhaustion

## Summary
The Move VM's depth checking mechanism can be completely bypassed when the `ENABLE_FUNCTION_VALUES` feature flag is disabled on networks running gas feature version ≥ 1.38, creating a critical gap where neither type-based nor value-based depth validation occurs during value serialization/deserialization in native functions. This enables attackers to craft deeply nested values that cause stack overflow and validator node crashes.

## Finding Description
The Aptos Move VM implements two complementary depth checking systems to prevent stack overflow from deeply nested values: type depth checking (TypeDepthChecker) and value depth checking (runtime checks).

A logic vulnerability exists in how these systems interact with feature flags:

When `ENABLE_FUNCTION_VALUES` is disabled, `enable_depth_checks` becomes `false`: [1](#0-0) 

This causes `SafeNativeContext::max_value_nest_depth()` to return `None`: [2](#0-1) 

Simultaneously, on networks running gas feature version ≥ 1.38, `propagate_dependency_limit_error` is set to `true`: [3](#0-2) 

This disables type depth checking by setting `maybe_max_depth` to `None`: [4](#0-3) 

When type depth checking encounters `None`, it returns early without validation: [5](#0-4) 

Native functions pass the `None` value to `ValueSerDeContext` for serialization: [6](#0-5) 

The `ValueSerDeContext::check_depth()` method bypasses validation when `max_value_nested_depth` is `None`: [7](#0-6) 

**Attack Path:**
1. Governance proposal disables `ENABLE_FUNCTION_VALUES` via the feature flag management system
2. Network continues running with gas feature version ≥ 1.38 (currently at v45)
3. Attacker crafts transaction with deeply nested Move values (e.g., recursive `vector<vector<vector<...>>>`)
4. Transaction invokes native function that serializes the value (e.g., `0x1::event::emit`)
5. Serialization recursively processes nested structure without depth checks
6. Stack overflow causes panic during transaction execution
7. Since VMState is not VERIFIER or DESERIALIZER during transaction execution, the panic handler calls `process::exit(12)`, crashing the validator

Feature flags are governance-controllable: [8](#0-7) 

Stack overflow panics during transaction execution cause process termination: [9](#0-8) 

## Impact Explanation
**Severity: High ($50,000)**

This vulnerability enables resource exhaustion attacks leading to validator node crashes and network availability issues:

1. **Validator Node Crashes** - Deeply nested values cause stack overflow, triggering panics that call `process::exit(12)`, crashing validator processes and requiring restarts
2. **Liveness Impact** - If multiple validators process the malicious transaction simultaneously, network liveness degrades
3. **Deterministic Execution Violation** - The vulnerability creates a scenario where depth checking is completely absent, violating the VM's safety invariants

The vulnerability does NOT result in:
- Direct fund loss or theft
- Permanent network partition
- Consensus safety violations (double-spending)

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns, API crashes, Significant protocol violations." The ability to crash validator nodes through a crafted transaction represents a significant protocol vulnerability that affects network availability.

## Likelihood Explanation
**Likelihood: Medium-Low**

The vulnerability requires specific conditions:
1. Network must be running gas feature version ≥ 1.38 (currently satisfied at v45)
2. `ENABLE_FUNCTION_VALUES` must be disabled via governance
3. Attacker must craft transaction with deeply nested values (trivial)

The feature flag is currently enabled by default, but could be legitimately disabled in scenarios such as:
- Emergency rollback due to function values bug
- Temporary governance decision to disable the feature
- Network upgrade complications

The vulnerability represents a **latent logic bug** where disabling one feature unintentionally disables a critical safety mechanism. The code comments indicate this interaction was not fully considered: [10](#0-9) [11](#0-10) 

## Recommendation
The fix should ensure that at least one depth checking mechanism remains active regardless of feature flag state:

1. **Option 1 (Preferred)**: Decouple `enable_depth_checks` from `ENABLE_FUNCTION_VALUES`. Always enable value depth checks regardless of function values status.

2. **Option 2**: When `enable_depth_checks` is false, ensure type depth checking remains active by not disabling it based on `propagate_dependency_limit_error`.

3. **Option 3**: Add an assertion that fails if both depth checking mechanisms are disabled simultaneously, preventing the system from entering this unsafe state.

The recommended code change in `prod_configs.rs`:
```rust
// Always enable depth checks to prevent stack overflow
let enable_depth_checks = true;
```

Or alternatively, fix `ty_depth_checker.rs` to not disable type checking:
```rust
pub(crate) fn new(struct_definition_loader: &'a T) -> Self {
    let vm_config = struct_definition_loader.runtime_environment().vm_config();
    // Always use max_value_nest_depth, don't gate on propagate_dependency_limit_error
    let maybe_max_depth = vm_config.max_value_nest_depth;
    Self {
        struct_definition_loader,
        maybe_max_depth,
        formula_cache: RefCell::new(HashMap::new()),
    }
}
```

## Proof of Concept
A complete PoC would require:
1. Setting up a test network with gas version ≥ 1.38
2. Disabling `ENABLE_FUNCTION_VALUES` via governance proposal
3. Submitting a transaction with deeply nested vectors (depth > 128)
4. Observing validator crash via stack overflow

The vulnerability is demonstrable through code analysis showing the depth checking bypass path is active when both conditions are met.

## Notes
This is a **logic vulnerability** where the interaction between two independently-reasonable configuration decisions creates an unintended security gap. The code comments suggest developers assumed type depth checking would remain active when function values were disabled, but the gating logic at gas version 1.38 disabled it as well. This creates a window where neither protection mechanism is active, violating the VM's fundamental safety invariants against stack overflow attacks.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L221-227)
```rust
    // Value runtime depth checks have been introduced together with function values and are only
    // enabled when the function values are enabled. Previously, checks were performed over types
    // to bound the value depth (checking the size of a packed struct type bounds the value), but
    // this no longer applies once function values are enabled. With function values, types can be
    // shallow while the value can be deeply nested, thanks to captured arguments not visible in a
    // type. Hence, depth checks have been adjusted to operate on values.
    let enable_depth_checks = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L262-262)
```rust
        propagate_dependency_limit_error: gas_feature_version >= RELEASE_V1_38,
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L174-186)
```rust
    pub fn max_value_nest_depth(&self) -> Option<u64> {
        self.module_storage()
            .runtime_environment()
            .vm_config()
            .enable_depth_checks
            .then(|| {
                self.module_storage()
                    .runtime_environment()
                    .vm_config()
                    .max_value_nest_depth
            })
            .flatten()
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L56-61)
```rust
        // Gate by other config which will be enabled in 1.38. Will be removed after it is enabled.
        let maybe_max_depth = if vm_config.propagate_dependency_limit_error {
            None
        } else {
            vm_config.max_value_nest_depth
        };
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_depth_checker.rs (L79-82)
```rust
        let max_depth = match self.maybe_max_depth {
            Some(max_depth) => max_depth,
            None => return Ok(()),
        };
```

**File:** aptos-move/framework/src/natives/event.rs (L126-130)
```rust
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
```

**File:** third_party/move/move-vm/types/src/value_serde.rs (L149-157)
```rust
    pub(crate) fn check_depth(&self, depth: u64) -> PartialVMResult<()> {
        if self
            .max_value_nested_depth
            .is_some_and(|max_depth| depth > max_depth)
        {
            return Err(PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED));
        }
        Ok(())
    }
```

**File:** types/src/on_chain_config/aptos_features.rs (L258-258)
```rust
            FeatureFlag::ENABLE_FUNCTION_VALUES,
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
