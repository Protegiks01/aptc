# Audit Report

## Title
Certified APK Distribution Delays Cause Non-Deterministic Randomness Aggregation and Consensus Liveness Failure

## Summary
Asynchronous distribution of certified augmented public keys (certified_apks) across validators causes different validators to verify and accept different sets of randomness shares for the same round. This leads to different WVUF evaluations, resulting in different randomness values being written to on-chain state, producing different state roots that prevent consensus, causing a chain halt requiring manual intervention.

## Finding Description

The vulnerability exists in the randomness generation subsystem's interaction with the certified APK distribution mechanism, violating the Deterministic Execution invariant that requires all validators to produce identical state roots for identical blocks.

**Root Cause:**

The `RandKeys` struct stores `certified_apks` as a `Vec<OnceCell<APK>>` that are populated asynchronously via network messages: [1](#0-0) 

When verifying randomness shares, validators check if the certified_apk for the share's author is available. If the OnceCell is empty (None), verification fails with a bail error and the share is effectively dropped: [2](#0-1) 

The verification task silently drops shares that fail verification by only forwarding successfully verified messages: [3](#0-2) 

During randomness aggregation, validators call `WVUF::derive_eval` which uses Lagrange interpolation over the set of shares included in the proof. Different sets of shares produce different interpolation results: [4](#0-3) 

**Critical Synchronization Gap:**

The system has a synchronization barrier (`CertifiedAugDataAckState`) that ensures all validators acknowledge receiving MY certified aug data: [5](#0-4) 

However, block processing starts as soon as MY certified aug data exists, without waiting to receive ALL other validators' certified aug data: [6](#0-5) 

**Attack Scenario:**

1. At epoch N+1 start, validators broadcast their certified AugData
2. Validator X completes its broadcast (all validators ack receipt of X's data)
3. X starts processing blocks because `my_certified_aug_data_exists()` returns true
4. Due to network delays, X has received certified_apks for [A, B, C] but not yet [D, E]
5. Validator Y has received all certified_apks [A, B, C, D, E]
6. For round R, validators broadcast randomness shares
7. X successfully verifies shares from [A, B, C] only; shares from D, E fail verification and are dropped
8. Y successfully verifies shares from [A, B, C, D]
9. X aggregates with shares [A, B, C] → randomness_X
10. Y aggregates with shares [A, B, C, D] → randomness_Y
11. Different Lagrange interpolation produces: randomness_X ≠ randomness_Y
12. Block execution includes different randomness in metadata transaction via `block_prologue_ext`: [7](#0-6) 

13. Different randomness values are written to PerBlockRandomness resource: [8](#0-7) 

14. Validators compute different state root hashes
15. Validators cannot form a quorum certificate on commit votes → chain halts

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This qualifies as "Significant protocol violations" under the High Severity category. The vulnerability causes:

1. **Liveness Failure**: The blockchain cannot progress as validators cannot reach consensus on state roots due to divergent randomness values in the PerBlockRandomness resource
2. **Requires Manual Intervention**: Operators must manually synchronize certified_apks or restart consensus to recover, as the system has no automatic recovery mechanism
3. **Breaks Core Invariant**: Violates Deterministic Execution invariant - validators executing identical blocks produce different state roots
4. **No Automatic Recovery**: Unlike transient network issues, this requires active intervention as validators have permanently divergent state that cannot self-correct

While this doesn't cause fund loss or safety violations (chain fork), it causes complete loss of liveness severely impacting network availability and requiring emergency response.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high probability of occurring in production because:

1. **Normal Network Conditions**: Standard network latency and packet delays naturally cause asynchronous message delivery between geographically distributed validators
2. **No Attacker Required**: This is a protocol design issue that manifests under normal operation without any malicious actor
3. **Epoch Boundaries**: Occurs at every epoch transition when certified_apks are redistributed
4. **Distributed System Reality**: Perfect synchronization of broadcast messages across distributed validators is impossible
5. **Race Condition**: The time window between when the first validator receives threshold shares and when the last validator receives all certified_apks creates a natural race condition

The reliable broadcast mechanism for AugData includes a barrier ensuring all validators receive each validator's data, but crucially lacks a barrier ensuring each validator has received ALL validators' data before randomness share processing begins.

## Recommendation

Add a synchronization barrier in `rand_manager.rs` to ensure all validators have received certified_apks from all other validators before processing blocks that require randomness verification:

1. Track which validators' certified_apks have been received
2. Only enable block processing (line 380) when certified_apks from all validators in the epoch are available, not just when `my_certified_aug_data_exists()`
3. Implement a timeout mechanism to detect if some validators fail to broadcast their certified aug data

Alternative approach: Include a round number or epoch counter in the certified aug data distribution protocol, and only process shares for rounds >= that counter, ensuring proper ordering.

## Proof of Concept

A full PoC would require a multi-validator testnet setup with network delay injection. The attack scenario described above can be reproduced by:

1. Setting up 5 validators (A, B, C, D, E) with threshold = 3
2. Starting epoch N+1 transition
3. Introducing network delays such that validator X receives certified_apks from A, B, C immediately but delayed receipt from D, E
4. Having all validators generate shares for round R
5. Observing X aggregates [A, B, C] while Y aggregates [A, B, C, D]
6. Confirming different randomness values in execution logs
7. Observing consensus halt due to state root mismatch

## Notes

This vulnerability represents a critical gap in the randomness generation protocol's synchronization guarantees. The system correctly ensures all validators receive each individual validator's certified aug data, but incorrectly assumes validators can immediately start processing shares without waiting for the complete set of certified_apks to be available. This race condition between certified_apk distribution and share aggregation fundamentally breaks the deterministic execution guarantee required for consensus.

### Citations

**File:** types/src/randomness.rs (L103-136)
```rust
#[derive(Clone, SilentDebug)]
pub struct RandKeys {
    // augmented secret / public key share of this validator, obtained from the DKG transcript of last epoch
    pub ask: ASK,
    pub apk: APK,
    // certified augmented public key share of all validators,
    // obtained from all validators in the new epoch,
    // which necessary for verifying randomness shares
    pub certified_apks: Vec<OnceCell<APK>>,
    // public key share of all validators, obtained from the DKG transcript of last epoch
    pub pk_shares: Vec<PKShare>,
}

impl RandKeys {
    pub fn new(ask: ASK, apk: APK, pk_shares: Vec<PKShare>, num_validators: usize) -> Self {
        let certified_apks = vec![OnceCell::new(); num_validators];

        Self {
            ask,
            apk,
            certified_apks,
            pk_shares,
        }
    }

    pub fn add_certified_apk(&self, index: usize, apk: APK) -> anyhow::Result<()> {
        assert!(index < self.certified_apks.len());
        if self.certified_apks[index].get().is_some() {
            return Ok(());
        }
        self.certified_apks[index].set(apk).unwrap();
        Ok(())
    }
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L221-261)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingRandGenRequest>,
        verified_msg_tx: UnboundedSender<RpcRequest<S, D>>,
        rand_config: RandConfig,
        fast_rand_config: Option<RandConfig>,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(rand_gen_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = rand_config.clone();
            let fast_config_clone = fast_rand_config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L378-382)
```rust
        while !self.stop {
            tokio::select! {
                Some(blocks) = incoming_blocks.next(), if self.aug_data_store.my_certified_aug_data_exists() => {
                    self.process_incoming_blocks(blocks);
                }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L69-101)
```rust
pub struct CertifiedAugDataAckState {
    validators: Mutex<HashSet<Author>>,
}

impl CertifiedAugDataAckState {
    pub fn new(validators: impl Iterator<Item = Author>) -> Self {
        Self {
            validators: Mutex::new(validators.collect()),
        }
    }
}

impl<S: TShare, D: TAugmentedData> BroadcastStatus<RandMessage<S, D>, RandMessage<S, D>>
    for Arc<CertifiedAugDataAckState>
{
    type Aggregated = ();
    type Message = CertifiedAugData<D>;
    type Response = CertifiedAugDataAck;

    fn add(&self, peer: Author, _ack: Self::Response) -> anyhow::Result<Option<Self::Aggregated>> {
        let mut validators_guard = self.validators.lock();
        ensure!(
            validators_guard.remove(&peer),
            "[RandMessage] Unknown author: {}",
            peer
        );
        // If receive from all validators, stop the reliable broadcast
        if validators_guard.is_empty() {
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L221-247)
```text
    fun block_prologue_ext(
        vm: signer,
        hash: address,
        epoch: u64,
        round: u64,
        proposer: address,
        failed_proposer_indices: vector<u64>,
        previous_block_votes_bitvec: vector<u8>,
        timestamp: u64,
        randomness_seed: Option<vector<u8>>,
    ) acquires BlockResource, CommitHistory {
        let epoch_interval = block_prologue_common(
            &vm,
            hash,
            epoch,
            round,
            proposer,
            failed_proposer_indices,
            previous_block_votes_bitvec,
            timestamp
        );
        randomness::on_new_block(&vm, epoch, round, randomness_seed);

        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L64-72)
```text
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: Option<vector<u8>>) acquires PerBlockRandomness {
        system_addresses::assert_vm(vm);
        if (exists<PerBlockRandomness>(@aptos_framework)) {
            let randomness = borrow_global_mut<PerBlockRandomness>(@aptos_framework);
            randomness.epoch = epoch;
            randomness.round = round;
            randomness.seed = seed_for_new_block;
        }
    }
```
