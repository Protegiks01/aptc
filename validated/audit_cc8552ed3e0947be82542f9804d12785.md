# Audit Report

## Title
Binary Complexity Check Bypass via Non-Generic Instruction Sequences

## Summary
The Move binary complexity checker fails to meter non-generic bytecode instructions, allowing attackers to publish modules with up to 65,535 non-generic instructions that bypass complexity budgets while forcing expensive multi-pass verification on all validator nodes during transaction execution.

## Finding Description

The binary complexity checking system is designed to prevent resource exhaustion during module verification with a budget of `2048 + blob.code().len() * 20`. [1](#0-0) 

However, the `meter_code()` function only meters generic bytecode variants (CallGeneric, PackGeneric, PackVariantGeneric, UnpackVariantGeneric, etc.) for their type instantiations. [2](#0-1) 

Non-generic instructions—including arithmetic operations (Add, Sub, Mul, Mod, Div), bitwise operations (BitOr, BitAnd, Xor, Shl, Shr), comparison operations (Eq, Neq, Lt, Gt, Le, Ge), boolean operations (Or, And, Not), branches (Branch, BrTrue, BrFalse), local operations (CopyLoc, MoveLoc, StLoc, MutBorrowLoc, ImmBorrowLoc), field accesses (MutBorrowField, ImmBorrowField), and global operations (Exists, MoveTo, MoveFrom, MutBorrowGlobal, ImmBorrowGlobal)—perform no metering at all. [3](#0-2) 

An attacker can create a function with up to 65,535 non-generic instructions, as specified by BYTECODE_COUNT_MAX. [4](#0-3) 

These instructions can fit within a single basic block, bypassing the production limit of 1024 basic blocks. [5](#0-4) 

During module verification, all instructions must be processed by multiple verification passes executed by `verify_module_with_config`. [6](#0-5) 

The type safety verifier iterates through every instruction in the code within each basic block. [7](#0-6) 

While verifier metering provides a secondary defense with max_per_fun_meter_units set to 80,000,000 units [8](#0-7) , the metering cost for simple non-generic instructions is minimal.

The TYPE_NODE_COST is 30 units per simple type [9](#0-8) , and arithmetic operations push only simple types onto the stack. [10](#0-9) 

For 65,535 instructions, this totals approximately 1,966,050 verifier metering units—only 2.45% of the 80,000,000 limit. The binary complexity check becomes completely ineffective while verification still requires multiple complete iterations through all instructions across different verification passes (type safety, reference safety, stack usage, control flow analysis).

## Impact Explanation

This represents **High Severity** under the Aptos bug bounty program's "Validator Node Slowdowns" category. All validators must verify published modules during transaction execution. A malicious module with tens of thousands of non-generic instructions would force all validator nodes to perform expensive multi-pass verification while consuming minimal complexity budget.

The binary complexity check is specifically designed to prevent resource exhaustion during verification, but completely fails for non-generic instructions. This makes it a protocol-level vulnerability rather than a performance issue. The attack causes significant performance degradation that could affect block execution timing and consensus participation across the entire validator network.

## Likelihood Explanation

This vulnerability is highly exploitable:
1. Any user can publish modules to the blockchain via standard transactions without special privileges
2. Creating a module with maximum non-generic instructions is straightforward (e.g., repeated arithmetic operations on local variables)
3. The complexity check is performed on every module publication
4. All validators are affected simultaneously during transaction execution
5. Verification cost scales linearly with instruction count while complexity budget remains constant
6. The attack fits within transaction size limits (arithmetic operations are 1 byte each, allowing 40,000+ instructions within 64KB)

## Recommendation

Modify the `meter_code()` function to charge complexity costs for non-generic instructions. Each instruction should incur a base complexity cost regardless of whether it has generic type parameters. The cost should reflect the actual verification overhead:

```rust
fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
    const INSTRUCTION_BASE_COST: u64 = 1; // Base cost per instruction
    
    self.meter_signature(code.locals)?;
    
    for instr in &code.code {
        // Charge base cost for every instruction
        self.charge(INSTRUCTION_BASE_COST)?;
        
        // Charge additional cost for generic instantiations
        match instr {
            CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                self.meter_function_instantiation(*idx)?;
            },
            // ... rest of generic instruction handling
        }
    }
    Ok(())
}
```

Alternatively, add a separate instruction count check in the complexity budget calculation that accounts for all instructions, not just generic ones.

## Proof of Concept

While a full PoC would require compiling and deploying a Move module, the vulnerability is demonstrable through code analysis:

1. Create a Move function with a loop unrolled to 65,535 arithmetic operations on local variables
2. Compile to bytecode (each arithmetic operation is 1 byte)
3. The binary complexity check will charge only for the locals signature, not the instructions
4. All validators must iterate through all 65,535 instructions multiple times during verification
5. Verifier metering charges only 1,966,050 units (2.45% of budget) despite expensive verification

The vulnerability is confirmed by the code structure where non-generic instructions explicitly match to empty action `()` in the metering function.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1556-1556)
```rust
            let budget = 2048 + blob.code().len() as u64 * 20;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L266-298)
```rust
                CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                    self.meter_function_instantiation(*idx)?;
                },
                PackGeneric(idx) | UnpackGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
                CallClosure(idx)
                | VecPack(idx, _)
                | VecLen(idx)
                | VecImmBorrow(idx)
                | VecMutBorrow(idx)
                | VecPushBack(idx)
                | VecPopBack(idx)
                | VecUnpack(idx, _)
                | VecSwap(idx) => {
                    self.meter_signature(*idx)?;
                },
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L300-380)
```rust
                // List out the other options explicitly so there's a compile error if a new
                // bytecode gets added.
                Pop
                | Ret
                | Branch(_)
                | BrTrue(_)
                | BrFalse(_)
                | LdU8(_)
                | LdU16(_)
                | LdU32(_)
                | LdU64(_)
                | LdU128(_)
                | LdU256(_)
                | LdI8(_)
                | LdI16(_)
                | LdI32(_)
                | LdI64(_)
                | LdI128(_)
                | LdI256(_)
                | LdConst(_)
                | CastU8
                | CastU16
                | CastU32
                | CastU64
                | CastU128
                | CastU256
                | CastI8
                | CastI16
                | CastI32
                | CastI64
                | CastI128
                | CastI256
                | LdTrue
                | LdFalse
                | Call(_)
                | Pack(_)
                | Unpack(_)
                | PackVariant(_)
                | UnpackVariant(_)
                | TestVariant(_)
                | PackClosure(..)
                | ReadRef
                | WriteRef
                | FreezeRef
                | Add
                | Sub
                | Mul
                | Mod
                | Div
                | Negate
                | BitOr
                | BitAnd
                | Xor
                | Shl
                | Shr
                | Or
                | And
                | Not
                | Eq
                | Neq
                | Lt
                | Gt
                | Le
                | Ge
                | CopyLoc(_)
                | MoveLoc(_)
                | StLoc(_)
                | MutBorrowLoc(_)
                | ImmBorrowLoc(_)
                | MutBorrowField(_)
                | ImmBorrowField(_)
                | MutBorrowVariantField(_)
                | ImmBorrowVariantField(_)
                | MutBorrowGlobal(_)
                | ImmBorrowGlobal(_)
                | Exists(_)
                | MoveTo(_)
                | MoveFrom(_)
                | Abort
                | AbortMsg
                | Nop => (),
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-175)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L30-30)
```rust
const TYPE_NODE_COST: u128 = 30;
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L120-125)
```rust
    for block_id in function_view.cfg().blocks() {
        for offset in function_view.cfg().instr_indexes(block_id) {
            let instr = &verifier.function_view.code().code[offset as usize];
            verify_instr(verifier, instr, offset, meter)?
        }
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L1042-1049)
```rust
        Bytecode::Add | Bytecode::Sub | Bytecode::Mul | Bytecode::Mod | Bytecode::Div => {
            let operand1 = safe_unwrap!(verifier.stack.pop());
            let operand2 = safe_unwrap!(verifier.stack.pop());
            if operand1.is_integer() && operand1 == operand2 {
                verifier.push(meter, operand1)?;
            } else {
                return Err(verifier.error(StatusCode::INTEGER_OP_TYPE_MISMATCH_ERROR, offset));
            }
```
