# Audit Report

## Title
Memory Ordering Vulnerability in skip_module_reads_validation Flag Enables Consensus Split

## Summary
The `skip_module_reads_validation` flag in BlockSTM V1 parallel executor uses `Ordering::Relaxed` for both reads and writes, creating a memory ordering race condition. This allows validation threads to skip critical module read validation checks, causing different validators to produce different execution results for identical blocks, leading to consensus splits.

## Finding Description

The vulnerability exists in the memory ordering semantics of the `skip_module_reads_validation` atomic flag used during parallel transaction execution in BlockSTM V1.

The flag is initialized to `true` as an optimization to skip module validation when no modules have been published in the block: [1](#0-0) 

When a transaction publishes a module, the flag is set to `false` using `Ordering::Relaxed`: [2](#0-1) 

During validation, the flag is read with `Ordering::Relaxed` to determine whether to skip module validation: [3](#0-2) [4](#0-3) 

**The Critical Issue:**

`Ordering::Relaxed` provides **no synchronization guarantees** between threads. Although `decrease_validation_idx` is called after setting the flag and uses `Ordering::SeqCst`: [5](#0-4) 

The `SeqCst` operation on `validation_idx` (a different atomic variable) does **not** establish a happens-before relationship with the `skip_module_reads_validation` flag. This allows the following race condition:

**Attack Scenario:**

1. Transaction 5 (higher index) executes first speculatively, reads Module M version 1 from global cache
2. Transaction 3 (lower index) executes, publishes Module M version 2, and commits:
   - Marks Module M as overridden in global cache [6](#0-5) 
   - Sets `skip_module_reads_validation = false` (Relaxed)
   - Calls `decrease_validation_idx(4)` (SeqCst), triggering re-validation of transactions 4+
3. Validation thread picks up Transaction 5 validation task triggered by the new wave
4. **Race occurs**: Validation thread reads `skip_module_reads_validation` with Relaxed and may observe stale value `true`
5. If flag reads as `true`: Module validation is skipped, Transaction 5 passes validation and commits with stale module read
6. If flag reads as `false`: Module validation runs, detects override, aborts Transaction 5 for re-execution

The module validation check would have detected the stale read: [7](#0-6) 

This checks whether the module was marked as overridden: [8](#0-7) 

**Why this breaks consensus:**

Different validator nodes can observe the race outcome differently due to thread scheduling variations. This produces non-deterministic execution:
- **Validator Node A**: Sees flag as `true` → skips check → commits Transaction 5 with Module M v1 results
- **Validator Node B**: Sees flag as `false` → performs check → aborts Transaction 5 → re-executes with Module M v2 → commits different results

This violates the **Deterministic Execution** invariant fundamental to blockchain consensus, causing validators to produce different state roots for identical blocks.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability directly breaks the fundamental consensus invariant that all validators must produce identical state roots for identical blocks. Per Aptos bug bounty Critical severity criteria, this enables:

1. **Consensus/Safety Violations**: Different validators commit blocks with different execution results, breaking BFT safety guarantees even with <1/3 Byzantine nodes
2. **Non-recoverable Network Partition**: Validators diverge into incompatible states, requiring manual intervention or hard fork to resolve
3. **Chain Split**: The network fragments as validators disagree on valid blocks, halting normal operation

The vulnerability affects BlockSTM V1, which is the default parallel execution engine: [9](#0-8) 

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability can be triggered during normal network operation:

1. **Common Trigger**: Module publishing is a standard operation (package upgrades, new deployments)
2. **Race Window**: Exists on every block containing module publishes with dependent transactions
3. **Thread Scheduling**: Natural thread scheduling variations across validator nodes increase probability of divergent outcomes
4. **No Attacker Control Required**: The race manifests naturally due to the code bug, without requiring malicious actors

**Mitigating Factors:**
- Race window is narrow (microseconds between flag write and read)
- Requires transactions reading modules that are published in the same block
- May not manifest on every module publish operation

Despite the narrow window, the **catastrophic impact** (consensus split requiring hard fork) combined with **regular occurrence** of module publishing operations makes this a serious production vulnerability.

## Recommendation

Fix the memory ordering by using `Ordering::Release` for the store and `Ordering::Acquire` for the load to establish proper synchronization:

**In `scheduler_wrapper.rs` line 87:**
```rust
skip_module_reads_validation.store(false, Ordering::Release);
```

**In `executor.rs` line 1372:**
```rust
skip_module_reads_validation.load(Ordering::Acquire),
```

This ensures that when a validation thread observes `false`, it is guaranteed to observe all the module cache updates (marking modules as overridden) that happened before the store. The Release-Acquire synchronization establishes the necessary happens-before relationship.

**Alternative Fix:** Use `Ordering::SeqCst` for both operations if stronger ordering guarantees are desired, though `Release`/`Acquire` is sufficient and more performant.

## Proof of Concept

This vulnerability requires a Rust integration test demonstrating the race condition. The test would need to:

1. Create a block with Transaction 3 publishing Module M and Transaction 5 reading Module M
2. Execute the block using BlockSTM V1 parallel executor
3. Use thread synchronization primitives to force the race timing
4. Demonstrate that Transaction 5 can commit with stale module reads when the race manifests

A minimal reproduction would modify the existing block executor tests to inject deliberate timing delays between the flag store and validation load, proving the race can cause validation to incorrectly pass. However, creating a reliable reproduction test is challenging due to the narrow race window and need to control thread scheduling.

The recommended validation approach is code review confirming the memory ordering bug exists as described, combined with fixing the ordering to `Release`/`Acquire` semantics.

---

**Notes:**
This vulnerability is specific to BlockSTM V1 (the default). BlockSTM V2 uses a different validation architecture and is not affected. The issue stems from incorrect application of Rust's memory ordering semantics - `Ordering::Relaxed` does not provide the synchronization the code comment claims. The fix is straightforward but critical for consensus safety.

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L810-815)
```rust
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1372-1372)
```rust
                        skip_module_reads_validation.load(Ordering::Relaxed),
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1895)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L84-87)
```rust
            SchedulerWrapper::V1(_, skip_module_reads_validation) => {
                // Relaxed suffices as syncronization (reducing validation index) occurs after
                // setting the module read validation flag.
                skip_module_reads_validation.store(false, Ordering::Relaxed);
```

**File:** aptos-move/block-executor/src/scheduler.rs (L820-821)
```rust
            self.validation_idx
                .fetch_update(Ordering::SeqCst, Ordering::Acquire, |val_idx| {
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L115-119)
```rust
    pub fn contains_not_overridden(&self, key: &K) -> bool {
        self.module_cache
            .get(key)
            .is_some_and(|entry| entry.is_not_overridden())
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-317)
```rust
    global_module_cache.mark_overridden(write.module_id());
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1060-1061)
```rust
        let validate = |key: &K, read: &ModuleRead<DC, VC, S>| match read {
            ModuleRead::GlobalCache(_) => global_module_cache.contains_not_overridden(key),
```

**File:** config/src/config/execution_config.rs (L91-91)
```rust
            blockstm_v2_enabled: false,
```
