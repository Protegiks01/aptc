# Audit Report

## Title
Active Validators Can Manipulate total_joining_power to Block New Validator Admission via add_stake() DoS

## Summary
The `total_joining_power` field in `ValidatorSet` is incremented when active validators add stake, allowing incumbent validators to consume the epoch's voting power increase quota and block new validators from joining the validator set, creating a permissionless validator admission denial-of-service mechanism.

## Finding Description

The `total_joining_power` field is documented as "Total voting power waiting to join in the next epoch" [1](#0-0)  and is intended to enforce a governance-configured limit on validator set growth per epoch.

However, the implementation in `add_stake_with_cap()` increments `total_joining_power` for BOTH `active_validators` AND `pending_active` validators. The code explicitly checks if a validator is in either set before calling `update_voting_power_increase()`: [2](#0-1) 

The `update_voting_power_increase()` function unconditionally increments `total_joining_power` and enforces the limit: [3](#0-2) 

This creates a semantic mismatch: while the field name and documentation suggest it tracks validators "joining" the set, active validators (who are already participating in consensus) can consume this quota. The stated rationale for the limit is to "prevent a massive amount of new stake from joining that can potentially take down the network if corresponding validators are not ready to participate in consensus in time" [4](#0-3)  â€” but this rationale does not apply to active validators already participating.

**Attack Execution:**
1. Active validators call `add_stake()` to add stake equal to the voting power increase limit (e.g., 20% of total voting power)
2. This increments `total_joining_power` to the maximum allowed for the epoch
3. New validators attempting `join_validator_set_internal()` are blocked with `EVOTING_POWER_INCREASE_EXCEEDS_LIMIT` [5](#0-4) 
4. Active validators can later unlock their added stake via `unlock_with_cap()`, which moves stake to `pending_inactive` but never decrements `total_joining_power` [6](#0-5) 
5. The attack can be repeated each epoch as `total_joining_power` resets to 0 at epoch boundaries [7](#0-6) 

## Impact Explanation

This vulnerability enables **validator set centralization** through admission denial-of-service. While active validators adding stake is tracked intentionally per code comments [8](#0-7) , the implementation is overly broad compared to the documented security purpose, which specifically targets preventing network instability from new validators not ready for consensus participation.

**Severity: Medium to High** - This constitutes a significant protocol violation that undermines the permissionless validator admission mechanism. While it doesn't cause direct fund loss or consensus safety violations (thus not Critical), it fundamentally compromises blockchain decentralization by enabling incumbent validators to maintain a closed validator set.

Long-term impacts include:
- Reduced validator diversity and increased consensus attack surface
- Economic centralization as rewards concentrate among incumbents
- Network governance control by a validator cartel

## Likelihood Explanation

**Likelihood: Medium** - While the attack mechanism is straightforward (calling public entry functions), practical execution faces meaningful constraints:

**Capital Requirements**: Attackers must provide NEW capital equal to the voting power increase limit (typically 20% of total voting power). If total voting power is 1 billion APT, this requires 200 million APT in fresh capital, which is substantial even for well-capitalized validators.

**Lockup Constraints**: Added stake enters a lockup period during which it cannot be withdrawn, imposing opportunity costs on attackers.

**Economic Rationality**: Incumbent validators do benefit from blocking competition (maintaining reward share), providing clear incentive. The attack is repeatable each epoch.

**Coordination**: May require coordination among multiple validators or a single well-capitalized entity controlling multiple validator operations.

The attack doesn't require >1/3 Byzantine validators (within threat model), but does require significant capital deployment, making it more viable for well-funded actors rather than being "trivially executable."

## Recommendation

Modify `add_stake_with_cap()` to only call `update_voting_power_increase()` for validators in the `pending_active` state (truly "joining" the set), not for `active_validators`:

```move
// Only track voting power increase for pending_active validators joining the set
let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
if (option::is_some(&find_validator(&validator_set.pending_active, pool_address))) {
    update_voting_power_increase(amount);
};
```

Alternatively, if limiting all voting power increases is truly intended, rename the field to `total_voting_power_increase` and update documentation to clarify the mechanism applies to all stake additions, not just new validator admissions.

## Proof of Concept

A Move test case demonstrating the attack:

```move
#[test(aptos_framework = @aptos_framework, validator1 = @0x123, validator2 = @0x456, new_validator = @0x789)]
public entry fun test_active_validator_blocks_new_admission(
    aptos_framework: &signer,
    validator1: &signer, 
    validator2: &signer,
    new_validator: &signer
) {
    // Setup: Initialize staking with 20% voting power increase limit
    // validator1 is active with 500 voting power
    // Total voting power = 1000
    
    // Attack: validator1 adds 200 stake (20% of total voting power)
    stake::add_stake(validator1, 200);
    // total_joining_power is now 200 (at limit)
    
    // Impact: new_validator cannot join
    stake::initialize_validator(new_validator, ...);
    stake::add_stake(new_validator, 300);
    
    // This should fail with EVOTING_POWER_INCREASE_EXCEEDS_LIMIT
    stake::join_validator_set(new_validator);
}
```

## Notes

The behavior is partially intentional per code comments, but the implementation creates an exploitable condition where the security mechanism (designed to prevent instability from unprepared new validators) can be weaponized by incumbents to block permissionless admission. The semantic mismatch between documented intent and implementation creates the vulnerability.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L191-192)
```text
        // Total voting power waiting to join in the next epoch.
        total_joining_power: u128,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L824-832)
```text
        // Only track and validate voting power increase for active and pending_active validator.
        // Pending_inactive validator will be removed from the validator set in the next epoch.
        // Inactive validator's total stake will be tracked when they join the validator set.
        let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
        // Search directly rather using get_validator_state to save on unnecessary loops.
        if (option::is_some(&find_validator(&validator_set.active_validators, pool_address)) ||
            option::is_some(&find_validator(&validator_set.pending_active, pool_address))) {
            update_voting_power_increase(amount);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1079-1079)
```text
        update_voting_power_increase(voting_power);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1403-1403)
```text
        validator_set.total_joining_power = 0;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1857-1869)
```text
    fun update_voting_power_increase(increase_amount: u64) acquires ValidatorSet {
        let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
        let voting_power_increase_limit =
            (staking_config::get_voting_power_increase_limit(&staking_config::get()) as u128);
        validator_set.total_joining_power = validator_set.total_joining_power + (increase_amount as u128);

        // Only validator voting power increase if the current validator set's voting power > 0.
        if (validator_set.total_voting_power > 0) {
            assert!(
                validator_set.total_joining_power <= validator_set.total_voting_power * voting_power_increase_limit / 100,
                error::invalid_argument(EVOTING_POWER_INCREASE_EXCEEDS_LIMIT),
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L67-70)
```text
        // Only this % of current total voting power is allowed to join the validator set in each epoch.
        // This is necessary to prevent a massive amount of new stake from joining that can potentially take down the
        // network if corresponding validators are not ready to participate in consensus in time.
        // This value is within (0, 50%), not inclusive.
```
