# Audit Report

## Title
ECDSA Signature Malleability in ethereum_derivable_account Due to Missing Low-S Canonicalization

## Summary
The native `ecdsa_recover()` function used by `ethereum_derivable_account` does not enforce low-s canonicalization, allowing secp256k1 ECDSA signature malleability. This creates transaction hash ambiguity where the same logical transaction can exist with multiple valid signatures, violating protocol consistency guarantees.

## Finding Description

**The Core Issue:**

The `native_ecdsa_recover()` function uses `libsecp256k1::Signature::parse_standard_slice()` to parse signatures without checking for high-s values. [1](#0-0) 

In contrast, regular secp256k1 transaction authentication properly enforces low-s canonicalization by checking `if self.0.s.is_high()` and rejecting such signatures. [2](#0-1) 

The `aptos-crypto` implementation correctly rejects high-s signatures in its `verify()` method, but this protection is bypassed when using the native `ecdsa_recover` function through abstract authenticators.

**Attack Mechanism:**

ECDSA signatures have an inherent malleability property: for any valid signature `(r, s)`, there exists a mathematically equivalent signature `(r, n-s)` where `n` is the curve order. Both signatures are cryptographically valid for the same message and recover to the same public key (with adjusted recovery_id).

When a transaction using `ethereum_derivable_account` authentication is submitted:

1. The authentication flow calls `ecdsa_recover()` via Move, specifically in the `recover_public_key()` function. [3](#0-2) 

2. This invokes the native function which accepts both high-s and low-s signatures through `libsecp256k1::recover()`. [4](#0-3) 

3. An attacker observing the transaction can create a malleable variant with the same `RawTransaction` but different signature.

4. Both transactions pass validation but have different transaction hashes since the signature is part of the authenticator. The `AccountAuthenticator::verify()` for abstract authentication only validates the signing message digest, not the signature canonicalization. [5](#0-4) 

**Consensus Impact:**

The consensus deduplication logic uses `(committed_hash, authenticator)` pairs to filter duplicates. [6](#0-5) 

The `committed_hash()` method includes the entire `SignedTransaction` (including the authenticator) in the hash calculation. [7](#0-6) 

Since malleable signatures produce different hashes AND different authenticators, they are NOT deduplicated at the consensus level. This means:

- Different validators may see different malleable versions first
- Different validators may propose blocks containing different versions
- Transaction hash becomes non-deterministic for the same logical operation
- Off-chain indexers and APIs may track the same execution under multiple transaction IDs

## Impact Explanation

**Severity: Medium**

This qualifies as **"Limited Protocol Violations"** per Aptos bug bounty criteria:

1. **Protocol Inconsistency**: Creates a discrepancy between regular secp256k1 authentication (which enforces low-s canonicalization) and abstract authentication via `ethereum_derivable_account` (which doesn't). This violates the implicit protocol guarantee that transaction hash uniquely identifies a transaction.

2. **Transaction Hash Ambiguity**: The same logical transaction can exist with multiple valid hashes, breaking assumptions that transaction hash uniquely identifies a transaction execution.

3. **Operational Impact**: 
   - Off-chain indexers may record duplicate executions under different hashes
   - Transaction status tracking becomes ambiguous
   - Mempool implementations across validators may hold different versions
   - Block proposals may include different versions, wasting consensus bandwidth and validator resources

4. **Not Critical Because**:
   - Sequence numbers prevent actual double-execution [8](#0-7) 
   - Consensus safety is not broken (validators still agree on state)
   - No direct funds loss or theft vector
   - Network remains available

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Any attacker can observe ethereum_derivable_account transactions in the mempool and create malleable versions by simply flipping `s` to `n-s` and adjusting the recovery_id.

2. **No Special Privileges Required**: Does not require validator access or special permissions.

3. **Ethereum Derivable Accounts in Use**: The `ethereum_derivable_account` module is actively deployed and used for SIWE (Sign In With Ethereum) authentication, supporting multiple wallets including Metamask, Phantom, Coinbase, OKX, Exodus, and Backpack. [9](#0-8) 

4. **Network Propagation**: Malleable variants would naturally propagate through the P2P network to different validators.

## Recommendation

Add low-s canonicalization checking to the `native_ecdsa_recover()` function to match the protection present in regular secp256k1 authentication:

```rust
// After parsing the signature, add:
if sig.s.is_high() {
    return Err(SafeNativeError::Abort {
        abort_code: abort_codes::NFE_DESERIALIZE,
    });
}
```

This ensures consistency across all secp256k1 signature verification paths and prevents signature malleability attacks.

## Proof of Concept

A proof of concept can be constructed by:

1. Creating a valid `ethereum_derivable_account` transaction with signature `(r, s, v)`
2. Computing the malleable signature `(r, n-s, v')` where `n` is the secp256k1 curve order and `v'` is the adjusted recovery ID
3. Submitting both transactions to different validators
4. Observing that both transactions pass validation but produce different `committed_hash()` values
5. Confirming that consensus deduplication does not detect them as duplicates

The malleability can be demonstrated using standard secp256k1 libraries to show that both signatures recover to the same public key and pass all validation checks in the `ethereum_derivable_account` authentication flow.

## Notes

This vulnerability represents a protocol-level inconsistency rather than a critical safety violation. While sequence numbers prevent double-execution of the same transaction, the existence of multiple valid transaction hashes for the same logical operation violates protocol consistency guarantees and creates operational challenges for indexers, APIs, and consensus efficiency. The fix is straightforward and aligns the `ecdsa_recover` path with the existing protection in regular secp256k1 authentication.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L65-72)
```rust
    let sig = match libsecp256k1::Signature::parse_standard_slice(&signature) {
        Ok(sig) => sig,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE,
            });
        },
    };
```

**File:** aptos-move/framework/src/natives/cryptography/secp256k1.rs (L77-83)
```rust
    match libsecp256k1::recover(&msg, &sig, &rid) {
        Ok(pk) => Ok(smallvec![
            Value::vector_u8(pk.serialize()[1..].to_vec()),
            Value::bool(true)
        ]),
        Err(_) => Ok(smallvec![Value::vector_u8([0u8; 0]), Value::bool(false)]),
    }
```

**File:** crates/aptos-crypto/src/secp256k1_ecdsa.rs (L216-217)
```rust
        if self.0.s.is_high() {
            Err(anyhow!(CryptoMaterialError::CanonicalRepresentationError))
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L18-24)
```text
/// 4. This module has been tested for the following wallets:
/// - Metamask
/// - Phantom
/// - Coinbase
/// - OKX
/// - Exodus
/// - Backpack
```

**File:** aptos-move/framework/aptos-framework/sources/account/common_account_abstractions/ethereum_derivable_account.move (L158-158)
```text
        let maybe_recovered = secp256k1::ecdsa_recover(*message, v - 27, &signature);
```

**File:** types/src/transaction/authenticator.rs (L779-790)
```rust
            Self::Abstract { authenticator } => {
                let original_signing_message = signing_message(message)?;
                ensure!(
                    authenticator.signing_message_digest()
                        == &AASigningData::signing_message_digest(
                            original_signing_message,
                            authenticator.function_info().clone()
                        )?,
                    "The signing message digest provided in Abstract Authenticator is not expected"
                );
                Ok(())
            },
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L68-68)
```rust
                true => Some((txn.committed_hash(), txn.authenticator())),
```

**File:** types/src/transaction/mod.rs (L1335-1339)
```rust
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L238-241)
```text
            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
```
