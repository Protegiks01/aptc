# Audit Report

## Title
Missing JWK Type Validation in Consensus Allows Unsupported Keys to Block Keyless Authentication

## Summary
The JWK consensus system in per-key mode does not validate that observed JWKs are of a supported type (RSA) before processing them through consensus and storing them on-chain. This allows `UnsupportedJWK` entries to be stored in `ObservedJWKs`, which are then rejected during keyless authentication, causing complete denial-of-service for all users of the affected OIDC provider.

## Finding Description

The JWK consensus system enables validators to observe JSON Web Keys from approved OIDC providers and reach consensus on storing them on-chain for keyless authentication. However, critical validation gaps allow unusable keys to be stored on-chain.

**Vulnerability Flow:**

1. **JWK Observation & Parsing**: When validators fetch JWKs from OIDC providers, the `fetch_jwks_from_jwks_uri` function converts JSON keys to JWK objects. [1](#0-0)  The conversion uses `JWK::from` which attempts RSA parsing first, and if that fails, creates an `UnsupportedJWK`. [2](#0-1) 

   RSA parsing explicitly requires the `kty` field to equal "RSA", which ECDSA/EdDSA keys will not satisfy. [3](#0-2) 

2. **Consensus Processing Without Validation**: In per-key consensus mode, the `process_new_observation` function creates `KeyLevelUpdate` entries with `to_upsert: Some(y.clone())` where `y` can be any `JWK` variant, including `UnsupportedJWK`. [4](#0-3)  The `KeyLevelUpdate` struct definition confirms `to_upsert` is an `Option<JWK>` with no type restrictions. [5](#0-4) 

   The `new_rb_request()` function in `PerKeyMode` simply extracts issuer and kid from the payload without validating the JWK type. [6](#0-5) 

3. **On-Chain Storage**: The Move function `upsert_into_observed_jwks` stores JWKs without type validation. It only checks if a JWK is an `UnsupportedJWK` to determine if it's a DELETE command by checking for a special payload, but otherwise stores any JWK type. [7](#0-6) 

4. **Authentication Rejection**: During keyless signature validation, `get_jwk_for_authenticator` explicitly rejects `UnsupportedJWK` entries with an error message stating the JWK "is not supported". [8](#0-7)  This rejection also occurs in both ZK and OpenID signature verification paths. [9](#0-8) [10](#0-9) 

**Design Intent vs. Implementation**: The Move module documentation clearly states that `UnsupportedJWK` "represents the JWKs which were observed but not yet supported by Aptos" and that "Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated." [11](#0-10)  This indicates `UnsupportedJWK` is meant as a signal for system updates, not as permanent on-chain state that blocks authentication.

**Attack Scenario**: If an approved OIDC provider migrates from RSA to ECDSA keys (or publishes only ECDSA keys), validators will observe these keys, convert them to `UnsupportedJWK`, reach consensus, and store them on-chain. All users attempting keyless authentication with that provider will then fail, experiencing complete DoS until either the provider reverts to RSA keys or Aptos governance manually removes the invalid entries.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring manual intervention" per Aptos bug bounty criteria:

- **Complete User DoS**: All users of an affected OIDC provider lose keyless authentication capability entirely
- **State Bloat**: Unusable `UnsupportedJWK` entries consume on-chain storage indefinitely with no automatic cleanup mechanism
- **Validator Resource Waste**: Validators expend CPU, network bandwidth, and storage resources on consensus for keys that can never be used
- **Recovery Complexity**: Remediation requires either (a) OIDC provider reverting to RSA keys, or (b) Aptos governance intervention to manually remove the invalid entries

The impact is limited to the keyless authentication feature and does not directly affect consensus safety, cause fund theft, or halt the entire network, placing it at Medium rather than High/Critical severity.

## Likelihood Explanation

**Medium to High Likelihood**:

- **Realistic Scenario**: OIDC providers regularly upgrade cryptographic algorithms as part of security best practices. While many maintain backward compatibility, there is no guarantee all providers will continue supporting RSA indefinitely
- **No Attacker Required**: This vulnerability can be triggered through normal, legitimate provider operations without any malicious intent
- **Already Observable**: Some OIDC providers already publish mixed key sets containing both RSA and ECDSA keys, meaning `UnsupportedJWK` entries may already be present in the observation flow
- **Low Barrier to Trigger**: Does not require validator collusion, privileged access, or complex attack choreography - simply requires an OIDC provider to update their key configuration
- **No Mitigation Controls**: No automatic filtering, warnings, or safeguards exist to prevent this scenario

## Recommendation

Add JWK type validation in the consensus processing pipeline before initiating consensus sessions:

1. **In `KeyLevelConsensusManager::process_new_observation`**: Filter out `UnsupportedJWK` entries before creating `KeyLevelUpdate` objects, or log warnings without initiating consensus.

2. **In `IssuerLevelConsensusManager::process_new_observation`**: Similarly filter `UnsupportedJWK` entries from the observed JWK set before initiating consensus.

3. **Add monitoring**: Emit events or logs when `UnsupportedJWK` entries are observed, alerting operators to provider key format changes without storing unusable keys on-chain.

4. **Alternative approach**: Extend the system to support additional key types (ECDSA, EdDSA) to handle provider migrations gracefully.

## Proof of Concept

A proof of concept would involve:
1. Setting up a test OIDC provider that returns ECDSA keys instead of RSA keys
2. Configuring validators to observe this provider
3. Demonstrating that `UnsupportedJWK` entries are stored on-chain
4. Showing that keyless authentication attempts fail for all users of this provider

The vulnerability is confirmed through code analysis showing the complete execution path from JWK observation through consensus to authentication rejection, with no validation preventing `UnsupportedJWK` entries from being stored on-chain.

## Notes

This vulnerability affects specifically the per-key consensus mode, though the issuer-level mode has similar characteristics. The core issue is the lack of type validation before consensus processing, allowing the system to reach consensus on keys that cannot be used for authentication. The design documentation clearly indicates `UnsupportedJWK` was intended as a signal rather than a permanent state, but the implementation lacks the necessary filtering to enforce this intent.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** types/src/jwks/rsa/mod.rs (L143-146)
```rust
        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L132-157)
```rust
                (Some(x), Some(y)) => {
                    if x == y {
                        // No change, drop any in-progress consensus.
                        self.states_by_key.remove(&(issuer.clone(), kid.clone()));
                    } else {
                        // Update detected.
                        let update = KeyLevelUpdate {
                            issuer: issuer.clone(),
                            base_version: effectively_onchain.version,
                            kid: kid.clone(),
                            to_upsert: Some(y.clone()),
                        };
                        self.maybe_start_consensus(update)
                            .context("process_new_observation failed at upsert consensus init")?;
                    }
                },
                (None, Some(y)) => {
                    // Insert detected.
                    let update = KeyLevelUpdate {
                        issuer: issuer.clone(),
                        base_version: effectively_onchain.version,
                        kid: kid.clone(),
                        to_upsert: Some(y.clone()),
                    };
                    self.maybe_start_consensus(update)
                        .context("process_new_observation failed at upsert consensus init")?;
```

**File:** types/src/jwks/mod.rs (L325-330)
```rust
pub struct KeyLevelUpdate {
    pub issuer: Issuer,
    pub base_version: u64,
    pub kid: KID,
    pub to_upsert: Option<JWK>, // If none, it is a deletion.
}
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L68-73)
```text
    /// An JWK variant that represents the JWKs which were observed but not yet supported by Aptos.
    /// Observing `UnsupportedJWK`s means the providers adopted a new key type/format, and the system should be updated.
    struct UnsupportedJWK has copy, drop, store {
        id: vector<u8>,
        payload: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L479-492)
```text
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L140-146)
```rust
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L366-366)
```rust
            JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L397-397)
```rust
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
```
