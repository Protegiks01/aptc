# Audit Report

## Title
Memory Exhaustion via Unbounded RPC Response Buffer Accumulation in Streaming Protocol

## Summary
The inbound streaming protocol for RPC responses fails to validate the total accumulated message size during fragment reassembly, allowing malicious peers to cause memory exhaustion by sending oversized responses that exceed the intended 64 MiB limit. This can lead to validator node slowdowns or crashes, affecting network availability.

## Finding Description

The Aptos networking layer uses a streaming protocol to fragment large messages that exceed the 4 MiB frame size. The network configuration defines `MAX_FRAME_SIZE = 4 MiB` and `MAX_MESSAGE_SIZE = 64 MiB`. [1](#0-0) 

When a `Peer` is initialized, it calculates `max_fragments` using integer division: `max_fragments = max_message_size / max_frame_size`, which equals 16. [2](#0-1) 

This `max_fragments` value is then used to create an `InboundStreamBuffer`: [3](#0-2) 

On the **outbound** side, the `OutboundStream` properly validates that the total message size doesn't exceed `max_message_size` before streaming: [4](#0-3) 

However, on the **inbound** side, `InboundStream::new()` only validates the fragment count, NOT the total accumulated byte size: [5](#0-4) 

The validation only checks that `header.num_fragments <= max_fragments` (line 151-152), but never validates the actual byte size of data in the header's `NetworkMessage` or the cumulative size as fragments arrive.

When fragments arrive, they are appended directly to the message buffer without any size validation: [6](#0-5) 

**The Vulnerability:** With `max_fragments = 16`, a malicious peer can exploit an off-by-one error in the fragment accounting:

1. Send a `StreamHeader` with `num_fragments=16` and ~4 MiB of data in the `NetworkMessage.raw_response` field
2. Send 16 `StreamFragment` messages, each with ~4 MiB in the `raw_data` field  
3. **Total accumulated: 4 MiB (header) + 16 Ã— 4 MiB (fragments) = 68 MiB**

This exceeds the intended 64 MiB limit because the validation logic incorrectly assumes the header contains no data. The accumulated response is passed to the application layer without any total size check: [7](#0-6) 

With `MAX_CONCURRENT_OUTBOUND_RPCS = 100` [8](#0-7) , an attacker can trigger 100 concurrent oversized responses, leading to ~6.8 GB of memory consumption per targeted node.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria: "Validator Node Slowdowns")

This vulnerability enables a resource exhaustion attack through a protocol validation bug, qualifying as "DoS through resource exhaustion" which is explicitly listed as HIGH severity in the bounty program. The attack can:

- Cause memory exhaustion on validator nodes (6.8+ GB per attack round)
- Lead to significant performance degradation affecting consensus participation
- Trigger out-of-memory conditions causing node crashes
- Impact network liveness if multiple validators are affected simultaneously

Unlike volumetric network DoS attacks (which are out of scope), this is an application-layer protocol bug that allows bypassing configured resource limits through crafted but otherwise valid protocol messages.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity:** Low - attacker only needs to establish network connection and send crafted stream messages
- **Attacker Requirements:** No special privileges required, any network peer can execute the attack
- **Detection Difficulty:** Difficult to distinguish from legitimate large message traffic
- **Exploitability:** Straightforward - send properly formatted but oversized stream messages
- **Attack Surface:** All validator and fullnode endpoints accepting RPC requests are vulnerable

The vulnerability is readily exploitable by any malicious peer that can establish network connections to Aptos nodes.

## Recommendation

Add total accumulated size validation in `InboundStream::append_fragment()` to enforce the `max_message_size` limit:

```rust
fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
    // ... existing validation ...
    
    // NEW: Validate total accumulated size before appending
    let current_size = self.message.data_len();
    let new_size = current_size + fragment.raw_data.len();
    ensure!(
        new_size <= self.max_message_size,
        "Stream accumulated size {} exceeds max message size {}!",
        new_size,
        self.max_message_size
    );
    
    // Append the fragment data to the message
    // ... existing code ...
}
```

The `InboundStream` struct should also store `max_message_size` in its fields for this validation to work properly.

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
// This would be added to network/framework/src/protocols/stream/mod.rs tests

#[test]
fn test_inbound_stream_size_bypass() {
    use crate::protocols::wire::messaging::v1::{NetworkMessage, RpcResponse};
    
    let max_fragments = 16; // 64 MiB / 4 MiB
    let frame_size = 4 * 1024 * 1024; // 4 MiB
    
    // Create header with max frame size of data
    let mut raw_response = vec![0u8; frame_size];
    let stream_header = StreamHeader {
        request_id: 1,
        num_fragments: 16,
        message: NetworkMessage::RpcResponse(RpcResponse {
            request_id: 1,
            priority: 0,
            raw_response,
        }),
    };
    
    let mut inbound_stream = InboundStream::new(stream_header, max_fragments).unwrap();
    
    // Append 16 fragments, each with max frame size
    for fragment_id in 1..=16 {
        let fragment = StreamFragment {
            request_id: 1,
            fragment_id,
            raw_data: vec![0u8; frame_size],
        };
        inbound_stream.append_fragment(fragment).unwrap();
    }
    
    // Total accumulated: 4 MiB (header) + 16 * 4 MiB = 68 MiB
    // This exceeds the intended 64 MiB limit
    assert_eq!(inbound_stream.message.data_len(), 17 * frame_size);
    assert!(inbound_stream.message.data_len() > 64 * 1024 * 1024);
}
```

### Citations

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** network/framework/src/peer/mod.rs (L194-194)
```rust
            inbound_stream: InboundStreamBuffer::new(max_fragments),
```

**File:** network/framework/src/peer/mod.rs (L551-554)
```rust
            StreamMessage::Fragment(fragment) => {
                if let Some(message) = self.inbound_stream.append_fragment(fragment)? {
                    self.handle_inbound_network_message(message)?;
                }
```

**File:** network/framework/src/protocols/stream/mod.rs (L124-161)
```rust
    fn new(header: StreamHeader, max_fragments: usize) -> anyhow::Result<Self> {
        // Verify that max fragments is within reasonable bounds
        ensure!(
            max_fragments > 0,
            "Max fragments must be greater than zero!"
        );
        ensure!(
            max_fragments <= (u8::MAX as usize),
            "Max fragments exceeded the u8 limit: {} (max: {})!",
            max_fragments,
            u8::MAX
        );

        // Verify the header message type
        let header_message = header.message;
        ensure!(
            !matches!(header_message, NetworkMessage::Error(_)),
            "Error messages cannot be streamed!"
        );

        // Verify the number of fragments specified in the header
        let header_num_fragments = header.num_fragments;
        ensure!(
            header_num_fragments > 0,
            "Stream header must specify at least one fragment!"
        );
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );

        Ok(Self {
            request_id: header.request_id,
            num_fragments: header_num_fragments,
            received_fragment_id: 0,
            message: header_message,
        })
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```

**File:** network/framework/src/constants.rs (L13-13)
```rust
pub const MAX_CONCURRENT_OUTBOUND_RPCS: u32 = 100;
```
