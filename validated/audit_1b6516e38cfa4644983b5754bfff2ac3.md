# Audit Report

## Title
Signature Bypass in RoundTimeout Verification Allows Timeout Reason Manipulation

## Summary
The `verify()` method in `RoundTimeout` does not validate that the cryptographic signature covers the `reason` field, allowing Byzantine validators to inject arbitrary timeout reasons that pass verification and manipulate consensus liveness behavior.

## Finding Description

The `RoundTimeout` struct contains four fields: `timeout`, `author`, `reason`, and `signature`. [1](#0-0) 

The `verify()` method only validates that the signature covers `self.timeout.signing_format()`, which returns a `TimeoutSigningRepr` containing only `epoch`, `round`, and `hqc_round` - explicitly excluding the `reason` field. [2](#0-1) 

The `TimeoutSigningRepr` structure is defined with only three fields: `epoch`, `round`, and `hqc_round`. [3](#0-2)  The `signing_format()` method constructs this limited representation. [4](#0-3) 

This breaks the cryptographic correctness invariant: the signature does not cover all security-relevant fields. A Byzantine validator can:

1. Create a legitimate `RoundTimeout` for their local timeout
2. Sign it using the normal signing process (signature covers only epoch/round/hqc_round) [5](#0-4) 
3. Replace the `reason` field with malicious data (e.g., `PayloadUnavailable { missing_authors: <targeted_validators> }`)
4. Broadcast the modified message

The attack is feasible because during timeout creation, the signature is generated **before** the reason is computed, and they are passed separately to `RoundTimeout::new()`. [6](#0-5) 

The modified message passes verification because `verify()` only checks the signature validity for the `timeout` component, not the `reason` field.

The `reason` field has significant behavioral impact:

**Timeout Reason Aggregation**: When forming a timeout certificate, validators aggregate timeout reasons by voting power, and the reason with f+1 voting power becomes the consensus reason. [7](#0-6) 

**Failure Tracking**: The `ExponentialWindowFailureTracker` treats `PayloadUnavailable` timeouts specially - they trigger exponential window growth (doubling up to max_window). [8](#0-7)  Authors listed in `missing_authors` are excluded from optimistic proposal generation. [9](#0-8) [10](#0-9) 

Other timeout reasons (`ProposalNotReceived`, `NoQC`, `Unknown`) are treated as successes and do not trigger window growth penalties, as evidenced by the matcher function. [11](#0-10) 

## Impact Explanation

**Severity: High** (Significant protocol violation affecting consensus liveness)

A Byzantine validator can:
- Inject fabricated `PayloadUnavailable` reasons claiming arbitrary validators failed to provide payload
- Manipulate timeout reason aggregation weighted by their voting power
- If they control f+1 voting power, force the aggregated reason to be their malicious `PayloadUnavailable`
- Trigger exponential backoff in the failure tracker (doubling window from 2 to max_window)
- Cause honest validators to be excluded from optimistic proposal generation

This constitutes a **significant protocol violation** affecting consensus liveness behavior. While it does not directly cause consensus safety violations (no double-spending or chain splits) or total network failure, it allows manipulation of the timeout mechanism and degradation of proposal efficiency, which can impact network performance and unfairly penalize honest validators.

Per Aptos bug bounty criteria, this aligns with **High Severity**: a validator-level protocol violation that affects consensus behavior and network performance without causing fund loss or complete network halt.

The attack does not require network-level capabilities - a single Byzantine validator can exploit this by manipulating their own timeout messages before broadcasting. This is within the AptosBFT threat model which tolerates up to f Byzantine validators in a 3f+1 configuration.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - a Byzantine validator simply modifies the `reason` field after signing but before broadcasting
- **Attacker Requirements**: Requires being a validator with voting power; impact scales with controlled voting power
- **Detection Difficulty**: Hard to detect - manipulated messages pass cryptographic verification and appear legitimate
- **Preconditions**: Requires timeout scenarios, which naturally occur during network delays, slow proposals, or actual payload unavailability

The vulnerability exists in every round timeout scenario and is exploitable by any Byzantine validator with sufficient voting power to influence aggregation (f+1).

## Recommendation

Include the `reason` field in the `TimeoutSigningRepr` structure that is cryptographically signed:

```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason: RoundTimeoutReason,  // Add this field
}
```

Update `TwoChainTimeout::signing_format()` to include the reason parameter, and modify the signing flow in `round_manager.rs` to compute the reason before signing, ensuring the signature covers all security-relevant fields of the timeout message.

## Proof of Concept

```rust
// This demonstrates the vulnerability by showing that:
// 1. A RoundTimeout can be created with one reason
// 2. The reason can be changed after creation
// 3. The signature verification still passes

#[test]
fn test_timeout_reason_not_covered_by_signature() {
    use aptos_consensus_types::{
        round_timeout::{RoundTimeout, RoundTimeoutReason},
        timeout_2chain::TwoChainTimeout,
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
    };
    use aptos_bitvec::BitVec;
    
    let (signers, verifier) = random_validator_verifier(4, None, false);
    
    // Create a legitimate timeout with Unknown reason
    let timeout = TwoChainTimeout::new(
        1,
        5,
        QuorumCert::certificate_for_genesis(),
    );
    let signature = timeout.sign(&signers[0]).unwrap();
    
    let mut round_timeout = RoundTimeout::new(
        timeout.clone(),
        signers[0].author(),
        RoundTimeoutReason::Unknown,
        signature.clone(),
    );
    
    // Verify it passes with Unknown reason
    assert!(round_timeout.verify(&verifier).is_ok());
    
    // Maliciously replace reason with PayloadUnavailable targeting validator 1
    let mut malicious_missing_authors = BitVec::with_num_bits(4);
    malicious_missing_authors.set(1);
    let malicious_reason = RoundTimeoutReason::PayloadUnavailable {
        missing_authors: malicious_missing_authors,
    };
    
    // Create a new RoundTimeout with the SAME signature but DIFFERENT reason
    let manipulated_timeout = RoundTimeout::new(
        timeout,
        signers[0].author(),
        malicious_reason,  // Different reason!
        signature,         // Same signature!
    );
    
    // The manipulated timeout still passes verification!
    assert!(manipulated_timeout.verify(&verifier).is_ok());
    
    // This demonstrates that the signature does not cover the reason field
}
```

## Notes

This vulnerability represents a fundamental cryptographic protocol flaw where a signature does not cover all security-relevant fields. The separation between signature generation and reason computation in the codebase makes this exploitable by any Byzantine validator. The impact on consensus liveness and validator reputation makes this a significant security issue that should be addressed by including the `reason` field in the signed data structure.

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L37-45)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L59-64)
```rust
    pub fn sign(
        &self,
        signer: &ValidatorSigner,
    ) -> Result<bls12381::Signature, CryptoMaterialError> {
        signer.sign(&self.signing_format())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L98-103)
```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/src/round_manager.rs (L1009-1030)
```rust
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;

                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
```

**File:** consensus/src/pending_votes.rs (L93-152)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L145-160)
```rust
        let exclude_authors = tracker.get_exclude_authors();
        if !exclude_authors.is_empty() {
            let exclude_authors_str: Vec<_> =
                exclude_authors.iter().map(|a| a.short_str()).collect();
            for author in &exclude_authors_str {
                counters::OPTQS_EXCLUDE_AUTHORS_COUNT
                    .with_label_values(&[author.as_str()])
                    .inc();
            }
            warn!("OptQS exclude authors: {:?}", exclude_authors_str);
        }
        Some(OptQSPayloadPullParams {
            exclude_authors,
            minimum_batch_age_usecs: self.minimum_batch_age_usecs,
        })
    }
```
