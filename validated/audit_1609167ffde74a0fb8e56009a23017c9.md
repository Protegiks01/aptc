# Audit Report

## Title
Byzantine Validators Can Crash Consensus Nodes via Empty Weights HashMap in Secret Share Aggregation

## Summary
The `SecretShareStore` in the consensus layer contains unchecked `expect()` calls that panic when looking up validator weights in an empty HashMap. Byzantine validators can trigger these panics by sending valid secret shares before a victim node adds its own share, causing the victim's consensus node to crash and lose liveness.

## Finding Description

The vulnerability exists in the secret sharing aggregation logic used during consensus randomness generation. The root cause is an incomplete implementation where the `weights` HashMap in `SecretShareConfig` is initialized as empty but never populated. [1](#0-0) 

The `get_peer_weight()` method returns a hardcoded value of `1` for all peers: [2](#0-1) 

While `get_peer_weights()` returns a reference to the empty HashMap: [3](#0-2) 

This creates a critical inconsistency in `SecretShareStore`. When shares from other validators arrive via the network, they are successfully added using `add_share()`: [4](#0-3) 

The `add_share()` method uses `get_peer_weight()` at line 260, which returns `1`, so Byzantine shares are successfully added to the aggregator.

However, when the node processes its own block and calls `add_self_share()`, it retrieves the empty HashMap and passes it to `add_share_with_metadata()`: [5](#0-4) 

The `add_share_with_metadata()` method has two panic points. **Panic Point 1** occurs when looking up the share author's weight in the empty HashMap: [6](#0-5) 

**Panic Point 2** occurs in the `retain()` method when recalculating total weight for existing shares: [7](#0-6) 

**Attack Execution Path:**

1. Byzantine validator sends cryptographically valid share via network RPC
2. Share arrives at `verification_task()` and passes cryptographic verification: [8](#0-7) 

3. Verified share is forwarded to `handle_incoming_msg()` which calls `add_share()`: [9](#0-8) 

4. Share is added successfully to the `SecretShareAggregator` using weight of 1
5. Victim node processes its own block and calls `add_self_share()`: [10](#0-9) 

6. The `add_share_with_metadata()` method attempts to lookup in the empty HashMap and panics

Shares can arrive from any validator within a 200-round window. The share verification process validates cryptographic authenticity: [11](#0-10) [12](#0-11) 

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** per the Aptos bug bounty criteria: "Validator node slowdowns / API crashes."

**Specific Impacts:**
- **Consensus Participation Loss**: The panic occurs within the `SecretShareManager` task running in the consensus pipeline. When `add_self_share().expect()` is called and the internal panic occurs, it crashes the secret sharing component, preventing the validator from participating in randomness generation.
- **Network Liveness Degradation**: If Byzantine validators crash multiple nodes simultaneously by sending shares before victims process their own blocks, the network may lose sufficient validators for optimal consensus operation.
- **Repeatable DoS**: Byzantine validators can continuously trigger this crash across epochs, as the empty HashMap is reinitialized each epoch.
- **No Automatic Recovery**: The crashed task requires manual validator restart by operators.

This breaks the **Consensus Liveness** invariant - Byzantine validators (< 1/3) should not be able to prevent honest nodes from participating in consensus. While this is not a safety violation (no consensus divergence or fund loss), it degrades network availability and validator participation.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered with:
- **Low Complexity**: Byzantine validators simply need to process their blocks and broadcast valid shares before target validators process their own blocks for the same round.
- **No Special Timing**: Shares can be sent at any time within the 200-round acceptance window defined by `FUTURE_ROUNDS_TO_ACCEPT`, providing a wide attack window.
- **Deterministic Outcome**: The panic is guaranteed if any shares exist in the aggregator when `add_self_share()` transitions from `PendingMetadata` to `PendingDecision` state and calls `retain()` with the empty weights HashMap.
- **Minimal Prerequisites**: Only requires being a validator in the active set. Byzantine validators (< 1/3 of stake) are an expected threat in BFT consensus systems.

The vulnerability can even trigger accidentally due to normal network timing variations between honest validators when some process blocks faster than others, making this a realistic operational risk beyond intentional attacks.

## Recommendation

Properly initialize and populate the `weights` HashMap in `SecretShareConfig`. The implementation should:

1. Initialize the HashMap with actual validator weights from the `ValidatorVerifier` during config construction
2. Ensure `get_peer_weight()` uses the populated HashMap instead of returning hardcoded `1`
3. Add validation to ensure weights are available before attempting aggregation

Example fix approach:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    // ... other params
) -> Self {
    // Populate weights from validator verifier
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (addr, validator.get_voting_power(&addr).unwrap_or(1)))
        .collect();
    
    Self {
        // ... other fields
        weights,
    }
}

pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    *self.weights.get(peer).unwrap_or(&1)
}
```

Alternatively, remove the `expect()` calls and handle missing weights gracefully by defaulting to weight `1`, or validate the HashMap is populated before attempting aggregation.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Running two validator nodes in a test network
2. Having validator A process and broadcast its secret share for round N
3. Ensuring validator B receives A's share before processing its own block for round N
4. Observing that validator B panics when calling `add_self_share()` due to the empty weights HashMap lookup in `retain()`

The panic stack trace would show the crash originating from `secret_share_store.rs:79` or `secret_share_store.rs:164` where `.expect("Author must exist for weight")` is called on a `None` value from the empty HashMap.

## Notes

This vulnerability exploits an incomplete implementation where the developers acknowledged the weights functionality needs completion (as indicated by the "This is temporary and meant to change in future PRs" comment). However, the current production code has the inconsistency deployed, where `get_peer_weight()` returns a hardcoded value while `get_peer_weights()` returns an empty HashMap, creating the panic condition. The issue is in active consensus code used for randomness generation, not test infrastructure.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-257)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-158)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
        let metadata = self_secret_share.metadata().clone();

        // Now acquire lock and update store
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }

        info!(LogSchema::new(LogEvent::BroadcastSecretShare)
            .epoch(self.epoch_state.epoch)
            .author(self.author)
            .round(block.round()));
        self.network_sender.broadcast_without_self(
            SecretShareMessage::Share(self_secret_share).into_network_message(),
        );
        self.spawn_share_requester_task(metadata)
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L279-322)
```rust
    fn handle_incoming_msg(&self, rpc: SecretShareRpc) {
        let SecretShareRpc {
            msg,
            protocol,
            response_sender,
        } = rpc;
        match msg {
            SecretShareMessage::RequestShare(request) => {
                let result = self
                    .secret_share_store
                    .lock()
                    .get_self_share(request.metadata());
                match result {
                    Ok(Some(share)) => {
                        self.process_response(
                            protocol,
                            response_sender,
                            SecretShareMessage::Share(share),
                        );
                    },
                    Ok(None) => {
                        warn!(
                            "Self secret share could not be found for RPC request {}",
                            request.metadata().round
                        );
                    },
                    Err(e) => {
                        warn!("[SecretShareManager] Failed to get share: {}", e);
                    },
                }
            },
            SecretShareMessage::Share(share) => {
                info!(LogSchema::new(LogEvent::ReceiveSecretShare)
                    .author(self.author)
                    .epoch(share.epoch())
                    .round(share.metadata().round)
                    .remote_peer(*share.author()));

                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
            },
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L27-39)
```rust
impl SecretShareMessage {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
}
```
