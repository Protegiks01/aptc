# Audit Report

## Title
Transaction Size Validation Bypass via Authenticator Inflation Enables Validator Memory Exhaustion

## Summary
The Aptos blockchain validates transaction size limits by checking only the raw transaction bytes (`raw_txn_bytes_len()`) while excluding the authenticator from size calculations. This allows attackers to bypass the 64KB transaction size limit by submitting transactions with minimal raw transaction payloads but arbitrarily large authenticators (up to the 8MB API limit), causing memory exhaustion on validators and bypassing mempool capacity controls.

## Finding Description

The vulnerability exists in a critical discrepancy between how transaction sizes are **validated** versus how transactions are **stored in memory**. The Aptos system uses `raw_txn_bytes_len()` for size validation, which excludes the `TransactionAuthenticator`, while the mempool stores the complete `SignedTransaction` including the authenticator.

**Transaction Size Validation Only Checks Raw Transaction:**

The `TransactionMetadata` constructor sets `transaction_size` using only `raw_txn_bytes_len()`, excluding the authenticator: [1](#0-0) 

**Size Check Validates Incomplete Size:**

The `check_gas` function validates `txn_metadata.transaction_size` against `max_transaction_size_in_bytes` (default 64KB), but this validation uses the incomplete size: [2](#0-1) 

**Mempool Tracking Uses Incomplete Calculation:**

The mempool's `get_estimated_bytes()` method uses `raw_txn_bytes_len()`, excluding authenticator size: [3](#0-2) 

When transactions are inserted into the mempool, `size_bytes` is incremented using this incomplete calculation: [4](#0-3) 

**Mempool Capacity Check Uses Incomplete Size:**

The mempool's `is_full()` method checks `size_bytes` against `capacity_bytes` (default 2GB): [5](#0-4) 

**Authenticators Can Be Arbitrarily Large:**

The `AbstractAuthenticationData` enum contains `abstract_signature: Vec<u8>` with no explicit size validation: [6](#0-5) 

**API Layer Allows 8MB Transactions:**

The API's content-length limit is 8MB, far exceeding the 64KB transaction size limit: [7](#0-6) 

**SignedTransaction Has Two Size Methods:**

The codebase defines both `raw_txn_bytes_len()` (excludes authenticator) and `txn_bytes_len()` (includes authenticator), but only the former is used for validation: [8](#0-7) 

**Attack Execution Path:**
1. Attacker crafts a transaction with 60KB raw transaction payload
2. Attacker attaches a 7.9MB `AbstractAuthenticator` with large `abstract_signature`
3. Total BCS-serialized transaction: ~8MB (passes API content-length check)
4. VM validation checks only `raw_txn_bytes_len` (60KB) against `max_transaction_size_in_bytes` (64KB) - **PASSES**
5. Transaction enters mempool, counted as only 60KB + overhead in `size_bytes` tracking
6. Actual memory consumed: full ~8MB `SignedTransaction` is stored
7. Mempool's `capacity_bytes` check (default 2GB) becomes ineffective - attacker can insert ~250 such transactions appearing as 15MB but consuming 2GB
8. Validators experience memory exhaustion, node slowdowns, and potential crashes

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria, specifically matching the "Validator Node Slowdowns" category with "DoS through resource exhaustion."

**Direct Impacts:**
1. **Validator Memory Exhaustion**: Coordinated submission of malicious transactions exhausts validator memory, causing crashes or forced restarts
2. **Consensus Degradation**: Memory-exhausted validators fail to participate effectively in consensus, reducing network liveness
3. **Mempool Capacity Bypass**: The mempool's `capacity_bytes` protection becomes ineffective since it tracks only raw transaction size, not actual memory consumption
4. **Resource Consumption Asymmetry**: Attackers pay gas fees for 60KB transactions while imposing 8MB memory costs on every validator

The vulnerability does not reach Critical severity as it does not directly cause fund loss or permanent network partition, but constitutes a significant DoS vector against validator infrastructure that affects consensus participation.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:

1. **Low Attack Complexity**: Creating transactions with large authenticators requires no special privileges - any account can submit transactions through the standard REST API
2. **No Special Requirements**: The `AbstractAuthenticator` type is part of the standard transaction authentication system, requiring no feature flags or special configuration
3. **Difficult to Detect**: Malicious transactions pass all existing validation checks and appear legitimate until memory pressure emerges on validators
4. **Economic Incentive**: Attackers pay only for the 60KB raw transaction size in gas fees while imposing 8MB memory costs on all validators, creating a significant cost asymmetry
5. **No Rate Limiting**: The vulnerability can be exploited repeatedly without triggering existing rate limits, which are based on transaction count rather than actual memory consumption
6. **No Validation Gap**: No code path validates the full transaction size (including authenticator) against any reasonable limit before mempool insertion

## Recommendation

**Short-term Fix:**

1. Add validation to check the **total** transaction size (including authenticator) against a reasonable limit:
   - Modify `TransactionMetadata::new()` to use `txn.txn_bytes_len()` instead of `txn.raw_txn_bytes_len()`
   - Or add a separate check in `check_gas()` to validate the full transaction size
   
2. Update mempool size tracking to use actual memory consumption:
   - Modify `MempoolTransaction::get_estimated_bytes()` to use `txn.txn_bytes_len()` instead of `txn.raw_txn_bytes_len()`

3. Add explicit size limits to `AbstractAuthenticationData` fields to prevent unbounded growth

**Long-term Fix:**

Audit all size-sensitive code paths to ensure consistency between validation and actual resource consumption, establishing a clear principle that size limits must account for all components of a transaction.

## Proof of Concept

```rust
// Pseudocode demonstrating the vulnerability
// This would need to be implemented as a full test case

fn test_authenticator_inflation_bypass() {
    // 1. Create minimal raw transaction (60KB)
    let raw_txn = create_minimal_transaction_60kb();
    
    // 2. Create oversized AbstractAuthenticator (7.9MB)
    let large_signature = vec![0u8; 7_900_000]; // 7.9MB signature
    let auth_data = AbstractAuthenticationData::V1 {
        signing_message_digest: vec![0u8; 32],
        abstract_signature: large_signature,
    };
    let authenticator = AbstractAuthenticator::new(function_info, auth_data);
    
    // 3. Create SignedTransaction
    let signed_txn = SignedTransaction::new_with_authenticator(
        raw_txn,
        TransactionAuthenticator::SingleSender { 
            sender: AccountAuthenticator::Abstract { authenticator } 
        }
    );
    
    // 4. Verify sizes
    assert_eq!(signed_txn.raw_txn_bytes_len(), ~60_000); // VM sees 60KB
    assert_eq!(signed_txn.txn_bytes_len(), ~8_000_000); // Actual size 8MB
    
    // 5. Submit transaction - it passes validation
    let result = submit_transaction(signed_txn);
    assert!(result.is_ok()); // Passes despite being 8MB
    
    // 6. Verify mempool thinks it's only 60KB
    let mempool_size = mempool.get_estimated_bytes();
    assert_eq!(mempool_size, ~60_000); // Mempool miscalculates
    
    // 7. But actual memory consumption is 8MB
    let actual_memory = size_of_val(&signed_txn);
    assert_eq!(actual_memory, ~8_000_000); // Real memory usage
}
```

**Notes:**
- This vulnerability breaks the **Resource Limits** invariant by allowing operations to exceed intended memory constraints
- The **Transaction Validation** invariant is broken because size checks are incomplete and bypassable
- The discrepancy between `raw_txn_bytes_len()` and `txn_bytes_len()` is the root cause, where validation uses the former but storage requires the latter

### Citations

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** mempool/src/core_mempool/transaction.rs (L70-72)
```rust
    pub(crate) fn get_estimated_bytes(&self) -> usize {
        self.txn.raw_txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L354-354)
```rust
            self.size_bytes += txn.get_estimated_bytes();
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** types/src/transaction/authenticator.rs (L595-611)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, Hash)]
pub enum AbstractAuthenticationData {
    V1 {
        #[serde(with = "serde_bytes")]
        signing_message_digest: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_signature: Vec<u8>,
    },
    DerivableV1 {
        #[serde(with = "serde_bytes")]
        signing_message_digest: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_signature: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_public_key: Vec<u8>,
    },
}
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** types/src/transaction/mod.rs (L1294-1306)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }

    pub fn txn_bytes_len(&self) -> usize {
        let authenticator_size = *self.authenticator_size.get_or_init(|| {
            bcs::serialized_size(&self.authenticator)
                .expect("Unable to serialize TransactionAuthenticator")
        });
        self.raw_txn_bytes_len() + authenticator_size
    }
```
