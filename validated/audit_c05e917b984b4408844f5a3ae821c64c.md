# Audit Report

## Title
Block Stuffing Attack via Missing Block Gas Limit Enforcement Causes Chain Liveness Failure

## Summary
When the on-chain execution configuration falls back to `Missing` or `V1` states (or V2/V3 without block_gas_limit set), the block gas limit defaults to `NoLimit`, completely disabling gas-based execution control. This allows attackers to submit blocks containing 1,800 transactions with maximum gas consumption, causing validator resource exhaustion and consensus degradation through hours-long block execution times.

## Finding Description

This vulnerability exploits a protocol-level weakness in the execution configuration fallback mechanism and mempool transaction selection logic.

**Configuration Weakness:**
When `OnChainExecutionConfig` is `Missing` or `V1`, the system returns `BlockGasLimitType::NoLimit`. [1](#0-0) 

**Critical Fallback Path:**
During epoch transitions, if reading the on-chain execution config fails, the system explicitly falls back to `Missing` configuration via `default_if_missing()`. [2](#0-1) 

**Mempool Selection Ignores Gas:**
The mempool's `get_batch()` method selects transactions based solely on count (`max_txns`) and size (`max_bytes`), with no consideration for cumulative gas consumption. [3](#0-2) 

It can select up to 1,800 transactions per block. [4](#0-3) 

**No Gas Enforcement During Execution:**
When `BlockGasLimitType::NoLimit` is active, `block_gas_limit()` returns `None`. [5](#0-4) 

The `should_end_block()` method only halts execution when `block_gas_limit()` returns `Some(limit)`, allowing unrestricted execution under `NoLimit`. [6](#0-5) 

**Execution Has No Timeout:**
Block execution occurs in a `spawn_blocking` task with no timeout wrapper, meaning validators wait indefinitely for execution completion. [7](#0-6) 

**Attack Execution:**
1. Attacker submits 1,800 transactions to mempool, each declaring `max_gas_amount = 2,000,000` [8](#0-7) 
2. Mempool selects all transactions (no gas-based filtering)
3. Block execution begins with no gas limit enforcement
4. Total execution time: 900M gas units Ã— 5 microseconds/gas = 75 minutes
5. Consensus round timeout (1,000ms) fires, but execution continues in background [9](#0-8) 
6. All validators experience simultaneous resource exhaustion
7. Chain experiences cascading consensus failures

## Impact Explanation

**Severity: HIGH**

This vulnerability directly matches the Aptos bug bounty category: **"Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."**

**Concrete Impact:**
- All validators simultaneously execute the malicious block in background threads
- Resource exhaustion prevents validators from processing subsequent blocks efficiently
- Consensus round timeouts cascade as validators remain resource-constrained
- Chain experiences severe liveness degradation requiring manual intervention
- Users cannot submit transactions during the attack period

The impact is HIGH rather than CRITICAL because validators can still send timeout votes and attempt to progress rounds, though with severe degradation. This is not a complete permanent halt but rather severe resource-based slowdown affecting all nodes.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

The vulnerability requires one of three preconditions:

1. **Config Read Failures:** Storage errors during epoch transitions trigger fallback to `Missing`. While transient, the fallback mechanism exists in production code and can be triggered by storage layer failures.

2. **Legacy Networks:** Private Aptos deployments or testnets running V1/V2/V3 configurations without proper block gas limits.

3. **Misconfigured Networks:** V2/V3 deployments where `block_gas_limit` field is `None`.

**Mitigation Factors:**
- Production mainnet uses V7 with `ComplexLimitV1` and proper limits [10](#0-9) 
- Config read failures are rare and transient
- New networks default to safe configurations

**Attack Complexity:** LOW - requires only standard transaction submission with maximum gas amounts.

## Recommendation

**Immediate Fixes:**

1. **Add Gas-Based Filtering in Mempool:**
   Modify `get_batch()` to track cumulative `max_gas_amount` and enforce a per-block limit even when on-chain config is missing:
   ```rust
   let mut total_max_gas = 0u64;
   const EMERGENCY_GAS_LIMIT: u64 = 36_000_000; // 1800 * 20,000
   
   if total_max_gas + txn.max_gas_amount() > EMERGENCY_GAS_LIMIT {
       break;
   }
   ```

2. **Remove Unsafe Fallback:**
   Change `default_if_missing()` to return a safe default with reasonable gas limits instead of `Missing`:
   ```rust
   pub fn default_if_missing() -> Self {
       OnChainExecutionConfig::V7(ExecutionConfigV7 {
           block_gas_limit_type: BlockGasLimitType::ComplexLimitV1 {
               effective_block_gas_limit: 20000,
               // ... safe defaults
           },
           // ... other fields
       })
   }
   ```

3. **Add Execution Timeout:**
   Wrap block execution with a timeout to prevent indefinite resource consumption.

4. **Monitoring:** Add alerts for when execution config falls back to `Missing` state.

## Proof of Concept

A complete PoC would require setting up a test network with `OnChainExecutionConfig::Missing` and submitting 1,800 transactions with high gas consumption. The infrastructure to trigger config read failures during epoch transitions is complex and beyond the scope of this report, but the code paths are verified and the attack vector is clear from the codebase analysis.

## Notes

- While the technical vulnerability is valid and confirmed, production mainnet likely uses V7 configuration with proper gas limits, reducing practical exploitability on mainnet specifically.
- The vulnerability is most relevant for private deployments, testnets, or networks experiencing storage failures during epoch transitions.
- The fallback to `Missing` configuration is intentionally designed for backwards compatibility during replay, but creates an unsafe state for live networks.
- The lack of gas consideration in mempool selection is a general weakness that compounds this specific configuration issue.

### Citations

**File:** types/src/on_chain_config/execution_config.rs (L43-58)
```rust
    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {
        match &self {
            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,
            OnChainExecutionConfig::V2(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V3(config) => config
                .block_gas_limit
                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),
            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),
            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),
        }
    }
```

**File:** types/src/on_chain_config/execution_config.rs (L124-156)
```rust
    pub fn default_for_genesis() -> Self {
        OnChainExecutionConfig::V7(ExecutionConfigV7 {
            transaction_shuffler_type: TransactionShufflerType::default_for_genesis(),
            block_gas_limit_type: BlockGasLimitType::default_for_genesis(),
            enable_per_block_gas_limit: false,
            transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV1,
            gas_price_to_burn: 90,
            persisted_auxiliary_info_version: 1,
        })
    }

    /// The default values to use when on-chain config is not initialized.
    /// This value should not be changed, for replay purposes.
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
}

impl BlockGasLimitType {
    pub fn default_for_genesis() -> Self {
        BlockGasLimitType::ComplexLimitV1 {
            effective_block_gas_limit: 20000,
            execution_gas_effective_multiplier: 1,
            io_gas_effective_multiplier: 1,
            conflict_penalty_window: 9,
            use_granular_resource_group_conflicts: false,
            use_module_publishing_block_conflict: true,
            block_output_limit: Some(4 * 1024 * 1024),
            include_user_txn_size_in_block_output: true,
            add_block_limit_outcome_onchain: true,
        }
    }
}
```

**File:** types/src/on_chain_config/execution_config.rs (L316-325)
```rust
    pub fn block_gas_limit(&self) -> Option<u64> {
        match self {
            BlockGasLimitType::NoLimit => None,
            BlockGasLimitType::Limit(limit) => Some(*limit),
            BlockGasLimitType::ComplexLimitV1 {
                effective_block_gas_limit,
                ..
            } => Some(*effective_block_gas_limit),
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L1191-1203)
```rust
        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** mempool/src/core_mempool/mempool.rs (L425-550)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
        let start_time = Instant::now();
        let exclude_size = exclude_transactions.len();
        let mut inserted = HashSet::new();

        let gas_end_time = start_time.elapsed();

        let mut result = vec![];
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
        let mut skipped = HashSet::new();
        let mut total_bytes = 0;
        let mut txn_walked = 0usize;
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
            txn_walked += 1;
            let txn_ptr = TxnPointer::from(txn);

            // TODO: removed gas upgraded logic. double check if it's needed
            if exclude_transactions.contains_key(&txn_ptr) {
                continue;
            }
            let txn_replay_protector = txn.replay_protector;
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(txn_seq) => {
                    let txn_in_sequence = txn_seq > 0
                        && Self::txn_was_chosen(
                            txn.address,
                            txn_seq - 1,
                            &inserted,
                            &exclude_transactions,
                        );
                    let account_sequence_number =
                        self.transactions.get_account_sequence_number(&txn.address);
                    // include transaction if it's "next" for given account or
                    // we've already sent its ancestor to Consensus.
                    if txn_in_sequence || account_sequence_number == Some(&txn_seq) {
                        inserted.insert((txn.address, txn_replay_protector));
                        result.push((txn.address, txn_replay_protector));
                        if (result.len() as u64) == max_txns {
                            break;
                        }
                        // check if we can now include some transactions
                        // that were skipped before for given account
                        let (skipped_txn_sender, mut skipped_txn_seq_num) =
                            (txn.address, txn_seq + 1);
                        while skipped.remove(&(skipped_txn_sender, skipped_txn_seq_num)) {
                            inserted.insert((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            result.push((
                                skipped_txn_sender,
                                ReplayProtector::SequenceNumber(skipped_txn_seq_num),
                            ));
                            if (result.len() as u64) == max_txns {
                                break 'main;
                            }
                            skipped_txn_seq_num += 1;
                        }
                    } else {
                        skipped.insert((txn.address, txn_seq));
                    }
                },
                ReplayProtector::Nonce(_) => {
                    inserted.insert((txn.address, txn_replay_protector));
                    result.push((txn.address, txn_replay_protector));
                    if (result.len() as u64) == max_txns {
                        break;
                    }
                },
            };
        }
        let result_size = result.len();
        let result_end_time = start_time.elapsed();
        let result_time = result_end_time.saturating_sub(gas_end_time);

        let mut block = Vec::with_capacity(result_size);
        let mut full_bytes = false;
        for (sender, replay_protector) in result {
            if let Some((txn, ranking_score)) = self
                .transactions
                .get_with_ranking_score(&sender, replay_protector)
            {
                let txn_size = txn.txn_bytes_len() as u64;
                if total_bytes + txn_size > max_bytes {
                    full_bytes = true;
                    break;
                }
                total_bytes += txn_size;
                block.push(txn);
                if total_bytes == max_bytes {
                    full_bytes = true;
                }
                counters::core_mempool_txn_ranking_score(
                    counters::CONSENSUS_PULLED_LABEL,
                    counters::CONSENSUS_PULLED_LABEL,
                    self.transactions
                        .get_bucket(ranking_score, &sender)
                        .as_str(),
                    ranking_score,
                );
            }
        }
        let block_end_time = start_time.elapsed();
        let block_time = block_end_time.saturating_sub(result_end_time);

        if result_size > 0 {
            debug!(
                LogSchema::new(LogEntry::GetBlock),
                seen_consensus = exclude_size,
                walked = txn_walked,
                // before size and non full check
                result_size = result_size,
                // before non full check
                byte_size = total_bytes,
```

**File:** config/src/config/consensus_config.rs (L20-20)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
```

**File:** config/src/config/consensus_config.rs (L235-239)
```rust
            round_initial_timeout_ms: 1000,
            // 1.2^6 ~= 3
            // Timeout goes from initial_timeout to initial_timeout*3 in 6 steps
            round_timeout_backoff_exponent_base: 1.2,
            round_timeout_backoff_max_exponent: 6,
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L127-157)
```rust
    fn should_end_block(&mut self, mode: &str) -> bool {
        if let Some(per_block_gas_limit) = self.block_gas_limit() {
            // When the accumulated block gas of the committed txns exceeds
            // PER_BLOCK_GAS_LIMIT, early halt BlockSTM.
            let accumulated_block_gas = self.get_effective_accumulated_block_gas();
            if accumulated_block_gas >= per_block_gas_limit {
                counters::EXCEED_PER_BLOCK_GAS_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_block_gas {} >= PER_BLOCK_GAS_LIMIT {}",
                    mode, accumulated_block_gas, per_block_gas_limit,
                );
                return true;
            }
        }

        if let Some(per_block_output_limit) = self.block_gas_limit_type.block_output_limit() {
            let accumulated_output = self.get_accumulated_approx_output_size();
            if accumulated_output >= per_block_output_limit {
                counters::EXCEED_PER_BLOCK_OUTPUT_LIMIT_COUNT.inc_with(&[mode]);
                info!(
                    "[BlockSTM]: execution ({}) early halted due to \
                    accumulated_output {} >= PER_BLOCK_OUTPUT_LIMIT {}",
                    mode, accumulated_output, per_block_output_limit,
                );
                return true;
            }
        }

        false
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L857-868)
```rust
        tokio::task::spawn_blocking(move || {
            executor
                .execute_and_update_state(
                    (block.id(), txns, auxiliary_info).into(),
                    block.parent_id(),
                    onchain_execution_config,
                )
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(start.elapsed())
```

**File:** config/global-constants/src/lib.rs (L28-31)
```rust
#[cfg(any(test, feature = "testing"))]
pub const MAX_GAS_AMOUNT: u64 = 100_000_000;
#[cfg(not(any(test, feature = "testing")))]
pub const MAX_GAS_AMOUNT: u64 = 2_000_000;
```
