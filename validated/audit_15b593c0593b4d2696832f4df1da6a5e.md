# Audit Report

## Title
Gas Metering Bypass in Batch Bulletproof Verification Allows DoS via Oversized Proof Deserialization

## Summary
The batch range proof verification function in the Bulletproofs native implementation fails to charge gas proportional to the `proof_bytes` size during deserialization, unlike its single-proof counterpart. This gas metering inconsistency allows attackers to submit transactions with oversized proof data while underpaying for deserialization work, enabling resource exhaustion attacks against validator nodes.

## Finding Description

A critical gas metering inconsistency exists between single and batch Bulletproof range proof verification in the native cryptography implementation.

**Single Proof Verification** correctly charges gas before deserialization proportional to proof size: [1](#0-0) 

The per-byte deserialization cost is defined as: [2](#0-1) 

**Batch Proof Verification** only charges fixed gas without any per-byte component: [3](#0-2) 

The `charge_gas()` function uses exclusively fixed amounts based on `(batch_size, bit_length)` combinations with no proof size consideration: [4](#0-3) 

After charging only fixed gas, deserialization proceeds on the potentially oversized `proof_bytes`: [5](#0-4) 

**Attack Path:**

1. Attacker calls `verify_batch_range_proof()` with minimal parameters (batch_size=1, bit_length=8)
2. Expected valid proof size: ~480 bytes per Bulletproofs formula
3. Fixed gas charged: 17,099,501 units [6](#0-5) 
4. Attacker provides `proof_bytes` up to transaction limit of 64KB [7](#0-6) 
5. Missing per-byte charge: 121 gas/byte × 65,536 bytes = 7,929,856 gas units
6. Total undercharged work: ~7.9M gas units per transaction (32% discount)

The Move interface provides no proof size validation before invoking the native function: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria under "Validator Node Slowdown."

**Resource Exhaustion Mechanism:**
The `RangeProof::from_bytes()` deserialization must parse the entire byte array regardless of validity, consuming CPU time proportional to input size. With 64KB oversized proofs versus expected ~480 bytes, this represents a 136× amplification of deserialization work while paying only fixed gas.

**Block-Level Impact:**
With a block execution gas limit of approximately 920M gas units [9](#0-8) , an attacker could submit ~54 transactions per block (920M ÷ 17M). Each transaction appears to consume 17M gas but actually performs ~25M gas worth of work. The cumulative undercharged work of ~427M gas units (54 × 7.9M) represents significant validator resource consumption that could impact block production times and network liveness.

**Consensus Impact:**
While this does not directly break consensus safety, sustained validator slowdown affects liveness and block production latency, especially under coordinated attacks.

## Likelihood Explanation

**HIGH likelihood** - This vulnerability is trivially exploitable:

- **No Privileges Required:** Any user can submit transactions calling the public `verify_batch_range_proof()` Move function
- **Low Attack Cost:** Attackers pay standard transaction fees (~17M gas) but receive disproportionate computational impact (~25M gas worth of work)
- **Simple Exploitation:** Requires only constructing a transaction with minimal batch parameters and oversized proof data
- **Repeatable:** Can be executed repeatedly across transactions and blocks
- **Detection Difficulty:** Transactions pass all validation checks; undercharged deserialization only occurs during native function execution

## Recommendation

Add per-byte deserialization charging to batch verification consistent with single proof verification:

```rust
fn verify_batch_range_proof(
    context: &mut SafeNativeContext,
    comm_points: &[CompressedRistretto],
    pc_gens: &PedersenGens,
    proof_bytes: &[u8],
    bit_length: usize,
    dst: Vec<u8>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Charge base gas for batch configuration
    charge_gas(context, comm_points.len(), bit_length)?;
    
    // ADD: Charge per-byte deserialization cost
    context.charge(
        BULLETPROOFS_PER_BYTE_RANGEPROOF_DESERIALIZE
            * NumBytes::new(proof_bytes.len() as u64)
    )?;

    let range_proof = match bulletproofs::RangeProof::from_bytes(proof_bytes) {
        // ... rest of function
    }
}
```

Alternatively, add proof size validation in the Move wrapper to reject oversized proofs before native function invocation.

## Proof of Concept

```move
#[test(fx = @std)]
fun test_oversized_batch_proof_undercharge(fx: signer) {
    use aptos_std::ristretto255_bulletproofs;
    use aptos_std::ristretto255;
    use aptos_std::features;
    
    features::change_feature_flags_for_testing(
        &fx, 
        vector[features::get_bulletproofs_batch_feature()], 
        vector[]
    );
    
    // Create minimal batch parameters
    let comm = ristretto255::basepoint();
    let comms = vector[comm];
    
    // Create oversized proof_bytes (64KB)
    let oversized_proof = vector::empty<u8>();
    let i = 0;
    while (i < 65536) {
        vector::push_back(&mut oversized_proof, 0u8);
        i = i + 1;
    };
    
    let proof = bulletproofs::range_proof_from_bytes(oversized_proof);
    
    // This call will charge only 17,099,501 gas (fixed for batch=1, bits=8)
    // but will deserialize all 64KB, consuming ~7.9M additional gas worth of work
    let _result = bulletproofs::verify_batch_range_proof(
        &comms,
        &ristretto255::basepoint(),
        &ristretto255::hash_to_point_base(),
        &proof,
        8,
        b"test"
    );
}
```

**Notes:**
- The vulnerability requires the `bulletproofs_batch_enabled()` feature flag to be active
- The batch bulletproofs gas parameters were introduced in RELEASE_V1_28, indicating production deployment
- The deserialization cost is real CPU work even when proofs are invalid
- Multiple transactions amplify the validator resource consumption impact

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L328-332)
```rust
    context.charge(
        BULLETPROOFS_BASE
            + BULLETPROOFS_PER_BYTE_RANGEPROOF_DESERIALIZE
                * NumBytes::new(proof_bytes.len() as u64),
    )?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L371-371)
```rust
    charge_gas(context, comm_points.len(), bit_length)?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L373-380)
```rust
    let range_proof = match bulletproofs::RangeProof::from_bytes(proof_bytes) {
        Ok(proof) => proof,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE_RANGE_PROOF,
            })
        },
    };
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L398-426)
```rust
fn charge_gas(
    context: &mut SafeNativeContext,
    batch_size: usize,
    bit_length: usize,
) -> SafeNativeResult<()> {
    match (batch_size, bit_length) {
        (1, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_8),
        (1, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_16),
        (1, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_32),
        (1, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_64),
        (2, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_8),
        (2, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_16),
        (2, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_32),
        (2, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_64),
        (4, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_8),
        (4, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_16),
        (4, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_32),
        (4, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_64),
        (8, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_8),
        (8, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_16),
        (8, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_32),
        (8, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_64),
        (16, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_8),
        (16, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_16),
        (16, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_32),
        (16, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_64),
        _ => unreachable!(),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L245-245)
```rust
        [bulletproofs_per_byte_rangeproof_deserialize: InternalGasPerByte, { 11.. => "bulletproofs.per_byte_rangeproof_deserialize" }, 121],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L250-250)
```rust
        [bulletproofs_verify_base_batch_1_bits_8: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_8" }, 17_099_501],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L211-214)
```rust
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move (L145-160)
```text
    public fun verify_batch_range_proof(
        comms: &vector<RistrettoPoint>,
        val_base: &RistrettoPoint, rand_base: &RistrettoPoint,
        proof: &RangeProof, num_bits: u64, dst: vector<u8>): bool
    {
        assert!(features::bulletproofs_batch_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));
        assert!(dst.length() <= 256, error::invalid_argument(E_DST_TOO_LONG));

        let comms = comms.map_ref(|com| ristretto255::point_to_bytes(&ristretto255::point_compress(com)));

        verify_batch_range_proof_internal(
            comms,
            val_base, rand_base,
            proof.bytes, num_bits, dst
        )
    }
```
