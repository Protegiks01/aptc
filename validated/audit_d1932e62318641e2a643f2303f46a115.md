# Audit Report

## Title
Missing Per-Author Deduplication in OrderVoteMsg Processing Enables CPU Amplification Attack

## Summary
The `PendingOrderVotes` structure lacks per-author vote tracking that exists in `PendingVotes` for regular votes. This design asymmetry allows a malicious validator to repeatedly send `OrderVoteMsg` instances with re-signed signatures, forcing all receiving validators to perform expensive BLS signature verifications for each duplicate message before deduplication occurs at the `SignatureAggregator` level.

## Finding Description

The consensus layer implements different duplicate detection mechanisms for regular votes versus order votes, creating an exploitable vulnerability.

**Regular Votes Protection:**

`PendingVotes` maintains per-author tracking via the `author_to_vote` HashMap that stores each author's vote and the corresponding LedgerInfo digest. [1](#0-0) 

This enables early duplicate and equivocation detection that occurs BEFORE signature aggregation. When a vote is inserted, the code checks if the author has already voted, returning `DuplicateVote` for identical votes or `EquivocateVote` for conflicting votes from the same author. [2](#0-1) 

**Order Votes Vulnerability:**

`PendingOrderVotes` only maintains a `li_digest_to_votes` HashMap mapping LedgerInfo digests to vote aggregation status, with no per-author tracking field. [3](#0-2) 

The structure cannot detect when the same author sends multiple order votes for the same LedgerInfo.

**Attack Execution Path:**

1. When an `OrderVoteMsg` is received as an `UnverifiedEvent`, it undergoes signature verification in the `verify()` method BEFORE any deduplication or processing. [4](#0-3) 

2. The `verify_order_vote` method performs validation and calls `OrderVote::verify()`. [5](#0-4) 

3. `OrderVote::verify()` performs expensive BLS signature verification by calling `validator.optimistic_verify()`. [6](#0-5) 

4. Only after verification completes does `process_order_vote_msg` check if enough votes exist via `has_enough_order_votes()`. [7](#0-6)  However, this check only prevents processing when a QC is already formed, not duplicate votes from the same author before QC formation.

5. During vote insertion in `insert_order_vote`, the code calls `SignatureAggregator::add_signature()` which uses `BTreeMap::insert()` to store signatures. [8](#0-7)  This merely overwrites previous signatures from the same author. [9](#0-8) 

6. The test suite confirms this behavior - when the same author votes twice for the same thing, both votes are accepted and return `VoteAdded(1)` with no duplicate detection or error. [10](#0-9) 

**Attack Scenario:**

A malicious validator creates M `OrderVoteMsg` instances for the same `LedgerInfo`, each with a freshly re-generated signature (signing the same data multiple times produces different signature bytes). When broadcast to N validators, each receiving validator performs signature verification for each message in step 3 above, triggering M × N expensive BLS signature verifications across the network before any deduplication occurs.

## Impact Explanation

**Severity: High** (Validator Node Slowdowns - up to $50,000 per bug bounty)

This vulnerability aligns with the Aptos bug bounty category: "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

Impact quantification:
- **CPU Exhaustion**: M duplicate messages × N validators = M×N BLS signature verifications consuming validator CPU resources
- **Consensus Performance Degradation**: CPU cycles wasted on redundant cryptographic operations reduce capacity for legitimate consensus activities
- **No Natural Limit Before QC**: There is no bound on how many duplicate order votes from the same author will be verified before quorum formation
- **Sustained Attack**: A malicious validator can maintain this behavior across multiple rounds

This is NOT a pure network DoS attack - it is a protocol-level vulnerability where missing validation logic causes unbounded expensive cryptographic operations, degrading consensus performance. The asymmetry between `PendingVotes` (which has per-author protection) and `PendingOrderVotes` (which lacks it) indicates this is a protocol design oversight rather than an intentional design decision.

## Likelihood Explanation

**Likelihood: High**

Requirements for exploitation:
- Attacker must be a validator (within BFT < 1/3 Byzantine assumption) - standard threat model
- No collusion required - single malicious validator sufficient  
- Trivial execution: repeatedly broadcast order votes with re-generated signatures
- Difficult to distinguish: messages appear as valid signatures from a valid validator

The attack is sustainable and can continue across multiple consensus rounds, providing continuous performance degradation.

## Recommendation

Add per-author tracking to `PendingOrderVotes` similar to `PendingVotes`. Modify the structure to include an `author_to_order_vote` HashMap and check for duplicate votes from the same author BEFORE signature verification occurs in the round manager's event processing loop. Return an early duplicate detection result without triggering signature verification.

Specifically:
1. Add `author_to_order_vote: HashMap<Author, (OrderVote, HashValue)>` field to `PendingOrderVotes`
2. In `insert_order_vote`, check if the author has already voted before calling `add_signature`
3. Return appropriate duplicate detection result if same author votes again
4. Optionally, perform duplicate check earlier in the processing pipeline before `verify_order_vote` is called

## Proof of Concept

The existing test demonstrates the vulnerability - the same author can vote multiple times without any duplicate detection: [11](#0-10) 

To demonstrate CPU amplification, a malicious validator would:
1. Create multiple `OrderVoteMsg` instances with different signatures for the same `LedgerInfo`
2. Broadcast all messages to network validators
3. Each validator performs full BLS signature verification for each message at verification time
4. Only after verification does deduplication occur via signature overwrite

## Notes

The vulnerability exists because of a design asymmetry between regular vote and order vote handling. Regular votes benefit from early duplicate detection via per-author tracking, while order votes lack this protection. This causes order vote signature verification to occur unconditionally for all received messages, regardless of whether the same author has already voted. The fix requires adding per-author tracking to match the protection level of regular votes.

### Citations

**File:** consensus/src/pending_votes.rs (L173-173)
```rust
    author_to_vote: HashMap<Author, (Vote, HashValue)>,
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** consensus/src/pending_order_votes.rs (L43-44)
```rust
    li_digest_to_votes:
        HashMap<HashValue /* LedgerInfo digest */, (QuorumCert, OrderVoteStatus)>,
```

**File:** consensus/src/pending_order_votes.rs (L111-112)
```rust
                sig_aggregator
                    .add_signature(order_vote.author(), order_vote.signature_with_status());
```

**File:** consensus/src/pending_order_votes.rs (L218-231)
```rust
        assert_eq!(
            pending_order_votes.insert_order_vote(
                &order_vote_1_author_0,
                &verifier,
                Some(qc.clone())
            ),
            OrderVoteReceptionResult::VoteAdded(1)
        );

        // same author voting for the same thing -> OrderVoteAdded
        assert_eq!(
            pending_order_votes.insert_order_vote(&order_vote_1_author_0, &verifier, None),
            OrderVoteReceptionResult::VoteAdded(1)
        );
```

**File:** consensus/src/round_manager.rs (L156-163)
```rust
            UnverifiedEvent::OrderVoteMsg(v) => {
                if !self_message {
                    v.verify_order_vote(peer_id, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["order_vote"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OrderVoteMsg(v)
```

**File:** consensus/src/round_manager.rs (L1561-1566)
```rust
            if self
                .pending_order_votes
                .has_enough_order_votes(order_vote_msg.order_vote().ledger_info())
            {
                return Ok(());
            }
```

**File:** consensus/consensus-types/src/order_vote_msg.rs (L63-65)
```rust
        self.order_vote
            .verify(validator)
            .context("[OrderVoteMsg] OrderVote verification failed")?;
```

**File:** consensus/consensus-types/src/order_vote.rs (L88-90)
```rust
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify OrderVote")?;
```

**File:** types/src/ledger_info.rs (L460-461)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
```
