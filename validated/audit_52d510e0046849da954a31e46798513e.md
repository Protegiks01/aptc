# Audit Report

## Title
Gas Bypass in Module Dependency Resolution via Linker Errors

## Summary
The module dependency resolution mechanism performs expensive storage reads before charging gas for dependencies. When modules do not exist, a linker error is raised after storage I/O completes but before dependency gas is charged, allowing attackers to force validators to perform unpaid storage operations.

## Finding Description

The vulnerability exists in the module dependency resolution flow where gas metering occurs **after** storage reads rather than before.

**Critical Code Path:**

The `check_dependencies_and_charge_gas` function performs dependency traversal and gas charging. At line 81, it calls `unmetered_get_existing_module_size` to get the module size, then attempts to charge gas at lines 82-89: [1](#0-0) 

However, if the module doesn't exist, `unmetered_get_existing_module_size` converts the `None` result to a linker error before gas charging occurs: [2](#0-1) 

The underlying `build` method performs actual storage I/O via `fetch_module_bytes`, which returns `None` for non-existent modules: [3](#0-2) 

The dependency gas charging implementation only executes when feature_version >= 15 and charges based on module count and size: [4](#0-3) 

**Gas Parameters:**

The bypassed costs are defined in the gas schedule: [5](#0-4) [6](#0-5) 

**Attack Flow:**
1. Attacker submits a transaction (script, entry function, or module publish) referencing many non-existent module dependencies
2. Transaction passes prologue validation and pays intrinsic gas (2,760,000 units)
3. During execution, dependency resolution calls `unmetered_get_existing_module_size` for each dependency
4. For each non-existent module, storage I/O is performed via `fetch_module_bytes`
5. `module_linker_error!` is raised, propagating via the `?` operator at line 81
6. Gas charging at lines 82-89 is never reached
7. Transaction fails with LINKER_ERROR status
8. Validators performed up to 768 storage lookups without charging dependency-specific gas

**Cost Differential:**
- Intrinsic gas paid: ~2.76M units
- Dependency gas bypassed: 74,460 × 768 + 42 × (bytes) ≈ 57M+ units
- Effective cost reduction: ~20-30x

**Existing Test Evidence:**

The codebase contains tests showing transactions with non-existent module dependencies result in LINKER_ERROR with gas charged, but these tests don't verify that dependency-specific gas (vs only intrinsic gas) was charged: [7](#0-6) 

**Invariant Broken:**

This violates the **Resource Limits** invariant that all operations must respect gas, storage, and computational limits. Storage I/O operations are performed without corresponding gas attribution for the dependency resolution work.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Validator node slowdowns":

1. **Unpaid Storage I/O**: Each transaction triggers up to 768 storage existence checks while only paying intrinsic gas, not dependency-specific gas

2. **Cost Differential**: The bypassed gas (~57M+ units per-module costs) versus paid intrinsic gas (~2.76M units) creates a ~20-30x cost reduction for the attacker

3. **Validator Resource Consumption**: Storage lookups consume validator disk/cache resources even for negative results (non-existent modules)

4. **Amplification Potential**: Multiple transactions can be submitted to amplify the impact, causing cumulative unpaid storage operations across validators

5. **Deterministic Execution**: The vulnerability is reliably triggered whenever dependency resolution encounters missing modules, making it a consistent attack vector

While this doesn't directly break consensus safety or steal funds, repeated exploitation could significantly slow block processing as validators handle unpaid storage operations, matching the "Validator node slowdowns" category.

## Likelihood Explanation

**Likelihood: High**

The attack is highly feasible because:

- **Trivial to Execute**: Any user can submit transactions referencing non-existent modules via scripts, entry functions, or module publishing
- **Low Cost**: Only requires paying intrinsic gas (~2.76M units) per transaction
- **No Special Privileges**: Works with standard transaction submission APIs
- **Deterministic**: The vulnerability is always present when dependency resolution encounters missing modules
- **Multiple Attack Vectors**: Exploitable through scripts with module handles, entry functions with non-existent dependencies, or module publishing with invalid dependency declarations

Constraints that bound but don't prevent exploitation:
- Mempool throughput limits the transaction submission rate
- Intrinsic gas still costs the attacker (not completely free)
- Max 768 dependencies per transaction provides an upper bound per attack

## Recommendation

The fix should charge gas **before** performing storage I/O, or ensure gas is charged even when modules don't exist:

**Option 1**: Charge a fixed "dependency lookup" gas before calling storage, regardless of whether the module exists.

**Option 2**: Modify `unmetered_get_existing_module_size` to charge gas before checking existence:

```rust
fn unmetered_get_existing_module_size(
    &self,
    address: &AccountAddress,
    module_name: &IdentStr,
) -> VMResult<usize> {
    // Charge lookup gas first
    self.charge_dependency_lookup(address, module_name)?;
    
    self.unmetered_get_module_size(address, module_name)?
        .ok_or_else(|| module_linker_error!(address, module_name))
}
```

**Option 3**: Move gas charging to occur before line 81 in `check_dependencies_and_charge_gas`, based on estimated size or a fixed lookup cost.

The key principle is ensuring that storage I/O operations are always paired with corresponding gas attribution, maintaining the invariant that all validator resources consumed must be paid for.

## Proof of Concept

While a full executable PoC is not provided, the vulnerability can be reproduced by:

1. Creating a Move script with module handles referencing non-existent modules (e.g., addresses with no deployed code)
2. Submitting the script transaction via the Aptos REST API
3. Observing in transaction output:
   - Transaction status: `Keep(MiscellaneousError(LINKER_ERROR))`
   - Gas used: approximately MIN_TRANSACTION_GAS_UNITS
   - Dependency-specific gas NOT charged despite storage lookups occurring
4. Monitoring validator storage I/O metrics showing lookup operations for non-existent modules
5. Repeating with up to 768 module references to maximize storage operations per transaction

The test framework in `aptos-move/e2e-testsuite/src/tests/scripts.rs` demonstrates the LINKER_ERROR case but does not validate that dependency gas was bypassed rather than charged.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/dependencies_gas_charging.rs (L80-89)
```rust
    while let Some((addr, name)) = stack.pop() {
        let size = module_storage.unmetered_get_existing_module_size(addr, name)?;
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Module(ModuleId::new(*addr, name.to_owned()))))?;
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L70-77)
```rust
    fn unmetered_get_existing_module_size(
        &self,
        address: &AccountAddress,
        module_name: &IdentStr,
    ) -> VMResult<usize> {
        self.unmetered_get_module_size(address, module_name)?
            .ok_or_else(|| module_linker_error!(address, module_name))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/implementations/unsync_module_storage.rs (L136-143)
```rust
    fn build(
        &self,
        key: &Self::Key,
    ) -> VMResult<Option<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>> {
        let mut bytes = match self.ctx.fetch_module_bytes(key.address(), key.name())? {
            Some(bytes) => bytes,
            None => return Ok(None),
        };
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L56-76)
```rust
    #[inline]
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        addr: &AccountAddress,
        _name: &IdentStr,
        size: NumBytes,
    ) -> PartialVMResult<()> {
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L29-36)
```rust
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-259)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
        ],
        [
            max_num_dependencies: NumModules,
            { RELEASE_V1_10.. => "max_num_dependencies" },
            768,
        ],
        [
            max_total_dependency_size: NumBytes,
            { RELEASE_V1_10.. => "max_total_dependency_size" },
            1024 * 1024 * 18 / 10, // 1.8 MB
        ],
```

**File:** aptos-move/e2e-testsuite/src/tests/scripts.rs (L73-150)
```rust
fn script_none_existing_module_dep() {
    let mut executor = FakeExecutor::from_head_genesis();
    executor.set_golden_file(current_function_name!());

    // create and publish sender
    let sender = executor.create_raw_account_data(1_000_000, 10);
    executor.add_account_data(&sender);

    // create a bogus script
    let mut script = empty_script();

    // make a non existent external module
    script
        .address_identifiers
        .push(AccountAddress::new([2u8; AccountAddress::LENGTH]));
    script.identifiers.push(Identifier::new("module").unwrap());
    let module_handle = ModuleHandle {
        address: AddressIdentifierIndex((script.address_identifiers.len() - 1) as u16),
        name: IdentifierIndex((script.identifiers.len() - 1) as u16),
    };
    script.module_handles.push(module_handle);
    // make a non existent function on the non existent external module
    script.identifiers.push(Identifier::new("foo").unwrap());
    let fun_handle = FunctionHandle {
        module: ModuleHandleIndex((script.module_handles.len() - 1) as u16),
        name: IdentifierIndex((script.identifiers.len() - 1) as u16),
        parameters: SignatureIndex(0),
        return_: SignatureIndex(0),
        type_parameters: vec![],
        access_specifiers: None,
        attributes: vec![],
    };
    script.function_handles.push(fun_handle);

    script.code.code = vec![
        Bytecode::Call(FunctionHandleIndex(
            (script.function_handles.len() - 1) as u16,
        )),
        Bytecode::Ret,
    ];
    let mut blob = vec![];
    script.serialize(&mut blob).expect("script must serialize");
    let txn = sender
        .account()
        .transaction()
        .script(Script::new(blob, vec![], vec![]))
        .sequence_number(10)
        .gas_unit_price(1)
        .sign();

    // execute transaction
    let output = &executor.execute_transaction(txn);
    let status = output.status();
    match status {
        TransactionStatus::Keep(_) => (),
        _ => panic!("TransactionStatus must be Keep"),
    }
    assert_eq!(
        status.status(),
        Ok(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::LINKER_ERROR
        ))),
        "Linker Error: Transaction executed at a non-existent external module"
    );
    executor.apply_write_set(output.write_set());

    // Check that numbers in store are correct.
    let gas = output.gas_used();
    let balance = 1_000_000 - gas;
    let updated_sender = executor
        .read_account_resource(sender.account())
        .expect("sender must exist");
    let updated_sender_balance = executor
        .read_apt_fungible_store_resource(sender.account())
        .expect("sender balance must exist");
    assert_eq!(balance, updated_sender_balance.balance());
    assert_eq!(11, updated_sender.sequence_number());
}
```
