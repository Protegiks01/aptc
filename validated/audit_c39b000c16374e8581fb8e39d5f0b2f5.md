# Audit Report

## Title
Missing Inner Vector Size Validation in DKG Weighted Transcript Enables DoS via MSM Amplification

## Summary
The DKG weighted transcript verification in `weighted_transcriptv2.rs` validates only the outer size of the `Vs`, `Cs`, and `Rs` vectors but fails to validate that inner vector sizes match each player's weight. A Byzantine validator can craft a malicious transcript with inflated inner vectors, forcing other validators to perform expensive Multi-Scalar Multiplication (MSM) computations during verification, resulting in denial-of-service.

## Finding Description

The vulnerability exists in the DKG transcript verification logic executed when validators submit DKG results. The verification process validates outer vector dimensions but omits validation of inner vector sizes.

**Missing Validation:**

The `verify()` function checks only that the outer vector lengths match the total number of players: [1](#0-0) 

However, there is no validation that `Vs[i].len()` or `Cs[i][j].len()` match the expected player weights. This contrasts with the `decrypt_own_share` function which includes a debug assertion (only active in debug builds): [2](#0-1) 

**Attack Mechanism:**

During normal operation, the `msm_terms()` function creates one MSM input per element with a single base-scalar pair: [3](#0-2) 

During sigma protocol verification, the verifier counts all elements by flattening the nested structure: [4](#0-3) 

The `CodomainShape::into_iter()` implementation flattens the `Vec<Vec<T>>` structure: [5](#0-4) 

This causes the verifier to generate beta powers for each element and process them in `merge_msm_terms`: [6](#0-5) 

Finally, the expensive MSM evaluation is performed: [7](#0-6) 

**Attack Path:**

1. Byzantine validator creates transcript with `Vs.len() = sc.get_total_num_players()` (passes outer validation)
2. Sets `Vs[i].len()` to arbitrarily large values (e.g., 10,000 per player instead of 1-5)
3. Generates valid sigma protocol proof for the inflated structure
4. Submits as ValidatorTransaction which is verified in the VM: [8](#0-7) 

5. Each validator processing this transaction performs expensive MSM computations proportional to the inflated sizes

## Impact Explanation

This is a **High Severity** validator node slowdown vulnerability per Aptos bug bounty criteria. The attack causes "Validator node slowdowns" (High Severity category) during DKG verification.

With typical weight configurations like `[1, 2, 5]` (total 8), an attacker could inflate to `[10000, 10000, 10000]` (total 30,000), causing ~755x computational amplification. MSM computation complexity is O(n/log₂n) where n is the number of scalar-base pairs.

Impact includes:
- Significant validator performance degradation during DKG ceremonies
- Validators lagging or timing out during critical epoch transitions
- Resource exhaustion on validator nodes
- Potential delay in epoch transitions affecting network liveness

This breaks the resource limits invariant that all operations must respect computational limits.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Any DKG participant (Byzantine validator with <1/3 stake)
- **Complexity**: Low - simply inflate inner vector sizes while maintaining correct outer sizes
- **Detection**: Difficult - transcript appears structurally valid, only causes slowdown during verification
- **Impact**: Immediate - each malicious transcript forces expensive computation on all validators

## Recommendation

Add validation of inner vector sizes in the `verify()` function:

```rust
// After line 486 in weighted_transcriptv2.rs
for i in 0..sc.get_total_num_players() {
    let expected_weight = sc.get_player_weight(&sc.get_player(i));
    if self.subtrs.Vs[i].len() != expected_weight {
        bail!(
            "Player {} has incorrect Vs size: expected {}, got {}",
            i, expected_weight, self.subtrs.Vs[i].len()
        );
    }
    if self.subtrs.Cs[i].len() != expected_weight {
        bail!(
            "Player {} has incorrect Cs size: expected {}, got {}",
            i, expected_weight, self.subtrs.Cs[i].len()
        );
    }
}
```

## Proof of Concept

A malicious validator can generate a transcript using the `generate()` function which creates arbitrary-sized structures: [9](#0-8) 

By modifying the loop bounds to create inflated inner vectors while maintaining correct outer dimensions, the transcript would pass current validation but cause DoS during verification.

## Notes

- The report's claim about a TODO comment acknowledging the missing validation is inaccurate. The TODO comments at lines 80-82 relate to notation and affine representation, not validation.
- The severity should be classified as **High** (not Medium as originally stated) per the Aptos bug bounty criteria for "Validator Node Slowdowns."
- The vulnerability affects all validators processing DKG transactions during epoch transitions, making it a critical availability issue for the consensus layer.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L474-486)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L613-643)
```rust
    #[allow(non_snake_case)]
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let Cs = &self.Cs[player.id];
        debug_assert_eq!(Cs.len(), sc.get_player_weight(player));

        if !Cs.is_empty() {
            if let Some(first_key) = self.Rs.first() {
                debug_assert_eq!(
                    first_key.len(),
                    Cs[0].len(),
                    "Number of ephemeral keys does not match the number of ciphertext chunks"
                );
            }
        }

        let pk_shares = self.get_public_key_share(sc, player);

        let sk_shares: Vec<_> =
            decrypt_chunked_scalars(&Cs, &self.Rs, &dk.dk, &pp.pp_elgamal, &pp.table, pp.ell);

        (
            Scalar::vec_from_inner(sk_shares),
            pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L895-930)
```rust
    #[allow(non_snake_case)]
    fn generate<R>(sc: &Self::SecretSharingConfig, pp: &Self::PublicParameters, rng: &mut R) -> Self
    where
        R: rand_core::RngCore + rand_core::CryptoRng,
    {
        let num_chunks_per_share = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;

        Transcript {
            dealer: sc.get_player(0),
            subtrs: Subtranscript {
                V0: unsafe_random_point_group::<E::G2, _>(rng),
                Vs: sc.group_by_player(&unsafe_random_points_group::<E::G2, _>(
                    sc.get_total_weight(),
                    rng,
                )),
                Cs: (0..sc.get_total_num_players())
                    .map(|i| {
                        let w = sc.get_player_weight(&sc.get_player(i)); // TODO: combine these functions...
                        (0..w)
                            .map(|_| unsafe_random_points_group(num_chunks_per_share, rng))
                            .collect() // todo: use vec![vec![]]... like in the generate functions
                    })
                    .collect(),
                Rs: (0..sc.get_max_weight())
                    .map(|_| unsafe_random_points_group(num_chunks_per_share, rng))
                    .collect(),
            },
            sharing_proof: SharingProof {
                range_proof_commitment: sigma_protocol::homomorphism::TrivialShape(
                    unsafe_random_point_group(rng),
                ),
                SoK: hkzg_chunked_elgamal_commit::Proof::generate(sc, num_chunks_per_share, rng),
                range_proof: dekart_univariate_v2::Proof::generate(pp.ell, rng),
            },
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_scalar_mul.rs (L61-71)
```rust
impl<T> IntoIterator for CodomainShape<T>
where
    T: CanonicalSerialize + CanonicalDeserialize + Clone,
{
    type IntoIter = std::vec::IntoIter<T>;
    type Item = T;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter().flatten().collect::<Vec<_>>().into_iter()
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_scalar_mul.rs (L98-116)
```rust
    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {
        let rows: Vec<Vec<Self::MsmInput>> = input
            .chunked_values
            .iter()
            .map(|row| {
                row.iter()
                    .map(|chunks| MsmInput {
                        bases: vec![self.base.clone()],
                        scalars: vec![le_chunks_to_scalar(
                            self.ell,
                            &Scalar::slice_as_inner(chunks),
                        )],
                    })
                    .collect()
            })
            .collect();

        CodomainShape(rows)
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_scalar_mul.rs (L118-120)
```rust
    fn msm_eval(input: Self::MsmInput) -> Self::MsmOutput {
        C::msm(input.bases(), input.scalars()).expect("MSM failed in Schnorr") // TODO: custom MSM here, because only length 1 MSM except during verification
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L104-132)
```rust
    fn msm_terms_for_verify<Ct: Serialize, H>(
        &self,
        public_statement: &Self::Codomain,
        proof: &Proof<C::ScalarField, H>,
        cntxt: &Ct,
    ) -> Self::MsmInput
    where
        H: homomorphism::Trait<Domain = Self::Domain, Codomain = Self::Codomain>, // Need this because the lifetime was changed
    {
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };

        let number_of_beta_powers = public_statement.clone().into_iter().count(); // TODO: maybe pass the into_iter version in merge_msm_terms?

        let (c, powers_of_beta) = self.compute_verifier_challenges(public_statement, prover_first_message, cntxt, number_of_beta_powers);

        let msm_terms_for_prover_response = self.msm_terms(&proof.z);

        Self::merge_msm_terms(
            msm_terms_for_prover_response.into_iter().collect(),
            prover_first_message,
            public_statement,
            &powers_of_beta,
            c,
        )
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L139-184)
```rust
    fn merge_msm_terms(
        msm_terms: Vec<Self::MsmInput>,
        prover_first_message: &Self::Codomain,
        statement: &Self::Codomain,
        powers_of_beta: &[C::ScalarField],
        c: C::ScalarField,
    ) -> Self::MsmInput
    {
        let mut final_basis = Vec::new();
        let mut final_scalars = Vec::new();

        // Collect all projective points to batch normalize
        // TODO: remove this stuff... we may assume things are deserialised and hence essentially affine, so into_affine() should do
        let mut all_points_to_normalize = Vec::new();
        for (A, P) in prover_first_message.clone().into_iter()
            .zip(statement.clone().into_iter())
        {
            all_points_to_normalize.push(A);
            all_points_to_normalize.push(P);
        }

        let affine_points = C::normalize_batch(&all_points_to_normalize);
        let mut affine_iter = affine_points.into_iter();

        for (term, beta_power) in msm_terms.into_iter().zip(powers_of_beta) {
            let mut bases = term.bases().to_vec();
            let mut scalars = term.scalars().to_vec();

            // Multiply scalars by βᶦ
            for scalar in scalars.iter_mut() {
                *scalar *= beta_power;
            }

            // Add prover + statement contributions
            bases.push(affine_iter.next().unwrap()); // this is the element `A` from the prover's first message
            bases.push(affine_iter.next().unwrap()); // this is the element `P` from the statement, but we'll need `P^c`

            scalars.push(- (*beta_power));
            scalars.push(-c * beta_power);

            final_basis.extend(bases);
            final_scalars.extend(scalars);
        }

        Self::MsmInput::new(final_basis, final_scalars).expect("Something went wrong constructing MSM input")
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
