# Audit Report

## Title
Order Vote Processing Violates `preferred_round <= last_voted_round` Invariant Causing Validator Liveness Failure

## Summary
The `guarded_construct_and_sign_order_vote` function updates `preferred_round` via `observe_qc()` without updating `last_voted_round`, allowing `preferred_round` to exceed `last_voted_round`. This violates a critical consensus invariant and prevents affected validators from functioning as leaders until the network progresses beyond the inflated `preferred_round` value.

## Finding Description
The vulnerability exists in the order vote processing logic where two critical operations are mismatched. In the order vote path, `observe_qc()` is called to update safety data but `verify_and_update_last_vote_round()` is never called: [1](#0-0) 

This contrasts with the regular voting path where both functions are called to maintain the invariant: [2](#0-1) 

The `observe_qc()` function updates `preferred_round` based on the QC's parent block round (the two-chain round): [3](#0-2) 

**Attack Scenario:**
1. Validator has state: `last_voted_round = 6`, `preferred_round = 5`
2. Network progresses to round 15 while validator is temporarily slow/disconnected
3. Validator receives OrderVoteProposal for round 15 with QC certifying round 14 (parent at round 13)
4. `observe_qc()` sets `preferred_round = 13` (the two-chain round from QC's parent)
5. `last_voted_round` remains 6 (not updated in order vote path)
6. **Result: `preferred_round (13) > last_voted_round (6)` - INVARIANT VIOLATED**

The corrupted state persists via `set_safety_data()` which performs no validation: [4](#0-3) 

When this validator later becomes leader and attempts to sign a proposal, `verify_and_update_preferred_round()` is called: [5](#0-4) 

This function requires `one_chain_round >= preferred_round`. If the validator tries to propose at round 7 with a QC for round 6, it fails because `6 < 13`, returning `IncorrectPreferredRound` error. The validator cannot serve as leader until the network reaches round 13+.

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Affected validators cannot function as leaders, reducing network throughput and increasing block proposal latency. If multiple validators are affected during network asynchrony periods, consensus performance degrades significantly. This directly matches the "Validator Node Slowdowns (High)" category in the bug bounty framework which specifies "Significant performance degradation affecting consensus."

2. **Significant Protocol Violations**: Violates the fundamental relationship between `preferred_round` and `last_voted_round`. The display format shows these fields are tracked together: [6](#0-5) 

3. **Persistent State Corruption**: The corrupted state survives node restarts and can only be recovered by waiting for network progression or voting on later proposals.

4. **No Direct Safety Violation**: While this breaks liveness, consensus safety is maintained because `verify_and_update_preferred_round` causes affected validators to be overly conservative (rejecting valid proposals rather than accepting invalid ones).

## Likelihood Explanation
**High Likelihood**:

1. **Natural Occurrence**: Validators commonly lag behind the network due to network delays, temporary downtime, or catching up after restarts.

2. **Normal Protocol Operation**: Order votes are broadcast as part of the standard consensus protocol after blocks receive QCs: [7](#0-6) 

3. **Order Vote Validation**: The `verify_order_vote_proposal()` function only checks epoch, QC validity, and block consistency - it does NOT validate round relationships with `last_voted_round`: [8](#0-7) 

4. **Frequent in Production**: Any validator experiencing temporary network issues or restarts will process order votes for blocks it hasn't voted on yet. Order votes are accepted if within 100 rounds of `highest_ordered_round`: [9](#0-8) 

## Recommendation
Add a call to `verify_and_update_last_vote_round()` in the order vote path, or alternatively, add validation in `set_safety_data()` to ensure `preferred_round <= last_voted_round` invariant is maintained. The fix should ensure that when processing order votes for rounds beyond the validator's current voting position, the safety data remains internally consistent.

## Proof of Concept
The vulnerability can be demonstrated through the following scenario in the existing test framework:

1. Initialize a validator with `last_voted_round = 6`, `preferred_round = 5`
2. Create an OrderVoteProposal for round 15 with a QC certifying round 14 (parent at round 13)
3. Call `construct_and_sign_order_vote()` - this succeeds and sets `preferred_round = 13`
4. Verify `last_voted_round` remains 6 (invariant violated: 13 > 6)
5. Attempt to call `sign_proposal()` for round 7 with QC for round 6
6. Observe `IncorrectPreferredRound(6, 13)` error, preventing the validator from proposing

## Notes
This vulnerability demonstrates a subtle inconsistency in how order votes update safety data compared to regular votes. While the safety rules correctly enforce that regular votes must monotonically increase `last_voted_round`, order votes can observe QCs for rounds far ahead without updating `last_voted_round`, breaking the expected invariant. The error type definition confirms this check exists: [10](#0-9)

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L43-51)
```rust
impl fmt::Display for SafetyData {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "SafetyData: [epoch: {}, last_voted_round: {}, preferred_round: {}, one_chain_round: {}, highest_timeout_round: {:?}]",
            self.epoch, self.last_voted_round, self.preferred_round, self.one_chain_round, self.highest_timeout_round,
        )
    }
}
```

**File:** consensus/src/round_manager.rs (L1568-1573)
```rust
            let highest_ordered_round = self.block_store.sync_info().highest_ordered_round();
            let order_vote_round = order_vote_msg.order_vote().ledger_info().round();
            let li_digest = order_vote_msg.order_vote().ledger_info().hash();
            if order_vote_round > highest_ordered_round
                && order_vote_round < highest_ordered_round + 100
            {
```

**File:** consensus/src/round_manager.rs (L1653-1680)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
            if !proposed_block.block().is_nil_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED,
                );
            }
            if proposed_block.block().is_opt_block() {
                observe_block(
                    proposed_block.block().timestamp_usecs(),
                    BlockStage::ORDER_VOTED_OPT_BLOCK,
                );
            }
            let order_vote_msg = OrderVoteMsg::new(order_vote, qc.as_ref().clone());
            info!(
                self.new_log(LogEvent::BroadcastOrderVote),
                "{}", order_vote_msg
            );
            self.network.broadcast_order_vote(order_vote_msg).await;
```

**File:** consensus/safety-rules/src/error.rs (L17-18)
```rust
    #[error("Provided round, {0}, is incompatible with preferred round, {1}")]
    IncorrectPreferredRound(u64, u64),
```
