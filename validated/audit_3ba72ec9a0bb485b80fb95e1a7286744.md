# Audit Report

## Title
JWK Consensus Config Buffer Overwrite During DKG-Based Reconfiguration

## Summary
Multiple JWK consensus configuration proposals can execute within the same epoch when DKG-based reconfiguration is enabled, causing later proposals to silently overwrite earlier proposals' buffered configurations without validation. This results in governance-approved configurations being lost and never applied to the blockchain.

## Finding Description

The vulnerability occurs in the interaction between the JWK consensus config buffering mechanism and the asynchronous DKG-based reconfiguration process.

**Root Cause:**

When governance proposals are generated for JWK consensus config updates, they produce scripts that call both `jwk_consensus_config::set_for_next_epoch()` and `aptos_governance::reconfigure()`. [1](#0-0) 

The `set_for_next_epoch()` function directly calls `config_buffer::upsert()` without any validation to check if a configuration is already buffered. [2](#0-1) 

The `config_buffer::upsert()` function uses `simple_map::upsert()` which silently overwrites any existing buffered value. [3](#0-2) 

The `simple_map::upsert()` implementation replaces existing values without error when a key already exists. [4](#0-3) 

When DKG-based reconfiguration is enabled, `aptos_governance::reconfigure()` calls `try_start()` instead of immediately finishing the epoch. [5](#0-4) 

The `try_start()` function initiates DKG but does NOT immediately complete the epoch transition. If called again while DKG is already in progress for the current epoch, it returns early without raising an error. [6](#0-5) 

**Attack Scenario:**

1. **Epoch N, Block B1**: Proposal A executes:
   - Buffers JWK config A via `config_buffer::upsert()`
   - Calls `reconfigure()` which invokes `try_start()`, initiating DKG
   - Epoch remains N, DKG begins asynchronously

2. **Epoch N, Block B2** (DKG still running): Proposal B executes:
   - Buffers JWK config B via `config_buffer::upsert()`, **overwriting config A**
   - Calls `reconfigure()` which invokes `try_start()` again
   - `try_start()` detects DKG already in progress for epoch N, returns early
   - No error is raised; the proposal appears to succeed

3. **Later**: DKG completes, `finish()` is called, which triggers `on_new_epoch()`. [7](#0-6) 

The `on_new_epoch()` function extracts the buffered config, but only config B exists (config A was overwritten). [8](#0-7) 

**Invariant Violation:**

This breaks the **Governance Integrity** invariant: approved governance proposals must execute as voted upon. The blockchain applies a different configuration than what was approved by governance, silently discarding legitimate governance decisions.

Critically, there is no mechanism preventing governance proposal execution during reconfiguration. The `reconfiguration_state::is_in_progress()` check exists in the staking module [9](#0-8)  but no such check exists in `aptos_governance.move`, `jwk_consensus_config.move`, or `config_buffer.move`.

The config buffer's overwrite behavior is intentional by design as shown in the test. [10](#0-9) 

## Impact Explanation

**Severity: Medium to High**

This qualifies as a **protocol integrity violation** because:

1. **Governance Integrity Compromise**: Governance-approved proposals are silently ignored, fundamentally undermining the blockchain's governance mechanism
2. **Silent Failure**: No error is raised; proposals appear to execute successfully while their configurations are discarded
3. **Security Configuration Impact**: JWK consensus configs control JSON Web Key validation for authentication
4. **Non-deterministic Behavior**: Which proposal "wins" depends on execution timing, not governance rules or voting results

This could lead to critical security configurations being silently not applied, validators operating under different assumptions about active configurations, and loss of trust in the governance system.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability occurs when:
1. DKG-based reconfiguration is enabled (production configuration)
2. Multiple JWK config proposals pass governance within a short timeframe
3. Both execute within the same epoch while DKG is running

**Factors increasing likelihood:**
- DKG sessions span multiple blocks (typically several seconds to minutes), creating a substantial execution window
- No warning or error is raised when configs are overwritten
- Governance participants have no visibility into the buffer state to detect conflicts
- No validation exists to prevent this scenario

**Factors decreasing likelihood:**
- Requires multiple JWK config proposals to be approved and executed in rapid succession
- JWK config changes are relatively infrequent in normal operation

## Recommendation

Add validation to prevent config buffer overwrites during active reconfiguration:

1. Check `reconfiguration_state::is_in_progress()` in `config_buffer::upsert()` before allowing overwrites
2. Add a check in `jwk_consensus_config::set_for_next_epoch()` to abort if a config is already buffered
3. Have `try_start()` abort with an error instead of silently returning when DKG is already in progress
4. Add events to log config buffer updates for visibility

## Proof of Concept

The technical validation demonstrates the execution path through code analysis. A complete PoC would require:
1. Creating two governance proposals for different JWK configs
2. Executing the first proposal to start DKG
3. Executing the second proposal while DKG is running
4. Verifying that only the second config is applied after DKG completes

## Notes

The core technical vulnerability is valid - the code analysis confirms that multiple governance proposals can overwrite buffered configurations during DKG. However, the severity classification should be carefully considered as this is a governance integrity issue rather than a consensus safety violation (it does not cause chain splits or validator disagreement on state).

### Citations

**File:** aptos-move/aptos-release-builder/src/components/jwk_consensus_config.rs (L29-44)
```rust
                    emitln!(writer, "jwk_consensus_config::set_for_next_epoch({}, jwk_consensus_config::new_off());", signer_arg);
                },
                OnChainJWKConsensusConfig::V1(v1) => {
                    emitln!(writer, "let config = jwk_consensus_config::new_v1(vector[");
                    for p in v1.oidc_providers.iter() {
                        emitln!(writer, "jwk_consensus_config::new_oidc_provider(utf8(b\"{}\"), utf8(b\"{}\")),", p.name, p.config_url);
                    }
                    emitln!(writer, "]);");
                    emitln!(
                        writer,
                        "jwk_consensus_config::set_for_next_epoch({}, config);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L62-65)
```text
    public fun set_for_next_epoch(framework: &signer, config: JWKConsensusConfig) {
        system_addresses::assert_aptos_framework(framework);
        config_buffer::upsert(config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L68-78)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires JWKConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<JWKConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<JWKConsensusConfig>();
            if (exists<JWKConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<JWKConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L94-110)
```text
    #[test(fx = @std)]
    fun test_config_buffer_basic(fx: &signer) acquires PendingConfigs {
        initialize(fx);
        // Initially nothing in the buffer.
        assert!(!does_exist<DummyConfig>(), 1);

        // Insert should work.
        upsert(DummyConfig { data: 888 });
        assert!(does_exist<DummyConfig>(), 1);

        // Update and extract should work.
        upsert(DummyConfig { data: 999 });
        assert!(does_exist<DummyConfig>(), 1);
        let config = extract_v2<DummyConfig>();
        assert!(config == DummyConfig { data: 999 }, 1);
        assert!(!does_exist<DummyConfig>(), 1);
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L116-134)
```text
    public fun upsert<Key: store, Value: store>(
        self: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value
    ): (std::option::Option<Key>, std::option::Option<Value>) {
        let data = &mut self.data;
        let len = data.length();
        for (i in 0..len) {
            let element = data.borrow(i);
            if (&element.key == &key) {
                data.push_back(Element { key, value });
                data.swap(i, len);
                let Element { key, value } = data.pop_back();
                return (std::option::some(key), std::option::some(value))
            };
        };
        self.data.push_back(Element { key, value });
        (std::option::none(), std::option::none())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L24-40)
```text
    public(friend) fun try_start() {
        let incomplete_dkg_session = dkg::incomplete_session();
        if (option::is_some(&incomplete_dkg_session)) {
            let session = option::borrow(&incomplete_dkg_session);
            if (dkg::session_dealer_epoch(session) == reconfiguration::current_epoch()) {
                return
            }
        };
        reconfiguration_state::on_reconfig_start();
        let cur_epoch = reconfiguration::current_epoch();
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1910-1912)
```text
    fun assert_reconfig_not_in_progress() {
        assert!(!reconfiguration_state::is_in_progress(), error::invalid_state(ERECONFIGURATION_IN_PROGRESS));
    }
```
