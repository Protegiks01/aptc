# Audit Report

## Title
Consensus Safety Violation via Partial Transaction Filter Validation in Hybrid Payloads

## Summary
Validators use separate local `consensus_filter` and `execution_filter` configurations with no cross-validator consistency enforcement. During consensus validation, only inline transactions are checked against filter rules, while execution filters ALL transactions (including proof-based batches). Since decoupled execution is always enabled, validators with different execution filter settings will execute different transaction sets from the same committed block, producing divergent state roots and breaking consensus safety.

## Finding Description

This vulnerability exploits an architectural mismatch between consensus validation and execution filtering in the hybrid payload system.

**Separate Filter Configurations Without Enforcement:**

The system maintains distinct `consensus_filter` and `execution_filter` configurations as separate fields in `TransactionFiltersConfig`. [1](#0-0) 

These filters are loaded from local node configuration independently by each validator with no cross-validator consistency validation. [2](#0-1) [3](#0-2) 

The README explicitly acknowledges that filters are applied locally and different nodes can have different configurations, warning that "care should be taken to ensure consistent execution across validators" but providing no enforcement mechanism. [4](#0-3) 

**Decoupled Execution Always Enabled:**

The `decoupled_execution()` method is hardcoded to always return `true`, meaning validators vote on block ordering without executing first. [5](#0-4) 

When creating vote proposals, the system always passes `true` for the `decoupled_execution` flag, causing validators to vote with placeholder state roots before execution completes. [6](#0-5) 

**Partial Validation During Consensus:**

During proposal validation, `check_denied_inline_transactions()` only checks inline transactions against the consensus filter. [7](#0-6) 

The `get_inline_transactions()` helper extracts ONLY inline batches from hybrid payloads, completely ignoring proof-based batches. [8](#0-7) 

**Complete Filtering During Execution:**

When blocks are executed, `get_transactions_quorum_store_inline_hybrid()` retrieves ALL transactions including proof-based portions by calling `process_qs_payload()` on the `proof_with_data` and then appending inline batch transactions. [9](#0-8) 

During block preparation, ALL retrieved transactions are filtered using the `execution_filter` configuration. [10](#0-9) 

The filtering logic removes transactions that don't pass the filter rules. [11](#0-10) 

**Attack Scenario:**

1. Validator A configures `execution_filter` to deny transactions from address 0xABCD (legitimate operational reason)
2. Validator B has no execution filter or different rules
3. Block proposer creates `QuorumStoreInlineHybrid` payload with transaction from 0xABCD in `proof_with_data` [12](#0-11) 
4. All validators call `check_denied_inline_transactions()` → only inline batches checked → 0xABCD transaction in proof portion → PASS
5. Validators vote with placeholder state roots (decoupled execution) → block committed with 2f+1 votes
6. Validator A: Executes with `execution_filter` → 0xABCD transaction removed → computes state root R₁
7. Validator B: Executes without filter → all transactions included → computes state root R₂
8. R₁ ≠ R₂ → Consensus divergence

This violates AptosBFT's fundamental safety guarantee that all honest validators must produce identical state roots for identical committed blocks.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This qualifies as Critical under the Aptos Bug Bounty program's "Consensus/Safety violations" and "Non-recoverable network partition" categories:

1. **Consensus Safety Break**: Validators compute different state roots for the same committed block, directly violating AptosBFT safety guarantees. Unlike typical Byzantine faults requiring >1/3 malicious validators, this exploits legitimate configuration differences between honest validators.

2. **Network Partition**: Once divergence occurs, validators form incompatible ledger states that cannot reconcile through normal consensus operations. The network splits into groups based on execution filter configurations.

3. **Requires Hardfork Recovery**: The divergence is permanent and irrecoverable through protocol mechanisms. Manual coordination and a hardfork are required to resolve the state inconsistency.

4. **Silent Failure Mode**: With decoupled execution, validators successfully vote and commit blocks before execution divergence occurs, providing no immediate indication of the problem. Divergence only becomes apparent when attempting to build subsequent blocks.

## Likelihood Explanation

**High Likelihood:**

1. **Legitimate Configuration Diversity**: The system explicitly supports and documents that different validators can have different filter configurations for valid operational reasons (emergency response, regulatory compliance, gradual rollouts).

2. **No Consistency Enforcement**: The codebase contains no validation mechanism to ensure validators use identical `execution_filter` configurations. Each validator independently loads filters from local configuration files.

3. **Natural Trigger Condition**: The vulnerability requires no malicious actor. QuorumStore naturally distributes transactions between inline batches and proof batches through normal operations. Any proof-based transaction matching a filter rule triggers divergence.

4. **Decoupled Execution Always Enabled**: The hardcoded `true` return value ensures validators always vote before executing, creating the window for undetected divergence.

5. **Production Payload Type**: `QuorumStoreInlineHybrid` payloads with `proof_with_data` are standard production features, not experimental code paths.

## Recommendation

Implement cross-validator consistency enforcement for execution filters:

1. **Option A - Make execution filters on-chain consensus parameters**: Store execution filter configurations in on-chain governance similar to `ConsensusConfig`, requiring all validators to use identical filters through epoch state.

2. **Option B - Validate proof transactions during consensus**: Extend `check_denied_inline_transactions()` to also check transactions in `proof_with_data`, ensuring consensus validation matches execution filtering:

```rust
fn get_all_transactions(block: &Block) -> Vec<SignedTransaction> {
    // Extract both inline AND proof-based transactions
    // Apply same logic as execution phase
}
```

3. **Option C - Disable execution filtering**: Remove `execution_filter` capability entirely, keeping only `consensus_filter` to ensure validation and execution are consistent.

4. **Immediate mitigation**: Add runtime assertion that `consensus_filter == execution_filter` during validator initialization to detect misconfigurations.

## Proof of Concept

While a full PoC would require deploying multiple validators with different configurations, the vulnerability is demonstrable through code inspection showing:

1. Two validators with different `execution_filter` configs (easily created in node YAML)
2. A `QuorumStoreInlineHybrid` block with transaction X in `proof_with_data`
3. Validator 1 filters X during execution, Validator 2 does not
4. Both validators vote and commit the block (decoupled execution)
5. Different transaction sets executed → different state roots computed
6. Consensus cannot proceed on next block due to parent state mismatch

The architectural flaw is evident from the code paths: consensus validation operates on a subset of transactions while execution operates on all transactions, with no enforcement of filter consistency across validators.

## Notes

This vulnerability is particularly concerning because:
- The README explicitly acknowledges filters can differ across validators
- The warning to "ensure consistent execution" is purely advisory with no technical enforcement
- Decoupled execution is hardcoded enabled, maximizing the attack window
- The hybrid payload feature naturally separates transactions into checked (inline) and unchecked (proof) portions

The issue represents a fundamental architectural mismatch between consensus validation scope and execution filtering scope, exacerbated by the decoupled execution model.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L14-15)
```rust
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/consensus_provider.rs (L69-69)
```rust
        node_config.transaction_filters.execution_filter.clone(),
```

**File:** crates/aptos-transaction-filters/README.md (L105-108)
```markdown

```

**File:** types/src/on_chain_config/consensus_config.rs (L239-241)
```rust
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L463-468)
```rust
        VoteProposal::new(
            compute_result.extension_proof(),
            self.block.clone(),
            compute_result.epoch_state().clone(),
            true,
        )
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L135-150)
```rust
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L319-319)
```rust
        let inline_transactions = get_inline_transactions(block);
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L576-589)
```rust
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L101-112)
```rust
        transactions
            .into_iter()
            .filter(|txn| {
                self.allows_transaction(
                    block_id,
                    block_author,
                    block_epoch,
                    block_timestamp_usecs,
                    txn,
                )
            })
            .collect()
```

**File:** consensus/src/quorum_store/proof_manager.rs (L229-234)
```rust
                Payload::QuorumStoreInlineHybrid(
                    inline_block,
                    ProofWithData::new(proof_block),
                    None,
                )
            }
```
