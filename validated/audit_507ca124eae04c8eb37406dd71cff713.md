# Audit Report

## Title
Missing Epoch Verification in Timeout Certificate Validation Allows Cross-Epoch Replay Attacks

## Summary
The `verify_tc()` function in the safety rules implementation fails to verify that timeout certificates belong to the current epoch, allowing timeout certificates from previous epochs to be replayed if validator sets overlap. This violates epoch isolation guarantees and can lead to consensus safety violations.

## Finding Description

The `verify_tc()` function validates timeout certificate signatures but does not verify the certificate's epoch matches the current epoch. [1](#0-0) 

This function is called in two critical consensus paths: when voting on proposals with attached timeout certificates [2](#0-1)  and when signing timeouts with previous timeout certificates [3](#0-2) 

While the timeout or proposal epoch is verified [4](#0-3) , the accompanying timeout certificate's epoch is never checked. In contrast, other parts of the codebase explicitly enforce epoch boundaries for timeout certificates. `SyncInfo::verify()` checks TC epoch matches other components [5](#0-4) , and persistent storage filters TCs by epoch during recovery [6](#0-5) 

**Attack Scenario:**

When an epoch transition occurs, safety data is reset to zero rounds [7](#0-6) 

1. Epoch N creates a valid timeout certificate TC_N for round 3 (with 2f+1 validator signatures)
2. Epoch N ends and epoch N+1 begins with overlapping validator set
3. A malicious leader includes TC_N in their proposal's SyncInfo in epoch N+1 at round 4
4. The TC passes through `insert_2chain_timeout_certificate()` which only validates round, not epoch [8](#0-7) 
5. When validators vote, `verify_tc(TC_N)` verifies signatures using epoch N+1's validator verifier but doesn't check epoch mismatch [1](#0-0) 
6. The `TwoChainTimeoutCertificate::verify()` method reconstructs TimeoutSigningRepr using the TC's embedded epoch N [9](#0-8) 
7. If validators overlap between epochs, their public keys remain the same, so signatures on epoch N messages verify against epoch N+1's verifier
8. `safe_to_vote()` uses the TC's round in safety logic, treating it as if it occurred in the current epoch [10](#0-9) 

The timeout certificate structure contains an epoch field that should be validated [11](#0-10) 

## Impact Explanation

This vulnerability represents **High Severity** per the Aptos bug bounty criteria as it enables significant protocol violations:

- **Consensus Safety Risk**: Validators make safety decisions based on timeout information from the wrong epoch context, potentially allowing voting patterns that violate 2-chain safety guarantees
- **Epoch Isolation Breach**: Consensus artifacts from previous epochs can influence current epoch decisions, breaking the fundamental isolation between epochs that is critical for consensus correctness
- **Validator Set Confusion**: When validator sets overlap between epochs (common in practice), replayed certificates appear cryptographically valid despite being from the wrong epoch

This qualifies as a consensus safety violation because it allows validators to base voting decisions on stale epoch state, potentially leading to incorrect block commitments. The impact is contained to protocol violations rather than direct fund loss, placing it in High rather than Critical severity.

## Likelihood Explanation

The likelihood is **MEDIUM** based on:

**Favorable conditions for exploitation:**
- Validator sets commonly overlap or remain identical between epochs in both testnet and mainnet deployments
- Epoch transitions are regular occurrences in normal operation
- Round numbers can naturally align between epoch boundaries (e.g., round 3 in epoch N, round 4 in epoch N+1)
- Only requires a single malicious or compromised validator serving as leader
- The block store accepts TCs based solely on round comparison without epoch validation [8](#0-7) 

**Limiting factors:**
- Requires being selected as leader at the right round after epoch transition
- Must have saved timeout certificates from previous epochs
- Attack window may be narrow depending on round progression speed
- Requires validator set overlap between consecutive epochs

## Recommendation

Add epoch verification to `verify_tc()` to ensure the timeout certificate belongs to the current epoch:

```rust
fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
    let epoch_state = self.epoch_state()?;
    let safety_data = self.persistent_storage.safety_data()?;
    
    // Add epoch check
    if tc.epoch() != safety_data.epoch {
        return Err(Error::IncorrectEpoch(tc.epoch(), safety_data.epoch));
    }
    
    if !self.skip_sig_verify {
        tc.verify(&epoch_state.verifier)
            .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
    }
    Ok(())
}
```

Additionally, add epoch filtering to `insert_2chain_timeout_certificate()` to prevent TCs from wrong epochs from entering the block store during runtime (not just during recovery).

## Proof of Concept

A full PoC would require setting up a test environment with:
1. Two consecutive epochs with overlapping validator sets
2. Creating a valid TC in epoch N
3. Attempting to use it in epoch N+1 through a malicious proposal
4. Demonstrating that `verify_tc()` accepts it without epoch validation

The vulnerability is confirmed through code analysis showing the missing epoch check in the verification path used during voting.

## Notes

The vulnerability exists because `verify_tc()` only performs cryptographic verification of signatures but assumes epoch correctness. While `SyncInfo::verify()` does check epoch consistency, it only ensures the TC's epoch matches other certificates within the same SyncInfo, not that they match the current epoch. The runtime insertion path through `insert_2chain_timeout_certificate()` only validates round numbers, allowing cross-epoch TCs to persist in the block store if they have higher rounds.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L32-34)
```rust
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L62-64)
```rust
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L180-188)
```rust
    fn verify_tc(&self, tc: &TwoChainTimeoutCertificate) -> Result<(), Error> {
        let epoch_state = self.epoch_state()?;

        if !self.skip_sig_verify {
            tc.verify(&epoch_state.verifier)
                .map_err(|e| Error::InvalidTimeoutCertificate(e.to_string()))?;
        }
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L63-85)
```rust
    pub(crate) fn verify_proposal(
        &mut self,
        vote_proposal: &VoteProposal,
    ) -> Result<VoteData, Error> {
        let proposed_block = vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        self.verify_qc(proposed_block.quorum_cert())?;
        if !self.skip_sig_verify {
            proposed_block
                .validate_signature(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidProposal(error.to_string()))?;
        }
        proposed_block
            .verify_well_formed()
            .map_err(|error| Error::InvalidProposal(error.to_string()))?;

        vote_proposal
            .gen_vote_data()
            .map_err(|error| Error::InvalidAccumulatorExtension(error.to_string()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L294-303)
```rust
            Ordering::Less => {
                // start new epoch
                self.persistent_storage.set_safety_data(SafetyData::new(
                    epoch_state.epoch,
                    0,
                    0,
                    0,
                    None,
                    0,
                ))?;
```

**File:** consensus/consensus-types/src/sync_info.rs (L148-150)
```rust
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }
```

**File:** consensus/src/persistent_liveness_storage.rs (L414-417)
```rust
            highest_2chain_timeout_certificate: match highest_2chain_timeout_cert {
                Some(tc) if tc.epoch() == epoch => Some(tc),
                _ => None,
            },
```

**File:** consensus/src/block_storage/block_store.rs (L564-569)
```rust
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L155-160)
```rust
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L185-188)
```rust
    /// The epoch of the timeout.
    pub fn epoch(&self) -> u64 {
        self.timeout.epoch()
    }
```
