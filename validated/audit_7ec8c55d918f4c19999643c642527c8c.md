# Audit Report

## Title
Missing Authorization in Consensus Observer Publisher Subscription Handler

## Summary
The `process_network_message()` function in `ConsensusPublisher` accepts subscription requests from any authenticated network peer without authorization checks. This allows untrusted peers on public networks to subscribe and receive sensitive pre-commitment consensus data, potentially enabling MEV attacks through advanced knowledge of transaction ordering and block contents.

## Finding Description

The consensus observer publisher system broadcasts consensus updates to subscribed observers. However, the subscription handler lacks authorization controls, creating an information disclosure vulnerability.

**Vulnerability Location**: The `process_network_message()` function directly adds any requesting peer to active subscribers without validation: [1](#0-0) 

When a `ConsensusObserverRequest::Subscribe` message is received, the function performs no checks to verify peer roles, allowlists, or authorization. It simply calls `add_active_subscriber(peer_network_id)` and sends an acknowledgment.

**Sensitive Data Exposure**: Once subscribed, peers receive all consensus updates via `publish_message()`, which broadcasts to all active subscribers: [2](#0-1) 

The published messages contain highly sensitive information:

- **OrderedBlock**: Contains `PipelinedBlock` structures with validator signatures [3](#0-2) 

- **CommitDecision**: Contains commit proofs with quorum signatures [4](#0-3) 

- **BlockPayload**: Contains actual `SignedTransaction` data and `ProofOfStore` before public commitment [5](#0-4) 

- **OrderedBlockWithWindow**: Contains block dependencies and execution pool information [6](#0-5) 

**Attack Vector**: The publisher is registered on ALL configured networks for a node: [7](#0-6) 

For Validator Full Nodes (VFNs), this includes the **Public network** where any public client can connect. The network README confirms: [8](#0-7) 

**Default Configuration**: Publishers are enabled by default on VFNs: [9](#0-8) [10](#0-9) 

**Exploit Scenario**:
1. Malicious actor runs a Public Full Node (PFN) with `observer_enabled: true` manually configured
2. PFN connects to a VFN on the Public network (VFNs accept public connections)
3. PFN sends a `Subscribe` RPC request to the VFN's publisher
4. VFN accepts without authorization checks and begins streaming consensus data
5. Attacker receives pre-commitment block contents, transaction ordering, and validator voting patterns

## Impact Explanation

**Medium Severity** - This vulnerability enables unauthorized information disclosure of pre-commitment consensus data, aligning with the Aptos Bug Bounty Medium severity category (up to $10,000).

**Impacts:**
- Information leakage of transaction ordering before public commitment enables front-running and sandwich attacks
- Unauthorized monitoring of validator voting patterns reveals consensus dynamics
- Advanced knowledge of block contents facilitates MEV (Maximal Extractable Value) extraction
- Violates principle of least privilege - untrusted peers receive data without authorization

**Why Not Higher Severity:**
- Does not directly cause loss of funds or theft
- Does not violate consensus safety (blocks remain cryptographically valid)
- Does not cause network partition or liveness failures
- Requires attacker to manually enable ConsensusObserver protocol (not enabled by default on PFNs)

This represents a significant protocol violation where access control assumptions are not enforced, creating information asymmetry that can be exploited for economic gain.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly exploitable because:

1. **Low Barrier to Entry**: Any actor can run a PFN and modify its configuration
2. **Simple Exploit**: Requires only enabling the protocol and sending a Subscribe RPC request
3. **No Defense in Depth**: Zero authorization checks or compensating controls
4. **Production Deployment**: Publishers enabled by default on all VFNs in production
5. **Network Topology**: VFNs explicitly accept connections from untrusted public clients

**Attack Prerequisites:**
- Run a PFN with `consensus_observer.observer_enabled: true` in configuration
- Connect to any VFN on the Public network (VFNs publicly accessible)
- Support ConsensusObserver protocols (ProtocolId::ConsensusObserver and ProtocolId::ConsensusObserverRpc)
- Send Subscribe RPC request

The only check performed is protocol support verification [11](#0-10)  which an attacker can trivially satisfy by enabling the protocols.

## Recommendation

Implement role-based authorization in the subscription handler:

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    match message {
        ConsensusObserverRequest::Subscribe => {
            // ADD AUTHORIZATION CHECK HERE
            if !self.is_peer_authorized_to_subscribe(&peer_network_id) {
                warn!("Unauthorized subscription attempt from peer: {:?}", peer_network_id);
                response_sender.send(ConsensusObserverResponse::UnauthorizedError);
                return;
            }
            
            self.add_active_subscriber(peer_network_id);
            // ... rest of handler
        },
        // ... other cases
    }
}

fn is_peer_authorized_to_subscribe(&self, peer: &PeerNetworkId) -> bool {
    // Check peer role, network ID, and authorization policy
    // For Public network: reject all subscriptions
    // For Vfn network: allow only validator connections
    // For Validator network: allow validator set members only
    match peer.network_id() {
        NetworkId::Public => false, // Never allow public subscribers
        NetworkId::Vfn => self.is_trusted_vfn_peer(peer),
        NetworkId::Validator => self.is_validator_peer(peer),
    }
}
```

Additionally, consider:
1. Disabling publisher on Public network entirely for VFNs
2. Implementing allowlist-based subscription control
3. Adding configuration option to restrict publisher to specific networks
4. Logging and monitoring subscription attempts for security analysis

## Proof of Concept

```rust
// Conceptual PoC demonstrating the vulnerability
// An attacker-controlled PFN can subscribe to a VFN publisher

use aptos_config::config::{ConsensusObserverConfig, NodeConfig, NetworkConfig};
use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_consensus::consensus_observer::network::observer_message::{
    ConsensusObserverRequest, ConsensusObserverMessage
};

#[test]
fn test_unauthorized_subscription_from_public_network() {
    // Setup: Create a VFN with publisher enabled (default config)
    let mut vfn_config = NodeConfig::default();
    vfn_config.consensus_observer.publisher_enabled = true;
    
    // Setup: Attacker PFN on Public network
    let attacker_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Attack: Send Subscribe request from Public network peer
    let subscribe_request = ConsensusObserverRequest::Subscribe;
    
    // Vulnerability: No authorization check prevents this subscription
    // The VFN publisher will accept and start streaming consensus data
    // Expected: Should reject Public network subscriptions
    // Actual: Accepts all authenticated peers regardless of network/role
    
    assert!(/* Subscription succeeds when it should fail */);
}
```

The vulnerability is exploitable in production: any actor running a modified PFN with ConsensusObserver protocols enabled can subscribe to VFN publishers and receive pre-commitment consensus data.

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L167-208)
```rust
    /// Processes a network message received by the consensus publisher
    fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
        // Unpack the network message
        let (peer_network_id, message, response_sender) = network_message.into_parts();

        // Update the RPC request counter
        metrics::increment_counter(
            &metrics::PUBLISHER_RECEIVED_REQUESTS,
            message.get_label(),
            &peer_network_id,
        );

        // Handle the message
        match message {
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
            ConsensusObserverRequest::Unsubscribe => {
                // Remove the peer from the set of active subscribers
                self.remove_active_subscriber(&peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Peer unsubscribed from consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple unsubscription ACK
                response_sender.send(ConsensusObserverResponse::UnsubscribeAck);
            },
        }
    }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L210-232)
```rust
    /// Publishes a direct send message to all active subscribers. Note: this method
    /// is non-blocking (to avoid blocking callers during publishing, e.g., consensus).
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-184)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L281-286)
```rust
/// the window information (e.g., dependencies for execution pool).
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlockWithWindow {
    ordered_block: OrderedBlock,
    execution_pool_window: ExecutionPoolWindow,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L335-339)
```rust
/// CommitDecision message contains the commit decision proof
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct CommitDecision {
    commit_proof: LedgerInfoWithSignatures,
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L839-843)
```rust
/// Payload message contains the block and transaction payload
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct BlockPayload {
    block: BlockInfo,
    transaction_payload: BlockTransactionPayload,
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** network/README.md (L36-39)
```markdown
In contrast, Validator Full Node (VFNs) servers will only prioritize connections
from more trusted peers in the on-chain discovery set; they will still service
any public clients. Public Full Nodes (PFNs) connecting to VFNs will always
authenticate the VFN server using the available discovery information.
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L352-356)
```rust
/// Returns true iff the peer metadata indicates support for consensus observer
fn supports_consensus_observer(peer_metadata: &PeerMetadata) -> bool {
    peer_metadata.supports_protocol(ProtocolId::ConsensusObserver)
        && peer_metadata.supports_protocol(ProtocolId::ConsensusObserverRpc)
}
```
