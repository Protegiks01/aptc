# Audit Report

## Title
Keyless ZKP Validation Performs Expensive Cryptographic Operations Before Gas Limit Checks

## Summary

The keyless transaction validation process performs computationally expensive zero-knowledge proof (ZKP) verification operations—including elliptic curve point deserialization with subgroup membership checks and Groth16 pairing verification—before validating that the transaction has sufficient gas. This allows attackers to submit keyless transactions with minimal gas that consume significant validator CPU resources before being rejected, enabling a resource exhaustion attack against validator nodes.

## Finding Description

The vulnerability exists in the transaction validation flow where keyless authenticator verification happens before gas limit validation. 

**Validation Flow in VMValidator Path:**

In the mempool validation path, transactions enter through `validate_and_add_transactions` which calls the validator: [1](#0-0) 

This invokes `VMValidator::validate_transaction` which calls `validate_signed_transaction` without first checking gas: [2](#0-1) 

Within `validate_signed_transaction`, keyless authenticators are extracted and validated WITHOUT checking gas limits first: [3](#0-2) 

The `validate_authenticators` function performs expensive cryptographic operations without any gas meter parameter: [4](#0-3) 

**Expensive Cryptographic Operations:**

The verification process calls `verify_groth16_proof` which deserializes elliptic curve points and performs pairing verification: [5](#0-4) 

G1 and G2 point deserialization operations invoke `deserialize_compressed` which performs expensive elliptic curve arithmetic with subgroup membership checks: [6](#0-5) [7](#0-6) 

**Gas Check Happens After:**

Only AFTER `validate_signed_transaction` completes does `run_prologue_with_payload` get called: [8](#0-7) 

`run_prologue_with_payload` finally calls `check_gas`: [9](#0-8) 

The `check_gas` function validates that the transaction has sufficient gas, including a KEYLESS_BASE_COST of 32,000,000 internal gas units: [10](#0-9) 

The KEYLESS_BASE_COST constant is defined as: [11](#0-10) 

**Attack Scenario:**

An attacker can submit keyless transactions with `max_gas_amount` set to 1 (far below the KEYLESS_BASE_COST of 32,000,000). Each transaction will:
1. Pass BCS deserialization
2. Enter validation via `VMValidator::validate_transaction`
3. Trigger expensive G1/G2 elliptic curve point deserialization with subgroup checks
4. Perform Groth16 pairing verification
5. Finally be rejected for insufficient gas in `check_gas`

The attacker pays minimal or no fees while consuming disproportionate validator CPU resources.

## Impact Explanation

**Severity: High (Validator Node Slowdowns)**

This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty framework category: "Validator Node Slowdowns: Significant performance degradation affecting consensus, DoS through resource exhaustion."

- **Validator CPU Exhaustion**: Each malformed keyless transaction forces validators to perform expensive BN254 elliptic curve operations before rejecting the transaction for insufficient gas.

- **Network Throughput Degradation**: An attacker flooding the network can significantly slow down transaction processing and block production.

- **Low Attack Cost**: The attacker pays minimal fees (or none if rejected before prologue) while consuming significant computational resources.

This is a protocol-level gas metering ordering bug, distinct from network-layer DoS attacks. The system performs expensive cryptographic operations without first validating that the transaction has sufficient gas to cover them, violating the principle that resource-intensive validation should occur after basic sanity checks like gas limits.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited:

1. **No Special Privileges Required**: Any user can submit keyless transactions through the public API.

2. **Easy to Execute**: The attack requires only valid BCS-encoded transaction structures with keyless authenticators and minimal `max_gas_amount` values.

3. **Low Cost for Attacker**: Transactions are rejected before gas payment or the attacker pays minimal fees while consuming disproportionate resources.

4. **Immediate Impact**: Each transaction immediately triggers expensive cryptographic operations on validators.

5. **Scalability**: The attacker can automate submission of thousands of malicious transactions.

## Recommendation

Reorder the validation logic to check gas limits before performing expensive cryptographic operations. Specifically:

1. Move the `check_gas` call earlier in the validation pipeline, before `validate_authenticators` is invoked.

2. Add an early gas check in `VMValidator::validate_transaction` before calling `validate_signed_transaction`.

3. Alternatively, pass a gas meter to `validate_authenticators` and charge for cryptographic operations incrementally, rejecting the transaction immediately if gas is exhausted.

The fix should ensure that transactions with insufficient gas are rejected before any expensive elliptic curve or ZKP operations are performed.

## Proof of Concept

A complete PoC would involve:

1. Creating a keyless transaction with valid BCS structure and ephemeral signature
2. Setting `max_gas_amount` to 1 (well below KEYLESS_BASE_COST of 32,000,000)
3. Submitting to a validator node via REST API
4. Observing that the transaction triggers expensive crypto operations before being rejected for insufficient gas
5. Measuring validator CPU consumption per malicious transaction
6. Demonstrating throughput degradation under sustained attack

The execution path traced through the codebase confirms this vulnerability exists and can be triggered through normal transaction submission APIs.

---

**Notes:**

This is a protocol-level bug in the validation ordering logic, not a network-layer DoS attack. The Aptos Bug Bounty framework explicitly includes "Validator Node Slowdowns" through "DoS through resource exhaustion" as High Severity, with the example "Gas calculation bug causes validator slowdowns" - which precisely describes this issue. The expensive cryptographic operations (G1/G2 point deserialization with subgroup checks and Groth16 pairing verification) occur before the system validates whether the transaction has sufficient gas to pay for them, creating an asymmetric resource consumption attack vector.

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L494-494)
```rust
                let result = smp.validator.read().validate_transaction(t.0.clone());
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1810)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1939-1949)
```rust
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3282-3290)
```rust
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L261-269)
```rust
        verify_keyless_signature_without_ephemeral_signature_check(
            pk,
            sig,
            &jwk,
            onchain_timestamp_obj.microseconds,
            &training_wheels_pk,
            config,
            pvk,
        )?;
```

**File:** types/src/keyless/groth16_sig.rs (L215-235)
```rust
    pub fn verify_proof(
        &self,
        public_inputs_hash: Fr,
        pvk: &PreparedVerifyingKey<Bn254>,
    ) -> anyhow::Result<()> {
        // let start = std::time::Instant::now();
        let proof: Proof<Bn254> = Proof {
            a: self.a.deserialize_into_affine()?,
            b: self.b.deserialize_into_affine()?,
            c: self.c.deserialize_into_affine()?,
        };
        // println!("Deserialization time: {:?}", start.elapsed());

        // let start = std::time::Instant::now();
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
        Ok(())
    }
```

**File:** types/src/keyless/bn254_circom.rs (L136-150)
```rust
impl TryInto<G1Projective> for &G1Bytes {
    type Error = CryptoMaterialError;

    fn try_into(self) -> Result<G1Projective, CryptoMaterialError> {
        G1Projective::deserialize_compressed(self.0.as_slice())
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}

impl TryInto<G1Affine> for &G1Bytes {
    type Error = CryptoMaterialError;

    fn try_into(self) -> Result<G1Affine, CryptoMaterialError> {
        let g1_projective: G1Projective = self.try_into()?;
        Ok(g1_projective.into())
```

**File:** types/src/keyless/bn254_circom.rs (L233-248)
```rust
impl TryInto<G2Projective> for &G2Bytes {
    type Error = CryptoMaterialError;

    fn try_into(self) -> Result<G2Projective, CryptoMaterialError> {
        G2Projective::deserialize_compressed(self.0.as_slice())
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}

impl TryInto<G2Affine> for &G2Bytes {
    type Error = CryptoMaterialError;

    fn try_into(self) -> Result<G2Affine, CryptoMaterialError> {
        let g2_projective: G2Projective = self.try_into()?;
        Ok(g2_projective.into())
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L144-159)
```rust
    let keyless = if txn_metadata.is_keyless() {
        KEYLESS_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let slh_dsa_sha2_128s = if txn_metadata.is_slh_dsa_sha2_128s() {
        SLH_DSA_SHA2_128S_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L261-264)
```rust
            keyless_base_cost: InternalGas,
            { RELEASE_V1_12.. => "keyless.base" },
            32_000_000,
        ],
```
