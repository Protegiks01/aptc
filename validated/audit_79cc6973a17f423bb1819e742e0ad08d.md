# Audit Report

## Title
Incomplete Complexity Metering for Variant Instantiation Tables in VERSION_7+ Modules

## Summary
The complexity checker fails to meter `struct_variant_instantiations` and `variant_field_instantiations` tables at the module level, allowing VERSION_7+ modules to include arbitrarily large, unused variant instantiation tables that bypass complexity limits.

## Finding Description
The Move binary format VERSION_7 introduced variant-related features (enums), adding four new tables to `CompiledModule`, including `struct_variant_instantiations` and `variant_field_instantiations`. [1](#0-0) 

The complexity checker in `check_module_complexity()` explicitly meters standard instantiation tables (`struct_def_instantiations`, `field_instantiations`, and `function_instantiations`) but completely omits the variant versions. [2](#0-1) 

While helper functions `meter_struct_variant_instantiation()` and `meter_variant_field_instantiation()` exist in the codebase [3](#0-2) [4](#0-3) , they are **never called** from `check_module_complexity()`. Unlike the metered instantiation types which have corresponding loop functions (e.g., `meter_struct_def_instantiations()`, `meter_field_instantiations()`), no such loop functions exist for variant instantiation tables.

These individual metering functions are only invoked from `meter_code()` when specific variant bytecode instructions are encountered during function body analysis. [5](#0-4) 

**Attack Scenario:**
1. Attacker creates a VERSION_7+ module (VERSION_7 is supported; current VERSION_MAX is VERSION_10) [6](#0-5) 
2. Populates `struct_variant_instantiations` and `variant_field_instantiations` with hundreds of entries containing complex type signatures
3. Never references these instantiations in bytecode or struct definitions
4. The bounds checker validates all entries are well-formed [7](#0-6) 
5. Module publishing calls `check_module_complexity()` with budget `2048 + blob.code().len() * 20` [8](#0-7) 
6. But `check_module_complexity()` never meters the variant instantiation tables, allowing complexity budget bypass
7. Module consumes resources during deserialization, bounds checking, and VM operations without corresponding complexity charges

## Impact Explanation
This is a **Medium severity** vulnerability aligning with "Limited Protocol Violations" category (up to $10,000 per Aptos bug bounty):

**Resource Limits Violation:** The complexity checker exists to enforce computational limits on module complexity. This gap allows modules to exceed intended complexity budgets by including unmeasured variant instantiation tables containing arbitrarily complex type signatures.

**Limited but Real Impact:**
- Unused instantiation tables consume CPU cycles during module deserialization and bounds checking
- They occupy storage in the module binary and blockchain state
- The blob size-based budget (20 units per byte) provides partial protection, but complex type signatures in compact encodings can have a much higher processing cost per byte than this ratio accounts for
- This violates the fundamental resource limits invariant that all operations must respect computational limits

**Not Critical because:**
- All validators process modules identically (no consensus split or safety violation)
- The blob size budget provides some proportional scaling
- Bounds checking prevents malformed entries that could cause crashes
- Attack requires module publishing permissions and associated gas costs

## Likelihood Explanation
**Likelihood: Medium to High**

**Ease of Exploitation:**
- Any user with module publishing access can create such modules through standard transaction submission
- No special permissions, validator collusion, or infrastructure access required
- The bug is straightforward to exploit once discovered - simply populate the unused tables with complex instantiations
- VERSION_7+ modules are widely supported in production (current VERSION_MAX is VERSION_10)
- The gap is a simple omission in the metering logic, not a complex timing or race condition

**Mitigating Factors:**
- Requires understanding of Move binary format internals to craft effective exploits
- Module publishing has inherent gas costs that provide economic disincentive for spam
- The blob size-based budget component provides partial protection by scaling with module size
- Bounds checking prevents truly malicious or malformed entries

## Recommendation
Add two new functions to meter all entries in the variant instantiation tables, mirroring the existing pattern for other instantiation types:

```rust
fn meter_struct_variant_instantiations(&self) -> PartialVMResult<()> {
    let struct_variant_insts = self.resolver.struct_variant_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get struct variant instantiations -- not a module.".to_string())
    })?;

    for idx in 0..struct_variant_insts.len() {
        self.meter_struct_variant_instantiation(StructVariantInstantiationIndex(idx as u16))?;
    }
    Ok(())
}

fn meter_variant_field_instantiations(&self) -> PartialVMResult<()> {
    let variant_field_insts = self.resolver.variant_field_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get variant field instantiations -- not a module.".to_string())
    })?;

    for idx in 0..variant_field_insts.len() {
        self.meter_variant_field_instantiation(VariantFieldInstantiationIndex(idx as u16))?;
    }
    Ok(())
}
```

Then call these functions in `check_module_complexity()`:

```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;
    meter.meter_struct_variant_instantiations()?;  // ADD THIS
    meter.meter_variant_field_instantiations()?;   // ADD THIS

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

## Proof of Concept
A complete PoC would require:

1. Creating a VERSION_7+ Move module with the Move compiler
2. Manually modifying the compiled bytecode to inject large `struct_variant_instantiations` and `variant_field_instantiations` tables
3. Ensuring these instantiations reference valid signature indices with complex nested type parameters
4. Publishing the module and observing it passes complexity checking despite containing unmeasured complexity

The core verification can be performed by code inspection: examining `check_module_complexity()` in `check_complexity.rs` shows it definitively does not call any functions to meter the variant instantiation tables, while confirming these tables exist in `CompiledModule` and are processed by bounds checking but not complexity metering.

### Citations

**File:** third_party/move/move-binary-format/src/file_format.rs (L3474-3478)
```rust
    /// Since bytecode version 7: variant related handle tables
    pub struct_variant_handles: Vec<StructVariantHandle>,
    pub struct_variant_instantiations: Vec<StructVariantInstantiation>,
    pub variant_field_handles: Vec<VariantFieldHandle>,
    pub variant_field_instantiations: Vec<VariantFieldInstantiation>,
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L139-153)
```rust
    fn meter_struct_variant_instantiation(
        &self,
        struct_inst_idx: StructVariantInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_variant_insts =
            self.resolver
                .struct_variant_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get enum type instantiation -- not a module.".to_string(),
                    )
                })?;
        let struct_variant_inst = safe_get_table(struct_variant_insts, struct_inst_idx.0)?;
        self.meter_signature(struct_variant_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L180-195)
```rust
    fn meter_variant_field_instantiation(
        &self,
        variant_field_inst_idx: VariantFieldInstantiationIndex,
    ) -> PartialVMResult<()> {
        let variant_field_insts =
            self.resolver
                .variant_field_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get variant field instantiations -- not a module.".to_string(),
                    )
                })?;
        let field_inst = safe_get_table(variant_field_insts, variant_field_inst_idx.0)?;

        self.meter_signature(field_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L272-287)
```rust
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L543-565)
```rust
/// Version 7: changes compare to version 6
/// + access specifiers (read/write set)
/// + enum types
pub const VERSION_7: u32 = 7;

/// Version 8: changes compared to version 7
/// + closure instructions
pub const VERSION_8: u32 = 8;

/// Version 9: changes compared to version 8
/// + signed integers
/// + allow `$` in identifiers
pub const VERSION_9: u32 = 9;

/// Version 10: changes compared to version 9
/// + abort with message instruction
pub const VERSION_10: u32 = 10;

/// Mark which oldest version is supported.
pub const VERSION_MIN: u32 = VERSION_5;

/// Mark which version is the latest version.
pub const VERSION_MAX: u32 = VERSION_10;
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L107-114)
```rust
        self.check_table(
            self.view.variant_field_instantiations(),
            Self::check_variant_field_instantiation,
        )?;
        self.check_table(
            self.view.struct_variant_instantiations(),
            Self::check_struct_variant_instantiation,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1558)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```
