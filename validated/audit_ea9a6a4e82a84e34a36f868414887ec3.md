# Audit Report

## Title
Missing Randomness Array Length Validation Enables Validator DoS in Chunky PVSS Decryption

## Summary
The `verify()` function in the chunky PVSS weighted transcript implementation fails to validate that the randomness array (`Rs`) has the correct length (`max_weight`). This allows a byzantine validator to create a malformed transcript that passes verification but causes other validators to crash during decryption or aggregation, violating liveness guarantees.

## Finding Description

The chunky PVSS implementation contains a critical missing validation in the `verify()` function. While it validates `Cs.len()` and `Vs.len()` against the total number of players, it completely omits validation for `Rs.len()`. [1](#0-0) 

The expected length for `Rs` is `sc.get_max_weight()`, as evidenced by the `generate()` function: [2](#0-1) 

And confirmed in the `encrypt_chunked_shares()` function: [3](#0-2) 

**Vulnerability Manifestation Path 1: Decryption Crash**

The vulnerability manifests in `Subtranscript::decrypt_own_share()` where ephemeral keys are constructed by taking the first `weight` elements from `Rs`: [4](#0-3) 

When a player has `weight > Rs.len()`, the resulting `ephemeral_keys` vector will only contain `Rs.len()` elements. The function then iterates `for i in 0..weight` and accesses `ephemeral_keys[i]`, causing an index out of bounds panic: [5](#0-4) 

**Vulnerability Manifestation Path 2: Aggregation Crash**

The vulnerability also manifests during transcript aggregation. When aggregating two subtranscripts with mismatched `Rs` lengths, the code accesses `other.Rs[j]` without bounds checking: [6](#0-5) 

Note that line 391 has a `debug_assert_eq!` which is compiled out in release builds, providing no protection in production.

**Attack Path:**

1. A byzantine validator creates a transcript with `Rs.len() < max_weight` during DKG dealing through `setup_deal_broadcast`: [7](#0-6) 

2. The transcript passes verification since `verify()` is called but never validates `Rs.len()`: [8](#0-7) 

3. The malformed transcript causes crashes during aggregation or when used in batch encryption setup through `FPTXWeighted::setup()`: [9](#0-8) 

4. Validators with `weight > Rs.len()` experience deterministic panics during decryption operations.

5. This also affects the real DKG implementation where `decrypt_own_share()` is called during secret share decryption: [10](#0-9) 

**Inconsistent Error Handling:**

Notably, there are two `decrypt_own_share()` implementations with inconsistent error handling. The `Subtranscript` version panics on out-of-bounds access (shown above), while the `Transcript` version uses `decrypt_chunked_scalars()` which silently truncates via `.zip()`: [11](#0-10) [12](#0-11) 

## Impact Explanation

**Severity: Medium**

This vulnerability causes deterministic validator crashes that affect network liveness. The impact manifests in two critical scenarios:

1. **Aggregation Phase**: When validators attempt to aggregate a malformed transcript with a valid one, they crash at the indexing operation in `aggregate_with()`
2. **Decryption Phase**: Validators with weight exceeding the malicious `Rs.len()` value panic during encrypted transaction setup or DKG secret share decryption

The impact aligns with **Medium Severity** criteria per Aptos bug bounty guidelines:
- ✅ Creates "state inconsistencies requiring manual intervention" as crashed validators need restart
- ✅ Causes "temporary liveness issues" affecting validators' ability to complete DKG or process encrypted transactions
- ❌ Does NOT cause fund loss, permanent network halt, or consensus safety violations
- ❌ Does NOT split consensus (all validators see the same malformed transcript)

This is not Critical severity because:
- Network can continue with remaining validators (assuming < 1/3 crash)
- Validators can be restarted to recover
- No permanent state corruption or fund theft occurs
- No double-spending or consensus safety violations
- Byzantine validator can only target specific weight ranges

## Likelihood Explanation

**Likelihood: Medium**

The attack requires a byzantine validator (assumed possible under < 1/3 Byzantine fault tolerance in the BFT threat model) to participate in DKG and broadcast a malformed transcript with `Rs.len() < max_weight`.

**Feasibility factors:**
- ✅ Attack execution is trivial: simply create transcript with shortened `Rs` array after calling `generate_transcript()`
- ✅ Verification will pass since the PoK and range proof validation operate on existing `Rs` entries without checking array length
- ✅ Crash is guaranteed and deterministic for affected validators
- ✅ No complex timing or state manipulation required
- ✅ Can be executed during normal DKG dealing phase

The straightforward nature of the attack once a byzantine validator exists, combined with the guaranteed impact on targeted validators, justifies Medium likelihood assessment.

## Recommendation

Add explicit validation for `Rs.len()` in the `verify()` function:

```rust
// In weighted_transcript.rs verify() function, add after line 153:
if self.subtrs.Rs.len() != sc.get_max_weight() {
    bail!(
        "Expected {} randomness arrays, but got {}",
        sc.get_max_weight(),
        self.subtrs.Rs.len()
    );
}
```

Additionally, strengthen the aggregation function by replacing the debug assertion with a runtime check:

```rust
// In weighted_transcript.rs aggregate_with() function, replace line 391:
ensure!(
    self.Rs.len() == other.Rs.len(),
    "Transcript Rs length mismatch during aggregation: {} != {}",
    self.Rs.len(),
    other.Rs.len()
);
```

## Proof of Concept

The vulnerability can be demonstrated by modifying a transcript after generation to have a truncated `Rs` array, then observing the crash during verification bypass and subsequent decryption. A byzantine validator would execute:

1. Call `DKG::generate_transcript()` to create a valid transcript
2. Deserialize the transcript and truncate the `subtrs.Rs` vector
3. Reserialize and broadcast the malformed transcript
4. Other validators' `verify()` calls will succeed (missing validation)
5. Validators with `weight > truncated_Rs.len()` will crash during `decrypt_own_share()` or aggregation

## Notes

This vulnerability represents a protocol-level validation flaw in the DKG implementation, not a network-level DoS attack. The missing length check allows malformed cryptographic material to bypass verification and propagate through the system, causing deterministic crashes in validators during critical consensus operations. The attack is feasible under the standard BFT threat model (< 1/3 Byzantine validators) and requires no special timing or coordination beyond participating in the DKG dealing phase.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L331-336)
```rust
        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L349-355)
```rust
        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L408-412)
```rust
        for j in 0..self.Rs.len() {
            for (R_jk, other_R_jk) in self.Rs[j].iter_mut().zip(&other.Rs[j]) {
                // Aggregate the R_{j,k}s
                *R_jk += other_R_jk;
            }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L592-599)
```rust
        let sk_shares: Vec<_> = decrypt_chunked_scalars(
            &Cs,
            &self.subtrs.Rs,
            &dk.dk,
            &pp.pp_elgamal,
            &pp.table,
            pp.ell,
        );
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L630-632)
```rust
                Rs: (0..sc.get_max_weight())
                    .map(|_| unsafe_random_points_group(num_chunks_per_share, rng))
                    .collect(),
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L662-673)
```rust
        let elgamal_randomness = Scalar::vecvec_from_inner(
            (0..sc.get_max_weight())
                .map(|_| {
                    chunked_elgamal::correlated_randomness(
                        rng,
                        1 << pp.ell as u64,
                        num_chunks_per_scalar::<E::ScalarField>(pp.ell),
                        &E::ScalarField::ZERO,
                    )
                })
                .collect(),
        );
```

**File:** dkg/src/dkg_manager/mod.rs (L332-339)
```rust
        let trx = DKG::generate_transcript(
            &mut rng,
            &public_params,
            &input_secret,
            self.my_index as u64,
            &self.dealer_sk,
            &self.dealer_pk,
        );
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L428-435)
```rust
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L262-268)
```rust
            shamir_share_evals: subtranscript
                .decrypt_own_share(
                    threshold_config,
                    &current_player,
                    msk_share_decryption_key,
                    pvss_public_params,
                )
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L327-333)
```rust
    for (row, Rs_row) in Cs_rows.iter().zip(Rs_rows.iter()) {
        // Compute C - d_k * R for each chunk
        let exp_chunks: Vec<C> = row
            .iter()
            .zip(Rs_row.iter())
            .map(|(C_ij, &R_j)| C_ij.sub(R_j * *dk))
            .collect();
```
