# Audit Report

## Title
PVSS Transcript Verification Accepts Trivial Transcripts with Identity Elements, Enabling Free-Riding in DKG

## Summary
A malicious validator can construct a PVSS transcript containing only identity elements (zero group elements) that passes all cryptographic verification checks in the weighted DAS protocol. This allows validators to participate in Distributed Key Generation (DKG) without contributing randomness, violating protocol security assumptions and enabling free-riding attacks that degrade randomness beacon quality.

## Finding Description

The PVSS transcript verification in the weighted DAS protocol accepts transcripts where all commitments (`V`, `V_hat`, `R`, `R_hat`, `C`) and the dealt public key are identity elements (zero group elements). This breaks the fundamental security guarantee that cryptographically verified transcripts contribute non-trivial secrets to the DKG protocol. [1](#0-0) 

**Why All Verification Checks Pass:**

**1. Schnorr Proof-of-Knowledge Verification:** When the dealt public key is the identity element (representing a discrete log of zero), an attacker can construct a valid PoK by setting `R = g^r, s = r` for random `r`. The batch verification computes a multi-exponentiation that evaluates to identity when the public key is identity: [2](#0-1) 

The verification equation `R^γ * pk^(e*γ) * g^(-s*γ)` evaluates to `g^(r*γ) * identity^(e*γ) * g^(-r*γ) = identity`, which passes the check at line 104. [3](#0-2) 

**2. Low-Degree Test:** When all `V` elements are identity, the multi-exponentiation with dual code word coefficients returns identity regardless of coefficient values: [4](#0-3) 

Since `multi_exp` of identity elements with any scalars yields identity, the check `zero == G1Projective::identity()` passes trivially. [5](#0-4) 

**3. Multi-Pairing Correctness Check:** All pairing computations involving identity elements evaluate to the identity in the target group `Gt`. Since `pairing(g, identity) = 1_Gt` and `pairing(identity, h) = 1_Gt`, the entire multi-pairing equation evaluates to `1_Gt`: [6](#0-5) 

**4. No Explicit Identity Check:** The verification logic performs no explicit checks to reject transcripts containing identity elements. The dealt public key retrieval shows no validation: [7](#0-6) 

**Attack Execution Path:**

1. Validator creates `Transcript` with all fields set to identity elements
2. Constructs valid Schnorr PoK: `(R = g^r, s = r)` for random `r`
3. Signs the identity commitment with legitimate BLS signing key
4. Submits transcript through DKG protocol
5. Transcript passes all verification checks in `verify()` method
6. When aggregated with honest transcripts, contributes zero (identity is additive neutral): [8](#0-7) 

The aggregation adds group elements, where `identity + G = G`, meaning the malicious transcript contributes no randomness.

## Impact Explanation

**Severity: MEDIUM** - Limited protocol violation per Aptos bug bounty criteria.

This vulnerability enables:

- **Cryptographic Protocol Violation:** Validators bypass the security guarantee that verified transcripts prove knowledge of and contribute non-trivial secrets. The verification accepts cryptographically meaningless commitments.

- **Randomness Quality Degradation:** If multiple validators exploit this (while staying below Byzantine threshold), the effective entropy of the randomness beacon decreases proportionally. With k malicious validators out of n, the randomness entropy reduces by k/n.

- **Free-Riding Attack:** Malicious validators appear to participate honestly in DKG while contributing zero computational work and zero randomness, potentially gaining rewards without fulfilling protocol obligations.

- **Liveness Risk:** If a threshold number of validators submit trivial transcripts, the aggregated randomness quality may fall below security requirements, though the protocol would not completely halt.

This violates the **Cryptographic Correctness** security invariant by accepting proofs that don't actually prove knowledge of any secret.

## Likelihood Explanation

**Likelihood: HIGH**

- **Single Actor:** Requires only one malicious validator (no collusion needed)
- **Trivial Construction:** Attacker simply fills all array fields with `G1Projective::identity()` and `G2Projective::identity()`
- **No Computational Barriers:** No expensive computations or timing requirements
- **Undetectable:** Indistinguishable from valid transcripts at verification time; only detectable after decryption reveals zero shares
- **No Prevention Mechanism:** No explicit checks exist to reject identity-element transcripts

The attack is practical and could be deployed by any validator wishing to reduce participation costs or degrade randomness generation quality.

## Recommendation

Add explicit non-identity checks to the `verify()` method before performing cryptographic verification:

```rust
// In weighted_protocol.rs verify() method, after line 288:
fn verify<A: Serialize + Clone>(
    &self,
    sc: &<Self as traits::Transcript>::SecretSharingConfig,
    pp: &Self::PublicParameters,
    spks: &[Self::SigningPubKey],
    eks: &[Self::EncryptPubKey],
    auxs: &[A],
) -> anyhow::Result<()> {
    self.check_sizes(sc)?;
    
    // CHECK: Reject transcripts with identity dealt public key
    let dealt_pk = self.get_dealt_public_key();
    if dealt_pk.0.is_identity().into() {
        bail!("Dealt public key cannot be identity element");
    }
    
    // CHECK: Reject transcripts with all-identity commitments
    if self.V.iter().all(|v| v.is_identity().into()) {
        bail!("All V commitments cannot be identity elements");
    }
    
    // Continue with existing verification...
}
```

Apply similar checks to other PVSS implementations (unweighted protocol, chunky variants).

## Proof of Concept

```rust
#[test]
fn test_identity_transcript_attack() {
    use aptos_dkg::pvss::{das::WeightedTranscript, traits::Transcript as _};
    use blstrs::{G1Projective, G2Projective};
    use group::Group;
    
    // Setup DKG parameters
    let sc = WeightedConfigBlstrs::new(/* ... */);
    let pp = das::PublicParameters::default();
    
    // Create malicious transcript with all identity elements
    let W = sc.get_total_weight();
    let mut malicious_trx = WeightedTranscript {
        soks: vec![/* valid signature on identity */],
        R: vec![G1Projective::identity(); W],
        R_hat: vec![G2Projective::identity(); W],
        V: vec![G1Projective::identity(); W + 1],
        V_hat: vec![G2Projective::identity(); W + 1],
        C: vec![G1Projective::identity(); W],
    };
    
    // Construct valid Schnorr PoK for identity commitment
    // R = g^r, s = r for random r
    
    // This SHOULD fail but currently PASSES verification
    let result = malicious_trx.verify(&sc, &pp, &spks, &eks, &auxs);
    
    // Expected: Err("identity elements rejected")
    // Actual: Ok(()) - verification passes!
    assert!(result.is_ok()); // This demonstrates the vulnerability
}
```

## Notes

This vulnerability exploits the mathematical property that identity elements satisfy all cryptographic verification equations trivially. While the verification performs sophisticated pairing checks and low-degree tests, none explicitly reject the degenerate case where all commitments are identity. The fix requires adding explicit identity checks before cryptographic verification, similar to how BLS signature validation rejects identity public keys.

### Citations

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L50-72)
```rust
pub struct Transcript {
    /// Proofs-of-knowledge (PoKs) for the dealt secret committed in $c = g_2^{p(0)}$.
    /// Since the transcript could have been aggregated from other transcripts with their own
    /// committed secrets in $c_i = g_2^{p_i(0)}$, this is a vector of PoKs for all these $c_i$'s
    /// such that $\prod_i c_i = c$.
    ///
    /// Also contains BLS signatures from each player $i$ on that player's contribution $c_i$, the
    /// player ID $i$ and auxiliary information `aux[i]` provided during dealing.
    soks: Vec<SoK<G1Projective>>,
    /// Commitment to encryption randomness $g_1^{r_j} \in G_1, \forall j \in [W]$
    R: Vec<G1Projective>,
    /// Same as $R$ except uses $g_2$.
    R_hat: Vec<G2Projective>,
    /// First $W$ elements are commitments to the evaluations of $p(X)$: $g_1^{p(\omega^i)}$,
    /// where $i \in [W]$. Last element is $g_1^{p(0)}$ (i.e., the dealt public key).
    V: Vec<G1Projective>,
    /// Same as $V$ except uses $g_2$.
    V_hat: Vec<G2Projective>,
    /// ElGamal encryption of the $j$th share of player $i$:
    /// i.e., $C[s_i+j-1] = h_1^{p(\omega^{s_i + j - 1})} ek_i^{r_j}, \forall i \in [n], j \in [w_i]$.
    /// We sometimes denote $C[s_i+j-1]$ by C_{i, j}.
    C: Vec<G1Projective>,
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L311-318)
```rust
        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L324-377)
```rust
        let alphas_betas_and_gammas = &extra[0..W * 3 + 1];
        let (alphas_and_betas, gammas) = alphas_betas_and_gammas.split_at(2 * W + 1);
        let (alphas, betas) = alphas_and_betas.split_at(W + 1);
        assert_eq!(alphas.len(), W + 1);
        assert_eq!(betas.len(), W);
        assert_eq!(gammas.len(), W);

        let lc_VR_hat = G2Projective::multi_exp_iter(
            self.V_hat.iter().chain(self.R_hat.iter()),
            alphas_and_betas.iter(),
        );
        let lc_VRC = G1Projective::multi_exp_iter(
            self.V.iter().chain(self.R.iter()).chain(self.C.iter()),
            alphas_betas_and_gammas.iter(),
        );
        let lc_V_hat = G2Projective::multi_exp_iter(self.V_hat.iter().take(W), gammas.iter());
        let mut lc_R_hat = Vec::with_capacity(n);

        for i in 0..n {
            let p = sc.get_player(i);
            let weight = sc.get_player_weight(&p);
            let s_i = sc.get_player_starting_index(&p);

            lc_R_hat.push(g2_multi_exp(
                &self.R_hat[s_i..s_i + weight],
                &gammas[s_i..s_i + weight],
            ));
        }

        let h = pp.get_encryption_public_params().message_base();
        let g_2_neg = g_2.neg();
        let eks = eks
            .iter()
            .map(Into::<G1Projective>::into)
            .collect::<Vec<G1Projective>>();
        // The vector of left-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L383-410)
```rust
    #[allow(non_snake_case)]
    fn aggregate_with(
        &mut self,
        sc: &WeightedConfig<ThresholdConfigBlstrs>,
        other: &Transcript,
    ) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        debug_assert!(self.check_sizes(sc).is_ok());
        debug_assert!(other.check_sizes(sc).is_ok());

        for i in 0..self.V.len() {
            self.V[i] += other.V[i];
            self.V_hat[i] += other.V_hat[i];
        }

        for i in 0..W {
            self.R[i] += other.R[i];
            self.R_hat[i] += other.R_hat[i];
            self.C[i] += other.C[i];
        }

        for sok in &other.soks {
            self.soks.push(sok.clone());
        }

        Ok(())
    }
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L69-109)
```rust
pub fn pok_batch_verify<'a, Gr>(
    poks: &Vec<(Gr, PoK<Gr>)>,
    g: &Gr,
    gamma: &Scalar,
) -> anyhow::Result<()>
where
    Gr: Serialize + Group + Mul<&'a Scalar> + HasMultiExp,
{
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);

    // Compute \gamma_i = \gamma^i, for all i \in [0, n]
    let mut gammas = Vec::with_capacity(n);
    gammas.push(Scalar::ONE);
    for _ in 0..(n - 1) {
        gammas.push(gammas.last().unwrap().mul(gamma));
    }

    let mut last_exp = Scalar::ZERO;
    for i in 0..n {
        let (pk, (R, s)) = poks[i];

        bases.push(R);
        exps.push(gammas[i]);

        bases.push(pk);
        exps.push(schnorr_hash(Challenge::<Gr> { R, pk, g: *g }) * gammas[i]);

        last_exp += s * gammas[i];
    }

    bases.push(*g);
    exps.push(last_exp.neg());

    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
        bail!("Schnorr PoK batch verification failed");
    }

    Ok(())
}
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L56-76)
```rust
    // First, the PoKs
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }

    let poks = soks
        .iter()
        .map(|(_, c, _, pok)| (*c, *pok))
        .collect::<Vec<(Gr, schnorr::PoK<Gr>)>>();

    // TODO(Performance): 128-bit exponents instead of powers of tau
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** crates/aptos-dkg/src/pvss/low_degree_test.rs (L141-161)
```rust
    pub fn low_degree_test_on_g1(self, evals: &Vec<G1Projective>) -> anyhow::Result<()> {
        if evals.len() != self.n {
            bail!("Expected {} evaluations; got {}", self.n, evals.len())
        }

        if self.t == self.n {
            return Ok(());
        }

        let v_times_f = self.dual_code_word();

        debug_assert_eq!(evals.len(), v_times_f.len());
        let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());

        (zero == G1Projective::identity())
            .then_some(())
            .context(format!(
                "the LDT G1 multiexp should return zero, but instead returned {}",
                zero
            ))
    }
```
