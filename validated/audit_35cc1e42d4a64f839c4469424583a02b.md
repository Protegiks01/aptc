# Audit Report

## Title
JWK Consensus State Inconsistency via Race Condition in Quorum Certificate Processing

## Summary
The `process_quorum_certified_update()` function in both issuer-level and per-key JWK consensus managers accepts quorum certified updates without verifying they match the validator's local proposal. Combined with a race condition during consensus state replacement, this allows validators to accept mismatched quorum certificates, causing off-chain consensus state inconsistencies.

## Finding Description

The vulnerability exists in the state transition logic of the JWK consensus managers. When a quorum certified update is received, the code transitions from `InProgress` to `Finished` state without verifying that the certified update's content matches the `my_proposal` that was originally initiated. [1](#0-0) 

The critical flaw is visible in the state transition where `my_proposal.clone()` and `issuer_level_repr` are stored together without validation that they match. The same vulnerability exists in the issuer-level manager: [2](#0-1) 

**Attack Scenario:**

1. A validator observes JWK update X for key K=(issuer, kid) and starts consensus, creating state `InProgress{my_proposal: X}`: [3](#0-2) 

2. The reliable broadcast task RB_X is spawned via `update_certifier.start_produce()`: [4](#0-3) 

3. The validator observes a different JWK update Y for the same key K, which can happen during OIDC provider key rotation.

4. The `maybe_start_consensus()` function checks if consensus is already running: [5](#0-4) 

5. Since `X.to_upsert != Y.to_upsert`, the check returns `false`, and new consensus starts for Y, replacing the old state via `insert()`.

6. When the old state is dropped, `QuorumCertProcessGuard` is dropped, triggering `abort()` on RB_X: [6](#0-5) 

7. **RACE CONDITION**: If RB_X's reliable broadcast has already completed the `.await` at line 68, the subsequent synchronous code (lines 69-78) will execute despite the abort, pushing QC(X) to the channel. The `Abortable` wrapper only interrupts at `.await` points.

8. The event loop receives QC(X) and processes it with the current state `InProgress{my_proposal: Y}`.

9. The code transitions to `Finished{my_proposal: Y, quorum_certified: QC(X)}` without validation.

10. A `ValidatorTransaction` is created with QC(X) and submitted to the pool.

The reliable broadcast aggregation logic only accepts signatures matching the local view: [7](#0-6) 

However, this doesn't prevent the race condition since each reliable broadcast instance runs independently.

## Impact Explanation

This vulnerability constitutes a **Medium Severity** issue under the "Limited Protocol Violations" category.

**Why Medium (not High/Critical):**

The impact is limited to the off-chain JWK consensus layer state inconsistency. While this breaks the JWK consensus protocol's safety guarantees, it does NOT constitute a Critical or High severity issue because:

1. **No fund theft capability**: Cannot directly steal APT or other tokens
2. **Main blockchain consensus unaffected**: AptosBFT consensus remains safe
3. **On-chain validation provides protection**: The version check prevents multiple conflicting updates from being applied: [8](#0-7) 

4. **Auxiliary system**: JWK consensus is for keyless accounts, not core blockchain functionality
5. **No network halt**: Does not cause loss of liveness or network availability

**Actual Impact:**

1. **Off-chain state inconsistency**: Validators' local JWK consensus states become mismatched with their submitted transactions
2. **Protocol confusion**: Validators may have incorrect beliefs about certified updates
3. **Manual intervention**: May require validator coordination to resolve state inconsistencies
4. **Potential liveness issues**: Could cause temporary issues in JWK update coordination

This fits the Medium severity category: "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable under realistic conditions:

1. **Natural trigger**: OIDC providers legitimately rotate keys, causing validators to observe different JWK states at different times when querying endpoints. Observation happens every 10 seconds.

2. **Non-negligible race window**: The race exists between reliable broadcast completion and abort signal taking effect. With asynchronous task scheduling, this window is realistic.

3. **Byzantine amplification**: Byzantine validators (< 1/3 of stake) can increase the probability by signing multiple conflicting observations quickly and providing different observations to different honest validators.

4. **No special privileges required**: Does not require compromising validator keys or insider access.

## Recommendation

Add explicit validation in `process_quorum_certified_update()` to verify the quorum certified update matches the local proposal:

```rust
pub fn process_quorum_certified_update(
    &mut self,
    issuer_level_repr: QuorumCertifiedUpdate,
) -> Result<()> {
    let key_level_update = KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
        .context("process_quorum_certified_update failed with repr err")?;
    let issuer = &key_level_update.issuer;
    let kid = &key_level_update.kid;
    
    let state = self
        .states_by_key
        .entry((issuer.clone(), kid.clone()))
        .or_default();
    
    match state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADD VALIDATION HERE
            ensure!(
                my_proposal.observed == key_level_update,
                "Quorum certified update does not match local proposal"
            );
            
            let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                issuer: issuer.clone(),
                kid: kid.clone(),
            };
            let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
            let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
            *state = ConsensusState::Finished {
                vtxn_guard,
                my_proposal: my_proposal.clone(),
                quorum_certified: issuer_level_repr,
            };
            Ok(())
        },
        _ => Err(anyhow!("qc update not expected ..."))
    }
}
```

Apply the same fix to the issuer-level manager in `jwk_manager/mod.rs`.

## Proof of Concept

A proof of concept would involve:
1. Running a validator with JWK observation enabled
2. Triggering two different JWK observations for the same key in quick succession
3. Demonstrating that the validator's state shows `my_proposal` with one update value while `quorum_certified` contains a different update value
4. Verifying the state inconsistency persists in the `Finished` state

The vulnerability can be reproduced by creating a unit test that:
- Initializes a `KeyLevelConsensusManager` 
- Processes observation X, initiating consensus
- Allows the reliable broadcast to complete
- Immediately processes observation Y, replacing the state
- Delivers the QC for X
- Asserts that the final state has mismatched `my_proposal` and `quorum_certified` fields

## Notes

This is a valid security vulnerability in the JWK consensus protocol implementation that requires fixing. However, the severity is **Medium** rather than High because the impact is limited to off-chain consensus layer state inconsistency, with on-chain validation providing protection against actual state divergence. The JWK consensus system is auxiliary to the main blockchain consensus, and while this bug violates protocol invariants, it does not enable fund theft, main consensus violations, or network halts that would qualify for higher severity ratings.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L185-189)
```rust
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L216-228)
```rust
        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L334-346)
```rust
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L332-343)
```rust
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-82)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        Ok(abort_handle)
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-130)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```
