# Audit Report

## Title
Sybil Attack on State Sync Peer Selection via Unauthenticated VFN Role Inference

## Summary
An attacker can exploit authentication and access control flaws in VFN network connections to bypass inbound connection limits and manipulate state sync peer selection. By establishing multiple unauthenticated connections that are auto-assigned the trusted `PeerRole::ValidatorFullNode` role, attackers can dominate peer selection and degrade validator synchronization performance.

## Finding Description

This vulnerability exists due to a chain of flawed assumptions in the network authentication and peer management system:

**1. VFN Networks Use Permissive Authentication Mode**

VFN networks default to `mutual_authentication = false`, which results in `MaybeMutual` authentication mode. [1](#0-0)  This configuration is then converted to `AuthenticationMode::MaybeMutual` during network builder initialization. [2](#0-1) 

**2. Automatic Role Assignment Without Verification**

In `MaybeMutual` mode, when unauthenticated peers connect to validators on VFN networks, they are automatically assigned `PeerRole::ValidatorFullNode` based solely on network context, without cryptographic verification or membership in the trusted peers set. [3](#0-2) 

**3. Connection Limit Bypass**

The inbound connection limiting logic only applies to peers with `PeerRole::Unknown`. The code explicitly treats all other roles as "trusted" and exempts them from connection limits. [4](#0-3)  Since auto-assigned `ValidatorFullNode` peers bypass this check, attackers can exceed the `MAX_INBOUND_CONNECTIONS` limit of 100. [5](#0-4) 

**4. Distance Metric Validation Accepts Auto-Assigned Roles**

When peers report `distance_from_validators = 1`, the validation checks if the peer's role is VFN by calling `peer_metadata.get_connection_metadata().role.is_vfn()`. [6](#0-5)  This check passes for auto-assigned roles, allowing unauthenticated peers to claim proximity to validators.

**5. Peer Selection Prioritizes by Distance**

The state sync peer selection algorithm groups peers by distance using a BTreeMap (sorted in ascending order) and selects from the lowest distance group first. [7](#0-6)  This gives distance=1 peers (including Sybil identities) priority over legitimate higher-distance peers.

**Attack Execution:**

1. Attacker generates multiple x25519 keypairs and establishes connections to validators on the VFN network
2. Each connection is auto-assigned `PeerRole::ValidatorFullNode` and bypasses connection limits
3. Attacker's peer monitoring service responds with `distance_from_validators = 1`
4. Validation passes due to the auto-assigned VFN role
5. All Sybil identities are grouped in the distance=1 tier and receive priority in peer selection
6. Attackers can provide slow/incomplete state sync responses to degrade synchronization performance

## Impact Explanation

**Severity: High**

This vulnerability qualifies as High severity under the Aptos bug bounty criteria because it enables **validator node slowdowns**, which is explicitly listed as High severity in the bug bounty program.

**Concrete Impacts:**

1. **Performance Degradation**: Malicious peers can provide slow or incomplete responses to state sync requests, significantly degrading validator synchronization performance and increasing time to achieve blockchain state consistency.

2. **Resource Exhaustion**: By bypassing connection limits, attackers can establish unlimited connections, consuming validator resources (memory, CPU, network bandwidth) beyond intended capacity.

3. **Protocol Manipulation**: The vulnerability breaks the fundamental security invariant that distance metrics should reflect actual network topology and trusted relationships. It allows arbitrary self-reported values from unauthenticated peers to influence critical protocol mechanisms.

4. **Eclipse Attack Vector**: If attackers dominate the peer pool, they can control what state data validators receive. While Merkle proof validation prevents invalid state injection, attackers can selectively withhold valid data and position themselves for more sophisticated attacks.

The impact does not reach Critical severity because consensus safety is not directly compromised and funds cannot be stolen. However, it significantly affects network operational security and validator performance.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Zero Prerequisites**: Any network participant can establish connections to validators on VFN networks without authentication, credentials, or special access.

2. **Trivial Execution**: The attack requires only standard networking capabilities (generating keypairs, establishing TCP connections, running a basic peer monitoring service).

3. **Default Configuration Vulnerable**: VFN networks use `MaybeMutual` mode by default, making all validators running standard configurations vulnerable without operator intervention.

4. **No Detection Mechanisms**: There is no validation that cross-references reported distance metrics with actual membership in the trusted peers set, and no anomaly detection for unusual connection patterns.

5. **Clear Economic Incentives**: Attackers can exploit this to slow down competing validators, extract MEV value during eclipse attacks, or disrupt network operations for strategic advantage.

6. **Low Cost, High Impact**: The attack requires minimal resources to execute but can significantly impact validator performance and network health.

## Recommendation

Implement multi-layered defenses to address the root causes:

**1. Enforce Mutual Authentication for VFN Networks**

Require `mutual_authentication = true` for VFN networks to prevent automatic role assignment to unauthenticated peers. This should be validated at the config sanitizer level similar to validator networks.

**2. Apply Connection Limits to All Untrusted Peers**

Modify the connection limiting logic to apply limits to any peer not explicitly in the trusted peers set, regardless of their assigned role:

```rust
// In peer_manager/mod.rs, modify the check:
if conn.metadata.origin == ConnectionOrigin::Inbound {
    // Apply limits to peers not in trusted set
    if !trusted_peers.contains_key(&conn.metadata.remote_peer_id) {
        // Count and limit untrusted inbound connections
        // ... existing logic ...
    }
}
```

**3. Validate Distance Claims Against Trusted Peer Set**

In the distance validation logic, verify that peers claiming `distance_from_validators = 1` are actually in the trusted peers set:

```rust
// In network_info.rs
1 => {
    let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
    let peer_in_trusted_set = trusted_peers.contains_key(&peer_id);
    let peer_has_correct_network = match self.base_config.role {
        RoleType::Validator => network_id.is_vfn_network(),
        RoleType::FullNode => network_id.is_public_network(),
    };
    peer_is_vfn && peer_in_trusted_set && peer_has_correct_network
},
```

**4. Implement Rate Limiting and Anomaly Detection**

Add IP-based rate limiting for connection attempts and implement anomaly detection for unusual patterns (e.g., many connections claiming distance=1 from different IPs).

## Proof of Concept

```rust
// Simplified PoC demonstrating the vulnerability
// This would be integrated into the Aptos test suite

#[test]
fn test_sybil_attack_via_vfn_role_inference() {
    // Setup: Create a validator with VFN network (default config)
    let validator_network_config = NetworkConfig::network_with_id(NetworkId::Vfn);
    assert_eq!(validator_network_config.mutual_authentication, false); // VFN uses MaybeMutual
    
    // Attack: Generate multiple attacker identities
    let attacker_identities: Vec<_> = (0..150) // Exceed MAX_INBOUND_CONNECTIONS
        .map(|_| x25519::PrivateKey::generate(&mut rng))
        .collect();
    
    // Each attacker connects and gets auto-assigned ValidatorFullNode role
    for identity in attacker_identities {
        let connection = establish_connection_to_validator(identity, NetworkId::Vfn);
        
        // Verify auto-assigned role (bypasses authentication)
        assert_eq!(connection.metadata.role, PeerRole::ValidatorFullNode);
        
        // Verify connection is NOT rejected despite exceeding limits
        assert!(connection.is_accepted());
        
        // Report distance=1 and verify it passes validation
        let distance_claim = NetworkInfoResponse { distance_from_validators: 1 };
        assert!(validate_distance(distance_claim, &connection.metadata).is_ok());
    }
    
    // Impact: Attacker dominates peer selection
    let selected_peers = choose_random_peers_by_distance_and_latency(
        all_peers,
        peers_and_metadata,
        num_peers_to_choose
    );
    
    // Most selected peers are attacker-controlled (distance=1 group prioritized)
    let attacker_ratio = selected_peers.iter()
        .filter(|peer| attacker_peer_ids.contains(peer))
        .count() as f64 / selected_peers.len() as f64;
    
    assert!(attacker_ratio > 0.8); // Attackers dominate selection
}
```

## Notes

**Additional Context:**

1. This vulnerability affects the default configuration of all validators running VFN networks. Operators would need to explicitly enable `mutual_authentication` for VFN networks to mitigate this issue.

2. The security assumption that "if role is not Unknown then it is trusted" (as stated in the code comment) is fundamentally broken when roles can be auto-assigned without authentication.

3. While state sync performs Merkle proof validation preventing invalid state injection, the performance impact of Sybil-dominated peer selection is still significant and meets the High severity threshold.

4. This is a protocol-level security vulnerability, not a simple network DoS attack. It exploits authentication and access control flaws rather than relying on resource flooding.

### Citations

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** config/src/config/network_config.rs (L136-136)
```rust
        let mutual_authentication = network_id.is_validator_network();
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/noise/handshake.rs (L407-410)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
```

**File:** network/framework/src/peer_manager/mod.rs (L353-389)
```rust
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L128-135)
```rust
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
```

**File:** state-sync/aptos-data-client/src/utils.rs (L31-48)
```rust
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
```
