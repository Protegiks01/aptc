# Audit Report

## Title
Race Condition in BlockSTMv1 Transaction Isolation Due to Relaxed Memory Ordering in Estimate Flag

## Summary
The BlockSTMv1 parallel execution engine uses `Ordering::Relaxed` for atomic operations on the estimate flag, creating a race condition where a validating transaction may not observe that a dependency has been marked as aborted. This can cause transactions to commit with data from aborted transactions, leading to consensus divergence between validators.

## Finding Description

In BlockSTMv1's multi-version concurrency control system, when a transaction aborts after validation failure, its writes are marked with an "estimate" flag to signal dependencies to other transactions. The vulnerability exists in the memory ordering semantics used to access this flag.

The estimate flag uses `Ordering::Relaxed` for both reads and writes: [1](#0-0) 

Relaxed memory ordering provides no synchronization guarantees between threads, allowing compiler and CPU reordering. This creates a race condition in the following scenario:

**Race Condition Flow:**

1. Transaction T1 (index i) executes and writes value V1 to key K
2. Transaction T2 (index j > i) executes and reads V1 from K
3. T1's validation fails, triggering abort sequence
4. **Thread A (abort handler)**: Acquires lock in `try_abort`, changes T1 status to `Aborting`, releases lock, then calls `mark_estimate()` which stores `FLAG_ESTIMATE` with Relaxed ordering [4](#0-3) [3](#0-2) 

5. **Thread B (validation)**: Concurrently validates T2, calls `is_estimate()` during read verification, loading the flag with Relaxed ordering [2](#0-1) 

6. Due to Relaxed memory ordering, Thread B may observe stale `FLAG_DONE` instead of `FLAG_ESTIMATE`
7. T2's validation incorrectly passes (should have returned `Dependency` error)
8. T1 re-executes and writes new value V2 to K
9. If T1 writes to same keys (not new keys), `needs_suffix_validation` remains false, so T2 is not re-validated [6](#0-5) 

10. T1 commits with V2, T2 commits with output based on V1 from aborted incarnation

**Critical Issue**: There is no synchronization between the abort thread marking estimates and the validation thread checking estimates. The scheduler's lock on transaction status is released before `mark_estimate()` is called, and validation does not acquire any lock related to the aborting transaction.

## Impact Explanation

This vulnerability represents a **Critical** severity consensus safety violation:

**Consensus Divergence**: Different validators executing the same block could observe different race timings:
- Validator A: Race doesn't occur → T2 validation fails → T2 re-executes → correct state
- Validator B: Race occurs → T2 validation passes → T2 commits with stale data → incorrect state

This produces different state roots for identical blocks, breaking the fundamental consensus guarantee that all honest validators produce identical results.

**Transaction Isolation Violation**: T2 commits with data from T1's aborted (uncommitted) incarnation, violating serializability guarantees that BlockSTM is designed to maintain.

**Determinism Broken**: The outcome depends on non-deterministic factors (thread scheduling, memory visibility timing, CPU architecture), making blockchain execution non-deterministic across validators.

This directly maps to the Aptos Bug Bounty Critical severity category: **"Consensus/Safety Violations - Different validators commit different blocks"** with potential for network partition requiring intervention.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can trigger during normal network operation under the following common conditions:

**Required Conditions** (all frequently occurring):
- Parallel execution with concurrency_level > 1 (default configuration)
- Transaction validation failures (common under high contention, conflicting writes, or re-execution scenarios)
- Concurrent validation of dependent transactions
- Race timing window between abort marking and validation checking

**Amplifying Factors**:
- **High Transaction Throughput**: More concurrent executions increase probability of validation failures and race timing collisions
- **Weakly-Ordered Architectures** (ARM-based validators): More susceptible to observable reordering with Relaxed atomics
- **Compiler Optimizations**: Can reorder Relaxed atomic operations even on strongly-ordered x86
- **Default Configuration**: BlockSTMv1 is the default execution mode [5](#0-4) 

The comment in the codebase suggesting BlockSTMv2 avoids estimate flags indicates the developers may have recognized limitations with this approach: [7](#0-6) 

## Recommendation

**Immediate Fix**: Upgrade atomic memory ordering from `Ordering::Relaxed` to `Ordering::Release` for `mark_estimate()` and `Ordering::Acquire` for `is_estimate()`:

```rust
pub(crate) fn is_estimate(&self) -> bool {
    self.flag.load(Ordering::Acquire) == FLAG_ESTIMATE  // Changed from Relaxed
}

pub(crate) fn mark_estimate(&self) {
    self.flag.store(FLAG_ESTIMATE, Ordering::Release);  // Changed from Relaxed
}
```

This establishes a happens-before relationship ensuring that when a validation thread observes `FLAG_ESTIMATE`, it also observes all writes that occurred before the estimate was marked.

**Long-term Solution**: Migrate to BlockSTMv2 which uses push-based validation with explicit dependency tracking instead of estimate flags, eliminating this race condition entirely. Enable via configuration:

```rust
blockstm_v2_enabled: true
```

## Proof of Concept

The vulnerability requires a Rust-level concurrent execution test demonstrating non-deterministic validation results. A simplified PoC structure:

```rust
// Pseudo-code demonstrating the race (actual PoC requires full BlockSTM harness)
#[test]
fn test_estimate_flag_race() {
    // Setup: Two transactions, T1 writes to K, T2 reads K
    // Thread 1: Execute T1, fail validation, call mark_estimate(K)
    // Thread 2: Concurrently validate T2, call is_estimate(K)
    // Assert: Due to Relaxed ordering, Thread 2 may not observe the estimate flag
    // Result: T2 validation passes when it should fail
    // Demonstrates consensus divergence potential
}
```

A complete proof of concept would require:
1. BlockSTM executor setup with MVHashMap
2. Controlled thread scheduling to trigger the race window
3. Verification that different executions produce different validation outcomes
4. Demonstration that this leads to different state commitments

## Notes

This vulnerability affects the default BlockSTMv1 configuration and represents a fundamental concurrency correctness issue in the parallel execution engine. The use of `Ordering::Relaxed` for synchronization between abort and validation threads violates memory model requirements for correct multi-threaded execution. While the race window may be small, under high load conditions with frequent validation failures, the probability of triggering becomes non-negligible, risking consensus failures in production.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L99-105)
```rust
    pub(crate) fn is_estimate(&self) -> bool {
        self.flag.load(Ordering::Relaxed) == FLAG_ESTIMATE
    }

    pub(crate) fn mark_estimate(&self) {
        self.flag.store(FLAG_ESTIMATE, Ordering::Relaxed);
    }
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L259-268)
```rust
            if entry.is_estimate() {
                debug_assert!(
                    maybe_reader_incarnation.is_none(),
                    "Entry must not be marked as estimate for BlockSTMv2"
                );
                // Found a dependency.
                return Err(Dependency(
                    idx.idx().expect("May not depend on storage version"),
                ));
            }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L322-326)
```rust
    if let Some(keys) = last_input_output.modified_resource_keys(txn_idx) {
        for (k, _) in keys {
            versioned_cache.data().mark_estimate(&k, txn_idx);
        }
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L654-656)
```rust
                if !prev_modified_resource_keys.remove(&k) {
                    needs_suffix_validation = true;
                }
```

**File:** aptos-move/block-executor/src/executor.rs (L827-831)
```rust
        let aborted = !valid && scheduler.try_abort(txn_idx, incarnation);

        if aborted {
            update_transaction_on_abort::<T, E>(txn_idx, last_input_output, versioned_cache);
            scheduler.finish_abort(txn_idx, incarnation)
```

**File:** config/src/config/execution_config.rs (L91-91)
```rust
            blockstm_v2_enabled: false,
```
