# Audit Report

## Title
Stale Verified Module Cache in None Path Leading to Consensus Divergence After Verifier Config Change

## Summary
When `AptosModuleCacheManager::try_lock` fails to acquire the global lock, it returns a `None` variant that creates a fresh environment with the updated verifier configuration but does not flush the global `VERIFIED_MODULES_CACHE`. This cache stores module hashes to skip re-verification. When verifier configuration changes via governance (e.g., enabling/disabling feature flags like `enable_enum_types`), validators taking different lock paths will produce different verification results for the same module, causing consensus divergence.

## Finding Description

The vulnerability exists in the asymmetric cache flushing behavior between two execution paths:

**Global Verified Module Cache:** [1](#0-0) 

This global static cache stores only module hashes, without including the verifier configuration as part of the cache key.

**Cache-Based Verification Skip:** [2](#0-1) 

Verification is entirely skipped if the module hash exists in the cache, regardless of whether the verifier configuration has changed.

**Guard Path (Lock Acquired) - Cache Flushed:** [3](#0-2) 

When the lock is successfully acquired, `check_ready` is called, which detects verifier config changes and flushes the cache: [4](#0-3) 

**None Path (Lock Failed) - Cache NOT Flushed:** [5](#0-4) 

The None path creates a fresh environment from state view (containing the new verifier config) but never calls `check_ready`, leaving the global cache with stale verification results.

**Verifier Configuration Changes:** [6](#0-5) 

The verifier configuration includes feature flags that change via governance: `enable_enum_types`, `enable_resource_access_control`, `enable_function_values`. These flags control critical verification rules: [7](#0-6) 

**Attack Scenario:**

1. **T0**: Feature flag `enable_enum_types` is enabled
2. **T1**: Module M containing enum types is published and verified, hash H added to cache
3. **T2**: Governance disables `enable_enum_types` (stricter verification)
4. **T3**: Block execution begins:
   - Validator A: Acquires lock, `check_ready()` flushes cache, re-verifies M with enums disabled → **FAILS** (feature not enabled)
   - Validator B: Lock fails, takes None path, cache NOT flushed, M uses cached verification → **PASSES** (cached from when enums were enabled)
5. **Result**: Different state roots → Consensus divergence

## Impact Explanation

**Critical Severity** - This is a consensus safety violation: [8](#0-7) 

All block executions use this manager. Different validators taking different lock paths after a verifier config change will produce different verification results for identical modules in identical blocks, violating the fundamental consensus invariant that all validators must produce identical state roots for identical blocks.

This enables:
- **Consensus Divergence**: Validators disagree on block validity
- **Security Bypass**: Modules violating new security constraints execute on some validators
- **Network Partition**: Sufficient disagreement could halt the network

## Likelihood Explanation

**Medium Likelihood:**

The None path can be triggered as demonstrated by the multi-threaded test: [9](#0-8) 

This test shows that when multiple threads compete for the lock, only one succeeds (returns 1) while others get None. While block execution has an outer `execution_lock`, the inner `try_lock()` can still fail during:
- Concurrent execution scenarios during testing/fuzzing
- Edge cases during block retries
- Race conditions during initialization

The alert indicates this is considered unexpected but explicitly handled: [10](#0-9) 

Verifier configuration changes via governance are legitimate operations that happen via feature flag updates, creating a window where this vulnerability is exploitable.

## Recommendation

Flush the verified module cache in the None path when creating a fresh environment:

```rust
None => {
    alert_or_println!("Locking module cache manager failed, fallback to empty caches");
    
    // Flush verified cache since we're creating a fresh environment
    if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
        RuntimeEnvironment::flush_verified_module_cache();
    }
    
    AptosModuleCacheManagerGuard::None {
        environment: storage_environment,
        module_cache: GlobalModuleCache::empty(),
    }
}
```

Alternatively, include the verifier configuration hash in the cache key: `(module_hash, verifier_config_hash)` instead of just `module_hash`.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Enabling a feature flag (e.g., `ENABLE_ENUM_TYPES`)
2. Publishing a module using that feature
3. Disabling the feature via governance
4. Executing a block where validators take different lock acquisition paths
5. Observing different verification results

The multi-threaded test at lines 635-674 of `code_cache_global_manager.rs` demonstrates that the None path can be reached, and the feature verification logic at lines 77-82 of `features.rs` shows how feature flag changes affect verification results.

## Notes

The report's specific example using `max_loop_depth` changing from 5 to 3 is incorrect - this value is hardcoded. However, the vulnerability is real and affects feature flags like `enable_enum_types`, `enable_resource_access_control`, and `enable_function_values` which DO change via governance and affect verification results. The core issue remains: asymmetric cache flushing between lock acquisition paths causes consensus-breaking verification inconsistencies.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L51-54)
```rust
lazy_static! {
    pub(crate) static ref VERIFIED_MODULES_CACHE: VerifiedModuleCache =
        VerifiedModuleCache::empty();
}
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-125)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L215-218)
```rust
        Ok(match self.inner.try_lock() {
            Some(mut guard) => {
                guard.check_ready(storage_environment, config, transaction_slice_metadata)?;
                AptosModuleCacheManagerGuard::Guard { guard }
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L220-229)
```rust
            None => {
                alert_or_println!("Locking module cache manager failed, fallback to empty caches");

                // If this is true, we failed to acquire a lock, and so default storage environment
                // and empty (thread-local) module caches will be used.
                AptosModuleCacheManagerGuard::None {
                    environment: storage_environment,
                    module_cache: GlobalModuleCache::empty(),
                }
            },
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L635-674)
```rust
    fn test_try_lock_inner_multiple_threads() {
        let manager = Arc::new(AptosModuleCacheManager::new());

        let state_view = Arc::new(MockStateView::empty());
        let config = Arc::new(BlockExecutorModuleCacheLocalConfig::default());
        let metadata = TransactionSliceMetadata::block_from_u64(0, 1);

        let counter = Arc::new(AtomicU64::new(0));
        let num_threads = 8;
        let mut handles = Vec::with_capacity(num_threads);

        for _ in 0..num_threads {
            let handle = std::thread::spawn({
                let manager = manager.clone();
                let state_view = state_view.clone();
                let config = config.clone();
                let counter = counter.clone();

                move || {
                    let guard = assert_ok!(manager.try_lock_inner(&state_view, &config, metadata));

                    // Wait for all threads to complete.
                    counter.fetch_add(1, Ordering::SeqCst);
                    loop {
                        if counter.load(Ordering::SeqCst) == num_threads as u64 {
                            break;
                        }
                    }
                    if matches!(guard, AptosModuleCacheManagerGuard::Guard { .. }) {
                        1
                    } else {
                        0
                    }
                }
            });
            handles.push(handle);
        }
        let sum = handles.into_iter().map(|h| h.join().unwrap()).sum::<i32>();
        assert_eq!(sum, 1);
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-182)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L77-82)
```rust
                        StructFieldInformation::DeclaredVariants(variants) => {
                            if !self.config.enable_enum_types {
                                return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                                    .at_index(IndexKind::StructDefinition, idx as u16)
                                    .with_message("enum type feature not enabled".to_string()));
                            }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L539-543)
```rust
        let mut module_cache_manager_guard = module_cache_manager.try_lock(
            &state_view,
            &config.local.module_cache_config,
            transaction_slice_metadata,
        )?;
```
