# Audit Report

## Title
Fee Payer Signature Count Bypass Enabling DoS Through Excessive Signature Verification

## Summary
The `TransactionAuthenticator::verify()` function fails to count the `fee_payer_signer`'s signatures when validating against the `MAX_NUM_OF_SIGS` limit of 32. This allows attackers to craft FeePayer transactions with up to 64 signatures, bypassing the intended resource limit and causing validator node slowdowns through excessive cryptographic operations.

## Finding Description

The vulnerability exists in the signature count validation logic of `TransactionAuthenticator::verify()`. The `MAX_NUM_OF_SIGS` constant is explicitly defined as "Maximum number of signatures supported in `TransactionAuthenticator`, across all `AccountAuthenticator`s included" with a value of 32. [1](#0-0) 

However, the signature counting implementation only sums the sender's signatures and secondary signers' signatures, explicitly excluding the fee payer signer: [2](#0-1) 

The `secondary_signers()` method for FeePayer transactions returns only the `secondary_signers` vector, explicitly excluding the `fee_payer_signer` field through the `..` pattern: [3](#0-2) 

Despite being excluded from the count, the `fee_payer_signer` is cryptographically verified during the FeePayer verification flow, where it is added to the `remaining` vector and verified: [4](#0-3) 

Each `MultiEd25519Signature` is individually limited to 32 signatures (MAX_NUM_OF_KEYS), enforced during deserialization: [5](#0-4) 

This creates a bypass where an attacker can construct a FeePayer transaction with:
- `sender`: MultiEd25519 authenticator with 32 signatures
- `secondary_signers`: empty vector
- `fee_payer_signer`: MultiEd25519 authenticator with 32 signatures

The signature count check calculates 32 signatures (from sender only), passing the validation. However, during verification, all 64 signatures are cryptographically verified.

The vulnerability is triggered during transaction validation when `check_signature()` is called, which invokes the vulnerable `verify()` method: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the "Validator Node Slowdowns" category in the Aptos bug bounty program.

**Protocol-Level Resource Limit Bypass**: The `MAX_NUM_OF_SIGS` constant exists as an explicit security boundary documented to apply "across all `AccountAuthenticator`s included." The implementation violates this documented security guarantee by not counting the fee payer signer's signatures.

**Validator Performance Degradation**: Signature verification occurs before gas charging during transaction validation. By bypassing the intended 32-signature limit, attackers force validators to perform double the intended cryptographic operations (64 vs 32 signatures) without proportional gas costs.

**DoS Through Resource Exhaustion**: An attacker can flood the mempool with such transactions, causing:
- Doubled CPU consumption on validator nodes for signature verification
- Reduced transaction throughput network-wide
- Delayed block production as validators spend excessive time on signature verification
- Potential mempool congestion with expensive-to-validate transactions

This is a protocol-level vulnerability that bypasses a fundamental resource constraint, not a network-level DoS attack. The impact directly affects validator operations and consensus performance.

## Likelihood Explanation

**Likelihood: High**

The attack has minimal barriers:
- **No Privileged Access**: Any user can submit FeePayer transactions
- **Low Complexity**: Constructing the malicious transaction requires only standard FeePayer transaction creation with MultiEd25519 authenticators containing 32 signatures each
- **No Economic Barriers**: Beyond normal transaction fees, no additional capital is required
- **Transaction Size Compliance**: The transaction size (approximately 6KB for 64 signatures and keys) is well within the 6MB transaction size limit
- **Deterministic**: The vulnerability triggers reliably every time such a transaction is submitted

The vulnerability is immediately exploitable upon discovery.

## Recommendation

Modify the signature count validation in `TransactionAuthenticator::verify()` to include all signers, including the fee payer signer. Replace the current implementation with:

```rust
pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
    let num_sigs: usize = self.all_signers()
        .iter()
        .map(|auth| auth.number_of_signatures())
        .sum::<usize>();
    if num_sigs > MAX_NUM_OF_SIGS {
        return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
    }
    // ... rest of verification logic
}
```

This ensures that the fee payer signer's signatures are counted towards the `MAX_NUM_OF_SIGS` limit, as intended by the documented security boundary.

## Proof of Concept

```rust
#[test]
fn test_fee_payer_signature_bypass() {
    use aptos_crypto::multi_ed25519::{MultiEd25519PrivateKey, MultiEd25519PublicKey};
    use aptos_crypto::PrivateKey;
    use aptos_types::transaction::{TransactionAuthenticator, AccountAuthenticator, RawTransaction};
    
    // Create sender with 32-signature MultiEd25519
    let sender_private_keys: Vec<_> = (0..32)
        .map(|_| Ed25519PrivateKey::generate_for_testing())
        .collect();
    let sender_multi_key = MultiEd25519PrivateKey::new(sender_private_keys, 32).unwrap();
    let sender_signature = sender_multi_key.sign(&raw_txn).unwrap();
    let sender_auth = AccountAuthenticator::multi_ed25519(
        sender_multi_key.public_key(),
        sender_signature,
    );
    
    // Create fee payer with 32-signature MultiEd25519
    let fee_payer_private_keys: Vec<_> = (0..32)
        .map(|_| Ed25519PrivateKey::generate_for_testing())
        .collect();
    let fee_payer_multi_key = MultiEd25519PrivateKey::new(fee_payer_private_keys, 32).unwrap();
    let fee_payer_signature = fee_payer_multi_key.sign(&raw_txn).unwrap();
    let fee_payer_auth = AccountAuthenticator::multi_ed25519(
        fee_payer_multi_key.public_key(),
        fee_payer_signature,
    );
    
    // Create FeePayer authenticator with empty secondary signers
    let authenticator = TransactionAuthenticator::fee_payer(
        sender_auth,
        vec![],  // empty secondary_signer_addresses
        vec![],  // empty secondary_signers
        AccountAddress::random(),
        fee_payer_auth,
    );
    
    // This should fail with MaxSignaturesExceeded but passes
    // because fee_payer_signer signatures are not counted
    assert!(authenticator.verify(&raw_txn).is_ok());
    // 64 signatures are verified but only 32 are counted
}
```

## Notes

The vulnerability is particularly concerning because:
1. The documented intent (comment) clearly states the limit should apply to "all `AccountAuthenticator`s included"
2. The `all_signers()` method correctly includes the fee payer signer, but `verify()` doesn't use it for counting
3. The `to_single_key_authenticators()` method pre-allocates capacity for only 32 authenticators but uses `all_signers()`, which could cause additional vector reallocations when processing malicious transactions

This represents a clear mismatch between the documented security guarantee and the actual implementation.

### Citations

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L161-169)
```rust
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
```

**File:** types/src/transaction/authenticator.rs (L175-220)
```rust
            Self::FeePayer {
                sender,
                secondary_signer_addresses,
                secondary_signers,
                fee_payer_address,
                fee_payer_signer,
            } => {
                // In the fee payer model, the fee payer address can be optionally signed. We
                // realized when we designed the fee payer model, that we made it too restrictive
                // by requiring the signature over the fee payer address. So now we need to live in
                // a world where we support a multitude of different solutions. The modern approach
                // assumes that some may sign over the address and others will sign over the zero
                // address, so we verify both and only fail if the signature fails for either of
                // them. The legacy approach is to assume the address of the fee payer is signed
                // over.
                let mut to_verify = vec![sender];
                let _ = secondary_signers
                    .iter()
                    .map(|signer| to_verify.push(signer))
                    .collect::<Vec<_>>();

                let no_fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    AccountAddress::ZERO,
                );

                let mut remaining = to_verify
                    .iter()
                    .filter(|verifier| verifier.verify(&no_fee_payer_address_message).is_err())
                    .collect::<Vec<_>>();

                remaining.push(&fee_payer_signer);

                let fee_payer_address_message = RawTransactionWithData::new_fee_payer(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                    *fee_payer_address,
                );

                for verifier in remaining {
                    verifier.verify(&fee_payer_address_message)?;
                }

                Ok(())
            },
```

**File:** types/src/transaction/authenticator.rs (L278-295)
```rust
    pub fn secondary_signers(&self) -> Vec<AccountAuthenticator> {
        match self {
            Self::Ed25519 { .. } | Self::MultiEd25519 { .. } | Self::SingleSender { .. } => {
                vec![]
            },
            Self::FeePayer {
                sender: _,
                secondary_signer_addresses: _,
                secondary_signers,
                ..
            } => secondary_signers.to_vec(),
            Self::MultiAgent {
                sender: _,
                secondary_signer_addresses: _,
                secondary_signers,
            } => secondary_signers.to_vec(),
        }
    }
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L424-454)
```rust
impl TryFrom<&[u8]> for MultiEd25519Signature {
    type Error = CryptoMaterialError;

    /// Deserialize a MultiEd25519Signature. This method will also check for malleable signatures
    /// and bitmap validity.
    fn try_from(bytes: &[u8]) -> std::result::Result<MultiEd25519Signature, CryptoMaterialError> {
        let length = bytes.len();
        let bitmap_num_of_bytes = length % ED25519_SIGNATURE_LENGTH;
        let num_of_sigs = length / ED25519_SIGNATURE_LENGTH;

        if num_of_sigs == 0
            || num_of_sigs > MAX_NUM_OF_KEYS
            || bitmap_num_of_bytes != BITMAP_NUM_OF_BYTES
        {
            return Err(CryptoMaterialError::WrongLengthError);
        }

        let bitmap = match bytes[length - BITMAP_NUM_OF_BYTES..].try_into() {
            Ok(bitmap) => bitmap,
            Err(_) => return Err(CryptoMaterialError::DeserializationError),
        };
        if bitmap_count_ones(bitmap) != num_of_sigs as u32 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        let signatures: Result<Vec<Ed25519Signature>, _> = bytes
            .chunks_exact(ED25519_SIGNATURE_LENGTH)
            .map(Ed25519Signature::try_from)
            .collect();
        signatures.map(|signatures| MultiEd25519Signature { signatures, bitmap })
    }
```

**File:** types/src/transaction/mod.rs (L1310-1313)
```rust
    pub fn check_signature(self) -> Result<SignatureCheckedTransaction> {
        self.authenticator.verify(&self.raw_txn)?;
        Ok(SignatureCheckedTransaction(self))
    }
```
