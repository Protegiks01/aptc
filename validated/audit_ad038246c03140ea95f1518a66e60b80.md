# Audit Report

## Title
Non-Recoverable Consensus Halt via Empty Validator Set After Epoch Transition

## Summary
The Aptos staking system contains a critical logic bug where the `on_new_epoch` function lacks validation to prevent an empty validator set from being created during epoch transitions. This asymmetric protection (present in `leave_validator_set` but absent in `on_new_epoch`) can lead to irrecoverable network halt requiring hardfork recovery.

## Finding Description

The vulnerability exists in the validator set filtering logic during epoch transitions. The `on_new_epoch` function filters validators based on minimum stake requirements but fails to validate that at least one validator remains after filtering. [1](#0-0) 

The filtering loop checks each validator's voting power against `minimum_stake` at line 1391 and only includes those meeting the threshold in `next_epoch_validators`. Critically, at line 1401, this potentially empty vector is directly assigned to `validator_set.active_validators` with **no validation check**. The function is explicitly designed to never abort as documented at line 1334 and specified as `aborts_if false` in formal verification.

This contrasts sharply with the explicit protection in `leave_validator_set`, which prevents the last validator from leaving: [2](#0-1) 

The error constant `ELAST_VALIDATOR` with comment "Can't remove last validator" demonstrates the system recognizes empty validator sets as invalid: [3](#0-2) 

The `update_required_stake` governance function only validates that `minimum_stake <= maximum_stake`, not whether the new threshold would eliminate all validators: [4](#0-3) 

When the empty `ValidatorSet` is converted to a `ValidatorVerifier`, the system accepts it and sets `quorum_voting_power = 0`: [5](#0-4) 

The consensus `EpochManager` extracts this empty validator set and initializes the new epoch without validation: [6](#0-5) 

The conversion from `ValidatorSet` to `ValidatorVerifier` at line 1168 contains no empty-set validation: [7](#0-6) 

With an empty validator set, all vote verifications fail with `UnknownAuthor` because `get_public_key` returns `None`: [8](#0-7) [9](#0-8) 

**Trigger Scenarios:**

1. **Governance parameter update**: `update_required_stake` called with `minimum_stake` higher than all current validators' voting power
2. **Economic cascade**: Market conditions causing all validators to unstake or reduce stakes below minimum threshold
3. **Combined slashing and withdrawals**: Slashing events combined with stake reductions across all validators

The reconfiguration flow shows no additional validation: [10](#0-9) 

## Impact Explanation

This vulnerability meets **Critical Severity** under Aptos bug bounty criteria, matching two critical impact categories:

1. **Total Loss of Liveness/Network Availability**: With zero active validators, `quorum_voting_power = 0`, and all vote verifications returning `UnknownAuthor`, the blockchain completely halts. No blocks can be proposed, no transactions processed, and the network becomes non-operational.

2. **Non-recoverable Network Partition (requires hardfork)**: There is no on-chain recovery mechanism. With no validators in the set, the chain cannot progress to execute any governance proposals to fix the configuration. Recovery requires off-chain coordination and a hardfork to manually restore the validator set state.

The impact affects all network participants:
- Complete inability to access or transfer funds
- All staked assets frozen
- Network requires emergency intervention
- Severe reputational damage to the protocol

## Likelihood Explanation

**Likelihood: Low**

While this is a severe logic bug, the likelihood is low because:

1. Governance parameter changes undergo review processes where misconfiguration would likely be caught
2. Economic scenarios requiring ALL validators to simultaneously drop below threshold are rare under normal conditions
3. Monitoring systems would detect validators approaching minimum stake thresholds

However, the vulnerability CAN be triggered through:
- Governance configuration errors during parameter updates (trusted actors can make mistakes - hence defensive validation is needed)
- Extreme market volatility combined with slashing events
- Black swan economic events causing mass validator stake reductions

**Key Concern**: This represents asymmetric protection. The system explicitly prevents the last validator from leaving via `ELAST_VALIDATOR` in `leave_validator_set`, demonstrating awareness that empty validator sets are invalid. The absence of equivalent protection in `on_new_epoch` is a logic bug, not a feature.

## Recommendation

Add validation in `on_new_epoch` after the filtering loop to ensure at least one validator remains:

```move
// After line 1399, before line 1401:
assert!(
    vector::length(&next_epoch_validators) > 0, 
    error::invalid_state(ELAST_VALIDATOR)
);
validator_set.active_validators = next_epoch_validators;
```

Additionally, consider adding validation in `update_required_stake` to check whether the new minimum would eliminate all active validators:

```move
// In staking_config.move after line 280:
// Verify new minimum doesn't exceed all current validators' stakes
stake::validate_minimum_stake_threshold(minimum_stake);
```

## Proof of Concept

While a complete Move test would require full testnet setup, the vulnerability can be demonstrated through the following sequence:

1. Deploy network with validators at varying stake levels (e.g., 100k, 150k, 200k APT)
2. Submit governance proposal calling `update_required_stake` with `minimum_stake = 1_000_000` (1M APT)
3. Governance proposal passes and executes parameter update
4. Next epoch transition occurs, calling `on_new_epoch`
5. Filtering loop at lines 1377-1399 evaluates all validators against 1M APT threshold
6. All validators fail check at line 1391 (`new_validator_info.voting_power >= minimum_stake`)
7. `next_epoch_validators` remains empty
8. Line 1401 assigns empty vector to `validator_set.active_validators`
9. `ValidatorVerifier::new()` creates verifier with `quorum_voting_power = 0`
10. All subsequent vote attempts return `UnknownAuthor`, network halts permanently

The logic bug is evident from code inspection and the asymmetric protection pattern.

## Notes

This vulnerability exemplifies the importance of defensive validation even for trusted actors. The existence of `ELAST_VALIDATOR` protection in `leave_validator_set` proves the system designers recognized empty validator sets as problematic. The missing equivalent check in `on_new_epoch` represents an oversight rather than intentional design, constituting a valid logic vulnerability regardless of likelihood.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L57-58)
```text
    /// Can't remove last validator.
    const ELAST_VALIDATOR: u64 = 6;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1402)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
        validator_set.total_voting_power = total_voting_power;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L255-267)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature: &bls12381::Signature,
    ) -> std::result::Result<(), VerifyError> {
        match self.get_public_key(&author) {
            Some(public_key) => public_key
                .verify_struct_signature(message, signature)
                .map_err(|_| VerifyError::InvalidMultiSignature),
            None => Err(VerifyError::UnknownAuthor),
        }
    }
```

**File:** types/src/validator_verifier.rs (L496-500)
```rust
    pub fn get_public_key(&self, author: &AccountAddress) -> Option<PublicKey> {
        self.address_to_validator_index
            .get(author)
            .map(|index| self.validator_infos[*index].public_key().clone())
    }
```

**File:** types/src/validator_verifier.rs (L563-586)
```rust
impl From<&ValidatorSet> for ValidatorVerifier {
    fn from(validator_set: &ValidatorSet) -> Self {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
        ValidatorVerifier::new(validator_infos)
    }
```

**File:** consensus/src/epoch_manager.rs (L1164-1176)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");
        let mut verifier: ValidatorVerifier = (&validator_set).into();
        verifier.set_optimistic_sig_verification_flag(self.config.optimistic_sig_verification);

        let epoch_state = Arc::new(EpochState {
            epoch: payload.epoch(),
            verifier: verifier.into(),
        });

        self.epoch_state = Some(epoch_state.clone());
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-135)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
        storage_gas::on_reconfig();
```
