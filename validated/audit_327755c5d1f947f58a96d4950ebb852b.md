# Audit Report

## Title
Order Vote Aggregation Failure Due to Race Condition Between Block Execution and Order Vote Creation

## Summary
A race condition exists in JolteonV2 consensus where the `order_vote_proposal()` method incorrectly derives `BlockInfo` from the block's current execution state instead of using the QuorumCert's certified `BlockInfo`. When asynchronous execution completes before order vote creation, the safety validation fails because the QC certified placeholder values but the order vote proposal contains updated execution results.

## Finding Description

This vulnerability exists in the decoupled execution pipeline when `order_vote_enabled` is true. The core implementation bug is in how `OrderVoteProposal` constructs its `BlockInfo`.

**The Bug:**

The `order_vote_proposal()` method incorrectly calls `self.block_info()` which derives `BlockInfo` from the current compute result: [1](#0-0) 

The `block_info()` method generates `BlockInfo` from the current compute result, which is mutable and updated asynchronously: [2](#0-1) 

The `compute_result()` returns a clone of mutable state: [3](#0-2) 

Asynchronous execution updates this state with real execution results: [4](#0-3) 

**The Race Condition Flow:**

1. Validators vote using `vote_data_ordering_only()` which creates `VoteData` with placeholder values (`ACCUMULATOR_PLACEHOLDER_HASH`): [5](#0-4) 

2. When votes aggregate, `new_qc_aggregated()` is called: [6](#0-5) 

3. This calls `insert_quorum_cert()` which triggers `send_for_execution()`: [7](#0-6) 

4. `send_for_execution()` calls `finalize_order()`: [8](#0-7) 

5. `finalize_order()` sends blocks to the async pipeline via channel and returns immediately WITHOUT waiting for execution completion: [9](#0-8) 

6. After `new_qc_aggregated()` completes, `broadcast_order_vote()` is called: [10](#0-9) 

7. **Race Window**: Between steps 5 and 6, execution can complete and call `set_compute_result()` to update the block's state with real execution results.

8. `broadcast_order_vote()` retrieves the block and calls `order_vote_proposal()`, which derives `BlockInfo` from the CURRENT (potentially updated) compute result: [11](#0-10) 

9. The safety check compares the QC's `certified_block()` (containing placeholder values from voting) with `order_vote_proposal.block_info()` (potentially containing real execution values): [12](#0-11) 

10. If execution completed quickly, the `executed_state_id` field in these `BlockInfo` structs will differ, causing validation failure.

**Critical Configuration:**

Decoupled execution defaults to `true`: [13](#0-12) 

Order vote enabled defaults to `true` in genesis configuration used by mainnet: [14](#0-13) 

**Why This Breaks:**

Blocks start with dummy compute results using `ACCUMULATOR_PLACEHOLDER_HASH`: [15](#0-14) 

Votes certify this placeholder value, but `order_vote_proposal()` reads the current state instead of the certified state. When execution completes quickly, this causes a mismatch that fails the safety check.

## Impact Explanation

**Severity: High**

This vulnerability causes **consensus liveness degradation** and aligns with the "Validator Node Slowdowns" category in the Aptos bug bounty program.

**Impact:**
1. Validators that complete execution quickly cannot create order votes due to safety check failures
2. If a majority of validators hit this race condition, order vote QC formation fails
3. The decoupled execution pipeline becomes unreliable and non-deterministic
4. Consensus progression is blocked until timing conditions change randomly

**Why Not Critical:**
- No fund theft or minting capability
- No consensus safety violation (the safety check correctly prevents signing inconsistent data)
- This is a liveness issue, not a safety break
- No permanent network partition

**Why High:**
- Significant protocol violation affecting core consensus functionality
- Can cause validator performance degradation and consensus delays
- Unpredictable behavior based on hardware/network conditions
- Affects production mainnet configuration with no option to disable

## Likelihood Explanation

**Likelihood: High**

This race condition is highly likely to occur in production environments:

1. **Always Active**: `decoupled_execution` defaults to `true` with no configuration option to disable
2. **Mainnet Default**: `order_vote_enabled` is `true` in the genesis configuration
3. **Natural Timing Variation**: Validators have different hardware capabilities, system load, and network conditions
4. **Fast Execution Triggers**: Simple blocks with few transactions or empty blocks execute quickly, maximizing race probability
5. **No Synchronization**: There is no mechanism preventing execution from completing before order vote creation
6. **Asynchronous By Design**: The pipeline explicitly allows execution to complete at any time after `finalize_order()` returns

The race window exists between `finalize_order()` returning (which sends blocks asynchronously) and `broadcast_order_vote()` executing (which reads the current state). For blocks that execute in milliseconds, this race is highly probable.

## Recommendation

Change the `order_vote_proposal()` method to use the QC's certified `BlockInfo` instead of deriving from current state:

```rust
pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
    OrderVoteProposal::new(
        self.block.clone(), 
        quorum_cert.certified_block().clone(),  // Use certified BlockInfo
        quorum_cert
    )
}
```

This ensures the order vote proposal uses the same `BlockInfo` that the QC certified, eliminating the race condition. The order vote should always be consistent with what was certified by the quorum, not with the current execution state.

## Proof of Concept

The race condition can be demonstrated by examining the execution timeline:

1. Block receives votes with placeholder `executed_state_id` = `ACCUMULATOR_PLACEHOLDER_HASH`
2. QC aggregates at time T0, certifying the placeholder value
3. `finalize_order()` sends block to execution pipeline at time T1
4. For fast-executing blocks: execution completes at time T2, calling `set_compute_result()` with real values
5. `broadcast_order_vote()` executes at time T3
6. If T2 < T3: `order_vote_proposal.block_info()` contains real `executed_state_id` ≠ `ACCUMULATOR_PLACEHOLDER_HASH`
7. Safety check fails: `qc.certified_block().executed_state_id` (placeholder) ≠ `order_vote_proposal.block_info().executed_state_id` (real value)

The probability of T2 < T3 increases with:
- Faster validator hardware
- Simpler blocks (fewer transactions)
- Lower system load
- Empty or nearly-empty blocks

This race is deterministic given the code structure and timing-dependent in production.

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-77)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
        .boxed();
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L60-69)
```rust
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/src/round_manager.rs (L1658-1662)
```rust
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/src/round_manager.rs (L1789-1794)
```rust
                self.new_qc_aggregated(qc.clone(), vote.author())
                    .await
                    .context(format!(
                        "[RoundManager] Unable to process the created QC {:?}",
                        qc
                    ))?;
```

**File:** consensus/src/round_manager.rs (L1805-1815)
```rust
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/block_storage/block_store.rs (L344-347)
```rust
        self.execution_client
            .finalize_order(blocks_to_commit, finality_proof.clone())
            .await
            .expect("Failed to persist commit");
```

**File:** consensus/src/pipeline/execution_client.rs (L613-623)
```rust
        if execute_tx
            .send(OrderedBlocks {
                ordered_blocks: blocks,
                ordered_proof: ordered_proof.ledger_info().clone(),
            })
            .await
            .is_err()
        {
            debug!("Failed to send to buffer manager, maybe epoch ends");
        }
        Ok(())
```

**File:** consensus/safety-rules/src/safety_rules.rs (L97-102)
```rust
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-36)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-484)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```
