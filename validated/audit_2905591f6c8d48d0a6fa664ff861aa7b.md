# Audit Report

## Title
Testnet Validators Forced into Fast Sync Can Experience Permanent Bootstrap Failures Without Fallback Mechanism

## Summary
Testnet and mainnet validators are automatically forced into fast sync mode (`BootstrappingMode::DownloadLatestStates`) by the config optimizer, but this mode lacks a fallback mechanism when snapshot peers are unavailable. This causes permanent bootstrap failures during network initialization, partitions, or when peers lack snapshot data, preventing validators from becoming operational without manual intervention.

## Finding Description

The vulnerability exists in the state sync configuration system where automatic optimizations can force validators into an unrecoverable bootstrap state.

**The Issue Chain:**

1. **Forced Fast Sync**: The config optimizer automatically sets testnet and mainnet validators to fast sync mode when no explicit bootstrapping mode is configured: [1](#0-0) 

2. **Auto-Bootstrapping Prohibited**: The sanitizer explicitly prevents auto-bootstrapping for fast sync nodes, removing a potential recovery mechanism: [2](#0-1) 

3. **No Fallback Mechanism**: Unlike `ExecuteOrApplyFromGenesis` mode which uses `OutputFallbackHandler` to switch between execution and output syncing: [3](#0-2) 

Fast sync mode in `fetch_missing_state_snapshot_data` has no fallback when snapshot data is unavailable: [4](#0-3) 

4. **Early Return on Empty Global Summary**: When no peers are available, the driver returns early without making progress: [5](#0-4) 

5. **Infinite Error Loop**: When bootstrap errors occur, they are logged but the node continues retrying indefinitely: [6](#0-5) 

6. **Error Propagation**: Data client errors for unavailable snapshot data propagate as `UnexpectedError`: [7](#0-6) [8](#0-7) 

7. **Read-Only Configuration**: The bootstrapping mode cannot be changed during runtime: [9](#0-8) 

**Failure Scenarios:**

- **Scenario 1**: Fresh testnet initialization where all validators start simultaneously with no existing snapshot data to share
- **Scenario 2**: Network partition isolating validators from peers with snapshot data
- **Scenario 3**: Mass validator restarts with cleared storage
- **Scenario 4**: Geographic isolation where available peers lack required snapshot data at the target version

## Impact Explanation

This vulnerability meets **Medium severity** ($10,000 range) criteria per the Aptos bug bounty program:

**Medium Severity Impacts:**
- **State inconsistencies requiring manual intervention**: Validators cannot bootstrap without manually modifying configuration files and restarting nodes
- **Affects validator availability during critical network events**: During testnet initialization or network partitions, validators become permanently unavailable

**Why Not Higher Severity:**
- Does not cause fund loss, theft, or minting vulnerabilities
- Does not break consensus safety properties (nodes that can't bootstrap don't participate in consensus)
- Does not cause total network liveness loss (only affects nodes attempting to bootstrap)
- Established networks with existing validators are less affected

**Significance:**
1. Validators cannot participate in consensus until successfully bootstrapped
2. No automatic recovery mechanism exists
3. Requires manual configuration changes and node restarts
4. Can affect multiple validators simultaneously during network-wide events
5. Particularly problematic for fresh testnet deployments

## Likelihood Explanation

**Likelihood: Medium**

**High Probability Scenarios:**
1. **Fresh Testnet Initialization**: When launching a new testnet, all validators start from genesis with no snapshot data to share. The automatic fast sync configuration forces all validators to request snapshot data that doesn't exist.

**Medium Probability Scenarios:**
2. **Network Partitions**: Validators isolated from peers with snapshot data cannot complete bootstrapping
3. **Coordinated Mass Restarts**: When multiple validators clear storage and restart simultaneously

**Mitigating Factors:**
- Operators can explicitly configure `bootstrapping_mode` to override the automatic setting
- Established networks typically have validators with available snapshot data
- The issue primarily affects edge cases like fresh network initialization

**Exacerbating Factors:**
- Automatic configuration is non-obvious to operators
- No warnings indicate that peers must have snapshot data available
- Error messages don't clearly indicate the configuration is the root cause
- Testnet operators may not realize manual override is necessary

## Recommendation

**Immediate Fixes:**

1. **Add Fallback for Fast Sync**: Implement a fallback mechanism similar to `OutputFallbackHandler` that switches to transaction/output syncing when snapshot data is unavailable:

```rust
// In BootstrappingMode::DownloadLatestStates handling
if snapshot_data_unavailable_after_retries {
    // Fall back to output syncing
    self.fetch_missing_transaction_data(...).await?
}
```

2. **Improve Auto-Bootstrapping Logic**: Allow auto-bootstrapping for fast sync in specific safe scenarios (e.g., when at genesis and no higher versions are advertised)

3. **Add Configuration Validation**: Provide warnings during node startup if fast sync is configured but network conditions suggest it may fail

**Long-term Solutions:**

1. **Smart Mode Selection**: Make the config optimizer more intelligent about when to apply fast sync:
   - Check if this is a fresh network initialization
   - Verify that snapshot data is likely available before forcing fast sync
   - Consider node's current state before applying optimizations

2. **Better Error Messages**: When bootstrap fails due to unavailable snapshot data, provide clear guidance that operators should configure an alternative bootstrapping mode

3. **Documentation**: Document the bootstrapping mode trade-offs and when manual configuration is necessary

## Proof of Concept

A complete PoC would require setting up a fresh testnet environment, but the vulnerability can be demonstrated through code path analysis:

```rust
// Theoretical test scenario (not executable without full testnet setup)
#[test]
fn test_fresh_testnet_fast_sync_deadlock() {
    // Setup: Multiple validators starting from genesis
    // with default config (no explicit bootstrapping_mode)
    
    // 1. Config optimizer forces fast sync
    // Result: bootstrapping_mode = DownloadLatestStates
    
    // 2. Validators start bootstrapping
    // Result: All try to fetch snapshot data
    
    // 3. No validators have snapshot data (all fresh)
    // Result: DataIsUnavailable errors
    
    // 4. Auto-bootstrapping blocked by sanitizer
    // Result: Cannot auto-bootstrap at genesis
    
    // 5. Infinite retry loop
    // Result: Network never launches
}
```

**Expected Behavior:** Validators should either:
- Fall back to transaction/output syncing when snapshot data is unavailable
- Successfully auto-bootstrap when at genesis with no higher versions advertised
- Provide clear error messages indicating configuration needs manual adjustment

**Notes:**

The vulnerability is valid and affects core state sync functionality, though it has workarounds (manual configuration) and primarily impacts edge cases like fresh testnet initialization. The automatic forcing of a configuration that can lead to permanent failure without clear error messages or recovery mechanisms constitutes a legitimate availability vulnerability requiring manual intervention to resolve.

### Citations

**File:** config/src/config/state_sync_config.rs (L508-516)
```rust
        // nodes that are fast syncing.
        let fast_sync_enabled = state_sync_driver_config.bootstrapping_mode.is_fast_sync();
        if state_sync_driver_config.enable_auto_bootstrapping && fast_sync_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Auto-bootstrapping should not be enabled for nodes that are fast syncing!"
                    .to_string(),
            ));
        }
```

**File:** config/src/config/state_sync_config.rs (L561-572)
```rust
        // Default to fast sync for all testnet and mainnet nodes
        // because pruning has kicked in, and nodes will struggle
        // to locate all the data since genesis.
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && local_driver_config_yaml["bootstrapping_mode"].is_null()
            {
                state_sync_driver_config.bootstrapping_mode =
                    BootstrappingMode::DownloadLatestStates;
                modified_config = true;
            }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L362-365)
```rust
    /// Returns the bootstrapping mode of the node
    fn get_bootstrapping_mode(&self) -> BootstrappingMode {
        self.driver_configuration.config.bootstrapping_mode
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L515-548)
```rust
    async fn fetch_missing_state_snapshot_data(
        &mut self,
        highest_synced_version: Version,
        highest_known_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        if highest_synced_version == GENESIS_TRANSACTION_VERSION {
            // We're syncing a new node. Check the progress and fetch any missing data
            if let Some(target) = self.metadata_storage.previous_snapshot_sync_target()? {
                if self.metadata_storage.is_snapshot_sync_complete(&target)? {
                    // Fast syncing to the target is complete. Verify that the
                    // highest synced version matches the target.
                    if target.ledger_info().version() == GENESIS_TRANSACTION_VERSION {
                        info!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                            "The fast sync to genesis is complete! Target: {:?}",
                            target
                        )));
                        self.bootstrapping_complete().await
                    } else {
                        Err(Error::UnexpectedError(format!(
                            "The snapshot sync for the target was marked as complete but \
                        the highest synced version is genesis! Something has gone wrong! \
                        Target snapshot sync: {:?}",
                            target
                        )))
                    }
                } else {
                    // Continue snapshot syncing to the target
                    self.fetch_missing_state_values(target, true).await
                }
            } else {
                // No snapshot sync has started. Start a new sync for the highest known ledger info.
                self.fetch_missing_state_values(highest_known_ledger_info, false)
                    .await
            }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L768-796)
```rust
            BootstrappingMode::ExecuteOrApplyFromGenesis => {
                if self.output_fallback_handler.in_fallback_mode() {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        1,
                    );
                    self.streaming_client
                        .get_all_transaction_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                        )
                        .await?
                } else {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::Bootstrapper.get_label(),
                        0,
                    );
                    self.streaming_client
                        .get_all_transactions_or_outputs(
                            next_version,
                            end_version,
                            highest_known_ledger_version,
                            false,
                        )
                        .await?
                }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L673-678)
```rust
        if global_data_summary.is_empty() {
            trace!(LogSchema::new(LogEntry::Driver).message(
                "The global data summary is empty! It's likely that we have no active peers."
            ));
            return self.check_auto_bootstrapping().await;
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L711-718)
```rust
        } else if let Err(error) = self.bootstrapper.drive_progress(&global_data_summary).await {
            sample!(
                    SampleRate::Duration(Duration::from_secs(DRIVER_ERROR_LOG_FREQ_SECS)),
                    warn!(LogSchema::new(LogEntry::Driver)
                        .error(&error)
                        .message("Error found when checking the bootstrapper progress!"));
            );
            metrics::increment_counter(&metrics::BOOTSTRAPPER_ERRORS, error.get_label());
```

**File:** state-sync/aptos-data-client/src/error.rs (L12-13)
```rust
    #[error("The requested data is unavailable and cannot be found! Error: {0}")]
    DataIsUnavailable(String),
```

**File:** state-sync/aptos-data-client/src/error.rs (L20-21)
```rust
    #[error("No connected peers: {0}")]
    NoConnectedPeers(String),
```
