# Audit Report

## Title
Version 5 Module Metadata Validation Bypass Allows Invalid Attributes to Affect Runtime Behavior

## Summary
The metadata validation mechanism for Move module publishing contains a critical inconsistency between validation-time and runtime metadata extraction for version 5 modules. During publishing validation, `get_metadata_from_compiled_code()` clears struct and function attributes for v5 modules, but at runtime, `get_metadata()` does not perform this clearing, allowing invalid attributes to bypass validation and affect execution behavior.

## Finding Description

The vulnerability stems from two different metadata extraction functions that handle version 5 modules inconsistently:

**During Publishing Validation:**

The validation flow uses `get_metadata_from_compiled_code()` which explicitly clears attributes for version 5 modules: [1](#0-0) 

This function is called during module metadata validation: [2](#0-1) 

And during resource group validation: [3](#0-2) 

**At Runtime:**

The runtime metadata access uses `get_metadata()` which does NOT clear version 5 attributes: [4](#0-3) 

This function is used in critical runtime paths:
- Resource group member detection: [5](#0-4) 

- Randomness annotation checking: [6](#0-5) 

- Runtime resource access: [7](#0-6) 

- Randomness session marking: [8](#0-7) 

**Exploitation Path:**

An attacker can manually craft a version 5 `CompiledModule` with V1 metadata containing invalid attributes. Despite the specification indicating V1 metadata requires version 6+: [9](#0-8) 

There is no validation enforcing this constraint. The module bytes are stored as-is during publishing: [10](#0-9) 

Version 5 modules remain publishable because version checking allows any version >= VERSION_MIN: [11](#0-10) [12](#0-11) 

Even with VM_BINARY_FORMAT_V6 enabled by default: [13](#0-12) 

The max version check still permits v5 modules (5 <= 6). Networks without binary format flags would explicitly allow v5: [14](#0-13) 

## Impact Explanation

This vulnerability has **Medium severity** with potential for state inconsistency:

1. **Resource Group Storage Inconsistency**: An attacker can mark structs with invalid `resource_group_member` attributes that bypass validation but become active at runtime. This causes resources to be accessed via incorrect storage keys, leading to state layout inconsistencies.

2. **Module Upgrade Validation Bypass**: Since both old and new module metadata have v5 attributes cleared during upgrade validation, an attacker can add/remove resource group associations without proper compatibility checks, violating upgrade invariants.

3. **Randomness Annotation Bypass**: Invalid `randomness` annotations can be attached to functions, causing sessions to be incorrectly marked as unbiasable without proper validation of the annotation's legitimacy.

This meets the **Medium Severity** criteria: "State inconsistencies requiring manual intervention" and could impact protocol correctness.

## Likelihood Explanation

**Likelihood: Medium**

The attack is feasible because:
- An attacker only needs the ability to publish Move modules (no special privileges)
- Version 5 modules are explicitly supported (VERSION_MIN = 5) and accepted even on networks with v6+ enabled
- The exploit requires manual bytecode crafting but is technically straightforward
- No validation prevents the "v5 module + V1 metadata" combination

However, likelihood is tempered by:
- Requires manual crafting of non-standard bytecode (compiler wouldn't produce this)
- Most production deployments likely have v6+ as the de facto standard
- The vulnerability requires specific runtime code paths to access the invalid metadata

## Recommendation

Implement consistent v5 attribute handling across all metadata extraction paths:

1. **Immediate Fix**: Update `get_metadata()` to clear v5 attributes consistently with `get_metadata_from_compiled_code()`:

```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let mut meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                // Clear v5 attributes for consistency
                // Note: version information not available here, so this may require
                // storing version in cached metadata or passing it as parameter
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        // ... existing v0 handling
    }
}
```

2. **Long-term Fix**: Add validation that rejects v5 modules with V1 metadata during deserialization, enforcing the METADATA_V1_MIN_FILE_FORMAT_VERSION constraint.

3. **Defense in Depth**: Consider requiring minimum bytecode version 6 on production networks through on-chain configuration.

## Proof of Concept

A complete proof of concept would require:

1. Manual construction of a v5 `CompiledModule` with V1 metadata containing invalid `resource_group_member` attribute
2. Publishing the module via transaction
3. Demonstrating that validation passes (attributes cleared)
4. At runtime, showing that `get_resource_group_member_from_metadata()` returns the invalid group
5. Demonstrating incorrect storage access patterns

Due to the complexity of manually crafting valid bytecode with specific metadata, a full PoC would require significant Move compiler and bytecode manipulation expertise. However, the code paths and inconsistency are clearly evident in the cited code sections.

## Notes

The comment at line 293 of `module_metadata.rs` acknowledges that v5 attributes "shouldn't have existed in the first place and isn't being used" and that clearing "should have been gated in verify module metadata." This indicates the developers were aware of potential issues but only implemented defensive clearing in the validation path, not the runtime path, creating this exploitable inconsistency.

### Citations

**File:** types/src/vm/module_metadata.rs (L39-40)
```rust
/// The minimal file format version from which the V1 metadata is supported
pub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;
```

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L234-250)
```rust
pub fn get_randomness_annotation_for_entry_function(
    entry_func: &EntryFunction,
    metadata: &[Metadata],
) -> Option<RandomnessAnnotation> {
    get_metadata(metadata).and_then(|metadata| {
        metadata
            .fun_attributes
            .get(entry_func.function().as_str())
            .map(|attrs| {
                attrs
                    .iter()
                    .filter_map(KnownAttribute::try_as_randomness_annotation)
                    .next()
            })
            .unwrap_or(None)
    })
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L441-456)
```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }

    if features.are_resource_groups_enabled() {
        check_metadata_format(module)?;
    }
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L119-124)
```rust
    let (new_groups, mut new_members) =
        if let Some(metadata) = get_metadata_from_compiled_code(new_module) {
            extract_resource_group_metadata(&metadata)?
        } else {
            (BTreeMap::new(), BTreeMap::new())
        };
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-129)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L983-991)
```rust
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
            }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L196-205)
```rust
            // Modules that pass compatibility checks are added to the staged storage.
            use btree_map::Entry::*;
            let account_module_storage = match staged_modules.entry(*compiled_module.self_addr()) {
                Occupied(entry) => entry.into_mut(),
                Vacant(entry) => entry.insert(BTreeMap::new()),
            };
            let prev = account_module_storage.insert(
                compiled_module.self_name().to_owned(),
                (module_bytes, compiled_module.clone()),
            );
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L561-562)
```rust
/// Mark which oldest version is supported.
pub const VERSION_MIN: u32 = VERSION_5;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L615-629)
```rust
                },
            };
            if version == 0 || version > u32::min(max_version, VERSION_MAX) {
                Err(PartialVMError::new(StatusCode::UNKNOWN_VERSION)
                    .with_message(format!("bytecode version {} unsupported", version)))
            } else {
                Ok((
                    Self {
                        version,
                        max_identifier_size,
                        binary,
                    },
                    cursor,
                ))
            }
```

**File:** types/src/on_chain_config/aptos_features.rs (L177-180)
```rust
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```
