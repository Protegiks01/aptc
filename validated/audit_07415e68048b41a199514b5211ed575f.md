# Audit Report

## Title
Source Digest Verification Does Not Validate Bytecode Integrity - Supply Chain Attack Vector

## Summary
The Move package system's source digest verification mechanism fails to cryptographically bind published bytecode to the declared source code. An attacker can publish malicious bytecode with legitimate source digest metadata, bypassing verification and enabling supply chain attacks against dependent packages.

## Finding Description

The vulnerability exists in the architectural separation between package metadata and bytecode during publishing, with no validation mechanism to ensure they correspond.

**Attack Execution Path:**

1. **Publishing Entry Point**: The `publish_package_txn` entry function accepts metadata and bytecode as independent parameters without cryptographic binding. [1](#0-0) 

An attacker can serialize arbitrary `PackageMetadata` (containing any `source_digest`) and provide mismatched bytecode.

2. **Metadata Storage Without Binding**: The package metadata (including `source_digest`) is stored in `PackageRegistry` without validation against the bytecode. [2](#0-1) 

The `source_digest` field is defined as a string in the metadata structure: [3](#0-2) 

3. **Native Publishing Without Validation**: The native function creates a `PublishRequest` with the bytecode bundle but never validates it against the `source_digest` in metadata. [4](#0-3) 

The `PublishRequest` struct contains bytecode but has no reference to or validation against `source_digest`: [5](#0-4) 

4. **VM Validation Gap**: The `validate_publish_request` function performs structural checks but does NOT validate bytecode matches source. [6](#0-5) 

This validation checks module structure, dependencies, and metadata format, but there is no code that computes a hash of the bytecode and compares it to `source_digest`.

5. **Verification Bypass**: The `VerifyPackage` command downloads only metadata (not bytecode) and compares metadata fields only. [7](#0-6) 

The `verify()` method compares metadata to metadata, not bytecode to source: [8](#0-7) 

Specifically, it compares the `source_digest` strings but never validates that the on-chain bytecode corresponds to that digest.

**Exploitation Scenario:**
- Attacker compiles legitimate source → obtains `source_digest_A`
- Attacker crafts malicious bytecode with matching module names/signatures
- Attacker calls `publish_package_txn` with malicious bytecode + metadata containing `source_digest_A`
- Bytecode passes structural validation but executes malicious logic
- Victim compiles the legitimate source (matching `source_digest_A`) and runs `VerifyPackage`
- Verification succeeds because metadata matches, despite bytecode mismatch
- Victim's dependent contracts execute the malicious on-chain bytecode

## Impact Explanation

**Critical Severity** - This vulnerability enables supply chain attacks that break the fundamental trust model of package dependencies.

**Direct Impacts:**
1. **Loss of Funds**: Malicious bytecode can steal assets when invoked by victim contracts through standard Move function calls
2. **State Manipulation**: Backdoored modules in critical infrastructure (governance, staking) can corrupt chain state
3. **Supply Chain Compromise**: A single malicious package can compromise entire ecosystems of dependent contracts

This qualifies as **Critical** under Aptos bug bounty criteria because it enables:
- Direct theft of funds through malicious Move code execution (Critical Impact #1)
- The vulnerability affects core Move package infrastructure used network-wide
- Exploitation requires no validator compromise or consensus violations
- The false sense of security amplifies the impact as developers trust "verified" packages

The `source_digest` mechanism exists specifically to provide reproducible build verification, but the implementation fails to validate the critical invariant: "published bytecode matches the declared source."

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**
- Entry function is publicly accessible - any address can call `publish_package_txn`
- Package source code is optional in metadata: [9](#0-8) 

- Developers commonly trust "verified" packages without independent auditing
- Move bytecode format is well-documented, making manual crafting feasible
- No runtime detection exists for bytecode-source mismatch
- Attack requires only moderate skill (bytecode crafting with correct structure)

**Factors Decreasing Likelihood:**
- Bytecode must pass comprehensive structural verification
- Manual bytecode crafting requires expertise in Move bytecode format
- Suspicious packages (no source in metadata, unknown publishers) may be avoided by cautious developers
- Community review may detect obvious malicious behavior in popular packages

However, the high-value targets (governance modules, DeFi protocols) and the supply chain multiplier effect make exploitation attractive despite moderate complexity.

## Recommendation

Implement cryptographic validation that binds bytecode to `source_digest` during publishing:

1. **At Publishing Time**: After receiving bytecode in `validate_publish_request`, compute a hash of the compiled bytecode and verify it matches the expected hash derived from the `source_digest` in metadata. This requires either:
   - Storing a bytecode hash alongside `source_digest` in `PackageMetadata`
   - Computing the expected bytecode hash from source and comparing during validation

2. **In VerifyPackage Command**: Download both metadata AND bytecode, then verify:
   - Compile local source → get expected bytecode
   - Download on-chain bytecode
   - Compare bytecode hashes (not just metadata)
   - Only succeed if both metadata AND bytecode match

3. **Add Native Validation**: In `native_request_publish`, pass the `source_digest` to the `PublishRequest` and validate in `validate_publish_request` that the bytecode corresponds to it.

## Proof of Concept

A complete PoC would require:
1. Compiling legitimate Move source to obtain valid `source_digest`
2. Crafting malicious Move bytecode with matching module structure
3. Calling `publish_package_txn` with mismatched metadata/bytecode
4. Demonstrating that `VerifyPackage` succeeds despite bytecode mismatch
5. Showing that dependent contracts execute the malicious bytecode

The vulnerability is confirmed through code analysis showing no validation path exists between bytecode and `source_digest` at any stage of the publishing or verification process.

## Notes

This is a fundamental architectural flaw in the package publishing system where metadata and bytecode are treated as independent artifacts without cryptographic binding. The `source_digest` field provides a false sense of security as it is never validated against the actual published bytecode. This enables sophisticated supply chain attacks where malicious bytecode can masquerade as verified, legitimate packages.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L38-40)
```text
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L61-62)
```text
        /// Source text, gzipped String. Empty if not provided.
        source: vector<u8>,
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L232-240)
```rust
pub struct PublishRequest {
    pub destination: AccountAddress,
    pub bundle: ModuleBundle,
    pub expected_modules: BTreeSet<String>,
    /// Allowed module dependencies. Empty for no restrictions. An empty string in the set
    /// allows all modules from that address.
    pub allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    pub check_compat: bool,
}
```

**File:** aptos-move/framework/src/natives/code.rs (L353-359)
```rust
    code_context.requested_module_bundle = Some(PublishRequest {
        destination,
        bundle: ModuleBundle::new(code),
        expected_modules,
        allowed_deps,
        check_compat: policy != ARBITRARY_POLICY,
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1679-1739)
```rust
    /// Validate a publish request.
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos/src/move_tool/mod.rs (L2048-2083)
```rust
    async fn execute(self) -> CliTypedResult<&'static str> {
        // First build the package locally to get the package metadata
        let build_options = BuildOptions {
            install_dir: self.move_options.output_dir.clone(),
            bytecode_version: fix_bytecode_version(
                self.move_options.bytecode_version,
                self.move_options.language_version,
            ),
            ..self.included_artifacts.build_options(&self.move_options)?
        };
        let pack = BuiltPackage::build(self.move_options.get_package_path()?, build_options)
            .map_err(|e| CliError::MoveCompilationError(format!("{:#}", e)))?;
        let compiled_metadata = pack.extract_metadata()?;

        // Now pull the compiled package
        let url = self.rest_options.url(&self.profile_options)?;
        let registry = CachedPackageRegistry::create(url, self.account, false).await?;
        let package = registry
            .get_package(pack.name())
            .await
            .map_err(|s| CliError::CommandArgumentError(s.to_string()))?;

        // We can't check the arbitrary, because it could change on us
        if package.upgrade_policy() == UpgradePolicy::arbitrary() {
            return Err(CliError::CommandArgumentError(
                "A package with upgrade policy `arbitrary` cannot be downloaded \
                since it is not safe to depend on such packages."
                    .to_owned(),
            ));
        }

        // Verify that the source digest matches
        package.verify(&compiled_metadata)?;

        Ok("Successfully verified source of package")
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```
