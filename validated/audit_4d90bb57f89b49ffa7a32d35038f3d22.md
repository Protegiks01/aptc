# Audit Report

## Title
Race Condition in send_for_execution() Causes Validator Crash Due to Inconsistent ordered_root Reads

## Summary
The `send_for_execution()` function in `consensus/src/block_storage/block_store.rs` performs multiple separate read lock acquisitions when checking `ordered_root()`, creating a TOCTOU race condition where `ordered_root` can be updated between checks. This causes `path_from_ordered_root()` to return `None`, triggering an assertion panic that crashes the validator node.

## Finding Description

The vulnerability exists in the `send_for_execution()` method at lines 312-350. The function performs two separate read lock acquisitions: [1](#0-0) 

Then later: [2](#0-1) 

The race condition occurs when:
1. **Thread A** checks `block_to_commit.round() > self.ordered_root().round()` and the check passes
2. **Thread B** concurrently calls `send_for_execution()` and updates `ordered_root` to a higher round
3. **Thread A** calls `path_from_ordered_root()` but now sees the NEW ordered_root
4. The path traversal fails because the block is now "below" the updated root

The `path_from_root_to_block()` function in `block_tree.rs` explicitly handles this race condition by returning `None`: [3](#0-2) [4](#0-3) 

However, `send_for_execution()` does NOT handle this `None` gracefully - it converts it to an empty vector via `unwrap_or_default()` and then immediately asserts: [5](#0-4) 

This assertion panic crashes the validator process.

**Concurrent Call Sites:**

The function is called from multiple locations without synchronization: [6](#0-5) [7](#0-6) [8](#0-7) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria: "Validator node slowdowns, API crashes")

This vulnerability causes **validator crashes** resulting in:
- **Individual validator liveness failure**: The affected validator goes offline immediately
- **Network degradation**: If multiple validators crash simultaneously during high QC processing load, the network could approach the 1/3 Byzantine threshold
- **Repeated crashes**: The vulnerability can be retriggered upon restart

The impact is HIGH (not Critical) because:
- It affects liveness, not safety (no consensus splits or fund loss)
- Single validator crashes don't break the 2/3+ quorum requirement
- Validators can recover by restarting

## Likelihood Explanation

**Likelihood: Medium-to-High** during normal network operation

This race condition occurs naturally when:
1. Multiple quorum certificates arrive within a short time window
2. Network delays cause QCs to arrive out of order
3. Fast-forward sync operations process multiple QCs concurrently

The vulnerability is triggered by **legitimate consensus operations**, not attacker actions. The race window exists between two read lock acquisitions with no synchronization preventing concurrent `send_for_execution()` calls.

Critically, the code developers are aware this race can occur, as evidenced by the comment in `block_tree.rs`, but `send_for_execution()` fails to handle it properly.

## Recommendation

Hold a single read lock across both the round check and path calculation, or handle the `None` case gracefully:

```rust
pub async fn send_for_execution(
    &self,
    finality_proof: WrappedLedgerInfo,
) -> anyhow::Result<()> {
    let block_id_to_commit = finality_proof.commit_info().id();
    let block_to_commit = self
        .get_block(block_id_to_commit)
        .ok_or_else(|| format_err!("Committed block id not found"))?;

    // Hold a single read lock for both operations to prevent race
    let blocks_to_commit = {
        let tree = self.inner.read();
        ensure!(
            block_to_commit.round() > tree.ordered_root().round(),
            "Committed block round lower than root"
        );
        tree.path_from_ordered_root(block_id_to_commit)
    };

    // Handle None case gracefully instead of panicking
    let blocks_to_commit = match blocks_to_commit {
        Some(blocks) if !blocks.is_empty() => blocks,
        _ => {
            warn!("Block {} is no longer above ordered root, likely due to concurrent update", block_id_to_commit);
            return Ok(());
        }
    };

    // Rest of the function...
}
```

## Proof of Concept

The vulnerability can be demonstrated through a race condition test where two threads call `send_for_execution()` concurrently with different finality proofs. The test would show that when the timing is correct, the second thread's ordered_root update causes the first thread to panic on the assertion.

## Notes

This is a classic TOCTOU (Time-of-Check-Time-of-Use) vulnerability. The code comment in `block_tree.rs` explicitly acknowledges this race condition can occur, and the lower-level function returns `None` to avoid panicking. However, the higher-level `send_for_execution()` function doesn't respect this design and panics anyway, creating a validator crash vulnerability during normal consensus operations.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L144-161)
```rust
    async fn try_send_for_execution(&self) {
        // reproduce the same batches (important for the commit phase)
        let mut certs = self.inner.read().get_all_quorum_certs_with_commit_info();
        certs.sort_unstable_by_key(|qc| qc.commit_info().round());
        for qc in certs {
            if qc.commit_info().round() > self.commit_root().round() {
                info!(
                    "trying to commit to round {} with ledger info {}",
                    qc.commit_info().round(),
                    qc.ledger_info()
                );

                if let Err(e) = self.send_for_execution(qc.into_wrapped_ledger_info()).await {
                    error!("Error in try-committing blocks. {}", e.to_string());
                }
            }
        }
    }
```

**File:** consensus/src/block_storage/block_store.rs (L322-325)
```rust
        ensure!(
            block_to_commit.round() > self.ordered_root().round(),
            "Committed block round lower than root"
        );
```

**File:** consensus/src/block_storage/block_store.rs (L327-329)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();
```

**File:** consensus/src/block_storage/block_store.rs (L331-331)
```rust
        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_tree.rs (L515-518)
```rust
    /// While generally the provided blocks should always belong to the active tree, there might be
    /// a race, in which the root of the tree is propagated forward between retrieving the block
    /// and getting its path from root (e.g., at proposal generator). Hence, we don't want to panic
    /// and prefer to return None instead.
```

**File:** consensus/src/block_storage/block_tree.rs (L540-541)
```rust
        if cur_block_id != root_id {
            return None;
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L218-219)
```rust
                SUCCESSFUL_EXECUTED_WITH_ORDER_VOTE_QC.inc();
                self.send_for_execution(ordered_cert.clone()).await?;
```
