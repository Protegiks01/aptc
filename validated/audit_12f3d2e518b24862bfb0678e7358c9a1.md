# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution During Epoch Transitions

## Summary
The `process_block_epilogue()` function catches epilogue execution failures and returns success status with empty output, allowing blocks to commit without distributing transaction fees to validators. This occurs when epoch transitions happen mid-block, causing validator index mismatches between fee distribution data and the `PendingTransactionFee` map, breaking the economic invariant that successful blocks must compensate validators.

## Finding Description

The vulnerability exists in the interaction between epoch transition logic and block epilogue fee distribution.

**Execution Flow:**

1. **Block Prologue Triggers Epoch Transition**: When a block's prologue executes and the epoch interval has elapsed, it calls `reconfiguration::reconfigure()`: [1](#0-0) 

2. **Validator Indices Reassigned**: The `reconfigure()` function calls `stake::on_new_epoch()`: [2](#0-1) 

This reassigns validator indices sequentially starting from 0 for the new epoch: [3](#0-2) 

3. **PendingTransactionFee Map Reinitialized**: The map is reset with aggregators for the NEW validator indices: [4](#0-3) 

4. **Proposer Index Set Before Execution**: The `proposer_index` in auxiliary_info is calculated when the block is proposed, BEFORE the prologue executes, using the OLD epoch's validator set: [5](#0-4) 

5. **Block Epilogue Uses OLD Indices**: After user transactions execute, `gen_block_epilogue()` constructs fee distribution using the OLD proposer_index from auxiliary_info: [6](#0-5) 

6. **record_fee Attempts Lookup with OLD Index**: The epilogue calls `record_fee()` which tries to access the OLD validator index in the NEW epoch's map: [7](#0-6) 

7. **borrow_mut Aborts on Missing Key**: When the OLD index doesn't exist in the NEW map, `borrow_mut` aborts: [8](#0-7) 

8. **Error Silently Caught**: The error is caught and the block returns success with empty output (no fee distribution): [9](#0-8) 

**Evidence of Awareness**: The developers implemented defensive bounds checking in `update_performance_statistics` to handle invalid indices during epoch transitions: [10](#0-9) 

However, `record_fee` lacks this defensive pattern, creating an inconsistency that causes fee distribution failures.

## Impact Explanation

**Medium Severity** - Per Aptos bug bounty guidelines, this qualifies as "Limited funds loss or manipulation" and "State inconsistencies requiring intervention":

1. **Economic Loss**: Validators lose transaction fee rewards for blocks where epoch transitions occur (one block per transition). The fees are not distributed to any validator - they are effectively lost.

2. **State Inconsistency**: The blockchain shows successful block execution, but the `PendingTransactionFee` resource doesn't reflect fees that should have been recorded, violating the economic invariant that successful blocks compensate validators.

3. **Silent Failure**: The error is only logged, not surfaced to monitoring systems or the consensus layer, making it difficult to detect and diagnose.

4. **Protocol Inconsistency**: Defensive handling exists in `update_performance_statistics` but not in `record_fee`, indicating an architectural inconsistency in error handling patterns.

The impact is limited to fee distribution for specific blocks and doesn't affect consensus safety, validator stake, or network liveness, aligning with Medium severity per the bug bounty program.

## Likelihood Explanation

**Medium to High Likelihood** - This occurs deterministically during epoch transitions:

1. **Regular Occurrence**: Epoch transitions happen on a configured schedule (e.g., every 2 hours on mainnet), making this a regular event.

2. **Deterministic Trigger**: When an epoch transition occurs in a block prologue, the validator index mismatch is guaranteed because:
   - Proposer_index is set when the block is proposed (before execution)
   - Epoch transition reassigns indices during prologue
   - Old indices don't map to the new PendingTransactionFee structure

3. **No Attacker Required**: This happens naturally through normal protocol operation whenever validator sets change (validators join/leave) or validator ordering changes (due to voting power changes).

4. **Multiple Trigger Scenarios**:
   - Validator set shrinks (old indices exceed new validator count)
   - Proposing validator leaves the active set
   - Validator reordering causes index remapping

## Recommendation

Add defensive bounds checking to `record_fee()` similar to `update_performance_statistics()`:

```move
public(friend) fun record_fee(
    vm: &signer,
    fee_distribution_validator_indices: vector<u64>,
    fee_amounts_octa: vector<u64>,
) acquires PendingTransactionFee {
    system_addresses::assert_vm(vm);
    assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

    let num_validators_to_distribute = fee_distribution_validator_indices.length();
    let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
    
    let i = 0;
    while (i < num_validators_to_distribute) {
        let validator_index = fee_distribution_validator_indices[i];
        let fee_octa = fee_amounts_octa[i];
        
        // Add defensive check: skip invalid indices during epoch transitions
        if (pending_fee.pending_fee_by_validator.contains(&validator_index)) {
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
        };
        // else: log warning or emit event for monitoring
        
        i = i + 1;
    }
}
```

Alternatively, ensure that `proposer_index` values are updated to reflect the new epoch's validator indices before the block epilogue executes.

## Proof of Concept

While a full PoC requires mainnet/testnet execution during an epoch transition, the vulnerability can be demonstrated by:

1. Deploy a local testnet with short epoch intervals (e.g., 60 seconds)
2. Submit transactions to a block that will trigger an epoch transition in its prologue
3. Monitor the block epilogue execution logs for "Unexpected error from BlockEpilogue txn"
4. Verify that `PendingTransactionFee` doesn't contain entries for the expected proposer fees
5. Confirm the block is marked as successful despite the fee distribution failure

The vulnerability is deterministically reproducible whenever validator set changes coincide with epoch transitions during block prologue execution.

## Notes

This vulnerability represents a protocol-level bug that violates economic invariants in the Aptos staking system. While the impact is limited to transaction fees for specific blocks (not validator stake or consensus), it occurs regularly during normal network operation and results in validators losing earned rewards. The inconsistent defensive coding patterns between `update_performance_statistics` and `record_fee` suggest this was an oversight rather than an intentional design choice.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L134-134)
```text
        stake::on_new_epoch();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L630-633)
```text
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1298-1306)
```text
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1409-1428)
```text
        let validator_index = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(validator_set.active_validators);
                invariant len(validator_set.pending_active) == 0;
                invariant len(validator_set.pending_inactive) == 0;
                invariant 0 <= validator_index && validator_index <= vlen;
                invariant vlen == len(validator_set.active_validators);
                invariant forall i in 0..validator_index:
                    global<ValidatorConfig>(validator_set.active_validators[i].addr).validator_index < validator_index;
                invariant forall i in 0..validator_index:
                    validator_set.active_validators[i].config.validator_index < validator_index;
                invariant len(validator_perf.validators) == validator_index;
            };
            validator_index < vlen
        }) {
            let validator_info = vector::borrow_mut(&mut validator_set.active_validators, validator_index);
            validator_info.config.validator_index = validator_index;
            let validator_config = borrow_global_mut<ValidatorConfig>(validator_info.addr);
            validator_config.validator_index = validator_index;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L827-849)
```rust
        let proposer_index = block
            .author()
            .and_then(|proposer| validator.iter().position(|&v| v == proposer));

        let auxiliary_info: Vec<_> = txns
            .iter()
            .enumerate()
            .map(|(txn_index, txn)| {
                let persisted_auxiliary_info = match persisted_auxiliary_info_version {
                    0 => PersistedAuxiliaryInfo::None,
                    1 => PersistedAuxiliaryInfo::V1 {
                        transaction_index: txn_index as u32,
                    },
                    _ => unimplemented!("Unsupported persisted auxiliary info version"),
                };

                let ephemeral_auxiliary_info = txn
                    .borrow_into_inner()
                    .try_as_signed_user_txn()
                    .and_then(|_| {
                        proposer_index.map(|index| EphemeralAuxiliaryInfo {
                            proposer_index: index as u64,
                        })
```

**File:** aptos-move/block-executor/src/executor.rs (L2054-2073)
```rust
                let auxiliary_info = signature_verified_block.get_auxiliary_info(i as TxnIndex);
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-600)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2604-2617)
```rust
            .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
        {
            Ok(_) => get_system_transaction_output(
                session,
                module_storage,
                &self.storage_gas_params(log_context)?.change_set_configs,
            )?,
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```
