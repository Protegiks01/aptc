# Audit Report

## Title
Allocator Reentrancy in jemalloc Stats Collection Callback Causes Validator Node Deadlock

## Summary
The `write_cb()` callback function in the admin service's malloc stats endpoint incorrectly checks total Vec capacity instead of remaining capacity when accumulating jemalloc statistics. This logic error causes Vec reallocation during the callback, triggering recursive jemalloc calls while jemalloc holds internal locks, resulting in deadlock or memory corruption that crashes validator nodes.

## Finding Description

The vulnerability exists in the `write_cb()` unsafe C callback function that accumulates jemalloc statistics into a Rust `Vec<u8>`. [1](#0-0) 

**The Core Bug:**

The callback incorrectly computes the truncation length by checking total capacity (`out.capacity()`) instead of remaining capacity (`out.capacity() - out.len()`). When jemalloc calls this callback multiple times with streaming statistics output, the accumulated data can exceed the pre-allocated capacity, causing `Vec::extend_from_slice()` to reallocate.

**Exploitation Mechanism:**

1. The `/malloc/stats` endpoint is called with the default `malloc_stats_max_len` of 2MB [2](#0-1) 

2. A Vec with 2MB capacity is created via `Vec::with_capacity(max_len)` but starts with length 0 [3](#0-2) 

3. `malloc_stats_print()` calls `write_cb` multiple times to stream output

4. **Critical flaw**: Each callback computes `len = min(capacity, incoming_len)`, ignoring how much data is already accumulated

5. When accumulated length exceeds capacity, `extend_from_slice` triggers reallocation

6. Reallocation invokes the global allocator (jemalloc) via Rust's allocator API

7. Jemalloc is already executing `malloc_stats_print()` with internal mutexes held

8. **Reentrancy violation**: Jemalloc attempts to acquire locks it already holds → deadlock or undefined behavior

The developer comment explicitly acknowledges the reentrancy constraint that this bug violates [4](#0-3) 

**Access Control Context:**

The admin service exposes this endpoint on port 9102 by default [5](#0-4) 

The endpoint is routed through the admin service handler [6](#0-5) 

On testnet/devnet, the admin service is enabled by default without authentication [7](#0-6) 

On mainnet, authentication is required but accessible to node operators [8](#0-7) 

**Jemalloc Configuration:**

Jemalloc is configured as the global allocator with profiling enabled [9](#0-8) 

With `prof:true` profiling, jemalloc statistics include per-arena details, per-size-class allocations, large allocation tracking with stack traces, and extensive metadata. For long-running validator nodes, profiled statistics can plausibly exceed 2MB.

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria

This vulnerability aligns with the following HIGH severity impacts:

1. **Validator Node Slowdowns**: When Vec reallocation triggers reentrancy, jemalloc deadlocks attempting to acquire locks it already holds. The validator node becomes permanently unresponsive and cannot participate in consensus, directly impacting network liveness.

2. **API Crashes**: If jemalloc's internal state is corrupted during reentrancy (rather than clean deadlock), this can lead to heap metadata corruption, use-after-free vulnerabilities, or double-free crashes affecting the entire node process.

3. **Consensus Impact**: Multiple validators calling this endpoint simultaneously (e.g., automated monitoring systems) could deadlock multiple validators concurrently. If sufficient validators are affected, network liveness degrades.

4. **Denial of Service**: Attackers with admin access (or unauthenticated access on testnet) can reliably trigger validator crashes by calling this endpoint, especially on long-running nodes with accumulated allocation history.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Factors Increasing Likelihood:**
- Jemalloc profiling enabled by default increases stats output size significantly
- Validator nodes run continuously for days/weeks, accumulating allocation history
- The 2MB default buffer size suggests developers anticipated large outputs
- No runtime checks prevent reallocation
- Admin service enabled by default on testnet/devnet without authentication
- Accessible to authenticated operators on mainnet

**Factors Decreasing Likelihood:**
- Requires statistics output to exceed 2MB across multiple callback invocations (uncertain without real-world testing)
- Requires admin endpoint access (authentication barrier on mainnet)
- Depends on active monitoring or debugging scenarios

**Realistic Trigger Scenarios:**
- Automated monitoring systems regularly polling `/malloc/stats` on testnet validators
- Node operators debugging memory issues on production validators
- Malicious actors with testnet access exploiting unauthenticated endpoints
- Insider threats with mainnet admin credentials

The uncertainty about whether stats actually exceed 2MB in typical deployments limits the likelihood assessment. However, the bug itself is a **logic vulnerability** that violates the code's explicit safety requirement.

## Recommendation

Fix the capacity check to account for already-accumulated data:

```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let remaining_capacity = out.capacity() - out.len();
    let len = std::cmp::min(remaining_capacity, stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

Additionally, consider:
1. Adding runtime assertions to detect capacity violations
2. Implementing error handling if stats exceed buffer size
3. Logging when truncation occurs for monitoring purposes

## Proof of Concept

While a complete PoC requires a running validator node with sufficient allocation history, the logic bug can be demonstrated with a minimal test:

```rust
#[test]
fn test_write_cb_capacity_bug() {
    use std::ffi::CString;
    
    // Simulate the buggy behavior
    let mut out = Vec::with_capacity(10);
    
    // First callback adds 6 bytes
    let data1 = CString::new("123456").unwrap();
    let len1 = std::cmp::min(out.capacity(), data1.as_bytes().len()); // min(10, 6) = 6
    out.extend_from_slice(&data1.as_bytes()[0..len1]); // len=6
    
    // Second callback adds 6 more bytes
    let data2 = CString::new("789012").unwrap();
    let len2 = std::cmp::min(out.capacity(), data2.as_bytes().len()); // min(10, 6) = 6
    // BUG: This will try to add 6 bytes when only 4 bytes remain
    // out.extend_from_slice would reallocate here
    
    assert_eq!(out.len(), 6);
    assert_eq!(out.capacity(), 10);
    // After second extend, len would be 12 > capacity of 10, triggering realloc
}
```

In the actual validator context, this reallocation occurs while jemalloc holds internal locks, causing deadlock or undefined behavior.

## Notes

This vulnerability represents a **logic error** that violates the code's explicitly stated safety requirement ("We do not want any memory allocation in the callback"). Even if the practical exploitability depends on statistics exceeding 2MB—which cannot be definitively confirmed without testing on long-running production validators—the bug itself is a clear deviation from correct implementation that introduces reentrancy risk in a safety-critical context (validator node stability).

The admin service's security posture varies by network: unauthenticated on testnet/devnet (higher risk) versus authenticated on mainnet (requires operator credentials). This creates realistic attack scenarios across different threat models.

### Citations

**File:** crates/aptos-admin-service/src/server/malloc.rs (L14-20)
```rust
unsafe extern "C" fn write_cb(buf: *mut c_void, s: *const c_char) {
    let out = unsafe { &mut *(buf as *mut Vec<u8>) };
    let stats_cstr = unsafe { CStr::from_ptr(s).to_bytes() };
    // We do not want any memory allocation in the callback.
    let len = std::cmp::min(out.capacity(), stats_cstr.len());
    out.extend_from_slice(&stats_cstr[0..len]);
}
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L22-34)
```rust
fn get_jemalloc_stats_string(max_len: usize) -> anyhow::Result<String> {
    let _ = jemalloc_ctl::epoch::advance();

    let mut stats = Vec::with_capacity(max_len);
    unsafe {
        jemalloc_sys::malloc_stats_print(
            Some(write_cb),
            &mut stats as *mut _ as *mut c_void,
            std::ptr::null(),
        );
    }
    Ok(String::from_utf8(stats)?)
}
```

**File:** config/src/config/admin_service_config.rs (L46-46)
```rust
            port: 9102,
```

**File:** config/src/config/admin_service_config.rs (L48-48)
```rust
            malloc_stats_max_len: 2 * 1024 * 1024,
```

**File:** config/src/config/admin_service_config.rs (L69-76)
```rust
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L94-100)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L189-191)
```rust
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
```

**File:** aptos-node/src/main.rs (L10-19)
```rust
#[cfg(unix)]
#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;

/// Can be overridden by setting the `MALLOC_CONF` env var.
#[allow(unsafe_code)]
#[cfg(unix)]
#[used]
#[unsafe(no_mangle)]
pub static mut malloc_conf: *const c_char = c"prof:true,lg_prof_sample:23".as_ptr().cast();
```
