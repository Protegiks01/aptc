# Audit Report

## Title
Trusted Waypoint Validation Bypass via Early Exit in Epoch Ending Restore

## Summary
The `preheat_impl()` function in `EpochEndingRestoreController` performs version bounds checking before cryptographic validation, allowing an attacker with write access to backup storage to trigger premature loop termination that completely bypasses trusted waypoint validation for all subsequent epochs. This defeats the primary security mechanism designed to validate backup data from untrusted sources.

## Finding Description

The vulnerability exists in the validation order within the epoch ending restore loop. The code processes ledger infos from backup chunks and checks if the version exceeds the target before performing any validation: [1](#0-0) 

This version check occurs **before** all cryptographic validations:
- Epoch sequence validation (lines 113-118)
- Manifest waypoint validation (lines 119-128)  
- **Trusted waypoint validation** [2](#0-1) 
- Signature chain verification [3](#0-2) 

An attacker who can modify backup data (compromised backup storage, MITM, malicious provider) can exploit this by:

1. Modifying a ledger info's version field in the serialized BCS data to artificially exceed `target_version`
2. The modified ledger info triggers the early break at line 110 before any validation occurs
3. All subsequent ledger infos—including those that should match trusted waypoints—are never processed or validated
4. The function returns an incomplete epoch history

The incomplete epoch history is then used by subsequent restore operations. When state snapshot or transaction restore calls `EpochHistory::verify_ledger_info()`, it encounters a critical weakness: [4](#0-3) 

For epochs beyond the incomplete history, the function returns `Ok()` with only a warning, allowing unverified data to pass. The transaction and state restore processes then proceed using ledger infos that were never cryptographically validated against trusted waypoints: [5](#0-4) 

## Impact Explanation

This is a **Medium severity** vulnerability per the Aptos bug bounty criteria ("State inconsistencies requiring manual intervention").

**Specific Impacts:**

1. **Trusted Waypoint Bypass**: The primary security mechanism for validating backup integrity from untrusted sources is completely circumvented. Trusted waypoints represent out-of-band trust anchors specifically designed to catch backup manipulation, but they are never validated if positioned after the early exit point.

2. **Incomplete Epoch History**: Nodes restore with missing epoch-ending information, potentially having incorrect or absent validator set data for later epochs.

3. **State Inconsistency**: Different nodes restoring from differently manipulated backups could have divergent epoch histories, leading to disagreements about validator sets during epoch transitions.

4. **Unverified Data Acceptance**: The permissive behavior in `verify_ledger_info()` allows transaction and state snapshot data for missing epochs to be accepted without cryptographic verification, relying only on a logged warning that does not prevent the restore from completing.

While this does not directly enable fund theft or immediate consensus safety violations, it creates state inconsistencies that could require manual intervention to resolve and potentially compromise validator set integrity during epoch boundaries.

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Write access to backup storage (compromised backup server, MITM during download, or malicious backup provider)
- Knowledge of BCS serialization format to modify the version field
- No validator privileges or special access required

**Complexity:**
- Moderate—requires compromising backup storage but no cryptographic breaks
- The attack is straightforward once storage access is obtained
- Version field modification in BCS-serialized data is technically simple

**Realistic Scenarios:**
1. Compromised cloud storage bucket containing validator backups
2. Man-in-the-middle attack during backup download from untrusted or compromised sources
3. Intentionally malicious backup service provider

Trusted waypoints exist specifically to protect against these exact scenarios, making the bypass particularly concerning. The fact that the security mechanism is present but can be circumvented through improper validation ordering represents a genuine threat.

## Recommendation

Move the version check to **after** all cryptographic validations. The corrected loop structure should be:

```rust
for li in lis {
    // Validate epoch sequence
    ensure!(li.ledger_info().epoch() == next_epoch, ...);
    
    // Validate manifest waypoint
    let wp_manifest = waypoint_iter.next().ok_or_else(|| ...)?;
    let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
    ensure!(*wp_manifest == wp_li, ...);
    
    // Validate against trusted waypoint OR previous epoch signature
    if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
        ensure!(*wp_trusted == wp_li, ...);
    } else if let Some(pre_li) = previous_li {
        pre_li.ledger_info().next_epoch_state()
            .ok_or_else(|| ...)?
            .verify(&li)?;
    }
    
    // NOW check version bounds AFTER all validation
    if li.ledger_info().version() > self.target_version {
        past_target = true;
        break;
    }
    
    ledger_infos.push(li);
    previous_li = ledger_infos.last();
    next_epoch += 1;
}
```

This ensures that even if an attacker modifies backup data to trigger early exit, all ledger infos up to that point have been properly validated against trusted waypoints and signature chains.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a legitimate epoch ending backup with trusted waypoints at specific versions
2. Modifying a ledger info in an early chunk to have a version exceeding the target
3. Observing that the restore completes successfully but with incomplete epoch history
4. Verifying that subsequent state/transaction restore accepts data for missing epochs without proper validation

A complete Rust integration test would require setting up the backup infrastructure and mocking storage access, but the code path is directly observable from the source.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L107-111)
```rust
            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-288)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```
