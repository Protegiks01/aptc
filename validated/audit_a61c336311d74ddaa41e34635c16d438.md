# Audit Report

## Title
Validator Node Crash via Mixed V1/V2 Batch Variant Attack in Batch Coordinator

## Summary
A malicious validator can crash other validators by sending a `BatchMsg` containing mixed V1 and V2 `BatchInfoExt` variants. The `BatchCoordinator::persist_and_send_digests` function only checks the first batch's variant to determine the processing path for all batches, causing a panic when subsequent batches have different variants.

## Finding Description
The vulnerability exists in the batch processing logic where variant consistency is assumed but not enforced across multiple batches in a single message.

**1. No Variant Validation**: The `BatchMsg::verify` method validates author, epoch, and individual batch integrity, but does NOT check that all batches in the message have the same `BatchInfoExt` variant (V1 or V2). [1](#0-0) 

**2. Incorrect Variant Assumption**: In `persist_and_send_digests`, the code checks only the first batch's variant (`persist_requests[0].batch_info().is_v2()`) to determine the processing path for ALL batches in the message. [2](#0-1) 

**3. Panic on Variant Mismatch**: When the first batch is V1, the code takes the else branch and attempts to convert all signed batch infos to V1 using `.expect("Batch must be V1 batch")`, which will panic on any V2 variant. [3](#0-2) 

**4. Guaranteed Failure**: The `TryFrom<SignedBatchInfo<BatchInfoExt>> for SignedBatchInfo<BatchInfo>` implementation explicitly fails on V2 variants with the error message "Batch must be V1 type". [4](#0-3) 

**Attack Execution Path**:
1. Malicious validator crafts a `BatchMsg<BatchInfoExt>` where the first batch is V1 and subsequent batches are V2
2. Message is verified in `UnverifiedEvent::verify()` which calls `BatchMsg::verify()` [5](#0-4) 
3. Verification passes because individual batch validation succeeds, but no cross-batch variant consistency check exists
4. Message is routed to `BatchCoordinator::handle_batches_msg` which calls `persist_and_send_digests` [6](#0-5) 
5. Processing reaches `persist_and_send_digests` inside a `tokio::spawn` task [7](#0-6) 
6. The panic occurs, and the global panic handler exits the validator process with code 12 [8](#0-7) 

## Impact Explanation
**Severity: High**

This vulnerability meets the **High Severity** criteria per Aptos bug bounty framework under two categories:
- **Validator Node Slowdowns (High)**: Directly causes validator node crashes through unhandled panic
- **API Crashes (High)**: Consensus layer crashes affecting network participation

**Concrete Impacts**:
- **Consensus Disruption**: Crashed validators cannot participate in consensus until manually restarted
- **Liveness Attack**: If enough validators are repeatedly crashed, the network could lose liveness
- **Byzantine Fault Amplification**: One malicious validator (< 1/3 Byzantine threshold) can disrupt multiple honest validators simultaneously
- **Repeated Exploitation**: Attacker can continuously send malicious messages to maintain disruption state

This is a protocol-level vulnerability, not a network DoS attack. The panic occurs due to incorrect variant handling logic in the consensus layer, making it a valid security issue within scope.

## Likelihood Explanation
**Likelihood: Medium-High**

**Attack Requirements**:
- Attacker must be a validator in the current epoch (passes validation checks in verify method)
- Can construct and send arbitrary batch messages through the consensus network layer using `BatchMsg::new()` constructor [9](#0-8) 
- No additional cryptographic barriers or complex preconditions required

**Attack Complexity**: Low
- Simple to construct: Create one V1 batch using `BatchInfoExt::new_v1()` and one V2 batch using `BatchInfoExt::new_v2()` [10](#0-9) 
- No timing dependencies or race conditions required
- Deterministic outcome (guaranteed panic on mixed variants)
- Can be repeated indefinitely after any validator restart

**Realistic Scenario**: Aptos's Byzantine fault tolerance model is designed to handle up to 1/3 malicious validators. A compromised validator node or malicious validator operator could trivially exploit this vulnerability to disrupt honest validators, which represents a realistic threat within the BFT security model.

## Recommendation
Add variant consistency validation in the `BatchMsg::verify` method to ensure all batches in a message have the same variant:

```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.batches.is_empty(), "Empty message");
    ensure!(
        self.batches.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.batches.len(),
        max_num_batches
    );
    
    // NEW: Check variant consistency
    if self.batches.len() > 1 {
        let first_is_v2 = self.batches[0].batch_info().is_v2();
        for batch in self.batches.iter().skip(1) {
            ensure!(
                batch.batch_info().is_v2() == first_is_v2,
                "All batches must have the same variant (V1 or V2)"
            );
        }
    }
    
    let epoch_authors = verifier.address_to_validator_index();
    for batch in self.batches.iter() {
        ensure!(
            epoch_authors.contains_key(&batch.author()),
            "Invalid author {} for batch {} in current epoch",
            batch.author(),
            batch.digest()
        );
        ensure!(
            batch.author() == peer_id,
            "Batch author doesn't match sender"
        );
        batch.verify()?
    }
    Ok(())
}
```

Alternatively, replace the `.expect()` call in `persist_and_send_digests` with proper error handling, though the validation approach is preferable as it prevents invalid messages earlier in the processing pipeline.

## Proof of Concept
This vulnerability can be demonstrated with the following Rust test that would panic when executed:

```rust
#[tokio::test]
async fn test_mixed_variant_batch_panic() {
    use consensus::quorum_store::types::{Batch, BatchMsg};
    use aptos_consensus_types::proof_of_store::BatchInfoExt;
    
    // Create a V1 batch
    let batch_v1 = Batch::new_v1(/* valid V1 parameters */);
    
    // Create a V2 batch
    let batch_v2 = Batch::new_v2(/* valid V2 parameters with BatchKind */);
    
    // Create mixed BatchMsg (first V1, second V2)
    let mixed_batches = vec![batch_v1, batch_v2];
    let batch_msg = BatchMsg::new(mixed_batches);
    
    // This would pass verification (no variant check)
    assert!(batch_msg.verify(peer_id, max_batches, validator).is_ok());
    
    // But would panic in persist_and_send_digests when processing
    // the V2 batch through the V1 conversion path
}
```

The test demonstrates that a `BatchMsg` with mixed variants passes verification but will panic during processing in `persist_and_send_digests`.

### Citations

**File:** consensus/src/quorum_store/types.rs (L429-431)
```rust
    pub fn new(batches: Vec<Batch<T>>) -> Self {
        Self { batches }
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L90-90)
```rust
        tokio::spawn(async move {
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-102)
```rust
            if persist_requests[0].batch_info().is_v2() {
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L122-125)
```rust
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L244-244)
```rust
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L206-254)
```rust
    pub fn new_v1(
        author: PeerId,
        batch_id: BatchId,
        epoch: u64,
        expiration: u64,
        digest: HashValue,
        num_txns: u64,
        num_bytes: u64,
        gas_bucket_start: u64,
    ) -> Self {
        Self::V1 {
            info: BatchInfo::new(
                author,
                batch_id,
                epoch,
                expiration,
                digest,
                num_txns,
                num_bytes,
                gas_bucket_start,
            ),
        }
    }

    pub fn new_v2(
        author: PeerId,
        batch_id: BatchId,
        epoch: u64,
        expiration: u64,
        digest: HashValue,
        num_txns: u64,
        num_bytes: u64,
        gas_bucket_start: u64,
        kind: BatchKind,
    ) -> Self {
        Self::V2 {
            info: BatchInfo::new(
                author,
                batch_id,
                epoch,
                expiration,
                digest,
                num_txns,
                num_bytes,
                gas_bucket_start,
            ),
            extra: ExtraBatchInfo { batch_kind: kind },
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L524-527)
```rust
        ensure!(
            matches!(signed_batch_info.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
```

**File:** consensus/src/round_manager.rs (L175-182)
```rust
            UnverifiedEvent::BatchMsgV2(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(b)
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```
