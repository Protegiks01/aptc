# Audit Report

## Title
Order Vote Aggregation Failure Due to Race Condition Between Block Execution and Order Vote Creation

## Summary
When order votes are enabled in JolteonV2 consensus, a race condition exists between asynchronous block execution completing and order vote creation. The `order_vote_proposal()` method incorrectly derives `BlockInfo` from the block's current compute result instead of using the `QuorumCert`'s certified `BlockInfo`, causing safety validation failures when execution completes before order vote creation.

## Finding Description

This vulnerability exists in the decoupled execution pipeline when `order_vote_enabled` is true. The core issue is an implementation bug in how `OrderVoteProposal` is constructed:

**The Bug Location:**
The `order_vote_proposal()` method incorrectly calls `self.block_info()` which derives `BlockInfo` from the current `compute_result()`. [1](#0-0) 

**Why This Is Wrong:**
The `block_info()` method derives `BlockInfo` from the current compute result, which can be updated asynchronously. [2](#0-1) 

The `compute_result()` returns a clone of the mutable state that can be updated by `set_compute_result()`. [3](#0-2) 

Async execution updates this state with real values via `set_compute_result()`. [4](#0-3) 

**The Race Condition Flow:**

1. Validators vote using `vote_data_ordering_only()` which creates `VoteData` with placeholder values (`ACCUMULATOR_PLACEHOLDER_HASH`). [5](#0-4) 

2. When votes aggregate, `new_qc_aggregated()` is called. [6](#0-5) 

3. This calls `insert_quorum_cert()` which triggers `send_for_execution()`. [7](#0-6) 

4. `send_for_execution()` calls `finalize_order()` on the execution client. [8](#0-7) 

5. `finalize_order()` sends blocks to the async pipeline and returns immediately WITHOUT waiting for execution. [9](#0-8) 

6. After `new_qc_aggregated()` completes, `broadcast_order_vote()` is called. [10](#0-9) 

7. **Race Window**: Between steps 5 and 6, execution can complete and update the block's state with real execution results.

8. `broadcast_order_vote()` retrieves the block and calls `order_vote_proposal()`, which derives `BlockInfo` from the CURRENT compute result. [11](#0-10) 

9. The safety check compares the QC's `certified_block()` (placeholder values) with `order_vote_proposal.block_info()` (potentially real values). [12](#0-11) 

10. If execution completed, these `BlockInfo` structs differ, causing validation failure.

**Critical Configuration:**
- `decoupled_execution()` is hardcoded to return `true`. [13](#0-12) 

- `order_vote_enabled` defaults to `true` in `default_for_genesis()` used by mainnet. [14](#0-13) 

**Why This Breaks:**
Blocks start with dummy compute results. [15](#0-14) 

The `StateComputeResult::new_dummy()` uses `ACCUMULATOR_PLACEHOLDER_HASH`, which is what votes certify. But `order_vote_proposal()` reads the CURRENT state, not the certified state, causing a mismatch when execution completes quickly.

## Impact Explanation

**Severity: High**

This vulnerability causes **consensus liveness degradation** and meets the "Validator Node Slowdowns" category in the Aptos bug bounty program.

**Impact:**
1. Validators that complete execution quickly cannot create order votes due to safety check failures
2. If a majority of validators hit this race condition, order vote QC formation fails
3. The decoupled execution pipeline becomes unreliable and non-deterministic
4. Consensus progression is blocked until timing conditions change

**Why Not Critical:**
- No fund theft or minting capability
- No consensus safety violation (the safety check correctly prevents signing inconsistent data)
- This is a liveness issue, not a safety break
- No permanent network partition

**Why High:**
- Significant protocol violation affecting core consensus functionality
- Can cause validator performance degradation and consensus delays
- Unpredictable behavior based on hardware/network conditions
- Affects production mainnet configuration

## Likelihood Explanation

**Likelihood: High**

This race condition is highly likely to occur in production:

1. **Always Active**: `decoupled_execution` is hardcoded to `true` with no option to disable
2. **Mainnet Default**: `order_vote_enabled` is `true` in genesis configuration
3. **Natural Timing Variation**: Validators have different hardware, load, and network conditions
4. **Fast Execution**: Simple blocks with few transactions execute quickly, increasing race probability
5. **No Synchronization**: No mechanism prevents execution from completing before order vote creation
6. **Asynchronous Design**: The pipeline explicitly allows execution to complete at any time

The race window exists between `finalize_order()` returning and `broadcast_order_vote()` executing. For blocks that execute quickly (empty blocks, few transactions), this race is highly probable.

## Recommendation

Fix the `order_vote_proposal()` method to use the QC's certified `BlockInfo` instead of deriving a fresh one:

```rust
pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
    // Use the BlockInfo that the QC actually certifies, not a freshly derived one
    OrderVoteProposal::new(
        self.block.clone(), 
        quorum_cert.certified_block().clone(),  // Changed from self.block_info()
        quorum_cert
    )
}
```

This ensures the `OrderVoteProposal` always uses the same `BlockInfo` that was certified in the QC, regardless of whether execution has completed.

## Proof of Concept

While a full PoC would require a test environment with timing control, the bug can be demonstrated through code inspection:

1. Create a block and vote with placeholder values
2. Form QC with those placeholder values  
3. Start async execution via `finalize_order()`
4. Before calling `broadcast_order_vote()`, simulate execution completion by calling `set_compute_result()` with real values
5. Call `order_vote_proposal()` - it will derive `BlockInfo` with real values
6. Pass to `verify_order_vote_proposal()` - it will fail the check at line 97 because QC has placeholders but proposal has real values

The test suite already validates this behavior indirectly - tests disable `order_vote_enabled` specifically because it changes message flow patterns. [16](#0-15)

### Citations

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-307)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L60-68)
```rust
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
```

**File:** consensus/src/round_manager.rs (L1658-1662)
```rust
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/src/round_manager.rs (L1789-1794)
```rust
                self.new_qc_aggregated(qc.clone(), vote.author())
                    .await
                    .context(format!(
                        "[RoundManager] Unable to process the created QC {:?}",
                        qc
                    ))?;
```

**File:** consensus/src/round_manager.rs (L1807-1814)
```rust
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/block_storage/block_store.rs (L344-347)
```rust
        self.execution_client
            .finalize_order(blocks_to_commit, finality_proof.clone())
            .await
            .expect("Failed to persist commit");
```

**File:** consensus/src/pipeline/execution_client.rs (L613-623)
```rust
        if execute_tx
            .send(OrderedBlocks {
                ordered_blocks: blocks,
                ordered_proof: ordered_proof.ledger_info().clone(),
            })
            .await
            .is_err()
        {
            debug!("Failed to send to buffer manager, maybe epoch ends");
        }
        Ok(())
```

**File:** consensus/safety-rules/src/safety_rules.rs (L97-101)
```rust
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-35)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
```

**File:** types/src/on_chain_config/consensus_config.rs (L239-241)
```rust
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/round_manager_tests/mod.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{
    block_storage::{pending_blocks::PendingBlocks, BlockStore},
    counters,
    liveness::{
        proposal_generator::{
            ChainHealthBackoffConfig, PipelineBackpressureConfig, ProposalGenerator,
        },
        proposer_election::ProposerElection,
        rotating_proposer_election::RotatingProposer,
        round_state::{ExponentialTimeInterval, RoundState},
    },
    metrics_safety_rules::MetricsSafetyRules,
    network::{IncomingBlockRetrievalRequest, NetworkSender},
    network_interface::{CommitMessage, ConsensusMsg, ConsensusNetworkClient, DIRECT_SEND, RPC},
    network_tests::{NetworkPlayground, TwinId},
    payload_manager::{
        DirectMempoolPayloadManager, QuorumStorePayloadManager, TPayloadManager,
        TQuorumStoreCommitNotifier,
    },
    persistent_liveness_storage::RecoveryData,
    pipeline::buffer_manager::OrderedBlocks,
    quorum_store::batch_store::BatchReader,
    round_manager::RoundManager,
    test_utils::{
        mock_execution_client::MockExecutionClient, MockOptQSPayloadProvider,
        MockPastProposalStatusTracker, MockPayloadManager, MockStorage,
    },
    util::time_service::{ClockTimeService, TimeService},
};
use aptos_channels::{self, aptos_channel, message_queues::QueueStyle};
use aptos_config::{
    config::{BlockTransactionFilterConfig, ConsensusConfig},
    network_id::{NetworkId, PeerNetworkId},
};
use aptos_consensus_types::{
    block_retrieval::BlockRetrievalRequest,
    common::{Author, Round},
    opt_block_data::OptBlockData,
    opt_proposal_msg::OptProposalMsg,
    order_vote_msg::OrderVoteMsg,
    pipeline::commit_decision::CommitDecision,
    proof_of_store::{BatchInfo, BatchInfoExt},
    proposal_msg::ProposalMsg,
    round_timeout::RoundTimeoutMsg,
    utils::PayloadTxnsSize,
    vote_msg::VoteMsg,
    wrapped_ledger_info::WrappedLedgerInfo,
```
