# Audit Report

## Title
Consensus Safety Violation via Payload Type Confusion in Consensus Observer Verification

## Summary
The `verify_against_ordered_payload()` function fails to enforce type consistency between consensus-agreed payloads and separately-received transaction payloads, allowing malicious publishers to inject unauthorized transactions into consensus observer nodes that were never voted on by validators.

## Finding Description

The consensus observer architecture separates consensus ordering from transaction data delivery. The critical security invariant is that transaction payloads received separately must exactly match what consensus agreed upon. This verification happens in `verify_against_ordered_payload()`. [1](#0-0) 

**The Type Confusion Vulnerability:**

When the ordered payload type is `Payload::InQuorumStore`, the function only verifies batch proofs without checking if the `BlockTransactionPayload` contains additional unauthorized batch data: [2](#0-1) 

The `BlockTransactionPayload::OptQuorumStore` variant contains two fields: transaction proofs AND a `Vec<BatchInfo>` for opt/inline batches: [3](#0-2) 

The `verify_batches()` function only compares proof batches, completely ignoring the opt/inline batches field: [4](#0-3) 

**Attack Execution Path:**

1. Attacker sends `BlockPayload` with `OptQuorumStore` containing:
   - Empty proofs (matches consensus)
   - Non-empty opt/inline batches with malicious transactions
   - Correct digests (passes internal consistency check)

2. The digest verification passes because it only checks internal consistency: [5](#0-4) 

3. When `OrderedBlock` arrives with `Payload::InQuorumStore(empty proofs)`, verification passes because only proofs are compared.

4. During execution, the consensus observer's payload manager retrieves transactions from the stored `BlockTransactionPayload`: [6](#0-5) 

5. The `transactions()` method returns ALL transactions, including those from unauthorized opt/inline batches: [7](#0-6) 

6. These transactions execute despite never being consensus-approved: [8](#0-7) 

The vulnerability allows bypassing consensus agreement because the verification flow uses the stored `BlockTransactionPayload` for execution rather than the consensus-certified payload.

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation category - up to $1,000,000)

This vulnerability directly violates AptosBFT consensus safety guarantees:

1. **Consensus Safety Violation**: Consensus observers execute transactions that were never voted on by validators, breaking the fundamental security property that all honest nodes execute identical transaction sets for consensus-agreed blocks.

2. **State Divergence**: Affected observers compute different state roots than validators, violating deterministic execution guarantees essential for blockchain security.

3. **Network Partition Risk**: Sufficient compromised observers create inconsistent network views, potentially causing partition or requiring manual intervention.

4. **Byzantine Fault Tolerance Breach**: Achieved without compromising validators or requiring >1/3 Byzantine stake, staying within the threat model.

The verification flow is called before finalization: [9](#0-8) 

This confirms that bypassing this verification allows execution of unauthorized transactions.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Act as consensus observer publisher peer (validators or infrastructure nodes)
- No validator compromise required
- No special cryptographic capabilities needed

**Attack Complexity:** LOW
- Construct `OptQuorumStore` payload with empty proofs + non-empty opt/inline batches
- No race conditions or precise timing requirements
- Direct exploitation through standard network messages

**Deployment Reality:**
- Consensus observers are production components
- Observers subscribe to publishers for block data
- Compromised validator or malicious infrastructure node can exploit all subscribers
- Threat model explicitly considers network peers as potentially malicious

The barrier is obtaining publisher access, which is realistic for compromised validators or malicious infrastructure providers.

## Recommendation

Add type enforcement in `verify_against_ordered_payload()` to reject mismatched payload types:

```rust
Payload::InQuorumStore(proof_with_data) => {
    // Verify the batches in the requested block
    self.verify_batches(&proof_with_data.proofs)?;
    
    // ADDED: Enforce that OptQuorumStore payloads have no opt/inline batches
    // when ordered payload is InQuorumStore
    if !self.optqs_and_inline_batches().is_empty() {
        return Err(Error::InvalidMessageError(
            "Transaction payload contains unauthorized opt/inline batches".to_string()
        ));
    }
},
```

Alternatively, enforce strict type matching at the beginning of the function to reject incompatible payload type combinations.

## Proof of Concept

```rust
#[test]
fn test_type_confusion_attack() {
    // Consensus agrees on empty InQuorumStore payload
    let ordered_payload = Payload::InQuorumStore(ProofWithData::new(vec![]));
    
    // Attacker sends OptQuorumStore with injected batches
    let malicious_batch = create_batch_info(); // Arbitrary transactions
    let transaction_payload = BlockTransactionPayload::new_opt_quorum_store(
        vec![create_malicious_transaction()], // Injected transactions
        vec![], // Empty proofs (matches ordered payload)
        None,
        None,
        vec![malicious_batch], // Unauthorized opt/inline batches
    );
    
    // Verification INCORRECTLY passes
    assert!(transaction_payload
        .verify_against_ordered_payload(&ordered_payload)
        .is_ok());
    
    // Attacker successfully injected transactions that were never
    // voted on by consensus, violating safety guarantees
}
```

The test demonstrates that `OptQuorumStore` payloads with non-empty opt/inline batches incorrectly pass verification against `InQuorumStore` ordered payloads, enabling consensus safety violations.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L504-509)
```rust
    OptQuorumStore(
        TransactionsWithProof,
        /* OptQS and Inline Batches */ Vec<BatchInfo>,
    ),
    QuorumStoreInlineHybridV2(TransactionsWithProof, Vec<BatchInfo>),
}
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L631-645)
```rust
    pub fn transactions(&self) -> Vec<SignedTransaction> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(payload) => {
                payload.transactions.clone()
            },
            BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(payload) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybrid(payload, _) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.transactions(),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L648-717)
```rust
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L720-737)
```rust
    fn verify_batches(&self, expected_proofs: &[ProofOfStore<BatchInfo>]) -> Result<(), Error> {
        // Get the batches in the block transaction payload
        let payload_proofs = self.payload_proofs();
        let payload_batches: Vec<&BatchInfo> =
            payload_proofs.iter().map(|proof| proof.info()).collect();

        // Compare the expected batches against the payload batches
        let expected_batches: Vec<&BatchInfo> =
            expected_proofs.iter().map(|proof| proof.info()).collect();
        if expected_batches != payload_batches {
            return Err(Error::InvalidMessageError(format!(
                "Transaction payload failed batch verification! Expected batches {:?}, but found {:?}!",
                expected_batches, payload_batches
            )));
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L386-397)
```rust
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L29-76)
```rust
async fn get_transactions_for_observer(
    block: &Block,
    block_payloads: &Arc<Mutex<BTreeMap<(u64, Round), BlockPayloadStatus>>>,
    consensus_publisher: &Option<Arc<ConsensusPublisher>>,
) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)> {
    // The data should already be available (as consensus observer will only ever
    // forward a block to the executor once the data has been received and verified).
    let block_payload = match block_payloads.lock().entry((block.epoch(), block.round())) {
        Entry::Occupied(mut value) => match value.get_mut() {
            BlockPayloadStatus::AvailableAndVerified(block_payload) => block_payload.clone(),
            BlockPayloadStatus::AvailableAndUnverified(_) => {
                // This shouldn't happen (the payload should already be verified)
                let error = format!(
                    "Payload data for block epoch {}, round {} is unverified!",
                    block.epoch(),
                    block.round()
                );
                return Err(InternalError { error });
            },
        },
        Entry::Vacant(_) => {
            // This shouldn't happen (the payload should already be present)
            let error = format!(
                "Missing payload data for block epoch {}, round {}!",
                block.epoch(),
                block.round()
            );
            return Err(InternalError { error });
        },
    };

    // If the payload is valid, publish it to any downstream observers
    let transaction_payload = block_payload.transaction_payload();
    if let Some(consensus_publisher) = consensus_publisher {
        let message = ConsensusObserverMessage::new_block_payload_message(
            block.gen_block_info(HashValue::zero(), 0, None),
            transaction_payload.clone(),
        );
        consensus_publisher.publish_message(message);
    }

    // Return the transactions and the transaction limit
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
}
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L113-119)
```rust
    async fn get_transactions(
        &self,
        block: &Block,
        _block_signers: Option<BitVec>,
    ) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)> {
        get_transactions_for_observer(block, &self.txns_pool, &self.consensus_publisher).await
    }
```
