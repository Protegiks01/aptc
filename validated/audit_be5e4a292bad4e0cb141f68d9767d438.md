# Audit Report

## Title
Unhandled Panic in Account Balance Handler Causes Rosetta Server Crash

## Summary
The Aptos Rosetta API service contains an unhandled panic vulnerability in the account balance endpoint. User-provided fungible asset addresses are parsed using `.unwrap()` without validation, allowing attackers to crash the server by sending malformed address strings in the `/account/balance` request when running in Online mode with a local full node.

## Finding Description

The vulnerability exists in the request handling flow for the `/account/balance` endpoint. The `handle_request()` wrapper function only catches `Result<Resp, ApiError>` errors and does not handle panics. [1](#0-0) 

The attack path executes as follows:

1. An attacker sends a POST request to `/account/balance` with a malformed `fa_address` in the `currencies` array
2. The request is deserialized into `AccountBalanceRequest`, which contains an optional `currencies` field [2](#0-1) 
3. Each currency can have `CurrencyMetadata` with an `fa_address` string field that is fully user-controlled [3](#0-2) 
4. The `account_balance` handler calls `get_balances()`, which passes user-provided currencies directly to `get_base_balances()` without validation [4](#0-3)  and [5](#0-4) 
5. In `get_base_balances()`, the malformed `fa_address` is parsed with `AccountAddress::from_str(fa_address).unwrap()` [6](#0-5) 
6. When the address string is invalid, `from_str()` returns an `Err`, and `.unwrap()` triggers a panic
7. The panic is not caught by `handle_request()` and propagates to the global panic handler
8. When running in Online mode with a local full node, the global panic handler is installed [7](#0-6)  and terminates the process [8](#0-7) 

The critical flaw is that user-provided currencies in the request are used directly without validating that they exist in `server_context.currencies`. [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria, specifically the "API Crashes (High)" category worth up to $50,000. The impact includes:

- **Complete service unavailability**: The entire Rosetta server process terminates when running in Online mode with a local full node, as the panic handler exits the process
- **Denial of Service**: Any node operator running in this configuration can be taken offline with a single malicious request
- **No authentication required**: The `/account/balance` endpoint is publicly accessible [10](#0-9) 
- **Instant impact**: The crash occurs immediately upon processing the request

The vulnerability breaks the availability guarantee that API services should remain operational even when receiving malformed input. This matches the documented "API Crashes (High)" impact category for REST API crashes affecting network participation.

## Likelihood Explanation

This vulnerability has **High likelihood** of exploitation:

- **Trivial complexity**: Requires only a single HTTP POST request with malformed JSON
- **No authentication**: Publicly accessible endpoint without access controls
- **No special permissions**: Any network client can exploit this
- **Deterministic result**: Crash occurs 100% of the time with malformed input in affected deployment mode
- **Zero cost**: Single HTTP request with no resource requirements

An attacker simply needs to send a request with an invalid `fa_address` value in the currencies metadata to trigger the panic.

## Recommendation

Add proper error handling for address parsing instead of using `.unwrap()`:

```rust
// Replace line 335 in get_base_balances()
// From:
bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),

// To:
bcs::to_bytes(
    &AccountAddress::from_str(fa_address)
        .map_err(|_| ApiError::InvalidInput(Some(format!("Invalid fa_address: {}", fa_address))))?
)?,
```

Additionally, validate that user-provided currencies exist in `server_context.currencies` before processing them in `get_balances()`.

## Proof of Concept

Send the following HTTP POST request to a Rosetta server running in Online mode with local full node:

```bash
curl -X POST http://localhost:8082/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": { "blockchain": "aptos", "network": "testnet" },
    "account_identifier": { "address": "0x1" },
    "currencies": [{
      "symbol": "FAKE",
      "decimals": 6,
      "metadata": { "fa_address": "not_a_valid_address" }
    }]
  }'
```

The server will panic and terminate when attempting to parse the invalid address string.

## Notes

- This vulnerability only affects deployments running in Online mode with a local full node, where the crash handler is installed [11](#0-10) 
- In Online Remote or Offline modes without the crash handler, Tokio would catch the panic and the server would continue running, though the specific request would fail
- The underlying bug (improper input validation) exists in all deployment modes and should be fixed regardless

### Citations

**File:** crates/aptos-rosetta/src/common.rs (L62-98)
```rust
pub fn handle_request<'a, F, R, Req, Resp>(
    handler: F,
) -> impl Fn(
    Req,
    RosettaContext,
) -> BoxFuture<'static, Result<warp::reply::WithStatus<warp::reply::Json>, Infallible>>
       + Clone
       + use<F, R, Req, Resp>
where
    F: FnOnce(Req, RosettaContext) -> R + Clone + Copy + Send + 'static,
    R: Future<Output = Result<Resp, ApiError>> + Send,
    Req: Deserialize<'a> + Send + 'static,
    Resp: std::fmt::Debug + Serialize,
{
    move |request, options| {
        let fut = async move {
            match handler(request, options).await {
                Ok(response) => {
                    debug!("Response: {:?}", serde_json::to_string_pretty(&response));
                    Ok(warp::reply::with_status(
                        warp::reply::json(&response),
                        warp::http::StatusCode::OK,
                    ))
                },
                Err(api_error) => {
                    debug!("Error: {:?}", api_error);
                    let status = api_error.status_code();
                    Ok(warp::reply::with_status(
                        warp::reply::json(&api_error.into_error()),
                        status,
                    ))
                },
            }
        };
        Box::pin(fut)
    }
}
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L26-38)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountBalanceRequest {
    /// Network identifier describing the blockchain and the chain id
    pub network_identifier: NetworkIdentifier,
    /// Account identifier describing the account address
    pub account_identifier: AccountIdentifier,
    /// For historical balance lookups by either hash or version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_identifier: Option<PartialBlockIdentifier>,
    /// For filtering which currencies to show
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencies: Option<Vec<Currency>>,
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** crates/aptos-rosetta/src/account.rs (L35-44)
```rust
pub fn routes(
    server_context: RosettaContext,
) -> impl Filter<Extract = (impl warp::Reply,), Error = warp::Rejection> + Clone {
    warp::post().and(
        warp::path!("account" / "balance")
            .and(warp::body::json())
            .and(with_context(server_context))
            .and_then(handle_request(account_balance)),
    )
}
```

**File:** crates/aptos-rosetta/src/account.rs (L78-84)
```rust
    let (sequence_number, operators, balances, lockup_expiration) = get_balances(
        &server_context,
        request.account_identifier,
        balance_version,
        request.currencies,
    )
    .await?;
```

**File:** crates/aptos-rosetta/src/account.rs (L119-128)
```rust
    let currencies_to_lookup = if let Some(currencies) = maybe_filter_currencies {
        currencies.into_iter().collect()
    } else {
        server_context.currencies.clone()
    };

    // Regular account, FA and Coin
    if account.is_base_account() {
        balances =
            get_base_balances(&rest_client, owner_address, version, currencies_to_lookup).await?;
```

**File:** crates/aptos-rosetta/src/account.rs (L335-335)
```rust
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** crates/aptos-rosetta/src/main.rs (L50-57)
```rust
    let _maybe_node = if let CommandArgs::Online(OnlineLocalArgs {
        ref node_args,
        ref online_args,
    }) = args
    {
        println!("aptos-rosetta: Starting local full node");
        let node_args = node_args.clone();
        let runtime = thread::spawn(move || node_args.run());
```
