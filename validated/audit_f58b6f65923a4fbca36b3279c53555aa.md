# Audit Report

## Title
DAG Consensus Parent Digest Verification Bypass Enables Byzantine Validators to Inject Equivocating Nodes and Cause Consensus Split

## Summary
The DAG consensus implementation fails to verify that fetched parent nodes match the digest specified in node certificates. When honest validators fetch missing parents from Byzantine responders, the Byzantine validator can provide a different valid certified node (equivocation) with the same (round, author) but different digest. This allows Byzantine validators to cause different honest validators to store different versions of the DAG, breaking consensus safety and potentially causing a chain split.

## Finding Description

The vulnerability exists in the intersection of three components in the DAG consensus fetch mechanism:

**1. Responder Selection for Uncertified Nodes:**

When an honest validator receives an uncertified `Node` (not yet a `CertifiedNode`) with missing parents, it requests to fetch those parents. The responders list for a `Node` contains **only the author** of that node. [1](#0-0) 

If the author is Byzantine, they become the sole responder, giving them complete control over which parent nodes are provided.

**2. Missing Digest Verification in Fetch Response:**

When the fetch response is received and verified, the system checks that returned nodes match the requested bitmask (round, author) and have valid quorum signatures, but **critically fails to verify that the node's digest matches the digest in the request's targets**. [2](#0-1) 

The verification only checks `(round, author_idx)` via `!request.exists_bitmask.has(round, *author_idx)`, completely ignoring the digest field in `NodeMetadata`. [3](#0-2) 

**3. DAG Store Uses Only (Round, Author) for Existence Check:**

When validating that a node's parents exist in the DAG, the system looks up nodes by (round, author) only, ignoring the digest specified in the parent certificate. [4](#0-3) [5](#0-4) 

This means if a Byzantine validator provides a different node with the same (round, author) but different digest than what the parent certificate specifies, it will still pass the existence check. [6](#0-5) 

**Attack Path:**

1. Byzantine validator B equivocates at round R-1, creating two different nodes P and P' for the same position with different digests
2. B gets both P and P' certified by different quorums of validators (possible when n > 3f+1, e.g., f=1, n=5: P signed by {B, H1, H2}, P' signed by {B, H3, H4})
3. B creates node N at round R with parent certificate referencing P (digest D1)
4. B broadcasts uncertified N to honest validators [7](#0-6) 

5. Honest validators check parent existence using `exists()` which only checks (round, author), find P missing, and trigger fetch with responders = [B]
6. B maliciously responds with P' (digest D2 â‰  D1)
7. `FetchResponse::verify` checks signatures and position but not digest - P' is accepted
8. P' is stored in DAG at position (R-1, author_of_P) [8](#0-7) 

9. Later when validating N, `exists(parent.metadata())` looks up by (round, author), finds P', returns true
10. N is accepted even though its parent certificate digest D1 doesn't match the actual parent P' with digest D2
11. Different honest validators now have different DAG states - a consensus safety violation

## Impact Explanation

This is a **Critical** severity vulnerability under the Aptos bug bounty criteria:

**Consensus Safety Violation:** The attack breaks the fundamental consensus safety guarantee that all honest validators maintain the same ledger state. By causing different honest validators to store different parent nodes in their DAGs, Byzantine validators can create divergent views of the consensus history. When these divergent DAGs are used for ordering and committing blocks, different validators may commit different blocks, causing a chain split.

**Impact on Invariants:**
- Violates **Consensus Safety**: AptosBFT must prevent chain splits under < 1/3 Byzantine validators
- Violates **Deterministic Execution**: Validators produce different state roots for what should be identical consensus history

**Scope:** Affects all nodes running DAG consensus. Can lead to non-recoverable network partition requiring manual intervention or hard fork.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Control of f Byzantine validators (where f < n/3)
- Ability to create equivocating nodes
- Network positioning to control message delivery to different honest validators

**Feasibility:**
The attack is practical because:
1. The responder selection for uncertified nodes gives Byzantine authors sole control
2. Equivocation is possible when there are more than minimum honest validators (n > 3f+1), which is the common case for network redundancy
3. No additional collusion or compromise required beyond being a Byzantine validator
4. The digest verification gap is systematic, not a race condition

**Constraints:**
- Requires n > 3f+1 (more than minimum honest validators) to get both equivocations certified by different quorums
- Byzantine validator must be the author of fetched nodes to be sole responder

## Recommendation

Add digest verification in three locations:

1. **In `FetchResponse::verify()`**: Verify that each returned node's digest matches the digest in the corresponding target from `RemoteFetchRequest`:

```rust
pub fn verify(
    self,
    request: &RemoteFetchRequest,
    validator_verifier: &ValidatorVerifier,
) -> anyhow::Result<Self> {
    // Existing checks...
    
    // NEW: Verify digest matches for each target
    for node in &self.certified_nodes {
        let matching_target = request.targets()
            .find(|target| target.round() == node.round() 
                       && target.author() == node.author());
        if let Some(target) = matching_target {
            ensure!(
                target.digest() == node.digest(),
                "node digest {} doesn't match requested digest {}",
                node.digest(),
                target.digest()
            );
        }
    }
    
    Ok(self)
}
```

2. **In `InMemDag::exists()`**: Verify digest match when checking parent existence:

```rust
pub fn exists(&self, metadata: &NodeMetadata) -> bool {
    self.get_node_ref_by_metadata(metadata)
        .map(|node_status| node_status.as_node().digest() == metadata.digest())
        .unwrap_or(false)
}
```

3. **Add equivocation detection**: When adding nodes, check if a different node already exists at the same (round, author) position and log/reject if digests differ.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Set up a DAG consensus network with 5 validators (n=5, f=1, quorum=3)
2. Byzantine validator B creates two nodes P and P' at round 1 with different payloads
3. B collects signatures from {B, H1, H2} for P and {B, H3, H4} for P'
4. B creates node N at round 2 with parent certificate pointing to P
5. B broadcasts uncertified N to H1 and H2
6. When H1 and H2 fetch the missing parent, B responds to H1 with P' and to H2 with P
7. Both accept their received nodes due to missing digest verification
8. H1 and H2 now have different DAG states, violating consensus safety

The attack succeeds because all three verification gaps allow the wrong node to be accepted and stored without detecting the digest mismatch.

### Citations

**File:** consensus/src/dag/dag_fetcher.rs (L105-112)
```rust
    pub fn responders(&self, validators: &[Author]) -> Vec<Author> {
        match self {
            LocalFetchRequest::Node(node, _) => vec![*node.author()],
            LocalFetchRequest::CertifiedNode(node, _) => {
                node.signatures().get_signers_addresses(validators)
            },
        }
    }
```

**File:** consensus/src/dag/types.rs (L96-100)
```rust
pub struct NodeMetadata {
    node_id: NodeId,
    timestamp: u64,
    digest: HashValue,
}
```

**File:** consensus/src/dag/types.rs (L750-777)
```rust
    pub fn verify(
        self,
        request: &RemoteFetchRequest,
        validator_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<Self> {
        ensure!(
            self.certified_nodes.iter().all(|node| {
                let round = node.round();
                let author = node.author();
                if let Some(author_idx) =
                    validator_verifier.address_to_validator_index().get(author)
                {
                    !request.exists_bitmask.has(round, *author_idx)
                } else {
                    false
                }
            }),
            "nodes don't match requested bitmask"
        );
        ensure!(
            self.certified_nodes
                .iter()
                .all(|node| node.verify(validator_verifier).is_ok()),
            "unable to verify certified nodes"
        );

        Ok(self)
    }
```

**File:** consensus/src/dag/dag_store.rs (L154-156)
```rust
            for parent in node.parents() {
                ensure!(self.exists(parent.metadata()), "parent not exist");
            }
```

**File:** consensus/src/dag/dag_store.rs (L199-201)
```rust
    pub fn exists(&self, metadata: &NodeMetadata) -> bool {
        self.get_node_ref_by_metadata(metadata).is_some()
    }
```

**File:** consensus/src/dag/dag_store.rs (L221-229)
```rust
    fn get_node_ref_by_metadata(&self, metadata: &NodeMetadata) -> Option<&NodeStatus> {
        self.get_node_ref(metadata.round(), metadata.author())
    }

    pub fn get_node_ref(&self, round: Round, author: &Author) -> Option<&NodeStatus> {
        let index = self.author_to_index.get(author)?;
        let round_ref = self.nodes_by_round.get(&round)?;
        round_ref[*index].as_ref()
    }
```

**File:** consensus/src/dag/dag_store.rs (L518-536)
```rust
    pub fn add_node(&self, node: CertifiedNode) -> anyhow::Result<()> {
        self.dag.write().validate_new_node(&node)?;

        // Note on concurrency: it is possible that a prune operation kicks in here and
        // moves the window forward making the `node` stale. Any stale node inserted
        // due to this race will be cleaned up with the next prune operation.

        // mutate after all checks pass
        self.storage.save_certified_node(&node)?;

        debug!("Added node {}", node.id());
        self.payload_manager.prefetch_payload_data(
            node.payload(),
            *node.author(),
            node.metadata().timestamp(),
        );

        self.dag.write().add_validated_node(node)
    }
```

**File:** consensus/src/dag/rb_handler.rs (L155-180)
```rust
        let missing_parents: Vec<NodeCertificate> = node
            .parents()
            .iter()
            .filter(|parent| !dag_reader.exists(parent.metadata()))
            .cloned()
            .collect();
        drop(dag_reader); // Drop the DAG store early as it is no longer required

        if !missing_parents.is_empty() {
            // For each missing parent, verify their signatures and voting power.
            // Otherwise, a malicious node can send bad nodes with fake parents
            // and cause this peer to issue unnecessary fetch requests.
            ensure!(
                missing_parents
                    .iter()
                    .all(|parent| { parent.verify(&self.epoch_state.verifier).is_ok() }),
                NodeBroadcastHandleError::InvalidParent
            );

            // Don't issue fetch requests for parents of the lowest round in the DAG
            // because they are already GC'ed
            if current_round > lowest_round {
                if let Err(err) = self.fetch_requester.request_for_node(node) {
                    error!("request to fetch failed: {}", err);
                }
                bail!(NodeBroadcastHandleError::MissingParents);
```
