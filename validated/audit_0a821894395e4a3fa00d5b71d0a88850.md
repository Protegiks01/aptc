# Audit Report

## Title
Optimistic Proposal Race Condition Enables Vote Splitting Through Last-Write-Wins Buffer Semantics

## Summary
A malicious validator elected as round leader can exploit the optimistic proposal buffering mechanism to cause consensus liveness failures. By broadcasting multiple conflicting optimistic proposals for the same round, the attacker leverages the last-write-wins semantics of `pending_opt_proposals` to ensure different validators process different proposals, splitting votes and preventing quorum certificate formation.

## Finding Description

The vulnerability exists in how optimistic proposals are buffered before processing. When an `OptProposalMsg` is received for a future round, it's stored in `pending_opt_proposals` - a `BTreeMap<Round, OptBlockData>` that maps rounds to block data. [1](#0-0) 

The critical flaw occurs during buffering. When an optimistic proposal arrives for a future round, the code only validates that the proposer is valid for that round, then inserts the proposal into the buffer: [2](#0-1) 

This uses `BTreeMap::insert()`, which silently overwrites any existing value for the same round key. There is no check for whether a proposal already exists, and no validation that the new proposal has the same block ID as any previously buffered proposal.

**Attack Scenario:**

1. Malicious validator V1 is elected leader for round R
2. V1 crafts two distinct optimistic proposals with different transaction payloads (OptBlockData uses CryptoHasher, so different payloads produce different block IDs): [3](#0-2) 

3. V1 broadcasts both proposals to the network using the standard broadcast mechanism: [4](#0-3) 

4. The broadcast sends to validators without ordering guarantees, causing different validators to receive messages in different orders: [5](#0-4) 

5. When validators advance to round R, each retrieves its buffered proposal (only one, due to the overwrite): [6](#0-5) 

6. Each validator processes its buffered proposal through `process_opt_proposal()`, which creates a Block and calls `process_proposal()`: [7](#0-6) 

7. The `is_valid_proposal()` check validates that this is the first proposal the validator has seen from this proposer for this round: [8](#0-7) 

8. The equivocation detection in `UnequivocalProposerElection` tracks proposals per-validator using a mutex-protected (Round, HashValue) state: [9](#0-8) 

Since each validator only processes ONE buffered proposal (the last one inserted), the equivocation check passes - each validator thinks it's seeing the proposer's first and only proposal for that round.

9. Validators vote for different blocks, splitting votes across different block IDs. No block reaches the 2f+1 threshold for QC formation, causing the round to timeout.

**Invariant Violation:**

The `UnequivocalProposerElection` wrapper is designed to detect and reject proposer equivocation: [10](#0-9) 

However, optimistic proposals bypass this protection during the buffering phase. The equivocation check only occurs when processing the proposal from the buffer, by which time different validators have already committed to different proposals due to the last-write-wins semantics.

**Key Technical Detail:**

Optimistic proposals are intentionally not signed by the proposer, making it trivial for a Byzantine validator to create multiple conflicting proposals: [11](#0-10) [12](#0-11) 

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability enables a single Byzantine validator to cause consensus liveness failures when elected as round leader. The impact includes:

1. **Liveness Degradation**: Each round where the attacker is leader results in a guaranteed timeout
2. **Vote Splitting**: Honest validators waste voting power on conflicting blocks  
3. **Equivocation Bypass**: The unequivocal proposer election mechanism is circumvented during the optimistic proposal window
4. **Reduced Throughput**: Network fails to achieve optimistic latency improvements

While this doesn't cause safety violations (no conflicting blocks get committed since no QC forms), it violates the protocol's explicit assumption of unequivocal proposer election. The optimistic proposal mechanism, designed to improve latency, becomes an attack vector for degrading network performance.

Per Aptos bug bounty criteria, this qualifies as **High Severity**: "Significant protocol violations" - the unequivocal proposer election guarantee is violated, and validator nodes experience degraded performance during malicious leader rounds.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Attacker only needs to broadcast two different `OptBlockData` messages
2. **No Coordination Required**: Single Byzantine validator can execute the attack alone
3. **Deterministic Success**: Network timing naturally causes different delivery orders across validators
4. **Recurring Opportunity**: Each time the Byzantine validator is elected leader (probability 1/n per round)
5. **No Detection**: Current implementation provides no warning when duplicate proposals overwrite existing buffered proposals

The attack requires only:
- Being a validator (assumed in BFT model with f < n/3 Byzantine validators)
- Being elected as round leader (happens regularly)
- Basic network broadcast capability

## Recommendation

Add duplicate detection during the buffering phase. Before inserting an optimistic proposal into `pending_opt_proposals`, check if a proposal already exists for that round and verify it has the same block ID:

```rust
// In process_opt_proposal_msg, around line 832-833:
if let Some(existing) = self.pending_opt_proposals.get(&proposal_msg.round()) {
    let new_id = proposal_msg.block_data().hash();
    let existing_id = existing.hash();
    ensure!(
        new_id == existing_id,
        "[OptProposal] Detected equivocating optimistic proposal for round {}: existing={}, new={}",
        proposal_msg.round(),
        existing_id,
        new_id
    );
    // Proposal already buffered, no need to insert again
    return Ok(());
}
self.pending_opt_proposals
    .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

This ensures that if a validator receives multiple different optimistic proposals for the same round, it detects the equivocation and can reject subsequent conflicting proposals.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating two different `OptBlockData` instances for the same round with different payloads
2. Sending them to validators in different orders via network simulation
3. Observing that validators buffer different proposals and vote for different blocks
4. Confirming that no QC is formed and the round times out

A full PoC would require setting up a test network with multiple validators and simulating network message delivery order variations, which is feasible using the existing test infrastructure in `consensus/src/round_manager_tests/`.

## Notes

The vulnerability is real and exploitable. All code evidence confirms:
- The BTreeMap buffering uses last-write-wins semantics with no duplicate detection
- Equivocation checks happen after buffering, when each validator has already committed to one proposal
- Network timing naturally causes different message delivery orders
- Optimistic proposals are unsigned, making it trivial to create multiple conflicting proposals

This represents a significant bypass of the unequivocal proposer election guarantee that the consensus protocol explicitly relies upon.

### Citations

**File:** consensus/src/round_manager.rs (L330-330)
```rust
    pending_opt_proposals: BTreeMap<Round, OptBlockData>,
```

**File:** consensus/src/round_manager.rs (L476-481)
```rust
        if let Some(opt_proposal) = self.pending_opt_proposals.remove(&new_round) {
            self.opt_proposal_loopback_tx
                .send(opt_proposal)
                .await
                .expect("Sending to a self loopback unbounded channel cannot fail");
        }
```

**File:** consensus/src/round_manager.rs (L825-833)
```rust
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

**File:** consensus/src/round_manager.rs (L843-875)
```rust
    async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
        let proposal = Block::new_from_opt(opt_block_data, hqc);
        observe_block(proposal.timestamp_usecs(), BlockStage::PROCESS_OPT_PROPOSAL);
        info!(
            self.new_log(LogEvent::ProcessOptProposal),
            block_author = proposal.author(),
            block_epoch = proposal.epoch(),
            block_round = proposal.round(),
            block_hash = proposal.id(),
            block_parent_hash = proposal.quorum_cert().certified_block().id(),
        );
        self.process_proposal(proposal).await
    }
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L20-28)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
/// Same as BlockData, without QC and with parent id
pub struct OptBlockData {
    pub epoch: u64,
    pub round: Round,
    pub timestamp_usecs: u64,
    pub parent: BlockInfo,
    pub block_body: OptBlockBody,
}
```

**File:** consensus/src/network.rs (L387-408)
```rust
    pub fn broadcast_without_self(&self, msg: ConsensusMsg) {
        fail_point!("consensus::send::any", |_| ());

        let self_author = self.author;
        let mut other_validators: Vec<_> = self
            .validators
            .get_ordered_account_addresses_iter()
            .filter(|author| author != &self_author)
            .collect();
        self.sort_peers_by_latency(&mut other_validators);

        counters::CONSENSUS_SENT_MSGS
            .with_label_values(&[msg.name()])
            .inc_by(other_validators.len() as u64);
        // Broadcast message over direct-send to all other validators.
        if let Err(err) = self
            .consensus_network_client
            .send_to_many(other_validators, msg)
        {
            warn!(error = ?err, "Error broadcasting message");
        }
    }
```

**File:** consensus/src/network.rs (L441-445)
```rust
    pub async fn broadcast_opt_proposal(&self, proposal_msg: OptProposalMsg) {
        fail_point!("consensus::send::broadcast_opt_proposal", |_| ());
        let msg = ConsensusMsg::OptProposalMsg(Box::new(proposal_msg));
        self.broadcast(msg).await
    }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L14-21)
```rust
// Wrapper around ProposerElection.
//
// Provides is_valid_proposal that remembers, and rejects if
// the same leader proposes multiple blocks.
pub struct UnequivocalProposerElection {
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    already_proposed: Mutex<(Round, HashValue)>,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```

**File:** consensus/consensus-types/src/block.rs (L410-417)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```
