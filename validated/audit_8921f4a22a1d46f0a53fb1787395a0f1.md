# Audit Report

## Title
CPU Exhaustion via Duplicate CommitVotes with Unfiltered Invalid Signatures

## Summary
A Byzantine validator can inject invalid BLS signatures that pass optimistic verification. When `BufferItem` is in the `Signed` state, the `try_advance_to_aggregated()` method clones the signature aggregator before verification, causing expensive individual signature verification to run repeatedly on the same invalid signatures without ever filtering them from the original aggregator. This leads to CPU exhaustion affecting validator performance.

## Finding Description

The vulnerability occurs in the consensus pipeline's signature aggregation logic, specifically when `BufferItem` is in the `Signed` state.

**Step 1: Invalid Signatures Pass Optimistic Verification**

When a `CommitVote` arrives, its `verify()` method calls `optimistic_verify()` which only checks if the author is a known validator without cryptographically verifying the signature: [1](#0-0) [2](#0-1) 

If optimistic verification is enabled (default) and the author is not in the `pessimistic_verify_set`, invalid signatures are accepted without cryptographic verification.

**Step 2: Signatures Accumulate in Aggregator**

The invalid signatures are added to the `SignatureAggregator` via `add_signature_if_matched()`: [3](#0-2) 

**Step 3: Vote Triggers Aggregation Attempt**

Each received vote triggers `try_advance_to_aggregated()` in the buffer manager: [4](#0-3) 

**Step 4: Critical Bug - Clone Without Filter Propagation**

For `Signed` items, `try_advance_to_aggregated()` clones the aggregator before calling `aggregate_and_verify()`: [5](#0-4) 

Note that the clone occurs at line 306-307, and if verification fails, the method returns the original `signed_item` at line 319 with unfiltered signatures.

**Step 5: Expensive Filtering on Clone Only**

When `aggregate_and_verify()` detects invalid signatures, it calls `filter_invalid_signatures()` which performs expensive individual BLS signature verification: [6](#0-5) [7](#0-6) 

The filtering uses parallel verification (line 295) which is computationally expensive, but crucially, this filtering only affects the **cloned** aggregator, not the original.

**Step 6: Voting Power Check Doesn't Validate**

The `check_voting_power()` method only counts voting power without validating signatures: [8](#0-7) [9](#0-8) 

This means invalid signatures count toward the voting power threshold, causing repeated aggregation attempts.

**Attack Path:**

1. Byzantine validator sends `CommitVote` with invalid BLS signature
2. Passes `optimistic_verify()` (only checks author is known validator)
3. Added to `SignatureAggregator` in `Signed` buffer item
4. `check_voting_power()` counts it (doesn't validate), threshold may be met
5. New vote arrives, triggers `try_advance_to_aggregated()`
6. Aggregator cloned, `aggregate_and_verify()` called on clone
7. Verification fails, `filter_invalid_signatures()` runs (expensive BLS operations on ALL signatures)
8. Invalid signatures filtered from clone, but original unchanged
9. Returns original `Signed` item with invalid signatures still present
10. Repeat steps 5-9 for every subsequent vote (including duplicates from reliable broadcast retries)

**Why This Doesn't Affect Executed Items:**

For comparison, `Executed` items call `aggregate_and_verify()` directly without cloning: [10](#0-9) 

Note line 333 calls `aggregate_and_verify()` directly on `executed_item.partial_commit_proof` without cloning, so filtering mutates the original aggregator.

## Impact Explanation

**High Severity** - This vulnerability causes validator node slowdowns, which qualifies for the High Severity category (up to $50,000) per the Aptos bug bounty program.

**Resource Exhaustion Calculation:**
- With f Byzantine validators, up to f invalid signatures can accumulate before detection
- Each subsequent vote from the 2f+1 honest validators triggers expensive verification
- BLS signature verification involves pairing operations (cryptographically expensive)
- Parallel verification overhead across multiple cores
- Total operations: O(f Ã— number_of_subsequent_votes)

With reliable broadcast retry mechanisms generating duplicates and multiple Byzantine validators, this creates sustained CPU load that slows consensus progress, delays block finalization, and reduces network throughput.

**Test Configuration Confirms Default Behavior:** [11](#0-10) 

## Likelihood Explanation

**High Likelihood:**

1. **Normal Operation Affected**: Every validator enters `Signed` state after executing blocks - this is not an edge case: [12](#0-11) 

2. **Byzantine Validators Expected**: AptosBFT's threat model explicitly tolerates up to f Byzantine validators

3. **Optimistic Verification Enabled by Default**: Standard configuration allows unverified signatures through initially

4. **Natural Duplicate Generation**: Reliable broadcast mechanisms include retry logic with exponential backoff that naturally generates duplicate message processing

5. **Low Detection Threshold**: A single Byzantine validator can inject one invalid signature before being added to `pessimistic_verify_set`, but that signature persists in the original aggregator

## Recommendation

**Fix the Clone Issue**: Modify `try_advance_to_aggregated()` for `Signed` items to either:

**Option 1**: Call `aggregate_and_verify()` on the original aggregator without cloning:
```rust
Self::Signed(mut signed_item) => {
    if signed_item
        .partial_commit_proof
        .check_voting_power(validator, true)
        .is_ok()
    {
        if let Ok(commit_proof) = signed_item
            .partial_commit_proof  // Remove .clone()
            .aggregate_and_verify(validator)
            .map(|(ledger_info, aggregated_sig)| {
                LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
            })
        {
            return Self::Aggregated(Box::new(AggregatedItem {
                executed_blocks: signed_item.executed_blocks,
                commit_proof,
            }));
        }
    }
    Self::Signed(signed_item)
},
```

**Option 2**: If cloning is necessary for other reasons, propagate the filtered results back to the original:
```rust
// After aggregate_and_verify fails on clone, update original with filtered signatures
signed_item.partial_commit_proof = cloned_proof;
```

This ensures invalid signatures are removed from the original aggregator after detection, preventing repeated expensive verification operations.

## Proof of Concept

The existing test suite demonstrates the vulnerability pattern: [13](#0-12) 

This test shows that after invalid signatures fail verification (lines 703, 727), the `pessimistic_verify_set` is updated (lines 721, 745), but the test doesn't verify whether the original aggregator still contains invalid signatures. The vulnerability would be exposed by adding assertions that check if subsequent calls to `try_advance_to_aggregated()` still trigger filtering operations for the same invalid signatures.

## Notes

- This vulnerability **only affects `Signed` items**, not `Executed` items, due to the cloning behavior difference
- The `pessimistic_verify_set` mechanism prevents **new** invalid signatures from the same author after detection, but doesn't remove **existing** invalid signatures from the original aggregator
- Each Byzantine validator can inject one invalid signature before detection, and with f Byzantine validators, this creates O(f) persistent invalid signatures that cause repeated expensive verification on every subsequent vote

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** types/src/validator_verifier.rs (L453-460)
```rust
    pub fn check_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let aggregated_voting_power = self.sum_voting_power(authors)?;
        self.check_aggregated_voting_power(aggregated_voting_power, check_super_majority)
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L296-319)
```rust
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
```

**File:** consensus/src/pipeline/buffer_item.rs (L321-344)
```rust
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
```

**File:** consensus/src/pipeline/buffer_item.rs (L401-405)
```rust
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L488-489)
```rust
        validator_verifier.set_optimistic_sig_verification_flag(true);
        (validator_signers, validator_verifier)
```

**File:** consensus/src/pipeline/buffer_item.rs (L609-758)
```rust
    fn test_buffer_item_bad_path_1() {
        let (validator_signers, validator_verifier) = create_validators();
        let pipelined_block = create_pipelined_block();
        let block_info = pipelined_block.block_info();
        let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
        let ordered_proof =
            LedgerInfoWithSignatures::new(ledger_info.clone(), AggregateSignature::empty());
        let mut commit_votes =
            create_valid_commit_votes(validator_signers.clone(), ledger_info.clone());

        // Corrupting commit_votes[3], commit_votes[5]
        commit_votes[3] = CommitVote::new_with_signature(
            validator_signers[3].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );
        commit_votes[5] = CommitVote::new_with_signature(
            validator_signers[5].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let mut partial_signatures = BTreeMap::new();
        partial_signatures.insert(
            validator_signers[0].author(),
            commit_votes[0].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[1].author(),
            commit_votes[1].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[2].author(),
            commit_votes[2].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[4].author(),
            commit_votes[4].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[6].author(),
            commit_votes[6].signature().clone(),
        );
        let li_with_sig = validator_verifier
            .aggregate_signatures(partial_signatures.iter())
            .unwrap();
        let commit_proof = LedgerInfoWithSignatures::new(ledger_info.clone(), li_with_sig);

        let mut cached_commit_votes = HashMap::new();
        cached_commit_votes.insert(commit_votes[0].author(), commit_votes[0].clone());
        cached_commit_votes.insert(commit_votes[1].author(), commit_votes[1].clone());
        let mut ordered_item = BufferItem::new_ordered(
            vec![pipelined_block.clone()],
            ordered_proof.clone(),
            cached_commit_votes,
        );

        ordered_item
            .add_signature_if_matched(commit_votes[2].clone())
            .unwrap();
        ordered_item
            .add_signature_if_matched(commit_votes[3].clone())
            .unwrap();

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 0);
        let mut executed_item = ordered_item.advance_to_executed_or_aggregated(
            vec![pipelined_block.clone()],
            &validator_verifier,
            None,
            true,
        );

        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }

        executed_item
            .add_signature_if_matched(commit_votes[4].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[3] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);

        executed_item
            .add_signature_if_matched(commit_votes[5].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[5] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 2);

        executed_item
            .add_signature_if_matched(commit_votes[6].clone())
            .unwrap();
        let aggregated_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match aggregated_item {
            BufferItem::Aggregated(aggregated_item_inner) => {
                assert_eq!(aggregated_item_inner.executed_blocks, vec![pipelined_block]);
                assert_eq!(aggregated_item_inner.commit_proof, commit_proof);
            },
            _ => panic!("Expected aggregated item."),
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L717-726)
```rust
            if item.is_executed() {
                // we have found the buffer item
                let mut signed_item = item.advance_to_signed(self.author, signature);
                let signed_item_mut = signed_item.unwrap_signed_mut();
                let commit_vote = signed_item_mut.commit_vote.clone();
                let commit_vote = Self::generate_commit_message(commit_vote);
                signed_item_mut.rb_handle = self
                    .do_reliable_broadcast(commit_vote)
                    .map(|handle| (Instant::now(), handle));
                self.buffer.set(&current_cursor, signed_item);
```

**File:** consensus/src/pipeline/buffer_manager.rs (L754-761)
```rust
                    let new_item = match item.add_signature_if_matched(vote) {
                        Ok(()) => {
                            let response =
                                ConsensusMsg::CommitMessage(Box::new(CommitMessage::Ack(())));
                            if let Ok(bytes) = protocol.to_bytes(&response) {
                                let _ = response_sender.send(Ok(bytes.into()));
                            }
                            item.try_advance_to_aggregated(&self.epoch_state.verifier)
```

**File:** types/src/ledger_info.rs (L488-495)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
