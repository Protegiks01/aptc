# Audit Report

## Title
Table Entry Count Overflow Enables Resource Exhaustion and Verification Bypass via Index Wraparound

## Summary
The Move binary format deserializer does not validate that table entry counts remain within `u16::MAX` (65,535), allowing attackers to craft modules with oversized tables that cause index wraparound during verification, resulting in resource exhaustion and validator slowdowns.

## Finding Description

The Move binary format architecture has a critical mismatch between deserialization and verification assumptions. The `Table::load` function reads entries based on byte count without validating entry count limits: [1](#0-0) 

The table size limit allows up to 4GB of data per table: [2](#0-1) 

During verification, the `DuplicationChecker` iterates through table lengths and performs unchecked casts to `u16`. In struct handle verification, this causes wraparound when the table exceeds 65,535 entries: [3](#0-2) 

The same wraparound pattern appears for function handles: [4](#0-3) 

While index constants enforce `u16::MAX` limits for individual index references: [5](#0-4) 

The verification pipeline calls `DuplicationChecker` without gas metering: [6](#0-5) 

Unlike `CodeUnitVerifier` which uses `BoundMeter`: [7](#0-6) 

The production configuration does not limit struct or function definitions: [8](#0-7) 

**Attack Scenario:**
An attacker crafts bytecode with 100,000+ struct handles (~800KB at 8 bytes each). During verification, `DuplicationChecker` loops iterate O(n) times without metering. When the loop index exceeds 65,535, the `as u16` cast wraps (e.g., 65536 → 0, 65537 → 1), causing incorrect verification and significant CPU exhaustion on validator nodes.

## Impact Explanation

This vulnerability has **HIGH severity** per Aptos bug bounty criteria:

**1. Validator Node Slowdowns (HIGH):**
Verification loops iterate through all entries without gas metering. A module with 1 million struct handles (within the 4GB table size limit) causes 1 million loop iterations during `DuplicationChecker` execution. This results in significant CPU exhaustion on validator nodes, directly affecting block production timing and network liveness. This matches the "Validator node slowdowns" HIGH severity category in the Aptos bug bounty program.

**2. Protocol Violation (MEDIUM):**
Violates the architectural invariant that table indices fit in `u16`. The index wraparound at line 299 of `check_duplication.rs` causes `StructHandleIndex(0)` to be created when iterating at position 65536, leading to incorrect verification logic. However, these wrapped handles cannot be referenced from bytecode instructions, which enforce index limits during deserialization.

**3. Potential DoS Vector:**
Multiple malicious modules could be published to systematically degrade validator performance, though this must be balanced against gas costs for module publication.

Note: The verification code executes deterministically across all validators, so consensus divergence is not a demonstrated impact.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements:** Ability to publish modules (standard transaction capability available to any user)
- **Technical Complexity:** Moderate - requires crafting raw bytecode to bypass compiler limits, but the binary format is well-documented
- **Economic Barrier:** Module publication gas costs provide some deterrent, though insufficient for large-scale attacks
- **Detection:** Oversized tables are not flagged during deserialization; no upstream validation catches this condition

## Recommendation

Implement entry count validation during table deserialization:

1. **Immediate fix**: Add validation in `Table::load` to reject tables with more than `u16::MAX` entries
2. **Proper fix**: Enforce entry count limits during table deserialization in `read_table` or `check_tables` functions
3. **Defense in depth**: Add metering to `DuplicationChecker` to prevent resource exhaustion regardless of table size
4. **Configuration**: Consider setting `max_struct_definitions` and `max_function_definitions` in production config as an additional safeguard

Example fix location: [9](#0-8) 

Add entry count validation before the iteration loop to ensure the number of deserialized entries does not exceed architectural limits.

## Proof of Concept

While a full PoC requires bytecode generation tools, the vulnerability can be demonstrated by:

1. Creating a custom binary module with a struct handles table containing 100,000 entries (each ~10 bytes = ~1MB total)
2. Submitting this module via module publishing transaction
3. Observing the verification phase where `DuplicationChecker::verify_module` iterates through all 100,000 entries
4. Measuring the CPU time consumed during verification (O(n) iterations without metering)
5. Noting the index wraparound behavior when iteration reaches position 65,536+

The exploit path is: Module Publishing Transaction → Deserializer → Verification Pipeline → `DuplicationChecker` → Resource Exhaustion

## Notes

- The vulnerability affects both struct handles and function handles verification
- The metering bug at line 115 of `meter.rs` (using `max_per_fun_meter_units` instead of `max_per_mod_meter_units` for module bounds) is a separate issue that compounds the problem
- Individual index references within bytecode are properly validated during deserialization, preventing exploitation beyond verification-time resource exhaustion

### Citations

**File:** third_party/move/move-binary-format/src/deserializer.rs (L573-589)
```rust
impl Table {
    /// Generic function to deserialize a table into a vector of given type.
    fn load<T>(
        &self,
        binary: &VersionedBinary,
        result: &mut Vec<T>,
        deserializer: impl Fn(&mut VersionedCursor) -> BinaryLoaderResult<T>,
    ) -> BinaryLoaderResult<()> {
        let start = self.offset as usize;
        let end = start + self.count as usize;
        let mut cursor = binary.new_cursor(start, end);
        while cursor.position() < self.count as u64 {
            result.push(deserializer(&mut cursor)?)
        }
        Ok(())
    }
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L40-40)
```rust
pub const TABLE_SIZE_MAX: u64 = 0xFFFF_FFFF;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-59)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const ADDRESS_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const IDENTIFIER_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const MODULE_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_DEF_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FUNCTION_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FUNCTION_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FIELD_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const FIELD_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const VARIANT_FIELD_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const VARIANT_FIELD_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_DEF_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const CONSTANT_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_VARIANT_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_VARIANT_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```

**File:** third_party/move/move-bytecode-verifier/src/check_duplication.rs (L298-302)
```rust
        if let Some(idx) = (0..self.module.struct_handles().len()).position(|x| {
            let y = StructHandleIndex::new(x as u16);
            self.module.struct_handle_at(y).module == self.module.self_handle_idx()
                && !implemented_struct_handles.contains(&y)
        }) {
```

**File:** third_party/move/move-bytecode-verifier/src/check_duplication.rs (L379-383)
```rust
        if let Some(idx) = (0..self.module.function_handles().len()).position(|x| {
            let y = FunctionHandleIndex::new(x as u16);
            self.module.function_handle_at(y).module == self.module.self_handle_idx()
                && !implemented_function_handles.contains(&y)
        }) {
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L148-148)
```rust
        DuplicationChecker::verify_module(module)?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L50-50)
```rust
        let mut meter = BoundMeter::new(verifier_config);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```
