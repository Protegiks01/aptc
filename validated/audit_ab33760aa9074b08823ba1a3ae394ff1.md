# Audit Report

## Title
ValidatorTransaction Deduplication Bypass Enabling Block Execution Failure via Duplicate DKG Transactions

## Summary
A malicious or buggy block proposer can include duplicate DKG ValidatorTransaction entries in a single block, which pass consensus validation but trigger a race condition in parallel execution, causing fatal block execution failures that waste validator resources and disrupt consensus liveness.

## Finding Description

The vulnerability exists due to a combination of three factors:

**1. Missing Deduplication for ValidatorTransactions**

The transaction deduplication mechanism only processes `SignedTransaction` types, completely bypassing `ValidatorTransaction` instances: [1](#0-0) 

**2. No Duplicate Detection in Proposal Validation**

The `process_proposal` function validates each ValidatorTransaction individually (type check, signature verification, count/size limits) but does not check for duplicates within the same proposal: [2](#0-1) 

**3. Race Condition in Parallel Execution**

When duplicate DKG transactions execute in parallel mode (default configuration with `concurrency_level=32`), a critical race condition occurs:

- **Transaction 1** (first DKG tx): Rust code reads `DKGState` (in_progress = Some) via `OnChainConfig::fetch_config`, passes validation, calls Move function `dkg::finish()`, which successfully sets `in_progress = None` and commits.

- **Transaction 2** (duplicate DKG tx): Rust code reads `DKGState` BEFORE Transaction 1 commits (sees in_progress = Some), passes the Rust-side validation check: [3](#0-2) 

However, by the time Transaction 2 calls the Move function `finish_with_dkg_result`, Transaction 1 has already committed. The Move code performs a SECOND read of `DKGState`, now seeing in_progress = None, causing the assertion to fail: [4](#0-3) 

This Move abort with `EDKG_NOT_IN_PROGRESS` is not in the list of "Expected" failures: [5](#0-4) 

**4. Fatal Error Propagation**

The Move abort propagates through `expect_only_successful_execution`, which converts ANY unexpected Move abort into an `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` error: [6](#0-5) 

This returns `Err(VMStatus)`, which becomes `ExecutionStatus::Abort(err)`: [7](#0-6) 

Finally, this causes a `FatalVMError` that halts block execution: [8](#0-7) 

## Impact Explanation

**Severity: High**

This vulnerability aligns with Aptos Bug Bounty **High Severity** criteria for "Validator node slowdowns":

1. **Wasted Computational Resources**: Validators execute blocks that cannot complete, wasting CPU cycles and delaying block production
2. **Consensus Liveness Degradation**: Repeated invalid blocks slow chain progress, especially if multiple validators (maliciously or due to bugs) produce such blocks
3. **Deterministic Execution Violation**: Blocks that pass consensus validation fail unexpectedly during execution, breaking the invariant that all validators should successfully execute agreed-upon blocks

The impact is **not Critical** because:
- Sequential fallback exists (line 2600 in executor.rs) - blocks can eventually execute correctly
- Does not cause permanent network partition or fund loss
- Requires probabilistic selection as block proposer
- Recoverable through normal consensus progression

## Likelihood Explanation

**Likelihood: Medium**

**Attack Requirements:**
- Attacker must be a validator (validators are untrusted actors per Aptos threat model)
- Must be selected as block proposer (probability = 1/validator_count)
- Must have access to valid DKG transcript (only during DKG phases)

**Exploitation Complexity: Low**
- Attack is trivial: simply include duplicate ValidatorTransaction in block proposal
- No complex timing or state manipulation required
- Passes all consensus validation checks

**Real-World Scenarios:**
1. **Malicious Validator**: Intentionally disrupts consensus by proposing blocks with duplicates
2. **Buggy Implementation**: Proposal generation logic accidentally includes duplicates (higher probability)
3. **Coordinated Disruption**: Multiple compromised validators degrade network liveness

The vulnerability is MORE likely to manifest accidentally than intentionally, increasing practical risk.

## Recommendation

Implement duplicate detection for ValidatorTransactions in `process_proposal`:

```rust
// In consensus/src/round_manager.rs, after line 1137, add:
let mut seen_vtxns = HashSet::new();
for vtxn in vtxns {
    let vtxn_hash = vtxn.hash(); // Or appropriate unique identifier
    ensure!(
        seen_vtxns.insert(vtxn_hash),
        "Duplicate ValidatorTransaction detected in proposal: {:?}",
        vtxn.type_name()
    );
    // ... existing validation code
}
```

Alternative: Add the duplicate check to the Expected failures list in `dkg.rs` to gracefully handle the race condition, though prevention at proposal validation is preferable.

## Proof of Concept

A malicious validator as block proposer can:

1. Obtain a valid DKG transcript during a DKG phase
2. Create a `ValidatorTransaction::DKGResult` with the transcript
3. Construct a block proposal containing the same DKG transaction twice
4. Submit the proposal to consensus

The block will pass `process_proposal` validation (each transaction validates individually) but fail during parallel execution when both transactions race, causing the second to abort with `EDKG_NOT_IN_PROGRESS`, triggering `FatalVMError`.

Testing on current mainnet configuration (concurrency_level=32) would demonstrate the race condition occurs reliably enough to cause execution failures before sequential fallback.

## Notes

The vulnerability specifically affects **parallel execution mode**, which is the default configuration. Sequential execution would safely discard the duplicate transaction as an "Expected" error because state updates from the first transaction would be visible before the second executes. However, the parallel execution path is the primary concern as it's the default and most common execution mode in production.

### Citations

**File:** consensus/src/transaction_deduper.rs (L10-11)
```rust
pub trait TransactionDeduper: Send + Sync {
    fn dedup(&self, txns: Vec<SignedTransaction>) -> Vec<SignedTransaction>;
```

**File:** consensus/src/round_manager.rs (L1126-1137)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L34-44)
```rust
enum ExpectedFailure {
    // Move equivalent: `errors::invalid_argument(*)`
    EpochNotCurrent = 0x10001,
    TranscriptDeserializationFailed = 0x10002,
    TranscriptVerificationFailed = 0x10003,

    // Move equivalent: `errors::invalid_state(*)`
    MissingResourceDKGState = 0x30001,
    MissingResourceInprogressDKGSession = 0x30002,
    MissingResourceConfiguration = 0x30003,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L96-97)
```rust
        let in_progress_session_state =
            in_progress.ok_or(Expected(MissingResourceInprogressDKGSession))?;
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L90-92)
```text
    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));
```

**File:** aptos-move/aptos-vm/src/errors.rs (L275-304)
```rust
pub fn expect_only_successful_execution(
    error: VMError,
    function_name: &str,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let status = error.into_vm_status();
    Err(match status {
        VMStatus::Executed => VMStatus::Executed,
        // Speculative errors are returned for caller to handle.
        e @ VMStatus::Error {
            status_code:
                StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR
                | StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR,
            ..
        } => e,
        status => {
            // Only trigger a warning here as some errors could be a result of the speculative parallel execution.
            // We will report the errors after we obtained the final transaction output in update_counters_for_processed_chunk
            let err_msg = format!(
                "[aptos_vm] Unexpected error from known Move function, '{}'. Error: {:?}",
                function_name, status
            );
            speculative_warn!(log_context, err_msg.clone());
            VMStatus::Error {
                status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                sub_status: status.sub_status(),
                message: Some(err_msg),
            }
        },
    })
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L99-115)
```rust
            // execute_single_transaction only returns an error when transactions that should never fail
            // (BlockMetadataTransaction and GenesisTransaction) return an error themselves.
            Err(err) => {
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
            },
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```
