# Audit Report

## Title
Aggregator Delta Writes Bypass I/O Gas Charging Leading to Undercharged State Modifications

## Summary
The `charge_change_set()` function in AptosVM does not charge I/O gas for aggregator v1 delta operations, allowing transactions to perform state modifications without paying the full gas cost. This bypasses the standard I/O gas metering for write operations worth approximately 89,568+ internal gas units per aggregator write.

## Finding Description

The vulnerability exists in the gas charging mechanism for change sets containing aggregator operations. When a transaction executes and modifies aggregators (used extensively in framework code for coin supply tracking, token collections, etc.), these modifications are stored as "deltas" in the `aggregator_v1_delta_set` rather than immediate writes. [1](#0-0) 

The `charge_change_set()` function iterates over `write_set_size_iter()` to charge I/O gas for each write operation: [2](#0-1) 

However, the `write_set_size_iter()` implementation only includes `resource_write_set` and `aggregator_v1_write_set`, completely omitting `aggregator_v1_delta_set`: [3](#0-2) 

This means aggregator delta operations avoid I/O gas charges entirely. The TODO comment explicitly acknowledges this missing charge: [4](#0-3) 

These deltas are later materialized into actual write operations after gas has already been finalized: [5](#0-4) [6](#0-5) 

**Attack Path:**
1. Attacker submits transaction calling framework functions that perform aggregator operations (e.g., `coin::mint`, `coin::burn`, token supply operations)
2. Each aggregator operation creates a delta in `aggregator_v1_delta_set`
3. During `charge_change_set()`, these deltas are not included in I/O gas calculation
4. Transaction completes with undercharged gas
5. Deltas are materialized into writes post-transaction without additional charging
6. Attacker saves I/O gas costs per aggregator operation

**Exploitability via Framework Functions:**

User transactions can trigger aggregator operations through public entry functions: [7](#0-6) [8](#0-7) 

These functions call into the coin framework which uses aggregators for supply tracking: [9](#0-8) [10](#0-9) 

Which trigger aggregator delta operations: [11](#0-10) [12](#0-11) 

## Impact Explanation

This vulnerability constitutes a **Medium Severity** issue under the Aptos bug bounty program's "Limited funds loss or manipulation" category.

**Quantified Impact:**
- Each aggregator write should incur I/O gas costs based on the current gas schedule: [13](#0-12) [14](#0-13) 

- For a typical aggregator (u128 = 16 bytes + key overhead ~50-80 bytes), the bypassed I/O gas per operation is approximately **95,000-96,000 internal gas units**
- A transaction performing N aggregator operations saves N × ~95,000 gas units
- At current gas prices, this represents tangible APT token savings per transaction
- Across many transactions, this accumulates to significant economic value extraction from the network

**Broken Invariants:**
- **Resource Limits Invariant**: "All operations must respect gas, storage, and computational limits" - violated because aggregator writes bypass I/O gas limits, allowing more operations than should be permitted for a given gas budget
- **Economic Security**: Validators are not properly compensated for the computational and storage resources consumed by aggregator operations

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence because:

1. **No special privileges required**: Any user with mint/burn capabilities for their tokens can trigger this through standard framework functions
2. **Common operations affected**: Coin minting/burning and token operations are frequent on-chain activities
3. **Natural usage pattern**: Developers using aggregators for parallelism optimization automatically benefit from this undercharging without realizing it
4. **Already happening**: The TODO comment indicates developers are aware but haven't fixed it, meaning current mainnet transactions are already undercharged
5. **Easy to exploit**: Simply call existing framework functions like `managed_coin::mint` or `managed_coin::burn`; no complex attack construction needed
6. **Multiple entry points**: Various framework modules expose entry functions that trigger aggregator operations (coin framework, fungible assets, token collections)

## Recommendation

The fix should charge I/O gas for aggregator v1 delta operations. This can be implemented by:

1. **Option A**: Include `aggregator_v1_delta_set` in the `write_set_size_iter()` implementation to charge for deltas at the same time as regular writes
2. **Option B**: Add a separate loop in `charge_change_set()` to iterate over and charge for delta operations before materialization
3. **Option C**: Accelerate the migration to Aggregator V2 (which uses delayed fields) and deprecate Aggregator V1 entirely

The most straightforward fix would be to extend `write_set_size_iter()` to include aggregator deltas, treating them as write operations for gas charging purposes.

## Proof of Concept

While a complete end-to-end PoC would require a full test environment, the vulnerability can be demonstrated through the following Move test scenario:

1. Deploy a custom coin type with monitored supply (enabling aggregator usage)
2. Initialize `managed_coin` with the custom coin type
3. Call `managed_coin::mint` multiple times in a single transaction
4. Observe that gas charged does not include I/O gas for the aggregator delta operations created by supply updates
5. Compare with equivalent transactions that modify regular resources without aggregators

The gas savings can be measured by comparing:
- Gas charged for transaction with N aggregator operations
- Expected gas = base gas + (N × 89,568) for I/O
- Actual savings = Expected gas - Charged gas

## Notes

This vulnerability specifically affects Aggregator V1, which is marked as deprecated in the codebase with multiple TODO comments indicating cleanup is planned. However, Aggregator V1 remains in active use on mainnet for coin supply tracking and other framework operations. The TODO comment at line 1158 of `aptos_vm.rs` explicitly acknowledges that charging for aggregator writes needs to be fixed, confirming this is a known but unresolved issue rather than intentional behavior.

The vulnerability also affects storage fee charging via `process_storage_fee_for_all()`, which uses `write_op_info_iter_mut()` that similarly excludes aggregator deltas: [15](#0-14) 

This means aggregator delta operations bypass both I/O gas charges and storage fee charges, compounding the economic impact.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L89-92)
```rust
    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L367-399)
```rust
    pub fn try_materialize_aggregator_v1_delta_set(
        &mut self,
        resolver: &impl AggregatorV1Resolver,
    ) -> VMResult<()> {
        let into_write =
            |(state_key, delta): (StateKey, DeltaOp)| -> VMResult<(StateKey, WriteOp)> {
                // Materialization is needed when committing a transaction, so
                // we need precise mode to compute the true value of an
                // aggregator.
                let write = resolver
                    .try_convert_aggregator_v1_delta_into_write_op(&state_key, &delta)
                    .map_err(|e| {
                        // We need to set abort location for Aggregator V1 to ensure correct VMStatus can
                        // be constructed.
                        const AGGREGATOR_V1_ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
                        const AGGREGATOR_V1_MODULE_NAME: &IdentStr = ident_str!("aggregator");
                        e.finish(Location::Module(ModuleId::new(
                            AGGREGATOR_V1_ADDRESS,
                            AGGREGATOR_V1_MODULE_NAME.into(),
                        )))
                    })?;
                Ok((state_key, write))
            };

        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L862-871)
```rust
    fn write_set_size_iter(&self) -> impl Iterator<Item = (&StateKey, WriteOpSize)> {
        self.resource_write_set()
            .iter()
            .map(|(k, v)| (k, v.materialized_size()))
            .chain(
                self.aggregator_v1_write_set()
                    .iter()
                    .map(|(k, v)| (k, v.write_op_size())),
            )
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L873-903)
```rust
    fn write_op_info_iter_mut<'a>(
        &'a mut self,
        executor_view: &'a dyn ExecutorView,
        _module_storage: &'a impl AptosModuleStorage,
        fix_prev_materialized_size: bool,
    ) -> impl Iterator<Item = PartialVMResult<WriteOpInfo<'a>>> {
        let resources = self.resource_write_set.iter_mut().map(move |(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.materialized_size(),
                prev_size: op.prev_materialized_size(
                    key,
                    executor_view,
                    fix_prev_materialized_size,
                )?,
                metadata_mut: op.metadata_mut(),
            })
        });
        let v1_aggregators = self.aggregator_v1_write_set.iter_mut().map(|(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.write_op_size(),
                prev_size: executor_view
                    .get_aggregator_v1_state_value_size(key)?
                    .unwrap_or(0),
                metadata_mut: op.metadata_mut(),
            })
        });

        resources.chain(v1_aggregators)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1098-1098)
```rust
        // ============= Gas fee cannot change after this line =============
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1124-1126)
```rust
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1158-1158)
```rust
        // TODO[agg_v1](fix): Charge for aggregator writes
```

**File:** aptos-move/framework/aptos-framework/sources/managed_coin.move (L37-52)
```text
    public entry fun burn<CoinType>(
        account: &signer,
        amount: u64,
    ) acquires Capabilities {
        let account_addr = signer::address_of(account);

        assert!(
            exists<Capabilities<CoinType>>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let capabilities = borrow_global<Capabilities<CoinType>>(account_addr);

        let to_burn = coin::withdraw<CoinType>(account, amount);
        coin::burn(to_burn, &capabilities.burn_cap);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/managed_coin.move (L79-94)
```text
    public entry fun mint<CoinType>(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires Capabilities {
        let account_addr = signer::address_of(account);

        assert!(
            exists<Capabilities<CoinType>>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let capabilities = borrow_global<Capabilities<CoinType>>(account_addr);
        let coins_minted = coin::mint(amount, &capabilities.mint_cap);
        coin::deposit(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1220-1220)
```text
            optional_aggregator::add(supply, (amount as u128));
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1238-1238)
```text
                optional_aggregator::sub(supply, (amount as u128));
```

**File:** aptos-move/framework/aptos-framework/sources/aggregator/optional_aggregator.move (L124-132)
```text
    public fun add(optional_aggregator: &mut OptionalAggregator, value: u128) {
        if (option::is_some(&optional_aggregator.aggregator)) {
            let aggregator = option::borrow_mut(&mut optional_aggregator.aggregator);
            aggregator::add(aggregator, value);
        } else {
            let integer = option::borrow_mut(&mut optional_aggregator.integer);
            add_integer(integer, value);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aggregator/optional_aggregator.move (L135-143)
```text
    public fun sub(optional_aggregator: &mut OptionalAggregator, value: u128) {
        if (option::is_some(&optional_aggregator.aggregator)) {
            let aggregator = option::borrow_mut(&mut optional_aggregator.aggregator);
            aggregator::sub(aggregator, value);
        } else {
            let integer = option::borrow_mut(&mut optional_aggregator.integer);
            sub_integer(integer, value);
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L108-116)
```rust
            storage_io_per_state_slot_write: InternalGasPerArg,
            { 0..=9 => "write_data.per_op", 10.. => "storage_io_per_state_slot_write"},
            // The cost of writing down the upper level new JMT nodes are shared between transactions
            // because we write down the JMT in batches, however the bottom levels will be specific
            // to each transactions assuming they don't touch exactly the same leaves. It's fair to
            // target roughly 1-2 full internal JMT nodes (about 0.5-1KB in total) worth of writes
            // for each write op.
            89_568,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L123-126)
```rust
            storage_io_per_state_byte_write: InternalGasPerByte,
            { 0..=9 => "write_data.per_byte_in_key", 10.. => "storage_io_per_state_byte_write"},
            89,
        ],
```
