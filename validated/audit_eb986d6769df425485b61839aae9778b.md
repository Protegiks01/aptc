# Audit Report

## Title
Consensus Observer Verification Failure Due to Inconsistent Expired Batch Handling in OptQuorumStore Payloads

## Summary
A critical inconsistency exists between how the consensus publisher and consensus observer handle expired batches in OptQuorumStore payloads. The publisher filters out transactions from expired optimistic batches but includes their batch infos in the payload, while the observer attempts to reconstruct all batches without skipping expired ones, causing verification to fail for valid blocks.

## Finding Description

The vulnerability stems from divergent handling of expired batches between the publisher and observer components.

**Publisher Behavior:**

When QuorumStorePayloadManager processes OptQuorumStore payloads, the `request_transactions()` function explicitly filters out expired batches during transaction retrieval. [1](#0-0) 

This filtering prevents transactions from expired opt batches from being fetched. The `process_optqs_payload()` function calls this filtered transaction request for opt batches. [2](#0-1) 

However, when creating the BlockTransactionPayload, the publisher includes ALL batch infos from the original payload, regardless of expiration status. [3](#0-2) 

**Observer Behavior:**

When the observer receives the BlockPayload and calls `verify_payload_digests()`, it processes payload proofs with `skip_expired_batches = true` but processes opt/inline batches with `skip_expired_batches = false`. [4](#0-3) 

The `reconstruct_batch()` function only skips expired batches when the flag is true. [5](#0-4) 

When `skip_expired_batches = false`, the function attempts to consume transactions for all batches and fails if transactions are missing. [6](#0-5) 

**Execution Flow:**
1. Block contains OptQuorumStore payload with expired opt batches
2. Publisher filters expired opt batch transactions via `request_transactions()` 
3. Publisher includes all batch infos (including expired) in BlockTransactionPayload
4. Observer receives payload and calls `verify_payload_digests()`
5. Observer processes opt batches with `skip_expired_batches = false` 
6. `reconstruct_batch()` tries to consume transactions for expired batches
7. Verification fails with "Failed to extract transaction during batch reconstruction!"

The consensus observer rejects the block payload at this point. [7](#0-6) 

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty)

This vulnerability qualifies as a **Significant Protocol Violation** under HIGH severity because:

1. **Protocol Integrity Breach**: The consensus observer subsystem fails to correctly verify valid blocks, breaking the fundamental integrity of the observation mechanism that allows non-validator nodes to follow consensus.

2. **Denial of Service for Observers**: Observers receiving blocks with expired opt batches will continuously fail verification and cannot stay synchronized with consensus, effectively denying service to the observer infrastructure.

3. **Network Inconsistency Risk**: Different observers may have different views of which blocks are valid based on timing of payload receipt, creating inconsistent states across the observer network.

4. **Infrastructure Reliability Impact**: While this doesn't affect the main consensus protocol or validators directly, the consensus observer is a critical component for network scalability, light clients, and network monitoring. Its failure undermines the reliability of this entire subsystem.

This meets the HIGH severity criteria for "Significant Protocol Violations" as it breaks protocol-level guarantees in a production consensus infrastructure component.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability occurs naturally under normal network conditions when:
- Blocks contain OptQuorumStore payloads with opt batches
- Opt batches expire between block creation and observer verification (when `block_timestamp > batch_info.expiration()`)
- Network delays, processing latency, or system load create timing discrepancies

The likelihood increases with:
- Higher network latency
- Shorter batch expiration times  
- Heavy system load
- Frequent use of optimistic batches in payloads

Since optimistic batches are a standard quorum store feature and expiration is a built-in mechanism, this can occur naturally without any malicious actor, making it a realistic and recurring issue in production environments.

## Recommendation

The fix requires aligning the publisher and observer behavior for expired opt batches. Two possible approaches:

**Option 1: Filter batch infos on publisher side**
```rust
// In quorum_store_payload_manager.rs, around line 536
// Filter out expired opt batches when creating batch info list
let valid_opt_batches: Vec<BatchInfo> = opt_qs_payload
    .opt_batches()
    .iter()
    .filter(|batch| block.timestamp_usecs() <= batch.expiration())
    .cloned()
    .collect();

BlockTransactionPayload::new_opt_quorum_store(
    all_txns,
    opt_qs_payload.proof_with_data().deref().clone(),
    opt_qs_payload.max_txns_to_execute(),
    opt_qs_payload.block_gas_limit(),
    [valid_opt_batches, opt_qs_payload.inline_batches().batch_infos()].concat(),
)
```

**Option 2: Skip expired batches on observer side**
```rust
// In observer_message.rs, around line 914
// Change skip_expired_batches to true for opt batches
match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, true) {
    Ok(Some(batch_transactions)) => {
        batches_and_transactions.push((batch_info.clone(), batch_transactions));
    },
    Ok(None) => { /* Expired batch skipped, continue */ },
    // ... error handling
}
```

Option 1 is preferred as it prevents sending unnecessary batch info for expired batches, reducing message size and maintaining consistency with the actual transactions sent.

## Proof of Concept

```rust
// This PoC demonstrates the inconsistency by showing that:
// 1. Publisher filters expired opt batches from transactions
// 2. Publisher includes expired opt batches in batch infos
// 3. Observer fails when trying to reconstruct expired batches

#[test]
fn test_expired_opt_batch_inconsistency() {
    // Setup: Create an OptQuorumStore payload with an expired opt batch
    let block_timestamp = 1000;
    let expired_batch = create_batch_info(
        "expired_batch",
        10, // num_txns
        999, // expiration < block_timestamp
    );
    
    // Publisher side: request_transactions filters expired batches
    let batches = vec![(expired_batch.clone(), vec![])];
    let futures = QuorumStorePayloadManager::request_transactions(
        batches,
        block_timestamp,
        batch_reader,
    );
    
    // Verify: No futures created for expired batch (filtered out)
    assert_eq!(futures.len(), 0);
    
    // But BlockTransactionPayload includes the batch info
    let payload = BlockTransactionPayload::new_opt_quorum_store(
        vec![], // no transactions
        vec![],
        None,
        None,
        vec![expired_batch.clone()], // batch info included!
    );
    
    // Observer side: tries to reconstruct with skip_expired_batches = false
    let block_info = create_block_info(block_timestamp);
    let mut txn_iter = vec![].into_iter();
    
    // This will fail because skip_expired_batches = false
    let result = reconstruct_batch(
        &block_info,
        &mut txn_iter,
        &expired_batch,
        false, // skip_expired_batches = false
    );
    
    // Assertion: Reconstruction fails with missing transaction error
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Failed to extract transaction"));
}
```

## Notes

This vulnerability represents a genuine protocol inconsistency in the consensus observer subsystem. The core issue is that the publisher and observer have mismatched assumptions about whether expired opt batches should be included in payload verification. The publisher's `request_transactions()` correctly filters expired batches to avoid fetching stale data, but it fails to filter the corresponding batch infos, creating a mismatch with the observer's expectation that all listed batches will have transactions available for reconstruction.

The fix should ensure consistency: either both sides skip expired opt batches, or both sides include them. Given that expired batches are intentionally filtered on the publisher side for good reasons (avoiding stale data), the solution should be to also filter them from the batch info list or allow the observer to gracefully skip them during reconstruction.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L102-106)
```rust
            if block_timestamp <= batch_info.expiration() {
                futures.push(batch_reader.get_batch(batch_info, responders.clone()));
            } else {
                debug!("QSE: skipped expired batch {}", batch_info.digest());
            }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L512-519)
```rust
                let opt_batch_txns = process_optqs_payload(
                    opt_qs_payload.opt_batches(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    block_signers.as_ref(),
                )
                .await?;
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L530-540)
```rust
                BlockTransactionPayload::new_opt_quorum_store(
                    all_txns,
                    opt_qs_payload.proof_with_data().deref().clone(),
                    opt_qs_payload.max_txns_to_execute(),
                    opt_qs_payload.block_gas_limit(),
                    [
                        opt_qs_payload.opt_batches().deref().clone(),
                        opt_qs_payload.inline_batches().batch_infos(),
                    ]
                    .concat(),
                )
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L890-932)
```rust
        for proof_of_store in &payload_proofs {
            match reconstruct_batch(
                &block_info,
                &mut transactions_iter,
                proof_of_store.info(),
                true,
            ) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions
                        .push((proof_of_store.info().clone(), batch_transactions));
                },
                Ok(None) => { /* Nothing needs to be done (the batch was expired) */ },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct payload proof batch! Num transactions: {:?}, \
                        num batches: {:?}, num inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, proof_of_store.info(), error
                    )));
                },
            }
        }

        // Gather the transactions for each inline batch
        for batch_info in opt_and_inline_batches.iter() {
            match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, false) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions.push((batch_info.clone(), batch_transactions));
                },
                Ok(None) => {
                    return Err(Error::UnexpectedError(format!(
                        "Failed to reconstruct inline/opt batch! Batch was unexpectedly skipped: {:?}",
                        batch_info
                    )));
                },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct inline/opt batch! Num transactions: {:?}, \
                        num batches: {:?}, num opt/inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, batch_info, error
                    )));
                },
            }
        }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L987-998)
```rust
fn reconstruct_batch(
    block_info: &BlockInfo,
    transactions_iter: &mut IntoIter<SignedTransaction>,
    expected_batch_info: &BatchInfo,
    skip_expired_batches: bool,
) -> Result<Option<Vec<SignedTransaction>>, Error> {
    // If the batch is expired we should skip reconstruction (as the
    // transactions for the expired batch won't be sent in the payload).
    // Note: this should only be required for QS batches (not inline batches).
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L1002-1015)
```rust
    for i in 0..expected_batch_info.num_txns() {
        let batch_transaction = match transactions_iter.next() {
            Some(transaction) => transaction,
            None => {
                return Err(Error::InvalidMessageError(format!(
                    "Failed to extract transaction during batch reconstruction! Batch: {:?}, transaction index: {:?}",
                    expected_batch_info, i
                )));
            },
        };
        batch_transactions.push(batch_transaction);
    }

    Ok(Some(batch_transactions))
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L386-397)
```rust
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }
```
