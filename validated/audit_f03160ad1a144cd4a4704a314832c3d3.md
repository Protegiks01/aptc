# Audit Report

## Title
Account Creation Fee Bypass via Out-of-Gas Storage Fee Accounting Inflation

## Summary
A gas accounting flaw allows attackers to create accounts while bypassing storage fee charges. When a transaction runs out of gas during storage fee charging in `finish_aborted_transaction()`, the `storage_fee_used` counter is incorrectly incremented even though no fee was deducted. This inflated value causes a verification check to pass while the epilogue only charges gas costs, not storage fees, resulting in underpriced account creation.

## Finding Description

The vulnerability arises from a discrepancy between storage fee accounting, verification logic, and actual fee collection across three components:

**1. Gas Meter Storage Fee Inflation**

When `charge_storage_fee()` encounters insufficient gas balance, it increments `storage_fee_used` by the full requested amount despite failing to deduct the fee: [1](#0-0) 

The critical issue occurs in the `None` branch (lines 282-290): when `feature_version >= 12`, line 287 increments `self.storage_fee_used += amount` even though the balance couldn't cover the charge and line 289 returns `OUT_OF_GAS` error.

**2. Verification Formula Uses Inflated Value**

In `finish_aborted_transaction()`, the verification check for account creation calculates the expected payment including the inflated storage fee: [2](#0-1) 

Line 767 calculates: `actual = gas_used * gas_unit_price + storage_fee - storage_refund`, adding the inflated `storage_fee` value from the fee statement created at line 757.

**3. Account Creation Flow**

The account creation process during transaction abort proceeds even when storage fee charging fails: [3](#0-2) 

Key steps:
- Line 706: Determines account should be created
- Lines 723-729: Account created with `UnmeteredGasMeter` if initial attempt fails
- Lines 743-754: `charge_change_set()` called to charge storage fees, but errors are only logged (lines 750-753), not handled
- Line 757: Fee statement created with inflated `storage_fee_used`

**4. Epilogue Charges Only Gas, Not Storage Fee**

The failure epilogue only charges gas consumption, not storage fees: [4](#0-3) 

Line 603 calculates `transaction_fee_amount = txn_gas_price * gas_used`, and line 622 burns only this amount minus storage refunds (which is 0 for aborted transactions per line 703 of aptos_vm.rs). The `storage_fee_used` value from the fee statement is never charged.

**Attack Scenario:**

1. Attacker crafts transaction with `sequence_number = 0` (triggering account creation), minimal `max_gas_amount` (e.g., 50,000 gas units - just enough for prologue), and minimum `gas_unit_price` (100 Octa/gas)

2. Transaction exhausts gas during execution

3. `finish_aborted_transaction()` determines account creation is needed and creates it with `UnmeteredGasMeter`

4. `charge_change_set()` attempts to charge storage fees via `charge_storage_fee()`, which fails with OUT_OF_GAS but increments `storage_fee_used` to the full account creation fee (~40,000-50,000 Octa based on storage parameters)

5. Verification check at line 767 calculates: `actual = 50,000 * 100 + 40,000 = 5,040,000 Octa` vs `expected ≈ 40,000 Octa` → passes

6. Epilogue charges user only `100 * 50,000 = 5,000,000 Octa` (gas cost), not the storage fee

7. Net result: User pays only gas cost, storage fee never collected

This breaks the invariant that "all operations must respect gas, storage, and computational limits" by allowing account creation without paying required storage fees.

## Impact Explanation

**Medium Severity** per Aptos Bug Bounty criteria: "Limited funds loss or manipulation"

- **Protocol Revenue Loss**: Storage fees are designed to disincentivize state bloat. The protocol loses intended storage fee revenue (40,000-50,000 Octa per account based on current gas parameters)

- **Storage Spam Vector**: Attackers can create accounts at significantly reduced cost (paying only gas, not storage fees), enabling mass account creation for storage spam attacks

- **Systematic Exploitation**: The attack is deterministic and repeatable - any user can craft transactions with calculated gas parameters to trigger the vulnerability

- **Limited Scope**: Does not result in direct fund theft or total loss of funds, but enables systematic undercharging that accumulates over many exploits

The impact qualifies as Medium severity because it involves "limited funds loss" (protocol loses storage fees per account created) and enables a form of protocol manipulation (bypassing intended economic incentives).

## Likelihood Explanation

**High Likelihood:**

- **No Special Privileges**: Any user can submit transactions with controlled gas parameters
- **Deterministic Exploit**: Once gas parameters are calculated, the exploit succeeds reliably
- **Always Active**: The vulnerability is active whenever `feature_version >= 12` (current version is 41) and account creation features are enabled
- **Simple Execution**: Requires only a single transaction with specific gas parameters
- **No Race Conditions**: Does not depend on timing, network conditions, or coordination with other transactions
- **Economically Viable**: The cost of exploitation (gas fees) is less than the savings (storage fees), providing positive economic incentive

The current gas feature version confirms the vulnerable code path is active: [5](#0-4) 

## Recommendation

**Fix Option 1 - Don't Inflate on Failure**: Modify `charge_storage_fee()` to NOT increment `storage_fee_used` when the charge fails:

```rust
None => {
    let old_balance = self.balance;
    self.balance = 0.into();
    if self.feature_version >= 12 {
        self.storage_fee_in_internal_units += old_balance;
        // Don't increment storage_fee_used when charge fails
        // self.storage_fee_used += amount;  // REMOVE THIS
    }
    return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
},
```

**Fix Option 2 - Enforce Proper Charging**: In `finish_aborted_transaction()`, if `charge_change_set()` fails, reject the transaction instead of just logging the error:

```rust
if let Err(err) = self.charge_change_set(
    &mut abort_hook_session_change_set,
    gas_meter,
    txn_data,
    resolver,
    module_storage,
) {
    return Err(err);  // Reject transaction instead of continuing
}
```

**Fix Option 3 - Adjust Verification**: Modify the verification to not include storage_fee when it wasn't actually charged, by checking if charge_change_set succeeded.

**Recommended Solution**: Option 1 is cleanest - the `storage_fee_used` counter should only reflect fees that were actually charged. This aligns the accounting with reality and prevents the verification from being misled.

## Proof of Concept

The vulnerability can be demonstrated with a test transaction that:
1. Has `sequence_number = 0` to trigger account creation
2. Sets `max_gas_amount` to minimal value (e.g., 50,000 gas units)
3. Sets `gas_unit_price` to minimum (100 Octa/gas)
4. Ensures transaction body consumes any remaining gas before storage fee charging

The transaction will abort with OUT_OF_GAS, but the account will be created and the user will only pay gas costs without the storage fee being deducted.

**Notes**

- The exact storage fee amount depends on `DiskSpacePricing` version and gas parameters, but is approximately 40,000-50,000 Octa for V2 pricing with current parameters
- The vulnerability only affects transactions where `gas_unit_price != 0` OR the default account resource feature is disabled (line 762 check)
- This is a post-execution accounting issue, not a consensus violation - all validators will process the transaction identically and reach consensus on the same state

### Citations

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L276-291)
```rust
        match self.balance.checked_sub(gas_consumed_internal) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.storage_fee_in_internal_units += gas_consumed_internal;
                self.storage_fee_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.storage_fee_in_internal_units += old_balance;
                    self.storage_fee_used += amount;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-754)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;

        let (previous_session_change_set, fee_statement) = if should_create_account_resource {
            let mut abort_hook_session =
                AbortHookSession::new(self, txn_data, resolver, prologue_session_change_set);

            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;

            let mut abort_hook_session_change_set =
                abort_hook_session.finish(change_set_configs, module_storage)?;
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L763-773)
```rust
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L603-622)
```text
        let transaction_fee_amount = txn_gas_price * gas_used;

        // it's important to maintain the error code consistent with vm
        // to do failed transaction cleanup.
        if (!skip_gas_payment(is_simulation, gas_payer)) {
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer, transaction_fee_amount),
                    error::out_of_range(PROLOGUE_ECANT_PAY_GAS_DEPOSIT),
                );
            };

            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer, burn_amount);
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```
