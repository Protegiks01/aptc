# Audit Report

## Title
Critical Validator Crash Due to Empty Weight HashMap in Secret Share State Machine

## Summary
A validator node will panic and crash when processing secret shares if peer shares arrive before the node's own self-share computation completes. This occurs due to an inconsistency between `get_peer_weight()` (returns hardcoded 1) and `get_peer_weights()` (returns empty HashMap) in `SecretShareConfig`, causing a `.expect()` panic in the `retain()` function during state transition from `PendingMetadata` to `PendingDecision`.

## Finding Description

The vulnerability exists in the secret sharing subsystem of the Aptos consensus layer. The `SecretShareItem` state machine manages three states: `PendingMetadata`, `PendingDecision`, and `Decided`. [1](#0-0) 

The root cause is an inconsistency in `SecretShareConfig`. The struct initializes an empty `weights` HashMap [2](#0-1)  but provides two inconsistent methods to access weights:
- `get_peer_weight()` returns a hardcoded value of 1 [3](#0-2) 
- `get_peer_weights()` returns the empty HashMap [4](#0-3) 

**The Race Condition:**

When incoming secret shares from peer validators arrive via network messages, they are processed through `add_share()` which uses `get_peer_weight()` to obtain a weight of 1. [5](#0-4)  These peer shares are successfully added to the aggregator while in `PendingMetadata` state. [6](#0-5) 

Later, when the validator's own self-share computation completes, `add_self_share()` is called. [7](#0-6)  This method retrieves the weights using `get_peer_weights()`, obtaining the empty HashMap. [8](#0-7) 

The empty HashMap is then passed to `add_share_with_metadata()` [9](#0-8)  which triggers a state transition and calls `retain()` to filter shares by metadata. [10](#0-9) 

**The Panic Point:**

Inside `retain()`, the function attempts to recalculate the total weight by iterating over all remaining shares (including the peer shares that arrived earlier) and looking up each author in the weights HashMap: [11](#0-10) 

When it encounters a peer share, the lookup in the empty HashMap fails, triggering the `.expect("Author must exist for weight")` panic at line 79, causing the validator to crash.

**Execution Flow in Production:**

The secret sharing manager is instantiated as part of the consensus pipeline [12](#0-11)  and processes incoming blocks. When a block arrives, it triggers self-share computation (involving cryptographic operations) [13](#0-12)  while simultaneously peer shares can arrive through the network message handler. [14](#0-13) 

## Impact Explanation

**Severity: Critical** (aligns with "Total Loss of Liveness/Network Availability")

This vulnerability causes validator nodes to panic and crash, directly impacting consensus availability:

- **Single Validator Impact**: Loss of one validator reduces network redundancy and increases risk of liveness failures. This alone constitutes HIGH severity per the "Validator Node Crashes" category.

- **Multiple Validator Impact**: If enough validators crash simultaneously (>1/3 of voting power), the network loses liveness and cannot make progress. Since all validators process blocks at approximately the same time, they are all subject to the same race condition, making simultaneous crashes highly likely. This escalates to CRITICAL severity under "Total Loss of Liveness/Network Availability."

- **Non-recoverable without intervention**: Crashed validators must be manually restarted, and without a code fix, the race condition will recur upon restart.

The vulnerability directly breaks the consensus layer's availability guarantees, a core security property of the Aptos blockchain.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger frequently in production environments because:

1. **Natural Network Conditions**: Validators have different hardware capabilities, network latencies, and computational loads. Some validators will naturally compute shares faster than others, creating the timing window for the race condition.

2. **No Special Privileges Required**: This is not an attack scenario requiring malicious actors—normal network operation triggers it. All validators are susceptible during normal consensus operations.

3. **Significant Timing Window**: The window between receiving peer shares and computing the self-share involves cryptographic operations (PVSS decryption key share derivation), which takes measurable time. Network message propagation can easily occur within this window.

4. **Guaranteed Trigger Condition**: In any scenario where peer shares arrive before self-share computation completes, the validator will crash. This is not a probabilistic edge case but a deterministic outcome.

5. **Network-Wide Impact**: Since all validators process blocks for the same rounds at approximately the same time, if one validator experiences the race condition, multiple validators are likely to experience it simultaneously, compounding the impact on network liveness.

The vulnerability is particularly severe because it doesn't require any Byzantine behavior or attack—it can occur purely from natural network timing variations that are expected in any distributed system.

## Recommendation

**Fix the inconsistency between weight accessor methods:**

Option 1: Populate the weights HashMap properly during `SecretShareConfig` initialization based on validator weights from the `ValidatorVerifier`.

Option 2: Have `get_peer_weights()` construct and return a HashMap with all validators having weight 1, matching the behavior of `get_peer_weight()`.

Option 3 (Immediate fix): In the `retain()` function, use `get_peer_weight()` instead of looking up in the HashMap:

```rust
fn retain(&mut self, metadata: &SecretShareMetadata, config: &SecretShareConfig) {
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .map(|author| config.get_peer_weight(author))
        .sum();
}
```

This would require passing the `SecretShareConfig` to `retain()` instead of the weights HashMap, ensuring consistency between the two code paths.

## Proof of Concept

The following describes the reproduction scenario:

1. Start a validator network with at least 3 validators (A, B, C)
2. Propose a block at round R that triggers secret sharing
3. Ensure validator B completes its share computation faster than validator A (can be simulated with different CPU speeds or by adding a small delay to A's computation)
4. Validator B broadcasts its share, which arrives at validator A
5. Validator A's `handle_incoming_msg()` processes B's share via `add_share()`, adding it to the aggregator with weight from `get_peer_weight()` (returns 1)
6. Validator A completes its own share computation and calls `add_self_share()`
7. The `retain()` function is invoked with an empty weights HashMap from `get_peer_weights()`
8. When `retain()` attempts to look up B's author in the empty HashMap, the `.expect()` at line 79 panics
9. Validator A crashes with: "Author must exist for weight"

This can be reliably triggered by introducing a controlled delay in the self-share computation path to ensure peer shares arrive first, demonstrating the race condition under realistic network timing conditions.

---

**Notes**:
- The comment at line 134 of `types/src/secret_sharing.rs` indicates "This is temporary and meant to change in future PRs," suggesting the weighted functionality is incomplete, but this does not diminish the severity as the code is deployed in the consensus-critical path.
- The vulnerability affects the production consensus pipeline as evidenced by the integration in `execution_client.rs`.
- This is not a network DoS attack but a protocol implementation bug that causes validators to self-crash under normal network conditions.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L88-97)
```rust
enum SecretShareItem {
    PendingMetadata(SecretShareAggregator),
    PendingDecision {
        metadata: SecretShareMetadata,
        share_aggregator: SecretShareAggregator,
    },
    Decided {
        self_share: SecretShare,
    },
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L108-113)
```rust
    fn add_share(&mut self, share: SecretShare, share_weight: u64) -> anyhow::Result<()> {
        match self {
            SecretShareItem::PendingMetadata(aggr) => {
                aggr.add_share(share, share_weight);
                Ok(())
            },
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L166-168)
```rust
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-242)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L254-254)
```rust
        item.add_share_with_metadata(share, peer_weights)?;
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-260)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
```

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-198)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L286-294)
```rust
        let secret_share_manager = SecretShareManager::new(
            self.author,
            epoch_state.clone(),
            config,
            secret_ready_block_tx,
            network_sender.clone(),
            self.bounded_executor.clone(),
            &self.consensus_config.rand_rb_config,
        );
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L132-138)
```rust
    async fn process_incoming_block(&self, block: &PipelinedBlock) -> DropGuard {
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L310-320)
```rust
            SecretShareMessage::Share(share) => {
                info!(LogSchema::new(LogEvent::ReceiveSecretShare)
                    .author(self.author)
                    .epoch(share.epoch())
                    .round(share.metadata().round)
                    .remote_peer(*share.author()));

                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
            },
```
