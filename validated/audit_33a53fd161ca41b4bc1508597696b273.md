# Audit Report

## Title
JWK Observer Lifecycle Race Condition Enables Governance Bypass

## Summary
The JWK consensus system maintains a fixed set of observers per epoch that cannot be modified during runtime. When governance removes an issuer mid-epoch via `remove_issuer_from_observed_jwks()`, the corresponding observer continues running and immediately recreates the removed state, completely bypassing the governance action until the next epoch boundary.

## Finding Description

The JWK consensus manager maintains two critical data structures with mismatched lifecycles:

**1. Observer Vector** - The `jwk_observers: Vec<JWKObserver>` field stores observers that are spawned once per epoch at the start of the `run()` method. [1](#0-0)  These observers are created from on-chain OIDC provider configuration. [2](#0-1) 

**2. State HashMap** - The `states_by_issuer: HashMap<Issuer, PerProviderState>` can change mid-epoch via on-chain events. [3](#0-2) 

Each observer runs independently in a separate tokio task, periodically fetching JWKs every 10 seconds. [4](#0-3)  Observers are only torn down when the epoch ends [5](#0-4)  via a close signal from the epoch manager. [6](#0-5) 

When governance calls `remove_issuer_from_observed_jwks()` to remove a compromised OIDC provider, [7](#0-6)  it removes the issuer from on-chain state and emits an `ObservedJWKsUpdated` event. [8](#0-7) 

This event triggers `reset_with_on_chain_state()` in all validators, [9](#0-8)  which removes the issuer from the local `states_by_issuer` HashMap. [10](#0-9) 

**The Race Condition:** The observer for the removed issuer continues running. When it sends a new observation, `process_new_observation()` recreates the state using `.or_default()`. [11](#0-10) 

The default `PerProviderState` has `on_chain: None`, [12](#0-11)  causing `on_chain_version()` to return 0. [13](#0-12) 

A new observation with version 1 is created, [14](#0-13)  reaches quorum, and is submitted as a validator transaction.

The validator transaction validation also uses `.or_insert_with()` to create a version 0 entry if the issuer doesn't exist. [15](#0-14)  The version check `if on_chain.version + 1 != observed.version` passes because 0 + 1 == 1, [16](#0-15)  allowing the removed issuer to be immediately re-added to on-chain state, completely bypassing governance's removal action.

## Impact Explanation

This vulnerability breaks the **Governance Integrity** invariant and constitutes a **Medium Severity** issue per Aptos bug bounty criteria.

**Medium Severity Factors:**
- State inconsistencies requiring manual intervention (must wait for epoch boundary to take effect)
- Governance decisions can be bypassed until next epoch
- Security incident response is delayed (cannot immediately remove compromised OIDC providers)
- Resource waste as validators continue processing unwanted issuers

**Real-World Impact:**
- If a compromised OIDC provider is discovered, governance cannot immediately stop its JWKs from being used for authentication
- The system continues accepting authentication tokens from the compromised provider until the next epoch boundary
- Could lead to unauthorized access if the provider's keys are compromised during the delay period

This meets the Medium Severity criteria: "State inconsistencies requiring intervention" and governance bypass requiring epoch-level recovery to resolve.

## Likelihood Explanation

**Likelihood: High**

This occurs automatically and deterministically whenever governance attempts to remove an issuer mid-epoch:
- No special attacker actions required beyond normal governance operations
- The race condition is deterministic: observers always continue running until epoch end
- Affects all validators simultaneously
- Reproducible with standard governance calls

The issue manifests during legitimate operational scenarios:
- Emergency removal of compromised OIDC providers
- Decommissioning deprecated authentication providers
- Security incident response requiring immediate issuer removal

## Recommendation

**Fix Option 1: Implement Dynamic Observer Lifecycle Management**

Add a mechanism to shut down specific observers when issuers are removed mid-epoch:

1. Store observers in a `HashMap<Issuer, JWKObserver>` instead of a `Vec<JWKObserver>`
2. In `reset_with_on_chain_state()`, identify removed issuers and shut down their corresponding observers
3. Add a method to shut down individual observers without waiting for epoch end

**Fix Option 2: Prevent State Recreation**

Modify `process_new_observation()` to check if the issuer exists in `states_by_issuer` before using `.or_default()`:

```rust
pub fn process_new_observation(&mut self, issuer: Issuer, jwks: Vec<JWKMoveStruct>) -> Result<()> {
    // Only process if issuer is still in the active set
    if !self.states_by_issuer.contains_key(&issuer) {
        debug!("Ignoring observation for removed issuer");
        return Ok(());
    }
    let state = self.states_by_issuer.get_mut(&issuer).unwrap();
    // ... rest of logic
}
```

**Fix Option 3: Stricter Validator Transaction Validation**

Modify the validator transaction validation to reject updates for issuers that were explicitly removed:
- Track removed issuers in a separate set during `reset_with_on_chain_state()`
- In validator transaction processing, check against this removed set before accepting updates

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Deploy a test OIDC provider and wait for it to be added to the observed JWKs
2. Mid-epoch, call `remove_issuer_from_observed_jwks()` via governance
3. Wait for the observer to fetch new JWKs (within 10 seconds)
4. Observe that the issuer is re-added to the on-chain state despite governance removal
5. Verify the issuer remains removed only after the epoch transition

The code paths cited above demonstrate this behavior occurs deterministically without requiring any special test setup beyond normal JWK consensus operation.

## Notes

This is a design flaw in the lifecycle management of the JWK consensus system. The mismatch between observer lifecycle (epoch-bound) and state management (event-driven) creates a window where governance decisions can be bypassed. While the impact is limited to the duration of the current epoch, it represents a real governance integrity issue that should be addressed to ensure immediate response to security incidents involving compromised OIDC providers.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L54-54)
```rust
    states_by_issuer: HashMap<Issuer, PerProviderState>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L61-61)
```rust
    jwk_observers: Vec<JWKObserver>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L170-181)
```rust
    async fn tear_down(&mut self, ack_tx: Option<oneshot::Sender<()>>) -> Result<()> {
        self.stopped = true;
        let futures = std::mem::take(&mut self.jwk_observers)
            .into_iter()
            .map(JWKObserver::shutdown)
            .collect::<Vec<_>>();
        join_all(futures).await;
        if let Some(tx) = ack_tx {
            let _ = tx.send(());
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L194-194)
```rust
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-201)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L231-292)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );
        let onchain_issuer_set: HashSet<Issuer> = on_chain_state
            .entries
            .iter()
            .map(|entry| entry.issuer.clone())
            .collect();
        let local_issuer_set: HashSet<Issuer> = self.states_by_issuer.keys().cloned().collect();

        for issuer in local_issuer_set.difference(&onchain_issuer_set) {
            info!(
                epoch = self.epoch_state.epoch,
                op = "delete",
                issuer = issuer.clone(),
                "reset_with_on_chain_state"
            );
        }

        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
        for on_chain_provider_jwks in on_chain_state.entries {
            let issuer = on_chain_provider_jwks.issuer.clone();
            let locally_cached = self
                .states_by_issuer
                .get(&on_chain_provider_jwks.issuer)
                .and_then(|s| s.on_chain.as_ref());
            if locally_cached == Some(&on_chain_provider_jwks) {
                // The on-chain update did not touch this provider.
                // The corresponding local state does not have to be reset.
                info!(
                    epoch = self.epoch_state.epoch,
                    op = "no-op",
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            } else {
                let old_value = self.states_by_issuer.insert(
                    on_chain_provider_jwks.issuer.clone(),
                    PerProviderState::new(on_chain_provider_jwks),
                );
                let op = if old_value.is_some() {
                    "update"
                } else {
                    "insert"
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    op = op,
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            }
        }
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state finished."
        );
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L361-366)
```rust
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct PerProviderState {
    pub on_chain: Option<ProviderJWKs>,
    pub observed: Option<Vec<JWKMoveStruct>>,
    pub consensus_state: ConsensusState<ObservedUpdate>,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L266-271)
```rust
    async fn shutdown_current_processor(&mut self) {
        if let Some(tx) = self.jwk_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            let _ = tx.send(ack_tx);
            let _ = ack_rx.await;
        }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L117-119)
```rust
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```
