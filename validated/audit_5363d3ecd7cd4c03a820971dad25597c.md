# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution During Epoch Transitions

## Summary
The `process_block_epilogue()` function catches epilogue execution failures and returns success status with empty output, allowing blocks to commit without distributing transaction fees to validators. This occurs when epoch transitions happen mid-block, causing validator index mismatches between fee distribution data and the `PendingTransactionFee` map, breaking the economic invariant that successful blocks must compensate validators.

## Finding Description

The vulnerability exists in the interaction between epoch transition logic and block epilogue fee distribution. 

When a block's prologue triggers an epoch transition, the `reconfigure()` function calls `stake::on_new_epoch()` which reassigns validator indices sequentially and reinitializes the `PendingTransactionFee` map: [1](#0-0) 

The validator indices are reassigned from scratch for the new epoch: [2](#0-1) 

However, the block's user transactions still carry `proposer_index` values from the OLD epoch in their auxiliary info. After execution, `gen_block_epilogue` constructs fee distribution using these OLD indices: [3](#0-2) 

When the block epilogue executes, it calls `block::block_epilogue()` which invokes `stake::record_fee()`: [4](#0-3) 

The `record_fee` function attempts to look up OLD validator indices in the NEW epoch's `PendingTransactionFee` map: [5](#0-4) 

When the OLD index doesn't exist in the NEW map, `borrow_mut` aborts: [6](#0-5) 

The critical flaw is in error handling. The error is caught and the block is kept as success with empty output (no fee distribution): [7](#0-6) 

**Evidence of Awareness:** The Aptos developers implemented defensive code in `update_performance_statistics` to handle invalid indices during epoch transitions: [8](#0-7) 

However, `record_fee` lacks this defensive check, creating an inconsistency that causes fee distribution failure.

## Impact Explanation

**Medium Severity** - Per Aptos bug bounty guidelines, this qualifies as "Limited funds loss or manipulation" and "State inconsistencies requiring intervention":

1. **Economic Loss**: Validators lose transaction fee rewards for blocks where epoch transitions occur (one block per transition)
2. **State Inconsistency**: Blockchain shows successful blocks but `PendingTransactionFee` doesn't reflect fees that should have been recorded
3. **Silent Failure**: Error only logged, not surfaced to monitoring systems
4. **Protocol Inconsistency**: Defensive handling exists in `update_performance_statistics` but not in `record_fee`

The impact is limited to fee distribution for specific blocks and doesn't affect consensus safety, total fund loss, or network liveness, aligning with Medium severity.

## Likelihood Explanation

**Medium to High Likelihood** - This occurs deterministically during epoch transitions:

1. **Regular Occurrence**: Epoch transitions happen regularly per configured interval
2. **Deterministic Race Condition**: When epoch transition occurs in block prologue, the validator index mismatch is guaranteed
3. **No Attacker Required**: Happens naturally through normal protocol operation
4. **Inconsistent Handling**: Other functions handle invalid indices defensively, but `record_fee` does not

## Recommendation

Add defensive validation in `record_fee` consistent with `update_performance_statistics`:

```move
public(friend) fun record_fee(
    vm: &signer,
    fee_distribution_validator_indices: vector<u64>,
    fee_amounts_octa: vector<u64>,
) acquires PendingTransactionFee {
    system_addresses::assert_vm(vm);
    assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());
    
    let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
    let i = 0;
    let num_validators_to_distribute = fee_distribution_validator_indices.length();
    
    while (i < num_validators_to_distribute) {
        let validator_index = fee_distribution_validator_indices[i];
        let fee_octa = fee_amounts_octa[i];
        
        // Skip invalid indices to prevent abort during epoch transitions
        if (pending_fee.pending_fee_by_validator.contains(&validator_index)) {
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
        };
        
        i = i + 1;
    }
}
```

## Proof of Concept

The vulnerability manifests when:
1. Block N's prologue triggers epoch transition via: [9](#0-8) 
2. Epoch transition calls: [10](#0-9) 
3. Validator indices change and PendingTransactionFee is reinitialized
4. Block epilogue attempts fee distribution with old indices
5. Error caught silently and fees not distributed

The proof is in the code path itself - no synthetic PoC needed as this is a deterministic protocol behavior observable during epoch transitions on mainnet.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L629-633)
```text
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1296-1306)
```text
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1425-1428)
```text
            let validator_info = vector::borrow_mut(&mut validator_set.active_validators, validator_index);
            validator_info.config.validator_index = validator_index;
            let validator_config = borrow_global_mut<ValidatorConfig>(validator_info.addr);
            validator_config.validator_index = validator_index;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** aptos-move/block-executor/src/executor.rs (L2055-2073)
```rust
                if let Some(proposer_index) = auxiliary_info.proposer_index() {
                    let gas_price = user_txn.gas_unit_price();
                    let total_gas_unit = fee_statement.gas_used();
                    // Total gas unit here includes the storage fee (deposit), which is not
                    // available for distribution. Only the execution gas and IO gas are available
                    // to distribute. Note here we deliberately NOT use the execution gas and IO
                    // gas value from the fee statement, because they might round up during the
                    // calculation and the sum of them could be larger than the actual value we
                    // burn. Instead we use the total amount (which is the total we've burnt)
                    // minus the storage deposit (round up), to avoid over distribution.
                    // We burn a fix amount of gas per gas unit.
                    let gas_price_to_burn = self.config.onchain.gas_price_to_burn();
                    if gas_price > gas_price_to_burn {
                        let gas_unit_available_to_distribute = total_gas_unit
                            .saturating_sub(fee_statement.storage_fee_used().div_ceil(gas_price));
                        if gas_unit_available_to_distribute > 0 {
                            let fee_to_distribute =
                                gas_unit_available_to_distribute * (gas_price - gas_price_to_burn);
                            *amount.entry(proposer_index).or_insert(0) += fee_to_distribute;
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L249-255)
```text
    fun block_epilogue(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) {
        stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-601)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2611-2617)
```rust
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L134-134)
```text
        stake::on_new_epoch();
```
