# Audit Report

## Title
Variant Field Instantiations Bypass Module Complexity Budget Checks

## Summary
The module complexity metering system fails to account for `variant_field_instantiations` and `struct_variant_instantiations` tables during module publishing complexity checks, allowing attackers to publish modules that bypass resource limits and cause validator node resource exhaustion during module loading.

## Finding Description

The Move binary format includes a complexity checking mechanism in `check_module_complexity()` to prevent modules from consuming excessive resources. This function iterates through various module tables and meters their complexity against a budget calculated as `2048 + blob_size * 20`. [1](#0-0) 

The complexity checking function meters several table types: [2](#0-1) 

Critically, while regular `field_instantiations` are metered at the table level via `meter_field_instantiations()`, there are NO equivalent table-level metering calls for `variant_field_instantiations` or `struct_variant_instantiations` tables. [3](#0-2) 

Individual metering functions DO exist for these types: [4](#0-3) [5](#0-4) 

However, these individual functions are only invoked when bytecode instructions explicitly use these instantiation indices: [6](#0-5) [7](#0-6) 

The vulnerability arises because during module loading, these tables ARE fully processed. For `struct_variant_instantiations`: [8](#0-7) 

And for `variant_field_instantiations`: [9](#0-8) 

**Exploit Mechanism:**

1. Attacker creates a module with a complex type signature (deeply nested generics) - this signature is metered ONCE during `meter_signatures()` call
2. Attacker includes thousands of entries (up to 65,535 per table) in `variant_field_instantiations` and/or `struct_variant_instantiations` tables, all pointing to the same complex signature
3. Each table entry is small (~4 bytes of indices), so blob size remains reasonable and budget check passes
4. During module loading, each table entry causes the complex signature to be cloned and processed, multiplying resource consumption by the number of table entries

The module structure definitions confirm each instantiation contains a `type_parameters: SignatureIndex`: [10](#0-9) [11](#0-10) 

The maximum table sizes allow up to 65,535 entries: [12](#0-11) [13](#0-12) 

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** per the Aptos bug bounty program as it enables **validator node slowdowns through resource exhaustion**.

The complexity budget system exists specifically to prevent modules from consuming excessive resources during loading and verification. By bypassing this protection, an attacker can cause:

1. **Memory exhaustion** from cloning thousands of complex type signatures
2. **Excessive CPU usage** from processing nested generic types repeatedly
3. **Validator performance degradation** affecting consensus participation
4. **Potential validator crashes** from out-of-memory conditions

All validators processing the module publish transaction are affected simultaneously, creating network-wide impact. This breaks the Resource Limits invariant requiring all operations respect computational limits.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation:

1. **Low barrier to entry**: Any user can publish a module to the blockchain
2. **Easy to exploit**: Creating modules with many variant field instantiations pointing to the same signature is straightforward
3. **Hard to detect**: Malicious modules appear normal in size (small indices) but hide amplification factor in table count
4. **No special privileges required**: Standard module publishing capability suffices
5. **Network-wide impact**: All validators processing the transaction are affected
6. **Minimal cost**: Only transaction gas fees required, minimal compared to potential network disruption

The asymmetry between complexity checking (table not iterated) and module loading (table fully iterated) makes this a reliable exploit vector.

## Recommendation

Add table-level metering functions for variant instantiation tables, similar to existing `meter_field_instantiations()`:

```rust
fn meter_struct_variant_instantiations(&self) -> PartialVMResult<()> {
    let struct_variant_insts = self.resolver.struct_variant_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get struct variant instantiations -- not a module.".to_string())
    })?;

    for struct_variant_inst_idx in 0..struct_variant_insts.len() {
        self.meter_struct_variant_instantiation(StructVariantInstantiationIndex(struct_variant_inst_idx as u16))?;
    }
    Ok(())
}

fn meter_variant_field_instantiations(&self) -> PartialVMResult<()> {
    let variant_field_insts = self.resolver.variant_field_instantiations().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get variant field instantiations -- not a module.".to_string())
    })?;

    for variant_field_inst_idx in 0..variant_field_insts.len() {
        self.meter_variant_field_instantiation(VariantFieldInstantiationIndex(variant_field_inst_idx as u16))?;
    }
    Ok(())
}
```

Then call these functions in `check_module_complexity()`:

```rust
meter.meter_signatures()?;
meter.meter_function_instantiations()?;
meter.meter_struct_def_instantiations()?;
meter.meter_field_instantiations()?;
meter.meter_struct_variant_instantiations()?;  // ADD THIS
meter.meter_variant_field_instantiations()?;    // ADD THIS
```

## Proof of Concept

A proof of concept would involve:

1. Creating a Move module with a deeply nested generic type signature (e.g., `vector<vector<vector<...>>>` nested 100+ levels)
2. Generating 10,000+ entries in `variant_field_instantiations` table, all pointing to this complex signature
3. Ensuring the entries are structurally valid but not used in any bytecode
4. Publishing this module and measuring validator resource consumption during module loading

The module would pass complexity checks (signature counted once) but cause significant resource exhaustion during loading (signature processed 10,000+ times).

## Notes

This vulnerability follows the exact same pattern that `meter_field_instantiations()` was designed to prevent for regular field instantiations. The omission of equivalent table-level metering for variant types represents a critical gap in the complexity checking system introduced with Move's enum/variant support.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1556-1558)
```rust
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L139-153)
```rust
    fn meter_struct_variant_instantiation(
        &self,
        struct_inst_idx: StructVariantInstantiationIndex,
    ) -> PartialVMResult<()> {
        let struct_variant_insts =
            self.resolver
                .struct_variant_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get enum type instantiation -- not a module.".to_string(),
                    )
                })?;
        let struct_variant_inst = safe_get_table(struct_variant_insts, struct_inst_idx.0)?;
        self.meter_signature(struct_variant_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L180-195)
```rust
    fn meter_variant_field_instantiation(
        &self,
        variant_field_inst_idx: VariantFieldInstantiationIndex,
    ) -> PartialVMResult<()> {
        let variant_field_insts =
            self.resolver
                .variant_field_instantiations()
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR).with_message(
                        "Can't get variant field instantiations -- not a module.".to_string(),
                    )
                })?;
        let field_inst = safe_get_table(variant_field_insts, variant_field_inst_idx.0)?;

        self.meter_signature(field_inst.type_parameters)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L197-207)
```rust
    fn meter_field_instantiations(&self) -> PartialVMResult<()> {
        let field_insts = self.resolver.field_instantiations().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get field instantiations -- not a module.".to_string())
        })?;

        for field_inst_idx in 0..field_insts.len() {
            self.meter_field_instantiation(FieldInstantiationIndex(field_inst_idx as u16))?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L272-273)
```rust
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L285-286)
```rust
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L408-411)
```rust
    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L250-259)
```rust
        for struct_variant_inst in module.struct_variant_instantiations() {
            let variant = &struct_variant_infos[struct_variant_inst.handle.0 as usize];
            struct_variant_instantiation_infos.push(StructVariantInfo {
                field_count: variant.field_count,
                variant: variant.variant,
                definition_struct_type: variant.definition_struct_type.clone(),
                instantiation: signature_table[struct_variant_inst.type_parameters.0 as usize]
                    .clone(),
            })
        }
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L361-380)
```rust
        for variant_inst in module.variant_field_instantiations() {
            let variant_info = &variant_field_infos[variant_inst.handle.0 as usize];
            let definition_struct_type = variant_info.definition_struct_type.clone();
            let variants = variant_info.variants.clone();
            let offset = variant_info.offset;
            let instantiation = signature_table[variant_inst.type_parameters.0 as usize].clone();
            // We can select one representative variant for finding the field type, all
            // must have the same type as the verifier ensured.
            let uninstantiated_ty = definition_struct_type
                .field_at(Some(variants[0]), offset)?
                .1
                .clone();
            variant_field_instantiation_infos.push(VariantFieldInfo {
                offset,
                uninstantiated_field_ty: uninstantiated_ty,
                variants,
                definition_struct_type,
                instantiation,
            });
        }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L541-544)
```rust
pub struct StructVariantInstantiation {
    pub handle: StructVariantHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L585-588)
```rust
pub struct VariantFieldInstantiation {
    pub handle: VariantFieldHandleIndex,
    pub type_parameters: SignatureIndex,
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-43)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L55-59)
```rust
pub const VARIANT_FIELD_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_DEF_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const CONSTANT_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_VARIANT_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const STRUCT_VARIANT_INST_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```
