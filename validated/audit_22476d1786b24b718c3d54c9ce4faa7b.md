# Audit Report

## Title
V2 Batch Storage Leak: Incorrect Deletion Functions Cause Unbounded Database Growth

## Summary
The quorum store batch cleanup functions contain critical bugs where V2 batches are never deleted from the database during normal operations and epoch transitions. The `gc_previous_epoch_batches_from_db_v2()` function incorrectly calls `delete_batches()` instead of `delete_batches_v2()`, and `update_certified_timestamp()` only deletes V1 batches. This causes V2 batches to accumulate indefinitely, leading to storage exhaustion and potential validator node failure.

## Finding Description

The quorum store maintains two separate storage schemas for batches: V1 batches stored in the "batch" column family and V2 batches in the "batch_v2" column family. [1](#0-0) 

The storage layer provides separate deletion methods for each schema: [2](#0-1) [3](#0-2) 

However, the deletion logic contains two critical bugs:

**Bug #1 - Epoch Cleanup Bug:**

The function `gc_previous_epoch_batches_from_db_v2()` reads V2 batches from storage but calls the V1 deletion function: [4](#0-3) 

This function is called during epoch transitions to clean up old batches, but V2 batches remain in the database indefinitely. [5](#0-4) 

**Bug #2 - Expiration Cleanup Bug:**

The `update_certified_timestamp()` function removes expired batches from the in-memory cache (which contains both V1 and V2 batches via `DashMap<HashValue, PersistedValue<BatchInfoExt>>`) but only deletes V1 batches from the database: [6](#0-5) 

**Correct Implementation for Comparison:**

The function `populate_cache_and_gc_expired_batches_v2()` correctly calls `delete_batches_v2()`, but this is only invoked during non-epoch initialization: [7](#0-6) 

**V2 Batch Persistence:**

V2 batches are indeed persisted to the database when the feature is enabled: [8](#0-7) 

**Configuration:**

V2 batches are controlled by configuration flag: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria ("Validator Node Slowdowns"):

1. **Storage Exhaustion**: V2 batches accumulate indefinitely in the database. With batches potentially containing up to 1MB of transaction data and created continuously during consensus operations, storage can grow unbounded over time.

2. **Performance Degradation**: As the database grows, RocksDB performance degrades due to increased compaction overhead, larger SST files, and slower lookups, causing validator node slowdowns that affect consensus participation.

3. **Node Crashes**: When storage is exhausted, the validator node cannot write new data and will crash, causing loss of liveness for that validator.

4. **Gradual Impact**: The storage growth is gradual, making detection difficult until critical levels are reached.

While the feature currently defaults to disabled, the presence of complete V2 infrastructure indicates this is intended for production deployment. Once enabled, the bug will cause deterministic resource exhaustion.

## Likelihood Explanation

**Likelihood: High (conditional on feature enablement)**

Currently, V2 batches default to disabled, making the immediate likelihood LOW. However, once enabled:

- **Certainty**: 100% - Every V2 batch created will eventually expire and fail to be deleted from persistent storage
- **Attacker Requirements**: None - This is a passive logic bug triggered by normal system operation
- **Detection Difficulty**: High - Storage growth is gradual and may not be noticed until critical levels
- **Exploitation Complexity**: Trivial - No special actions required beyond enabling the configuration flag

The bug represents a logic error in resource cleanup that will manifest automatically during normal consensus operations without any attacker interaction.

## Recommendation

Fix both cleanup functions to use the correct deletion methods:

**Fix for Bug #1:**
In `gc_previous_epoch_batches_from_db_v2()`, change line 241 from:
```rust
db.delete_batches(expired_keys)
```
to:
```rust
db.delete_batches_v2(expired_keys)
```

**Fix for Bug #2:**
In `update_certified_timestamp()`, modify the cleanup logic to handle both V1 and V2 batches. The function should:
1. Separate expired keys by batch version
2. Call `delete_batches()` for V1 batches
3. Call `delete_batches_v2()` for V2 batches

Alternatively, track batch version in the expiration data structure and use the appropriate deletion method based on version.

## Proof of Concept

While no executable PoC is provided, the vulnerability can be verified through code inspection and would manifest as follows once V2 batches are enabled:

1. Enable V2 batches via configuration (`enable_batch_v2: true`)
2. Operate the validator node normally, allowing batches to be created and expired
3. Monitor database size growth in the "batch_v2" column family
4. Observe that expired V2 batches are removed from cache but remain in database
5. After epoch transitions, verify that V2 batches from previous epochs remain in storage
6. Observe unbounded storage growth over time

The bug is deterministic and requires only enabling the V2 batch feature to trigger.

## Notes

This is a **logic vulnerability** where the cleanup functions use incorrect deletion methods due to copy-paste errors or incomplete refactoring when V2 batch support was added. The single correct implementation in `populate_cache_and_gc_expired_batches_v2()` demonstrates the proper pattern, but the other two cleanup paths were not updated accordingly.

### Citations

**File:** consensus/src/quorum_store/schema.rs (L14-16)
```rust
pub(crate) const BATCH_CF_NAME: ColumnFamilyName = "batch";
pub(crate) const BATCH_ID_CF_NAME: ColumnFamilyName = "batch_ID";
pub(crate) const BATCH_V2_CF_NAME: ColumnFamilyName = "batch_v2";
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L93-101)
```rust
    fn delete_batches(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchSchema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/quorum_store_db.rs (L123-131)
```rust
    fn delete_batches_v2(&self, digests: Vec<HashValue>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        for digest in digests.iter() {
            trace!("QS: db delete digest {}", digest);
            batch.delete::<BatchV2Schema>(digest)?;
        }
        self.db.write_schemas_relaxed(batch)?;
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L156-160)
```rust
        if is_new_epoch {
            tokio::task::spawn_blocking(move || {
                Self::gc_previous_epoch_batches_from_db_v1(db_clone.clone(), epoch);
                Self::gc_previous_epoch_batches_from_db_v2(db_clone, epoch);
            });
```

**File:** consensus/src/quorum_store/batch_store.rs (L212-243)
```rust
    fn gc_previous_epoch_batches_from_db_v2(db: Arc<dyn QuorumStoreStorage>, current_epoch: u64) {
        let db_content = db
            .get_all_batches_v2()
            .expect("failed to read data from db");
        info!(
            epoch = current_epoch,
            "QS: Read batches from storage. Len: {}",
            db_content.len(),
        );

        let mut expired_keys = Vec::new();
        for (digest, value) in db_content {
            let epoch = value.epoch();

            trace!(
                "QS: Batchreader recovery content epoch {:?}, digest {}",
                epoch,
                digest
            );

            if epoch < current_epoch {
                expired_keys.push(digest);
            }
        }

        info!(
            "QS: Batch store bootstrap expired keys len {}",
            expired_keys.len()
        );
        db.delete_batches(expired_keys)
            .expect("Deletion of expired keys should not fail");
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L332-335)
```rust
        tokio::task::spawn_blocking(move || {
            db.delete_batches_v2(expired_keys)
                .expect("Deletion of expired keys should not fail");
        });
```

**File:** consensus/src/quorum_store/batch_store.rs (L501-513)
```rust
                    if !batch_info.is_v2() {
                        let persist_request =
                            persist_request.try_into().expect("Must be a V1 batch");
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch(persist_request)
                            .expect("Could not write to DB");
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** config/src/config/quorum_store_config.rs (L102-102)
```rust
    pub enable_batch_v2: bool,
```

**File:** config/src/config/quorum_store_config.rs (L144-144)
```rust
            enable_batch_v2: false,
```
