# Audit Report

## Title
Critical Validator Crash via Native Struct Publishing Bypass

## Summary
An attacker can crash any Aptos validator node by publishing a Move module containing a native struct definition. The bytecode verifier allows native structs to bypass validation checks, but the runtime loader explicitly panics when encountering such structs, causing immediate validator termination and network disruption.

## Finding Description

The vulnerability exists in a validation gap between multiple components that creates a complete attack path from module publishing to validator crash.

**Bytecode Verifier Skips Native Struct Validation:**

The `verify_struct_def()` function explicitly returns `Ok(())` early for native structs without performing any ability constraint validation, since native structs have no Move-level fields to validate. [1](#0-0) 

**Native Validation Only Checks Functions:**

The `validate_module_natives()` function in module publishing validation only iterates over `function_defs()` to check native functions for special address restrictions, completely missing native struct validation. [2](#0-1) 

This validation is called during the publishing request validation flow: [3](#0-2) 

**Runtime Loader Panics on Native Structs:**

When the VM attempts to load a module with a native struct during publishing, the `make_struct_type()` function matches on `StructFieldInformation::Native` and hits an `unreachable!()` macro that immediately panics the validator process. [4](#0-3) 

This function is called during module construction: [5](#0-4) 

**Bytecode Deserializer Allows Native Structs:**

The bytecode deserializer explicitly supports deserializing native structs from bytecode by matching `SerializedNativeStructFlag::NATIVE` and creating `StructFieldInformation::Native`. [6](#0-5) 

The native struct flag is a simple byte value that can be easily modified: [7](#0-6) 

**Complete Attack Path:**

1. Attacker crafts malicious bytecode with a native struct (changing byte `0x2` to `0x1`)
2. Attacker submits transaction calling `code::publish_package_txn` 
3. Module proceeds to `finish_with_module_publishing_and_initialization()`
4. `StagingModuleStorage::create_with_compat_config()` is called: [8](#0-7) 

5. Bytecode verification runs with VMState set to VERIFIER, then state is restored: [9](#0-8) 

6. After verification completes, `build_verified_module_with_linking_checks()` is called: [10](#0-9) 

7. This calls `Module::new()` to construct the verified module OUTSIDE the VERIFIER state protection: [11](#0-10) 

8. `Module::new()` calls `make_struct_type()` which hits the `unreachable!()` panic
9. The crash handler checks VMState and calls `process::exit(12)` since state is no longer VERIFIER: [12](#0-11) 

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability causes **Total loss of liveness/network availability**, which aligns with the Aptos bug bounty CRITICAL severity category #4:

- Any validator processing the malicious transaction will immediately crash via panic
- All validators that attempt to execute the block containing this transaction will crash deterministically  
- The network becomes partitioned as validators crash one by one during block execution
- Recovery requires manual intervention to remove the malicious transaction from mempool/blocks
- In worst case, this could require a hard fork if the transaction is already committed to validator state

The attack breaks the **Deterministic Execution** invariant: validators should produce identical state transitions, but instead they crash before completing state computation, creating consensus failure.

It violates the **Move VM Safety** invariant: the panic bypasses all normal error handling, gas metering, and transaction rollback mechanisms, causing undefined behavior in the validator process.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable by any network participant:

- **No special permissions required** - any user can submit module publishing transactions
- **No resource requirements** - the malicious module can be minimal in size  
- **No timing constraints** - the attack works at any time during normal network operation
- **Simple execution** - requires only editing compiled bytecode to set the native struct flag (single byte modification from `0x2` to `0x1`)
- **Low economic cost** - only requires transaction gas fees
- **No coordination needed** - single transaction is sufficient

The native struct flag serialization shows this is a simple byte value modification: [13](#0-12) 

## Recommendation

Add native struct validation in `validate_module_natives()` to check that user-submitted modules cannot contain native structs. This should mirror the existing native function validation:

```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        
        // Check native functions
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(/* ... */);
            }
        }
        
        // ADD: Check native structs
        for struct_def in module.struct_defs().iter() {
            if matches!(struct_def.field_information, StructFieldInformation::Native) {
                if !module_address.is_special() {
                    return Err(
                        PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                            .with_message("Cannot publish native struct to non-special address".to_string())
                            .finish(Location::Module(module.self_id())),
                    );
                }
            }
        }
    }
    Ok(())
}
```

## Proof of Concept

A complete PoC would require:
1. Compiling a minimal Move module with one struct
2. Modifying the compiled bytecode to change the struct's field information flag from `0x2` (DECLARED) to `0x1` (NATIVE)
3. Submitting via `code::publish_package_txn` entry function
4. Observing validator crash with panic message "native structs have been removed"

The technical path has been validated through code analysis showing all components allow this attack vector.

## Notes

The vulnerability exists because native structs were removed from the Move VM runtime (as indicated by the "native structs have been removed" panic message), but the validation infrastructure was not updated to reject them during module publishing. The bytecode format still supports native structs for backward compatibility, but there is no check preventing user-submitted modules from including them. This creates a critical gap where malicious bytecode can crash validators deterministically.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/signature_v2.rs (L1084-1085)
```rust
        match &struct_def.field_information {
            StructFieldInformation::Native => Ok(()),
```

**File:** aptos-move/aptos-vm/src/verifier/native_validation.rs (L12-27)
```rust
pub(crate) fn validate_module_natives(modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        let module_address = module.self_addr();
        for native in module.function_defs().iter().filter(|def| def.is_native()) {
            if native.is_entry || !module_address.is_special() {
                return Err(
                    PartialVMError::new(StatusCode::USER_DEFINED_NATIVE_NOT_ALLOWED)
                        .with_message(
                            "Cannot publish native function to non-special address".to_string(),
                        )
                        .finish(Location::Module(module.self_id())),
                );
            }
        }
    }
    Ok(())
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L216-218)
```rust
        for (idx, struct_def) in module.struct_defs().iter().enumerate() {
            let definition_struct_type =
                Arc::new(Self::make_struct_type(&module, struct_def, &struct_idxs)?);
```

**File:** third_party/move/move-vm/runtime/src/loader/modules.rs (L452-453)
```rust
        let layout = match &struct_def.field_information {
            StructFieldInformation::Native => unreachable!("native structs have been removed"),
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L1511-1512)
```rust
    let field_information = match field_information_flag {
        SerializedNativeStructFlag::NATIVE => StructFieldInformation::Native,
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L211-214)
```rust
pub enum SerializedNativeStructFlag {
    NATIVE                  = 0x1,
    DECLARED                = 0x2,
    DECLARED_VARIANTS       = 0x3,
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L97-102)
```rust
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L138-172)
```rust
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L272-275)
```rust
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L217-224)
```rust
        let result = Module::new(
            &self.natives,
            locally_verified_module.1,
            locally_verified_module.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        );
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** third_party/move/move-binary-format/src/serializer.rs (L634-638)
```rust
    match &struct_definition.field_information {
        StructFieldInformation::Native => binary.push(SerializedNativeStructFlag::NATIVE as u8),
        StructFieldInformation::Declared(fields) => {
            binary.push(SerializedNativeStructFlag::DECLARED as u8)?;
            serialize_field_definitions(binary, fields)
```
