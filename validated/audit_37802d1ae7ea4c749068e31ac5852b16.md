# Audit Report

## Title
JWK Observer Lifecycle Race Condition Enables Governance Bypass

## Summary
The JWK consensus system maintains a fixed set of observers per epoch that cannot be modified during runtime. When governance removes an issuer mid-epoch via `remove_issuer_from_observed_jwks()`, the corresponding observer continues running and immediately recreates the removed state, completely bypassing the governance action until the next epoch boundary.

## Finding Description

The JWK consensus manager maintains two critical data structures with mismatched lifecycles:

1. **`jwk_observers: Vec<JWKObserver>`** - Spawned once per epoch at the start of the `run()` method and stored as an immutable vector field [1](#0-0) . Observers are created from on-chain OIDC provider configuration [2](#0-1) .

2. **`states_by_issuer: HashMap<Issuer, PerProviderState>`** - Can change mid-epoch via on-chain events [3](#0-2) .

Each observer runs independently in a separate tokio task, periodically fetching JWKs every 10 seconds [4](#0-3) . Observers are only torn down when the epoch ends [5](#0-4)  via a close signal from the epoch manager [6](#0-5) .

When governance calls `remove_issuer_from_observed_jwks()` to remove a compromised OIDC provider [7](#0-6) , it removes the issuer from on-chain state and emits an `ObservedJWKsUpdated` event [8](#0-7) .

This event triggers `reset_with_on_chain_state()` in all validators [9](#0-8) , which removes the issuer from the local `states_by_issuer` HashMap [10](#0-9) .

**The Race Condition:** The observer for the removed issuer continues running. When it sends a new observation, `process_new_observation()` recreates the state using `.or_default()` [11](#0-10) .

The default `PerProviderState` has `on_chain: None` [12](#0-11) , causing `on_chain_version()` to return 0 [13](#0-12) .

A new observation with version 1 is created [14](#0-13) , reaches quorum, and is submitted as a validator transaction.

The validator transaction validation also uses `.or_insert_with()` to create a version 0 entry if the issuer doesn't exist [15](#0-14) . The version check `if on_chain.version + 1 != observed.version` passes because 0 + 1 == 1 [16](#0-15) , allowing the removed issuer to be immediately re-added to on-chain state [17](#0-16) .

This completely bypasses governance's removal action until the next epoch boundary when observers are recreated [18](#0-17) .

## Impact Explanation

This vulnerability breaks the **Governance Integrity** invariant and constitutes a **Medium Severity** issue per Aptos bug bounty criteria:

**Medium Severity Factors:**
- State inconsistencies requiring manual intervention (must wait for epoch boundary)
- Governance decisions can be bypassed until next epoch
- Security incident response is delayed (cannot immediately remove compromised OIDC providers)

**Potential Security Implications:**
- If a compromised OIDC provider is discovered, governance cannot immediately stop its JWKs from being used
- The system continues accepting authentication tokens from the compromised provider until the next epoch
- Could lead to unauthorized access if the provider's keys are compromised during this window

This meets the Medium Severity criteria: "State inconsistencies requiring intervention" and governance bypass requiring epoch-level recovery to resolve.

## Likelihood Explanation

**Likelihood: High**

This occurs automatically and deterministically whenever governance attempts to remove an issuer mid-epoch:
- No special attacker actions required beyond normal governance operations
- The race condition is deterministic: observers always continue running until epoch end
- Affects all validators simultaneously
- Reproducible with standard governance calls

The issue manifests during legitimate operational scenarios:
- Emergency removal of compromised OIDC providers
- Decommissioning deprecated authentication providers
- Security incident response requiring immediate issuer removal

## Recommendation

Implement one of the following solutions:

1. **Dynamic Observer Management**: Modify the observer lifecycle to respond to on-chain events. When `reset_with_on_chain_state()` detects a removed issuer, explicitly shutdown its corresponding observer.

2. **Observer State Validation**: Before processing observations in `process_new_observation()`, verify the issuer still exists in the on-chain state. Reject observations from removed issuers.

3. **Validator Transaction Enhancement**: Add a check in the validator transaction validation to reject updates for issuers that don't exist in the current on-chain `ObservedJWKs` state (not just absent from the local HashMap).

The preferred solution is option 1, as it prevents unnecessary work and network traffic from removed issuers.

## Proof of Concept

The vulnerability can be demonstrated as follows:

1. Deploy a test environment with JWK consensus enabled
2. Add an OIDC provider via governance, wait for epoch to start with observer running
3. Submit governance transaction calling `jwks::remove_issuer_from_observed_jwks()` mid-epoch
4. Observe that within 10 seconds (next observer tick), the removed issuer is re-added to `ObservedJWKs` on-chain state
5. Verify the issuer remains in on-chain state until next epoch boundary

The race condition is deterministic and occurs 100% of the time when governance removes an issuer mid-epoch.

## Notes

This vulnerability represents a fundamental lifecycle management issue where the observer infrastructure (running in tokio tasks) is not synchronized with the consensus state management (event-driven HashMap updates). The `.or_default()` and `.or_insert_with()` patterns, while convenient for handling new issuers, inadvertently allow removed issuers to be recreated without governance approval.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L54-54)
```rust
    states_by_issuer: HashMap<Issuer, PerProviderState>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L61-61)
```rust
    jwk_observers: Vec<JWKObserver>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-143)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L170-181)
```rust
    async fn tear_down(&mut self, ack_tx: Option<oneshot::Sender<()>>) -> Result<()> {
        self.stopped = true;
        let futures = std::mem::take(&mut self.jwk_observers)
            .into_iter()
            .map(JWKObserver::shutdown)
            .collect::<Vec<_>>();
        join_all(futures).await;
        if let Some(tx) = ack_tx {
            let _ = tx.send(());
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L194-194)
```rust
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L199-199)
```rust
                version: state.on_chain_version() + 1,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L252-253)
```rust
        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L361-366)
```rust
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub struct PerProviderState {
    pub on_chain: Option<ProviderJWKs>,
    pub observed: Option<Vec<JWKMoveStruct>>,
    pub consensus_state: ConsensusState<ObservedUpdate>,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L377-381)
```rust
    pub fn on_chain_version(&self) -> u64 {
        self.on_chain
            .as_ref()
            .map_or(0, |provider_jwks| provider_jwks.version)
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L259-263)
```rust
    async fn on_new_epoch(&mut self, reconfig_notification: ReconfigNotification<P>) -> Result<()> {
        self.shutdown_current_processor().await;
        self.start_new_epoch(reconfig_notification.on_chain_configs)
            .await?;
        Ok(())
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L267-271)
```rust
        if let Some(tx) = self.jwk_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            let _ = tx.send(ack_tx);
            let _ = ack_rx.await;
        }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L117-119)
```rust
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L128-130)
```rust
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** types/src/jwks/mod.rs (L131-137)
```rust
    pub fn new(issuer: Issuer) -> Self {
        Self {
            issuer,
            version: 0,
            jwks: vec![],
        }
    }
```
