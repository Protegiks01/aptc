# Audit Report

## Title
Validator Node Panic via Forked Block Certificate in `send_for_execution` - Unhandled None from `path_from_ordered_root`

## Summary
A validator node can be crashed by sending a `SyncInfo` message containing a valid `QuorumCert` for a block that exists on a fork. The `send_for_execution` method assumes `path_from_ordered_root` always returns a valid path, using `unwrap_or_default()` followed by a panic-inducing assertion when the path is None.

## Finding Description

The `BlockReader` trait explicitly documents that `path_from_ordered_root` returns `None` "In case a given block is not the successor of the root." [1](#0-0) 

However, `send_for_execution` mishandles this case by using `unwrap_or_default()` to convert `None` to an empty vector, then immediately asserting the vector is non-empty, guaranteeing a panic: [2](#0-1) 

The implementation of `path_from_root_to_block` returns `None` when traversing parent links reaches a block that doesn't match the root_id, which occurs when the target block is on a different fork: [3](#0-2) 

The vulnerability is exploitable because `insert_quorum_cert` only validates that the commit_info round is greater than the ordered root round, without verifying the block is a descendant: [4](#0-3) 

**Attack Path:**

1. The `BlockTree` explicitly supports multiple children per block, allowing forks to coexist in memory: [5](#0-4) 

2. During consensus, a block on a fork receives valid 2f+1 votes and gets a `QuorumCert`.

3. An attacker sends a `SyncInfo` message via network containing this QC.

4. The `sync_up` method verifies the SyncInfo signatures and calls `add_certs`: [6](#0-5) 

5. The `add_certs` method calls `insert_quorum_cert`: [7](#0-6) 

6. The validation only checks round ordering, allowing a forked block with higher round to pass, then calls `send_for_execution`.

7. Since the forked block is not a descendant of ordered_root, `path_from_ordered_root` returns `None`, the `unwrap_or_default()` creates an empty vector, and the assertion panics.

This breaks the consensus liveness invariant that validators should handle valid network messages without crashing.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

This enables validator node crashes through validly-signed but maliciously-crafted `SyncInfo` messages. The impact qualifies as HIGH because:

- **Validator crashes**: Systematic crashes of validator nodes during certificate processing
- **Consensus liveness disruption**: Repeated exploitation can delay block finalization
- **Critical path failure**: Crash occurs in consensus layer during normal message processing

Not CRITICAL because validators can recover by restarting, no permanent state corruption occurs, and no funds are lost.

## Likelihood Explanation

**High Likelihood:**

1. **Natural preconditions**: Forks occur regularly during normal consensus when validators propose competing blocks for the same round or during network delays.

2. **Low barrier to entry**: Attacker only needs network access to send `SyncInfo` messages. The required `QuorumCert` with 2f+1 signatures occurs naturally during consensus for forked blocks.

3. **No special permissions**: Any network participant can send `SyncInfo` messages without validator credentials.

4. **Deterministic exploitation**: Once a QC for a forked block is obtained, the attack succeeds against any validator processing the message.

5. **Timing window**: The vulnerability is exploitable whenever a forked block with higher round than the ordered root exists with a valid QC.

## Recommendation

Add validation in `insert_quorum_cert` and `send_for_execution` to verify the block is a descendant of the ordered root:

```rust
// In send_for_execution, replace unwrap_or_default() with proper error handling:
let blocks_to_commit = self
    .path_from_ordered_root(block_id_to_commit)
    .ok_or_else(|| format_err!(
        "Block {} is not a descendant of ordered root {}",
        block_id_to_commit,
        self.ordered_root().id()
    ))?;
```

Alternatively, add validation in `insert_quorum_cert` before calling `send_for_execution`:

```rust
// Before line 188, verify block is descendant:
if self.path_from_ordered_root(qc.commit_info().id()).is_none() {
    bail!("Block {} not a descendant of ordered root", qc.commit_info().id());
}
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a block tree with a fork where both branches have QCs
2. Advancing the ordered root along one branch
3. Sending a `SyncInfo` containing a QC for a block on the other branch with higher round
4. Observing the panic in `send_for_execution`

The existing test at [8](#0-7)  demonstrates that `path_from_ordered_root` returning `None` is expected behavior, but no handling exists in the production code path through `insert_quorum_cert` â†’ `send_for_execution`.

## Notes

The `SyncInfo` verification only checks signatures and round ordering, not chain relationships: [9](#0-8)  This allows validly-signed certificates for forked blocks to pass validation and reach the vulnerable code path.

### Citations

**File:** consensus/src/block_storage/mod.rs (L41-46)
```rust
    /// In case a given block is not the successor of the root, return None.
    /// For example if a tree is b0 <- b1 <- b2 <- b3, then
    /// path_from_root(b2) -> Some([b2, b1])
    /// path_from_root(b0) -> Some([])
    /// path_from_root(a) -> None
    fn path_from_ordered_root(&self, block_id: HashValue) -> Option<Vec<Arc<PipelinedBlock>>>;
```

**File:** consensus/src/block_storage/block_store.rs (L327-331)
```rust
        let blocks_to_commit = self
            .path_from_ordered_root(block_id_to_commit)
            .unwrap_or_default();

        assert!(!blocks_to_commit.is_empty());
```

**File:** consensus/src/block_storage/block_tree.rs (L32-36)
```rust
struct LinkableBlock {
    /// Executed block that has raw block data and execution output.
    executed_block: Arc<PipelinedBlock>,
    /// The set of children for cascading pruning. Note: a block may have multiple children.
    children: HashSet<HashValue>,
```

**File:** consensus/src/block_storage/block_tree.rs (L539-542)
```rust
        // At this point cur_block.round() <= self.root.round()
        if cur_block_id != root_id {
            return None;
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L144-145)
```rust
        self.insert_quorum_cert(sync_info.highest_quorum_cert(), &mut retriever)
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L186-189)
```rust
        if self.ordered_root().round() < qc.commit_info().round() {
            SUCCESSFUL_EXECUTED_WITH_REGULAR_QC.inc();
            self.send_for_execution(qc.into_wrapped_ledger_info())
                .await?;
```

**File:** consensus/src/round_manager.rs (L888-901)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
```

**File:** consensus/src/block_storage/block_store_test.rs (L272-272)
```rust
    assert_eq!(block_store.path_from_ordered_root(genesis.id()), None);
```

**File:** consensus/consensus-types/src/sync_info.rs (L138-165)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );
```
