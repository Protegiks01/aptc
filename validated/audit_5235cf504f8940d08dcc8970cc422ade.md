# Audit Report

## Title
Schema Evolution Attack in validator_txn_enabled() Causes Consensus Split During Rolling Upgrades

## Summary
The `validator_txn_enabled()` native function uses `unwrap_or_default()` when deserializing consensus config bytes, which silently falls back to a default configuration with validator transactions DISABLED if deserialization fails. During rolling upgrades where the OnChainConsensusConfig schema evolves (e.g., V5 to V6), non-upgraded validators cannot deserialize the new config format and fall back to default, while upgraded validators deserialize correctly. This causes different validators to have contradictory views of whether validator transactions are enabled, leading to consensus splits and network halts.

## Finding Description

This vulnerability represents a critical logic flaw in how consensus configuration updates are handled during rolling upgrades with schema evolution.

**The Core Vulnerability:**

The native function `validator_txn_enabled()` deserializes consensus config bytes with a silent failure mode using `unwrap_or_default()`. [1](#0-0) 

When BCS deserialization fails (e.g., an old validator encounters a new schema variant it doesn't recognize), the default configuration is returned instead of propagating an error. The default OnChainConsensusConfig is V4 with ValidatorTxnConfig set to `default_if_missing()`. [2](#0-1) 

The `default_if_missing()` function explicitly returns V0, which means validator transactions are DISABLED. [3](#0-2) [4](#0-3) 

**Schema Evolution Context:**

The `OnChainConsensusConfig` enum has already evolved through multiple versions (V1→V2→V3→V4→V5), demonstrating that schema evolution is an ongoing process. [5](#0-4) 

**Attack Scenario:**

During a rolling upgrade where a new schema variant (e.g., V6) is introduced:

1. Network runs with V5 code and V5 config on-chain with validator transactions ENABLED
2. Some validators upgrade to V6-aware code, others remain on V5
3. Governance updates on-chain config to V6 format via `set_for_next_epoch()`
4. **Non-upgraded validators** (V5 code) attempt to deserialize V6 variant, BCS deserialization fails (unknown enum discriminant), they fall back to default with vtxn DISABLED
5. **Upgraded validators** (V6 code) successfully deserialize V6 with vtxn status as configured (likely ENABLED)

**Critical Consensus Paths Affected:**

**Path 1 - Reconfiguration Logic Divergence:**

The `aptos_governance::reconfigure()` function branches based on `validator_txn_enabled()` result. [6](#0-5) 

Validators disagreeing on vtxn status will follow different reconfiguration paths:
- Validators seeing vtxn ENABLED → call `reconfiguration_with_dkg::try_start()` (begins DKG process)
- Validators seeing vtxn DISABLED → call `reconfiguration_with_dkg::finish()` (immediate epoch transition)

**Path 2 - Proposal Validation Rejection:**

The `process_proposal()` function in round_manager explicitly rejects `ProposalExt` blocks when vtxn is disabled. [7](#0-6) 

This means:
- Validators with vtxn ENABLED will propose and accept `ProposalExt` blocks
- Validators with vtxn DISABLED will reject those same blocks with error "ProposalExt unexpected while the vtxn feature is disabled"
- Consensus cannot be reached, causing network halt

**No Validation in Config Update:**

Critically, the Move function `set_for_next_epoch()` that updates consensus config performs NO version compatibility validation or deserialization testing. [8](#0-7) 

It only checks that the config bytes are non-empty, without any deserialization test or schema compatibility verification. This allows deployment of new schema variants that will cause deserialization failures on non-upgraded validators.

## Impact Explanation

**CRITICAL Severity** - This vulnerability breaks the fundamental **Consensus Safety** invariant of the Aptos blockchain.

When validators disagree on validator transaction status during a rolling upgrade:

1. **Consensus Split/Halt**: Validators will reject each other's proposals based on different interpretations of whether `ProposalExt` blocks are valid. The network cannot reach consensus and stops producing blocks.

2. **Chain Fork Risk**: If some validators continue while others halt due to proposal rejections, a chain fork could occur requiring manual intervention to resolve.

3. **Non-recoverable Network Partition**: The network cannot self-heal because:
   - There's no mechanism to detect that validators have different consensus config interpretations
   - The failure is silent (no error logs from `unwrap_or_default()`)
   - Recovery requires manual coordination to either rollback the config or complete all validator upgrades

This qualifies as **Critical Severity** under the Aptos Bug Bounty program's categories of:
- "Consensus/Safety violations" - validators cannot agree on valid blocks
- "Non-recoverable network partition (requires hardfork)" - network split requiring emergency intervention
- "Total Loss of Liveness/Network Availability" - all validators unable to progress

The impact extends to all network participants:
- Validators cannot reach consensus
- Users cannot submit transactions
- The entire blockchain halts
- Emergency intervention required

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - This vulnerability will trigger during any rolling upgrade scenario where the `OnChainConsensusConfig` schema is extended and governance updates the config before all validators complete their upgrade.

The likelihood is assessed as medium-high because:

1. **Schema Evolution is Ongoing**: The enum has already evolved through 5 versions (V1→V2→V3→V4→V5), demonstrating this is a regular occurrence in protocol development. [5](#0-4) 

2. **Rolling Upgrades are Standard Practice**: Framework upgrade tests demonstrate that config updates can occur when only half the validators are upgraded, making this scenario realistic. [9](#0-8) 

3. **No Protective Mechanisms**: The current code has no safeguards:
   - No validation in `set_for_next_epoch()` to test if validators can deserialize the config
   - No version compatibility checks
   - No mechanism to prevent config updates during rolling upgrades
   - Silent failure mode makes the issue undetectable until consensus fails

4. **Normal Governance Workflow**: Governance proposals updating consensus configuration follow standard procedures and don't account for validator upgrade completion status. [10](#0-9) 

5. **Silent Failure**: The `unwrap_or_default()` pattern provides no error indication, making it impossible to detect the misconfiguration before consensus splits occur.

The vulnerability is not purely theoretical - it WILL trigger when:
- A new consensus config schema variant is added (e.g., V6)
- Governance updates the on-chain config to the new format
- Not all validators have completed the code upgrade

While proper operational procedures SHOULD prevent this (upgrade all validators before updating config), there is NO TECHNICAL ENFORCEMENT of this ordering, making it a valid design vulnerability.

## Recommendation

Implement deserialization validation in `set_for_next_epoch()`:

**Option 1: Add Deserialization Check in Move**
Modify `consensus_config::set_for_next_epoch()` to call a native function that validates the config bytes can be deserialized before staging them:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    // Add validation that config can be deserialized
    assert!(validate_config_bytes(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_config_bytes(config_bytes: vector<u8>): bool;
```

**Option 2: Return Error Instead of Default**
Modify the native function to return an error instead of silently falling back to default:

```rust
pub fn validator_txn_enabled(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let config_bytes = safely_pop_arg!(args, Vec<u8>);
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes)
        .map_err(|e| PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
            .with_message(format!("Failed to deserialize OnChainConsensusConfig: {}", e)))?;
    Ok(smallvec![Value::bool(config.is_vtxn_enabled())])
}
```

**Option 3: Version Coordination Mechanism**
Implement a validator version tracking system that prevents config updates until all validators report supporting the new schema version.

## Proof of Concept

While a full end-to-end PoC requires introducing a V6 variant and simulating a rolling upgrade, the vulnerability logic can be demonstrated:

```rust
// Demonstrate BCS deserialization failure with unknown enum variant
use aptos_types::on_chain_config::OnChainConsensusConfig;

#[test]
fn test_schema_evolution_vulnerability() {
    // Simulate V5 config with vtxn enabled
    let v5_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_enabled(), // ENABLED
        window_size: None,
        rand_check_enabled: true,
    };
    
    let v5_bytes = bcs::to_bytes(&v5_config).unwrap();
    
    // V5 validator can deserialize V5 config correctly
    let deserialized = bcs::from_bytes::<OnChainConsensusConfig>(&v5_bytes).unwrap();
    assert!(deserialized.is_vtxn_enabled()); // Returns true
    
    // Simulate V6 bytes (would have discriminant 5)
    // If a V5 validator receives V6 bytes, bcs::from_bytes() will fail
    // and unwrap_or_default() returns V4 with vtxn DISABLED
    
    // Demonstrate default has vtxn disabled
    let default_config = OnChainConsensusConfig::default();
    assert!(!default_config.is_vtxn_enabled()); // Returns false
    
    // This divergence causes consensus split
}
```

## Notes

This vulnerability represents a **design flaw** in the schema evolution handling during rolling upgrades. While it requires specific operational conditions to trigger (new schema variant + premature config update), the lack of technical safeguards makes it a genuine security risk.

The vulnerability is particularly insidious because:
1. The failure is completely silent (no error logs)
2. Validators appear to be functioning normally until consensus splits occur
3. The network cannot self-diagnose or recover without manual intervention

The impact qualifies as CRITICAL because it directly violates consensus safety guarantees and can cause total network halt requiring emergency intervention or hardfork to resolve.

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L19-19)
```rust
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-167)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L192-213)
```rust
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** testsuite/testcases/src/framework_upgrade.rs (L77-82)
```rust
        // Update half the validators to latest version.
        let first_half = &all_validators[..all_validators.len() / 2];
        let msg = format!("Upgrade the nodes to version: {}", new_version);
        info!("{}", msg);
        ctx.report.report_text(msg);
        batch_update(ctx, first_half, &new_version).await?;
```

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L40-45)
```rust
            emitln!(
                writer,
                "consensus_config::set_for_next_epoch({}, consensus_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```
