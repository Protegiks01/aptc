# Audit Report

## Title
Missing Gas Deposit Enforcement for Randomness Transactions Enables Test-and-Abort Attacks

## Summary
The Aptos randomness API lacks enforcement of required gas deposits for transactions using randomness, allowing attackers to perform test-and-abort attacks by setting artificially low `max_gas_units` values while still accessing randomness APIs through the `#[randomness]` annotation. This completely undermines the security guarantees of the randomness system.

## Finding Description

The randomness system is designed to prevent "test-and-abort" attacks where users observe random values and abort transactions with unfavorable outcomes. The intended protection mechanism involves requiring transactions to commit to paying a maximum gas amount, even if they abort early. [1](#0-0) 

However, the actual enforcement is missing. When a transaction with a `#[randomness]` annotation is processed, the code only verifies that the annotation EXISTS but never validates that the transaction's `txn_max_gas_units` matches the annotation's `max_gas` value or the on-chain `RequiredGasDeposit` configuration. [2](#0-1) 

Infrastructure exists for this validation:
- On-chain configuration structures for RequiredGasDeposit and AllowCustomMaxGasFlag: [3](#0-2) 

- Configuration fetching in the VM: [4](#0-3) 

- Error code definition: [5](#0-4) 

- RandomnessAnnotation structure that stores max_gas: [6](#0-5) 

**However, no code actually uses these to validate transactions before execution.** The error code `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` is never raised anywhere in the codebase.

**Attack Path:**

1. Attacker deploys a module with `#[randomness(max_gas = 1000000)]` on an entry function (example structure shown in): [7](#0-6) 

2. Attacker submits transaction calling this function with `txn_max_gas_units = 5000` (much lower than declared)

3. Prologue checks balance >= `txn_gas_price * 5000` (passes easily): [8](#0-7) 

4. Transaction executes and session is marked as unbiasable because annotation exists (no max_gas validation)

5. Function calls randomness API which passes the unbiasable check: [9](#0-8) 

6. If value is unfavorable, function calls `abort()`

7. Epilogue charges only for gas actually used before abort: [10](#0-9) 

8. Attacker pays minimal cost (e.g., 1000 gas units) and can retry many times until favorable outcome

## Impact Explanation

**Critical Severity** - This vulnerability completely undermines the security of the randomness API, enabling:

1. **Biased Randomness**: Attackers can filter for favorable random outcomes in any randomness-dependent application (lotteries, NFT mints, games, etc.)

2. **Economic Loss**: Legitimate users of randomness-based protocols lose to attackers who can cherry-pick outcomes, directly leading to loss of funds

3. **Protocol Security Violation**: Breaks the fundamental guarantee stated in the code comments that the randomness API prevents biasable usage

4. **Protocol Trust Failure**: Any protocol built on Aptos randomness becomes exploitable

This meets **Critical severity** under the Aptos bug bounty "Loss of Funds" category, as it allows systematic extraction of value from randomness-dependent protocols. The vulnerability also qualifies under "Consensus/Safety violations" as it breaks a core security invariant of the randomness system.

## Likelihood Explanation

**High Likelihood** - The attack is:

- **Easy to execute**: Requires only setting a lower `max_gas` parameter when submitting transactions - standard transaction submission
- **Low cost**: Failed attempts cost minimal gas (only up to abort point, e.g., ~1000 gas units)
- **High reward**: Can extract significant value from randomness-dependent applications (lotteries with jackpots, rare NFT mints, etc.)
- **Already documented**: The comment in the code explicitly acknowledges the need for protection against biasable usage
- **No special privileges required**: Any transaction sender can exploit this - attacker just needs to deploy a module and submit transactions
- **Infrastructure exists but unused**: The test framework even has `DiscardedWithMaxGasCheck` enum variant defined, showing this validation was planned but never implemented: [11](#0-10) 

## Recommendation

Implement validation in the transaction prologue or VM execution layer that:

1. Retrieves the `RandomnessAnnotation` for the entry function being executed
2. Fetches the on-chain `RequiredGasDeposit` and `AllowCustomMaxGasFlag` configurations
3. Determines the required gas deposit based on the configuration:
   - If `AllowCustomMaxGasFlag` is true and annotation has `max_gas`, use that value
   - Otherwise use the `RequiredGasDeposit` value from on-chain config
4. Validates that `txn_max_gas_units >= required_deposit`
5. Raises `REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS` error if validation fails

This validation should occur before marking the session as unbiasable, ensuring transactions cannot access randomness APIs without committing to sufficient gas payment.

## Proof of Concept

```move
// Attacker module
module attacker::exploit {
    use aptos_framework::randomness;
    
    #[randomness(max_gas = 1000000)]
    entry fun biased_lottery(account: signer) {
        // Get random number
        let random_value = randomness::u64_range(0, 100);
        
        // Only accept favorable outcomes
        assert!(random_value > 95, 1); // Abort if not in top 5%
        
        // If we reach here, we got a favorable outcome
        // ... collect reward ...
    }
}

// Attack execution:
// 1. Deploy module above
// 2. Submit transactions with txn_max_gas_units = 5000 (much less than 1000000)
// 3. 95% of attempts abort early, costing ~1000 gas units each
// 4. 5% succeed and attacker collects reward
// 5. Net cost is minimal: 19 failed attempts * 1000 gas = 19000 gas
//    vs 1 success with full reward
```

The attack exploits that the prologue only checks if the payer can afford `txn_gas_price * 5000`, not whether 5000 meets the required deposit of 1000000 specified in the annotation. The epilogue then only charges for actual gas used, making failed attempts extremely cheap.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L25-27)
```text
    /// Randomness APIs calls must originate from a private entry function with
    /// `#[randomness]` annotation. Otherwise, malicious users can bias randomness result.
    const E_API_USE_IS_BIASIBLE: u64 = 1;
```

**File:** aptos-move/framework/aptos-framework/sources/randomness.move (L76-77)
```text
    fun next_32_bytes(): vector<u8> acquires PerBlockRandomness {
        assert!(is_unbiasable(), E_API_USE_IS_BIASIBLE);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L983-990)
```rust
            if function.is_friend_or_private() {
                let maybe_randomness_annotation = get_randomness_annotation_for_entry_function(
                    entry_fn,
                    &function.owner_as_module()?.metadata,
                );
                if maybe_randomness_annotation.is_some() {
                    session.mark_unbiasable();
                }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_api_v0_config.move (L8-15)
```text
    struct RequiredGasDeposit has key, drop, store {
        gas_amount: Option<u64>,
    }

    /// If this flag is set, `max_gas` specified inside `#[randomness()]` will be used as the required deposit.
    struct AllowCustomMaxGasFlag has key, drop, store {
        value: bool,
    }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L284-297)
```rust
impl RandomnessConfig {
    /// Returns randomness config based on the current state.
    pub fn fetch(state_view: &impl StateView) -> Self {
        let randomness_api_v0_required_deposit = RequiredGasDeposit::fetch_config(state_view)
            .unwrap_or_else(RequiredGasDeposit::default_if_missing)
            .gas_amount;
        let allow_rand_contract_custom_max_gas = AllowCustomMaxGasFlag::fetch_config(state_view)
            .unwrap_or_else(AllowCustomMaxGasFlag::default_if_missing)
            .value;
        Self {
            randomness_api_v0_required_deposit,
            allow_rand_contract_custom_max_gas,
        }
    }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L658-658)
```rust
    REQUIRED_DEPOSIT_INCONSISTENT_WITH_TXN_MAX_GAS = 39,
```

**File:** types/src/vm/module_metadata.rs (L674-685)
```rust
/// The randomness consuming options specified by developers for their entry function.
/// Examples: `#[randomness(max_gas = 99999)]`, `#[randomness]`.
#[derive(Default)]
pub struct RandomnessAnnotation {
    pub max_gas: Option<u64>,
}

impl RandomnessAnnotation {
    pub fn new(max_gas: Option<u64>) -> Self {
        Self { max_gas }
    }
}
```

**File:** aptos-move/move-examples/on_chain_dice/sources/dice.move (L28-31)
```text
    #[randomness(max_gas=56789)]
    entry fun roll_v2(_account: signer) {
        let _ = randomness::u64_range(0, 6);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L812-819)
```text
        assert!(txn_max_gas_units >= gas_units_remaining, error::invalid_argument(EOUT_OF_GAS));
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** testsuite/smoke-test/src/randomness/entry_func_attrs.rs (L38-38)
```rust
    DiscardedWithMaxGasCheck,
```
