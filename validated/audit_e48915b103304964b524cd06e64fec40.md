# Audit Report

## Title
DKG Sigma Protocol Verification Panics Due to Missing Length Validation in TupleCodomainShape

## Summary
The `TupleCodomainShape::check()` method only validates individual components without enforcing length consistency between the prover's commitment and public statement. A malicious validator can craft a DKG proof with mismatched component lengths, causing other validator nodes to panic during verification when an iterator is unexpectedly exhausted.

## Finding Description

The vulnerability exists in the sigma protocol verification for DKG (Distributed Key Generation) transcripts. The `TupleCodomainShape::check()` implementation only validates components individually: [1](#0-0) 

This validation does not check whether the iterable lengths in the prover's commitment match the public statement's expected lengths.

During proof verification in `PairingTupleHomomorphism`, the `msm_terms_for_verify()` function computes beta powers based on the public statement's lengths: [2](#0-1) 

The verification then calls `merge_msm_terms()` separately for each component: [3](#0-2) 

Inside `merge_msm_terms()`, the code zips `prover_first_message` and `statement` iterators: [4](#0-3) 

This creates `affine_iter` with length `2 * min(prover_first_message.len(), statement.len())`. The subsequent loop then iterates based on `msm_terms.len()` (derived from the public statement) and consumes 2 elements per iteration: [5](#0-4) 

**Attack Path:**
1. Malicious validator crafts a DKG transcript with a proof where the second component of `TupleCodomainShape` (the `WeightedCodomainShape`) has fewer elements than expected
2. The `WeightedCodomainShape` structure allows variable-length vectors: [6](#0-5) 
3. Honest validator receives the transcript during DKG via the network interface: [7](#0-6) 
4. Deserialization succeeds because `check()` only validates individual components
5. During verification, `merge_msm_terms()` is called with mismatched lengths
6. The loop iterates more times than `affine_iter` has elements
7. `affine_iter.next().unwrap()` panics with "called `Option::unwrap()` on a `None` value"
8. **Validator node crashes**

The DKG verification flow is: [8](#0-7) 

Which calls the PVSS transcript verification: [9](#0-8) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Crashes**: A malicious validator can crash other validator nodes by sending a crafted DKG transcript with mismatched proof lengths. This qualifies as "Validator node slowdowns" and "API crashes" in the High severity category.

2. **DKG Disruption**: If validator nodes crash during DKG, the distributed key generation process fails. Since DKG is required for randomness generation in Aptos consensus, this can prevent new epochs from starting and disrupt consensus liveness.

3. **Deterministic Crash**: The panic is deterministic - any validator that receives and attempts to verify the malicious proof will crash.

4. **Network-Wide Impact**: A malicious validator can broadcast the malicious transcript to multiple validators simultaneously, potentially causing widespread node crashes.

This does not reach Critical severity because it does not cause permanent damage (nodes can restart), does not violate consensus safety (it's a liveness issue), and does not result in fund loss.

## Likelihood Explanation

**Likelihood: Medium**

**Note**: The original report incorrectly stated "any network peer" can exploit this. In reality, the attacker must be a validator in the validator set, as DKG messages are only accepted on the authenticated validator network.

- **Requires Validator Access**: The attacker must control a validator in the validator set, which requires significant stake and is within the < 1/3 Byzantine threshold that the protocol is designed to tolerate
- **Easy to Craft**: Once validator access is obtained, crafting the malicious payload requires only setting vector lengths incorrectly in the serialized proof data
- **Difficult to Detect**: The malicious proof passes basic deserialization validation since `check()` doesn't validate lengths
- **Automatic Trigger**: The vulnerability triggers automatically during normal verification
- **Timing Dependent**: DKG only occurs during specific protocol phases (epoch transitions), requiring the attacker to time the attack

## Recommendation

Add length validation to `TupleCodomainShape::check()`:

```rust
impl<A, B> Valid for TupleCodomainShape<A, B>
where
    A: Valid + IntoIterator,
    B: Valid + IntoIterator,
{
    fn check(&self) -> Result<(), SerializationError> {
        self.0.check()?;
        self.1.check()?;
        
        // Validate length consistency
        let len_a = self.0.clone().into_iter().count();
        let len_b = self.1.clone().into_iter().count();
        
        if len_a == 0 || len_b == 0 {
            return Err(SerializationError::InvalidData);
        }
        
        Ok(())
    }
}
```

Additionally, add explicit length checks in `merge_msm_terms()` before the loop:

```rust
let expected_affine_count = msm_terms.len() * 2;
let actual_affine_count = affine_points.len();
if actual_affine_count != expected_affine_count {
    return Err(anyhow!("Length mismatch in merge_msm_terms"));
}
```

## Proof of Concept

A proof of concept would require:
1. Setting up a test validator node
2. Crafting a malicious `WeightedCodomainShape` with truncated `chunks` or `randomness` vectors
3. Serializing it into a DKG transcript
4. Sending it to another validator node
5. Observing the panic during verification

The core issue can be reproduced by creating a `TupleCodomainShape` where the second component's `into_iter().count()` is less than the expected length based on the secret sharing configuration, then calling the verification path.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L138-142)
```rust
    fn check(&self) -> Result<(), SerializationError> {
        self.0.check()?;
        self.1.check()?;
        Ok(())
    }
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L353-356)
```rust
        let len1 = public_statement.0.clone().into_iter().count(); // hmm maybe pass the into_iter version in merge_msm_terms?
        let len2 = public_statement.1.clone().into_iter().count();
        let powers_of_beta = utils::powers(beta, len1 + len2);
        let (first_powers_of_beta, second_powers_of_beta) = powers_of_beta.split_at(len1);
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L360-373)
```rust
        let first_input = H1::merge_msm_terms(
            first_msm_terms_of_response.into_iter().collect(),
            &prover_first_message.0,
            &public_statement.0,
            first_powers_of_beta,
            c,
        );
        let second_input = H2::merge_msm_terms(
            second_msm_terms_of_response.into_iter().collect(),
            &prover_first_message.1,
            &public_statement.1,
            second_powers_of_beta,
            c,
        );
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L153-158)
```rust
        for (A, P) in prover_first_message.clone().into_iter()
            .zip(statement.clone().into_iter())
        {
            all_points_to_normalize.push(A);
            all_points_to_normalize.push(P);
        }
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L163-174)
```rust
        for (term, beta_power) in msm_terms.into_iter().zip(powers_of_beta) {
            let mut bases = term.bases().to_vec();
            let mut scalars = term.scalars().to_vec();

            // Multiply scalars by βᶦ
            for scalar in scalars.iter_mut() {
                *scalar *= beta_power;
            }

            // Add prover + statement contributions
            bases.push(affine_iter.next().unwrap()); // this is the element `A` from the prover's first message
            bases.push(affine_iter.next().unwrap()); // this is the element `P` from the statement, but we'll need `P^c`
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L115-118)
```rust
pub struct WeightedCodomainShape<T: CanonicalSerialize + CanonicalDeserialize + Clone> {
    pub chunks: Vec<Vec<Vec<T>>>, // Depending on T these can be chunked ciphertexts, or their MSM representations
    pub randomness: Vec<Vec<T>>,  // Same story, depending on T
}
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-101)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
        let mut trx_aggregator = self.trx_aggregator.lock();
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }

        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L178-190)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    self.sharing_proof.range_proof_commitment.clone(),
                    chunked_elgamal::WeightedCodomainShape {
                        chunks: self.subtrs.Cs.clone(),
                        randomness: self.subtrs.Rs.clone(),
                    },
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
            }
```
