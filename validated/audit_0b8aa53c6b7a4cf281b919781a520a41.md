# Audit Report

## Title
Stale VM Environment in Transaction Validation Causes Feature Flag and Gas Parameter Inconsistency

## Summary
The VM validator's `CachedModuleView` maintains separate `state_view` and `environment` fields. When `notify_commit()` is called after block commits, it updates only the `state_view` via `reset_state_view()` in the normal case, leaving the `environment` stale. This causes transaction validation to use outdated feature flags and gas parameters from the cached environment while reading from current state, leading to incorrect validation decisions until an asynchronous `restart()` call updates the environment.

## Finding Description

The vulnerability exists in the VM validator's state management across block commits:

**Root Cause**: The `CachedModuleView` struct contains both `state_view` and `environment` fields [1](#0-0) . When `notify_commit()` is called after block commits, it decides between `reset_state_view()` and `reset_all()` based on version compatibility [2](#0-1) .

For linear version progressions (the normal case), `reset_state_view()` is called, which only updates the `state_view` field [3](#0-2) . The `environment` field remains unchanged and only gets updated when `reset_all()` is called [4](#0-3) .

**Environment Contents**: The `AptosEnvironment` stores critical on-chain configuration including feature flags, gas parameters, storage gas parameters, VM configuration, keyless verification keys, chain ID, and timed features [5](#0-4) . These are fetched from state during initialization [6](#0-5) .

**The Inconsistency**: When governance updates feature flags or gas parameters and the block commits:
1. The new configuration is written to state
2. `notify_commit()` calls `reset_state_view()` for linear versions [7](#0-6) 
3. The `state_view` now reflects new configuration
4. The `environment` still contains old configuration
5. This persists until `restart()` is explicitly called

The `restart()` method calls `reset_all()` which updates the environment [8](#0-7) , but it's invoked asynchronously via `process_config_update()` [9](#0-8) , which is spawned as a separate task [10](#0-9) .

**Validation Impact**: When `validate_transaction()` is called, it creates an `AptosVM` instance with the cached (stale) environment [11](#0-10) . The validation then checks feature flags using `self.features().is_enabled()` [12](#0-11) , where `features()` returns values from the VM's environment [13](#0-12) .

**Attack Scenario**:
1. Governance enables a new feature flag (e.g., `WEBAUTHN_SIGNATURE`)
2. Configuration commits to state in block N
3. `notify_commit()` updates `state_view` but not `environment`
4. User submits transaction using the newly enabled feature
5. Validation checks stale environment, finds feature disabled
6. Valid transaction is incorrectly rejected with `FEATURE_UNDER_GATING`
7. Issue persists until async `restart()` completes

**Comparison with Block Execution**: Block execution does not have this issue because it creates a fresh environment for each block and compares environments via hash-based equality, updating when they differ [14](#0-13) [15](#0-14) .

## Impact Explanation

This qualifies as **Medium to High Severity** under Aptos bug bounty criteria:

**Protocol Violation Impact**:
- Valid transactions incorrectly rejected (DoS for users with new features)
- Potential for invalid transactions to be accepted (if features disabled but environment stale in opposite direction)
- Mempool state divergence across validators due to different reconfig notification timing
- Breaks transaction validation invariant requiring current state configuration

**Why Not Critical**:
- Does NOT break consensus (block execution uses fresh environment)
- Does NOT cause fund loss or theft
- Does NOT cause permanent network issues
- Temporary issue resolved when `restart()` completes

**Classification**: This is a "significant protocol violation" affecting validator mempool validation, qualifying for Medium severity under "Limited protocol violations" ($10,000 range), though it could be argued as High under "Significant protocol violations" due to the determinism violation across validators.

## Likelihood Explanation

**High Likelihood**:
- Automatically occurs on every governance configuration change
- No attacker action required - normal governance operation triggers it
- Affects all validators running the code
- Governance proposals to update features/gas parameters occur regularly on mainnet
- Time window exists between commit notification and async restart completion
- Deterministic and reproducible

## Recommendation

**Solution 1 (Preferred)**: Always call `reset_all()` instead of `reset_state_view()` in `notify_commit()` to ensure environment stays synchronized:

```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    // Always reset everything to ensure environment stays fresh
    self.state.reset_all(db_state_view.into());
}
```

**Solution 2**: Make `reset_state_view()` also update the environment:

```rust
pub fn reset_state_view(&mut self, state_view: S) {
    self.state_view = state_view;
    self.environment = AptosEnvironment::new(&self.state_view);
}
```

**Solution 3**: Track environment hash and detect when it needs updating:

```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    let new_env = AptosEnvironment::new(db_state_view.as_state_view());
    
    // Check if environment changed
    if self.state.environment != new_env {
        self.state.reset_all(db_state_view.into());
    } else {
        self.state.reset_state_view(db_state_view.into());
    }
}
```

## Proof of Concept

The PoC would require:
1. Deploy governance proposal to toggle a feature flag
2. Execute proposal and commit block
3. Submit transaction using newly enabled feature before `restart()` completes
4. Observe `FEATURE_UNDER_GATING` error despite feature being enabled in state

This can be tested by:
- Adding instrumentation to log environment updates vs state_view updates
- Measuring time window between `notify_commit()` and `restart()` completion
- Submitting test transactions during this window with feature-gated functionality

## Notes

This vulnerability demonstrates a subtle state synchronization issue where the VM validator maintains two views of on-chain configuration that can temporarily diverge. While the impact is limited to mempool validation (not consensus), it violates the principle that validation should always use current state configuration. The issue is particularly concerning because it's non-obvious and could lead to user confusion when valid transactions are rejected during the window after configuration updates.

The severity assessment is debatable - while technically a "protocol violation," the temporary nature and lack of consensus impact suggest Medium severity is more appropriate than High, despite the report's classification.

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L134-138)
```rust
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** vm-validator/src/vm_validator.rs (L70-74)
```rust
    fn restart(&mut self) -> Result<()> {
        let db_state_view = self.db_state_view();
        self.state.reset_all(db_state_view.into());
        Ok(())
    }
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L155-165)
```rust
        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L152-158)
```rust
impl PartialEq for AptosEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0.hash == other.0.hash
    }
}

impl Eq for AptosEnvironment {}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L166-188)
```rust
struct Environment {
    /// Specifies the chain, i.e., testnet, mainnet, etc.
    chain_id: ChainId,

    /// Set of features enabled in this environment.
    features: Features,
    /// Set of timed features enabled in this environment.
    timed_features: TimedFeatures,

    /// The prepared verification key for keyless accounts. Optional because it might not be set
    /// on-chain or might fail to parse.
    keyless_pvk: Option<PreparedVerifyingKey<Bn254>>,
    /// Some keyless configurations which are not frequently updated.
    keyless_configuration: Option<Configuration>,

    /// Gas feature version used in this environment.
    gas_feature_version: u64,
    /// Gas parameters used in this environment. Error is stored if gas parameters were not found
    /// on-chain.
    gas_params: Result<AptosGasParameters, String>,
    /// Storage gas parameters used in this environment. Error is stored if gas parameters were not
    /// found on-chain.
    storage_gas_params: Result<StorageGasParameters, String>,
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L212-318)
```rust
    fn new(
        state_view: &impl StateView,
        inject_create_signer_for_gov_sim: bool,
        gas_hook: Option<Arc<dyn Fn(DynamicExpression) + Send + Sync>>,
    ) -> Self {
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);

        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();

        // TODO(Gas):
        //   Right now, we have to use some dummy values for gas parameters if they are not found
        //   on-chain. This only happens in a edge case that is probably related to write set
        //   transactions or genesis, which logically speaking, shouldn't be handled by the VM at
        //   all. We should clean up the logic here once we get that refactored.
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };

        let mut builder = SafeNativeBuilder::new(
            gas_feature_version,
            native_gas_params,
            misc_gas_params,
            timed_features.clone(),
            features.clone(),
            gas_hook,
        );
        let natives = aptos_natives_with_builder(&mut builder, inject_create_signer_for_gov_sim);
        let vm_config = aptos_prod_vm_config(
            chain_id,
            gas_feature_version,
            &features,
            &timed_features,
            ty_builder,
        );
        let verifier_bytes =
            bcs::to_bytes(&vm_config.verifier_config).expect("Verifier config is serializable");
        let runtime_environment = RuntimeEnvironment::new_with_config(natives, vm_config);

        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
        let keyless_configuration =
            Configuration::fetch_keyless_config(state_view).map(|(config, config_bytes)| {
                sha3_256.update(&config_bytes);
                config
            });

        let hash = sha3_256.finalize().into();

        #[allow(deprecated)]
        Self {
            chain_id,
            features,
            timed_features,
            keyless_pvk,
            keyless_configuration,
            gas_feature_version,
            gas_params,
            storage_gas_params,
            runtime_environment,
            inject_create_signer_for_gov_sim,
            hash,
            verifier_bytes,
            async_runtime_checks_enabled: get_async_runtime_checks(),
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L762-794)
```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }

    let consensus_config: anyhow::Result<OnChainConsensusConfig> = config_update.get();
    match consensus_config {
        Ok(consensus_config) => {
            *broadcast_within_validator_network.write() =
                !consensus_config.quorum_store_enabled() && !consensus_config.is_dag_enabled()
        },
        Err(e) => {
            error!(
                "Failed to read on-chain consensus config, keeping value broadcast_within_validator_network={}: {}",
                *broadcast_within_validator_network.read(),
                e
            );
        },
    }
}
```

**File:** mempool/src/shared_mempool/coordinator.rs (L268-291)
```rust
async fn handle_mempool_reconfig_event<NetworkClient, TransactionValidator, ConfigProvider>(
    smp: &mut SharedMempool<NetworkClient, TransactionValidator>,
    bounded_executor: &BoundedExecutor,
    config_update: OnChainConfigPayload<ConfigProvider>,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg> + 'static,
    TransactionValidator: TransactionValidation + 'static,
    ConfigProvider: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Received
    ));
    let _timer =
        counters::task_spawn_latency_timer(counters::RECONFIG_EVENT_LABEL, counters::SPAWN_LABEL);

    bounded_executor
        .spawn(tasks::process_config_update(
            config_update,
            smp.validator.clone(),
            smp.broadcast_within_validator_network.clone(),
        ))
        .await;
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L348-350)
```rust
    fn features(&self) -> &Features {
        self.move_vm.env.features()
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3198)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }

        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L99-130)
```rust
    fn check_ready(
        &mut self,
        storage_environment: AptosEnvironment,
        config: &BlockExecutorModuleCacheLocalConfig,
        transaction_slice_metadata: TransactionSliceMetadata,
    ) -> Result<(), VMStatus> {
        // If we execute non-consecutive sequence of transactions, we need to flush everything.
        if !transaction_slice_metadata.is_immediately_after(&self.transaction_slice_metadata) {
            self.module_cache.flush();
            self.environment = None;
        }
        // Record the new metadata for this slice of transactions.
        self.transaction_slice_metadata = transaction_slice_metadata;

        // Next, check the environment. If the current environment has not been set, or is
        // different, we reset it to the new one, and flush the module cache.
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```
