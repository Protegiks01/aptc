# Audit Report

## Title
Consensus Safety Violation: Transaction Filter Bypass via QuorumStore Proof Batches Causes Deterministic Execution Failure

## Summary
A critical discrepancy exists between transaction filtering during the voting phase and execution phase in QuorumStore payloads. During voting, only inline transactions are validated against block transaction filters, while during execution, ALL transactions (including those from proof batches and optimistic batches) are filtered. This allows transactions matching Deny rules to bypass voting validation but be filtered inconsistently across validators during execution, breaking consensus safety and causing network partition.

## Finding Description

The Aptos consensus system employs two separate transaction filter configurations that are applied at different phases with different transaction scopes:

**Voting Phase - Consensus Filter (Incomplete Scope):**

During block proposal validation in RoundManager, the consensus_filter is applied via `check_denied_inline_transactions()`: [1](#0-0) 

This delegates to the QuorumStorePayloadManager which only extracts inline transactions: [2](#0-1) 

The critical issue is that `get_inline_transactions()` ONLY returns transactions from inline batches: [3](#0-2) 

Notice that proof batches (ProofWithData) and optimistic batches are completely excluded from this extraction.

**Execution Phase - Execution Filter (Complete Scope):**

After consensus is reached, the execution_filter is applied during block preparation: [4](#0-3) 

This filters ALL transactions retrieved by `get_transactions()`, which includes proof batches: [5](#0-4) 

**Two Separate Filter Configurations:**

The system maintains distinct filter configurations for voting and execution: [6](#0-5) 

These are initialized independently:
- consensus_filter → RoundManager (voting phase)
- execution_filter → ExecutionProxy/BlockPreparer (execution phase) [7](#0-6) [8](#0-7) 

**Attack Scenario:**

1. Attacker crafts a transaction that matches a Deny rule in some validators' execution_filter
2. Attacker includes this transaction in a ProofWithData batch (NOT in inline batch)
3. During voting: All validators call `check_denied_inline_transactions()`, which only checks inline batches. The malicious transaction in the proof batch is not evaluated. All validators vote to accept.
4. Block achieves 2/3+ quorum and is committed to the blockchain
5. During execution: `filter_block_transactions()` is called with ALL transactions including proof batches
   - Validators with matching Deny rule: Filter out the transaction, execute N-1 transactions
   - Validators without the rule or with different execution_filter: Execute all N transactions
6. Result: Different validators compute different state roots from the same committed block → consensus split → network partition

**Test Coverage Gap:**

The existing tests only verify inline transaction filtering and never test proof batches: [9](#0-8) 

Note `ProofWithData::empty()` - no transactions are placed in proof batches during testing.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental consensus safety guarantee that all honest validators must execute the same transactions and arrive at the same state root for any committed block.

The attack produces:
- **Consensus Safety Violation**: Different validators execute different transaction sets from the same committed block, violating the deterministic execution invariant
- **Non-recoverable Network Partition**: Validators permanently diverge on state and cannot reach agreement on subsequent blocks, requiring emergency hardfork intervention
- **State Root Divergence**: Different execution results produce different state commitments, causing validators to reject each other's blocks
- **Potential Loss of Funds**: Depending on the filtered transaction's effects, state divergence can enable double-spending or fund loss across different validator states

This qualifies for **Critical Severity** (up to $1,000,000) under the Aptos bug bounty categories:
- "Consensus/Safety violations"
- "Non-recoverable network partition (requires hardfork)"
- "Different validators commit different blocks"

## Likelihood Explanation

**High Likelihood** if transaction filters are deployed in production:

1. **Low Attacker Requirements**: Any transaction sender can submit transactions to QuorumStore batches. No validator privileges or special access required.

2. **Realistic Preconditions**: Validators can independently configure their `execution_filter` in their node_config files. There is no consensus mechanism enforcing identical filter configurations across validators. It is realistic that validators would configure different filters for compliance, regulatory, or operational reasons.

3. **Deterministic Trigger**: If any validators have Deny rules in their execution_filter (or have different execution_filter configurations), the vulnerability is exploitable.

4. **No Detection During Voting**: The discrepancy between `get_inline_transactions()` and `get_transactions()` means proof batch transactions completely bypass voting-phase validation.

5. **Test Coverage Confirms Gap**: All existing tests create `ProofWithData::empty()`, indicating this scenario was never validated.

## Recommendation

**Immediate Fix**: Ensure voting-phase filtering checks the same transaction set as execution-phase filtering.

Option 1 - Expand voting checks to include all transactions:
```rust
fn check_denied_inline_transactions(...) -> anyhow::Result<()> {
    if !block_txn_filter_config.is_enabled() {
        return Ok(());
    }
    
    // Get ALL transactions, not just inline
    let all_transactions = get_all_transactions_for_voting(block)?;
    
    let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
    let denied_transactions = block_transaction_filter.get_denied_block_transactions(
        block.id(),
        block.author(),
        block.epoch(),
        block.timestamp_usecs(),
        all_transactions,
    );
    
    if !denied_transactions.is_empty() {
        return Err(anyhow::anyhow!("Block contains denied transactions: {:?}", denied_transactions));
    }
    
    Ok(())
}
```

Option 2 - Enforce consensus_filter == execution_filter via on-chain configuration or validator set requirements.

Option 3 - Remove execution-phase filtering entirely, relying only on voting-phase filtering.

**Testing**: Add comprehensive tests that place denied transactions in ProofWithData batches and verify they are rejected during voting.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configure Validator A with execution_filter containing a Deny rule for a specific sender address
2. Configure Validator B with no execution_filter (or different rules)
3. Create a QuorumStore block with:
   - Empty inline batches
   - ProofWithData containing a transaction from the denied sender
4. Both validators vote to accept (voting only checks inline batches)
5. Block is committed
6. During execution:
   - Validator A filters out the transaction → computes state root S1
   - Validator B executes the transaction → computes state root S2
7. S1 ≠ S2 → consensus failure

The code paths are clearly separated and the test gap is evident in the existing test suite, confirming this vulnerability is exploitable in production environments where validators configure transaction filters.

### Citations

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L126-163)
```rust
    async fn get_transactions_quorum_store_inline_hybrid(
        &self,
        block: &Block,
        inline_batches: &[(BatchInfo, Vec<SignedTransaction>)],
        proof_with_data: &ProofWithData,
        max_txns_to_execute: &Option<u64>,
        block_gas_limit_override: &Option<u64>,
    ) -> ExecutorResult<BlockTransactionPayload> {
        let all_transactions = {
            let mut all_txns = process_qs_payload(
                proof_with_data,
                self.batch_reader.clone(),
                block,
                &self.ordered_authors,
            )
            .await?;
            all_txns.append(
                &mut inline_batches
                    .iter()
                    // TODO: Can clone be avoided here?
                    .flat_map(|(_batch_info, txns)| txns.clone())
                    .collect(),
            );
            all_txns
        };
        let inline_batches = inline_batches
            .iter()
            .map(|(batch_info, _)| batch_info.clone())
            .collect();
        Ok(BlockTransactionPayload::new_quorum_store_inline_hybrid(
            all_transactions,
            proof_with_data.proofs.clone(),
            *max_txns_to_execute,
            *block_gas_limit_override,
            inline_batches,
            self.enable_payload_v2,
        ))
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/src/block_preparer.rs (L71-119)
```rust
    pub async fn prepare_block(
        &self,
        block: &Block,
        txns: Vec<SignedTransaction>,
        max_txns_from_block_to_execute: Option<u64>,
        block_gas_limit: Option<u64>,
    ) -> (Vec<SignedTransaction>, Option<u64>) {
        let start_time = Instant::now();

        let txn_filter_config = self.txn_filter_config.clone();
        let txn_deduper = self.txn_deduper.clone();
        let txn_shuffler = self.txn_shuffler.clone();

        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp_usecs = block.timestamp_usecs();

        // Transaction filtering, deduplication and shuffling are CPU intensive tasks, so we run them in a blocking task.
        let result = tokio::task::spawn_blocking(move || {
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
            let deduped_txns = txn_deduper.dedup(filtered_txns);
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
            };

            if let Some(max_txns_from_block_to_execute) = max_txns_from_block_to_execute {
                shuffled_txns.truncate(max_txns_from_block_to_execute as usize);
            }
            TXNS_IN_BLOCK
                .with_label_values(&["after_filter"])
                .observe(shuffled_txns.len() as f64);
            MAX_TXNS_FROM_BLOCK_TO_EXECUTE.observe(shuffled_txns.len() as f64);
            shuffled_txns
        })
        .await
        .expect("Failed to spawn blocking task for transaction generation");
        counters::BLOCK_PREPARER_LATENCY.observe_duration(start_time.elapsed());
        (result, block_gas_limit)
    }
```

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/consensus_provider.rs (L65-72)
```rust
    let execution_proxy = ExecutionProxy::new(
        Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db)),
        txn_notifier,
        state_sync_notifier,
        node_config.transaction_filters.execution_filter.clone(),
        node_config.consensus.enable_pre_commit,
        None,
    );
```

**File:** consensus/src/round_manager_tests/txn_filter_proposal_test.rs (L238-244)
```rust
    if use_quorum_store_payloads {
        let inline_batch = (create_batch_info(transactions.len()), transactions);
        Payload::QuorumStoreInlineHybrid(vec![inline_batch], ProofWithData::empty(), None)
    } else {
        Payload::DirectMempool(transactions)
    }
}
```
