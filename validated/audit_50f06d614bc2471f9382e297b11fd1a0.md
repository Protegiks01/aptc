# Audit Report

## Title
Undetected Validator Equivocation Due to Missing Timeout Recovery After Node Restart

## Summary
After a validator node restarts, the `timeout_sent` field in `RoundState` is not restored from persistent storage, remaining `None` even if the validator had previously broadcast a timeout for the current round. This allows the validator to create and broadcast a second, different timeout message for the same round with different consensus-critical content (different highest QC). The system fails to detect this equivocation, violating consensus safety guarantees.

## Finding Description

The vulnerability stems from asymmetric recovery of consensus state after node restart. The `RoundState` structure tracks whether a validator has sent a vote or timeout in the current round using `Option<>` fields (vote_sent and timeout_sent). [1](#0-0) 

When a validator node restarts, the `RoundManager.init()` function restores the last vote but **not** the last timeout. [2](#0-1) 

The recovery data structure only includes `last_vote`, not a `last_timeout` field. [3](#0-2) 

This creates the following attack sequence:

**Phase 1 - Initial Timeout:**
1. Validator V times out in round R with highest QC for round R-5
2. Creates and broadcasts `RoundTimeout` with `hqc_round = R-5`
3. Records it locally in `timeout_sent` via `record_round_timeout()` [4](#0-3) 
4. SafetyRules persists `last_voted_round = R`

**Phase 2 - Node Restart:**
5. Validator V crashes/restarts
6. `init()` restores `vote_sent` but leaves `timeout_sent = None`
7. V's `is_timeout_sent()` now incorrectly returns false [5](#0-4) 

**Phase 3 - Second Timeout (Equivocation):**
8. V receives a new QC for round R-2 (higher than R-5)
9. Upon receiving f+1 timeouts, `is_timeout_sent()` returns false, triggering `EchoTimeout` [6](#0-5) 
10. V calls `process_local_timeout()` again for the same round R
11. Creates a **new** `RoundTimeout` with `hqc_round = R-2` (different content!) using the current highest QC [7](#0-6) 
12. SafetyRules signs this second timeout because `round == last_voted_round` doesn't error - only `round < last_voted_round` errors [8](#0-7) 
13. V broadcasts the second timeout with different `hqc_round`

**Phase 4 - Undetected Equivocation:**
14. Other validators receive both conflicting timeouts from V
15. `insert_round_timeout()` has **no** equivocation detection (unlike `insert_vote()`) [9](#0-8) 

Compare this to vote equivocation detection which explicitly checks and returns `EquivocateVote` [10](#0-9) 

16. The `add_signature()` method uses `or_insert()`, silently ignoring subsequent timeouts from the same validator [11](#0-10) 

The validator has successfully equivocated (signed two conflicting messages for the same round) without detection.

## Impact Explanation

This is a **High Severity** issue representing a significant consensus protocol violation. Validator equivocation is a fundamental Byzantine fault that Byzantine Fault Tolerant protocols must detect and prevent. The AptosBFT protocol assumes validators will not equivocate, or that equivocation will be detected and potentially slashed.

Key impacts:
- **Consensus Safety Violation**: Validator signs conflicting consensus messages with different `hqc_round` values for the same round
- **Undetected Byzantine Behavior**: No `EquivocateVote` error, no logging, no consequences for the equivocating validator
- **Potential for Exploitation**: Malicious validators could intentionally trigger restarts to equivocate strategically
- **Trust Model Breach**: Other validators unknowingly aggregate signatures from an equivocating validator

While this doesn't immediately cause consensus failure (one timeout is silently dropped via `or_insert`), it violates the fundamental safety invariant that validators should not equivocate undetected. This aligns with **High Severity** per Aptos bug bounty criteria as a significant protocol violation affecting consensus safety guarantees.

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers automatically in the following realistic scenarios:
1. **Validator crash during consensus**: Common in production systems due to software bugs or hardware failures
2. **Validator restart for maintenance**: Regular operational procedure for updates
3. **Network partition recovery**: Node reconnects after isolation with new QC information
4. **Resource exhaustion causing restart**: Out of memory, disk issues forcing restart

The vulnerability requires:
- Node restart between sending timeout and round completion (realistic timing window)
- Receipt of a new higher QC after restart (common in normal operation as consensus progresses)
- f+1 timeouts received triggering echo timeout (standard timeout aggregation mechanism)

No malicious intent required - this happens during normal operational failures. The asymmetric recovery (restoring votes but not timeouts) combined with SafetyRules allowing signing when `round == last_voted_round` creates an automatic equivocation path.

## Recommendation

**Fix 1: Add timeout recovery to init()**
Extend `RecoveryData` to include `last_timeout` field and restore it in `RoundManager::init()`:

```rust
pub async fn init(&mut self, last_vote_sent: Option<Vote>, last_timeout_sent: Option<RoundTimeout>) {
    // ... existing code ...
    if let Some(vote) = last_vote_sent {
        self.round_state.record_vote(vote);
    }
    if let Some(timeout) = last_timeout_sent {
        self.round_state.record_round_timeout(timeout);
    }
    // ... rest of init ...
}
```

**Fix 2: Add timeout equivocation detection**
Add equivocation detection to `insert_round_timeout()` similar to `insert_vote()`:

```rust
// In PendingVotes struct, add:
author_to_timeout: HashMap<Author, RoundTimeout>,

// In insert_round_timeout, before adding:
if let Some(previous_timeout) = self.author_to_timeout.get(&round_timeout.author()) {
    if previous_timeout.two_chain_timeout().hqc_round() != round_timeout.two_chain_timeout().hqc_round() {
        error!(SecurityEvent::ConsensusEquivocatingTimeout, ...);
        return VoteReceptionResult::EquivocateTimeout;
    }
}
```

**Fix 3: Strengthen SafetyRules check**
Track the last timeout signed per round to prevent re-signing:

```rust
// In SafetyData, add last_timeout_round field
// In guarded_sign_timeout_with_qc, check:
if timeout.round() <= safety_data.last_timeout_round {
    return Err(Error::AlreadySignedTimeout(...));
}
```

## Proof of Concept

While a complete Rust test would require extensive consensus infrastructure setup, the vulnerability can be demonstrated through the following logical sequence using the codebase:

1. Start validator in round R, send timeout with QC for round R-5
2. Restart validator (simulating crash)
3. Observe `timeout_sent = None` after init despite being in same round R
4. Trigger `EchoTimeout` by receiving f+1 timeouts
5. Observe validator creates second timeout with different QC (e.g., R-2)
6. Verify SafetyRules signs it (round == last_voted_round check passes)
7. Verify no equivocation detection in `insert_round_timeout()`
8. Confirm second timeout is silently dropped via `or_insert()`

The key validation points are confirmed in the codebase citations above.

## Notes

This vulnerability represents a gap between the theoretical safety properties of AptosBFT (validators should not equivocate) and the actual implementation (equivocation is possible but silently handled). While the immediate impact is mitigated by dropping duplicate signatures, the fundamental security property violation remains. Proper equivocation detection and potential slashing mechanisms are essential for long-term protocol security and validator accountability.

### Citations

**File:** consensus/src/liveness/round_state.rs (L160-163)
```rust
    // Vote sent locally for the current round.
    vote_sent: Option<Vote>,
    // Timeout sent locally for the current round.
    timeout_sent: Option<RoundTimeout>,
```

**File:** consensus/src/liveness/round_state.rs (L217-219)
```rust
    pub fn is_timeout_sent(&self) -> bool {
        self.vote_sent.as_ref().is_some_and(|v| v.is_timeout()) || self.timeout_sent.is_some()
    }
```

**File:** consensus/src/liveness/round_state.rs (L324-328)
```rust
    pub fn record_round_timeout(&mut self, timeout: RoundTimeout) {
        if timeout.round() == self.current_round {
            self.timeout_sent = Some(timeout)
        }
    }
```

**File:** consensus/src/round_manager.rs (L1009-1030)
```rust
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;

                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
```

**File:** consensus/src/round_manager.rs (L1821-1823)
```rust
            VoteReceptionResult::EchoTimeout(_) if !self.round_state.is_timeout_sent() => {
                self.process_local_timeout(round).await
            },
```

**File:** consensus/src/round_manager.rs (L2018-2030)
```rust
    pub async fn init(&mut self, last_vote_sent: Option<Vote>) {
        let epoch_state = self.epoch_state.clone();
        let new_round_event = self
            .round_state
            .process_certificates(self.block_store.sync_info(), &epoch_state.verifier)
            .expect("Can not jump start a round_state from existing certificates.");
        if let Some(vote) = last_vote_sent {
            self.round_state.record_vote(vote);
        }
        if let Err(e) = self.process_new_round_event(new_round_event).await {
            warn!(error = ?e, "[RoundManager] Error during start");
        }
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L404-408)
```rust
        Ok(RecoveryData {
            last_vote: match last_vote {
                Some(v) if v.epoch() == epoch => Some(v),
                _ => None,
            },
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L37-45)
```rust
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
```

**File:** consensus/src/pending_votes.rs (L190-271)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );

        let partial_tc = two_chain_votes.partial_2chain_tc_mut();
        let tc_voting_power =
            match validator_verifier.check_voting_power(partial_tc.signers(), true) {
                Ok(_) => {
                    return match partial_tc.aggregate_signatures(validator_verifier) {
                        Ok(tc_with_sig) => {
                            VoteReceptionResult::New2ChainTimeoutCertificate(Arc::new(tc_with_sig))
                        },
                        Err(e) => VoteReceptionResult::ErrorAggregatingTimeoutCertificate(e),
                    };
                },
                Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => voting_power,
                Err(error) => {
                    error!(
                        "MUST_FIX: 2-chain timeout vote received could not be added: {}, vote: {}",
                        error, timeout
                    );
                    return VoteReceptionResult::ErrorAddingVote(error);
                },
            };

        // Echo timeout if receive f+1 timeout message.
        if !self.echo_timeout {
            let f_plus_one = validator_verifier.total_voting_power()
                - validator_verifier.quorum_voting_power()
                + 1;
            if tc_voting_power >= f_plus_one {
                self.echo_timeout = true;
                return VoteReceptionResult::EchoTimeout(tc_voting_power);
            }
        }

        //
        // No TC could be formed, return the TC's voting power
        //

        VoteReceptionResult::VoteAdded(tc_voting_power)
    }
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```
