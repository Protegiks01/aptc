After thorough analysis of the DKG PVSS implementation in the Aptos Core codebase, I must validate this security claim.

# Audit Report

## Title
Missing Vector Size Validation in DKG PVSS Subtranscript Allows Incomplete Share Decryption

## Summary
The `Subtranscript` struct in the DKG PVSS chunky protocol lacks validation for the `Rs` (randomness) vector size during deserialization and verification. A malicious validator can craft transcripts with truncated `Rs` vectors that pass verification but corrupt the aggregated DKG transcript, causing decryption failures network-wide and breaking on-chain randomness generation.

## Finding Description

The vulnerability exists across multiple validation gaps that allow a single Byzantine validator to corrupt the entire DKG process:

**Gap 1: Deserialization Accepts Arbitrary Vector Sizes**

In v1, the `Subtranscript` struct uses standard BCS deserialization without size validation: [1](#0-0) 

In v2, the `Valid::check()` implementation performs no validation: [2](#0-1) 

**Gap 2: Verification Missing Rs Length Check**

The `verify` function validates `Cs.len()` and `Vs.len()` but omits `Rs.len()`: [3](#0-2) 

The same pattern exists in v2: [4](#0-3) 

**Gap 3: Silent Truncation During Decryption**

The `decrypt_chunked_scalars` function uses zip iteration which truncates at the shorter vector length: [5](#0-4) 

When Rs inner vectors have fewer chunks than expected, zip truncation produces incorrect decryption without errors.

**Expected Invariant Violation**

The `generate` function shows the expected invariant - Rs should have `sc.get_max_weight()` elements: [6](#0-5) 

**Aggregation Corruption**

The `aggregate_with` function only has debug assertions for Rs length, allowing truncated Rs to corrupt aggregated transcripts: [7](#0-6) 

**Attack Execution Path**

1. Malicious validator creates transcript with truncated Rs (either outer or inner dimensions)
2. Transcript passes verification due to missing Rs length check: [8](#0-7) 

3. During transcript aggregation, verification occurs before aggregation: [9](#0-8) 

4. Malicious transcript gets aggregated, corrupting the final transcript: [10](#0-9) 

5. All validators attempt to decrypt shares from corrupted transcript: [11](#0-10) 

6. Decryption failures break randomness setup, causing network-wide impact

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

- **Significant protocol violation**: DKG is critical infrastructure for on-chain randomness and validator epoch transitions
- **Network-wide impact**: A single malicious transcript corrupts the aggregated result used by all validators
- **Randomness failure**: Breaks VRF-based operations and randomness beacon functionality
- **Consensus degradation**: While epoch transition continues, randomness failure impacts leader election and other consensus features
- **No direct fund loss**: Does not enable theft of APT or other tokens
- **Recoverable**: Network can recover through DKG retry or governance intervention

The vulnerability affects all validators simultaneously when the corrupted aggregated transcript is used, making it a systemic issue rather than isolated node failure.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

- **Attack complexity**: LOW - requires only ability to submit DKG transcripts as a validator
- **Attacker requirements**: Must be in the validator set during DKG epoch (within threat model of single Byzantine validator)
- **Detection difficulty**: HIGH - truncated vectors pass cryptographic verification and only manifest during decryption
- **Execution barrier**: LOW - no sophisticated cryptographic knowledge required, simple vector manipulation
- **Impact scope**: Network-wide when malicious transcript enters aggregation

Any compromised or malicious validator in the dealer set can execute this attack during DKG participation. The attack exploits a clear validation gap rather than cryptographic weakness.

## Recommendation

Add explicit Rs vector size validation at multiple layers:

1. **Deserialization validation**: Implement size checks in `Valid::check()` for v2 and add validation wrapper for v1
2. **Verification layer**: Add Rs length validation in the `verify` function
3. **Aggregation safety**: Add runtime assertions (not just debug) in `aggregate_with`

Recommended fix for verification function:

```rust
// Add after existing Cs and Vs length checks
if self.subtrs.Rs.len() != sc.get_max_weight() {
    bail!(
        "Expected {} Rs vectors, but got {}",
        sc.get_max_weight(),
        self.subtrs.Rs.len()
    );
}

// Validate inner dimension
let expected_chunks = num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize;
for (i, Rs_vec) in self.subtrs.Rs.iter().enumerate() {
    if Rs_vec.len() != expected_chunks {
        bail!(
            "Expected {} chunks in Rs[{}], but got {}",
            expected_chunks,
            i,
            Rs_vec.len()
        );
    }
}
```

## Proof of Concept

A PoC would demonstrate:
1. Creating a Subtranscript with `Rs.len() < sc.get_max_weight()`
2. Serializing and deserializing it successfully
3. Passing it through `verify_transcript()` without errors
4. Showing decryption failures or incorrect values during `decrypt_own_share()`
5. Demonstrating aggregation corruption when combined with honest transcripts

The vulnerability can be triggered through the standard DKG flow by a malicious validator crafting a non-conformant transcript during the dealing phase.

## Notes

This vulnerability represents a critical gap in the DKG validation pipeline where cryptographic proofs are verified but structural invariants are not enforced. The use of Rust's zip iterator for aggregation and decryption amplifies the impact by silently truncating to the shortest vector, allowing the vulnerability to propagate through the system undetected until decryption failure occurs at the epoch boundary.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L102-109)
```rust
impl<E: Pairing> TryFrom<&[u8]> for Subtranscript<E> {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        bcs::from_bytes::<Subtranscript<E>>(bytes)
            .map_err(|_| CryptoMaterialError::DeserializationError)
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L387-413)
```rust
    fn aggregate_with(&mut self, sc: &SecretSharingConfig<E>, other: &Self) -> anyhow::Result<()> {
        debug_assert_eq!(self.Cs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Vs.len(), sc.get_total_num_players());
        debug_assert_eq!(self.Cs.len(), other.Cs.len());
        debug_assert_eq!(self.Rs.len(), other.Rs.len());
        debug_assert_eq!(self.Vs.len(), other.Vs.len());

        // Aggregate the V0s
        self.V0 += other.V0;

        for i in 0..sc.get_total_num_players() {
            for j in 0..self.Vs[i].len() {
                // Aggregate the V_{i,j}s
                self.Vs[i][j] += other.Vs[i][j];
                for k in 0..self.Cs[i][j].len() {
                    // Aggregate the C_{i,j,k}s
                    self.Cs[i][j][k] += other.Cs[i][j][k];
                }
            }
        }

        for j in 0..self.Rs.len() {
            for (R_jk, other_R_jk) in self.Rs[j].iter_mut().zip(&other.Rs[j]) {
                // Aggregate the R_{j,k}s
                *R_jk += other_R_jk;
            }
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L630-632)
```rust
                Rs: (0..sc.get_max_weight())
                    .map(|_| unsafe_random_points_group(num_chunks_per_share, rng))
                    .collect(),
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L366-370)
```rust
impl<E: Pairing> Valid for Subtranscript<E> {
    fn check(&self) -> Result<(), SerializationError> {
        Ok(())
    }
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L474-486)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunked_elgamal.rs (L327-333)
```rust
    for (row, Rs_row) in Cs_rows.iter().zip(Rs_rows.iter()) {
        // Compute C - d_k * R for each chunk
        let exp_chunks: Vec<C> = row
            .iter()
            .zip(Rs_row.iter())
            .map(|(C_ij, &R_j)| C_ij.sub(R_j * *dk))
            .collect();
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L117-121)
```rust
        if let Some(agg_trx) = trx_aggregator.trx.as_mut() {
            S::aggregate_transcripts(&self.dkg_pub_params, agg_trx, transcript);
        } else {
            trx_aggregator.trx = Some(transcript);
        }
```

**File:** consensus/src/epoch_manager.rs (L1066-1072)
```rust
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;
```
