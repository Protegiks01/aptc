# Audit Report

## Title
Consensus Split During OnChainConsensusConfig V4→V5 Migration Due to BCS Deserialization Incompatibility

## Summary
During migration from OnChainConsensusConfig V4 to V5, validators running pre-V5 code fail to deserialize the new config format and silently fall back to a default configuration with validator transactions disabled, while V5-aware validators correctly deserialize and see validator transactions as enabled. This creates divergent block validation rules that cause consensus safety violations.

## Finding Description

The vulnerability exists in the handling of `OnChainConsensusConfig` version upgrades when the on-chain config is updated from V4 to V5. The V5 variant adds a `rand_check_enabled: bool` field that V4-only code cannot deserialize due to BCS enum forward-incompatibility.

**Critical Code Paths:**

1. **Native Function Fallback** - The `validator_txn_enabled()` native function uses `unwrap_or_default()` when BCS deserialization fails: [1](#0-0) 

2. **Epoch Manager Fallback** - During epoch initialization, failed deserialization falls back to default config: [2](#0-1) 

3. **Default Configuration** - The default config returns V4 with validator transactions DISABLED: [3](#0-2) 

4. **ValidatorTxnConfig Default** - Returns V0 (disabled) when config is missing: [4](#0-3) [5](#0-4) 

5. **Block Validation** - RoundManager rejects ProposalExt blocks when vtxn is disabled: [6](#0-5) 

6. **Proposal Generation** - V5 validators create ProposalExt blocks when vtxn is enabled: [7](#0-6) 

7. **Governance Reconfiguration** - Uses validator_txn_enabled() to determine reconfiguration path: [8](#0-7) 

**Attack Scenario:**

BCS enum deserialization is NOT forward-compatible. The OnChainConsensusConfig enum is defined with variants V1-V5 (indices 0-4): [9](#0-8) 

When code expecting V4 (indices 0-3) receives V5 data (index 4), BCS deserialization fails. This creates the following sequence:

1. Network has validators running mixed versions during rolling upgrade
2. Governance proposal updates consensus config from V4 to V5 via `set_for_next_epoch()`: [10](#0-9) 

3. **V5-aware validators**: Successfully deserialize, see `vtxn_enabled() = true`
4. **V4-only validators**: Deserialization fails, fall back to `default()` which has `vtxn: ValidatorTxnConfig::V0` (disabled)
5. When a block with `BlockType::ProposalExt` is proposed by V5 validators:
   - V5 validators: Accept the block (vtxn enabled)
   - V4 validators: Reject with error "ProposalExt unexpected while the vtxn feature is disabled"
6. **Consensus split occurs** - validators disagree on block validity, violating consensus safety

This breaks the critical invariant that all validators must produce identical validation results for identical blocks.

## Impact Explanation

This is a **CRITICAL** severity issue under Aptos bug bounty criteria:

- **Consensus/Safety Violation**: Validators reach different conclusions about block validity, directly violating the AptosBFT safety guarantee that < 1/3 Byzantine validators cannot cause chain splits
- **Non-recoverable Network Partition**: Once validators diverge on block validation, the network cannot achieve consensus without manual intervention or emergency hardfork
- **Breaks Deterministic Execution Invariant**: Different validators execute governance reconfiguration logic differently based on their view of `validator_txn_enabled()`

The impact affects:
- All validators during config migration period
- Governance operations that depend on `validator_txn_enabled()`
- DKG (Distributed Key Generation) reconfiguration logic
- Network liveness and safety properties

This qualifies as Category #2 Critical Impact: "Different validators commit different blocks" leading to chain splits without requiring Byzantine validators.

## Likelihood Explanation

**High Likelihood** - This vulnerability will trigger automatically during routine network upgrades:

1. **No attacker required**: The issue manifests naturally during any V4→V5 config migration while validators run mixed software versions
2. **Standard upgrade procedure**: Rolling validator upgrades are the recommended deployment model for network stability
3. **No special permissions needed**: The vulnerability is triggered by normal governance proposals
4. **Silent failure**: The `unwrap_or_default()` pattern suppresses errors, preventing early detection
5. **Observable in production**: Any network attempting V5 config deployment before 100% validator upgrade completion will experience this

The only mitigation currently is perfect coordination requiring ALL validators to upgrade before config change, which contradicts standard rolling upgrade practices.

## Recommendation

Implement version-safe deserialization that handles forward compatibility:

1. **Add explicit version checking** before applying config changes:
   - Reject V5 config updates if any validator is running V4-only code
   - Add on-chain validator version tracking

2. **Replace unwrap_or_default() with proper error handling**:
   - Log warnings when deserialization fails
   - Require explicit acknowledgment of config version support

3. **Implement graceful degradation**:
   - Allow V4 code to deserialize V5 config by ignoring unknown fields
   - Add a compatibility layer that extracts V4-compatible fields from V5 config

4. **Add coordination mechanism**:
   - Require minimum validator version before allowing V5 config updates
   - Add governance checks that validate validator readiness

## Proof of Concept

While a full end-to-end test requires a multi-validator testnet, the vulnerability can be demonstrated by:

1. Serialize a V5 config with vtxn enabled
2. Attempt to deserialize with V4-only code (simulated by removing V5 from the enum)
3. Observe deserialization failure and fallback to default with vtxn disabled
4. Show that this creates divergent `vtxn_enabled()` results

The core BCS incompatibility is inherent to the enum design and the unwrap_or_default pattern used throughout the codebase.

## Notes

This vulnerability represents a fundamental issue in how versioned on-chain configs are handled during rolling upgrades. The `unwrap_or_default()` pattern, while providing fault tolerance for missing configs, creates a silent failure mode during version migrations that leads to consensus divergence.

The issue is particularly critical because:
- It affects core consensus behavior (block validation)
- It has no visible warnings or errors
- It contradicts recommended deployment practices (rolling upgrades)
- Recovery requires emergency coordination or hardfork

### Citations

**File:** aptos-move/framework/src/natives/consensus_config.rs (L19-19)
```rust
    let config = bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes).unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L147-149)
```rust
    pub fn default_if_missing() -> Self {
        Self::V0
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L162-167)
```rust
    pub fn enabled(&self) -> bool {
        match self {
            ValidatorTxnConfig::V0 => false,
            ValidatorTxnConfig::V1 { .. } => true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L190-213)
```rust
/// The on-chain consensus config, in order to be able to add fields, we use enum to wrap the actual struct.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub enum OnChainConsensusConfig {
    V1(ConsensusConfigV1),
    V2(ConsensusConfigV1),
    V3 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
    },
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
    V5 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
        // Whether to check if we can skip generating randomness for blocks
        rand_check_enabled: bool,
    },
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/src/round_manager.rs (L1116-1124)
```rust
        if !self.vtxn_config.enabled()
            && matches!(
                proposal.block_data().block_type(),
                BlockType::ProposalExt(_)
            )
        {
            counters::UNEXPECTED_PROPOSAL_EXT_COUNT.inc();
            bail!("ProposalExt unexpected while the vtxn feature is disabled.");
        }
```

**File:** consensus/src/liveness/proposal_generator.rs (L534-543)
```rust
        let block = if self.vtxn_config.enabled() {
            BlockData::new_proposal_ext(
                validator_txns,
                payload,
                self.author,
                failed_authors,
                round,
                timestamp,
                quorum_cert,
            )
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L687-687)
```text
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```
