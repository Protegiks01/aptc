# Audit Report

## Title
DoS Amplification via Unauthenticated Expensive Cryptographic Verification in Secret Share Manager

## Summary
The `verification_task()` function in the consensus secret sharing manager performs expensive pairing-based cryptographic verification on incoming `SecretShareMessage::Share` messages without validating the sender identity or share author beforehand. Byzantine validators can exploit this to send malicious shares that pass lightweight checks but trigger computationally expensive verification operations, causing DoS amplification and validator node slowdowns.

## Finding Description

The vulnerability exists in the secret share verification pipeline. When a `SecretShareMessage::Share` arrives from the network, it is wrapped in an `IncomingSecretShareRequest` containing a `sender` field that identifies the peer who sent the message. [1](#0-0) 

However, this sender field is marked with `#[allow(unused)]` and is never validated before expensive cryptographic operations are performed. The message flows to `verification_task()` which only performs two checks before expensive verification: [2](#0-1) 

The function deserializes the message and calls `msg.verify()` without checking if the sender matches the share author. For Share messages, this delegates to cryptographic verification: [3](#0-2) 

The verification calls the share's verify method: [4](#0-3) 

Note the TODO comment at line 78 acknowledging missing bounds checking. The verification proceeds to perform BLS signature verification using expensive pairing operations: [5](#0-4) 

Each `verify_bls()` call performs **two pairing operations** (lines 126-127), which are among the most expensive cryptographic primitives. For weighted validators, the attack is amplified as verification iterates over all virtual players: [6](#0-5) 

**Critical Issue**: A Byzantine validator can send malicious shares with:
1. Correct epoch (passes epoch check)
2. Valid BCS structure (passes deserialization)
3. Any author field value
4. Invalid cryptographic data

Since the sender is never checked against the share author before expensive verification, the attack succeeds in consuming CPU resources even though the cryptographic verification will eventually fail.

The BoundedExecutor provides concurrency limits but doesn't prevent the attack: [7](#0-6) 

While tasks wait for permits, malicious verification tasks consume CPU resources. The attacker can continuously send shares as queue space becomes available when verification tasks complete.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria: "Validator node slowdowns - Significant performance degradation affecting consensus - DoS through resource exhaustion."

**Specific impacts:**
- **CPU Exhaustion**: Each malicious share triggers multiple pairing operations (2 Ã— number of virtual players for weighted validators)
- **Verification Backlog**: Legitimate shares are delayed as the bounded executor capacity is saturated with failing verification attempts
- **Consensus Delays**: Random beacon generation depends on threshold secret shares; verification delays impact consensus liveness
- **Amplification Factor**: Validators with higher weights have more virtual players, amplifying the attack cost

The attack is effective because:
- No rate limiting per validator before expensive verification
- No authentication that sender matches share author
- BoundedExecutor only limits concurrency, not total malicious work consumed
- Attacker can send messages much faster than verification completes
- The per-peer channel queue limit (10 messages) is insufficient as space opens up when tasks complete

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a validator in the current epoch (Byzantine validator under 1/3 assumption - within Aptos threat model)
- Network access to consensus layer (standard for validators)
- Can observe current epoch from any node (public information)

**Attack Simplicity:**
- Craft messages with correct epoch (publicly observable)
- Use any validator address as author in share
- Include random cryptographic points as share data
- Send at high rate through consensus network

**No Special Conditions Required:**
- No race conditions to exploit
- No timing dependencies
- Works against all validators simultaneously
- Effective throughout entire epoch
- Requires minimal resources from attacker

## Recommendation

Add sender authentication before expensive cryptographic verification:

```rust
async fn verification_task(
    epoch_state: Arc<EpochState>,
    mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
    verified_msg_tx: UnboundedSender<SecretShareRpc>,
    config: SecretShareConfig,
    bounded_executor: BoundedExecutor,
) {
    while let Some(dec_msg) = incoming_rpc_request.next().await {
        let tx = verified_msg_tx.clone();
        let epoch_state_clone = epoch_state.clone();
        let config_clone = config.clone();
        let sender = dec_msg.sender; // Extract sender
        
        bounded_executor
            .spawn(async move {
                match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                    Ok(msg) => {
                        // CHECK: Verify sender matches author before expensive verification
                        if let SecretShareMessage::Share(ref share) = msg {
                            if share.author != sender {
                                warn!("Share author mismatch: sender={}, author={}", sender, share.author);
                                return;
                            }
                        }
                        
                        if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                            let _ = tx.unbounded_send(SecretShareRpc {
                                msg,
                                protocol: dec_msg.protocol,
                                response_sender: dec_msg.response_sender,
                            });
                        }
                    },
                    Err(e) => {
                        warn!("Invalid dec message: {}", e);
                    },
                }
            })
            .await;
    }
}
```

Additionally, consider implementing per-validator rate limiting before spawning verification tasks.

## Proof of Concept

A Byzantine validator can execute this attack by:

1. Connecting to the consensus network as a validator
2. Sending `SecretShareMessage::Share` messages with:
   - Current epoch (obtained from network state)
   - Any author field (including their own or others)
   - Random invalid cryptographic share data
3. Sending messages at high rate (limited only by network bandwidth)
4. Each message triggers expensive pairing operations before failing verification
5. Legitimate shares are delayed as the bounded executor saturates

The attack can be demonstrated by modifying a validator node to send such messages, observing CPU utilization spike on victim validators and increased latency in secret share aggregation affecting random beacon generation and consensus timing.

## Notes

The vulnerability is confirmed present in the codebase. The sender field is explicitly marked as unused, and no validation occurs to check that the network sender matches the cryptographic share author before expensive pairing-based verification operations. This allows Byzantine validators to amplify DoS attacks by triggering expensive cryptographic operations that will fail, but only after consuming significant CPU resources. The attack aligns with High Severity "Validator node slowdowns" impact category in the Aptos bug bounty program.

### Citations

**File:** consensus/src/network.rs (L154-161)
```rust
#[derive(Debug)]
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L27-38)
```rust
impl SecretShareMessage {
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** crates/aptos-batch-encryption/src/shared/key_derivation.rs (L118-133)
```rust
fn verify_bls(
    verification_key_g2: G2Affine,
    digest: &Digest,
    offset: G2Affine,
    signature: G1Affine,
) -> Result<()> {
    let hashed_offset: G1Affine = symmetric::hash_g2_element(offset)?;

    if PairingSetting::pairing(digest.as_g1() + hashed_offset, verification_key_g2)
        == PairingSetting::pairing(signature, G2Affine::generator())
    {
        Ok(())
    } else {
        Err(anyhow::anyhow!("bls verification error"))
    }
}
```

**File:** crates/aptos-batch-encryption/src/schemes/fptx_weighted.rs (L149-169)
```rust
    pub fn verify_decryption_key_share(
        &self,
        digest: &Digest,
        dk_share: &WeightedBIBEDecryptionKeyShare,
    ) -> Result<()> {
        (self.vks_g2.len() == dk_share.1.len())
            .then_some(())
            .ok_or(BatchEncryptionError::DecryptionKeyVerifyError)?;

        self.vks_g2
            .iter()
            .map(|vk_g2| BIBEVerificationKey {
                mpk_g2: self.mpk_g2,
                vk_g2: *vk_g2,
                player: self.weighted_player, // arbitrary
            })
            .zip(&dk_share.1)
            .try_for_each(|(vk, dk_share)| {
                vk.verify_decryption_key_share(digest, &(self.weighted_player, dk_share.clone()))
            })
    }
```

**File:** crates/bounded-executor/src/executor.rs (L45-52)
```rust
    pub async fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        let permit = self.acquire_permit().await;
        self.executor.spawn(future_with_permit(future, permit))
    }
```
