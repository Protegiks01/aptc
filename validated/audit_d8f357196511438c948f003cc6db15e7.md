# Audit Report

## Title
Premature Peer Score Update Allows Malicious Peers to Boost Reputation by Serving Invalid Data

## Summary
The `send_request_to_peer()` function updates peer scores immediately upon receiving a network-level response, before validating compression settings or response data type. Malicious peers can exploit this timing gap to maintain artificially high scores by sending well-formed but invalid responses that pass network checks but fail later validation stages, with compression validation failures never triggering score penalties.

## Finding Description

The vulnerability exists in the peer scoring mechanism within the Aptos data client's request handling flow, specifically in how peer scores are updated relative to response validation.

**Problem 1: Immediate Score Update Before Validation**

When a peer successfully responds at the network layer, the score is immediately incremented by +1.0 before any validation of the response content occurs. [1](#0-0) 

The score update uses a success delta of +1.0 capped at a maximum score of 100.0. [2](#0-1)  The actual score increment is implemented as: [3](#0-2) 

**Problem 2: Compression Validation Failures Without Score Penalties**

After the score has already been updated, the response undergoes compression validation. If the compression settings don't match the request (compressed when uncompressed was requested, or vice versa), the function returns an `Error::InvalidResponse` directly without invoking the response callback mechanism. [4](#0-3) 

This creates an asymmetry with type conversion failures, which DO call the response callback to penalize the peer: [5](#0-4) 

**Attack Execution Path:**

1. Malicious peer receives a data request from an honest node
2. Peer sends a response with intentionally wrong compression settings  
3. Response passes network/RPC layer checks [6](#0-5) 
4. Peer immediately receives +1.0 score boost [1](#0-0) 
5. Response validation detects compression mismatch and returns error, but never calls the response callback to penalize the peer
6. Peer maintains inflated score and continues to be preferentially selected for future requests

**Score Penalty Mechanisms That Don't Apply:**

The peer scoring system defines error multipliers that should apply to bad responses:
- NotUseful errors: 0.95x multiplier
- Malicious errors: 0.8x multiplier [7](#0-6) 

These penalties are applied through the `update_score_error()` function: [8](#0-7) 

However, compression validation failures bypass this mechanism entirely by returning errors before the callback can be invoked.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program under the "Validator Node Slowdowns" category.

**1. Validator Node Resource Waste:** Malicious peers can repeatedly send invalid data while maintaining high reputation scores, forcing honest nodes to waste resources on:
- Network bandwidth receiving invalid responses
- CPU cycles attempting decompression/validation  
- Memory allocations for invalid payloads
- Request retry logic when validation fails [9](#0-8) 

**2. State Sync Disruption:** The multi-peer request system tries multiple peers in parallel, but malicious peers with artificially inflated scores will be preferentially selected, causing wasted fetch attempts and degraded data availability for nodes catching up to the network.

**3. Peer Reputation System Subversion:** The ignore threshold mechanism at 25.0 is designed to filter out low-quality peers [10](#0-9) , but malicious peers exploiting this vulnerability can stay above this threshold indefinitely.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No Special Access Required:** Any network peer can connect to validator nodes and serve data responses - no validator credentials or stake required

2. **Trivial Exploitation:** The attack requires only sending responses with mismatched compression flags, which is a simple protocol violation requiring no sophisticated tooling

3. **No Detection Mechanism:** The current scoring system has no mechanism to detect peers consistently sending invalid data while maintaining high scores through this exploit

4. **Continuous Opportunity:** State sync is an ongoing process with frequent peer requests, providing continuous exploitation opportunities

5. **Resource Asymmetry:** The cost to the attacker (bandwidth for invalid responses) is minimal compared to the cost imposed on victims (validation overhead, retry logic, bandwidth waste)

## Recommendation

Move the peer score update to occur AFTER all validation checks have passed, or ensure that ALL validation failure paths invoke the response callback to apply appropriate penalties.

**Option 1: Delay Score Update**
Move line 817 to occur after compression validation and type conversion succeed.

**Option 2: Add Callback Invocation for Compression Failures**
Modify the compression validation logic to invoke the response callback before returning the error:

```rust
// In send_request_to_peer_and_decode() at lines 738-748
if request.use_compression && !storage_response.is_compressed() {
    context.response_callback.notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(...)));
} else if !request.use_compression && storage_response.is_compressed() {
    context.response_callback.notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(...)));
}
```

**Option 3: Conditional Score Update**
Only update the score upon successful validation, not just successful network response.

## Proof of Concept

A proof of concept would involve:

1. Set up a malicious peer that monitors for incoming `StorageServiceRequest` messages
2. For each request, respond with intentionally mismatched compression settings:
   - If `use_compression == true`, send uncompressed `StorageServiceResponse`
   - If `use_compression == false`, send compressed `StorageServiceResponse`
3. Monitor the peer's score over multiple requests - it should increase despite sending invalid data
4. Observe that the peer remains above the ignore threshold and continues to be selected
5. Measure the resource waste on victim nodes processing these invalid responses

The existing test files at `state-sync/aptos-data-client/src/tests/compression.rs` demonstrate that compression mismatches result in errors, but they don't verify that peer scores are penalized appropriately for these failures.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L675-695)
```rust
        // Wait for the first successful response and abort all other tasks.
        // If all requests fail, gather the errors and return them.
        let num_sent_requests = sent_requests.len();
        let mut sent_request_errors = vec![];
        for _ in 0..num_sent_requests {
            if let Ok(response_result) = sent_requests.select_next_some().await {
                match response_result {
                    Ok(response) => {
                        // We received a valid response. Abort all pending tasks.
                        for abort_handle in abort_handles {
                            abort_handle.abort();
                        }
                        return Ok(response); // Return the response
                    },
                    Err(error) => {
                        // Gather the error and continue waiting for a response
                        sent_request_errors.push(error)
                    },
                }
            }
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L738-748)
```rust
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L753-761)
```rust
            match T::try_from(storage_response) {
                Ok(new_payload) => Ok(Response::new(context, new_payload)),
                // If the variant doesn't match what we're expecting, report the issue
                Err(err) => {
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
                },
```

**File:** state-sync/aptos-data-client/src/client.rs (L798-799)
```rust
        match result {
            Ok(response) => {
```

**File:** state-sync/aptos-data-client/src/client.rs (L817-817)
```rust
                self.peer_states.update_score_success(peer);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L33-37)
```rust
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L38-41)
```rust
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L42-43)
```rust
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```
