# Audit Report

## Title
Batch Ordering Mismatch in OptQuorumStore Payloads Causes Verification Failures for Expired Optimistic Batches

## Summary
A logic bug exists in the OptQuorumStore payload handling where expired optimistic batches are excluded from the transaction list during payload creation but their metadata remains in the batch info list. During verification by consensus observers, expired opt batches cannot be skipped (unlike proof batches), causing transaction iterator misalignment and digest verification failures, leading to rejection of valid blocks.

## Finding Description

The vulnerability stems from inconsistent handling of expired optimistic batches between payload creation and verification.

**During Payload Creation:**

When `get_transactions` processes an `OptQuorumStore` payload, it calls `process_optqs_payload` for opt_batches, which internally invokes `request_transactions`. [1](#0-0) 

The `request_transactions` function explicitly skips expired batches by checking `if block_timestamp <= batch_info.expiration()` and only requesting non-expired batches. [2](#0-1) 

However, when creating the `BlockTransactionPayload`, ALL opt batch metadata (including expired ones) is included via `opt_qs_payload.opt_batches().deref().clone()`. [3](#0-2) 

This creates a mismatch: the transaction list excludes expired opt batch transactions, but the batch info list includes all opt batch metadata.

**During Verification:**

The `verify_payload_digests` method processes opt_and_inline_batches with `skip_expired_batches=false`. [4](#0-3) 

The `reconstruct_batch` function only skips expired batches when `skip_expired_batches=true`. [5](#0-4) 

Since opt batches are verified with `skip_expired_batches=false`, the verifier attempts to consume transactions for expired opt batches that don't exist in the transaction list. This causes the iterator to consume transactions from subsequent batches, resulting in digest mismatches.

When verification fails, the consensus observer logs an error and rejects the block payload. [6](#0-5) 

**Root Cause:**

The asymmetry exists because:
- Proof batches can be skipped during both creation and verification (expired proofs are filtered in both paths)
- Inline batches have transactions embedded, so they're always present
- Opt batches are treated like proof batches during creation (transactions excluded if expired) but like inline batches during verification (cannot be skipped)

This violates the invariant that the transaction list and batch metadata list must correspond exactly during verification.

## Impact Explanation

**Severity: Medium (up to $10,000)**

This vulnerability causes state inconsistencies requiring manual intervention, fitting the Medium severity category in the Aptos bug bounty program.

**Specific Impacts:**

1. **Consensus Observer Rejection**: Legitimate blocks containing expired optimistic batches are rejected by consensus observers, causing observers to fall out of sync with the validator network.

2. **State Divergence**: Observers diverge from validators when processing blocks with expired opt batches, creating temporary state inconsistencies requiring manual resynchronization through state sync.

3. **Observer Network Degradation**: If multiple observers are affected, it reduces the reliability of the observer network for downstream applications.

**Why Not Critical:**
- No direct fund loss or theft
- No consensus safety violation among validators (they execute blocks successfully)
- Validators can still progress normally
- No permanent network partition (observers can resync)
- Recovery is possible through state sync mechanisms

**Why Medium:**
- Creates state inconsistencies between observers and validators
- Requires manual intervention to resynchronize affected nodes
- Affects network infrastructure reliability
- Natural occurrence under realistic conditions

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability triggers under realistic operational conditions:

1. **Active Feature**: OptQuorumStore is an actively used feature in Aptos consensus for optimistic batch processing.

2. **Natural Occurrence**: Opt batches have expiration timestamps calculated from creation time. Network delays or high transaction volume can cause batches to expire between when they're pulled for inclusion in a block and when observers receive and verify the block.

3. **No Attacker Required**: This is a logic bug that occurs naturally during normal network operation when timing variations cause opt batches to expire.

4. **Timing Conditions**: The vulnerability requires that opt batches expire (relative to block timestamp) between batch selection and observer verification. This can happen with:
   - Network congestion causing processing delays
   - High transaction volume creating many batches with varying expiration times
   - Normal timing variations in distributed systems

The likelihood is not High because it requires specific timing conditions where opt batches expire, rather than occurring on every block. However, it's not Low because these timing conditions are realistic and expected in normal network operation.

## Recommendation

The fix should make opt batch expiration handling consistent between creation and verification. Two potential approaches:

**Option 1 (Recommended): Filter expired opt batches from metadata during creation**
```rust
// In quorum_store_payload_manager.rs, around line 535-539
// Instead of including all opt_batches metadata:
let non_expired_opt_batches: Vec<BatchInfo> = opt_qs_payload
    .opt_batches()
    .iter()
    .filter(|batch| block.timestamp_usecs() <= batch.expiration())
    .cloned()
    .collect();

[
    non_expired_opt_batches,
    opt_qs_payload.inline_batches().batch_infos(),
]
.concat()
```

**Option 2: Allow skipping expired opt batches during verification**
```rust
// In observer_message.rs, separate opt batches from inline batches
// and verify opt batches with skip_expired_batches=true
// This requires changes to the payload structure to distinguish them
```

Option 1 is simpler and maintains the invariant that metadata always corresponds to present transactions.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating an OptQuorumStore payload with opt batches that have varying expiration times
2. Setting the block timestamp such that some opt batches are expired
3. Observing that `get_transactions` excludes expired opt batch transactions but includes their metadata
4. Attempting to verify the payload and observing the digest mismatch error

A full PoC would require setting up a test environment with:
- Mock batch reader that returns transactions for non-expired batches
- OptQuorumStore payload construction with mixed expired/non-expired opt batches
- Verification of the resulting BlockTransactionPayload showing the failure

The test at lines 1690-1775 in observer_message.rs demonstrates similar expiration handling for proof batches and inline batches, confirming the expected behavior. [7](#0-6) 

## Notes

This vulnerability specifically affects the consensus observer path, not validator execution. Validators successfully create and execute blocks with expired opt batches. The issue only manifests when consensus observers attempt to verify these blocks, causing them to reject valid blocks and fall out of sync with the validator network.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L102-106)
```rust
            if block_timestamp <= batch_info.expiration() {
                futures.push(batch_reader.get_batch(batch_info, responders.clone()));
            } else {
                debug!("QSE: skipped expired batch {}", batch_info.digest());
            }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L512-518)
```rust
                let opt_batch_txns = process_optqs_payload(
                    opt_qs_payload.opt_batches(),
                    self.batch_reader.clone(),
                    block,
                    &self.ordered_authors,
                    block_signers.as_ref(),
                )
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L535-539)
```rust
                    [
                        opt_qs_payload.opt_batches().deref().clone(),
                        opt_qs_payload.inline_batches().batch_infos(),
                    ]
                    .concat(),
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L914-914)
```rust
            match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, false) {
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L996-998)
```rust
    if skip_expired_batches && block_info.timestamp_usecs() > expected_batch_info.expiration() {
        return Ok(None);
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L1690-1775)
```rust
    #[test]
    fn test_verify_payload_digests_expired() {
        // Create a new block info with the specified timestamp
        let block_timestamp = 1000;
        let block_info = BlockInfo::new(
            0,
            0,
            HashValue::random(),
            HashValue::random(),
            0,
            block_timestamp,
            None,
        );

        // Create multiple signed transactions
        let num_signed_transactions = 100;
        let signed_transactions = create_signed_transactions(num_signed_transactions);

        // Create multiple batch proofs (where some batches are expired)
        let (proofs, non_expired_transactions) =
            create_mixed_expiration_proofs(block_timestamp, &signed_transactions);

        // Create a block payload (with non-expired transactions, all proofs and no inline batches)
        let block_payload = create_block_payload(
            Some(block_info.clone()),
            &non_expired_transactions,
            &proofs,
            &[],
        );

        // Verify the block payload digests and ensure it passes
        assert_ok!(block_payload.verify_payload_digests());

        // Create multiple inline transactions
        let num_inline_transactions = 25;
        let inline_transactions = create_signed_transactions(num_inline_transactions);

        // Create multiple inline batches (where some batches are expired)
        let (inline_batches, non_expired_inline_transactions) =
            create_mixed_expiration_proofs(block_timestamp, &inline_transactions);

        // Create a block payload (with all non-expired inline transactions, no proofs and inline batches)
        let inline_batches: Vec<_> = inline_batches
            .iter()
            .map(|proof| proof.info().clone())
            .collect();
        let block_payload = create_block_payload(
            Some(block_info.clone()),
            &non_expired_inline_transactions,
            &[],
            &inline_batches,
        );

        // Verify the block payload digests and ensure it fails (expired inline batches are still checked)
        let error = block_payload.verify_payload_digests().unwrap_err();
        assert_matches!(error, Error::InvalidMessageError(_));

        // Create a block payload (with all inline transactions, no proofs and inline batches)
        let block_payload = create_block_payload(
            Some(block_info.clone()),
            &inline_transactions,
            &[],
            &inline_batches,
        );

        // Verify the block payload digests and ensure it now passes
        assert_ok!(block_payload.verify_payload_digests());

        // Gather all transactions (from both QS and inline batches)
        let all_transactions: Vec<_> = non_expired_transactions
            .iter()
            .chain(inline_transactions.iter())
            .cloned()
            .collect();

        // Create a block payload (with all transactions, all proofs and inline batches)
        let block_payload = create_block_payload(
            Some(block_info),
            &all_transactions,
            &proofs,
            &inline_batches,
        );

        // Verify the block payload digests and ensure it passes
        assert_ok!(block_payload.verify_payload_digests());
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L386-396)
```rust
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
```
