# Audit Report

## Title
Timeout Signature Equivocation in SafetyRules: Missing Duplicate Round Check Allows Multiple Timeout Signatures for Same Round

## Summary
The `guarded_sign_timeout_with_qc()` function in SafetyRules contains a logic flaw where `timeout.round() == last_voted_round` is not explicitly handled, allowing validators to sign multiple different timeout messages for the same round after crash recovery. This enables timeout signature equivocation that violates BFT consensus safety assumptions.

## Finding Description

The vulnerability exists in the `guarded_sign_timeout_with_qc()` function where round equality is not properly checked. [1](#0-0) 

When `timeout.round() == last_voted_round`, neither conditional branch executes:
- The less-than check at line 37 evaluates to false
- The greater-than check at line 43 evaluates to false
- Execution proceeds directly to signing without checking for previous timeouts

**Critical Difference from Voting Protection:**

The voting logic has explicit equivocation protection by storing and returning the previous vote when the same round is encountered. [2](#0-1) 

However, `SafetyData` lacks a `last_timeout` field for equivalent protection. [3](#0-2) 

The structure only stores `highest_timeout_round` (u64), not the full timeout object like `last_vote: Option<Vote>`.

**Why Different QCs Produce Different Signatures:**

Timeout signatures are created over `TimeoutSigningRepr` which includes `hqc_round`. [4](#0-3) 

The `signing_format()` method extracts the `hqc_round` from the embedded QuorumCert. [5](#0-4) 

Where `hqc_round()` returns the QC's certified block round. [6](#0-5) 

Therefore, two timeouts for the same round with different QCs produce different `TimeoutSigningRepr` structures and thus different signatures.

**Realistic Attack Scenario (Crash Recovery):**

The consensus layer has upper-layer protection via `timeout_sent()` check. [7](#0-6) 

However, `timeout_sent` is stored only in-memory within `RoundState`. [8](#0-7) 

On validator restart, `RoundState` is recreated with `timeout_sent = None`. [9](#0-8) 

When `process_certificates()` is called to advance to a new round, it resets the timeout state. [10](#0-9) 

Meanwhile, `last_voted_round` is persisted to disk via `SafetyData` in `PersistentSafetyStorage` and survives restarts. [11](#0-10) 

**Exploit Sequence:**
1. Validator in round 10, signs timeout with QC at round 8 → `last_voted_round = 10` (persisted), `timeout_sent = Some(...)` (memory)
2. Validator crashes before round advances
3. On restart: `RoundState` created with `timeout_sent = None`
4. `process_certificates()` called → sets `current_round = 10`, `timeout_sent = None`
5. `last_voted_round = 10` loaded from persistent storage
6. Validator receives new QC for round 9 (higher than previous)
7. Timeout occurs on round 10 again
8. `timeout_sent()` returns `None` (lost in crash)
9. Creates new timeout with QC at round 9
10. Calls `sign_timeout_with_qc(round=10)` with `last_voted_round=10`
11. Neither `10 < 10` nor `10 > 10` is true → both checks pass through
12. Signs `TimeoutSigningRepr{epoch:1, round:10, hqc_round:9}` (different from first signature)

Result: Two distinct signatures for round 10 with different `hqc_round` values.

## Impact Explanation

**Severity: Critical (Consensus/Safety Violation)**

This vulnerability directly violates AptosBFT consensus safety assumptions by enabling timeout signature equivocation. The impacts include:

1. **BFT Safety Compromise**: A single honest validator can produce conflicting timeout messages for the same round without Byzantine behavior, violating the fundamental BFT assumption that honest validators don't equivocate. This weakens consensus security guarantees that rely on at most f Byzantine validators.

2. **Network Confusion**: Different nodes receiving different timeout signatures from the same validator for the same round causes inconsistent timeout certificate aggregation, potentially leading to disagreement on round advancement.

3. **Consensus Liveness Risk**: Conflicting timeout messages can cause validators to disagree on which timeout certificate is valid, potentially stalling consensus progress.

4. **Protocol Invariant Violation**: The asymmetry between voting protection (with `last_vote` storage) and timeout protection (without `last_timeout` storage) indicates this is an unintended bug rather than a design choice.

Per Aptos bug bounty criteria, this qualifies as a consensus-layer vulnerability that enables protocol violations with fewer than f+1 Byzantine validators, as equivocation occurs through normal crash recovery rather than Byzantine behavior.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can be triggered through realistic operational scenarios:

1. **Crash/Restart Scenarios**: Natural validator crashes or restarts (power failures, software updates, resource exhaustion) create the conditions where `timeout_sent` is lost but `last_voted_round` persists. This is a normal operational event.

2. **No Trusted Role Compromise Required**: The vulnerability triggers through normal crash recovery mechanisms, not through malicious validator operators or compromised keys.

3. **Timing Window**: The vulnerability has a realistic timing window - crashes can occur during active consensus rounds, and receiving new QCs after restart is common in active networks.

4. **No Test Coverage**: The existing test suite does not cover the equal-round timeout case. [12](#0-11) 

The upper-layer protection (`timeout_sent()` check) only works within a single validator session. Across crash boundaries, the protection is lost while the vulnerable state (`last_voted_round`) persists.

## Recommendation

Add explicit handling for the `timeout.round() == last_voted_round` case in `guarded_sign_timeout_with_qc()`:

**Option 1: Store Last Timeout (Preferred)**
Add a `last_timeout: Option<TwoChainTimeout>` field to `SafetyData` structure, similar to `last_vote`. When `timeout.round() == last_voted_round`, return an error or re-sign the same timeout to ensure idempotency.

**Option 2: Reject Equal Round Timeouts**
Modify the condition at line 37 from `<` to `<=` to reject timeout attempts for rounds that have already been voted on/timed out:
```rust
if timeout.round() <= safety_data.last_voted_round {
    return Err(Error::IncorrectLastVotedRound(
        timeout.round(),
        safety_data.last_voted_round,
    ));
}
```

Option 1 is preferred as it maintains consistency with the voting logic and provides idempotent behavior across crashes.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a validator with `last_voted_round = 10`
2. Clearing the in-memory `timeout_sent` state (simulating crash)
3. Calling `sign_timeout_with_qc()` twice for round 10 with different QCs
4. Observing that both calls succeed and produce different signatures

The test suite at `consensus/safety-rules/src/tests/suite.rs` should be extended to cover this case, but currently does not test equal-round timeout scenarios.

## Notes

This vulnerability represents a fundamental inconsistency between the voting and timeout logic in SafetyRules. The voting path explicitly prevents equivocation by storing and returning the previous vote, while the timeout path lacks equivalent protection. This asymmetry, combined with the ephemeral nature of `timeout_sent` versus the persistent nature of `last_voted_round`, creates a window for equivocation after crash recovery that violates BFT consensus assumptions.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L37-45)
```rust
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L51-53)
```rust
    pub fn hqc_round(&self) -> Round {
        self.quorum_cert.certified_block().round()
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L98-103)
```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/src/round_manager.rs (L1005-1021)
```rust
        if self.local_config.enable_round_timeout_msg {
            let timeout = if let Some(timeout) = self.round_state.timeout_sent() {
                timeout
            } else {
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;
```

**File:** consensus/src/liveness/round_state.rs (L163-163)
```rust
    timeout_sent: Option<RoundTimeout>,
```

**File:** consensus/src/liveness/round_state.rs (L210-211)
```rust
            vote_sent: None,
            timeout_sent: None,
```

**File:** consensus/src/liveness/round_state.rs (L260-261)
```rust
            self.vote_sent = None;
            self.timeout_sent = None;
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/safety-rules/src/tests/suite.rs (L774-843)
```rust
fn test_2chain_timeout(constructor: &Callback) {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let genesis_round = genesis_qc.certified_block().round();
    let round = genesis_round;
    safety_rules.initialize(&proof).unwrap();
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, None, &signer);

    safety_rules
        .sign_timeout_with_qc(&TwoChainTimeout::new(1, 1, genesis_qc.clone()), None)
        .unwrap();
    assert_eq!(
        safety_rules
            .sign_timeout_with_qc(&TwoChainTimeout::new(1, 2, genesis_qc.clone()), None)
            .unwrap_err(),
        Error::NotSafeToTimeout(2, 0, 0, 0),
    );

    assert_eq!(
        safety_rules
            .sign_timeout_with_qc(&TwoChainTimeout::new(2, 2, genesis_qc.clone()), None)
            .unwrap_err(),
        Error::IncorrectEpoch(2, 1)
    );
    safety_rules
        .sign_timeout_with_qc(
            &TwoChainTimeout::new(1, 2, genesis_qc.clone()),
            Some(make_timeout_cert(1, &genesis_qc, &signer)).as_ref(),
        )
        .unwrap();
    assert_eq!(
        safety_rules
            .sign_timeout_with_qc(&TwoChainTimeout::new(1, 1, genesis_qc.clone()), None)
            .unwrap_err(),
        Error::IncorrectLastVotedRound(1, 2)
    );
    // update one-chain to 2
    safety_rules
        .construct_and_sign_vote_two_chain(&a3, None)
        .unwrap();
    assert_eq!(
        safety_rules
            .sign_timeout_with_qc(
                &TwoChainTimeout::new(1, 4, a3.block().quorum_cert().clone(),),
                Some(make_timeout_cert(2, &genesis_qc, &signer)).as_ref()
            )
            .unwrap_err(),
        Error::NotSafeToTimeout(4, 2, 2, 2)
    );
    assert_eq!(
        safety_rules
            .sign_timeout_with_qc(
                &TwoChainTimeout::new(1, 4, a2.block().quorum_cert().clone(),),
                Some(make_timeout_cert(3, &genesis_qc, &signer)).as_ref()
            )
            .unwrap_err(),
        Error::NotSafeToTimeout(4, 1, 3, 2)
    );
    assert!(matches!(
        safety_rules
            .sign_timeout_with_qc(
                &TwoChainTimeout::new(1, 1, a3.block().quorum_cert().clone(),),
                Some(make_timeout_cert(2, &genesis_qc, &signer)).as_ref()
            )
            .unwrap_err(),
        Error::InvalidTimeout(_)
    ));
}
```
