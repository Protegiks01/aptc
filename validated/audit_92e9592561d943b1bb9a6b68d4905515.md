# Audit Report

## Title
Missing Usage Data for Intermediate State Checkpoints in Multi-Checkpoint Batches

## Summary
When a single `ChunkToCommit` spans multiple state checkpoint boundaries, the storage layer only writes usage metadata (`VersionData`) for the last checkpoint, causing intermediate checkpoints to lack required usage data. This creates data integrity issues affecting backup operations, database management, and state queries.

## Finding Description

The Aptos storage system supports transaction batches that span multiple state checkpoint boundaries. The `StateUpdateRefs` structure tracks all checkpoint versions via `all_checkpoint_versions`: [1](#0-0) 

Tests confirm that chunks with multiple checkpoints are explicitly supported: [2](#0-1) 

The validation that enforces at-most-one-checkpoint only applies to non-block scenarios (primarily tests), not normal operation: [3](#0-2) 

However, when committing state updates, the `put_stats_and_indices` function only writes usage data for the **last** checkpoint: [4](#0-3) 

This code writes `VersionData` only for:
1. `latest_state.last_checkpoint()` - the final checkpoint in the chunk
2. `latest_state` - the latest version if it's not a checkpoint

It does NOT iterate over `all_checkpoint_versions` to write usage data for intermediate checkpoints. When usage data is queried for a version without `VersionData`, the system errors if `skip_usage` is false: [5](#0-4) 

This affects database management operations, which must implement fallback logic when encountering missing usage data: [6](#0-5) 

## Impact Explanation

This constitutes a **Medium Severity** issue per Aptos bug bounty criteria: "State inconsistencies requiring manual intervention."

The missing usage data creates:
1. **Database Management Failures**: Truncation operations must fall back to alternative versions when targeting intermediate checkpoints
2. **Backup Operation Issues**: Queries for state storage usage at intermediate checkpoint versions fail unless `skip_usage` is enabled
3. **State Query Inconsistencies**: API calls to `get_state_storage_usage()` at intermediate checkpoints return errors
4. **Data Integrity Violations**: Checkpoint versions lack required metadata that should be present

While the system includes fallback mechanisms, these are reactive mitigations that mask the underlying data integrity issue rather than preventing it. Operations may fail unexpectedly, requiring manual intervention or configuration changes.

## Likelihood Explanation

This occurs during normal operations when chunks span multiple checkpoint boundaries, primarily during:
- **State Synchronization**: Chunks can contain multiple blocks, each ending with a checkpoint
- **Catch-up Scenarios**: Nodes syncing historical data process multi-checkpoint batches
- **Database Operations**: Truncation, backup, or recovery targeting intermediate checkpoint versions

The likelihood is **MEDIUM** because:
- Chunks with multiple checkpoints are explicitly supported by the codebase
- No validation prevents multi-checkpoint chunks in normal operation
- State sync commonly processes such batches
- The issue manifests whenever operations query usage at intermediate checkpoints

## Recommendation

Modify `put_stats_and_indices` to write usage data for ALL checkpoints tracked in `all_checkpoint_versions`, not just the last one:

```rust
// Write usage for ALL checkpoints in the chunk
for &checkpoint_version in state_update_refs.all_checkpoint_versions() {
    if let Some(checkpoint_state) = get_state_at_version(checkpoint_version) {
        Self::put_usage(&checkpoint_state, batch)?;
    }
}

// Then write for latest if it's not a checkpoint
if !latest_state.is_checkpoint() {
    Self::put_usage(latest_state, batch)?;
}
```

This ensures complete metadata coverage for all checkpoint versions within each committed batch.

## Proof of Concept

The issue can be demonstrated by:
1. Creating a chunk with transactions spanning multiple checkpoint boundaries (e.g., versions 0-500 with checkpoints at 100, 200, 300, 400)
2. Committing the chunk through the normal storage pipeline
3. Querying `get_state_storage_usage(100)` or `get_state_storage_usage(200)`
4. Observing the error: "VersionData at {version} is missing" when `skip_usage` is false

The existing test framework in `transactions_with_output.rs` demonstrates multi-checkpoint chunk support, and the truncation code shows the need for fallback logic when usage data is missing.

## Notes

This is a data integrity issue affecting operational reliability rather than a critical security vulnerability. While fallback mechanisms exist (e.g., `get_usage_before_or_at`), they indicate the system is designed to cope with missing data rather than prevent the root cause. The proper fix is to ensure all checkpoint versions receive complete metadata during the commit process.

### Citations

**File:** storage/storage-interface/src/state_store/state_update_refs.rs (L120-134)
```rust
#[derive(Debug)]
pub struct StateUpdateRefs<'kv> {
    pub per_version: PerVersionStateUpdateRefs<'kv>,
    all_checkpoint_versions: Vec<Version>,
    /// Updates from the beginning of the block/chunk to the last checkpoint (if it exists).
    for_last_checkpoint: Option<(PerVersionStateUpdateRefs<'kv>, BatchedStateUpdateRefs<'kv>)>,
    /// Updates from the version after last checkpoint to last version (`None` if the last version
    /// is a checkpoint, e.g. in a regular block).
    for_latest: Option<(PerVersionStateUpdateRefs<'kv>, BatchedStateUpdateRefs<'kv>)>,
}

impl<'kv> StateUpdateRefs<'kv> {
    pub(crate) fn all_checkpoint_versions(&self) -> &[Version] {
        &self.all_checkpoint_versions
    }
```

**File:** execution/executor-types/src/transactions_with_output.rs (L368-396)
```rust
    fn test_chunk_with_ckpts_no_reconfig() {
        let txns = vec![
            dummy_txn(),
            ckpt_txn(),
            dummy_txn(),
            ckpt_txn(),
            dummy_txn(),
        ];
        let outputs = vec![
            default_output(),
            default_output(),
            default_output(),
            default_output(),
            default_output(),
        ];
        let aux_infos = vec![
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
            default_aux_info(),
        ];
        let txn_with_outputs = TransactionsWithOutput::new(txns, outputs, aux_infos);

        let (all_ckpt_indices, is_reconfig) =
            TransactionsToKeep::get_all_checkpoint_indices(&txn_with_outputs, false);
        assert_eq!(all_ckpt_indices, vec![1, 3]);
        assert!(!is_reconfig);
    }
```

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L75-78)
```rust
            if !execution_output.is_block {
                // We should enter this branch only in test.
                execution_output.to_commit.ensure_at_most_one_checkpoint()?;
            }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L879-891)
```rust
        {
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["put_stats_and_indices__put_usage"]);
            if latest_state.last_checkpoint().next_version() > current_state.next_version() {
                // has a checkpoint in the chunk
                Self::put_usage(latest_state.last_checkpoint(), batch)?;
            }
            if !latest_state.is_checkpoint() {
                // latest state isn't a checkpoint
                Self::put_usage(latest_state, batch)?;
            }
            STATE_ITEMS.set(latest_state.usage().items() as i64);
            TOTAL_STATE_BYTES.set(latest_state.usage().bytes() as i64);
        }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L114-127)
```rust
        if ledger_db.metadata_db().get_usage(target_version).is_err() {
            println!(
                "Unable to truncate to version {}, since there is no VersionData on that version.",
                target_version
            );
            println!(
                "Trying to fallback to the largest valid version before version {}.",
                target_version,
            );
            target_version = ledger_db
                .metadata_db()
                .get_usage_before_or_at(target_version)?
                .0;
        }
```
