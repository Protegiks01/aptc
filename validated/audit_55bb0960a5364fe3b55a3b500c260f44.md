# Audit Report

## Title
Consensus Indefinite Wait Due to Silent State Sync Callback Failures

## Summary
The state sync driver fails to send callbacks to consensus when storage errors occur during sync request handling. Consensus waits indefinitely without timeout mechanisms for `sync_to_target` and `sync_for_duration` operations, causing validator liveness failures.

## Finding Description

This vulnerability exists in the interaction between consensus and state sync components, involving three critical design flaws:

**1. No Timeout on Consensus Side**

The `sync_to_target()` method awaits the callback receiver indefinitely without any timeout protection: [1](#0-0) 

Similarly, `sync_for_duration()` awaits without timeout: [2](#0-1) 

In contrast, `notify_new_commit()` does implement a timeout mechanism: [3](#0-2) 

Consensus invokes these methods through the ExecutionProxy: [4](#0-3) 

**2. Silent Error Handling in State Sync**

When `handle_consensus_sync_target_notification()` encounters storage errors before storing the callback, the error is returned early and the callback is never sent: [5](#0-4) 

The error is caught but only logged, with no callback sent to consensus: [6](#0-5) 

When `check_sync_request_progress()` encounters errors, they are logged without propagating callbacks: [7](#0-6) 

**3. Storage Operations Can Fail**

The storage utility functions wrap database operations that return `Result` types: [8](#0-7) 

Multiple storage operations in `check_sync_request_progress()` can fail: [9](#0-8) [10](#0-9) [11](#0-10) 

**Attack Path:**

1. Consensus calls `sync_to_target()` and awaits callback without timeout
2. State sync receives notification and either:
   - Encounters storage error in `handle_consensus_sync_target_notification()` before storing the callback (lines 413-416)
   - Successfully stores the notification but encounters persistent storage errors in `check_sync_request_progress()` (lines 542, 573, 575, 596)
3. Errors are logged but no callback is sent to consensus
4. The oneshot channel receiver in consensus never receives a response
5. Consensus waits indefinitely, causing validator liveness failure

## Impact Explanation

This vulnerability causes **validator liveness failures**. When a validator's consensus component waits indefinitely for state sync callbacks, it cannot process new sync requests, progress with block execution, or participate in consensus rounds.

**Impact Severity: HIGH to CRITICAL**

- **Individual Validator (HIGH)**: Single validator experiencing storage errors will hang indefinitely, unable to participate in consensus. The network continues operating with remaining validators.

- **Multiple Validators (CRITICAL)**: If multiple validators (>1/3) experience storage errors simultaneously, network-wide liveness failure occurs. This is possible through:
  - Correlated storage failures during high load conditions
  - Resource exhaustion attacks targeting storage subsystems
  - Common infrastructure dependencies failing

This represents a protocol-level design flaw (missing timeout protection) that violates liveness guarantees under fault conditions, qualifying as a HIGH severity validator availability issue that can escalate to CRITICAL under coordinated failure scenarios.

## Likelihood Explanation

**Likelihood: Medium to High**

Storage errors can occur through natural causes without requiring any privileged access:

**Natural Causes:**
- Database corruption from disk failures
- I/O errors from storage subsystem issues
- Out-of-memory conditions during high load
- File system inconsistencies

**Induced Scenarios:**
- Resource exhaustion targeting storage operations
- High transaction throughput causing storage contention
- Race conditions during epoch transitions

The vulnerability affects standard validator operations and requires no attacker capabilities beyond inducing storage stress. Storage operations are called frequently in sync progress checks, making the probability of encountering persistent storage errors non-negligible under adverse conditions.

## Recommendation

Implement timeout mechanisms for `sync_to_target()` and `sync_for_duration()` operations, consistent with the existing `notify_new_commit()` implementation. Additionally, ensure that all error paths in state sync driver send appropriate error callbacks to consensus before returning.

**Recommended Fix:**

1. Add timeout wrapper to `sync_to_target()` similar to `notify_new_commit()`
2. Add timeout wrapper to `sync_for_duration()`
3. Ensure `handle_consensus_sync_target_notification()` sends error callbacks before returning on storage failures
4. Ensure `check_sync_request_progress()` sends error callbacks on persistent storage failures

## Proof of Concept

The vulnerability can be triggered by inducing storage errors during sync operations. A complete PoC would require:

1. Setup a validator node in sync mode
2. Trigger `sync_to_target()` from consensus
3. Induce storage errors (disk I/O failure, database corruption, OOM)
4. Observe consensus indefinitely waiting without timeout
5. Monitor validator liveness metrics showing no progress

The code analysis demonstrates the vulnerability exists through the documented execution paths without requiring explicit PoC code, as the issue is a protocol-level design flaw in error handling and timeout mechanisms.

## Notes

This vulnerability is particularly concerning because:
- It violates fundamental liveness guarantees expected in BFT consensus systems
- Storage errors are realistic failure modes in production environments
- No timeout protection creates unbounded wait conditions
- The inconsistency between `notify_new_commit()` (with timeout) and `sync_to_target()`/`sync_for_duration()` (without timeout) suggests an oversight in the original design

The vulnerability affects the core consensus-state sync interaction and should be addressed as a high priority issue to ensure validator resilience under fault conditions.

### Citations

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L122-137)
```rust
        if let Ok(response) = timeout(
            Duration::from_millis(self.commit_timeout_ms),
            callback_receiver,
        )
        .await
        {
            match response {
                Ok(consensus_notification_response) => consensus_notification_response.get_result(),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Consensus commit notification failure: {:?}",
                    error
                ))),
            }
        } else {
            Err(Error::TimeoutWaitingForStateSync)
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L162-178)
```rust
        match callback_receiver.await {
            Ok(response) => match response.get_result() {
                Ok(_) => response.get_latest_synced_ledger_info().ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "Sync for duration returned an empty latest synced ledger info!".into(),
                    )
                }),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Sync for duration returned an error: {:?}",
                    error
                ))),
            },
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L200-206)
```rust
        match callback_receiver.await {
            Ok(response) => response.get_result(),
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync to target failure: {:?}",
                error
            ))),
        }
```

**File:** consensus/src/state_computer.rs (L216-219)
```rust
        let result = monitor!(
            "sync_to_target",
            self.state_sync_notifier.sync_to_target(target).await
        );
```

**File:** state-sync/state-sync-driver/src/driver.rs (L307-312)
```rust
        // Log any errors from notification handling
        if let Err(error) = result {
            warn!(LogSchema::new(LogEntry::ConsensusNotification)
                .error(&error)
                .message("Error encountered when handling the consensus notification!"));
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L413-416)
```rust
        let latest_pre_committed_version =
            utils::fetch_pre_committed_version(self.storage.clone())?;
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
```

**File:** state-sync/state-sync-driver/src/driver.rs (L541-542)
```rust
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
```

**File:** state-sync/state-sync-driver/src/driver.rs (L572-576)
```rust
                let latest_synced_version =
                    utils::fetch_pre_committed_version(self.storage.clone())?;
                let latest_synced_ledger_info =
                    utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
                let latest_ledger_info_version = latest_synced_ledger_info.ledger_info().version();
```

**File:** state-sync/state-sync-driver/src/driver.rs (L595-596)
```rust
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
```

**File:** state-sync/state-sync-driver/src/driver.rs (L681-685)
```rust
        if let Err(error) = self.check_sync_request_progress().await {
            warn!(LogSchema::new(LogEntry::Driver)
                .error(&error)
                .message("Error found when checking the sync request progress!"));
        }
```

**File:** state-sync/state-sync-driver/src/utils.rs (L267-284)
```rust
/// Fetches the latest synced ledger info from the specified storage
pub fn fetch_latest_synced_ledger_info(
    storage: Arc<dyn DbReader>,
) -> Result<LedgerInfoWithSignatures, Error> {
    storage.get_latest_ledger_info().map_err(|error| {
        Error::StorageError(format!(
            "Failed to get the latest ledger info from storage: {:?}",
            error
        ))
    })
}

/// Fetches the latest synced version from the specified storage
pub fn fetch_pre_committed_version(storage: Arc<dyn DbReader>) -> Result<Version, Error> {
    storage.ensure_pre_committed_version().map_err(|e| {
        Error::StorageError(format!("Failed to get latest version from storage: {e:?}"))
    })
}
```
