# Audit Report

## Title
Temporal Paradox in SafetyData: one_chain_round Can Exceed last_voted_round During Order Vote Processing

## Summary
A validator can enter an inconsistent SafetyData state where `one_chain_round` exceeds `last_voted_round`, violating the temporal invariant and causing liveness degradation. This occurs when validators create order votes for blocks they haven't personally voted on, preventing legitimate timeouts and stalling consensus progress in the 2-chain protocol.

## Finding Description

The `SafetyData` structure maintains two critical round counters that track consensus progress: `last_voted_round` (the last round the validator voted on) and `one_chain_round` (the highest 1-chain round observed). [1](#0-0) 

In the normal voting flow, when a validator votes on a block, it updates both fields through `guarded_construct_and_sign_vote_two_chain`, which calls both `verify_and_update_last_vote_round` and `observe_qc`. [2](#0-1) 

However, the order vote mechanism breaks this invariant. When votes from other validators aggregate into a QC, the validator broadcasts an order vote through `broadcast_order_vote`. [3](#0-2) 

The order vote creation path calls `guarded_construct_and_sign_order_vote`, which updates `one_chain_round` via `observe_qc` but does NOT update `last_voted_round`. [4](#0-3) 

The `observe_qc` method unconditionally updates `one_chain_round` to the QC's certified block round when that round is higher. [5](#0-4) 

The only safety check in order vote creation is `safe_for_order_vote`, which validates against `highest_timeout_round` but NOT `last_voted_round`. [6](#0-5) 

**Exploitation Scenario:**
1. Validator A votes on round 10 → `last_voted_round = 10`
2. Network asynchrony causes Validator A to receive block proposal for round 15 (stored in block store) but delays voting
3. Validator A receives votes from other validators for round 15
4. These votes aggregate into QC15 in `process_vote`
5. `broadcast_order_vote` is triggered at line 1807 of round_manager.rs
6. `observe_qc(QC15)` updates `one_chain_round = 15` but `last_voted_round` remains at 10
7. **Result:** `one_chain_round (15) > last_voted_round (10)` — SafetyData inconsistency

This inconsistent state critically affects the timeout safety mechanism. The `safe_to_timeout` check requires that `qc_round >= safety_data.one_chain_round` to allow a timeout. [7](#0-6) 

If `one_chain_round = 15` but the validator only has QC10, attempting to timeout at round 12 would fail because the check `qc_round (10) >= one_chain_round (15)` evaluates to false, blocking legitimate timeouts and causing liveness failures.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos bug bounty framework)

This vulnerability causes significant protocol violations:

1. **Liveness Degradation**: Validators with inflated `one_chain_round` cannot timeout correctly when they fall behind, stalling consensus progress. The timeout safety check becomes impossible to satisfy when `one_chain_round` exceeds the validator's actual highest QC round, preventing the validator from participating in timeout recovery mechanisms.

2. **Validator Node Slowdowns**: Affected validators experience consensus stalls and cannot progress through rounds, directly matching the HIGH severity criterion of "Validator node slowdowns" in the Aptos bug bounty program.

3. **Safety Check Over-Conservatism**: The 2-chain safety rules depend on accurate `one_chain_round` values to prevent unsafe timeouts. An artificially inflated `one_chain_round` makes the safety check reject valid timeout attempts, degrading the network's ability to handle temporary leader failures or network partitions.

4. **State Inconsistency**: The SafetyData enters an inconsistent state where the validator acknowledges a certified block at a higher round (via `one_chain_round`) than it has personally participated in (via `last_voted_round`), violating the assumption that validators track consensus progress through their own participation.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This issue occurs naturally in production networks without requiring any malicious behavior:

1. **Normal Network Conditions**: Network asynchrony, message reordering, and packet delays are routine occurrences in distributed systems. Validators regularly receive messages out of order, making the scenario where a validator has a block but hasn't voted on it yet highly realistic.

2. **Vote Aggregation Design**: The consensus protocol explicitly allows validators to aggregate votes from other validators into QCs regardless of their own participation. This is intentional for resilience but creates the vulnerability.

3. **Automatic Trigger**: The `broadcast_order_vote` function is automatically invoked when QC aggregation succeeds (as shown in round_manager.rs), requiring no operator intervention or special conditions beyond normal consensus operation.

4. **No Validation Barrier**: The order vote code path contains zero checks preventing `one_chain_round` from exceeding `last_voted_round`. The safety validation only checks against `highest_timeout_round`, leaving this invariant unprotected.

The likelihood increases with:
- Higher network latency variance between geographically distributed validators
- Increased consensus throughput (more rounds per second amplifies timing differences)
- Temporary network partitions or congestion
- Validator synchronization delays after catching up from behind

## Recommendation

Add a validation check in `guarded_construct_and_sign_order_vote` to ensure order votes don't inflate `one_chain_round` beyond the validator's actual participation level. Specifically:

1. Before calling `observe_qc`, check if the QC's certified block round exceeds `last_voted_round`
2. If so, either:
   - Skip updating `one_chain_round` for order votes (only update during actual voting)
   - Or require validators to vote before creating order votes for future rounds

Alternative solution: Modify `safe_to_timeout` to use `max(last_voted_round, one_chain_round)` or add a separate `order_vote_one_chain_round` field to distinguish between rounds the validator has voted on versus rounds it has only observed through vote aggregation.

The fix should maintain the safety guarantees while preventing artificial inflation of `one_chain_round` that blocks legitimate timeouts.

## Proof of Concept

The vulnerability can be reproduced by:

1. Setting up a 4-validator network with `order_vote_enabled = true`
2. Having Validator A vote on round 10
3. Introducing network delay for Validator A to miss rounds 11-14
4. Having other validators (B, C, D) vote on round 15 and send votes to A
5. Validator A receives 3 votes for round 15, aggregates them into QC15
6. Validator A calls `broadcast_order_vote`, which updates `one_chain_round = 15`
7. Checking SafetyData shows: `last_voted_round = 10`, `one_chain_round = 15`
8. Attempting to timeout at round 12 with QC10 fails the safety check

The code paths demonstrated in the citations show this flow is reachable through normal consensus message processing without requiring any special configuration or malicious actors.

## Notes

This vulnerability affects the 2-chain consensus protocol implementation specifically when order votes are enabled. The issue stems from the asymmetry between normal voting (which updates both counters) and order voting (which only updates `one_chain_round`). While this design might have been intentional to allow validators to acknowledge certified blocks they didn't directly participate in, the side effect on timeout safety was not properly accounted for, leading to liveness degradation under realistic network conditions.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/src/round_manager.rs (L1774-1816)
```rust
    async fn process_vote_reception_result(
        &mut self,
        vote: &Vote,
        result: VoteReceptionResult,
    ) -> anyhow::Result<()> {
        let round = vote.vote_data().proposed().round();
        match result {
            VoteReceptionResult::NewQuorumCertificate(qc) => {
                if !vote.is_timeout() {
                    observe_block(
                        qc.certified_block().timestamp_usecs(),
                        BlockStage::QC_AGGREGATED,
                    );
                }
                QC_AGGREGATED_FROM_VOTES.inc();
                self.new_qc_aggregated(qc.clone(), vote.author())
                    .await
                    .context(format!(
                        "[RoundManager] Unable to process the created QC {:?}",
                        qc
                    ))?;
                if self.onchain_config.order_vote_enabled() {
                    // This check is already done in safety rules. As printing the "failed to broadcast order vote"
                    // in humio logs could sometimes look scary, we are doing the same check again here.
                    if let Some(last_sent_vote) = self.round_state.vote_sent() {
                        if let Some((two_chain_timeout, _)) = last_sent_vote.two_chain_timeout() {
                            if round <= two_chain_timeout.round() {
                                return Ok(());
                            }
                        }
                    }
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
                Ok(())
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
