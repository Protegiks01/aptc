# Audit Report

## Title
Critical Process Crash in Secret Share Verification Due to Missing Author Validation

## Summary
The secret sharing verification path lacks validation that the `author` field in received `SecretShare` messages matches the authenticated network sender. A malicious validator can send crafted messages with invalid author addresses, triggering a panic in `SecretShare::verify()` that crashes the entire validator process via the global crash handler.

## Finding Description

The vulnerability exists in the message handling flow where incoming secret share messages are not validated to ensure the message author matches the authenticated sender.

**Attack Path:**

1. Network layer receives `SecretShareMsg` and creates `IncomingSecretShareRequest` with authenticated `sender` field from the network peer [1](#0-0) 

2. The `sender` field is marked `#[allow(unused)]` and is never validated against the message content [2](#0-1) 

3. The `verification_task` deserializes and verifies messages without checking if the author matches the sender [3](#0-2) 

4. `SecretShareMessage::verify()` delegates to `share.verify(config)` without author validation [4](#0-3) 

5. `SecretShare::verify()` calls `config.get_id(self.author())` [5](#0-4)  which panics via `.expect()` if author is not in validator set [6](#0-5) 

6. The panic triggers the global crash handler which exits the entire validator process [7](#0-6) 

**Contrast with Reliable Broadcast Path:**

The reliable broadcast response path correctly validates author matches sender BEFORE calling verify [8](#0-7) 

However, the direct message path in `verification_task` lacks this critical validation.

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability causes **complete validator process termination**, not just task failure:

1. **Validator Availability Impact**: A single malicious message crashes the entire validator process through the global crash handler. The validator cannot participate in consensus until the process is restarted by external supervision.

2. **Network-Wide Attack Surface**: Any single malicious validator can target all other validators simultaneously with crafted messages, causing coordinated network disruption.

3. **Consensus Liveness Risk**: If multiple validators are crashed simultaneously, the network may lose consensus liveness if below the 2/3 threshold required for progress.

4. **Repeated Attack Vector**: An attacker can continuously send malicious messages to prevent validator recovery, requiring additional mitigation measures beyond simple restart.

This qualifies as **HIGH Severity** under "Validator Node Slowdowns" and DoS categories, as it causes complete validator unavailability through a protocol-level input validation bug (distinct from infrastructure-level network DoS attacks which are out of scope).

## Likelihood Explanation

**Likelihood: HIGH**

The attack is easily exploitable by any malicious validator:

1. **Attacker Profile**: Any validator in the current epoch (untrusted actor per threat model)

2. **Trivial Exploitation**: Attacker only needs to craft a `SecretShare` with `author` field set to `AccountAddress::ZERO` or any non-validator address

3. **Authenticated Network Access**: Validators use mutual authentication, so malicious validators can reliably deliver messages

4. **No Detection**: The panic results in process termination with only crash logs, no runtime detection or prevention

5. **Single Message Impact**: One malformed message causes complete process crash

## Recommendation

Add author validation in the `verification_task` before calling `msg.verify()`:

```rust
bounded_executor
    .spawn(async move {
        match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
            Ok(msg) => {
                // Validate author matches sender for Share messages
                if let SecretShareMessage::Share(ref share) = msg {
                    if share.author() != &dec_msg.sender {
                        warn!("Author does not match sender");
                        return;
                    }
                }
                
                if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                    let _ = tx.unbounded_send(SecretShareRpc {
                        msg,
                        protocol: dec_msg.protocol,
                        response_sender: dec_msg.response_sender,
                    });
                }
            },
            Err(e) => {
                warn!("Invalid dec message: {}", e);
            },
        }
    })
    .await;
```

This mirrors the validation pattern already present in the reliable broadcast path.

## Proof of Concept

```rust
// Simulated attack by malicious validator
use aptos_types::{
    account_address::AccountAddress,
    secret_sharing::{SecretShare, SecretShareMetadata},
};

// Attacker crafts a SecretShare with invalid author
let invalid_author = AccountAddress::ZERO; // Or any non-validator address
let malicious_share = SecretShare::new(
    invalid_author,
    metadata,
    share_data,
);

// When this is sent to verification_task and verify() is called,
// config.get_id(invalid_author) will panic with "Peer should be in the index!"
// This triggers the global crash handler which calls process::exit(12)
```

## Notes

The vulnerability is a classic missing input validation issue where the authenticated network sender is not validated against the claimed author in the message payload. The reliable broadcast code path demonstrates the correct validation pattern, but the direct verification path omits this critical check. This allows any malicious validator to crash other validators by crafting messages with invalid author fields, causing denial of service through repeated process termination.

### Citations

**File:** consensus/src/network.rs (L155-161)
```rust
pub struct IncomingSecretShareRequest {
    pub req: SecretShareNetworkMessage,
    #[allow(unused)]
    pub sender: Author,
    pub protocol: ProtocolId,
    pub response_sender: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** consensus/src/network.rs (L920-928)
```rust
                        ConsensusMsg::SecretShareMsg(req) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback = IncomingRpcRequest::SecretShareRequest(
                                IncomingSecretShareRequest {
                                    req,
                                    sender: peer_id,
                                    protocol: RPC[0],
                                    response_sender: tx,
                                },
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L217-226)
```rust
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L34-37)
```rust
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
```

**File:** types/src/secret_sharing.rs (L75-76)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** crates/crash-handler/src/lib.rs (L52-57)
```rust
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-52)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
```
