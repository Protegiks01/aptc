# Audit Report

## Title
State Merkle DB Truncation Returns Non-Root Node Versions Leading to Database Corruption

## Summary
The `find_closest_node_version_at_or_before()` function in the state merkle database truncation logic can return versions where only non-root nodes exist (partial commits), without validating root node presence. When `truncate_state_merkle_db()` uses this function in its internal loop, it commits database progress to versions lacking valid state roots, violating state consistency guarantees and potentially leaving the database in a corrupted state if a crash occurs during the truncation window.

## Finding Description

The vulnerability exists in the interaction between `find_closest_node_version_at_or_before()` and `truncate_state_merkle_db()` within the state merkle database recovery process.

**NodeKey Encoding and Lexicographic Ordering:**

The NodeKey encoding uses big-endian format for version followed by num_nibbles and path bytes. [1](#0-0) 

Root nodes (empty path) encode as `[version][0]`, while non-root nodes encode as `[version][n>0][path_bytes]`. Due to lexicographic ordering: `NodeKey(99, []) < NodeKey(99, [0x1]) < NodeKey(100, [])`.

**The Vulnerability:**

The `find_closest_node_version_at_or_before()` function uses a reverse iterator with `seek_for_prev` to find the closest node version. [2](#0-1) 

When seeking `NodeKey::new_empty_path(version)` and no root exists at that version, RocksDB positions the iterator at the largest key less than the target. This could be a non-root node like `NodeKey(version, [0x1])`. The function returns this version WITHOUT checking if a root node exists.

**Partial Commits Are Acknowledged:**

The codebase explicitly acknowledges that partial commits (versions with nodes but no root) can exist due to sharded commits. [3](#0-2) 

The commit process confirms this: shards are written in parallel before the top levels (including root) are committed. [4](#0-3) 

**Critical Usage Without Validation:**

In `truncate_state_merkle_db()`, the function iteratively truncates from the current version down to the target version. Within the loop, it calls `find_closest_node_version_at_or_before()` to find intermediate truncation points. [5](#0-4) 

The returned `version_before` is then used to truncate shards without verifying a root exists at that version. [6](#0-5) 

The progress marker is written through `delete_nodes_and_stale_indices_at_or_after_version()`, which calls `put_progress()` with the version. [7](#0-6) 

**Correct Implementation Pattern:**

The function `find_tree_root_at_or_before()` demonstrates the correct approach by explicitly validating root existence using `root_exists_at_version()`. [8](#0-7) 

This correct pattern is used in `sync_commit_progress()` to find the target version for truncation. [9](#0-8) 

However, the internal truncation loop does not use this validated approach.

**Attack Scenario:**

1. Database state after crash during sharded commit: Version 98 (complete with root), Version 99 (partial - only non-root nodes exist, no root), Version 100 (complete with root)
2. System recovery calls `sync_commit_progress()` which invokes `truncate_state_merkle_db()` with target version 98
3. First loop iteration: `current_version` = 100, calls `find_closest_node_version_at_or_before(99)` 
4. Function finds a non-root node at version 99 and returns version 99
5. Database commits progress to version 99 through the truncation operations
6. If system crashes during this window, database is left with progress marker at version 99 without a valid state root
7. Subsequent operations expecting a root at version 99 will fail, causing operational disruption

## Impact Explanation

This violates the **State Consistency** invariant that state transitions must be atomic and verifiable via Merkle proofs. The database progress marker can point to a version without a valid state root, making the state unverifiable and requiring manual intervention.

**Severity: Medium** (up to $10,000) - "State inconsistencies requiring manual intervention"

- **Database corruption**: Progress marker references a version without a valid root node
- **Operational disruption**: Node operations attempting to access the state root at the corrupted version will fail
- **Manual intervention required**: Database recovery requires re-running truncation or manual rollback
- **Does not directly cause consensus splits**: Nodes would fail-stop rather than diverge on state
- **Not direct loss of funds**: No immediate fund theft, but significant operational impact

The severity aligns with Medium category in the Aptos bug bounty program, as it causes state inconsistencies requiring intervention but does not result in direct fund loss or consensus violations.

## Likelihood Explanation

**Likelihood: Medium**

Partial commits can occur during:
- **System crashes during sharded commits**: The state merkle commit process splits work across multiple shards that are committed in parallel, creating windows where partial data exists
- **Recovery/truncation operations**: The vulnerability manifests during the truncation loop executed as part of crash recovery
- **Multi-step crash scenario**: Requires crash during initial commit (creating partial state) followed by crash during truncation recovery

The code explicitly acknowledges partial commits are a known system condition, not a theoretical edge case. The truncation function is part of the standard crash recovery flow in `sync_commit_progress()`, making this a realistic operational scenario.

## Recommendation

Replace `find_closest_node_version_at_or_before()` with `find_tree_root_at_or_before()` in the truncation loop to ensure the progress marker always points to a version with a valid root node. The corrected code should validate root existence before committing progress to any version.

Alternatively, add explicit root existence validation after calling `find_closest_node_version_at_or_before()` and retry with `version_before - 1` if no root exists, similar to the pattern in `find_tree_root_at_or_before()`.

## Proof of Concept

A full proof of concept would require:
1. Setting up a test environment with sharded state merkle commits
2. Triggering a crash during the sharded commit process to create a partial commit at version N
3. Restarting recovery and triggering another crash during the truncation loop when it sets progress to version N
4. Verifying that the database progress marker points to version N without a valid root

The logic vulnerability is evident from code inspection: the truncation loop uses a function that does not validate root existence, while the codebase contains a correct implementation that does validate root existence but is not used in this critical path.

## Notes

This is a logic vulnerability in the database recovery code path. While it requires specific crash timing to manifest (multi-crash scenario), it represents a genuine flaw where the wrong helper function is used in a critical code path. The codebase demonstrates awareness of partial commits and provides the correct implementation pattern (`find_tree_root_at_or_before`), but the truncation loop fails to use it, creating a potential path to database corruption requiring manual intervention.

### Citations

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L103-109)
```rust
    pub fn encode(&self) -> Result<Vec<u8>> {
        let mut out = vec![];
        out.write_u64::<BigEndian>(self.version())?;
        out.write_u8(self.nibble_path().num_nibbles() as u8)?;
        out.write_all(self.nibble_path().bytes())?;
        Ok(out)
    }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L159-163)
```rust
        let version_before = find_closest_node_version_at_or_before(
            state_merkle_db.metadata_db(),
            current_version - 1,
        )?
        .expect("Must exist.");
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L174-176)
```rust
        state_merkle_db.commit_top_levels(version_before, top_levels_batch)?;

        truncate_state_merkle_db_shards(state_merkle_db, version_before)?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L208-245)
```rust
pub(crate) fn find_tree_root_at_or_before(
    ledger_metadata_db: &LedgerMetadataDb,
    state_merkle_db: &StateMerkleDb,
    version: Version,
) -> Result<Option<Version>> {
    if let Some(closest_version) =
        find_closest_node_version_at_or_before(state_merkle_db.metadata_db(), version)?
    {
        if root_exists_at_version(state_merkle_db, closest_version)? {
            return Ok(Some(closest_version));
        }

        // It's possible that it's a partial commit when sharding is not enabled,
        // look again for the previous version:
        if version == 0 {
            return Ok(None);
        }
        if let Some(closest_version) =
            find_closest_node_version_at_or_before(state_merkle_db.metadata_db(), version - 1)?
        {
            if root_exists_at_version(state_merkle_db, closest_version)? {
                return Ok(Some(closest_version));
            }

            // Now we are probably looking at a pruned version in this epoch, look for the previous
            // epoch ending:
            let mut iter = ledger_metadata_db.db().iter::<EpochByVersionSchema>()?;
            iter.seek_for_prev(&version)?;
            if let Some((closest_epoch_version, _)) = iter.next().transpose()? {
                if root_exists_at_version(state_merkle_db, closest_epoch_version)? {
                    return Ok(Some(closest_epoch_version));
                }
            }
        }
    }

    Ok(None)
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L286-293)
```rust
pub(crate) fn find_closest_node_version_at_or_before(
    db: &DB,
    version: Version,
) -> Result<Option<Version>> {
    let mut iter = db.rev_iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek_for_prev(&NodeKey::new_empty_path(version))?;
    Ok(iter.next().transpose()?.map(|item| item.0.version()))
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L603-622)
```rust
fn delete_nodes_and_stale_indices_at_or_after_version(
    db: &DB,
    version: Version,
    shard_id: Option<usize>,
    batch: &mut SchemaBatch,
) -> Result<()> {
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexSchema>(db, version, batch)?;
    delete_stale_node_index_at_or_after_version::<StaleNodeIndexCrossEpochSchema>(
        db, version, batch,
    )?;

    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }

    StateMerkleDb::put_progress(version.checked_sub(1), shard_id, batch)
}
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L147-171)
```rust
    pub(crate) fn commit(
        &self,
        version: Version,
        top_levels_batch: impl IntoRawBatch,
        batches_for_shards: Vec<impl IntoRawBatch + Send>,
    ) -> Result<()> {
        ensure!(
            batches_for_shards.len() == NUM_STATE_SHARDS,
            "Shard count mismatch."
        );
        THREAD_MANAGER.get_io_pool().install(|| {
            batches_for_shards
                .into_par_iter()
                .enumerate()
                .for_each(|(shard_id, batch)| {
                    self.db_shard(shard_id)
                        .write_schemas(batch)
                        .unwrap_or_else(|err| {
                            panic!("Failed to commit state merkle shard {shard_id}: {err}")
                        });
                })
        });

        self.commit_top_levels(version, top_levels_batch)
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L340-343)
```rust
                // Since we split state merkle commit into multiple batches, it's possible that
                // the root is not committed yet. In this case we need to look at the previous
                // root.
                return self.get_state_snapshot_version_before(version);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L478-489)
```rust
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
```
