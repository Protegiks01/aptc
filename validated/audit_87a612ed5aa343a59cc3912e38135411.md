# Audit Report

## Title
Governance Bypass via Stale Feature Flags in Transaction Validation - VMValidator Environment Not Updated After Feature Changes

## Summary
The `VMValidator` in the mempool validation pipeline fails to update its cached `AptosEnvironment` when `notify_commit()` is called after governance-driven feature flag changes. This creates a window where transactions using disabled features can pass validation and execute successfully, bypassing governance security controls.

## Finding Description

This vulnerability exists due to a state synchronization issue in the mempool validator combined with inadequate feature flag checking during transaction execution.

**Root Cause - Stale Environment:**

When `notify_commit()` is invoked on `VMValidator` after a state change, it conditionally updates the validator's state based on version compatibility: [1](#0-0) 

When `old_version <= new_version` (the normal sequential case), it calls `reset_state_view()` which only updates the underlying state view snapshot: [2](#0-1) 

Critically, this does NOT update the `environment` field which contains the cached `Features` configuration: [3](#0-2) 

In contrast, `reset_all()` creates a fresh environment from the new state view: [4](#0-3) 

**Validation Path - Stale Feature Checks:**

When `validate_transaction()` is called, it checks feature flags for signature types: [5](#0-4) 

These checks use `self.features()` which delegates to the stale environment: [6](#0-5) [7](#0-6) 

**Execution Path - No Re-validation:**

During block execution, `validate_signed_transaction()` is called: [8](#0-7) 

This function checks some features (account abstraction, orderless transactions, payload v2) but critically does NOT re-check the signature-type features (`WEBAUTHN_SIGNATURE`, `SINGLE_SENDER_AUTHENTICATOR`, `SLH_DSA_SHA2_128S_SIGNATURE`).

Furthermore, signature verification during block preparation does not check features at all: [9](#0-8) [10](#0-9) 

**Attack Scenario:**

1. Governance disables `WEBAUTHN_SIGNATURE` at version N+1 via `change_feature_flags_for_next_epoch()`: [11](#0-10) 

2. VMValidator's environment retains stale features from version N (feature enabled)
3. Attacker sends transaction with WebAuthn signature
4. Mempool validation passes using stale environment
5. Transaction enters mempool
6. Signature verification succeeds (no feature check)
7. Execution `validate_signed_transaction()` does NOT re-check `WEBAUTHN_SIGNATURE`
8. Transaction executes successfully despite governance disabling the feature

## Impact Explanation

**Severity: High**

This vulnerability constitutes a **governance bypass** that qualifies for High severity under Aptos bug bounty criteria for the following reasons:

1. **Violation of Governance Guarantees**: The fundamental guarantee that governance decisions take immediate effect is broken. When governance disables a feature for security reasons, the system should enforce this immediately.

2. **Security Control Circumvention**: Features disabled due to discovered vulnerabilities remain exploitable during the stale environment window. This directly undermines the security response mechanism.

3. **Protocol Invariant Violation**: The protocol assumes feature flags are consistently checked. The disconnect between mempool validation (checks features) and execution validation (doesn't re-check signature-type features) creates an exploitable inconsistency.

4. **Window Persistence**: The vulnerable window persists until `reset_all()` is triggered (version incompatibility) or validator restart, potentially spanning multiple blocks.

This is not merely mempool pollution - transactions using disabled features **actually execute successfully** because the feature checks are not repeated during execution prologue.

## Likelihood Explanation

**Likelihood: High**

1. **Low Attack Complexity**: Any user can exploit this by observing public governance proposals and sending transactions immediately after epoch changes.

2. **No Special Privileges Required**: Attack requires no validator access, staking, or special permissions.

3. **Affects All Validators**: The bug exists in core validation logic, affecting all nodes running the standard implementation.

4. **Common Trigger Condition**: Feature flag changes occur regularly as the protocol evolves, creating frequent exploitation windows.

5. **Difficult Detection**: The vulnerability may go unnoticed as transactions appear to validate normally.

## Recommendation

**Immediate Fix:**

Modify `VMValidator::notify_commit()` to always call `reset_all()` instead of conditionally calling `reset_state_view()`:

```rust
fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    // Always perform full reset to ensure environment stays fresh
    self.state.reset_all(db_state_view.into());
}
```

**Long-term Fix:**

Add feature flag re-validation during execution in `validate_signed_transaction()` to provide defense-in-depth:

```rust
// After line 1790 in aptos_vm.rs
// Re-validate signature-type feature flags
if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
    // Check for WebAuthn signatures
    if let Ok(sk_authenticators) = transaction.authenticator_ref().to_single_key_authenticators() {
        for authenticator in sk_authenticators {
            if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
            }
        }
    }
}
// Similar checks for SINGLE_SENDER_AUTHENTICATOR and SLH_DSA_SHA2_128S_SIGNATURE
```

## Proof of Concept

While a full executable PoC requires test infrastructure setup, the vulnerability can be demonstrated through the following sequence:

1. Deploy a governance proposal that disables `WEBAUTHN_SIGNATURE`
2. Wait for epoch transition and feature flag update
3. Immediately submit a transaction with WebAuthn signature
4. Observe that mempool validation passes (stale environment)
5. Verify transaction executes successfully in a block
6. Confirm that the feature flag shows as disabled in current state

The vulnerability is confirmed through code inspection showing:
- Feature checks are only in `VMValidator::validate_transaction` (mempool)
- No re-checks in `validate_signed_transaction` (execution)
- `notify_commit` uses `reset_state_view` which doesn't update environment
- Signature verification bypasses feature checks entirely

## Notes

This vulnerability specifically affects feature flags that gate **signature types** and other **Rust-level validation checks** performed before Move prologue execution. Feature flags checked within Move code during prologue/epilogue are not affected as they read directly from on-chain state.

The fix should prioritize either always calling `reset_all()` or implementing a mechanism to detect when features have changed and trigger environment refresh accordingly. The performance trade-off of always calling `reset_all()` is acceptable given the critical nature of maintaining governance guarantees.

### Citations

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L134-138)
```rust
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L348-350)
```rust
    fn features(&self) -> &Features {
        self.move_vm.env.features()
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1779-1951)
```rust
    fn validate_signed_transaction(
        &self,
        session: &mut SessionExt<impl AptosMoveResolver>,
        module_storage: &impl ModuleStorage,
        transaction: &SignedTransaction,
        transaction_data: &TransactionMetadata,
        log_context: &AdapterLogSchema,
        is_approved_gov_script: bool,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl AptosGasMeter,
    ) -> Result<SerializedSigners, VMStatus> {
        // Check transaction format.
        if transaction.contains_duplicate_signers() {
            return Err(VMStatus::error(
                StatusCode::SIGNERS_CONTAIN_DUPLICATES,
                None,
            ));
        }

        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
        }

        // Account Abstraction dispatchable authentication.
        let senders = transaction_data.senders();
        let proofs = transaction_data.authentication_proofs();

        // Validate that the number of senders matches the number of authentication proofs
        if senders.len() != proofs.len() {
            return Err(VMStatus::error(
                StatusCode::INVALID_NUMBER_OF_AUTHENTICATION_PROOFS,
                Some(format!(
                    "Mismatch between senders count ({}) and authentication proofs count ({})",
                    senders.len(),
                    proofs.len()
                )),
            ));
        }

        // Add fee payer.
        let fee_payer_signer = if let Some(fee_payer) = transaction_data.fee_payer {
            Some(match &transaction_data.fee_payer_authentication_proof {
                Some(AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                }) => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                    }
                },
                _ => Ok(serialized_signer(&fee_payer)),
            }?)
        } else {
            None
        };
        let sender_signers = itertools::zip_eq(senders, proofs)
            .map(|(sender, proof)| match proof {
                AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                } => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            sender,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None))
                    }
                },
                _ => Ok(serialized_signer(&sender)),
            })
            .collect::<Result<_, _>>()?;

        let serialized_signers = SerializedSigners::new(sender_signers, fee_payer_signer);

        if matches!(transaction.payload(), TransactionPayload::Payload(_))
            && !self.features().is_transaction_payload_v2_enabled()
        {
            return Err(VMStatus::error(
                StatusCode::FEATURE_UNDER_GATING,
                Some(
                    "User transactions with TransactionPayloadInner variant are not yet supported"
                        .to_string(),
                ),
            ));
        }

        if !self.features().is_orderless_txns_enabled() {
            if let ReplayProtector::Nonce(_) = transaction.replay_protector() {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Orderless transactions are not yet supported".to_string()),
                ));
            }
        }

        // The prologue MUST be run AFTER any validation. Otherwise you may run prologue and hit
        // SEQUENCE_NUMBER_TOO_NEW if there is more than one transaction from the same sender and
        // end up skipping validation.
        let executable = transaction
            .executable_ref()
            .map_err(|_| deprecated_module_bundle!())?;
        let extra_config = transaction.extra_config();
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
        Ok(serialized_signers)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3212)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }

        if !self.features().is_enabled(FeatureFlag::WEBAUTHN_SIGNATURE) {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::WebAuthn { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }

        if !self
            .features()
            .is_enabled(FeatureFlag::SLH_DSA_SHA2_128S_SIGNATURE)
        {
            if let Ok(sk_authenticators) = transaction
                .authenticator_ref()
                .to_single_key_authenticators()
            {
                for authenticator in sk_authenticators {
                    if let AnySignature::SlhDsa_Sha2_128s { .. } = authenticator.signature() {
                        return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
                    }
                }
            } else {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            }
        }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L76-80)
```rust
    /// Returns the [Features] used by this environment.
    #[inline]
    pub fn features(&self) -> &Features {
        &self.0.features
    }
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-138)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
```

**File:** types/src/transaction/authenticator.rs (L1288-1313)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        public_key: &AnyPublicKey,
        message: &T,
    ) -> Result<()> {
        match (self, public_key) {
            (Self::Ed25519 { signature }, AnyPublicKey::Ed25519 { public_key }) => {
                signature.verify(message, public_key)
            },
            (Self::Secp256k1Ecdsa { signature }, AnyPublicKey::Secp256k1Ecdsa { public_key }) => {
                signature.verify(message, public_key)
            },
            (
                Self::SlhDsa_Sha2_128s { signature },
                AnyPublicKey::SlhDsa_Sha2_128s { public_key },
            ) => signature.verify(message, public_key),
            (Self::WebAuthn { signature }, _) => signature.verify(message, public_key),
            (Self::Keyless { signature }, AnyPublicKey::Keyless { public_key: _ }) => {
                Self::verify_keyless_ephemeral_signature(message, signature)
            },
            (Self::Keyless { signature }, AnyPublicKey::FederatedKeyless { public_key: _ }) => {
                Self::verify_keyless_ephemeral_signature(message, signature)
            },
            _ => bail!("Invalid key, signature pairing"),
        }
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L805-828)
```text
    public fun change_feature_flags_for_next_epoch(
        framework: &signer,
        enable: vector<u64>,
        disable: vector<u64>
    ) acquires PendingFeatures, Features {
        assert!(signer::address_of(framework) == @std, error::permission_denied(EFRAMEWORK_SIGNER_NEEDED));

        // Figure out the baseline feature vec that the diff will be applied to.
        let new_feature_vec = if (exists<PendingFeatures>(@std)) {
            // If there is a buffered feature vec, use it as the baseline.
            let PendingFeatures { features } = move_from<PendingFeatures>(@std);
            features
        } else if (exists<Features>(@std)) {
            // Otherwise, use the currently effective feature flag vec as the baseline, if it exists.
            Features[@std].features
        } else {
            // Otherwise, use an empty feature vec.
            vector[]
        };

        // Apply the diff and save it to the buffer.
        apply_diff(&mut new_feature_vec, enable, disable);
        move_to(framework, PendingFeatures { features: new_feature_vec });
    }
```
