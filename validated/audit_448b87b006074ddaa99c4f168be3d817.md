# Audit Report

## Title
Index Out of Bounds Panic in DKG Share Decryption Causes Validator Node Crash

## Summary
The DKG (Distributed Key Generation) implementation contains an uncontrolled panic vulnerability where validators can crash during epoch transitions when attempting to decrypt shares from transcripts with mismatched player counts. The vulnerability stems from missing bounds checking when using validator indices to access transcript arrays, combined with explicit skipping of transcript verification.

## Finding Description

The `Player` struct was designed with type-safety intentions, but the `id` field is public, allowing arbitrary construction: [1](#0-0) 

During epoch transitions, validators construct `Player` instances directly from their validator index without validation. The validator index is obtained from the new epoch state's validator verifier: [2](#0-1) 

Critically, transcript verification is explicitly skipped before decryption: [3](#0-2) 

The Player is then passed to `decrypt_secret_share_from_transcript`, which internally calls `decrypt_own_share`: [4](#0-3) 

The vulnerability manifests in `decrypt_own_share()`, which does not return a Result type (panics propagate uncontrolled): [5](#0-4) 

The panic occurs when accessing arrays without bounds checking. Both `get_player_weight()` and `get_share_index()` directly access `self.weights[player.id]` without verifying bounds: [6](#0-5) [7](#0-6) 

The DKG session's `target_validator_set` is determined during initialization from `stake::next_validator_consensus_infos()`: [8](#0-7) [9](#0-8) 

**Attack Path:**
1. DKG transcript is created for validator set of size N (from `target_validator_set`)
2. Due to epoch transition timing, configuration mismatch, or state inconsistency, a validator with index M (where M ≥ N) attempts to decrypt
3. The validator's index comes from `new_epoch_state.verifier`, which may differ from the transcript's `target_validator_set`
4. When `decrypt_own_share()` calls `sc.get_player_weight(player)`, it accesses `self.weights[M]`
5. Since M ≥ N, this causes an index out of bounds panic
6. The validator node crashes with an uncontrolled panic

This violates defensive programming principles: critical operations must validate inputs before array access.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

**Validator Node Crashes**: The uncontrolled panic causes immediate node termination. Unlike graceful error handling that would log the issue and continue operation, this panic requires manual operator intervention to restart the node.

**Consensus Liveness Impact**: Affected validators cannot participate in consensus during and after epoch transitions. If multiple validators experience this simultaneously during a critical epoch transition, it degrades network resilience and could impact block production rates.

**Availability Degradation**: Epoch transitions are critical operational windows. Validator crashes during these periods create a window of vulnerability where consensus requires the remaining validators to maintain quorum.

While this does not directly enable fund theft or compromise consensus safety (it does not violate the <1/3 Byzantine assumption), it represents a significant protocol violation affecting network availability. The lack of defensive bounds checking means any configuration bug, state inconsistency, or edge case in validator set management will trigger this crash.

## Likelihood Explanation

**Likelihood: Medium** considering specific triggering conditions:

**Triggering Scenarios:**
1. **Validator Set Size Changes**: If the actual epoch validator set differs in size from the `target_validator_set` used to create the DKG transcript
2. **Configuration Errors**: Incorrect DKG session parameters or validator set management bugs
3. **State Inconsistencies**: Edge cases during epoch reconfiguration where validator sets are not properly synchronized
4. **Late Validator Changes**: Validators added to the set between DKG completion and epoch transition

**Defensive Programming Failure**: The explicit comment "No need to verify the transcript" indicates a deliberate decision to skip validation. Combined with the lack of bounds checking in multiple layers (`get_player_weight`, `get_share_index`, array access), this creates a fragile system where any mismatch causes immediate failure rather than graceful degradation.

In normal operation, the validator set from DKG should match the actual epoch validator set. However, the absence of explicit validation means any bug elsewhere in the system will trigger this panic.

## Recommendation

Add defensive bounds checking before array access:

```rust
// In weighted_config.rs
pub fn get_player_weight(&self, player: &Player) -> Result<usize> {
    self.weights.get(player.id)
        .copied()
        .ok_or_else(|| anyhow!("Player index {} out of bounds (max: {})", player.id, self.weights.len()))
}

// In epoch_manager.rs, validate before decryption:
ensure!(
    my_index < dkg_pub_params.pvss_config.wconfig.get_total_num_players() as u64,
    "Validator index {} exceeds DKG transcript player count {}",
    my_index,
    dkg_pub_params.pvss_config.wconfig.get_total_num_players()
);
```

Additionally, restore transcript verification or add explicit validator set size validation before attempting decryption.

## Proof of Concept

The vulnerability requires creating a scenario where validator sets mismatch. A full PoC would require:
1. Mocking a DKG session with N validators
2. Simulating an epoch transition where the verifier contains M > N validators
3. Attempting decryption with validator index M

The code evidence above demonstrates that such a scenario would trigger an uncontrolled panic due to missing bounds checks.

---

**Notes**: This vulnerability represents a defensive programming failure in a critical consensus path. While normal operation should prevent validator set mismatches, the lack of validation means any edge case or bug in validator set management will cause validator crashes instead of graceful error handling. The explicit decision to skip transcript verification, combined with missing bounds checks at multiple layers, creates unnecessary fragility in the epoch transition process.

### Citations

**File:** crates/aptos-crypto/src/player.rs (L21-28)
```rust
pub struct Player {
    /// A number from 0 to n-1.
    pub id: usize,
}

/// The point of Player is to provide type-safety: ensure nobody creates out-of-range player IDs.
/// So there is no `new()` method; only the SecretSharingConfig trait is allowed to create them.
// TODO: AFAIK the only way to really enforce this is to put both traits inside the same module (or use unsafe Rust)
```

**File:** consensus/src/epoch_manager.rs (L1047-1052)
```rust
        let my_index = new_epoch_state
            .verifier
            .address_to_validator_index()
            .get(&self.author)
            .copied()
            .ok_or_else(|| NoRandomnessReason::NotInValidatorSet)?;
```

**File:** consensus/src/epoch_manager.rs (L1063-1072)
```rust
        // No need to verify the transcript.

        // keys for randomness generation
        let (sk, pk) = DefaultDKG::decrypt_secret_share_from_transcript(
            &dkg_pub_params,
            &transcript,
            my_index as u64,
            &dkg_decrypt_key,
        )
        .map_err(NoRandomnessReason::SecretShareDecryptionFailed)?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L97-105)
```rust
pub fn build_dkg_pvss_config(
    cur_epoch: u64,
    secrecy_threshold: U64F64,
    reconstruct_threshold: U64F64,
    maybe_fast_path_secrecy_threshold: Option<U64F64>,
    next_validators: &[ValidatorConsensusInfo],
) -> DKGPvssConfig {
    let validator_stakes: Vec<u64> = next_validators.iter().map(|vi| vi.voting_power).collect();
    let timer = Instant::now();
```

**File:** types/src/dkg/real_dkg/mod.rs (L428-435)
```rust
        let (sk, pk) = trx.main.decrypt_own_share(
            &pub_params.pvss_config.wconfig,
            &Player {
                id: player_idx as usize,
            },
            dk,
            &pub_params.pvss_config.pp,
        );
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-244)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L163-165)
```rust
    pub fn get_player_weight(&self, player: &Player) -> usize {
        self.weights[player.id]
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L199-205)
```rust
    pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
        if j < self.weights[i] {
            Some(self.starting_index[i] + j)
        } else {
            None
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L34-39)
```text
        dkg::start(
            cur_epoch,
            randomness_config::current(),
            stake::cur_validator_consensus_infos(),
            stake::next_validator_consensus_infos(),
        );
```
