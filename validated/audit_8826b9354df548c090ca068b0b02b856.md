# Audit Report

## Title
DKG Range Proof Verification Panic Due to Missing Length Validation Causes Validator Node Crashes

## Summary
The DeKART univariate range proof verification functions in the DKG system fail to validate that proof vector lengths match the expected `ell` parameter before performing multi-scalar multiplication (MSM) operations. A Byzantine validator can craft a malicious DKG transcript with mismatched vector lengths, causing all honest validators to panic and crash during consensus execution, leading to consensus disruption.

## Finding Description

The range proof verification implementation contains a critical missing validation that allows panics during DKG transcript verification. The vulnerability exists in both `dekart_univariate.rs` and `dekart_univariate_v2.rs` implementations.

The `Proof` struct derives `CanonicalDeserialize`, allowing arbitrary-length vectors to be deserialized without validation: [1](#0-0) 

The `verify()` function performs MSM operations without validating that vector lengths match the `ell` parameter: [2](#0-1) 

When `self.c.len() ≠ ell`, the MSM returns an error which triggers a panic via `.expect()`. Additional panic points exist: [3](#0-2) 

Array indexing operations also panic on out-of-bounds access when vector lengths are incorrect: [4](#0-3) 

The v2 implementation has the same vulnerability: [5](#0-4) [6](#0-5) 

**Attack Path:**

1. Byzantine validator creates a malicious DKG transcript with range proof vectors where `c.len() ≠ ell` or `Cs.len() ≠ ell`
2. Transcript is serialized and submitted as a ValidatorTransaction::DKGResult during epoch transition
3. Honest validators deserialize the transcript via BCS (no length validation): [7](#0-6) 

4. VM processes the DKG result and calls verification: [8](#0-7) 

5. Transcript verification flows to the main PVSS transcript verification: [9](#0-8) 

6. Which calls the range proof verification where the panic occurs: [10](#0-9) 

7. The panic propagates to the global panic handler which terminates the process: [11](#0-10) 

Since DKG range proof verification does not set the verifier/deserializer state, the panic causes `process::exit(12)`, crashing the validator node.

## Impact Explanation

**Severity: High**

This vulnerability aligns with the Aptos bug bounty **HIGH** severity category for "Validator Node Slowdowns" and "API Crashes":

- **Validator Node Crashes**: Each validator processing the malicious transcript will panic and crash with exit code 12, requiring manual restart
- **Consensus Disruption**: If enough validators crash simultaneously, consensus can experience delays or temporary liveness loss until nodes are restarted
- **Deterministic Failure**: All honest validators processing the same malicious block will crash identically, as the panic is deterministic
- **Byzantine Fault Tolerance Violation**: A single Byzantine validator (well within the <1/3 BFT threshold) can trigger crashes across the entire honest validator set

This breaks the consensus liveness guarantee that the system should maintain progress under <1/3 Byzantine validators. The vulnerability violates the principle that cryptographic verification should return errors gracefully rather than crash the process.

While this causes validator node crashes, it differs from out-of-scope "Network DoS attacks" because it exploits a protocol-level bug (missing validation) through normal consensus mechanisms, not external network-level attacks.

## Likelihood Explanation

**Likelihood: High**

- **Low Barrier to Attack**: Any validator can create and submit DKG transcripts during epoch transitions as part of normal DKG protocol operations. No special privileges beyond validator status are required
- **Simple Exploitation**: Crafting a malicious proof only requires modifying vector lengths before serialization - no complex cryptographic computation, timing manipulation, or state preparation is needed
- **No Upstream Detection**: The vulnerability exists in core verification logic with no prior validation that would catch malformed proofs before the panic occurs
- **Guaranteed Impact**: The attack deterministically crashes all validators that process the malicious transcript, making the exploit reliable and repeatable
- **Regular Opportunity**: DKG runs during every epoch transition, providing recurring attack windows approximately every 2 hours

The attack requires validator status, which is within the Byzantine threat model (<1/3 Byzantine validators) that Aptos consensus is explicitly designed to tolerate. The validator's identity is authenticated, but the content of their DKG transcript is only validated during the cryptographic verification step where the panic occurs.

## Recommendation

Add explicit length validation in the `verify()` function before any operations that assume specific vector lengths:

```rust
fn verify(
    &self,
    vk: &Self::VerificationKey,
    n: usize,
    ell: usize,
    comm: &Self::Commitment,
) -> anyhow::Result<()> {
    // Add length validation immediately
    anyhow::ensure!(
        self.c.len() == ell,
        "Proof vector c has length {} but expected {}",
        self.c.len(),
        ell
    );
    anyhow::ensure!(
        self.c_hat.len() == ell,
        "Proof vector c_hat has length {} but expected {}",
        self.c_hat.len(),
        ell
    );
    
    // Continue with existing verification logic...
    let mut fs_t = merlin::Transcript::new(Self::DST);
    // ... rest of function
}
```

Similarly for `dekart_univariate_v2.rs`:

```rust
fn verify(
    &self,
    vk: &Self::VerificationKey,
    n: usize,
    ell: usize,
    comm: &Self::Commitment,
) -> anyhow::Result<()> {
    // Add length validations
    anyhow::ensure!(
        self.Cs.len() == ell,
        "Proof vector Cs has length {} but expected {}",
        self.Cs.len(),
        ell
    );
    anyhow::ensure!(
        self.a_js.len() == ell,
        "Proof vector a_js has length {} but expected {}",
        self.a_js.len(),
        ell
    );
    
    // Continue with existing verification logic...
}
```

This ensures that any malformed proof with incorrect vector lengths is rejected with a proper error before any panic-inducing operations occur.

## Proof of Concept

While a complete PoC would require setting up a test validator network, the vulnerability can be demonstrated conceptually:

```rust
#[test]
fn test_range_proof_length_mismatch_panic() {
    use aptos_dkg::range_proofs::dekart_univariate::Proof;
    use ark_bls12_381::Bls12_381;
    
    // Create a proof with mismatched vector lengths
    let mut malicious_proof = Proof::<Bls12_381>::generate(10, &mut rng);
    
    // Truncate one vector to create length mismatch
    malicious_proof.c.truncate(5); // c.len() = 5, but ell = 10
    
    // Serialize and deserialize (no validation occurs)
    let bytes = bcs::to_bytes(&malicious_proof).unwrap();
    let deserialized: Proof<Bls12_381> = bcs::from_bytes(&bytes).unwrap();
    
    // Verification will panic due to MSM length mismatch
    // This is the same path that would execute in a DKG transcript verification
    let result = deserialized.verify(&vk, n, 10, &comm);
    // Expected: panic with "Failed to compute msm"
    // Actual secure behavior: should return Err() instead
}
```

The attack scenario in production:
1. Malicious validator modifies their DKG transcript generation to produce proofs with `c.len() = 5` when `ell = 10`
2. Submits the transcript as part of normal DKG protocol
3. All honest validators deserialize and attempt to verify the transcript
4. All honest validators panic and crash with exit code 12
5. Consensus is disrupted until validators are manually restarted

### Citations

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L31-36)
```rust
#[derive(CanonicalSerialize, CanonicalDeserialize, Debug, Clone, PartialEq, Eq)]
pub struct Proof<E: Pairing> {
    d: E::G1,                // commitment to h(X) = \sum_{j=0}^{\ell-1} beta_j h_j(X)
    c: Vec<E::G1Affine>,     // of size \ell
    c_hat: Vec<E::G2Affine>, // of size \ell
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L580-582)
```rust
        let commitment_recomputed: E::G1 =
            VariableBaseMSM::msm(&self.c, &vk.powers_of_two[..ell]).expect("Failed to compute msm");
        ensure!(comm.0 == commitment_recomputed);
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L599-608)
```rust
        let h_check = E::multi_pairing(
            (0..ell)
                .map(|j| self.c[j] * betas[j]) // E::G1
                .chain(once(-self.d)) // add -d
                .collect::<Vec<_>>(), // collect into Vec<E::G1>
            (0..ell)
                .map(|j| self.c_hat[j] - vk.tau_2) // E::G2
                .chain(once(vk.vanishing_com)) // add vanishing commitment
                .collect::<Vec<_>>(), // collect into Vec<E::G2>
        );
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate.rs (L614-617)
```rust
        let g1_comb = VariableBaseMSM::msm(&self.c, &alphas).unwrap();

        // Compute MSM in G2: sum_j (alphas[j] * proof.c_hat[j])
        let g2_comb = VariableBaseMSM::msm(&self.c_hat, &alphas).unwrap();
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L38-48)
```rust
#[derive(CanonicalSerialize, Debug, PartialEq, Eq, Clone, CanonicalDeserialize)]
pub struct Proof<E: Pairing> {
    hatC: E::G1,
    pi_PoK: sigma_protocol::Proof<E::ScalarField, two_term_msm::Homomorphism<E::G1>>,
    Cs: Vec<E::G1>, // has length ell
    D: E::G1,
    a: E::ScalarField,
    a_h: E::ScalarField,
    a_js: Vec<E::ScalarField>, // has length ell
    pi_gamma: univariate_hiding_kzg::OpeningProof<E>,
}
```

**File:** crates/aptos-dkg/src/range_proofs/dekart_univariate_v2.rs (L738-738)
```rust
        let U = E::G1::msm(&U_bases, &U_scalars).expect("Failed to compute MSM in DeKARTv2");
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L106-109)
```rust
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L193-200)
```rust
            if let Err(err) = self.sharing_proof.range_proof.verify(
                &pp.pk_range_proof.vk,
                sc.get_total_weight() * num_chunks_per_scalar::<E::ScalarField>(pp.ell) as usize,
                pp.ell as usize,
                &self.sharing_proof.range_proof_commitment,
            ) {
                bail!("Range proof batch verification failed: {:?}", err);
            }
```

**File:** crates/crash-handler/src/lib.rs (L48-58)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```
