# Audit Report

## Title
Table Native Function Gas Bypass: Value Serialization Cost Not Charged in `native_add_box()`

## Summary
The `native_add_box()` function only charges gas for key serialization but not for value serialization, allowing attackers to force validators to perform expensive BCS serialization of large values while paying minimal gas. The value serialization occurs in `into_change_set()` after the gas meter is no longer accessible, creating an ~8,500x discrepancy for 1MB values.

## Finding Description

The table native implementation contains a critical gas accounting flaw where CPU costs for value serialization are not properly charged during native function execution.

In `native_add_box()`, only the **key** is serialized and charged for gas. The key serialization happens at [1](#0-0)  with gas charging at [2](#0-1) .

The value is stored as a `Value` object without serialization via `gv.move_to(val)` at [3](#0-2) .

The actual value serialization happens later when `into_change_set()` is called during session finalization. The serialization occurs at [4](#0-3)  and [5](#0-4) .

The critical issue is that `into_change_set()` has no access to a gas meter, as shown by its signature at [6](#0-5) . It is called from `SessionExt::finish()` at [7](#0-6) , which also has no gas meter parameter at [8](#0-7) .

The serialization work happens in `serialize_value()` using BCS serialization at [9](#0-8) .

After session finalization, `charge_change_set()` is called at [10](#0-9) . However, this only charges IO gas and storage fees based on the already-serialized write size, not the CPU cost of serialization itself.

**Attack Scenario:**
1. Attacker creates a table with `Table<u8, vector<u8>>`
2. Calls `add_box()` with key = `1` (1 byte) and value = 1MB of data
3. Native function charges: BASE (4,411) + 36 × 1 = 4,447 internal gas for key serialization only
4. Validator must later serialize 1MB value during `into_change_set()`: expected cost of 36 × 1,048,576 = 37,748,736 internal gas, but **zero is charged**
5. Storage fees account for stored size, not the CPU cost of BCS serialization

The gas parameter for BCS serialization is consistently 36 internal gas per byte as shown at [11](#0-10) .

Transaction limits are 1MB per write operation at [12](#0-11)  and 10MB total per transaction at [13](#0-12) , which bound but do not prevent the attack.

## Impact Explanation

**High Severity** - This qualifies as "Validator Node Slowdowns (High)" per the Aptos bug bounty criteria:

- Attackers can craft transactions forcing disproportionate CPU work (BCS serialization of megabyte-scale values) while paying minimal native function gas (4,447 gas vs expected 37,748,736 gas for 1MB)
- The gas parameters show serialization should cost 36 internal gas per byte, but this only applies to keys, not values
- While storage fees eventually charge for stored bytes, the CPU serialization work occurs in a non-metered context before storage fees are applied
- Repeated exploitation could cause validator performance degradation through CPU exhaustion
- An attacker can create 10 table entries of 1MB each per transaction, causing ~377 million internal gas worth of uncharged CPU work
- Does not cause consensus failures or fund loss, but degrades network performance through resource exhaustion

## Likelihood Explanation

**High Likelihood:**
- Exploitable by any transaction sender with no special privileges
- Simple to execute: create table and call `add()` with small key (1 byte) and large value (up to 1MB)
- No prerequisites beyond transaction submission capability
- Attack is economically viable as the gas discrepancy is ~8,500x for 1MB values
- Can be repeated across multiple transactions to amplify impact
- No complex timing or state requirements

## Recommendation

Charge gas for value serialization during `native_add_box()` execution, similar to how key serialization is charged. This requires:

1. Serialize the value during native function execution when the gas meter is accessible
2. Charge gas proportional to the serialized value size (36 internal gas per byte)
3. Cache the serialized bytes to avoid re-serialization in `into_change_set()`

Alternatively, restructure the session finalization flow to provide gas meter access to `into_change_set()` for charging serialization costs.

## Proof of Concept

```move
module attacker::exploit {
    use std::vector;
    use aptos_std::table;

    public entry fun exploit_gas_bypass(account: &signer) {
        // Create table
        let t = table::new<u8, vector<u8>>();
        
        // Create 1MB value
        let large_value = vector::empty<u8>();
        let i = 0;
        while (i < 1048576) {
            vector::push_back(&mut large_value, 0);
            i = i + 1;
        };
        
        // Add with small key (1 byte) and large value (1MB)
        // Only charges ~4,447 gas but forces ~37.7M gas worth of CPU work
        table::add(&mut t, 1u8, large_value);
        
        // Move table to storage to trigger serialization
        move_to(account, TableHolder { t });
    }
    
    struct TableHolder has key {
        t: table::Table<u8, vector<u8>>
    }
}
```

This proof of concept demonstrates that a 1MB value can be inserted into a table while only paying gas for the 1-byte key serialization, forcing validators to perform expensive BCS serialization of the value during session finalization without corresponding gas charges.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L145-148)
```rust
    pub fn into_change_set(
        self,
        function_value_extension: &impl FunctionValueExtension,
    ) -> PartialVMResult<TableChangeSet> {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L173-178)
```rust
                            Op::New(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L183-188)
```rust
                            Op::Modify(serialize_value(
                                function_value_extension,
                                &value_layout_info,
                                &val,
                            )?),
                        );
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L411-412)
```rust
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L428-428)
```rust
    let res = match gv.move_to(val) {
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L438-438)
```rust
    context.charge(key_cost)?;
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L680-702)
```rust
fn serialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    layout_info: &LayoutInfo,
    val: &Value,
) -> PartialVMResult<(Bytes, Option<TriompheArc<MoveTypeLayout>>)> {
    let max_value_nest_depth = function_value_extension.max_value_nest_depth();
    let serialization_result = if layout_info.contains_delayed_fields {
        // Value contains delayed fields, so we should be able to serialize it.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_delayed_fields_serde()
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), Some(layout_info.layout.clone())))
    } else {
        // No delayed fields, make sure serialization fails if there are any
        // native values.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), None))
    };
    serialization_result.ok_or_else(|| partial_extension_error("cannot serialize table value"))
}
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L161-165)
```rust
    pub fn finish(
        self,
        configs: &ChangeSetConfigs,
        module_storage: &impl ModuleStorage,
    ) -> VMResult<VMChangeSet> {
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L220-223)
```rust
        let table_context: NativeTableContext = extensions.remove();
        let table_change_set = table_context
            .into_change_set(&function_extension)
            .map_err(|e| e.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1112-1140)
```rust
    fn charge_change_set(
        &self,
        change_set: &mut impl ChangeSetInterface,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<GasQuantity<Octa>, VMStatus> {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }

        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
        if !self.features().is_storage_deletion_refund_enabled() {
            storage_refund = 0.into();
        }

        Ok(storage_refund)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/table.rs (L23-23)
```rust
        [add_box_per_byte_serialized: InternalGasPerByte, "add_box.per_byte_serialized", 36],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-156)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L159-161)
```rust
            max_bytes_all_write_ops_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_write_ops_per_transaction" },
            10 << 20, // all write ops from a single transaction are 10MB max
```
