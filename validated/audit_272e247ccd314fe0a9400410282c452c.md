# Audit Report

## Title
JSON Key Ordering Attack Bypasses UnsupportedJWK Deduplication via Non-Canonical Serialization

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization (`json_value.to_string()`) before computing ID hashes. This allows identical JWKs with different key orderings to produce different IDs, completely bypassing the ID-based deduplication mechanism and causing consensus liveness issues when validators observe different JSON key orderings from the same OIDC provider.

## Finding Description

The vulnerability exists in the conversion of `serde_json::Value` to `UnsupportedJWK`, where the ID is computed by hashing the non-canonical JSON string representation: [1](#0-0) 

The code explicitly acknowledges this issue with a TODO comment on line 53. Since `serde_json::Value::to_string()` does not guarantee any particular key ordering, the same semantic JWK object can produce different string representations and therefore different SHA3-256 hash IDs.

The system relies on unique IDs for JWK deduplication. The `get_jwk_id` function extracts the `id` field from `UnsupportedJWK` structs: [2](#0-1) 

The `upsert_jwk` function uses these IDs for deduplication via binary search, comparing JWK IDs to determine insertion or update positions: [3](#0-2) 

**Attack Flow:**

1. Attacker controls an OIDC provider (federated keyless dapp owner per AIP-96)
2. Provider serves unsupported JWK formats (not parseable as `RSA_JWK`)
3. Provider alternates key orderings: `{"kid":"A","kty":"EC"}` vs `{"kty":"EC","kid":"A"}`
4. Validators fetch JWKs from the provider's endpoint: [4](#0-3) 

5. Each JSON value is converted to a JWK, falling back to `UnsupportedJWK` for unsupported formats: [5](#0-4) [6](#0-5) 

6. Different key orderings produce different `to_string()` output, resulting in different SHA3-256 hashes and therefore different IDs
7. Validators sort JWKs by ID and attempt consensus: [7](#0-6) 

**Consensus Impact:**

When validators observe the same provider's JWKs with different key orderings, they compute different IDs. During consensus aggregation, the system requires exact equality of observations: [8](#0-7) 

Validators with mismatched JWK IDs will fail to reach consensus with a "mismatched view" error, preventing quorum from being achieved and causing consensus liveness degradation.

## Impact Explanation

**Severity: High** per Aptos bug bounty categories:

1. **Validator Node Slowdowns**: Each duplicate JWK with a different ID consumes processing resources during observation aggregation, multi-signature verification, and on-chain storage operations. This matches the HIGH severity criterion of "significant performance degradation affecting consensus."

2. **Consensus Liveness Issues**: Different validators observing different key orderings will have mismatched `ProviderJWKs` views, preventing them from reaching the required quorum threshold. This causes temporary but significant consensus delays for JWK updates.

3. **Resource Exhaustion**: For federated JWKs, a 2KB size limit is enforced: [9](#0-8) [10](#0-9) 

An attacker can fill this limit faster with duplicate entries (same semantic JWK with different IDs), reducing capacity for legitimate JWKs.

4. **Protocol Violations**: The deduplication mechanism is a core security control ensuring unique JWKs are stored. Bypassing it violates the protocol's resource management and consensus invariants.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements for exploitation:**
- Attacker controls an OIDC provider in a federated keyless scenario (AIP-96), OR
- Mainstream OIDC provider adopts new unsupported key types with non-deterministic JSON serialization

**Feasibility:**
- Federated keyless (AIP-96) explicitly allows dapp owners to run their own OIDC providers
- Dapp owners are untrusted actors in the threat model
- No special validator access or privileges required
- Attack is entirely client-side (manipulating served JSON responses)

**Attack complexity: Low**
- Simply serve the same JWK JSON object with different key orderings to different validators or at different times
- No cryptographic attacks required
- No protocol-level exploits needed
- Can be accomplished with basic HTTP server configuration

## Recommendation

Implement canonical JSON serialization before computing the ID hash in `UnsupportedJWK::from()`. Use a deterministic JSON canonicalization library such as `serde_json_canonicalizer` or implement RFC 8785 (JSON Canonicalization Scheme).

**Fixed code approach:**
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (RFC 8785)
        let payload = canonical_json_serialize(&json_value);
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Alternatively, for `UnsupportedJWK` objects, extract and use a deterministic identifier from the JSON (like the `kid` field if present) rather than hashing the entire serialized payload.

## Proof of Concept

The following demonstrates how different key orderings produce different IDs:

```rust
#[test]
fn test_non_canonical_json_produces_different_ids() {
    use serde_json::json;
    use aptos_types::jwks::unsupported::UnsupportedJWK;
    
    // Same semantic JWK with different key orderings
    let jwk1 = json!({"kid": "key1", "kty": "EC", "crv": "P-256"});
    let jwk2 = json!({"kty": "EC", "kid": "key1", "crv": "P-256"});
    let jwk3 = json!({"crv": "P-256", "kty": "EC", "kid": "key1"});
    
    let unsupported1 = UnsupportedJWK::from(jwk1);
    let unsupported2 = UnsupportedJWK::from(jwk2);
    let unsupported3 = UnsupportedJWK::from(jwk3);
    
    // Despite being semantically identical, they produce different IDs
    assert_ne!(unsupported1.id, unsupported2.id);
    assert_ne!(unsupported2.id, unsupported3.id);
    assert_ne!(unsupported1.id, unsupported3.id);
    
    // This bypasses deduplication in upsert_jwk
    println!("ID 1: {:?}", hex::encode(&unsupported1.id));
    println!("ID 2: {:?}", hex::encode(&unsupported2.id));
    println!("ID 3: {:?}", hex::encode(&unsupported3.id));
}
```

## Notes

This vulnerability specifically affects:
1. **Federated keyless providers** serving unsupported JWK formats (primary attack vector)
2. **Mainstream OIDC providers** (Google, Apple, etc.) if they adopt new key types that fall into the `UnsupportedJWK` category

For `RSA_JWK` types, the vulnerability does not apply because the ID is extracted from the `kid` field rather than computed from a hash, making it deterministic regardless of JSON key ordering.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L31-33)
```text
    /// We limit the size of a `PatchedJWKs` resource installed by a dapp owner for federated keyless accounts.
    /// Note: If too large, validators waste work reading it for invalid TXN signatures.
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L200-203)
```text
        // TODO: Can we check the size more efficiently instead of serializing it via BCS?
        let num_bytes = vector::length(&bcs::to_bytes(fed_jwks));
        assert!(num_bytes < MAX_FEDERATED_JWKS_SIZE_BYTES, error::invalid_argument(EFEDERATED_JWKS_TOO_LARGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L562-573)
```text
    fun get_jwk_id(jwk: &JWK): vector<u8> {
        let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
        if (variant_type_name == b"0x1::jwks::RSA_JWK") {
            let rsa = copyable_any::unpack<RSA_JWK>(jwk.variant);
            *string::bytes(&rsa.kid)
        } else if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
            let unsupported = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
            unsupported.id
        } else {
            abort(error::invalid_argument(EUNKNOWN_JWK_VARIANT))
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L626-654)
```text
    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {
        let found = false;
        let index = 0;
        let num_entries = vector::length(&set.jwks);
        while (index < num_entries) {
            let cur_entry = vector::borrow(&set.jwks, index);
            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));
            if (is_greater_than(&comparison)) {
                index = index + 1;
            } else {
                found = is_equal(&comparison);
                break
            }
        };

        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to
        // where we want to insert.
        let ret = if (found) {
            let entry = vector::borrow_mut(&mut set.jwks, index);
            let old_entry = option::some(*entry);
            *entry = jwk;
            old_entry
        } else {
            vector::insert(&mut set.jwks, index, jwk);
            option::none()
        };

        ret
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L77-80)
```rust
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** crates/jwk-utils/src/lib.rs (L34-36)
```rust
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```
