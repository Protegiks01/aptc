# Audit Report

## Title
Missing Validation of Version-Epoch Correspondence in Subscription Streams Allows Generation of Unverifiable Proofs

## Summary
The storage service server does not validate that `known_version_at_stream_start` and `known_epoch_at_stream_start` in subscription requests correspond to the same ledger state. This allows malicious network peers to provide mismatched values, causing servers to generate proofs with incorrect epoch information that clients cannot verify, leading to state sync failures and resource exhaustion.

## Finding Description

The `SubscriptionStreamMetadata` struct contains two critical fields that clients provide when creating subscription streams: [1](#0-0) 

When a client creates a new subscription stream, the server accepts these values without validating their correspondence. The server directly creates a `SubscriptionStreamRequests` object using the client-provided metadata: [2](#0-1) [3](#0-2) 

The server uses `known_epoch_at_stream_start` to fetch the appropriate epoch ending ledger info and `known_version_at_stream_start` to determine which transactions to send. The critical validation occurs when determining if subscriptions are ready: [4](#0-3) 

This validation only checks ONE direction of the version-epoch mismatch at line 951. It detects when a client claims to be in epoch N but has a version beyond epoch N's ending (i.e., `epoch_ending_version <= known_version`). However, it **fails to detect** when a client claims to be in epoch N+1 but has a version still in epoch N (i.e., `epoch_ending_version > known_version` when the version belongs to an earlier epoch).

**Attack Scenario:**
1. Blockchain state: Epoch 4 ends at version 800, Epoch 5 ends at version 1200
2. Malicious client at version 750 (actually in epoch 4) sends subscription with:
   - `known_version_at_stream_start = 750`
   - `known_epoch_at_stream_start = 5` (incorrect - should be 4)
3. Server fetches epoch 5 ending ledger info (version 1200)
4. Check: `1200 <= 750`? **FALSE** → Not marked invalid, marked as ready
5. Server generates proof request with the wrong epoch ending as target

The proof generation uses the target ledger info's version as the proof version: [5](#0-4) 

The server sends transactions starting from version 751 (which include the epoch 4→5 transition at version 801) with proofs anchored at epoch 5's ending (version 1200). The client at epoch 4 cannot verify these proofs because they only have epoch 4's validator set and cannot verify epoch 5 validator signatures.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria, specifically as a "Validator Node Slowdowns" issue that can cause significant resource exhaustion:

1. **State Sync Failure**: Clients receive proofs with epoch information inconsistent with their actual state, causing verification failures and blocking state synchronization for legitimate nodes trying to sync.

2. **Resource Exhaustion**: Storage service servers (which run on validators and fullnodes) waste computational resources generating cryptographically valid but semantically incorrect proofs that clients cannot use. This includes CPU for proof generation and network bandwidth for transmission.

3. **Denial of Service Potential**: Malicious actors can repeatedly create subscriptions with mismatched epoch/version values, causing continuous resource waste on storage servers. Since this bypasses the initial validation, it can consume server resources before being detected.

4. **Protocol Invariant Violation**: Breaks the critical state sync invariant that proofs must be verifiable by clients at their claimed position. The generated proofs are cryptographically valid but semantically incorrect for the client's state.

The vulnerability affects the state sync infrastructure used by validators and fullnodes to maintain synchronized blockchain state: [6](#0-5) 

## Likelihood Explanation

**Likelihood: High**

- **No authentication beyond network-level**: Any connected network peer can send subscription requests with arbitrary version/epoch values. The request handling accepts client-provided metadata without upfront validation.

- **Simple exploitation**: Attacker only needs to provide two mismatched integer values in the subscription request. No complex protocol interactions or timing requirements.

- **No special privileges needed**: Requires no validator access, staking, or insider knowledge. Any peer connected to the network can exploit this.

- **Easily repeatable**: Attack can be executed continuously by creating multiple subscription streams with different stream IDs, bypassing rate limits that only apply after requests are marked invalid.

- **Bypasses validation**: The attack bypasses the initial validation logic and only wastes resources during proof generation, making it difficult to detect and prevent proactively.

## Recommendation

Add bidirectional validation to check that the claimed epoch and version correspond to the same ledger state. When a peer claims to be at a specific version and epoch, verify that:

1. The version is NOT beyond the claimed epoch's ending (existing check)
2. The version is NOT before the claimed epoch's beginning (missing check)

The fix should be implemented in `identify_ready_and_invalid_subscriptions()` by fetching the previous epoch's ending ledger info and validating:

```rust
// After line 947 in subscription.rs, add:
// Also check that the version is not before this epoch's start
if highest_known_epoch > 0 {
    let previous_epoch_ending_ledger_info = /* fetch epoch (highest_known_epoch - 1) ending */;
    if previous_epoch_ending_ledger_info.ledger_info().version() >= highest_known_version {
        // Version is in previous epoch, not in claimed epoch
        peers_with_invalid_subscriptions.lock().push(peer_network_id);
        return;
    }
}
```

Alternatively, implement validation at subscription creation time in `SubscriptionStreamRequests::new()` by verifying the version-epoch correspondence against storage before accepting the subscription.

## Proof of Concept

The vulnerability can be demonstrated by creating a subscription request with version 750 and epoch 5, when the blockchain state shows version 750 is actually in epoch 4 (which ends at version 800). The existing test at line 172 validates the opposite scenario but not this one: [7](#0-6) 

A complete PoC would involve:
1. Setting up a mock blockchain with epoch 4 ending at version 800
2. Creating a subscription with `known_version_at_stream_start = 750` and `known_epoch_at_stream_start = 5`
3. Observing that the subscription is marked as "ready" instead of "invalid"
4. Verifying that the server generates proofs anchored at epoch 5 ending (version 1200)
5. Demonstrating that a client at epoch 4 cannot verify these proofs

## Notes

This vulnerability represents a missing validation in the state sync protocol that allows untrusted network peers to cause validators and fullnodes to waste resources. While it does not directly compromise consensus or cause fund loss, it can significantly degrade state sync performance and enable resource exhaustion attacks against the storage service infrastructure. The severity is assessed as High due to the potential impact on validator operations and the ease of exploitation.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L417-422)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct SubscriptionStreamMetadata {
    pub known_version_at_stream_start: u64, // The highest known transaction version at stream start
    pub known_epoch_at_stream_start: u64,   // The highest known epoch at stream start
    pub subscription_stream_id: u64,        // The unique id of the subscription stream
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L313-317)
```rust
                    // Create a new subscription stream for the peer
                    let subscription_stream = SubscriptionStreamRequests::new(
                        subscription_request,
                        self.time_service.clone(),
                    );
```

**File:** state-sync/storage-service/server/src/subscription.rs (L68-141)
```rust
    fn get_storage_request_for_missing_data(
        &self,
        config: StorageServiceConfig,
        known_version: u64,
        target_ledger_info: &LedgerInfoWithSignatures,
    ) -> aptos_storage_service_types::Result<StorageServiceRequest, Error> {
        // Calculate the number of versions to fetch
        let target_version = target_ledger_info.ledger_info().version();
        let mut num_versions_to_fetch =
            target_version.checked_sub(known_version).ok_or_else(|| {
                Error::UnexpectedErrorEncountered(
                    "Number of versions to fetch has overflown!".into(),
                )
            })?;

        // Bound the number of versions to fetch by the maximum chunk size
        num_versions_to_fetch = min(
            num_versions_to_fetch,
            self.max_chunk_size_for_request(config),
        );

        // Calculate the start and end versions
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;

        // Create the storage request
        let data_request = match &self.request.data_request {
            DataRequest::SubscribeTransactionOutputsWithProof(_) => {
                DataRequest::GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                })
            },
            DataRequest::SubscribeTransactionsWithProof(request) => {
                DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                    proof_version: target_version,
                    start_version,
                    end_version,
                    include_events: request.include_events,
                })
            },
            DataRequest::SubscribeTransactionsOrOutputsWithProof(request) => {
                DataRequest::GetTransactionsOrOutputsWithProof(
                    TransactionsOrOutputsWithProofRequest {
                        proof_version: target_version,
                        start_version,
                        end_version,
                        include_events: request.include_events,
                        max_num_output_reductions: request.max_num_output_reductions,
                    },
                )
            },
            DataRequest::SubscribeTransactionDataWithProof(request) => {
                DataRequest::GetTransactionDataWithProof(GetTransactionDataWithProofRequest {
                    transaction_data_request_type: request.transaction_data_request_type,
                    proof_version: target_version,
                    start_version,
                    end_version,
                    max_response_bytes: request.max_response_bytes,
                })
            },
            request => unreachable!("Unexpected subscription request: {:?}", request),
        };
        let storage_request =
            StorageServiceRequest::new(data_request, self.request.use_compression);
        Ok(storage_request)
    }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L314-335)
```rust
    pub fn new(subscription_request: SubscriptionRequest, time_service: TimeService) -> Self {
        // Extract the relevant information from the request
        let highest_known_version = subscription_request.highest_known_version_at_stream_start();
        let highest_known_epoch = subscription_request.highest_known_epoch_at_stream_start();
        let subscription_stream_metadata = subscription_request.subscription_stream_metadata();

        // Create a new set of pending subscription requests using the first request
        let mut pending_subscription_requests = BTreeMap::new();
        pending_subscription_requests.insert(
            subscription_request.subscription_stream_index(),
            subscription_request,
        );

        Self {
            highest_known_version,
            highest_known_epoch,
            next_index_to_serve: 0,
            pending_subscription_requests,
            subscription_stream_metadata,
            last_stream_update_time: time_service.now(),
            time_service,
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L918-965)
```rust
        let active_task = runtime.spawn_blocking(move || {
            // Check if we have synced beyond the highest known version
            if highest_known_version < highest_synced_version {
                if highest_known_epoch < highest_synced_epoch {
                    // Fetch the epoch ending ledger info from storage (the
                    // peer needs to sync to their epoch ending ledger info).
                    let epoch_ending_ledger_info = match utils::get_epoch_ending_ledger_info(
                        cached_storage_server_summary.clone(),
                        optimistic_fetches.clone(),
                        subscriptions.clone(),
                        highest_known_epoch,
                        lru_response_cache.clone(),
                        request_moderator.clone(),
                        &peer_network_id,
                        storage.clone(),
                        time_service.clone(),
                    ) {
                        Ok(epoch_ending_ledger_info) => epoch_ending_ledger_info,
                        Err(error) => {
                            // Log the failure to fetch the epoch ending ledger info
                            error!(LogSchema::new(LogEntry::SubscriptionRefresh)
                                .error(&error)
                                .message(&format!(
                                    "Failed to get the epoch ending ledger info for epoch: {:?} !",
                                    highest_known_epoch
                                )));

                            return;
                        },
                    };

                    // Check that we haven't been sent an invalid subscription request
                    // (i.e., a request that does not respect an epoch boundary).
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_subscriptions
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_subscriptions
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
                } else {
                    peers_with_ready_subscriptions
                        .lock()
                        .push((peer_network_id, highest_synced_ledger_info.clone()));
                };
            }
```

**File:** aptos-node/src/state_sync.rs (L266-290)
```rust
fn setup_state_sync_storage_service(
    config: StateSyncConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
    network_service_events: NetworkServiceEvents<StorageServiceMessage>,
    db_rw: &DbReaderWriter,
    storage_service_listener: StorageServiceNotificationListener,
) -> anyhow::Result<Runtime> {
    // Create a new state sync storage service runtime
    let storage_service_runtime = aptos_runtimes::spawn_named_runtime("stor-server".into(), None);

    // Spawn the state sync storage service servers on the runtime
    let storage_reader = StorageReader::new(
        config.storage_service,
        Arc::clone(&db_rw.reader),
        TimeService::real(),
    );
    let service = StorageServiceServer::new(
        config,
        storage_service_runtime.handle().clone(),
        storage_reader,
        TimeService::real(),
        peers_and_metadata,
        StorageServiceNetworkEvents::new(network_service_events),
        storage_service_listener,
    );
```

**File:** state-sync/storage-service/server/src/tests/subscription.rs (L169-191)
```rust
        // Update the storage server summary so that there is new data (at version 100)
        let _ = utils::update_storage_summary_cache(cached_storage_server_summary.clone(), 100, 2);

        // Verify that subscription 3 is not returned because it was invalid
        // (i.e., the epoch ended at version 9, but the peer didn't respect it).
        let peers_with_ready_subscriptions = subscription::get_peers_with_ready_subscriptions(
            Handle::current(),
            storage_service_config,
            cached_storage_server_summary.clone(),
            optimistic_fetches.clone(),
            lru_response_cache.clone(),
            request_moderator.clone(),
            storage_reader.clone(),
            subscriptions.clone(),
            time_service.clone(),
        )
        .await
        .unwrap();
        assert_eq!(peers_with_ready_subscriptions, vec![]);

        // Verify that the subscriptions are now empty
        assert!(subscriptions.is_empty());
    }
```
