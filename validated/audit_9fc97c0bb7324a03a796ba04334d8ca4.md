# Audit Report

## Title
State Sync Failure Due to Overly Restrictive Empty Ledger Info Check

## Summary
The `save_ledger_infos()` function in `restore_utils.rs` contains an overly restrictive empty array check that causes state synchronization to fail when nodes sync to a version within the same epoch. This prevents legitimate node bootstrapping operations and creates temporary liveness issues requiring manual intervention.

## Finding Description

The vulnerability exists in the state sync finalization path. The complete execution flow has been validated:

1. **Same-Epoch Detection**: During bootstrapping, when a node syncs to a target version within the current epoch (no epoch boundaries crossed), the bootstrapper correctly identifies this scenario and logs "No new epoch ending ledger infos to fetch! All peers are in the same epoch!" [1](#0-0) 

2. **Empty Vector Return**: The `all_epoch_ending_ledger_infos()` method returns an empty vector by collecting values from the internal `new_epoch_ending_ledger_infos` BTreeMap, which contains no entries when no epoch boundaries were crossed. [2](#0-1) 

3. **Propagation Through State Sync**: When processing state values beyond genesis, this empty vector is assigned to `epoch_change_proofs` and passed to `initialize_state_synchronizer()`. [3](#0-2) 

4. **Finalization Call**: The empty `epoch_change_proofs` is captured in the spawned receiver [4](#0-3)  and eventually passed to `finalize_storage_and_send_commit()` [5](#0-4) , which calls `finalize_state_snapshot()` with the empty array. [6](#0-5) 

5. **Database Write Attempt**: The `finalize_state_snapshot()` function calls `save_ledger_infos()` with the empty `ledger_infos` array and an existing batch parameter. [7](#0-6) 

6. **Failure Point**: The `save_ledger_infos()` function has an unconditional check at the entry point that rejects empty arrays. [8](#0-7)  This check causes the entire state sync operation to abort with "No LedgerInfos to save." error.

The check was likely added to prevent panics in `update_latest_ledger_info()` which calls `ledger_infos.last().unwrap()` twice. [9](#0-8) 

However, when syncing within the same epoch, there are legitimately no epoch-ending ledger infos to save. The bootstrapper explicitly acknowledges this as a valid scenario, yet the restrictive check prevents successful completion.

## Impact Explanation

**Medium Severity** - This vulnerability causes temporary liveness issues as defined in the Aptos bug bounty program:

- **Node Synchronization Failure**: Nodes attempting to fast-sync to a version within the current epoch will fail and cannot catch up with the network until the next epoch boundary
- **Network Availability Impact**: During periods of low epoch turnover (epochs can span hours or days in Aptos mainnet), multiple nodes could be affected simultaneously
- **Operational Disruption**: Requires manual intervention or workarounds to restore affected nodes to operational state
- **No Consensus Violation**: Does not affect consensus safety or enable fund theft, but impacts network health and node availability

This aligns with Medium Severity criteria per Aptos bug bounty: "State inconsistencies requiring manual intervention" and "temporary liveness issues" - impacts network liveness without causing critical consensus or fund security issues.

## Likelihood Explanation

**High Likelihood** - This will occur in production under normal conditions:

- Epochs in Aptos can span many transactions (hours or days of network operation on mainnet)
- State sync operations frequently occur within the same epoch during normal node operation
- The bootstrapper code explicitly acknowledges same-epoch syncing as a valid scenario with dedicated logging [10](#0-9) 
- No special attacker action required - happens naturally during normal node operation
- Affected nodes include: new validators joining mid-epoch, nodes recovering from downtime, archive nodes syncing
- The execution path from same-epoch detection to failure is direct and unavoidable in the current implementation

## Recommendation

Modify `save_ledger_infos()` to handle empty arrays gracefully:

```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    // Return early if no ledger infos to save (valid for same-epoch sync)
    if ledger_infos.is_empty() {
        return Ok(());
    }

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

This change treats empty arrays as a no-op rather than an error, allowing same-epoch syncing to complete successfully while still preventing panics in `update_latest_ledger_info()`.

## Proof of Concept

A proof of concept would require setting up a full Aptos node environment with:

1. A running network with at least one epoch already completed
2. A new node attempting to bootstrap to a version within the current epoch (not at an epoch boundary)
3. Fast-sync/state-sync enabled on the new node

The node will:
1. Detect that all peers are in the same epoch
2. Proceed with state value synchronization
3. Fail when attempting to finalize the state snapshot with error "No LedgerInfos to save."

The failure can be observed in node logs and the node will be unable to complete synchronization until the next epoch boundary.

## Notes

This vulnerability represents a logic flaw in the state synchronization finalization path. While it does not compromise consensus safety or enable fund theft, it creates a legitimate liveness issue that prevents nodes from joining or recovering within the same epoch. The bootstrapper code explicitly handles same-epoch synchronization as valid, but the overly defensive check in `save_ledger_infos()` prevents this scenario from completing successfully. This meets the Aptos bug bounty Medium severity criteria for temporary liveness issues requiring manual intervention.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L197-202)
```rust
    pub fn all_epoch_ending_ledger_infos(&self) -> Vec<LedgerInfoWithSignatures> {
        self.new_epoch_ending_ledger_infos
            .values()
            .cloned()
            .collect()
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L861-866)
```rust
        } else if self.verified_epoch_states.verified_waypoint() {
            info!(LogSchema::new(LogEntry::Bootstrapper).message(
                "No new epoch ending ledger infos to fetch! All peers are in the same epoch!"
            ));
            self.verified_epoch_states
                .set_fetched_epoch_ending_ledger_infos();
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L988-999)
```rust
            let epoch_change_proofs = if version_to_sync == GENESIS_TRANSACTION_VERSION {
                vec![ledger_info_to_sync.clone()] // Sync to genesis
            } else {
                self.verified_epoch_states.all_epoch_ending_ledger_infos() // Sync beyond genesis
            };

            // Initialize the state value synchronizer
            let _join_handle = self.storage_synchronizer.initialize_state_synchronizer(
                epoch_change_proofs,
                ledger_info_to_sync,
                transaction_output_to_sync.clone(),
            )?;
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L838-842)
```rust
    epoch_change_proofs: Vec<LedgerInfoWithSignatures>,
    target_ledger_info: LedgerInfoWithSignatures,
    target_output_with_proof: TransactionOutputListWithProofV2,
    runtime: Option<Handle>,
) -> JoinHandle<()> {
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L932-943)
```rust
                            if let Err(error) = finalize_storage_and_send_commit(
                                chunk_executor,
                                &mut commit_notification_sender,
                                metadata_storage,
                                state_snapshot_receiver,
                                storage,
                                &epoch_change_proofs,
                                target_output_with_proof,
                                version,
                                &target_ledger_info,
                                last_committed_state_index,
                            )
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L1129-1136)
```rust
    storage
        .writer
        .finalize_state_snapshot(
            version,
            target_output_with_proof.clone(),
            epoch_change_proofs,
        )
        .map_err(|error| format!("Failed to finalize the state snapshot! Error: {:?}", error))?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L201-205)
```rust
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L46-46)
```rust
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L66-71)
```rust
        if li.ledger_info().epoch() > ledger_infos.last().unwrap().ledger_info().epoch() {
            // No need to update latest ledger info.
            return Ok(());
        }
    }
    ledger_metadata_db.set_latest_ledger_info(ledger_infos.last().unwrap().clone());
```
