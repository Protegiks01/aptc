# Audit Report

## Title
Out-of-Bounds Array Access in Cross-Shard Message Routing Due to Unchecked max_partitioning_rounds Configuration

## Summary
The `max_partitioning_rounds` configuration parameter lacks validation against the `MAX_ALLOWED_PARTITIONING_ROUNDS` constant (value: 8), allowing values that exceed pre-allocated cross-shard message channel array bounds. This causes deterministic validator node crashes via Rust panics when round IDs >= 8 attempt to access out-of-bounds array indices during cross-shard communication.

## Finding Description

The vulnerability exists in the interaction between three components:

**1. Unchecked Configuration Setter:**

The `max_partitioning_rounds()` setter method accepts arbitrary `usize` values without any validation against the system's hard limit: [1](#0-0) 

Similarly, the CLI parameter accepts any value: [2](#0-1) 

**2. Hardcoded Channel Array Allocation:**

Cross-shard message channels are allocated with a fixed size of `MAX_ALLOWED_PARTITIONING_ROUNDS` (8): [3](#0-2) 

For local execution: [4](#0-3) 

For remote execution: [5](#0-4) 

This creates arrays with valid indices 0-7 only.

**3. Unchecked Array Access:**

The `send_cross_shard_msg` and `receive_cross_shard_msg` methods use `round` as a direct array index without bounds checking: [6](#0-5) [7](#0-6) 

**Exploitation Path:**

If a validator configures `max_partitioning_rounds` to any value > 8 (e.g., 10):

1. The partitioner creates rounds 0 through (max_partitioning_rounds - 2) in a loop, then adds a final round: [8](#0-7) [9](#0-8) 

This creates rounds 0-9 (10 total rounds) when max_partitioning_rounds = 10.

2. During block execution, the service iterates through all sub-blocks and executes each round: [10](#0-9) 

3. When executing rounds 8 or 9, cross-shard messages are sent with the round parameter: [11](#0-10) 

4. These array accesses with round=8 or round=9 are out-of-bounds for arrays sized to 8 (valid indices 0-7), causing a Rust panic and immediate validator process termination.

**Additional Semantic Violation:**

The system defines `GLOBAL_ROUND_ID = MAX_ALLOWED_PARTITIONING_ROUNDS + 1 = 9`: [12](#0-11) 

If `max_partitioning_rounds` is set to exactly 9, regular sharded transactions in round 8 may collide with the global round ID, potentially causing message misrouting and incorrect transaction execution ordering.

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Validator Node Crashes (High)**: Any validator with misconfigured `max_partitioning_rounds > 8` will experience deterministic crashes during block execution with sharded transactions. This causes:
   - Loss of validator participation and rewards
   - Reduced network decentralization
   - Service disruption requiring manual intervention

2. **Network Liveness Risk (High)**: If multiple validators share the same misconfiguration (e.g., copying deployment scripts), the network could experience temporary liveness issues due to reduced validator participation. While not reaching the threshold for "total liveness failure," this still represents significant network disruption.

3. **Potential Consensus Impact**: The GLOBAL_ROUND_ID collision scenario (when max_partitioning_rounds = 9) could theoretically cause message misrouting, though the actual impact on consensus would require deeper analysis to confirm state divergence.

Per Aptos bug bounty criteria, validator node crashes that affect network operation qualify as **High Severity** impact.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability has medium likelihood of occurring in practice:

**Factors Increasing Likelihood:**
1. **No Input Validation**: The configuration system accepts any positive integer without validation or warnings
2. **Non-Obvious Limit**: The `MAX_ALLOWED_PARTITIONING_ROUNDS = 8` constraint is defined in a separate file with no documentation linking it to the configuration parameter
3. **Performance Tuning Incentive**: Validators seeking to optimize parallel execution throughput may experiment with higher values
4. **Misleading Default**: The default value of 4 is well below the limit, providing no indication that a hard boundary exists

**Factors Decreasing Likelihood:**
1. **Explicit Configuration Required**: The vulnerability requires validators to explicitly override the default value
2. **Safe Default**: The default value of 4 is well within safe bounds
3. **Limited Documentation**: Without clear guidance on tuning this parameter, most validators likely use defaults

While the vulnerability requires explicit misconfiguration, the lack of validation and non-obvious constraints make accidental triggering reasonably possible, especially if validators share configuration templates or attempt performance optimization.

## Recommendation

**Immediate Fix:**

Add validation to the configuration setters to enforce the hard limit:

```rust
// In execution/block-partitioner/src/v2/config.rs
pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
    assert!(
        val <= MAX_ALLOWED_PARTITIONING_ROUNDS,
        "max_partitioning_rounds ({}) exceeds MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
        val,
        MAX_ALLOWED_PARTITIONING_ROUNDS
    );
    self.max_partitioning_rounds = val;
    self
}
```

**Additional Recommendations:**

1. Add runtime assertion in the partitioner to catch violations:
   ```rust
   // In execution/block-partitioner/src/v2/mod.rs
   pub fn new(..., num_rounds_limit: usize, ...) -> Self {
       assert!(
           num_rounds_limit <= MAX_ALLOWED_PARTITIONING_ROUNDS,
           "Configuration error: max_partitioning_rounds must be <= {}",
           MAX_ALLOWED_PARTITIONING_ROUNDS
       );
       // ... rest of constructor
   }
   ```

2. Add bounds checking before array access:
   ```rust
   // In local_executor_shard.rs
   fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
       assert!(round < MAX_ALLOWED_PARTITIONING_ROUNDS, 
               "Round {} exceeds maximum {}", round, MAX_ALLOWED_PARTITIONING_ROUNDS);
       self.message_txs[shard_id][round].send(msg).unwrap()
   }
   ```

3. Document the constraint in configuration documentation and CLI help text

## Proof of Concept

The vulnerability can be reproduced with the following steps:

```bash
# Run executor-benchmark with max_partitioning_rounds > 8
./target/release/executor-benchmark \
    --block-size 1000 \
    --num-executor-shards 4 \
    --max-partitioning-rounds 10 \
    --use-sharded-block-executor

# Expected result: Validator crashes with:
# thread 'executor-shard-X' panicked at 'index out of bounds: 
# the len is 8 but the index is 8'
```

The crash occurs when the executor attempts to send cross-shard messages for transactions in rounds 8 or 9, which exceed the pre-allocated channel array bounds.

## Notes

1. **Production Impact**: The sharded block executor is used in production environments, making this a real operational risk for validators who might tune performance parameters.

2. **GLOBAL_ROUND_ID Collision**: The secondary issue where `max_partitioning_rounds = 9` equals `GLOBAL_ROUND_ID` represents a potential semantic violation that could affect transaction ordering, though the exact consensus impact requires further investigation.

3. **Defense in Depth**: Even with the configuration validation fix, adding runtime bounds checking provides an additional safety layer against future code changes.

4. **Scope**: This vulnerability affects both local (in-process) and remote (distributed) sharded execution modes, as both use the same channel allocation pattern based on `MAX_ALLOWED_PARTITIONING_ROUNDS`.

### Citations

**File:** execution/block-partitioner/src/v2/config.rs (L28-31)
```rust
    pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
        self.max_partitioning_rounds = val;
        self
    }
```

**File:** execution/executor-benchmark/src/main.rs (L216-217)
```rust
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
```

**File:** types/src/block_executor/partitioner.rs (L20-20)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
```

**File:** types/src/block_executor/partitioner.rs (L21-21)
```rust
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-337)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        self.message_rxs[current_round].recv().unwrap()
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L28-41)
```rust
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-48)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
            remaining_txns = discarded;
            num_remaining_txns = remaining_txns.iter().map(|ts| ts.len()).sum();

            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
        }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L60-70)
```rust
        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
                    });
                });
        });
        state.finalized_txn_matrix.push(remaining_txns);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L164-168)
```rust
                    cross_shard_client_clone.send_cross_shard_msg(
                        shard_id,
                        round,
                        CrossShardMsg::StopMsg,
                    );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L192-205)
```rust
        for (round, sub_block) in transactions.into_sub_blocks().into_iter().enumerate() {
            let _timer = SHARDED_BLOCK_EXECUTION_BY_ROUNDS_SECONDS
                .timer_with(&[&self.shard_id.to_string(), &round.to_string()]);
            SHARDED_BLOCK_EXECUTOR_TXN_COUNT.observe_with(
                &[&self.shard_id.to_string(), &round.to_string()],
                sub_block.transactions.len() as f64,
            );
            info!(
                "executing sub block for shard {} and round {}, number of txns {}",
                self.shard_id,
                round,
                sub_block.transactions.len()
            );
            result.push(self.execute_sub_block(sub_block, round, state_view, config.clone())?);
```
