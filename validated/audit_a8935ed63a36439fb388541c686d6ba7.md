# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution While Keeping Block

## Summary
The `process_block_epilogue()` function contains overly permissive error handling that returns a success status even when block epilogue execution fails, causing permanent loss of transaction fees for validators when validator set changes occur during epoch transitions.

## Finding Description
The vulnerability exists in the interaction between block execution, epoch reconfiguration, and fee distribution. The execution flow is:

**Normal Flow:**
1. Consensus sets proposer_index in transaction auxiliary_info based on the current validator set [1](#0-0) 
2. Block prologue executes and may trigger epoch reconfiguration [2](#0-1) 
3. During reconfiguration, `on_new_epoch()` reassigns validator indices sequentially starting from 0 [3](#0-2) 
4. The `pending_fee_by_validator` map is cleared and repopulated with only current active validators [4](#0-3) 
5. Block epilogue calls `block::block_epilogue` [5](#0-4) 
6. Which calls `stake::record_fee` with proposer indices from before reconfiguration [6](#0-5) 
7. `record_fee` calls `borrow_mut` on the map with old proposer index [7](#0-6) 

**Vulnerability Trigger:**
When validators leave during epoch reconfiguration, the new validator set has fewer validators and indices are compressed (e.g., 10 validators â†’ 9 validators means indices 0-9 become 0-8). If the proposer_index from transactions is >= the new validator count, `borrow_mut` aborts with `EKEY_NOT_FOUND` [8](#0-7) 

**Broken Error Handling:**
The error is caught and the system returns success with empty output, keeping the block but skipping all fee distribution [9](#0-8) 

This breaks the security guarantee that "validator rewards and penalties must be calculated correctly" as fees are permanently lost without recovery mechanism.

## Impact Explanation
**Medium Severity** - Qualifies as "Limited funds loss or manipulation" under Aptos bug bounty Medium severity criteria.

**Specific Impacts:**
1. **Permanent Financial Loss**: All transaction fees from affected blocks are permanently lost to validators
2. **No Detection/Recovery**: Only error logs exist; no on-chain record or recovery mechanism
3. **State Inconsistency**: Violates the invariant that all successful blocks must distribute fees
4. **Silent Failure**: Validators have no way to detect they lost fees

The impact is limited to fee loss from individual blocks (not total network funds) but is permanent and unrecoverable, justifying Medium severity.

## Likelihood Explanation
**Low to Medium** - Requires specific conditions but can occur naturally:

**Required Conditions:**
1. Block triggers epoch reconfiguration
2. At least one validator leaves the active set during reconfiguration  
3. Proposer's old index becomes >= new validator count

**Likelihood Factors:**
- Epoch transitions are scheduled events (e.g., daily/weekly)
- Validator departures are relatively rare but do occur
- The specific index mismatch depends on which validators leave
- No attacker control required - happens naturally through protocol operation

**Real-World Scenario:**
If the last validator in a 100-validator set proposes the block that triggers epoch reconfiguration, and 2 validators leave (reducing set to 98), the proposer_index of 99 would fail to find a match in the new map with indices 0-97.

## Recommendation
Implement strict validation before recording fees:

1. **Validate indices exist before recording:**
```move
// In stake::record_fee, before the loop:
while (i < num_validators_to_distribute) {
    let validator_index = fee_distribution_validator_indices[i];
    // Add validation:
    assert!(
        pending_fee_by_validator.contains(&validator_index),
        error::invalid_argument(EINVALID_VALIDATOR_INDEX)
    );
    // ... rest of logic
}
```

2. **Fail block execution on epilogue errors:**
Change error handling in `process_block_epilogue` to return an error status instead of success when epilogue fails, forcing block rejection rather than silent fee loss.

3. **Add monitoring:**
Emit events when fee distribution fails to enable detection and analysis.

## Proof of Concept
The vulnerability can be demonstrated by creating a test scenario where:
1. Set up epoch with N validators
2. Create block that will trigger epoch transition
3. Configure validator set change removing validators
4. Execute block and verify epilogue fails but block is kept
5. Verify fees are not distributed

The exact PoC would require setting up a test harness that can control epoch transitions and validator set membership, which requires integration with the Aptos testing framework.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L827-829)
```rust
        let proposer_index = block
            .author()
            .and_then(|proposer| validator.iter().position(|&v| v == proposer));
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L213-217)
```text
        let epoch_interval = block_prologue_common(&vm, hash, epoch, round, proposer, failed_proposer_indices, previous_block_votes_bitvec, timestamp);
        randomness::on_new_block(&vm, epoch, round, option::none());
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L249-255)
```text
    fun block_epilogue(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) {
        stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L616-635)
```text
    public(friend) fun record_fee(
        vm: &signer,
        fee_distribution_validator_indices: vector<u64>,
        fee_amounts_octa: vector<u64>,
    ) acquires PendingTransactionFee {
        // Operational constraint: can only be invoked by the VM.
        system_addresses::assert_vm(vm);

        assert!(fee_distribution_validator_indices.length() == fee_amounts_octa.length());

        let num_validators_to_distribute = fee_distribution_validator_indices.length();
        let pending_fee = borrow_global_mut<PendingTransactionFee>(@aptos_framework);
        let i = 0;
        while (i < num_validators_to_distribute) {
            let validator_index = fee_distribution_validator_indices[i];
            let fee_octa = fee_amounts_octa[i];
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
            i = i + 1;
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1424-1428)
```text
        }) {
            let validator_info = vector::borrow_mut(&mut validator_set.active_validators, validator_index);
            validator_info.config.validator_index = validator_index;
            let validator_config = borrow_global_mut<ValidatorConfig>(validator_info.addr);
            validator_config.validator_index = validator_index;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-601)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2611-2617)
```rust
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```
