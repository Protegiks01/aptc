# Audit Report

## Title
Unbounded Dealer Count in DKG Transcript Verification Enables Computational DoS Attack

## Summary
A malicious validator can submit a DKG transcript with an excessive number of dealer proofs (up to the full validator set size), forcing all validators to perform expensive multi-exponentiation operations during verification without any early bounds checking, causing computational resource exhaustion and validator slowdowns.

## Finding Description

The DKG (Distributed Key Generation) transcript verification flow contains a computational DoS vulnerability where the number of dealers (and their associated Schnorr proofs) is not validated before performing expensive cryptographic operations.

**Attack Flow:**

1. During DKG, validators generate individual transcripts and aggregate them to reach quorum (typically 2/3+1 of validators).

2. A malicious validator collects transcripts from ALL validators in the network (not just quorum) and aggregates them using the `aggregate_with` function, which unconditionally appends all dealer proofs without size limits. [1](#0-0) 

3. The attacker submits this maximally-aggregated transcript as a DKG validator transaction to their local validator transaction pool. When the malicious validator becomes a block proposer, this transcript is included in their proposed block.

4. When other validators receive and process the proposal containing this transaction, consensus verification calls `vtxn.verify()` [2](#0-1)  which performs voting power checks [3](#0-2)  but only validates that the aggregated power meets or exceeds quorum threshold, not that it's within reasonable bounds. The voting power check only ensures `aggregated_voting_power >= target`, allowing transcripts with all validators to pass. [4](#0-3) 

5. Subsequently, during block execution, the VM calls `DefaultDKG::verify_transcript` without any check on the number of dealers. [5](#0-4) 

6. The verification function only validates that dealer indices are valid (within validator set bounds), but does NOT check if the number of dealers is reasonable or exceeds what's necessary for quorum. [6](#0-5) 

7. The verification proceeds to the underlying PVSS transcript verification, which calls `batch_verify_soks` to extract and verify all proof-of-knowledge elements. [7](#0-6) 

8. The `batch_verify_soks` function calls `pok_batch_verify` with all dealer proofs. [8](#0-7) 

9. The `pok_batch_verify` function allocates vectors with capacity `2*n+1` and performs multi-exponentiation with all `2*n+1` bases, where `n` is the number of dealer proofs. [9](#0-8) [10](#0-9) 

**The Critical Vulnerability:**

For a network with 500 validators:
- **Normal case**: ~334 dealers (2/3 quorum) = 669 multi-exponentiations
- **Attack case**: 500 dealers (all validators) = 1,001 multi-exponentiations  
- **Overhead**: ~50% additional computation per validator

The multi-exponentiation operation on BLS12-381 elliptic curve points is computationally expensive (O(n) group operations with logarithmic factors). Forcing this on ALL validators synchronously during block verification can cause:
- Increased block processing latency
- CPU resource exhaustion
- Delayed consensus progress
- Potential timeout failures in block verification

**Why This Breaks Security Invariants:**

This violates the Resource Limits security invariant: "All operations must respect gas, storage, and computational limits." The verification performs unbounded computation proportional to the number of dealers without checking if it exceeds reasonable limits before executing the expensive cryptographic operations.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: The attack directly causes increased computational load on all validator nodes through resource exhaustion. While "Validator node slowdowns" is typically categorized as High severity, this specific case warrants Medium severity due to:
   - The computational overhead (~50%) is significant but not catastrophic
   - The base case already involves expensive operations, limiting the delta
   - Attack can only occur when the malicious validator becomes proposer during DKG phase (periodic but not constant)
   - Only affects epoch transitions, not regular block processing

2. **Network-Wide Impact**: Every validator must verify the malicious transcript when processing the block, affecting the entire network synchronously during that block's execution.

3. **Repeatable Attack**: The attacker can include such transcripts in blocks they propose across different epochs when DKG is active, sustaining the DoS effect over time.

**Severity Justification:**
- Not Critical: Does not cause fund loss, consensus violations, network halts, or permanent damage
- Not High: Does not cause crashes, permanent degradation, or API failures; limited to epoch transition periods
- Medium: Causes computational resource exhaustion with temporary but significant performance impact that can be repeated periodically

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Must be a validator in the current epoch (achievable through staking - open participation)
- Must collect transcripts from all validators during DKG (publicly available through network gossip)
- Must wait to become block proposer during DKG phase (happens periodically through leader election)

**Execution Complexity:**
- Low technical complexity - simply continue aggregating legitimate transcripts beyond quorum
- No cryptographic attacks or signature forgery required
- Can be automated and repeated in every epoch where the attacker is a validator and DKG is active

**Detection Difficulty:**
- The malicious transcript contains valid signatures and proofs from real validators
- Appears cryptographically legitimate and passes all existing validation checks
- No mechanism exists to distinguish "excessive but valid" from "optimal" transcript sizes
- Computational cost is only incurred after full verification begins

**Practical Feasibility:**
- An adversarial validator can execute this attack each time they become proposer during DKG
- The cost to the attacker is minimal (offline aggregation overhead)
- The cost to all other validators is substantial (synchronous verification overhead)
- Attack can be sustained across multiple epochs

## Recommendation

Implement upper bound validation on the number of dealers before performing expensive cryptographic operations:

1. **Early Validation**: Add a check in `verify_transcript_extra()` to ensure the number of dealers doesn't significantly exceed the quorum threshold (e.g., quorum + reasonable buffer).

2. **Size Validation**: Before calling expensive operations like `batch_verify_soks`, validate that the number of dealer proofs is within acceptable bounds.

3. **Recommended Fix**: Add validation after line 320 in `types/src/dkg/real_dkg/mod.rs`:
```rust
// After voting power check, also validate dealer count
let dealer_count = dealer_set.len();
let max_reasonable_dealers = (num_validators * 3 / 4) + 10; // Quorum + buffer
ensure!(
    dealer_count <= max_reasonable_dealers,
    "Excessive number of dealers: {} exceeds maximum {}",
    dealer_count,
    max_reasonable_dealers
);
```

This ensures that transcripts with unnecessarily large numbers of dealers are rejected early, before expensive cryptographic verification begins.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with multiple validators
2. During DKG, having one validator aggregate transcripts from ALL validators instead of stopping at quorum
3. Having that validator become proposer and include the over-aggregated transcript
4. Observing the increased verification time on other validators compared to a normal quorum-sized transcript
5. Measuring the computational overhead (approximately 50% more multi-exponentiations for a full validator set vs. quorum)

The code evidence provided above demonstrates that no validation prevents this attack, and the execution path through consensus verification → VM verification → PVSS batch verification is clearly traced.

## Notes

This is a **logic vulnerability** in the DKG transcript validation flow. The system correctly verifies that dealer signatures are valid and voting power meets quorum, but fails to check if the number of dealers is reasonable before performing expensive cryptographic operations. This creates an opportunity for computational resource exhaustion attacks by malicious validators.

The vulnerability is protocol-level (not network infrastructure), making it in-scope for the bug bounty program. While it requires validator access, validators are considered untrusted actors in the threat model, and the attack requires only standard validator capabilities (staking, participating in DKG, becoming proposer).

### Citations

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L256-263)
```rust
        batch_verify_soks::<G2Projective, A>(
            self.soks.as_slice(),
            &g_2,
            &self.V[sc.n],
            spks,
            auxs,
            &extra[0],
        )?;
```

**File:** crates/aptos-dkg/src/pvss/das/unweighted_protocol.rs (L336-338)
```rust
        for sok in &other.soks {
            self.soks.push(sok.clone());
        }
```

**File:** consensus/src/round_manager.rs (L1134-1135)
```rust
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/validator_verifier.rs (L473-478)
```rust
        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L344-347)
```rust
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L76-76)
```rust
    schnorr::pok_batch_verify::<Gr>(&poks, pk_base, &tau)?;
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L77-79)
```rust
    let n = poks.len();
    let mut exps = Vec::with_capacity(2 * n + 1);
    let mut bases = Vec::with_capacity(2 * n + 1);
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L104-104)
```rust
    if Gr::multi_exp_iter(bases.iter(), exps.iter()) != Gr::identity() {
```
