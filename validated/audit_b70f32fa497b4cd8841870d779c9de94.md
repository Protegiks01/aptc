# Audit Report

## Title
Timeout Certificate HQC Validation Bypass in SyncInfo Allows Inconsistent State and Voting Disruption

## Summary
The `SyncInfo::verify()` function fails to validate that the embedded timeout certificate's highest quorum certificate (HQC) round does not exceed the SyncInfo's own HQC round, allowing nodes to accept and propagate inconsistent consensus state that can disrupt voting and cause liveness issues.

## Finding Description

The AptosBFT consensus protocol uses `SyncInfo` messages to synchronize state between validators. When a `SyncInfo` contains a `TwoChainTimeoutCertificate`, the certificate includes an embedded `QuorumCert` representing the highest QC known to 2f+1 validators at timeout. [1](#0-0) [2](#0-1) 

The `SyncInfo::verify()` function validates epoch consistency, round ordering, and certificate signatures, but critically **does not validate that the timeout certificate's embedded HQC round is not newer than the SyncInfo's own `highest_quorum_cert` round**. [3](#0-2) 

This creates a semantic inconsistency: the SyncInfo claims the highest certified round is R, while the embedded TC proves that 2f+1 validators certified round R' > R.

In stark contrast, both `VoteMsg` and `RoundTimeoutMsg` properly enforce this constraint with explicit checks: [4](#0-3) [5](#0-4) 

However, `ProposalMsg` verification does not enforce this constraint, only verifying the TC signatures and postponing SyncInfo verification. [6](#0-5) 

The vulnerable flow occurs during sync operations where `sync_up()` verifies the SyncInfo and then calls `add_certs()` to process certificates: [7](#0-6) 

When `add_certs()` processes the SyncInfo, it inserts the timeout certificate without extracting or validating its embedded HQC against the SyncInfo's HQC: [8](#0-7) [9](#0-8) 

This creates an inconsistent state where the node's `highest_quorum_cert` is at round R, but `highest_2chain_timeout_cert` contains an embedded HQC at round R' > R.

**Attack Scenario:**
1. Validators V1, V2, V3 time out at round 11 with HQCs at rounds 10, 12, and 11 respectively
2. Aggregated TC is formed for round 11 with embedded HQC at round 12 (the maximum among signers)
3. Validator V1 (or a Byzantine node) sends a `SyncInfo` with:
   - `highest_quorum_cert`: QC at round 10
   - `highest_2chain_timeout_cert`: TC at round 11 with embedded HQC at round 12
4. Honest nodes accept this SyncInfo through `verify()` without detecting the inconsistency
5. The safety rules subsequently use the TC's inflated HQC round for voting decisions, while the node's actual highest QC is lower: [10](#0-9) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria, causing significant protocol violations:

1. **State Inconsistency**: Nodes maintain contradictory views where their `highest_quorum_cert` differs from the QC proven by their `highest_2chain_timeout_cert`, violating fundamental consensus state consistency invariants.

2. **Liveness Disruption**: The inconsistent state can cause validators to make incorrect voting decisions based on the TC's inflated HQC round while their actual highest QC is lower, potentially stalling consensus progression.

3. **Consensus Protocol Violation**: The discrepancy between what VoteMsg/RoundTimeoutMsg enforce versus what SyncInfo allows reveals a broken invariant in the protocol's consistency guarantees.

4. **Network-Wide Propagation**: A single malformed SyncInfo can propagate through the network via proposals and sync messages, affecting multiple validators simultaneously.

The vulnerability does not lead to safety violations (double-spending or chain splits) because cryptographic verification prevents forged TCs, but it significantly impacts availability and protocol correctness.

## Likelihood Explanation

**Likelihood: High**

This vulnerability can be triggered in multiple ways:

1. **Benign Network Asynchrony**: Legitimately occurs when validators have different views due to network delays. A validator may receive and participate in creating a TC with a higher HQC than its own, then send a SyncInfo reflecting this inconsistency.

2. **Malicious Exploitation**: A Byzantine node can deliberately construct and broadcast SyncInfo messages with this inconsistency to disrupt honest validators.

3. **Ease of Exploitation**: No special privileges required - any network participant can send SyncInfo through proposals or direct sync messages.

4. **Detection Difficulty**: The inconsistency is not caught by existing validation, making it propagate silently until operational issues manifest.

## Recommendation

Add the missing validation check in `SyncInfo::verify()` to enforce the invariant that a timeout certificate's embedded HQC round must not exceed the SyncInfo's highest certified round:

```rust
// In SyncInfo::verify() after line 150
if let Some(tc) = &self.highest_2chain_timeout_cert {
    ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
    // Add this check:
    ensure!(
        tc.highest_hqc_round() <= self.highest_quorum_cert.certified_block().round(),
        "Timeout certificate HQC round {} exceeds SyncInfo HQC round {}",
        tc.highest_hqc_round(),
        self.highest_quorum_cert.certified_block().round()
    );
}
```

This brings SyncInfo validation into consistency with VoteMsg and RoundTimeoutMsg, ensuring the protocol invariant is enforced at all entry points.

## Proof of Concept

The vulnerability can be demonstrated by constructing a test case where:
1. Create a SyncInfo with `highest_quorum_cert` at round 10
2. Create a `TwoChainTimeoutCertificate` at round 11 with embedded HQC at round 12
3. Verify that `SyncInfo::verify()` accepts this inconsistent state
4. Confirm that the same inconsistency would be rejected by `VoteMsg::verify()` and `RoundTimeoutMsg::verify()`

The existing code structure makes this trivially reproducible by examining the different validation paths in the three message types.

## Notes

The presence of this check in VoteMsg and RoundTimeoutMsg but not in SyncInfo represents a clear inconsistency in the protocol's validation strategy. The fact that two message types enforce this invariant while SyncInfo does not suggests this was an oversight rather than an intentional design decision. The vulnerability is particularly concerning because SyncInfo is used in critical synchronization paths where state consistency is paramount.

### Citations

**File:** consensus/consensus-types/src/sync_info.rs (L16-25)
```rust
pub struct SyncInfo {
    /// Highest quorum certificate known to the peer.
    highest_quorum_cert: QuorumCert,
    /// Highest ordered cert known to the peer.
    highest_ordered_cert: Option<WrappedLedgerInfo>,
    /// Highest commit cert (ordered cert with execution result) known to the peer.
    highest_commit_cert: WrappedLedgerInfo,
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L138-212)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let epoch = self.highest_quorum_cert.certified_block().epoch();
        ensure!(
            epoch == self.highest_ordered_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HQC"
        );
        ensure!(
            epoch == self.highest_commit_cert().commit_info().epoch(),
            "Multi epoch in SyncInfo - HOC and HCC"
        );
        if let Some(tc) = &self.highest_2chain_timeout_cert {
            ensure!(epoch == tc.epoch(), "Multi epoch in SyncInfo - TC and HQC");
        }

        ensure!(
            self.highest_quorum_cert.certified_block().round()
                >= self.highest_ordered_cert().commit_info().round(),
            "HQC has lower round than HOC"
        );

        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );

        ensure!(
            *self.highest_ordered_cert().commit_info() != BlockInfo::empty(),
            "HOC has no committed block"
        );

        ensure!(
            *self.highest_commit_cert().commit_info() != BlockInfo::empty(),
            "HLI has empty commit info"
        );

        // we don't have execution in unit tests, so this check would fail
        #[cfg(not(any(test, feature = "fuzzing")))]
        {
            ensure!(
                !self.highest_commit_cert().commit_info().is_ordered_only(),
                "HLI {} has ordered only commit info",
                self.highest_commit_cert().commit_info()
            );
        }

        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L24-32)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TwoChainTimeout {
    /// Epoch number corresponds to the set of validators that are active for this round.
    epoch: u64,
    /// The consensus protocol executes proposals (blocks) in rounds, which monotonically increase per epoch.
    round: Round,
    /// The highest quorum cert the signer has seen.
    quorum_cert: QuorumCert,
}
```

**File:** consensus/consensus-types/src/vote_msg.rs (L71-76)
```rust
        if let Some((timeout, _)) = self.vote().two_chain_timeout() {
            ensure!(
                timeout.hqc_round() <= self.sync_info.highest_certified_round(),
                "2-chain Timeout hqc should be less or equal than the sync info hqc"
            );
        }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L162-166)
```rust
        ensure!(
            self.round_timeout.two_chain_timeout().hqc_round()
                <= self.sync_info.highest_certified_round(),
            "2-chain Timeout hqc should be less or equal than the sync info hqc"
        );
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L113-118)
```rust
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/src/round_manager.rs (L878-906)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L169-171)
```rust
        if let Some(tc) = sync_info.highest_2chain_timeout_cert() {
            self.insert_2chain_timeout_certificate(Arc::new(tc.clone()))?;
        }
```

**File:** consensus/src/block_storage/block_store.rs (L560-575)
```rust
    pub fn insert_2chain_timeout_certificate(
        &self,
        tc: Arc<TwoChainTimeoutCertificate>,
    ) -> anyhow::Result<()> {
        let cur_tc_round = self
            .highest_2chain_timeout_cert()
            .map_or(0, |tc| tc.round());
        if tc.round() <= cur_tc_round {
            return Ok(());
        }
        self.storage
            .save_highest_2chain_timeout_cert(tc.as_ref())
            .context("Timeout certificate insert failed when persisting to DB")?;
        self.inner.write().replace_2chain_timeout_cert(tc);
        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L150-166)
```rust
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
