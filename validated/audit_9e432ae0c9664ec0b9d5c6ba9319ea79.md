# Audit Report

## Title
Unmetered Memory Allocation in BCS Native Function Enables Validator Node Memory Exhaustion

## Summary
The `native_to_bytes()` function in the BCS (Binary Canonical Serialization) native implementation performs an unmetered deep copy of values via `read_ref()`, bypassing the memory quota system designed to prevent out-of-memory attacks. This allows attackers to cause validator node memory exhaustion and potential crashes.

## Finding Description

The vulnerability exists in the BCS serialization native function implementation. When Move code calls `bcs::to_bytes<T>(&T)`, it invokes the Rust native function `native_to_bytes()` which performs an unmetered deep copy of the referenced value. [1](#0-0) 

The `read_ref()` operation creates a complete duplicate of the value by recursively calling `copy_value()` on all containers and nested structures: [2](#0-1) [3](#0-2) 

The deep copy recursively duplicates all container values without any memory quota checking: [4](#0-3) 

Gas and memory charging only occurs AFTER serialization completes, based on the serialized output size: [5](#0-4) 

In contrast, other native functions properly charge for heap memory usage BEFORE allocating. For example, the table natives call `context.use_heap_memory()`: [6](#0-5) [7](#0-6) 

The memory quota system is designed to prevent OOM attacks with a default limit of 10,000,000 abstract value size units: [8](#0-7) 

The memory tracking system enforces this quota by returning `MEMORY_LIMIT_EXCEEDED` errors when the limit is exceeded: [9](#0-8) 

However, the BCS native function bypasses this protection entirely. The TODO comment indicates developers are aware of the deep copy inefficiency but may not recognize the security implications: [10](#0-9) 

**Attack Flow:**
1. Attacker creates a large value near the memory quota limit using normal Move operations (properly tracked)
2. Attacker calls `bcs::to_bytes(&large_value)` in a transaction
3. The `read_ref()` operation performs an unmetered deep copy, allocating a complete duplicate
4. Real memory consumption spikes to 2-3x the tracked quota (original + copy + serialization buffer)
5. Multiple concurrent transactions amplify the effect across all validator nodes
6. Validator nodes experience memory pressure, performance degradation, or OOM crashes

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

- **Validator node slowdowns (High)**: Large unmetered allocations cause memory pressure and performance degradation affecting consensus participation
- **API crashes (High)**: Out-of-memory conditions can crash validator node processes, affecting network availability

The impact is amplified because:
- Multiple transactions can execute concurrently, multiplying untracked memory consumption
- Nested structures (vectors of structs containing vectors) can create large allocations while staying within depth limits
- All validator nodes processing the same transaction experience identical memory pressure, creating network-wide liveness issues
- The memory quota system (10,000,000 abstract units) is a fundamental security control being bypassed

This does not reach Critical severity because:
- No consensus safety violation (all nodes behave identically)
- No direct fund loss or theft
- Network can recover after node restarts
- Not a permanent network partition

## Likelihood Explanation

**Likelihood: HIGH**

The attack is straightforward to execute:
- No special privileges requiredâ€”any transaction sender can call `bcs::to_bytes()`
- The function is part of the standard library and commonly used
- Attackers can construct large values within memory quota limits using normal Move operations
- The exploit is deterministic and repeatable
- Economic cost is limited to normal transaction gas fees

Factors increasing likelihood:
- The TODO comment indicates developers recognize the inefficiency as a performance issue but not a security vulnerability
- The same vulnerability pattern exists in both `native_to_bytes()` and `serialized_size_impl()` functions
- No runtime protections prevent this attack vector
- Multiple transactions can be submitted concurrently to amplify the effect

## Recommendation

Add memory quota charging before the deep copy operation in `native_to_bytes()` and `serialized_size_impl()`:

```rust
fn native_to_bytes(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ... existing code ...
    
    let ref_to_val = safely_pop_arg!(args, Reference);
    
    // Calculate the heap size of the value before copying
    let heap_size = context
        .vm_gas_params()
        .misc
        .abs_val
        .abstract_heap_size(&ref_to_val, context.feature_version())?;
    
    // Charge for the deep copy BEFORE allocating
    context.use_heap_memory(u64::from(heap_size))?;
    
    let val = ref_to_val.read_ref()?;
    
    // ... continue with serialization ...
}
```

Alternatively, implement a more efficient zero-copy serialization path that doesn't require deep copying the value.

## Proof of Concept

```move
script {
    use std::bcs;
    use std::vector;
    
    fun exploit_memory_exhaustion() {
        // Create a large vector near the memory quota limit
        let large_vector = vector::empty<u128>();
        let i = 0;
        while (i < 500000) {
            vector::push_back(&mut large_vector, 0u128);
            i = i + 1;
        };
        
        // This call will perform an unmetered deep copy
        // Real memory usage spikes to ~2x the quota-tracked amount
        let _serialized = bcs::to_bytes(&large_vector);
        
        // Submit multiple such transactions concurrently to amplify
        // the memory pressure on validator nodes
    }
}
```

When multiple transactions execute this pattern concurrently, validator nodes will experience memory pressure beyond what the quota system tracks, potentially leading to OOM conditions or severe performance degradation.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L91-93)
```rust
    // TODO(#14175): Reading the reference performs a deep copy, and we can
    //               implement it in a more efficient way.
    let val = ref_to_val.read_ref()?;
```

**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L110-111)
```rust
    context
        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L629-669)
```rust
    fn copy_value(&self, depth: u64, max_depth: Option<u64>) -> PartialVMResult<Self> {
        fn copy_rc_ref_vec_val(
            r: &Rc<RefCell<Vec<Value>>>,
            depth: u64,
            max_depth: Option<u64>,
        ) -> PartialVMResult<Rc<RefCell<Vec<Value>>>> {
            let vals = r.borrow();
            let mut copied_vals = Vec::with_capacity(vals.len());
            for val in vals.iter() {
                copied_vals.push(val.copy_value(depth + 1, max_depth)?);
            }
            Ok(Rc::new(RefCell::new(copied_vals)))
        }

        Ok(match self {
            Self::Vec(r) => Self::Vec(copy_rc_ref_vec_val(r, depth, max_depth)?),
            Self::Struct(r) => Self::Struct(copy_rc_ref_vec_val(r, depth, max_depth)?),

            Self::VecU8(r) => Self::VecU8(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU16(r) => Self::VecU16(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU32(r) => Self::VecU32(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU64(r) => Self::VecU64(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU128(r) => Self::VecU128(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecU256(r) => Self::VecU256(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI8(r) => Self::VecI8(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI16(r) => Self::VecI16(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI32(r) => Self::VecI32(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI64(r) => Self::VecI64(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI128(r) => Self::VecI128(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecI256(r) => Self::VecI256(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecBool(r) => Self::VecBool(Rc::new(RefCell::new(r.borrow().clone()))),
            Self::VecAddress(r) => Self::VecAddress(Rc::new(RefCell::new(r.borrow().clone()))),

            Self::Locals(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("cannot copy a Locals container".to_string()),
                )
            },
        })
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1552-1556)
```rust
    fn read_ref(self, depth: u64, max_depth: Option<u64>) -> PartialVMResult<Value> {
        Ok(Value::Container(
            self.container().copy_value(depth, max_depth)?,
        ))
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L1614-1616)
```rust
    pub fn read_ref(self) -> PartialVMResult<Value> {
        self.0.read_ref(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L439-441)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L499-501)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L142-142)
```rust
        [memory_quota: AbstractValueSize, { 1.. => "memory_quota" }, 10_000_000],
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L47-63)
```rust
    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
    }
```
