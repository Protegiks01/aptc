# Audit Report

## Title
Consensus Observer Permanent Liveness Failure Due to Uncleared State Sync Metrics on Error

## Summary
When state synchronization fails in the consensus observer, the `OBSERVER_STATE_SYNC_EXECUTING` gauge metric remains permanently set to 1, and internal sync handles are not cleared. This causes the consensus observer to enter a permanent stuck state where it believes syncing is still in progress, preventing it from processing any new consensus messages until manual node restart.

## Finding Description

The consensus observer uses the `OBSERVER_STATE_SYNC_EXECUTING` gauge metric with two labels (`STATE_SYNCING_FOR_FALLBACK` and `STATE_SYNCING_TO_COMMIT`) to track active state sync operations. [1](#0-0) 

When fallback sync is initiated via `sync_for_fallback()`, the metric is set to 1 and a sync handle is stored. [2](#0-1) [3](#0-2) 

**The critical bug**: When `execution_client.sync_for_duration()` fails, the code logs the error and returns early without clearing the metric that was set. [4](#0-3)  The metric reset code at lines 175-180 is never reached, leaving the gauge permanently at 1.

The same bug exists in `sync_to_commit()`: when `execution_client.sync_to_target()` fails, the metric is set to 1 but never cleared on error. [5](#0-4) 

This creates three compounding problems:

1. **Metric permanently stuck**: The gauge remains at 1 even though no sync is running, hiding the failure from operators monitoring the system.

2. **Handles never cleared**: The `fallback_sync_handle` and `sync_to_commit_handle` are set before spawning the async task. [6](#0-5)  When the async task fails, these handles remain `Some(_)`, so `in_fallback_mode()` and `is_syncing_to_commit()` return true indefinitely. [7](#0-6) 

3. **Permanent liveness failure**: The `check_progress()` method checks these flags and returns early when true, believing sync is in progress. [8](#0-7)  This prevents the observer from executing its recovery logic (lines 191-213), causing it to wait forever for a sync that has already failed.

The handles are only cleared when processing successful sync notifications, which are never sent when the async task fails. [9](#0-8) [10](#0-9) 

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring manual intervention":

1. **Permanent liveness failure for observer nodes**: The consensus observer stops processing all consensus messages and cannot recover without manual restart.

2. **State inconsistency**: The node's internal state is inconsistent - the manager believes sync is ongoing, but no sync task is actually running.

3. **Hidden failures**: Failed state sync attempts are completely hidden from operators because the metric incorrectly shows syncing is "in progress".

4. **No automatic recovery mechanism**: The automatic recovery logic in `check_progress()` is permanently blocked from executing.

5. **Operational impact**: While consensus observers are fullnodes (not validators) and don't participate in consensus voting, they are critical infrastructure for network monitoring, APIs, and observability. Multiple stuck observer nodes would degrade operational capabilities.

The impact is limited to Medium severity (rather than Critical/High) because:
- Only affects consensus observer nodes (fullnodes/VFNs/PFNs), not validators
- Does not impact the consensus protocol itself
- Does not cause loss of funds or network-wide availability issues
- Can be recovered through manual restart (temporary liveness issue)

## Likelihood Explanation

**High likelihood** - This bug can be triggered naturally through common operational failures:

1. **Network failures**: Temporary network issues during state sync causing `sync_for_duration()` or `sync_to_target()` to fail
2. **Database errors**: Storage layer issues preventing successful synchronization
3. **Resource exhaustion**: Memory or disk pressure causing sync operations to fail
4. **Execution client errors**: Any error condition in the execution client during sync

No attacker action is required - this is a reliability bug that manifests during normal operational failures, making it highly likely to occur in production environments.

## Recommendation

Add proper error handling to clear metrics and handles when state sync fails:

**For `sync_for_fallback()`**: Wrap the sync logic in a deferred cleanup that ensures the metric is cleared and notification is sent regardless of success or failure:

```rust
tokio::spawn(Abortable::new(
    async move {
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_STATE_SYNC_EXECUTING,
            metrics::STATE_SYNCING_FOR_FALLBACK,
            1,
        );
        
        let result = execution_client
            .clone()
            .sync_for_duration(fallback_duration)
            .await;
            
        // Always clear the metric
        metrics::set_gauge_with_label(
            &metrics::OBSERVER_STATE_SYNC_EXECUTING,
            metrics::STATE_SYNCING_FOR_FALLBACK,
            0,
        );
        
        match result {
            Ok(latest_synced_ledger_info) => {
                // Send success notification
                let _ = sync_notification_sender.send(
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info)
                );
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::ConsensusObserver)
                    .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                // Send failure notification or clear handle via separate mechanism
            },
        }
    },
    abort_registration,
));
```

Apply the same fix to `sync_to_commit()`. Alternatively, use Rust's `Drop` trait or a guard pattern to ensure cleanup always occurs.

## Proof of Concept

This can be reproduced by simulating execution client failures in the consensus observer test suite:

```rust
#[tokio::test]
async fn test_sync_failure_clears_state() {
    use crate::pipeline::execution_client::TExecutionClient;
    use async_trait::async_trait;
    
    // Mock execution client that always fails
    struct FailingExecutionClient;
    
    #[async_trait]
    impl TExecutionClient for FailingExecutionClient {
        async fn sync_for_duration(&self, _duration: Duration) 
            -> anyhow::Result<LedgerInfoWithSignatures> {
            Err(anyhow::anyhow!("Simulated sync failure"))
        }
        
        async fn sync_to_target(&self, _target: LedgerInfoWithSignatures) 
            -> anyhow::Result<()> {
            Err(anyhow::anyhow!("Simulated sync failure"))
        }
        // ... other required trait methods
    }
    
    let consensus_observer_config = ConsensusObserverConfig::default();
    let (state_sync_notification_sender, _rx) = tokio::sync::mpsc::unbounded_channel();
    let mut state_sync_manager = StateSyncManager::new(
        consensus_observer_config,
        Arc::new(FailingExecutionClient),
        state_sync_notification_sender,
    );
    
    // Trigger fallback sync
    state_sync_manager.sync_for_fallback();
    
    // Wait for async task to complete
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // BUG: Even though sync failed, the handle is still set
    assert!(state_sync_manager.in_fallback_mode()); // This should be false but is true
    
    // BUG: Metric is still at 1 (would need to check the actual metric)
}
```

The test demonstrates that after sync failure, `in_fallback_mode()` incorrectly returns true, blocking the consensus observer from making progress.

## Notes

This vulnerability is specific to the consensus observer component used by fullnodes for tracking consensus without participating in voting. The bug does not affect validators or the core consensus protocol. The severity is appropriate for Medium classification as it requires manual intervention but has limited blast radius compared to validator-affecting issues.

### Citations

**File:** consensus/src/consensus_observer/common/metrics.rs (L181-188)
```rust
pub static OBSERVER_STATE_SYNC_EXECUTING: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "consensus_observer_state_sync_executing",
        "Gauge for tracking when consensus observer has invoked state sync",
        &["syncing_mode"]
    )
    .unwrap()
});
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L54-60)
```rust
    // we've fallen back to state sync, and we should wait for it to complete.
    fallback_sync_handle: Option<DropGuard>,

    // The active sync to commit handle. If this is set, it means that
    // we're waiting for state sync to synchronize to a known commit decision.
    // The flag indicates if the commit will transition us to a new epoch.
    sync_to_commit_handle: Option<(DropGuard, bool)>,
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L100-114)
```rust
    /// Returns true iff state sync is currently executing in fallback mode
    pub fn in_fallback_mode(&self) -> bool {
        self.fallback_sync_handle.is_some()
    }

    /// Returns true iff we are waiting for state sync to synchronize
    /// to a commit decision that will transition us to a new epoch
    pub fn is_syncing_through_epoch(&self) -> bool {
        matches!(self.sync_to_commit_handle, Some((_, true)))
    }

    /// Returns true iff state sync is currently syncing to a commit decision
    pub fn is_syncing_to_commit(&self) -> bool {
        self.sync_to_commit_handle.is_some()
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L139-143)
```rust
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L150-160)
```rust
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L186-186)
```rust
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L211-230)
```rust
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L173-188)
```rust
        if self.state_sync_manager.in_fallback_mode() {
            info!(LogSchema::new(LogEntry::ConsensusObserver)
                .message("Waiting for state sync to complete fallback syncing!",));
            return;
        }

        // If state sync is syncing to a commit decision, we should wait for it to complete
        if self.state_sync_manager.is_syncing_to_commit() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Waiting for state sync to reach commit decision: {:?}!",
                    self.observer_block_data.lock().root().commit_info()
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L964-964)
```rust
        self.state_sync_manager.clear_active_fallback_sync();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1048-1048)
```rust
        self.state_sync_manager.clear_active_commit_sync();
```
