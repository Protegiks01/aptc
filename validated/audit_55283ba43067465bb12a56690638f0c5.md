# Audit Report

## Title
Byzantine Validator Can Prevent Batch Retrieval via Stale LedgerInfo Injection in Quorum Store

## Summary
A Byzantine validator can prevent honest nodes from retrieving available batches by responding with `BatchResponse::NotFound` containing an old but valid `LedgerInfoWithSignatures`. The requester validates only the epoch, timestamp, and cryptographic signatures, but does not verify freshness or require consensus from multiple validators. This causes immediate request termination without waiting for responses from honest validators, resulting in a liveness attack that breaks Byzantine fault tolerance guarantees.

## Finding Description
The vulnerability exists in the batch request handling logic of the Quorum Store consensus component. When a node requests a batch, it sends requests to multiple validators and processes responses as they arrive using a `FuturesUnordered` collection. [1](#0-0) 

The critical flaw occurs when processing `BatchResponse::NotFound` responses. The validation performs only three checks: [2](#0-1) 

Critically, the code does NOT verify:
- That the ledger info is the LATEST one
- That multiple validators agree on batch unavailability  
- That the responding validator actually checked local storage

When these minimal checks pass, the requester immediately returns an error and abandons the entire request, even if honest validators have the batch and would respond successfully.

**Attack Mechanism:**

The honest implementation retrieves the latest ledger info when a batch is not found: [3](#0-2) 

However, a Byzantine validator can:
1. Store old `LedgerInfoWithSignatures` from earlier in the same epoch
2. When requested for a batch it possesses, lie by sending `BatchResponse::NotFound(old_ledger_info)`
3. Use an old ledger info where `old_ledger_info.timestamp > batch.expiration`
4. The requester validates the old ledger info and immediately terminates
5. Honest validators' responses are never awaited

**Why This Works:**

Batches are created with expiration timestamps (60 seconds by default): [4](#0-3) 

Batches remain in storage for an additional buffer period (60 seconds) after expiration: [5](#0-4) 

**Attack Timeline:**
1. T1: Batch B created with expiration = T1 + 60s
2. T2 (T1+65s): Ledger info L2 committed with timestamp T2
3. T3 (T1+70s): Current latest ledger info L3 committed
4. T4 (T1+75s): Requester asks for batch B
5. Byzantine validator has batch B (not yet garbage collected) but sends `NotFound(L2)`
6. Requester validates L2 (epoch matches, T2 > T1+60s, signatures valid)
7. Requester immediately errors out without waiting for honest validators

The signature verification only confirms cryptographic validity, not freshness: [6](#0-5) 

## Impact Explanation
This is a **High Severity** liveness attack per the Aptos bug bounty categories:

**Validator Node Slowdowns (High)**: Affected nodes cannot retrieve batches needed for consensus execution, causing them to fall behind and degrading network performance.

**Significant Protocol Violation**: This breaks Byzantine fault tolerance guarantees. A single Byzantine validator (< 1/3 threshold) can cause denial of service for batch retrieval, violating the fundamental assumption that < 1/3 Byzantine actors should not prevent progress.

**Consensus Impact**: Prevents block execution on affected nodes. If multiple nodes are targeted simultaneously, it can cause network-wide slowdowns or stalls.

While cryptographic forgery is impossible (cannot create fake signatures), the attack achieves the same denial-of-service goal using old but valid ledger infos from earlier in the same epoch.

## Likelihood Explanation
**High Likelihood:**
- Any validator in the active set can execute this attack
- No sophisticated exploit required - simply respond with stored old ledger info
- Attacker only needs to store previous `LedgerInfoWithSignatures` from the same epoch
- Works whenever batch expiration < old_ledger_timestamp < current_ledger_timestamp (a regular occurrence during normal operations)
- No detection mechanism exists - appears as legitimate NotFound response
- Single Byzantine validator sufficient (no collusion needed)
- Can target specific nodes or all requesters

## Recommendation
Implement freshness verification and quorum requirements for NotFound responses:

1. **Add freshness check**: Compare the ledger info timestamp against the requester's local latest ledger info or require a minimum recency threshold
2. **Require quorum consensus**: Don't terminate on single NotFound response; wait for multiple validators to agree before concluding a batch is expired
3. **Version tracking**: Track ledger info versions and reject responses with stale versions
4. **Timeout-based approach**: Instead of immediate termination, continue waiting for other responses until timeout, giving honest validators opportunity to respond with the batch

Example fix for batch_requester.rs:
```rust
Ok(BatchResponse::NotFound(ledger_info)) => {
    counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
    if ledger_info.commit_info().epoch() == epoch
        && ledger_info.commit_info().timestamp_usecs() > expiration
        && ledger_info.verify_signatures(&validator_verifier).is_ok()
    {
        // Instead of immediate return, track NotFound votes
        // Only terminate after receiving quorum of NotFound responses
        // OR after comparing against local latest ledger info for freshness
        not_found_votes += 1;
        if not_found_votes >= quorum_threshold {
            counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
            debug!("QS: batch request expired after quorum, digest:{}", digest);
            return Err(ExecutorError::CouldNotGetData);
        }
        // Continue waiting for other responses
    }
}
```

## Proof of Concept
The attack can be demonstrated through the existing test infrastructure by modifying the MockBatchRequester to return an old but valid LedgerInfoWithSignatures: [7](#0-6) 

The test at lines 234-277 demonstrates that a single NotFound response with valid but old ledger info causes immediate termination (request_duration < retry_interval_ms). This confirms the vulnerability: even if other honest validators have the batch, the requester never waits for their responses.

## Notes
- This vulnerability specifically affects the Quorum Store batch retrieval mechanism in the consensus layer
- The attack exploits the protocol's trust in single validator responses without quorum verification
- The 60-second expiration buffer, intended to help slow nodes catch up, creates a timing window where this attack is particularly effective
- This is NOT a network-level DoS attack but a protocol logic vulnerability that mishandles Byzantine behavior
- The fix requires balancing liveness (not waiting forever for expired batches) with Byzantine fault tolerance (not trusting single validators)

### Citations

**File:** consensus/src/quorum_store/batch_requester.rs (L117-127)
```rust
        monitor!("batch_request", {
            let mut interval = time::interval(retry_interval);
            let mut futures = FuturesUnordered::new();
            let request = BatchRequest::new(my_peer_id, epoch, digest);
            loop {
                tokio::select! {
                    _ = interval.tick() => {
                        // send batch request to a set of peers of size request_num_peers
                        if let Some(request_peers) = request_state.next_request_peers(request_num_peers) {
                            for peer in request_peers {
                                futures.push(network_sender.request_batch(request.clone(), peer, rpc_timeout));
```

**File:** consensus/src/quorum_store/batch_requester.rs (L142-152)
```rust
                            Ok(BatchResponse::NotFound(ledger_info)) => {
                                counters::RECEIVED_BATCH_NOT_FOUND_COUNT.inc();
                                if ledger_info.commit_info().epoch() == epoch
                                    && ledger_info.commit_info().timestamp_usecs() > expiration
                                    && ledger_info.verify_signatures(&validator_verifier).is_ok()
                                {
                                    counters::RECEIVED_BATCH_EXPIRED_COUNT.inc();
                                    debug!("QS: batch request expired, digest:{}", digest);
                                    return Err(ExecutorError::CouldNotGetData);
                                }
                            }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L265-265)
```rust
            Duration::from_secs(60).as_micros() as u64,
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L417-418)
```rust
                    match aptos_db_clone.get_latest_ledger_info() {
                        Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
```

**File:** config/src/config/quorum_store_config.rs (L131-131)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** consensus/src/quorum_store/tests/batch_requester_test.rs (L234-277)
```rust
#[tokio::test]
async fn test_batch_request_not_exists_expired() {
    let retry_interval_ms = 1_000;
    let expiration = 10_000;

    // Batch has expired according to the ledger info that will be returned
    let (ledger_info_with_signatures, validator_verifier) =
        create_ledger_info_with_timestamp(expiration + 1);

    let batch = Batch::new(
        BatchId::new_for_test(1),
        vec![],
        1,
        expiration,
        AccountAddress::random(),
        0,
    );
    let batch_response = BatchResponse::NotFound(ledger_info_with_signatures);
    let batch_requester = BatchRequester::new(
        1,
        AccountAddress::random(),
        1,
        2,
        retry_interval_ms,
        1_000,
        MockBatchRequester::new(batch_response),
        validator_verifier.into(),
    );

    let request_start = Instant::now();
    let (_, subscriber_rx) = oneshot::channel();
    let result = batch_requester
        .request_batch(
            *batch.digest(),
            batch.expiration(),
            Arc::new(Mutex::new(btreeset![AccountAddress::random()])),
            subscriber_rx,
        )
        .await;
    let request_duration = request_start.elapsed();
    assert_err!(result);
    // No retry because of short-circuiting of expired batch
    assert!(request_duration < Duration::from_millis(retry_interval_ms as u64));
}
```
