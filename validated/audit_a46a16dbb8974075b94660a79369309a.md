# Audit Report

## Title
DAG Consensus Pipeline Latency Tracking Memory Leak Causes Total Liveness Failure After 30 Seconds

## Summary
The DAG consensus implementation fails to clean up the `block_ordered_ts` tracking map, causing all validators to permanently stop voting after 30 seconds of operation within an epoch, resulting in complete consensus halt.

## Finding Description

The `OrderedNotifierAdapter` in DAG consensus maintains a `block_ordered_ts` map that tracks when blocks are ordered for pipeline latency measurement. [1](#0-0) 

This map is used by `pipeline_pending_latency()` to calculate the elapsed time since the oldest ordered block by retrieving the first entry and returning its elapsed time. [2](#0-1) 

When nodes are ordered, entries are inserted into this map with the current timestamp. [3](#0-2) 

However, the cleanup callback that should remove committed blocks from this map is commented out with a TODO note, preventing any entries from ever being removed during the epoch. [4](#0-3) 

The `PipelineLatencyBasedBackpressure` implementation compares this growing latency against `voter_pipeline_latency_limit_ms` (default 30,000ms). [5](#0-4) [6](#0-5) 

When the limit is exceeded, the `stop_voting()` method returns true, causing validators to refuse voting on new blocks. [7](#0-6) 

DAG consensus is enabled via on-chain configuration through `is_dag_enabled()` check in the epoch manager. [8](#0-7) [9](#0-8) 

**Security Guarantee Broken**: This violates the Consensus Liveness invariant. After 30 seconds from the first block ordered in an epoch, ALL validators (honest and Byzantine alike) will hit the latency limit and stop voting, causing complete consensus halt until the next epoch boundary. Since the map is never cleaned up and only grows, the oldest timestamp continuously ages, eventually exceeding the 30-second threshold.

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" category from the Aptos Bug Bounty program. Within 30 seconds of epoch start, the entire DAG consensus network would stop producing blocks. 

While epochs reset the state by creating a new `OrderedNotifierAdapter` instance with an empty `block_ordered_ts` map at each epoch boundary [10](#0-9) , this creates a pattern of 30-second windows of liveness followed by consensus halt for the remaining duration of each epoch (default 2-hour epochs = ~7170 seconds of halt per ~7200 second epoch, or 99.6% downtime).

The graduated pipeline backpressure penalties would also incorrectly trigger at lower thresholds as latency grows, causing progressive degradation before total halt.

## Likelihood Explanation

**Certain** - This bug triggers automatically on all DAG consensus validators. No attacker action is required. The moment the first block is ordered in an epoch, the 30-second countdown begins for all validators simultaneously. This would manifest immediately in any DAG consensus deployment where the feature is enabled via on-chain configuration.

## Recommendation

Uncomment and properly implement the callback mechanism that removes committed blocks from the `block_ordered_ts` map. The callback should retain only rounds greater than the committed round:

```rust
callback: Box::new(
    move |committed_blocks: &[Arc<PipelinedBlock>],
          commit_decision: LedgerInfoWithSignatures| {
        block_ordered_ts
            .write()
            .retain(|&round, _| round > commit_decision.commit_info().round());
        // ... rest of callback logic
    },
)
```

This ensures that once blocks are committed, their tracking entries are cleaned up, preventing the unbounded growth of the latency metric.

## Proof of Concept

The vulnerability is demonstrated through code inspection showing:
1. Insertion of entries without removal mechanism
2. Growing latency calculation from oldest entry
3. Automatic voting refusal when threshold exceeded
4. Integration in critical consensus voting path

A functional test would require:
1. Enabling DAG consensus via on-chain configuration
2. Running for >30 seconds within an epoch
3. Observing voting refusal in `NodeBroadcastHandler` logs
4. Confirming consensus halt across all validators

## Notes

This vulnerability affects the DAG consensus implementation specifically, not the traditional Jolteon consensus. The issue would only manifest when DAG consensus is enabled through on-chain governance configuration. The commented-out cleanup code with TODO indicates this was a known incomplete feature during development, but represents a critical liveness bug if DAG consensus is deployed.

### Citations

**File:** consensus/src/dag/adapter.rs (L101-101)
```rust
    block_ordered_ts: Arc<RwLock<BTreeMap<Round, Instant>>>,
```

**File:** consensus/src/dag/adapter.rs (L125-134)
```rust
    pub(super) fn pipeline_pending_latency(&self) -> Duration {
        match self.block_ordered_ts.read().first_key_value() {
            Some((round, timestamp)) => {
                let latency = timestamp.elapsed();
                info!(round = round, latency = latency, "pipeline pending latency");
                latency
            },
            None => Duration::ZERO,
        }
    }
```

**File:** consensus/src/dag/adapter.rs (L203-205)
```rust
        self.block_ordered_ts
            .write()
            .insert(block_info.round(), Instant::now());
```

**File:** consensus/src/dag/adapter.rs (L215-228)
```rust
            // TODO: this needs to be properly integrated with pipeline_builder
            // callback: Box::new(
            //     move |committed_blocks: &[Arc<PipelinedBlock>],
            //           commit_decision: LedgerInfoWithSignatures| {
            //         block_created_ts
            //             .write()
            //             .retain(|&round, _| round > commit_decision.commit_info().round());
            //         dag.commit_callback(commit_decision.commit_info().round());
            //         ledger_info_provider
            //             .write()
            //             .notify_commit_proof(commit_decision);
            //         update_counters_for_committed_blocks(committed_blocks);
            //     },
            // ),
```

**File:** consensus/src/dag/health/pipeline_health.rs (L77-80)
```rust
    fn stop_voting(&self) -> bool {
        let latency = self.adapter.pipeline_pending_latency();
        latency > self.voter_pipeline_latency_limit
    }
```

**File:** config/src/config/dag_consensus_config.rs (L151-151)
```rust
            voter_pipeline_latency_limit_ms: 30_000,
```

**File:** consensus/src/dag/rb_handler.rs (L219-222)
```rust
        ensure!(
            !self.health_backoff.stop_voting(),
            NodeBroadcastHandleError::VoteRefused
        );
```

**File:** consensus/src/epoch_manager.rs (L1293-1310)
```rust
        if consensus_config.is_dag_enabled() {
            warn!("DAG doesn't support secret sharing");
            self.start_new_epoch_with_dag(
                epoch_state,
                loaded_consensus_key.clone(),
                consensus_config,
                execution_config,
                onchain_randomness_config,
                jwk_consensus_config,
                network_sender,
                payload_client,
                payload_manager,
                rand_config,
                fast_rand_config,
                rand_msg_rx,
                secret_share_manager_rx,
            )
            .await
```

**File:** types/src/on_chain_config/consensus_config.rs (L77-83)
```rust
    pub fn is_dag_enabled(&self) -> bool {
        match self {
            ConsensusAlgorithmConfig::Jolteon { .. }
            | ConsensusAlgorithmConfig::JolteonV2 { .. } => false,
            ConsensusAlgorithmConfig::DAG(_) => true,
        }
    }
```

**File:** consensus/src/dag/bootstrap.rs (L533-540)
```rust
        let ordered_notifier = Arc::new(OrderedNotifierAdapter::new(
            self.ordered_nodes_tx.clone(),
            dag.clone(),
            self.epoch_state.clone(),
            parent_block_info,
            ledger_info_provider.clone(),
            self.allow_batches_without_pos_in_proposal,
        ));
```
