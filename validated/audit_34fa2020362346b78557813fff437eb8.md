# Audit Report

## Title
DKG Proof Reuse Attack: Malicious Dealer Can Copy Another Dealer's PVSS Contribution via Stateless PoK Verification

## Summary
The Schnorr Proof-of-Knowledge (PoK) verification in the DKG protocol does not bind proofs to dealer identities, allowing a malicious validator to copy another dealer's PVSS contribution (cryptographic commitments and PoK) and re-sign it with their own BLS key. This passes all verification checks and results in compromised randomness output, as the final secret becomes `2*secret_A` instead of `secret_A + secret_B`, breaking the DKG security assumption that each dealer contributes independent randomness.

## Finding Description

The DKG protocol uses Schnorr Proofs-of-Knowledge to prove that dealers know the discrete logarithm of their committed secrets. However, the PoK structure is stateless and identity-agnostic. [1](#0-0) 

The Fiat-Shamir challenge is computed without any dealer identity binding: [2](#0-1) 

**Attack Execution Path:**

1. **Dealer A creates legitimate transcript**: When `deal()` is called, Dealer A generates a valid transcript with commitment `V[W] = g^{s_A}`, proof `pok_A`, and BLS signature `sig_A` over `Contribution{comm: V[W], player: A, aux: (epoch, addr_A)}`: [3](#0-2) 

2. **Dealer B observes and copies**: Dealer B observes the broadcast transcript and copies all cryptographic vectors (`V`, `V_hat`, `R`, `R_hat`, `C`) along with `pok_A`.

3. **Dealer B creates own signature**: Dealer B generates `sig_B` signing their own `Contribution{comm: V[W], player: B, aux: (epoch, addr_B)}`: [4](#0-3) 

4. **Transcripts aggregate**: During aggregation, all vectors are summed element-wise: [5](#0-4) 

The result is `V_agg[W] = 2*g^{s_A}` and `soks = [(A, g^{s_A}, sig_A, pok_A), (B, g^{s_A}, sig_B, pok_A)]`.

5. **Verification passes**: The `batch_verify_soks` function checks that the sum of commitments equals the dealt public key: [6](#0-5) 

The check passes: `g^{s_A} + g^{s_A} = 2*g^{s_A}` ✓. Both PoKs verify (valid for same commitment), and both BLS signatures verify (each dealer signed their own contribution structure with their identity).

6. **Dealer uniqueness check bypassed**: The uniqueness check only prevents the SAME dealer from contributing twice, not different dealers with identical commitments: [7](#0-6) [8](#0-7) 

This check ensures dealer addresses are unique (2 ≠ 2 would fail), but Dealers A and B are different addresses, so it passes (2 = 2).

## Impact Explanation

**High Severity** - This vulnerability breaks critical DKG security properties:

1. **Randomness Compromise**: The final DKG secret is `2*s_A` instead of `s_A + s_B`, meaning Dealer B contributed zero independent entropy. Dealer A knows the final secret completely.

2. **Collusion Attack**: If Dealers A and B collude, they can predict all future randomness outputs derived from this compromised DKG session, enabling manipulation of consensus outcomes.

3. **Leader Selection Manipulation**: DKG-generated randomness is used for WVUF-based leader selection in Aptos consensus. Predictable randomness allows attackers to forecast which validators will be selected as leaders, enabling targeted attacks or censorship.

4. **Protocol Violation**: This breaks the fundamental DKG security assumption that each participant contributes independent, unpredictable randomness to the shared secret.

This meets **High Severity** criteria per Aptos bug bounty as a "significant protocol violation" affecting the randomness generation subsystem critical for consensus security, distinct from Critical impacts like direct fund theft or consensus splits.

## Likelihood Explanation

**High Likelihood:**

1. **Low Barrier to Entry**: Any validator participating in DKG can execute this attack without special privileges or resources.

2. **Simple Execution**: The attacker only needs to observe another dealer's broadcast transcript, copy the cryptographic components, and create their own BLS signature—no advanced cryptographic manipulation required.

3. **Network Observable**: DKG transcripts are broadcast over the network during aggregation, making them trivially observable by all participants: [9](#0-8) 

4. **No Detection Mechanism**: The verification logic has no checks for duplicate commitments from different dealers—only that dealer identities are unique.

5. **Economic Incentive**: Validators gain significant advantage in leader selection by compromising randomness, creating clear motivation for exploitation.

## Recommendation

Bind Schnorr PoKs to dealer identities by including the dealer's player ID in the Fiat-Shamir challenge computation:

**Modified Challenge Structure:**
```rust
#[derive(Serialize, Deserialize, BCSCryptoHash, CryptoHasher)]
struct Challenge<Gr> {
    R: Gr,
    pk: Gr,
    g: Gr,
    dealer: Player,  // Add dealer identity binding
}
```

**Modified Verification:**
Update `batch_verify_soks` to verify PoKs with dealer-specific challenges, and add explicit checks for duplicate commitments across different dealers.

Alternatively, implement commitment uniqueness validation during aggregation to reject transcripts with duplicate commitments from different dealers.

## Proof of Concept

No executable PoC is provided, but the attack path is verified through code analysis:

1. Run DKG session with malicious Dealer B
2. Dealer B delays contribution until observing Dealer A's transcript
3. Dealer B creates transcript with copied `V`, `R`, `R_hat`, `V_hat`, `C` vectors
4. Dealer B creates own `soks` entry: `(B, V_A[W], sig_B, pok_A)` where `sig_B` is BLS signature over `Contribution{comm: V_A[W], player: B, aux: (epoch, addr_B)}`
5. Both transcripts aggregate successfully
6. Verification passes all checks
7. Final reconstructed secret is `2*secret_A`

**Notes:**
- The vulnerability exploits the stateless nature of Schnorr PoK verification that doesn't bind proofs to dealer identities
- This is distinct from the existing protection against a single dealer contributing twice
- The attack is feasible under normal network operation within the Byzantine fault tolerance assumptions of DKG protocols

### Citations

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L19-19)
```rust
pub type PoK<Gr> = (Gr, Scalar);
```

**File:** crates/aptos-dkg/src/pvss/schnorr.rs (L41-41)
```rust
    let e = schnorr_hash(Challenge::<Gr> { R, pk: *pk, g: *g });
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L179-179)
```rust
            soks: vec![(*dealer, V[W], sig, pok)],
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L394-407)
```rust
        for i in 0..self.V.len() {
            self.V[i] += other.V[i];
            self.V_hat[i] += other.V_hat[i];
        }

        for i in 0..W {
            self.R[i] += other.R[i];
            self.R_hat[i] += other.R_hat[i];
            self.C[i] += other.C[i];
        }

        for sok in &other.soks {
            self.soks.push(sok.clone());
        }
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L19-24)
```rust
#[derive(Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct Contribution<Gr, A> {
    pub comm: Gr,
    pub player: Player,
    pub aux: A,
}
```

**File:** crates/aptos-dkg/src/pvss/contribution.rs (L57-68)
```rust
    let mut c = Gr::identity();
    for (_, c_i, _, _) in soks {
        c.add_assign(c_i)
    }

    if c.ne(pk) {
        bail!(
            "The PoK does not correspond to the dealt secret. Expected {} but got {}",
            pk,
            c
        );
    }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L92-94)
```rust
        if trx_aggregator.contributors.contains(&metadata.author) {
            return Ok(None);
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L311-311)
```rust
        ensure!(main_trx_dealers.len() == dealer_set.len());
```

**File:** dkg/src/dkg_manager/mod.rs (L332-345)
```rust
        let trx = DKG::generate_transcript(
            &mut rng,
            &public_params,
            &input_secret,
            self.my_index as u64,
            &self.dealer_sk,
            &self.dealer_pk,
        );

        let my_transcript = DKGTranscript::new(
            self.epoch_state.epoch,
            self.my_addr,
            bcs::to_bytes(&trx).map_err(|e| anyhow!("transcript serialization error: {e}"))?,
        );
```
