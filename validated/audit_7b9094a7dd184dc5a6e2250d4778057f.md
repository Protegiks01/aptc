# Audit Report

## Title
Sybil Attack on State Sync Peer Selection via Unauthenticated VFN Role Inference

## Summary
Validators on VFN networks auto-assign `PeerRole::ValidatorFullNode` to untrusted inbound peers due to `MaybeMutual` authentication mode. These peers can report `distance_from_validators = 1` without verification, bypassing inbound connection limits and dominating peer selection algorithms used by state sync, consensus observer, and mempool. This enables Sybil attacks that can cause validator slowdowns and eclipse attacks.

## Finding Description

The vulnerability exists in the interaction between four system components:

**1. VFN Network Authentication Default**

VFN networks default to `mutual_authentication = false` because the network ID is not a validator network. [1](#0-0) 

This configuration is converted to `AuthenticationMode::MaybeMutual` during network initialization. [2](#0-1) 

**2. Automatic Role Assignment Without Authentication**

When an untrusted peer (not in the trusted peer set) establishes an inbound connection to a validator on the VFN network in `MaybeMutual` mode, the handshake logic automatically infers the peer's role as `PeerRole::ValidatorFullNode` based solely on network context, without cryptographic proof of identity. [3](#0-2) 

**3. Insufficient Distance Validation**

When peers report `distance_from_validators = 1` through the peer monitoring service, the validation logic only verifies that the peer's role is VFN and the network ID is correct. It does not verify that the peer is actually in the trusted peer set or has legitimate connections to validators. [4](#0-3) 

**4. Distance-Priority Peer Selection**

The state sync peer selection algorithm groups peers by distance from validators (in ascending order via BTreeMap), then selects from the lowest distance group first before considering higher distance groups. [5](#0-4) 

**5. Connection Limit Bypass (Critical Amplification)**

The inbound connection limiting logic only applies to peers with `PeerRole::Unknown`. Peers with auto-assigned `PeerRole::ValidatorFullNode` are exempt from the 100 connection limit, treating them as trusted. [6](#0-5) 

The comment states: "Everything below here is meant for unknown peers only. The role comes from the Noise handshake and if it's not `Unknown` then it is trusted." This creates a false trust assumption when roles are auto-assigned without authentication.

**Attack Execution:**

1. Attacker generates multiple x25519 keypairs and derives PeerIDs
2. Establishes unlimited inbound connections to validators on VFN network (bypasses 100 limit)
3. Each connection receives auto-assigned `PeerRole::ValidatorFullNode` 
4. Attacker's peer monitoring service responds with `distance_from_validators = 1`
5. Distance validation passes (only checks role, not trusted peer set membership)
6. All Sybil identities grouped in distance=1 tier
7. Peer selection algorithms (state sync, consensus observer, mempool) prioritize distance=1 peers
8. Attacker dominates peer selection across critical protocol components

## Impact Explanation

**Severity: High**

This vulnerability qualifies as High severity under the Aptos bug bounty criteria:

1. **Validator Node Slowdowns** (explicitly High severity): Malicious peers selected for state sync can provide slow or incomplete responses, degrading synchronization performance. The attack affects multiple protocol components using distance-based peer selection.

2. **Significant Protocol Violations** (explicitly High severity): The distance-based peer prioritization is a core protocol mechanism. The vulnerability allows unauthenticated peers to manipulate this metric across state sync, consensus observer, and mempool, violating fundamental trust assumptions.

3. **Eclipse Attack Potential**: By establishing unlimited connections (bypassing the 100 limit) and dominating the distance=1 peer group, attackers can control what state data victim nodes receive. While Merkle proofs prevent invalid state injection, attackers can selectively withhold valid data, consume resources, and position for sophisticated attacks.

The impact does not reach Critical severity because:
- Consensus safety remains intact (validator consensus is unaffected)
- Funds cannot be stolen or frozen
- Cryptographic validation (Merkle proofs) prevents invalid state acceptance

## Likelihood Explanation

**Likelihood: High**

1. **Minimal Barrier**: Any network participant can establish connections to validators on VFN networks without privileged access
2. **Simple Execution**: Requires only keypair generation, TCP connections, and a basic peer monitoring service
3. **Default Vulnerability**: VFN networks use `MaybeMutual` mode by default, affecting all validators unless explicitly reconfigured
4. **Unlimited Scale**: Connection limit bypass allows attackers to create arbitrary Sybil identities
5. **No Detection**: System lacks validation that distance=1 claims correspond to actual trusted peer relationships
6. **Economic Incentive**: Enables validator performance degradation, potential MEV extraction during eclipse attacks, and network disruption

## Recommendation

**Short-term mitigation:**

1. **Validate auto-assigned roles**: In `MaybeMutual` mode, do not automatically assign `PeerRole::ValidatorFullNode` to untrusted peers. Use `PeerRole::Unknown` instead and require explicit trusted peer configuration.

2. **Apply connection limits uniformly**: Modify the inbound connection limiting logic to apply limits based on trusted peer set membership, not just role assignment.

3. **Verify distance claims**: When validating `distance_from_validators = 1`, additionally check that the peer is in the trusted peer set, not just that the role is VFN.

**Long-term solution:**

Implement cryptographic attestation for distance claims, where peers must provide proof of their connections to validators (e.g., signed statements from validators confirming the connection relationship).

## Proof of Concept

A complete PoC would require:
1. Generate multiple x25519 keypairs
2. Implement a peer monitoring service that responds with `distance_from_validators = 1`
3. Establish multiple connections to a validator's VFN network endpoint
4. Observe that connections are accepted without limit and auto-assigned VFN role
5. Monitor peer selection in state sync to confirm dominance of distance=1 group

The vulnerability can be verified by code inspection of the cited files, confirming the role inference logic, distance validation, and connection limiting behavior.

## Notes

This vulnerability is particularly severe because:
- The connection limit bypass was not mentioned in the original report but significantly amplifies the impact
- The auto-assignment of trusted roles to untrusted peers violates the principle of least privilege
- The issue affects multiple critical protocol components (state sync, consensus observer, mempool)
- Default configuration leaves all validators vulnerable

The distinction from "Network DoS" (out of scope) is critical: this is a protocol-level vulnerability exploiting trust assumptions in peer selection logic, not infrastructure-level flooding or bandwidth exhaustion.

### Citations

**File:** config/src/config/network_config.rs (L135-142)
```rust
    pub fn network_with_id(network_id: NetworkId) -> NetworkConfig {
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L128-136)
```rust
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```

**File:** network/framework/src/peer_manager/mod.rs (L352-390)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```
