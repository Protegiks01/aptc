# Audit Report

## Title
Timeout Certificate Denial of Service via Signature-Timeout Object Inconsistency

## Summary
A malicious validator can cause timeout certificate (TC) formation failures by exploiting an inconsistency between signature storage and timeout object updates in the consensus timeout aggregation logic. This blocks consensus progress and causes network-wide liveness failures.

## Finding Description

The vulnerability exists in the timeout aggregation logic where signature storage and timeout object updates are not properly synchronized.

**Attack Flow:**

When a validator sends their first timeout message with `(round=R, hqc_round=X, signature_for_X)`, the system processes it through `TwoChainTimeoutWithPartialSignatures::add()` which stores the signature via `add_signature()`. [1](#0-0) 

When the same validator sends a second timeout message with `(round=R, hqc_round=Y where Y>X, signature_for_Y)`:

1. The condition at line 259 evaluates to TRUE since Y > X, causing `self.timeout` to be updated with the new hqc_round=Y
2. Line 262 calls `add_signature(author, Y, signature_for_Y)` 
3. However, `PartialSignaturesWithRound::add_signature()` uses `or_insert` which prevents signature replacement [2](#0-1) 

This creates an inconsistency: `self.timeout.hqc_round() = Y` but `self.signatures[validator] = (X, signature_for_X)` where X < Y.

**Verification Failure:**

During TC verification, the code checks that the timeout's hqc_round equals the maximum of all signed rounds: [3](#0-2) 

With the inconsistency, if the attacker's signed round X is among the maximum of all validators' signed rounds, but the timeout object has Y where Y > X, this verification fails.

**No Duplicate Detection:**

The system lacks duplicate detection for timeout messages from the same author. In `pending_votes.rs`, the `insert_round_timeout()` method directly adds timeout messages without checking if the author already submitted one: [4](#0-3) 

This contrasts with regular vote handling which explicitly checks for duplicates: [5](#0-4) 

**Message Verification:**

Both timeout messages pass individual signature verification since each carries a valid signature for its respective hqc_round: [6](#0-5) 

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria.

This vulnerability causes:

1. **Consensus Liveness Failure**: TC verification failures prevent validators from progressing to the next round, halting consensus
2. **Network-Wide Impact**: All nodes participating in consensus are affected when attempting to form a TC for the compromised round
3. **Sustained Attack**: The malicious validator can repeat this attack across multiple rounds to maintain the denial of service
4. **Single Validator Attack**: Requires only one Byzantine validator within the f < n/3 BFT threshold

This aligns with the "Validator Node Slowdowns (High)" and "Significant protocol violations" categories in the Aptos bug bounty program, as it causes consensus to stall through a protocol-level vulnerability rather than network flooding.

## Likelihood Explanation

**Likelihood: High**

1. **Trivial Execution**: Attack requires only sending two network messages with different HQC values in sequence
2. **No Collusion Required**: Single malicious validator can execute the attack independently
3. **Missing Protection**: No duplicate timeout detection exists in the codebase for the same author in the same round
4. **BFT Threat Model**: The attack assumes a Byzantine validator, which is within the standard BFT assumptions (f < n/3)
5. **Zero Economic Cost**: Beyond minimal network messaging, no stake or tokens are required

## Recommendation

Implement duplicate timeout detection in `PendingVotes::insert_round_timeout()` similar to the duplicate vote detection:

1. Add a map to track timeout authors: `HashMap<Author, TwoChainTimeout>`
2. Before adding a new timeout, check if the author has already submitted one for this round
3. Return `VoteReceptionResult::DuplicateTimeout` if duplicate detected
4. Optionally, allow updating to a higher HQC round only if the new timeout's HQC is strictly greater and properly update both the timeout object AND the signature atomically

Alternatively, modify `PartialSignaturesWithRound::add_signature()` to use `insert()` instead of `or_insert()` to allow signature updates, but this may have other security implications that need careful analysis.

## Proof of Concept

A complete proof of concept would involve:
1. Setting up a test network with 4 validators where 3 constitute quorum
2. Having validator A send timeout (round=4, hqc_round=1, valid_sig_for_1)
3. Having validator A send timeout (round=4, hqc_round=3, valid_sig_for_3)
4. Having validators B and C send valid timeouts with hqc_round=2
5. Observing that TC aggregation succeeds (quorum reached) but TC verification fails with "Inconsistent hqc round" error

The test should be added to `consensus/consensus-types/src/timeout_2chain.rs` in the tests module to demonstrate the inconsistency.

## Notes

This is a protocol-level consensus vulnerability, not a network-level DoS attack. The distinction is critical: the vulnerability exploits flawed consensus logic rather than network flooding or packet manipulation. The attack is within the Byzantine fault tolerance threat model that assumes up to f < n/3 malicious validators.

The existing test at lines 492-499 of `timeout_2chain.rs` tests a different scenario where the QC is manually modified after aggregation, not where a validator sends conflicting timeout messages during aggregation.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L170-181)
```rust
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```

**File:** consensus/src/pending_votes.rs (L190-232)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```
