# Audit Report

## Title
Network Shutdown via Validator Set Depletion During Epoch Transition

## Summary
The `on_new_epoch()` function can result in an empty validator set if all remaining validators are filtered out due to insufficient stake, causing complete network shutdown. While `leave_validator_set()` prevents the last validator from explicitly leaving, it does not prevent the validator set from becoming empty during epoch transitions when validators fall below the minimum stake requirement.

## Finding Description

The vulnerability exists in the interaction between two critical functions in the Aptos staking module.

The `leave_validator_set()` function contains a protection that prevents removing the last validator from the active set. After a validator is removed from `active_validators`, the function checks that at least one validator remains: [1](#0-0) 

However, this check only applies during **explicit** leave operations initiated by validators. The critical vulnerability occurs in the `on_new_epoch()` function, which handles automatic validator set updates during epoch transitions.

During epoch transitions, `on_new_epoch()` iterates through all active validators and filters them based on whether their voting power meets the minimum stake requirement: [2](#0-1) 

Validators whose `voting_power` is less than `minimum_stake` are NOT added to `next_epoch_validators`. Crucially, **there is no validation after the filtering loop to ensure that `next_epoch_validators` is not empty** before assigning it to `validator_set.active_validators` at line 1401.

The framework's documentation explicitly confirms this automatic removal behavior: [3](#0-2) 

The `ELAST_VALIDATOR` error constant exists but only protects explicit leaving operations: [4](#0-3) 

**Attack Scenario:**

1. Network starts with N validators (N ≥ 2)
2. N-1 validators call `leave_validator_set()` successfully - each time the check passes since ≥1 validator remains after each removal
3. One validator remains in `active_validators`
4. This validator's stake drops below `minimum_stake` through either:
   - **Path A**: The validator calls `unlock()` to move active stake to pending_inactive. The unlock function allows moving any amount up to the full active stake with no check for maintaining minimum stake requirements: [5](#0-4) 
   - **Path B**: Governance executes a proposal to increase `minimum_stake` via the staking config, which can be updated by the @aptos_framework account: [6](#0-5) 
5. At the next epoch boundary, `reconfigure()` calls `stake::on_new_epoch()`: [7](#0-6) 
6. The filtering loop evaluates the last validator and finds `voting_power < minimum_stake`
7. The validator is NOT added to `next_epoch_validators`
8. `next_epoch_validators` remains empty
9. Line 1401 assigns the empty vector without validation
10. Network cannot produce blocks → Complete shutdown

The formal specification confirms the function never aborts, even with an empty result: [8](#0-7) 

## Impact Explanation

This is a **CRITICAL severity** vulnerability under the Aptos Bug Bounty Program, meeting the "Total Loss of Liveness/Network Availability (Critical - up to $1,000,000)" category.

With zero validators, the AptosBFT consensus protocol cannot function. The validator verifier in the Rust implementation handles empty validator sets by setting quorum voting power to 0: [9](#0-8) 

However, this doesn't enable consensus - it merely prevents a panic. Without any validators to propose blocks or vote on proposals, block production completely halts and the network enters a permanent deadlock state.

**Non-recoverable Network Partition:** Once `active_validators` becomes empty, the network cannot recover through normal operations. There are no validators to execute transactions, process governance proposals, or trigger any state changes. Recovery would require manual intervention by the Aptos foundation, a hardfork, or complete network restart with modified genesis state.

The validator set is fundamental to AptosBFT consensus. An empty validator set violates the core protocol invariant that the network must always have at least one validator capable of producing blocks.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through several realistic scenarios that do NOT require Byzantine behavior or malicious intent:

**Scenario 1 - Natural Validator Attrition:** As validators leave the network over time for legitimate operational or economic reasons, the validator set naturally shrinks. If the last remaining validator subsequently unlocks stake for treasury management and falls below the minimum threshold, the network halts at the next epoch.

**Scenario 2 - Governance-Driven Minimum Stake Increase:** A well-intentioned governance proposal to improve network security by raising `minimum_stake` could inadvertently trigger this vulnerability if the proposal passes when validator count is already low and remaining validators haven't proactively increased their stake.

**Key factors making this MEDIUM-HIGH likelihood:**
- Does NOT require Byzantine validator behavior or compromised keys
- Can occur through normal network operations and legitimate validator decisions
- No complex exploit chain or precise timing required (epoch transitions are predictable)
- Both triggering mechanisms (unlock and governance) are standard operations
- Requires specific conditions (low validator count + stake management issue)
- Assumes network governance/operators don't proactively monitor validator health

## Recommendation

Add a validation check in `on_new_epoch()` after the filtering loop to ensure at least one validator remains:

```move
// After line 1399, before line 1401:
assert!(vector::length(&next_epoch_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

Additionally, consider:
1. Adding a check in `unlock()` to prevent validators from unlocking stake that would drop them below `minimum_stake` while in the active set
2. Adding governance safeguards when increasing `minimum_stake` to verify it won't remove all validators
3. Implementing monitoring alerts when validator count drops below a safety threshold

## Proof of Concept

The vulnerability can be demonstrated through the following sequence on a test network:

1. Start with 2 validators in the active set
2. Have validator 1 call `leave_validator_set()` - succeeds (1 validator remains)
3. Have validator 2 call `unlock()` with their full active stake amount
4. Wait for the next epoch boundary
5. `on_new_epoch()` executes and filters validator 2 (insufficient stake)
6. `active_validators` becomes empty vector
7. Network halts - no blocks can be produced

**Notes**

This is a **logic vulnerability** in the staking module where the design of `on_new_epoch()` (specified to never abort) creates a critical edge case. The function works as formally specified but the specification itself is flawed by not preventing an empty validator set outcome.

This is distinct from network DoS attacks (which are out of scope). This is a protocol-level bug where missing validation allows a state that fundamentally breaks consensus, not an attack overwhelming network resources.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L13-17)
```text
/// 6. Validator can request to unlock their stake at any time. However, their stake will only become withdrawable when
/// their current lockup expires. This can be at most as long as the fixed lockup duration.
/// 7. After exiting, the validator can either explicitly leave the validator set by calling stake::leave_validator_set
/// or if their stake drops below the min required, they would get removed at the end of the epoch.
/// 8. Validator can always rejoin the validator set by going through steps 2-3 again.
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L57-58)
```text
    /// Can't remove last validator.
    const ELAST_VALIDATOR: u64 = 6;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1253-1255)
```text
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1377-1401)
```text
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L272-285)
```text
    /// Update the min and max stake amounts.
    /// Can only be called as part of the Aptos governance proposal process established by the AptosGovernance module.
    public fun update_required_stake(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
    ) acquires StakingConfig {
        system_addresses::assert_aptos_framework(aptos_framework);
        validate_required_stake(minimum_stake, maximum_stake);

        let staking_config = borrow_global_mut<StakingConfig>(@aptos_framework);
        staking_config.minimum_stake = minimum_stake;
        staking_config.maximum_stake = maximum_stake;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-134)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.spec.move (L453-464)
```text
    spec on_new_epoch {
        pragma verify = false; // TODO: set because of timeout (property proved).
        pragma disable_invariants_in_body;
        // The following resource requirement cannot be discharged by the global
        // invariants because this function is called during genesis.
        include ResourceRequirement;
        include GetReconfigStartTimeRequirement;
        include staking_config::StakingRewardsConfigRequirement;
        include aptos_framework::aptos_coin::ExistsAptosCoin;
        // This function should never abort.
        /// [high-level-req-4]
        aborts_if false;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
