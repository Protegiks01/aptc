# Audit Report

## Title
Module Verification DoS: Expensive Bytecode Verification Performed Before Adequate Gas Metering

## Summary
The Move bytecode verifier performs expensive computational work (control flow analysis, type checking, reference safety analysis) on submitted modules without charging gas proportional to the verification complexity. This breaks the fundamental DoS protection mechanism and enables attackers to cause validator node slowdowns by submitting modules that require expensive verification work while paying minimal gas.

## Finding Description

The vulnerability exists in the module publishing flow where bytecode verification happens without gas metering, creating a massive gap between the attacker's cost and the validators' computational burden.

**Execution Flow:**

1. The `native_request_publish` function charges gas based only on module size: `CODE_REQUEST_PUBLISH_BASE` (1838) + `CODE_REQUEST_PUBLISH_PER_BYTE` (7) × size. [1](#0-0) 

2. AptosVM charges additional size-based gas for old modules, new modules, and dependencies - all proportional to byte size, not verification complexity. [2](#0-1) 

3. A complexity check is performed with budget `2048 + size * 20`, but this **does not charge gas** - it only enforces a limit that will abort if exceeded. [3](#0-2) 

4. `StagingModuleStorage::create_with_compat_config` is called, triggering verification. [4](#0-3) 

5. **Critical Issue:** `build_locally_verified_module()` performs expensive bytecode verification **without any gas meter parameter**. [5](#0-4) 

6. The bytecode verifier is called without gas metering, performing computationally expensive operations. [6](#0-5) 

7. The verifier has an internal meter limit of 80,000,000 units (80M), far exceeding the complexity check budget. [7](#0-6) 

**Attack Scenario:**

An attacker crafts modules with:
- Small byte size (minimize gas: e.g., 1KB = 9,006 gas units)
- Maximal verification complexity within limits (complex control flow, deep type nesting)
- Passes complexity check (budget: 22,528 for 1KB)
- Forces expensive verifier work (up to 80M meter units)

**Gap Analysis:** For a 1KB module, the verifier can perform ~3,500× more work than the complexity check allows, and ~8,888× more than gas charged.

## Impact Explanation

**High Severity - Validator Node Slowdowns**

This vulnerability aligns with the Aptos bug bounty category "Validator Node Slowdowns (High): Significant performance degradation affecting consensus; DoS through resource exhaustion."

Specific impacts:
1. **Validator CPU exhaustion**: Attackers spam verification-heavy modules consuming validator CPU cycles disproportionate to gas paid
2. **Transaction processing delays**: While validators verify malicious modules, legitimate transactions experience delays
3. **Economic imbalance**: Attacker cost (~9K gas per 1KB) << Validator cost (up to 80M verifier units), enabling sustained attacks
4. **Breaks DoS protection invariant**: Violates "All operations must respect gas limits and computational limits"

The cache provides limited protection since attackers can generate unique module hashes (e.g., by adding dummy constants) to force full verification for each submission.

## Likelihood Explanation

**High Likelihood**

1. **Easy to exploit**: Any transaction sender can submit module publishing transactions
2. **No special privileges required**: Standard transaction submission capability
3. **Deterministic**: The verification cost gap is inherent to the current design
4. **Cache bypass trivial**: Generate unique module hashes by varying bytecode
5. **Economically viable**: Low gas cost versus high validator CPU cost enables sustained attacks

The maximum transaction gas limit is 2,000,000 units, allowing publication of modules up to ~285KB, which can still exploit the verification cost gap. [8](#0-7) 

## Recommendation

Implement gas metering proportional to actual verification work:

1. **Pass gas meter to verification**: Modify `build_locally_verified_module()` to accept and use a gas meter parameter
2. **Charge for verifier operations**: Integrate the verifier's internal meter with the transaction gas meter, charging gas proportional to verifier meter units consumed
3. **Align limits**: Ensure complexity check budget and gas charged are proportional to maximum verifier work allowed
4. **Alternative**: Reduce `max_per_mod_meter_units` to align with complexity check budget, though this may reject legitimate complex modules

## Proof of Concept

A concrete PoC would require crafting a Move module with:
- Minimal structural complexity (few signatures/handles)
- Maximum verification complexity (deep control flow graphs, complex type inference requirements)
- Module size ~1-10KB to minimize gas cost

The module would pass the `check_module_complexity` check (budget ~22K-202K) but trigger near-maximum verifier work (80M units). Testing would involve:
1. Submitting the module via transaction
2. Measuring validator CPU time during verification
3. Comparing gas paid versus CPU consumed
4. Demonstrating economic imbalance enabling DoS

## Notes

This vulnerability represents a fundamental mismatch between gas charged (size-based) and computational work performed (verification-complexity-based). The two complexity measures - `check_module_complexity` (structural) and `verify_module_with_config` (verification work) - measure different things, allowing modules with low structural complexity but high verification complexity to pass through with minimal gas payment while forcing expensive validator work.

### Citations

**File:** aptos-move/framework/src/natives/code.rs (L292-300)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1511-1536)
```rust
                if let Some(old_size) = size_if_old_module_exists {
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            addr,
                            name,
                            NumBytes::new(old_size),
                        )
                        .map_err(|err| {
                            err.finish(Location::Module(ModuleId::new(*addr, name.to_owned())))
                        })?;
                }
            }

            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L97-102)
```rust
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L252-257)
```rust
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L55-57)
```rust
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
```
