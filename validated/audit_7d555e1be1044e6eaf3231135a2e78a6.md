# Audit Report

## Title
Panic-Based Denial of Service in DKG Verification Due to Unvalidated Tuple Component Sizes

## Summary
A Byzantine validator can craft a malicious DKG transcript with mismatched proof component sizes, causing other validators to panic during cryptographic verification. The vulnerability exists in the sigma protocol's `merge_msm_terms` function, which assumes matching sizes between the prover's first message and the public statement without validation.

## Finding Description

The vulnerability exists in the DKG transcript verification flow where a `PairingTupleHomomorphism` proof is verified without size validation between deserialized components.

**Root Cause**: The `TupleCodomainShape<A, B>` deserialization independently deserializes components A and B without cross-validation of their sizes. The `CanonicalDeserialize` implementation simply deserializes each component sequentially with no size consistency checks between them. [1](#0-0) 

**Vulnerable Code Path**: During verification, the `merge_msm_terms` function assumes matching element counts between `prover_first_message` and `statement`. The function first zips these iterators to collect points for normalization. If `prover_first_message` has fewer elements than `statement`, the zip creates fewer pairs, resulting in `affine_iter` having fewer elements than needed. [2](#0-1) 

The subsequent loop iterates based on `powers_of_beta`, which is sized according to the `statement` length. Each iteration calls `affine_iter.next().unwrap()` twice. When `affine_iter` is exhausted before the loop completes, the `unwrap()` panics, crashing the validator. [3](#0-2) 

**Attack Trigger Point**: The vulnerability is reached when verifying DKG transcripts in the VM during validator transaction processing. [4](#0-3) 

This calls the transcript verification which eventually invokes the vulnerable sigma protocol verification. [5](#0-4) 

The transcript's `SharingProof.SoK` is verified using the `PairingTupleHomomorphism::verify` method, which constructs the public statement and calls verification. [6](#0-5) 

The `PairingTupleHomomorphism::verify` method computes `powers_of_beta` based on the public statement size by counting elements in each component, then calls `merge_msm_terms` for each homomorphism with these sized parameters. [7](#0-6) 

**Attack Path:**
1. Byzantine validator crafts DKG transcript with malformed `SharingProof.SoK`
2. The proof's `first_proof_item` contains a `TupleCodomainShape` where one component has fewer elements than the corresponding public statement component
3. Validator receives transcript via block proposal or validator transaction pool
4. During verification, deserialization succeeds (no size validation)
5. The size mismatch causes iterator exhaustion in `merge_msm_terms`
6. The `.unwrap()` call panics, crashing the validator node

## Impact Explanation

**Severity: HIGH**

This qualifies as HIGH severity under Aptos bug bounty criteria for "Validator Node Slowdowns/Crashes":

- **Validator crashes**: Malicious DKG transcripts cause immediate validator node panics during verification
- **DKG protocol disruption**: Multiple validators can be crashed, preventing DKG completion required for epoch transitions and validator set updates
- **Network impact**: While not total network failure (validators can restart), this significantly disrupts critical epoch transition functionality
- **Reproducible**: Any Byzantine validator can trigger this repeatedly during DKG sessions

The impact does not reach CRITICAL because:
- Network can recover (not permanent partition)
- Does not affect consensus on existing blocks
- Requires validator restart, not hard fork
- Limited to DKG-participating validators during DKG sessions

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity: Low** - Attacker only needs to serialize a proof with mismatched vector sizes in the `TupleCodomainShape` components
- **Attacker Requirements: Minimal** - Any validator participating in DKG can craft and submit malicious transcripts
- **No Sophisticated Knowledge Required** - Does not require cryptographic expertise beyond understanding serialization format
- **Detection: Difficult** - Malformed proof passes all prior validation checks and is only detected during MSM term computation
- **Threat Model: Within Scope** - Byzantine validators with <1/3 stake are within the Aptos threat model

## Recommendation

Add size validation during `TupleCodomainShape` deserialization or before calling `merge_msm_terms`:

**Option 1: Validate in deserialization**
```rust
impl<A, B> CanonicalDeserialize for TupleCodomainShape<A, B>
where
    A: CanonicalDeserialize + IntoIterator,
    B: CanonicalDeserialize + IntoIterator,
{
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, SerializationError> {
        let a = A::deserialize_with_mode(&mut reader, compress, validate)?;
        let b = B::deserialize_with_mode(&mut reader, compress, validate)?;
        // Add size validation if needed for specific use cases
        Ok(Self(a, b))
    }
}
```

**Option 2: Validate before merge_msm_terms**
```rust
fn merge_msm_terms(
    msm_terms: Vec<Self::MsmInput>,
    prover_first_message: &Self::Codomain,
    statement: &Self::Codomain,
    powers_of_beta: &[C::ScalarField],
    c: C::ScalarField,
) -> Self::MsmInput
{
    // Validate size consistency
    let prover_len = prover_first_message.clone().into_iter().count();
    let statement_len = statement.clone().into_iter().count();
    
    if prover_len != statement_len {
        panic!("Size mismatch: prover_first_message has {} elements but statement has {} elements", 
               prover_len, statement_len);
    }
    
    // ... rest of function
}
```

**Option 3: Use checked iterator operations**
Replace `.unwrap()` calls with proper error handling:
```rust
let a = affine_iter.next()
    .ok_or_else(|| anyhow::anyhow!("Insufficient elements in prover_first_message"))?;
let p = affine_iter.next()
    .ok_or_else(|| anyhow::anyhow!("Insufficient elements in prover_first_message"))?;
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Generates a valid DKG transcript with proper proof
2. Modifies the `first_proof_item` to have fewer elements in one component
3. Attempts verification, which will panic

```rust
#[test]
#[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
fn test_panic_on_size_mismatch() {
    use crate::sigma_protocol::homomorphism::tuple::TupleCodomainShape;
    
    // Setup: Create DKG transcript with valid parameters
    let mut transcript = create_valid_dkg_transcript();
    
    // Attack: Modify the proof's first_proof_item to have mismatched sizes
    // Make component A have fewer elements than expected
    transcript.sharing_proof.SoK.first_proof_item = 
        create_malformed_first_proof_item_with_size_mismatch();
    
    // Trigger: Verify the transcript (will panic)
    let result = transcript.verify(&config, &pp, &spks, &eks, &aux);
    
    // This line is never reached due to panic
    assert!(result.is_err());
}
```

The panic occurs because the verification flow does not validate that the deserialized `prover_first_message` size matches the `public_statement` size before using them in `merge_msm_terms`, causing iterator exhaustion when `.unwrap()` is called on an empty iterator.

## Notes

This vulnerability specifically affects the DKG protocol's sigma protocol verification layer. The issue is that cryptographic proof structures allow independent deserialization of components without cross-validation, which is then assumed to be consistent in downstream verification code. The fix should add explicit size validation at the deserialization boundary or before the vulnerable `merge_msm_terms` function to prevent the panic condition.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L117-131)
```rust
impl<A, B> CanonicalDeserialize for TupleCodomainShape<A, B>
where
    A: CanonicalDeserialize,
    B: CanonicalDeserialize,
{
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, SerializationError> {
        let a = A::deserialize_with_mode(&mut reader, compress, validate)?;
        let b = B::deserialize_with_mode(&mut reader, compress, validate)?;
        Ok(Self(a, b))
    }
}
```

**File:** crates/aptos-dkg/src/sigma_protocol/homomorphism/tuple.rs (L353-366)
```rust
        let len1 = public_statement.0.clone().into_iter().count(); // hmm maybe pass the into_iter version in merge_msm_terms?
        let len2 = public_statement.1.clone().into_iter().count();
        let powers_of_beta = utils::powers(beta, len1 + len2);
        let (first_powers_of_beta, second_powers_of_beta) = powers_of_beta.split_at(len1);

        let (first_msm_terms_of_response, second_msm_terms_of_response) = self.msm_terms(&proof.z);

        let first_input = H1::merge_msm_terms(
            first_msm_terms_of_response.into_iter().collect(),
            &prover_first_message.0,
            &public_statement.0,
            first_powers_of_beta,
            c,
        );
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L153-161)
```rust
        for (A, P) in prover_first_message.clone().into_iter()
            .zip(statement.clone().into_iter())
        {
            all_points_to_normalize.push(A);
            all_points_to_normalize.push(P);
        }

        let affine_points = C::normalize_batch(&all_points_to_normalize);
        let mut affine_iter = affine_points.into_iter();
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L163-178)
```rust
        for (term, beta_power) in msm_terms.into_iter().zip(powers_of_beta) {
            let mut bases = term.bases().to_vec();
            let mut scalars = term.scalars().to_vec();

            // Multiply scalars by βᶦ
            for scalar in scalars.iter_mut() {
                *scalar *= beta_power;
            }

            // Add prover + statement contributions
            bases.push(affine_iter.next().unwrap()); // this is the element `A` from the prover's first message
            bases.push(affine_iter.next().unwrap()); // this is the element `P` from the statement, but we'll need `P^c`

            scalars.push(- (*beta_power));
            scalars.push(-c * beta_power);

```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L514-528)
```rust
            if let Err(err) = hom.verify(
                &TupleCodomainShape(
                    TupleCodomainShape(
                        self.sharing_proof.range_proof_commitment.clone(),
                        chunked_elgamal::WeightedCodomainShape {
                            chunks: self.subtrs.Cs.clone(),
                            randomness: self.subtrs.Rs.clone(),
                        },
                    ),
                    chunked_scalar_mul::CodomainShape(self.subtrs.Vs.clone()),
                ),
                &self.sharing_proof.SoK,
                &sok_cntxt,
            ) {
                bail!("PoK verification failed: {:?}", err);
```
