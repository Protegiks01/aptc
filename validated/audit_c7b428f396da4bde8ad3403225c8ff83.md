# Audit Report

## Title
Distance-from-Validators Spoofing Vulnerability in Peer Monitoring Service Enables Malicious Peer Prioritization

## Summary
The peer monitoring service validation logic allows untrusted peers with `PeerRole::Unknown` to report arbitrary distances from validators (2-100) without verification. This false distance information is used by consensus observer and mempool for peer prioritization, enabling malicious peers to be preferentially selected over honest peers.

## Finding Description

The vulnerability exists in the distance validation logic where untrusted peers can claim false network distances. The validation performs strict role-based checks for distances 0 and 1, but only performs a boundary check for distances ≥ 2. [1](#0-0) 

During the Noise handshake, untrusted peers not in the `trusted_peers` set are assigned `PeerRole::Unknown`: [2](#0-1) 

The distance calculation on each node trusts peer-reported values without cross-validation: [3](#0-2) 

**Attack Flow:**
1. Attacker runs malicious full nodes and connects to victim PFN/VFN
2. During handshake, attacker nodes receive `PeerRole::Unknown`
3. Attacker responds to `GetNetworkInformation` requests with false low distance (e.g., 2-5)
4. Validation passes because distance ≥ 2 only checks upper bound (≤ 100)
5. Consensus observer prioritizes malicious peers based on distance: [4](#0-3) 

The consensus observer explicitly prioritizes distance over latency, sorting peers by distance in ascending order (lower distances prioritized first).

6. Mempool also uses distance for peer prioritization: [5](#0-4) [6](#0-5) 

The `MAX_DISTANCE_FROM_VALIDATORS` constant is set to 100: [7](#0-6) 

## Impact Explanation

This vulnerability represents a **protocol-level trust model violation** that affects Public Full Nodes (PFNs) and critical infrastructure:

**Affected Systems:**
- **Consensus Observer**: Malicious peers prioritized for subscriptions can delay consensus updates, provide stale information, and cause synchronization lag
- **Mempool**: Transaction broadcasting prioritizes malicious peers, affecting propagation efficiency
- **Critical Infrastructure**: Wallet backends, API nodes, and archive nodes relying on PFNs for transaction submission and blockchain data

**Severity Justification:**
While this does not affect consensus safety (block proofs are still cryptographically verified) or directly impact validators (who use authenticated channels), it constitutes a **significant protocol violation** enabling **liveness degradation** for critical network infrastructure. This aligns with the "Significant protocol violations" category for High severity issues, as it undermines the intended peer prioritization trust model and can degrade service quality for important ecosystem components.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly exploitable:

1. **Low Barrier to Entry**: Any attacker can run full nodes and connect to public networks without authentication
2. **Simple Exploitation**: Requires only modifying the `GetNetworkInformation` response (minimal code changes)
3. **No Detection Mechanism**: No cross-validation or reputation-based filtering for distance claims
4. **Immediate Impact**: Malicious peers are immediately prioritized upon connection
5. **Scalable Attack**: Multiple malicious nodes increase probability of selection

The attack requires no special privileges, insider knowledge, or complex infrastructure.

## Recommendation

Implement distance verification for untrusted peers:

1. **Cross-Validation**: Compare reported distances across multiple peers to detect anomalies
2. **Role-Based Restrictions**: Extend validation logic to restrict distance ranges based on `PeerRole::Unknown`
3. **Reputation System**: Integrate with existing peer reputation scoring to penalize peers reporting inconsistent distances
4. **Progressive Trust**: Initially treat distance claims from unknown peers with skepticism, only trusting them after consistent behavior

Example fix in `network_info.rs`:
```rust
distance_from_validators => {
    // For unknown peers, enforce higher minimum distance
    if peer_metadata.get_connection_metadata().role == PeerRole::Unknown {
        distance_from_validators >= 10 && distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    } else {
        distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    }
}
```

## Proof of Concept

A malicious node can be implemented by:

1. Running a standard Aptos full node
2. Modifying the peer monitoring service server to return false distance:
```rust
fn get_distance_from_validators(...) -> u64 {
    2  // Always claim distance of 2 (close to validators)
}
```
3. Connecting to target PFNs on the public network
4. Observing prioritization in consensus observer subscriptions and mempool forwarding

The victim PFN will accept this false distance and prioritize the malicious peer for consensus subscriptions and transaction broadcasting.

## Notes

- This vulnerability affects the peer prioritization trust model at the protocol level
- While consensus safety is maintained through cryptographic proof verification, liveness and service quality for PFNs are impacted
- The issue is particularly concerning for critical infrastructure components (wallets, APIs, archives) that rely on PFNs
- Health checks provide reactive mitigation but do not prevent initial exploitation
- Validators are not directly affected as they use mutually authenticated channels with trusted peer sets

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** peer-monitoring-service/server/src/lib.rs (L298-340)
```rust
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L615-638)
```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
```

**File:** peer-monitoring-service/types/src/lib.rs (L22-22)
```rust
pub const MAX_DISTANCE_FROM_VALIDATORS: u64 = 100; // Nodes that aren't connected to the network
```
