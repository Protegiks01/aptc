# Audit Report

## Title
Control Flow Graph Construction DoS via Unbounded Resource Consumption During Bytecode Verification

## Summary
The Move bytecode verifier constructs Control Flow Graphs (CFGs) for functions without enforcing resource limits beforehand, enabling attackers to cause validator node slowdowns through module publishing transactions containing pathologically large functions with maximized basic block counts.

## Finding Description

The vulnerability exists in the bytecode verification pipeline where expensive CFG construction occurs before the `max_basic_blocks` limit is enforced.

**Verification Flow Analysis:**

1. Module deserialization enforces a maximum of 65,535 instructions per function [1](#0-0) 

2. Complexity checking via `check_module_complexity` meters binary format elements (signatures, type nodes, identifiers) but does NOT construct or meter CFG complexity [2](#0-1) [3](#0-2) 

3. Module bytecode verification occurs during block execution, invoking `verify_module_with_config` through the runtime environment [4](#0-3)  which orchestrates multiple verification passes [5](#0-4) 

4. `CodeUnitVerifier::verify_function` is called for each function and invokes `control_flow::verify_function` to create a validated `FunctionView` [6](#0-5) 

5. The `control_flow::verify_function` creates a `FunctionView` which immediately constructs the CFG [7](#0-6) [8](#0-7) 

6. **Only AFTER** the CFG is fully constructed does the verifier check `max_basic_blocks` and reject if exceeded [9](#0-8) 

**Resource Consumption Analysis:**

The CFG construction algorithm performs expensive operations before any limit checking:
- O(n) iteration to identify basic block boundaries (lines 86-92)
- O(n) basic block creation with memory allocation (lines 94-112)  
- O(V + E) depth-first search for loop analysis, allocating exploration maps, DFS stacks, and post-order traversal vectors (lines 114-224) [10](#0-9) 

**Critical Gap:** The meter parameter is explicitly unused during CFG construction, with a TODO comment indicating metering is not yet implemented [11](#0-10) 

**Attack Vector:**

An attacker can craft a function with 65,535 instructions structured to maximize basic blocks (e.g., alternating branch instructions). The complexity budget enforced during publishing [12](#0-11)  does NOT cover CFG construction costs. Production limits `max_basic_blocks` to 1024 [13](#0-12) , but this check occurs after potentially thousands of basic blocks have been constructed and processed through expensive DFS algorithms.

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns - Significant performance degradation affecting consensus, DoS through resource exhaustion."

Each malicious module submission forces every validator to:
- Allocate memory for potentially thousands of basic blocks and associated data structures
- Execute expensive O(V+E) DFS traversals for loop analysis before rejection
- Waste CPU and memory resources during block execution

The attack affects block execution across all validators [14](#0-13) , causing sustained performance degradation that can slow consensus. An attacker can repeatedly submit such modules at minimal cost (gas proportional only to bytecode size, not verification complexity), creating an asymmetric cost structure that degrades consensus performance.

## Likelihood Explanation

**High likelihood** of exploitation:
- Any account can publish modules through the standard Move framework interface
- Attack requires only crafting modules with many branch instructions (trivially achievable with standard Move compiler)
- No special permissions required
- Gas cost is asymmetric: attacker pays for module size (~65KB), validators pay for verification complexity (potentially thousands of basic blocks with O(V+E) DFS)
- Attack can be repeated continuously through multiple transactions
- Affects all validators simultaneously during block execution

## Recommendation

Implement one of the following mitigations:

1. **Pre-validation basic block counting**: Perform a lightweight scan to count potential basic blocks before constructing the full CFG, and reject early if the count exceeds `max_basic_blocks`

2. **Proper metering**: Implement the TODO at [11](#0-10)  by metering CFG construction operations and enforcing limits within the complexity budget

3. **Reorder verification**: Check `max_basic_blocks` limit before constructing the CFG by implementing a preliminary analysis pass

## Proof of Concept

```rust
// Pseudocode for attack module generation
// Generate a Move function with 65,535 instructions structured as:
// loop {
//     if (condition) { branch_target_1 } else { branch_target_2 }
//     if (condition) { branch_target_3 } else { branch_target_4 }
//     // ... repeat to maximize basic blocks
// }
// This creates maximum basic blocks while staying under BYTECODE_COUNT_MAX
// Each branch instruction creates new basic blocks, forcing expensive CFG construction
```

The attacker publishes this module via standard `code::publish_package` transaction. All validators must verify the bytecode during block execution, wasting resources on CFG construction before the module is rejected for exceeding `max_basic_blocks`.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L61-61)
```rust
pub const BYTECODE_COUNT_MAX: u64 = 65535;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L138-145)
```rust
        let function_view = control_flow::verify_function(
            verifier_config,
            module,
            index,
            function_definition,
            code,
            meter,
        )?;
```

**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L147-153)
```rust
        if let Some(limit) = verifier_config.max_basic_blocks {
            if function_view.cfg().blocks().len() > limit {
                return Err(
                    PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS).at_code_offset(index, 0)
                );
            }
        }
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L41-41)
```rust
    _meter: &mut impl Meter, // TODO: metering
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L48-52)
```rust
    } else {
        verify_fallthrough(Some(index), code)?;
        let function_view = FunctionView::function(module, index, code, function_handle);
        verify_reducibility(verifier_config, &function_view)?;
        Ok(function_view)
```

**File:** third_party/move/move-binary-format/src/binary_views.rs (L442-450)
```rust
        Self {
            index: Some(index),
            code,
            parameters: module.signature_at(function_handle.parameters),
            return_: module.signature_at(function_handle.return_),
            locals: module.signature_at(code.locals),
            type_parameters: &function_handle.type_parameters,
            cfg: VMControlFlowGraph::new(&code.code),
        }
```

**File:** third_party/move/move-binary-format/src/control_flow_graph.rs (L84-224)
```rust
    pub fn new(code: &[Bytecode]) -> Self {
        let code_len = code.len() as CodeOffset;
        // First go through and collect block ids, i.e., offsets that begin basic blocks.
        // Need to do this first in order to handle backwards edges.
        let mut block_ids = Set::new();
        block_ids.insert(ENTRY_BLOCK_ID);
        for pc in 0..code.len() {
            VMControlFlowGraph::record_block_ids(pc as CodeOffset, code, &mut block_ids);
        }

        // Create basic blocks
        let mut blocks = Map::new();
        let mut entry = 0;
        let mut exit_to_entry = Map::new();
        for pc in 0..code.len() {
            let co_pc = pc as CodeOffset;

            // Create a basic block
            if Self::is_end_of_block(co_pc, code, &block_ids) {
                let exit = co_pc;
                exit_to_entry.insert(exit, entry);
                let successors = Bytecode::get_successors(co_pc, code);
                let bb = BasicBlock { exit, successors };
                blocks.insert(entry, bb);
                entry = co_pc + 1;
            }
        }
        let blocks = blocks;
        assert_eq!(entry, code_len);

        // # Loop analysis
        //
        // This section identifies loops in the control-flow graph, picks a back edge and loop head
        // (the basic block the back edge returns to), and decides the order that blocks are
        // traversed during abstract interpretation (reverse post-order).
        //
        // The implementation is based on the algorithm for finding widening points in Section 4.1,
        // "Depth-first numbering" of Bourdoncle [1993], "Efficient chaotic iteration strategies
        // with widenings."
        //
        // NB. The comments below refer to a block's sub-graph -- the reflexive transitive closure
        // of its successor edges, modulo cycles.

        #[derive(Copy, Clone)]
        enum Exploration {
            InProgress,
            Done,
        }

        let mut exploration: Map<BlockId, Exploration> = Map::new();
        let mut stack = vec![ENTRY_BLOCK_ID];

        // For every loop in the CFG that is reachable from the entry block, there is an entry in
        // `loop_heads` mapping to all the back edges pointing to it, and vice versa.
        //
        // Entry in `loop_heads` implies loop in the CFG is justified by the comments in the loop
        // below.  Loop in the CFG implies entry in `loop_heads` is justified by considering the
        // point at which the first node in that loop, `F` is added to the `exploration` map:
        //
        // - By definition `F` is part of a loop, meaning there is a block `L` such that:
        //
        //     F - ... -> L -> F
        //
        // - `F` will not transition to `Done` until all the nodes reachable from it (including `L`)
        //   have been visited.
        // - Because `F` is the first node seen in the loop, all the other nodes in the loop
        //   (including `L`) will be visited while `F` is `InProgress`.
        // - Therefore, we will process the `L -> F` edge while `F` is `InProgress`.
        // - Therefore, we will record a back edge to it.
        let mut loop_heads: Map<BlockId, Set<BlockId>> = Map::new();

        // Blocks appear in `post_order` after all the blocks in their (non-reflexive) sub-graph.
        let mut post_order = Vec::with_capacity(blocks.len());

        while let Some(block) = stack.pop() {
            match exploration.entry(block) {
                Entry::Vacant(entry) => {
                    // Record the fact that exploration of this block and its sub-graph has started.
                    entry.insert(Exploration::InProgress);

                    // Push the block back on the stack to finish processing it, and mark it as done
                    // once its sub-graph has been traversed.
                    stack.push(block);

                    for succ in &blocks[&block].successors {
                        match exploration.get(succ) {
                            // This successor has never been visited before, add it to the stack to
                            // be explored before `block` gets marked `Done`.
                            None => stack.push(*succ),

                            // This block's sub-graph was being explored, meaning it is a (reflexive
                            // transitive) predecessor of `block` as well as being a successor,
                            // implying a loop has been detected -- greedily choose the successor
                            // block as the loop head.
                            Some(Exploration::InProgress) => {
                                loop_heads.entry(*succ).or_default().insert(block);
                            },

                            // Cross-edge detected, this block and its entire sub-graph (modulo
                            // cycles) has already been explored via a different path, and is
                            // already present in `post_order`.
                            Some(Exploration::Done) => { /* skip */ },
                        };
                    }
                },

                Entry::Occupied(mut entry) => match entry.get() {
                    // Already traversed the sub-graph reachable from this block, so skip it.
                    Exploration::Done => continue,

                    // Finish up the traversal by adding this block to the post-order traversal
                    // after its sub-graph (modulo cycles).
                    Exploration::InProgress => {
                        post_order.push(block);
                        entry.insert(Exploration::Done);
                    },
                },
            }
        }

        let traversal_order = {
            // This reverse post order is akin to a topological sort (ignoring cycles) and is
            // different from a pre-order in the presence of diamond patterns in the graph.
            post_order.reverse();
            post_order
        };

        // build a mapping from a block id to the next block id in the traversal order
        let traversal_successors = traversal_order
            .windows(2)
            .map(|window| {
                debug_assert!(window.len() == 2);
                (window[0], window[1])
            })
            .collect();

        VMControlFlowGraph {
            blocks,
            traversal_successors,
            loop_heads,
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L160-160)
```rust
        max_basic_blocks: Some(1024),
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L81-203)
```rust
    pub(crate) fn finish_with_module_publishing_and_initialization(
        mut self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        gas_meter: &mut impl AptosGasMeter,
        traversal_context: &mut TraversalContext,
        features: &Features,
        gas_feature_version: u64,
        change_set_configs: &ChangeSetConfigs,
        destination: AccountAddress,
        bundle: ModuleBundle,
        modules: &[CompiledModule],
        compatability_checks: Compatibility,
    ) -> Result<UserSessionChangeSet, VMStatus> {
        // Stage module bundle on top of module storage. In case modules cannot be added (for
        // example, fail compatibility checks, create cycles, etc.), we return an error here.
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;

        let init_func_name = ident_str!("init_module");
        for module in modules {
            // INVARIANT:
            //   We have charged for the old version (if it exists) before when pre-processing the
            //   module bundle. We have also charged for the new versions as well.
            if features.is_lazy_loading_enabled() {
                traversal_context
                    .check_is_special_or_visited(module.self_addr(), module.self_name())
                    .map_err(|err| err.finish(Location::Undefined))?;
            }

            if module_storage
                .unmetered_check_module_exists(module.self_addr(), module.self_name())?
            {
                // Module existed before, so do not run initialization.
                continue;
            }

            self.session.execute(|session| {
                dispatch_loader!(&staging_module_storage, loader, {
                    #[allow(clippy::collapsible_else_if)]
                    if gas_feature_version <= RELEASE_V1_30 {
                        if let Ok(init_func) = loader.load_instantiated_function(
                            &LegacyLoaderConfig::unmetered(),
                            gas_meter,
                            traversal_context,
                            &module.self_id(),
                            init_func_name,
                            &[],
                        ) {
                            // We need to check that init_module function we found is well-formed.
                            verifier::module_init::legacy_verify_module_init_function(module)
                                .map_err(|e| e.finish(Location::Undefined))?;

                            session.execute_loaded_function(
                                init_func,
                                vec![MoveValue::Signer(destination).simple_serialize().unwrap()],
                                gas_meter,
                                traversal_context,
                                &loader,
                                // We should never enable trace record for init_module - it runs on
                                // newly published state so it is safer to do checks in-place.
                                &mut NoOpTraceRecorder,
                            )?;
                        }
                    } else {
                        if let Ok((module, function)) = loader.load_function_definition(
                            gas_meter,
                            traversal_context,
                            &module.self_id(),
                            init_func_name,
                        ) {
                            verifier::module_init::verify_init_module_function(&function)?;

                            let ty_args_id =
                                loader.runtime_environment().ty_pool().intern_ty_args(&[]);
                            let loaded_function = LoadedFunction {
                                owner: LoadedFunctionOwner::Module(module),
                                ty_args: vec![],
                                ty_args_id,
                                function,
                            };
                            session.execute_loaded_function(
                                loaded_function,
                                vec![MoveValue::Signer(destination)
                                    .simple_serialize()
                                    .expect("Signer is always serializable")],
                                gas_meter,
                                traversal_context,
                                &loader,
                                // We should never enable trace record for init_module - it runs on
                                // newly published state so it is safer to do checks in-place.
                                &mut NoOpTraceRecorder,
                            )?;
                        }
                    }
                });
                Ok::<_, VMStatus>(())
            })?;
        }

        // Get the changes from running module initialization. Note that here we use the staged
        // module storage to ensure resource group metadata from new modules is visible.
        let Self { session } = self;
        let change_set = session.finish_with_squashed_change_set(
            change_set_configs,
            &staging_module_storage,
            false,
        )?;

        let write_ops = convert_modules_into_write_ops(
            resolver,
            features,
            module_storage,
            staging_module_storage.release_verified_module_bundle(),
        )
        .map_err(|e| e.finish(Location::Undefined))?;
        let module_write_set = ModuleWriteSet::new(write_ops);
        UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)
    }
```
