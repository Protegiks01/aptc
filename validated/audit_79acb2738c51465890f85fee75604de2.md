# Audit Report

## Title
KeyRotation Event Emission Without OriginatingAddress Table Update Causes Permanent Account Recovery Failure

## Summary
Two key rotation functions (`rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account`) update account authentication keys but fail to update the `OriginatingAddress` table. This breaks the wallet recovery mechanism for keyless accounts and passkey users, leading to permanent loss of account access when users attempt recovery after key rotation.

## Finding Description

The Aptos account system maintains a global `OriginatingAddress` resource at `@aptos_framework` that maps rotated authentication keys to their original account addresses, enabling wallet recovery after key rotation. [1](#0-0) 

The standard key rotation function `rotate_authentication_key` properly maintains this mapping by calling `update_auth_key_and_originating_address_table`. [2](#0-1)  This function updates the table by removing old mappings and adding new authentication key to original address mappings. [3](#0-2) 

However, two alternative rotation functions designed for non-standard signature schemes do NOT update the `OriginatingAddress` table:

**Vulnerable Function #1: `rotate_authentication_key_from_public_key`**

This function explicitly documents that it does not update the `OriginatingAddress` table. [4](#0-3)  The function derives a new authentication key from the provided public key, calls `rotate_authentication_key_call` which only updates the account's authentication key field without touching the `OriginatingAddress` table. [5](#0-4) 

**Vulnerable Function #2: `upsert_ed25519_backup_key_on_keyless_account`**

This function creates a multi-key combining the keyless public key with an ED25519 backup key, calls `rotate_authentication_key_call` to update the authentication key, but does NOT update the `OriginatingAddress` table. [6](#0-5) 

Both functions call `rotate_authentication_key_call`, which explicitly does not update the `OriginatingAddress` table. [7](#0-6)  This function only calls `rotate_authentication_key_internal`, which updates the authentication key field but nothing else. [8](#0-7) 

**Critical Failure: Remediation Function is Disabled**

The documentation suggests using `set_originating_address()` to manually update the table after using these rotation functions. However, this function is permanently disabled and immediately aborts with error code `ESET_ORIGINATING_ADDRESS_DISABLED`. [9](#0-8)  The error constant documents this is "disabled due to potential poisoning from account abstraction". [10](#0-9) 

**Account Recovery Mechanism Breaks**

The `originating_address()` view function is used by wallets to look up the original address from a rotated authentication key. When the `OriginatingAddress` table doesn't contain the mapping, it returns `option::none()`. [11](#0-10) 

The wallet SDK's `derive_keyless_account` function calls `rest_client.lookup_address()` with the derived authentication key to find the actual on-chain account address. [12](#0-11) 

The `lookup_address` REST client function queries the `OriginatingAddress` table to map authentication keys to account addresses. [13](#0-12)  When the table item is not found (because it was never added after rotation), it returns the authentication key itself as the address. [14](#0-13) 

**Attack Scenario:**
1. User creates keyless account at address `0xALICE` with initial authentication key `0xALICE`
2. User calls `upsert_ed25519_backup_key_on_keyless_account` to add backup key, rotating to new authentication key `0xNEW_KEY`
3. The function updates `Account.authentication_key = 0xNEW_KEY` and emits `KeyRotationToPublicKey` event
4. The `OriginatingAddress` table is NOT updated (no entry `0xNEW_KEY â†’ 0xALICE` created)
5. User loses device and attempts recovery with their JWT credentials and backup key
6. Wallet SDK derives authentication key `0xNEW_KEY` from credentials
7. SDK calls `lookup_address(0xNEW_KEY)` to find account address
8. Query to `OriginatingAddress` table returns no mapping, so `lookup_address` returns `0xNEW_KEY`
9. SDK attempts to access account at `0xNEW_KEY`, which does not exist (actual account is at `0xALICE`)
10. **User permanently loses access to account at address `0xALICE` and all funds**

## Impact Explanation

**Critical Severity** - This qualifies as "Permanent freezing of funds (requires hardfork)" per Aptos bug bounty criteria:

- Users who rotate keys using these functions permanently lose the ability to recover their accounts through the standard wallet recovery mechanism
- The `OriginatingAddress` table is the ONLY mechanism in the wallet SDK for mapping rotated authentication keys back to original addresses during recovery
- Without this mapping, wallet recovery is impossible - the SDK cannot determine which account address corresponds to the rotated authentication key
- The remediation function `set_originating_address()` is permanently disabled, providing no recovery path for affected users
- This affects all keyless account and passkey users who use these rotation functions - a growing user demographic that Aptos actively promotes
- Funds become permanently inaccessible at the original address, requiring a hardfork or manual intervention to restore access
- The vulnerability creates a permanent state inconsistency where the on-chain account has a rotated key but the recovery infrastructure lacks the mapping needed to find that account

## Likelihood Explanation

**High Likelihood:**

- Keyless accounts and passkey authentication are actively promoted features in Aptos ecosystem
- These vulnerable functions are the ONLY way for keyless/passkey users to rotate keys, as they cannot use the standard `rotate_authentication_key` function which requires proof-of-knowledge signatures that non-standard schemes cannot produce
- Users naturally rotate keys for legitimate security reasons (compromised keys, security hardening, upgrading from keyless to backup key authentication)
- The vulnerability triggers automatically during legitimate usage - no attacker action required
- Users unknowingly break their own recovery capability by performing a security operation (key rotation) that appears to succeed
- The documentation incorrectly suggests using `set_originating_address()` as a fix, but that function is disabled - users following the documentation will still be affected
- Every keyless/passkey user who rotates keys using these functions becomes vulnerable to permanent account loss

## Recommendation

Modify both `rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account` to update the `OriginatingAddress` table after rotating the authentication key. This can be done by:

1. Acquire the `OriginatingAddress` resource in the function signature
2. After calling `rotate_authentication_key_call`, manually update the `OriginatingAddress` table by adding the new mapping
3. Alternatively, create a new internal function similar to `update_auth_key_and_originating_address_table` that can be called by these functions

Since the new authentication key is not verified with a proof-of-knowledge, additional security considerations may be needed to prevent the account abstraction poisoning attack mentioned in the `ESET_ORIGINATING_ADDRESS_DISABLED` error message.

## Proof of Concept

The existing test `test_add_ed25519_backup_key_to_keyless_account` demonstrates the key rotation but does not verify the `OriginatingAddress` table update. [15](#0-14) 

A complete proof of concept would extend this test to:
1. Create a keyless account at address A
2. Call `upsert_ed25519_backup_key_on_keyless_account` to rotate to auth key B
3. Verify that `Account[A].authentication_key == B`
4. Call `originating_address(B)` and verify it returns `option::none()` (BUG: should return `option::some(A)`)
5. Demonstrate that wallet recovery using the SDK would fail to find the account at address A

## Notes

This vulnerability demonstrates a critical gap between the on-chain state management and the off-chain recovery infrastructure. While the authentication key is properly updated on-chain, the recovery mechanism used by wallets relies on the `OriginatingAddress` table which is not maintained for these non-standard key rotation functions. The disabled remediation function leaves no recovery path for affected users.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L103-105)
```text
    struct OriginatingAddress has key {
        address_map: Table<address, address>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L221-222)
```text
    /// The set_originating_address is disabled due to potential poisoning from account abstraction
    const ESET_ORIGINATING_ADDRESS_DISABLED: u64 = 27;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L395-401)
```text
    public fun originating_address(auth_key: address): Option<address> acquires OriginatingAddress {
        let address_map_ref = &OriginatingAddress[@aptos_framework].address_map;
        if (address_map_ref.contains(auth_key)) {
            option::some(*address_map_ref.borrow(auth_key))
        } else {
            option::none()
        }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L440-450)
```text
    public(friend) fun rotate_authentication_key_internal(account: &signer, new_auth_key: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        assert!(
            new_auth_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );
        check_rotation_permission(account);
        let account_resource = &mut Account[addr];
        account_resource.authentication_key = new_auth_key;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L452-462)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    ///
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
    /// `set_originating_address()`.
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L468-496)
```text
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        let account_resource = &Account[addr];
        let old_auth_key = account_resource.authentication_key;
        let new_auth_key;
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == SINGLE_KEY_SCHEME) {
            new_auth_key = single_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else if (scheme == MULTI_KEY_SCHEME) {
            new_auth_key = multi_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else {
            abort error::invalid_argument(EUNRECOGNIZED_SCHEME)
        };
        rotate_authentication_key_call(account, new_auth_key);
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L520-574)
```text
    entry fun upsert_ed25519_backup_key_on_keyless_account(account: &signer, keyless_public_key: vector<u8>, backup_public_key: vector<u8>, backup_key_proof: vector<u8>) acquires Account {
        // Check that the provided public key is a keyless public key
        let keyless_single_key = single_key::new_public_key_from_bytes(keyless_public_key);
        assert!(single_key::is_keyless_or_federated_keyless_public_key(&keyless_single_key), error::invalid_argument(ENOT_A_KEYLESS_PUBLIC_KEY));

        let addr = signer::address_of(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;

        // Check that the provided public key is original public key of the account by comparing
        // its authentication key to the account address.
        assert!(
            bcs::to_bytes(&addr) == keyless_single_key.to_authentication_key(),
            error::invalid_argument(ENOT_THE_ORIGINAL_PUBLIC_KEY)
        );

        let curr_auth_key_as_address = from_bcs::to_address(old_auth_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: backup_public_key,
        };

        // Assert the challenges signed by the provided backup key is valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            ED25519_SCHEME,
            backup_public_key,
            backup_key_proof,
            &challenge
        );

        // Get the backup key as a single key
        let backup_key_ed25519 = ed25519::new_unvalidated_public_key_from_bytes(backup_public_key);
        let backup_key_as_single_key = single_key::from_ed25519_public_key_unvalidated(backup_key_ed25519);

        let new_public_key = multi_key::new_multi_key_from_single_keys(vector[keyless_single_key, backup_key_as_single_key], 1);
        let new_auth_key = new_public_key.to_authentication_key();

        // Rotate the authentication key to the new multi key public key
        rotate_authentication_key_call(account, new_auth_key);

        event::emit(KeyRotationToPublicKey {
            account: addr,
            // This marks that both the keyless public key and the new backup key are verified
            // The keyless public key is the original public key of the account and the new backup key
            // has been validated via verifying the challenge signed by the new backup key.
            // Represents the bitmap 0b11000000000000000000000000000000
            verified_public_key_bit_map: vector[0xC0, 0x00, 0x00, 0x00],
            public_key_scheme: MULTI_KEY_SCHEME,
            public_key: bcs::to_bytes(&new_public_key),
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L661-661)
```text
        update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L832-833)
```text
    entry fun set_originating_address(_account: &signer) acquires Account, OriginatingAddress {
        abort error::invalid_state(ESET_ORIGINATING_ADDRESS_DISABLED);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1044-1101)
```text
    fun update_auth_key_and_originating_address_table(
        originating_addr: address,
        account_resource: &mut Account,
        new_auth_key_vector: vector<u8>,
    ) acquires OriginatingAddress {
        let address_map = &mut OriginatingAddress[@aptos_framework].address_map;
        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);
        let new_auth_key = from_bcs::to_address(new_auth_key_vector);
        assert!(
            new_auth_key != curr_auth_key,
            error::invalid_argument(ENEW_AUTH_KEY_SAME_AS_CURRENT)
        );

        // Checks `OriginatingAddress[curr_auth_key]` is either unmapped, or mapped to `originating_address`.
        // If it's mapped to the originating address, removes that mapping.
        // Otherwise, abort if it's mapped to a different address.
        if (address_map.contains(curr_auth_key)) {
            // If account_a with address_a is rotating its keypair from keypair_a to keypair_b, we expect
            // the address of the account to stay the same, while its keypair updates to keypair_b.
            // Here, by asserting that we're calling from the account with the originating address, we enforce
            // the standard of keeping the same address and updating the keypair at the contract level.
            // Without this assertion, the dapps could also update the account's address to address_b (the address that
            // is programmatically related to keypaier_b) and update the keypair to keypair_b. This causes problems
            // for interoperability because different dapps can implement this in different ways.
            // If the account with address b calls this function with two valid signatures, it will abort at this step,
            // because address b is not the account's originating address.
            assert!(
                originating_addr == address_map.remove(curr_auth_key),
                error::not_found(EINVALID_ORIGINATING_ADDRESS)
            );
        };

        // Set `OriginatingAddress[new_auth_key] = originating_address`.
        assert!(
            !address_map.contains(new_auth_key),
            error::invalid_argument(ENEW_AUTH_KEY_ALREADY_MAPPED)
        );
        address_map.add(new_auth_key, originating_addr);

        if (std::features::module_event_migration_enabled()) {
            event::emit(KeyRotation {
                account: originating_addr,
                old_authentication_key: account_resource.authentication_key,
                new_authentication_key: new_auth_key_vector,
            });
        } else {
            event::emit_event<KeyRotationEvent>(
                &mut account_resource.key_rotation_events,
                KeyRotationEvent {
                    old_authentication_key: account_resource.authentication_key,
                    new_authentication_key: new_auth_key_vector,
                }
            );
        };

        // Update the account resource's authentication key.
        account_resource.authentication_key = new_auth_key_vector;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L2026-2058)
```text
    public entry fun test_add_ed25519_backup_key_to_keyless_account(
        account: signer
    ) acquires Account {
        initialize(&account);
        let keyless_pk_bytes: vector<u8> = x"031b68747470733a2f2f6163636f756e74732e676f6f676c652e636f6d2086bc0a0a825eb6337ca1e8a3157e490eac8df23d5cef25d9641ad5e7edc1d514";
        let curr_pk = single_key::new_public_key_from_bytes(keyless_pk_bytes);
        let alice_addr = from_bcs::to_address(curr_pk.to_authentication_key());
        let alice = create_account_unchecked(alice_addr);

        let (new_sk, new_pk) = ed25519::generate_keys();

        let challenge = RotationProofChallenge {
            sequence_number: Account[alice_addr].sequence_number,
            originator: alice_addr,
            current_auth_key: alice_addr,
            new_public_key: ed25519::validated_public_key_to_bytes(&new_pk),
        };

        let new_pk_unvalidated = ed25519::public_key_to_unvalidated(&new_pk);
        let backup_key_as_single_key = single_key::from_ed25519_public_key_unvalidated(new_pk_unvalidated);
        let new_public_key = multi_key::new_multi_key_from_single_keys(vector[curr_pk, backup_key_as_single_key], 1);
        let new_auth_key = new_public_key.to_authentication_key();

        let to_sig = ed25519::sign_struct(&new_sk, challenge);

        upsert_ed25519_backup_key_on_keyless_account(
            &alice,
            keyless_pk_bytes,
            ed25519::validated_public_key_to_bytes(&new_pk),
            ed25519::signature_to_bytes(&to_sig),
        );
        assert!(Account[alice_addr].authentication_key == new_auth_key, 0);
    }
```

**File:** aptos-move/framework/aptos-framework/doc/account.md (L1717-1717)
```markdown
Note: This function does not update the <code><a href="account.md#0x1_account_OriginatingAddress">OriginatingAddress</a></code> table.
```

**File:** sdk/src/types.rs (L1098-1100)
```rust
    let address = rest_client
        .lookup_address(account.authentication_key().account_address(), false)
        .await?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L270-289)
```rust
    pub async fn lookup_address(
        &self,
        address_key: AccountAddress,
        must_exist: bool,
    ) -> AptosResult<Response<AccountAddress>> {
        let originating_address_table: Response<OriginatingAddress> = self
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::account::OriginatingAddress")
            .await?;

        let table_handle = originating_address_table.inner().address_map.handle;

        // The derived address that can be used to look up the original address
        match self
            .get_table_item_bcs(
                table_handle,
                "address",
                "address",
                address_key.to_hex_literal(),
            )
            .await
```

**File:** crates/aptos-rest-client/src/lib.rs (L299-305)
```rust
            })) => {
                // If the table item wasn't found, we may check if the account exists
                if !must_exist {
                    Ok(Response::new(
                        address_key,
                        originating_address_table.state().clone(),
                    ))
```
