# Audit Report

## Title
Unmetered Memory Allocation in Reflection Native Function Enables Resource Exhaustion Attack

## Summary
The `identifier_from_string()` helper function in the reflection native implementation performs unconditional memory cloning of string byte vectors without charging proportional gas or tracking memory usage. This allows attackers to trigger large memory allocations while paying only a fixed 4096 gas units, violating Move VM safety invariants and enabling resource exhaustion attacks against validator nodes.

## Finding Description

The vulnerability exists in the native implementation of the `std::reflect::resolve()` function. When invoked, it calls the native `native_resolve()` implementation which charges only a fixed base gas cost: [1](#0-0) 

The gas cost is defined as 4096 internal gas units: [2](#0-1) 

The function calls `identifier_from_string()` twice to process the module name and function name string arguments: [3](#0-2) 

The critical flaw is in `identifier_from_string()` which unconditionally clones the entire byte vector via `to_vec()` without any memory tracking or size-dependent gas charging: [4](#0-3) 

Crucially, the memory clone at line 77 occurs BEFORE the identifier validation at line 78, meaning even invalid identifiers trigger the full memory allocation.

This violates the established pattern used by other native functions. For comparison, table natives properly track memory allocations using the `use_heap_memory()` API: [5](#0-4) 

The `SafeNativeContext` provides the `use_heap_memory()` method specifically for tracking native memory allocations and enforcing memory quotas: [6](#0-5) 

**Attack Vector:**

1. Attacker creates a transaction with large string arguments up to the transaction size limits defined in gas parameters: [7](#0-6) 

2. Calls `std::reflect::resolve(@0x1, large_module_name, large_func_name)` with strings approaching the transaction size limit (65,536 bytes for normal transactions, 1,048,576 bytes for governance)
3. Native function charges only 4096 gas units regardless of string size
4. Two separate `to_vec()` calls allocate memory for both strings without tracking
5. Even though identifier validation eventually fails (identifiers have strict syntax rules), the memory clone already occurred
6. Attacker can repeat this in a loop or submit many concurrent transactions to amplify the effect

**Invariant Violations:**
- **Move VM Safety**: Native functions must track heap memory usage - violated by untracked allocations
- **Gas Metering**: Operations must charge gas proportional to work performed - violated by O(n) work charged as O(1)
- **Resource Limits**: Memory allocations must respect VM memory quotas - violated by bypassing `use_heap_memory()` tracking

## Impact Explanation

**Severity: Medium**

This vulnerability meets the Medium severity criteria because:

1. **Resource Exhaustion**: Attackers can allocate significant memory (up to ~128KB per call with two ~64KB strings in normal transactions) with minimal gas cost (4096 units), enabling resource exhaustion through concurrent transactions or loops within a single transaction.

2. **Gas Metering Bypass**: The function performs O(n) work (cloning n bytes twice) but charges O(1) gas, creating a severe imbalance where attackers receive disproportionate computational work per gas unit compared to properly metered operations.

3. **Memory Quota Circumvention**: Native allocations bypass the Move VM's memory tracking system designed to prevent resource exhaustion, as evidenced by the proper pattern used in table natives.

4. **Limited Scope**: Impact is constrained because:
   - Requires the `FUNCTION_REFLECTION` feature flag to be enabled, which is included in the default features: [8](#0-7) [9](#0-8) 

   - Memory is eventually deallocated after function returns
   - Does not directly cause consensus divergence or fund loss
   - Limited to nodes processing the malicious transactions

The vulnerability represents a clear protocol violation enabling resource exhaustion but does not reach High/Critical severity as it doesn't enable fund theft, consensus violations, or permanent network damage.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:

1. **Low Complexity**: Attacker only needs to submit a standard transaction calling the public `std::reflect::resolve()` API with large string arguments as shown in the Move interface: [10](#0-9) 

2. **No Special Privileges**: Any account can execute this attack without requiring validator or governance permissions

3. **Feature Flag Dependency**: Attack only works when `FUNCTION_REFLECTION` feature flag is enabled on-chain, which is enabled by default in the current codebase

4. **Amplification**: Attacker can call this in a loop or submit many concurrent transactions to multiply the resource exhaustion effect

5. **Cost-Effective**: Attacker pays minimal gas (4096 units per call) relative to memory resources consumed (~64-128KB per call)

The likelihood is HIGH once the feature flag is enabled, as the attack requires no special knowledge beyond reading the public API documentation.

## Recommendation

The issue can be fixed by adding proper memory tracking to the `identifier_from_string()` function:

1. Calculate the size of the byte vector before cloning
2. Call `context.use_heap_memory(size)` to track the allocation against memory quotas
3. Alternatively, charge gas proportional to the string size

The fix should follow the pattern used by table natives which properly track heap memory allocations.

## Proof of Concept

A Move test demonstrating the vulnerability would create a transaction calling `std::reflect::resolve()` with maximum-sized string arguments (64KB each) in a loop, showing that only fixed gas is charged regardless of string size while large memory allocations occur. The test would demonstrate that the gas cost remains constant at 4096 per call despite allocating ~128KB of memory per call, violating the principle of proportional gas metering.

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L32-32)
```rust
    context.charge(REFLECT_RESOLVE_BASE)?;
```

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L43-48)
```rust
    let Some(fun_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
    let Some(mod_name) = identifier_from_string(safely_pop_arg!(args))? else {
        return Ok(smallvec![result::err_result(pack_err(INVALID_IDENTIFIER))]);
    };
```

**File:** aptos-move/framework/move-stdlib/src/natives/reflect.rs (L70-79)
```rust
fn identifier_from_string(v: Value) -> SafeNativeResult<Option<Identifier>> {
    let bytes = v
        .value_as::<StructRef>()
        .and_then(|s| s.borrow_field(0))
        .and_then(|v| v.value_as::<VectorRef>())
        .map_err(SafeNativeError::InvariantViolation)?
        .as_bytes_ref()
        .to_vec();
    Ok(Identifier::from_utf8(bytes).ok())
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L363-363)
```rust
        [reflect_resolve_base: InternalGas, { RELEASE_V1_39.. => "reflect.resolve_base" }, 4096],
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L439-441)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** types/src/on_chain_config/aptos_features.rs (L163-163)
```rust
    ENABLE_FUNCTION_REFLECTION = 105,
```

**File:** types/src/on_chain_config/aptos_features.rs (L273-273)
```rust
            FeatureFlag::ENABLE_FUNCTION_REFLECTION,
```

**File:** aptos-move/framework/move-stdlib/sources/reflect.move (L31-39)
```text
    public fun resolve<FuncType>(
        addr: address, module_name: &String, func_name: &String
    ): Result<FuncType, ReflectionError> {
        assert!(
            features::is_function_reflection_enabled(),
            error::invalid_state(E_FEATURE_NOT_ENABLED)
        );
        native_resolve(addr, module_name, func_name)
    }
```
