# Audit Report

## Title
Signature Bypass in RoundTimeout Verification Allows Timeout Reason Manipulation

## Summary
The `verify()` method in `RoundTimeout` does not validate that the cryptographic signature covers the `reason` field, allowing Byzantine validators to inject arbitrary timeout reasons that pass verification and manipulate consensus liveness behavior.

## Finding Description

The `RoundTimeout` struct contains four fields: `timeout`, `author`, `reason`, and `signature`. [1](#0-0) 

The `verify()` method only validates that the signature covers `self.timeout.signing_format()`, which returns a `TimeoutSigningRepr` containing only `epoch`, `round`, and `hqc_round`. [2](#0-1) 

The `TimeoutSigningRepr` structure explicitly excludes the `reason` field from signature coverage, containing only epoch, round, and hqc_round. [3](#0-2) [4](#0-3) 

This breaks the cryptographic correctness invariant: the signature does not cover all security-relevant fields. A Byzantine validator can:

1. Create a legitimate `RoundTimeout` for their local timeout
2. Sign it using `TwoChainTimeout.sign()` (signature covers only epoch/round/hqc_round) [5](#0-4) 
3. Replace the `reason` field with malicious data (e.g., `PayloadUnavailable { missing_authors: <targeted_validators> }`)
4. Broadcast the modified message

The modified message passes verification because `verify()` only checks the signature validity for the `timeout` component, not the `reason` field.

The `reason` field has significant behavioral impact:

**Timeout Reason Aggregation**: When forming a timeout certificate, validators aggregate timeout reasons by voting power, and the reason with f+1 voting power becomes the consensus reason. [6](#0-5) 

**Failure Tracking**: The `ExponentialWindowFailureTracker` treats `PayloadUnavailable` timeouts specially - they trigger exponential window growth (doubling up to max_window) and exclude authors listed in `missing_authors` from optimistic proposal generation. [7](#0-6) [8](#0-7) 

Other timeout reasons (`ProposalNotReceived`, `NoQC`, `Unknown`) are treated as successes and do not trigger window growth penalties. [9](#0-8) 

When a validator creates a timeout, the signature is generated before the reason is computed and both are passed separately to `RoundTimeout::new()`. [10](#0-9) 

## Impact Explanation

**Severity: High** (Significant protocol violation affecting consensus liveness)

A Byzantine validator can:
- Inject fabricated `PayloadUnavailable` reasons claiming arbitrary validators failed to provide payload
- Manipulate timeout reason aggregation weighted by their voting power
- If they control f+1 voting power, force the aggregated reason to be their malicious `PayloadUnavailable`
- Trigger exponential backoff in the failure tracker (doubling window from 2 to max_window of 100)
- Cause honest validators to be excluded from optimistic proposal generation

This constitutes a **significant protocol violation** affecting consensus liveness behavior. While it does not directly cause consensus safety violations (no double-spending or chain splits) or total network failure, it allows manipulation of the timeout mechanism and degradation of proposal efficiency, which can impact network performance and unfairly penalize honest validators.

The attack does not require network-level capabilities - a single Byzantine validator can exploit this by manipulating their own timeout messages before broadcasting.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - a Byzantine validator simply modifies the `reason` field after signing but before broadcasting
- **Attacker Requirements**: Requires being a validator with voting power; impact scales with controlled voting power
- **Detection Difficulty**: Hard to detect - manipulated messages pass cryptographic verification and appear legitimate
- **Preconditions**: Requires timeout scenarios, which naturally occur during network delays, slow proposals, or actual payload unavailability

The vulnerability exists in every round timeout scenario and is exploitable by any Byzantine validator with sufficient voting power to influence aggregation (f+1).

## Recommendation

Include the `reason` field in the signed data structure. Modify `TimeoutSigningRepr` to include the timeout reason:

```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
    pub reason: RoundTimeoutReason, // Add this field
}
```

Update `TwoChainTimeout::signing_format()` to include the reason parameter, and modify `RoundTimeout` creation flow to compute the reason before signing rather than after.

Alternatively, have the `RoundTimeout` struct compute its own signature including all fields, or use a separate signature specifically for the reason field that gets verified alongside the timeout signature.

## Proof of Concept

A Byzantine validator can execute this attack by:

1. Creating a legitimate `TwoChainTimeout` for round N
2. Signing it to get a valid signature (covers epoch/round/hqc_round only)
3. Computing a fabricated reason: `PayloadUnavailable { missing_authors: BitVec targeting honest validators }`
4. Constructing `RoundTimeout::new(timeout, author, fabricated_reason, signature)`
5. Broadcasting this message

The receiving validators will call `RoundTimeoutMsg::verify()` which calls `RoundTimeout::verify()`, which only checks the signature against the timeout's signing format (epoch/round/hqc_round), not the reason field. The fabricated reason will be accepted and used in timeout reason aggregation and failure tracking.

## Notes

This vulnerability represents a fundamental cryptographic correctness issue where a security-relevant field (`reason`) is not covered by the authentication mechanism. The impact is limited to liveness and performance degradation rather than safety violations, but it still represents a significant protocol weakness that allows Byzantine validators to manipulate consensus behavior beyond what the BFT protocol should tolerate.

### Citations

**File:** consensus/consensus-types/src/round_timeout.rs (L37-45)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct RoundTimeout {
    // The timeout
    timeout: TwoChainTimeout,
    author: Author,
    reason: RoundTimeoutReason,
    /// Signature on the Timeout
    signature: bls12381::Signature,
}
```

**File:** consensus/consensus-types/src/round_timeout.rs (L97-107)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        self.timeout.verify(validator)?;
        validator
            .verify(
                self.author(),
                &self.timeout.signing_format(),
                &self.signature,
            )
            .context("Failed to verify 2-chain timeout signature")?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L59-64)
```rust
    pub fn sign(
        &self,
        signer: &ValidatorSigner,
    ) -> Result<bls12381::Signature, CryptoMaterialError> {
        signer.sign(&self.signing_format())
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L98-103)
```rust
#[derive(Serialize, Deserialize, Debug, CryptoHasher, BCSCryptoHash)]
pub struct TimeoutSigningRepr {
    pub epoch: u64,
    pub round: Round,
    pub hqc_round: Round,
}
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/round_manager.rs (L1014-1030)
```rust
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;

                let timeout_reason = self.compute_timeout_reason(round);

                RoundTimeout::new(
                    timeout,
                    self.proposal_generator.author(),
                    timeout_reason,
                    signature,
                )
```
