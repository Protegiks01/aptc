# Audit Report

## Title
Silent Transaction Verification Bypass in `verify_execution()` Due to Non-Equal Length Iterator Handling

## Summary
The `verify_execution()` function in the chunk executor uses `multizip` instead of `zip_eq` when verifying re-executed transactions against historical data. This allows transactions flagged with `Retry` or `Discard` status during re-execution to bypass verification entirely, while still being applied to state using historical data. This breaks the fundamental guarantee of replay verification and can lead to consensus divergence.

## Finding Description

The vulnerability exists in the transaction replay verification workflow used during state synchronization and backup restoration operations.

**The Vulnerable Code Flow:**

The `verify_execution()` function re-executes a range of historical transactions and compares the results against stored transaction outputs. It uses `multizip` to iterate over five parallel collections: [1](#0-0) 

The critical comment `"not zip_eq, deliberately"` indicates this design choice is intentional, but no safeguard exists for length mismatches.

**How the Vulnerability Works:**

1. **VM Re-Execution Phase**: Transactions are re-executed via `DoGetExecutionOutput::by_transaction_execution()`: [2](#0-1) 

2. **Transaction Filtering**: If VM execution produces different results than the original execution (due to epoch boundary detection, VM non-determinism, or state inconsistencies), some transactions receive `TransactionStatus::Retry` or `TransactionStatus::Discard`: [3](#0-2) 

3. **Retry/Discard Removal**: These transactions are removed from `to_commit` by `extract_retries_and_discards()`: [4](#0-3) 

This makes `execution_output.to_commit.transaction_outputs` shorter than the expected `(end_version - begin_version)` count.

4. **Silent Early Termination**: The `multizip` loop terminates when the shortest iterator (the reduced `to_commit.transaction_outputs`) is exhausted, verifying only a subset of transactions: [5](#0-4) 

5. **False Success Return**: The function returns `Ok(end_version)` regardless of how many transactions were actually verified: [6](#0-5) 

6. **Unverified Transaction Application**: The caller `remove_and_replay_epoch()` uses this return value to drain the full range of transactions: [7](#0-6) 

7. **State Application Without VM Verification**: `remove_and_apply()` creates transaction outputs from historical data (not from VM execution) and applies them: [8](#0-7) 

The transaction outputs are created directly from stored `transaction_infos` without VM re-execution, then applied via `ChunkToApply::into_output()` which calls `DoGetExecutionOutput::by_transaction_output()`: [9](#0-8) 

**Why Existing Safeguards Fail:**

The `ensure_transaction_infos_match()` check that occurs later compares lengths: [10](#0-9) 

However, this check passes because both sides have the full transaction count - the applied outputs were created from the full set of stored transaction_infos, not from the VM execution results.

**Triggering Scenarios:**

1. **Epoch Boundary Mismatch**: If `event_vecs` is corrupted or the epoch detection at lines 464-470 fails, but VM re-execution correctly detects reconfiguration and produces `SkipRest` status: [11](#0-10) 

The VM produces `SkipRest` when it detects reconfiguration: [12](#0-11) 

Which results in `TransactionStatus::Retry`: [13](#0-12) 

2. **VM Non-Determinism**: Any VM bug causing different execution results during replay.

3. **State Inconsistencies**: If the replay state differs from the original execution state.

This vulnerability is actively used in production for replay verification and backup restoration: [14](#0-13) 

## Impact Explanation

**Severity: Critical**

This vulnerability meets the Critical severity criteria for **Consensus/Safety Violations** and **Non-recoverable Network Partition**:

1. **Consensus Divergence**: If different validator nodes experience different VM behavior during replay (due to timing-dependent bugs, hardware differences, or race conditions), they will silently accept different state transitions. The VM's detection of issues (via Retry/Discard status) is ignored, and historical data is applied regardless. This violates consensus safety guarantees.

2. **State Corruption Without Detection**: The core verification mechanism is bypassed. Transactions that the VM flagged as problematic are still committed to state using historical outputs, breaking the deterministic execution guarantee.

3. **Non-Recoverable**: Once divergent state is committed across different nodes, reconciliation requires a hard fork. Different nodes will have different state roots for the same version.

4. **State Sync Attack Vector**: During state synchronization, if provided data triggers VM execution differences, receiving nodes will commit unverified state transitions.

This directly maps to the Critical severity category: "Different validators commit different blocks" and "Chain splits without hardfork requirement."

## Likelihood Explanation

**Likelihood: Medium**

While the vulnerability requires a triggering condition, multiple realistic scenarios exist:

1. **Epoch Boundary Corruption**: Database corruption or state sync errors could cause `event_vecs` to not match actual transaction events, causing epoch detection to fail while VM re-execution succeeds.

2. **VM Non-Determinism Bugs**: Any future VM bug introducing non-determinism would trigger this silently.

3. **Production Usage**: This code path is actively used in production for backup restoration and replay verification operations, increasing exposure.

4. **Intentional Design**: The "deliberately" comment at line 628 suggests developers knew about the behavior but did not add proper length validation, indicating this edge case may not be well-tested.

The likelihood is not "High" because it requires a triggering condition (VM producing different results), but it's elevated from "Low" because multiple realistic scenarios can trigger it, and the code is in active production use.

## Recommendation

Replace `multizip` with `zip_eq` to enforce equal-length iterators, or add explicit length validation before and after the verification loop:

```rust
// Before the loop
ensure!(
    execution_output.to_commit.transaction_outputs.len() == (end_version - begin_version) as usize,
    "VM re-execution produced {} outputs but expected {} transactions",
    execution_output.to_commit.transaction_outputs.len(),
    end_version - begin_version
);

// Use zip_eq instead of multizip, or keep multizip with post-loop validation
for (version, txn_out, txn_info, write_set, events) in multizip((
    begin_version..end_version,
    &execution_output.to_commit.transaction_outputs,
    transaction_infos.iter(),
    write_sets.iter(),
    event_vecs.iter(),
)) {
    // existing verification logic
}
```

Additionally, consider whether transactions with `Retry` status should immediately fail verification rather than being silently filtered out, since their presence during replay indicates a mismatch between expected and actual VM behavior.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Create a chunk of 10 transactions where transaction 9 triggers an epoch change
2. Corrupt the `event_vecs` so epoch boundary detection fails (e.g., remove the new epoch event)
3. Call `verify_execution()` with the full range [version, version+10)
4. The epoch detection loop at lines 464-470 fails to split at transaction 9
5. VM re-execution detects the reconfiguration at transaction 9, produces `SkipRest` status for transactions 9-10
6. These transactions get `Retry` status and are removed from `to_commit`
7. The `multizip` loop only verifies transactions 0-8
8. Function returns `Ok(version+10)` claiming all 10 verified
9. `remove_and_apply()` drains all 10 transactions and applies them using historical data
10. Transactions 9-10 are committed without VM verification

A full Rust test would require mocking the VM to produce `Retry` status for specific transactions and verifying that `verify_execution()` still returns success while `remove_and_apply()` commits all transactions.

## Notes

This is a logic vulnerability in the verification infrastructure itself, not in the VM or consensus layer. The issue is that the verification function claims success without ensuring all transactions in the requested range were actually verified. The "deliberately" comment suggests this behavior may be intentional for some use case, but no documentation or safeguards exist to prevent the security implications described above.

### Citations

**File:** execution/executor/src/chunk_executor/mod.rs (L464-473)
```rust
        for (version, events) in multizip((chunk_begin..chunk_end, event_vecs.iter())) {
            let is_epoch_ending = events.iter().any(ContractEvent::is_new_epoch_event);
            if is_epoch_ending {
                epochs.push((epoch_begin, version + 1));
                epoch_begin = version + 1;
            }
        }
        if epoch_begin < chunk_end {
            epochs.push((epoch_begin, chunk_end));
        }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-586)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
            self.remove_and_apply(
                transactions,
                persisted_aux_info,
                transaction_infos,
                write_sets,
                event_vecs,
                batch_begin,
                next_begin,
            )?;
            chunks_enqueued += 1;
            batch_begin = next_begin;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L619-627)
```rust
        let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
            &V::new(),
            txns.into(),
            auxiliary_info,
            &parent_state,
            state_view,
            BlockExecutorConfigFromOnchain::new_no_block_limit(),
            TransactionSliceMetadata::chunk(begin_version, end_version),
        )?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L628-635)
```rust
        // not `zip_eq`, deliberately
        for (version, txn_out, txn_info, write_set, events) in multizip((
            begin_version..end_version,
            &execution_output.to_commit.transaction_outputs,
            transaction_infos.iter(),
            write_sets.iter(),
            event_vecs.iter(),
        )) {
```

**File:** execution/executor/src/chunk_executor/mod.rs (L636-650)
```rust
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
                return if verify_execution_mode.is_lazy_quit() {
                    error!("(Not quitting right away.) {}", err);
                    verify_execution_mode.mark_seen_error();
                    Ok(version + 1)
                } else {
                    Err(err)
                };
            }
        }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L651-652)
```rust
        Ok(end_version)
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L666-701)
```rust
        let num_txns = (end_version - begin_version) as usize;
        let txn_infos: Vec<_> = transaction_infos.drain(..num_txns).collect();
        let (transactions, persisted_aux_info, transaction_outputs) = multizip((
            transactions.drain(..num_txns),
            persisted_aux_info.drain(..num_txns),
            txn_infos.iter(),
            write_sets.drain(..num_txns),
            event_vecs.drain(..num_txns),
        ))
        .map(|(txn, persisted_aux_info, txn_info, write_set, events)| {
            (
                txn,
                persisted_aux_info,
                TransactionOutput::new(
                    write_set,
                    events,
                    txn_info.gas_used(),
                    TransactionStatus::Keep(txn_info.status().clone()),
                    TransactionAuxiliaryData::default(), // No auxiliary data if transaction is not executed through VM
                ),
            )
        })
        .multiunzip();

        let chunk = ChunkToApply {
            transactions,
            transaction_outputs,
            persisted_aux_info,
            first_version: begin_version,
        };
        let chunk_verifier = Arc::new(ReplayChunkVerifier {
            transaction_infos: txn_infos,
        });
        self.enqueue_chunk(chunk, chunk_verifier, "replay")?;

        Ok(())
```

**File:** types/src/transaction/mod.rs (L1577-1587)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum TransactionStatus {
    /// Discard the transaction output
    Discard(DiscardedVMStatus),

    /// Keep the transaction output
    Keep(ExecutionStatus),

    /// Retry the transaction, e.g., after a reconfiguration
    Retry,
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L460-497)
```rust
    fn extract_retries_and_discards(
        transactions: &mut Vec<Transaction>,
        transaction_outputs: &mut Vec<TransactionOutput>,
        persisted_auxiliary_infos: &mut Vec<PersistedAuxiliaryInfo>,
    ) -> (TransactionsWithOutput, TransactionsWithOutput) {
        let _timer = OTHER_TIMERS.timer_with(&["parse_raw_output__retries_and_discards"]);

        let mut to_discard = TransactionsWithOutput::new_empty();
        let mut to_retry = TransactionsWithOutput::new_empty();

        let mut num_keep_txns = 0;

        for idx in 0..transactions.len() {
            match transaction_outputs[idx].status() {
                TransactionStatus::Keep(_) => {
                    if num_keep_txns != idx {
                        transactions[num_keep_txns] = transactions[idx].clone();
                        transaction_outputs[num_keep_txns] = transaction_outputs[idx].clone();
                        persisted_auxiliary_infos[num_keep_txns] = persisted_auxiliary_infos[idx];
                    }
                    num_keep_txns += 1;
                },
                TransactionStatus::Retry => to_retry.push(
                    transactions[idx].clone(),
                    transaction_outputs[idx].clone(),
                    persisted_auxiliary_infos[idx],
                ),
                TransactionStatus::Discard(_) => to_discard.push(
                    transactions[idx].clone(),
                    transaction_outputs[idx].clone(),
                    persisted_auxiliary_infos[idx],
                ),
            }
        }

        transactions.truncate(num_keep_txns);
        transaction_outputs.truncate(num_keep_txns);
        persisted_auxiliary_infos.truncate(num_keep_txns);
```

**File:** execution/executor/src/chunk_executor/transaction_chunk.rs (L132-154)
```rust
    fn into_output<V: VMBlockExecutor>(
        self,
        parent_state: &LedgerState,
        state_view: CachedStateView,
    ) -> Result<ExecutionOutput> {
        let Self {
            transactions,
            transaction_outputs,
            persisted_aux_info,
            first_version: _,
        } = self;

        DoGetExecutionOutput::by_transaction_output(
            transactions,
            transaction_outputs,
            persisted_aux_info
                .into_iter()
                .map(|info| AuxiliaryInfo::new(info, None))
                .collect(),
            parent_state,
            state_view,
        )
    }
```

**File:** execution/executor-types/src/ledger_update_output.rs (L90-99)
```rust
    pub fn ensure_transaction_infos_match(
        &self,
        transaction_infos: &[TransactionInfo],
    ) -> Result<()> {
        ensure!(
            self.transaction_infos.len() == transaction_infos.len(),
            "Lengths don't match. {} vs {}",
            self.transaction_infos.len(),
            transaction_infos.len(),
        );
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L85-90)
```rust
                } else if AptosVM::should_restart_execution(vm_output.events()) {
                    speculative_info!(
                        &log_context,
                        "Reconfiguration occurred: restart required".into()
                    );
                    ExecutionStatus::SkipRest(AptosTransactionOutput::new(vm_output))
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L377-381)
```rust
    /// Execution output for transactions that comes after SkipRest signal or when there was a
    /// problem creating the output (e.g. group serialization issue).
    fn skip_output() -> Self {
        Self::new(VMOutput::empty_with_status(TransactionStatus::Retry))
    }
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L44-82)
```rust
pub struct ReplayVerifyCoordinator {
    storage: Arc<dyn BackupStorage>,
    metadata_cache_opt: MetadataCacheOpt,
    trusted_waypoints_opt: TrustedWaypointOpt,
    concurrent_downloads: usize,
    replay_concurrency_level: usize,
    restore_handler: RestoreHandler,
    start_version: Version,
    end_version: Version,
    validate_modules: bool,
    verify_execution_mode: VerifyExecutionMode,
}

impl ReplayVerifyCoordinator {
    pub fn new(
        storage: Arc<dyn BackupStorage>,
        metadata_cache_opt: MetadataCacheOpt,
        trusted_waypoints_opt: TrustedWaypointOpt,
        concurrent_downloads: usize,
        replay_concurrency_level: usize,
        restore_handler: RestoreHandler,
        start_version: Version,
        end_version: Version,
        validate_modules: bool,
        verify_execution_mode: VerifyExecutionMode,
    ) -> Result<Self> {
        Ok(Self {
            storage,
            metadata_cache_opt,
            trusted_waypoints_opt,
            concurrent_downloads,
            replay_concurrency_level,
            restore_handler,
            start_version,
            end_version,
            validate_modules,
            verify_execution_mode,
        })
    }
```
