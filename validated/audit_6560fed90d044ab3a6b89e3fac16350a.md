# Audit Report

## Title
Version Monotonicity Violation in Fast Sync Storage: Duplicate Commit Vulnerability

## Summary
The `AptosDB.get_and_check_commit_range()` function uses a non-strict inequality (`>=`) instead of strict (`>`) when validating commit versions, allowing the same version to be committed multiple times. This violates the fundamental version monotonicity invariant required for blockchain correctness.

## Finding Description

The vulnerability exists in the version validation logic within the storage layer's commit path. The `FastSyncStorageWrapper` delegates commit operations to the underlying `AptosDB` without additional version validation: [1](#0-0) 

The critical flaw is in the `get_and_check_commit_range()` validation function, which performs version range checking before commits: [2](#0-1) 

At line 526, the check uses `version_to_commit >= old_committed_ver.unwrap()` instead of the strict `>` operator. This allows a version V to be committed even when `old_committed_ver == V`, violating strict monotonicity.

**Exploitation Scenario:**

After `finalize_state_snapshot(version=V)` completes:
- `OverallCommitProgress` is set to V [3](#0-2) 

- The state store is reset with `next_version = V+1` [4](#0-3) 

When `commit_ledger(V, ledger_info, None)` is subsequently called (as seen in the block executor): [5](#0-4) 

The validation logic evaluates:
- `old_committed_ver = get_synced_version() = Some(V)` [6](#0-5) 

- Check: `V >= V` evaluates to `true` (PASSES, but SHOULD FAIL)
- Check: `V <= V` evaluates to `true` (PASSES)

Both checks pass, allowing duplicate commits. The database writes proceed, potentially overwriting ledger info with different signatures: [7](#0-6) 

When `chunk_opt = None`, the `pre_commit_validation()` check (which enforces `chunk.first_version == next_version`) is bypassed, leaving only the flawed `>=` check as protection: [8](#0-7) 

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability aligns with the Aptos bug bounty's Medium severity category for "Limited Protocol Violations" due to:

1. **Database Integrity Violation**: The version monotonicity invariant is fundamental to blockchain correctness. Allowing duplicate commits at the same version violates this invariant.

2. **Ledger Info Corruption**: If `commit_ledger()` is called with a different `LedgerInfoWithSignatures` for the same version, the existing ledger info can be overwritten with different signatures, despite having the same root hash and epoch. This could lead to confusion about which signature set is canonical.

3. **State Synchronization Issues**: If the system repeatedly attempts to commit version V, forward progress could stall, requiring manual intervention to diagnose and resolve.

While defense-in-depth validations in `check_and_put_ledger_info()` provide some protection (root hash verification, epoch continuity checks), these do not prevent all problematic scenarios: [9](#0-8) 

The fundamental invariant violation remains exploitable in edge cases where these secondary checks pass.

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability requires specific coordination failures between internal components:

1. Fast sync completes via `finalize_state_snapshot()` at version V
2. Due to race conditions, message reordering, or coordination bugs between consensus and state sync components, `commit_ledger(V, ...)` is invoked again
3. The call uses `chunk_opt = None`, bypassing `pre_commit_validation()`

While not directly exploitable by external attackers (requires internal component coordination), this represents a defensive programming failure that could manifest during:
- **Network partition recovery**: When state sync and consensus re-coordinate after network healing
- **Epoch transitions with fast sync**: During the handover between fast sync completion and consensus resumption
- **State sync coordination errors**: Due to timing issues in the storage synchronizer

The likelihood is elevated by the fact that the block executor explicitly calls `commit_ledger()` with `chunk_opt = None`, demonstrating that this code path is actively used.

## Recommendation

Change the version validation in `get_and_check_commit_range()` from non-strict to strict inequality:

```rust
fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
    let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
    let pre_committed_ver = self.state_store.current_state_locked().version();
    ensure!(
        old_committed_ver.is_none() || version_to_commit > old_committed_ver.unwrap(), // Changed from >= to >
        "Version already committed or too old. Committed: {:?}; Trying to commit: {}",
        old_committed_ver,
        version_to_commit,
    );
    ensure!(
        pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
        "Version too new to commit. Pre-committed: {:?}, Trying to commit: {}",
        pre_committed_ver,
        version_to_commit,
    );
    Ok(old_committed_ver)
}
```

Additionally, consider adding explicit assertions in `commit_ledger()` when `chunk_opt = None` to ensure that version monotonicity is maintained even without chunk validation.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Complete fast sync at version V via `finalize_state_snapshot(V, ...)`
2. Observe that `OverallCommitProgress = V` and state's `next_version = V+1`
3. Call `commit_ledger(V, ledger_info, None)` 
4. The validation passes due to `V >= V` being true
5. The same version V is committed again, violating monotonicity

A full Rust integration test would require mocking the coordination bug between state sync and consensus, which is complex to reproduce deterministically. However, the logical vulnerability is evident from the code analysis above.

## Notes

This is a valid logic vulnerability in defensive programming. While the impact is mitigated by additional validation layers, the fundamental use of `>=` instead of `>` violates the strict version monotonicity invariant that is critical for blockchain correctness. The vulnerability exists in production code paths and could manifest during edge cases in distributed system coordination.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L177-185)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        self.get_aptos_db_write_ref()
            .commit_ledger(version, ledger_info_with_sigs, chunk_opt)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L97-107)
```rust
            let mut ledger_batch = SchemaBatch::new();
            // Write down LedgerInfo if provided.
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L213-218)
```rust
            ledger_db_batch
                .ledger_metadata_db_batches
                .put::<DbMetadataSchema>(
                    &DbMetadataKey::OverallCommitProgress,
                    &DbMetadataValue::Version(version),
                )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L237-237)
```rust
            self.state_store.reset();
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L245-261)
```rust
    fn pre_commit_validation(&self, chunk: &ChunkToCommit) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions_validation"]);

        ensure!(!chunk.is_empty(), "chunk is empty, nothing to save.");

        let next_version = self.state_store.current_state_locked().next_version();
        // Ensure the incoming committing requests are always consecutive and the version in
        // buffered state is consistent with that in db.
        ensure!(
            chunk.first_version == next_version,
            "The first version passed in ({}), and the next version expected by db ({}) are inconsistent.",
            chunk.first_version,
            next_version,
        );

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-537)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L388-391)
```rust
        self.db
            .writer
            .commit_ledger(target_version, Some(&ledger_info_with_sigs), None)?;

```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```
