# Audit Report

## Title
Cross-Shard Transaction Abort Causes Permanent Network Deadlock via Unimplemented Error Propagation

## Summary
The sharded block executor contains an unimplemented `on_execution_aborted` handler that panics with `todo!()`, causing dependent shards to deadlock indefinitely when waiting for cross-shard values from aborted transactions. This breaks the liveness invariant and can halt the entire network when sharded execution is enabled.

## Finding Description

The Aptos sharded block executor enables parallel transaction execution across multiple shards. When a transaction on one shard depends on values written by a transaction on another shard, the dependent transaction blocks waiting for those values via a condition variable mechanism.

**The Critical Execution Path:**

1. **Cross-Shard Dependency Setup**: Transaction T2 on Shard B depends on reading a state key written by Transaction T1 on Shard A. The system initializes a `RemoteStateValue` in "Waiting" status for this key. [1](#0-0) 

2. **Blocking Wait**: When T2 executes and reads the key, it calls `RemoteStateValue::get_value()` which blocks on a condition variable in a while loop until the value is set. [2](#0-1) 

3. **Transaction Abort on Source Shard**: T1 on Shard A encounters a fatal VM error (e.g., arithmetic overflow, assertion failure, resource not found) and returns `ExecutionStatus::Abort`.

4. **Parallel Execution Failure**: The commit process detects the abort status and returns a `FatalVMError`, triggering fallback to sequential execution. [3](#0-2) 

5. **Sequential Execution Fallback**: Sharded execution is configured with `allow_fallback: true` by default, so it falls back to sequential execution when parallel execution fails. [4](#0-3) [5](#0-4) 

6. **Sequential Abort Handler Invocation**: During sequential execution, when the transaction aborts again, the system invokes the commit hook's `on_execution_aborted` method. [6](#0-5) 

7. **Unimplemented Handler Panic**: The `CrossShardCommitSender::on_execution_aborted` method contains only a `todo!()` macro which immediately panics. [7](#0-6) 

8. **Permanent Deadlock**: The panic prevents any abort notification from being sent to dependent shards. Transaction T2 on Shard B remains blocked forever in `get_value()`, as `set_value()` is never called. The condition variable never receives a notification, causing permanent deadlock. [8](#0-7) 

**Why This Breaks Consensus:**

- All validators executing the same block with sharded execution will panic at the same deterministic point
- The network cannot make progress as the panicked shard prevents block completion
- Dependent shards remain deadlocked waiting for values that will never arrive
- This violates the **liveness** invariant: the network cannot commit new blocks

## Impact Explanation

**Severity: CRITICAL - Total Loss of Liveness/Network Availability**

This vulnerability qualifies as Critical Severity per the Aptos bug bounty program because it causes:

1. **Total loss of liveness/network availability**: When triggered, all validators executing sharded blocks will panic on one shard while other shards deadlock, halting consensus and preventing any new blocks from being committed.

2. **Deterministic network-wide failure**: This is not a single-node crash but a deterministic panic that all honest validators will encounter at the same execution point when processing the same block.

3. **Non-recoverable without intervention**: The deadlock requires manual intervention to restart validators, and the problematic block must be excluded or execution mode changed.

4. **Violates critical invariants**:
   - **Liveness**: Network cannot make progress
   - **Deterministic Execution**: Execution panics instead of producing deterministic outputs  
   - **State Consistency**: Shards have inconsistent views (some panicked, some waiting)

The sharded executor is production code integrated into the main execution workflow and configurable via the `--num-executor-shards` command-line flag. [9](#0-8) 

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger whenever all of the following conditions are met:

1. **Sharded block execution is enabled** (`--num-executor-shards > 1`)
2. **A block contains transactions with cross-shard dependencies** (common in real-world usage)
3. **The source transaction encounters ANY fatal VM error** during execution

Common abort triggers that would cause this include:
- Arithmetic overflow/underflow in Move code
- Failed assertions in Move contracts
- Resource not found errors during state access
- Type safety violations
- Gas exhaustion during execution
- Module access errors
- Any other `VMStatus::Error` that results in abort

The vulnerability is **deterministic and unavoidable** once these conditions are met. An attacker could deliberately craft transactions that:
- Create cross-shard dependencies by accessing state keys that map to different shards
- Trigger guaranteed VM errors (e.g., division by zero, accessing non-existent resources)

This requires **no special permissions**—any user can submit such transactions through the normal transaction submission process.

## Recommendation

Implement the `on_execution_aborted` handler to properly notify dependent shards when a transaction aborts:

```rust
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
        for (state_key, dependent_shard_ids) in edges.iter() {
            for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                // Send None to indicate the write will not occur due to abort
                let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                    state_key.clone(),
                    None, // None indicates abort
                ));
                if *round_id == GLOBAL_ROUND_ID {
                    self.cross_shard_client.send_global_msg(message);
                } else {
                    self.cross_shard_client.send_cross_shard_msg(
                        *dependent_shard_id,
                        *round_id,
                        message,
                    );
                }
            }
        }
    }
}
```

The `RemoteTxnWrite` struct already supports `None` for the `write_op` field to represent aborted transactions. [10](#0-9) 

## Proof of Concept

A proof of concept would require:
1. Running an Aptos validator with `--num-executor-shards 2` or higher
2. Submitting a block containing:
   - Transaction T1 that writes to state key K1 (mapped to Shard A) and triggers an abort (e.g., assertion failure)
   - Transaction T2 that reads state key K1 and writes to K2 (mapped to Shard B)
3. Observing that Shard A panics with the `todo!()` error while Shard B remains blocked indefinitely in `RemoteStateValue::get_value()`

The exact test setup would require integration testing infrastructure with sharded execution enabled, which is beyond the scope of this static analysis report.

## Notes

The `todo!()` comment explicitly states that abort handling "is not supported for sharded execution yet," indicating this is a known incomplete implementation. However, the security implications—that this causes deterministic network-wide deadlock—may not have been fully recognized. The feature appears to be production-ready code that is configurable and tested, but contains this critical gap in error handling that breaks liveness guarantees.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L16-20)
```rust
    pub fn waiting() -> Self {
        Self {
            value_condition: Arc::new((Mutex::new(RemoteValueStatus::Waiting), Condvar::new())),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-38)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L331-337)
```rust
        if let OutputStatusKind::Abort(msg) = &output_wrapper.output_status_kind {
            // Fatal VM error.
            error!(
                "FatalVMError from parallel execution {:?} at txn {}",
                msg, txn_idx
            );
            return Err(PanicOr::Or(ParallelBlockExecutionError::FatalVMError));
```

**File:** types/src/block_executor/config.rs (L71-79)
```rust
    pub fn default_with_concurrency_level(concurrency_level: usize) -> Self {
        Self {
            blockstm_v2: false,
            concurrency_level,
            allow_fallback: true,
            discard_failed_blocks: false,
            module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L89-100)
```rust
        let cross_shard_commit_sender =
            CrossShardCommitSender::new(self.shard_id, self.cross_shard_client.clone(), &sub_block);
        Self::execute_transactions_with_dependencies(
            Some(self.shard_id),
            self.executor_thread_pool.clone(),
            sub_block.into_transactions_with_deps(),
            self.cross_shard_client.clone(),
            Some(cross_shard_commit_sender),
            round,
            state_view,
            config,
        )
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L242-247)
```rust
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L34-38)
```rust
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L103-134)
```rust
    fn send_remote_update_for_success(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let edges = self.dependent_edges.get(&txn_idx).unwrap();
        let write_set = txn_output
            .get()
            .expect("Committed output must be set")
            .write_set();

        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
                }
            }
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```
