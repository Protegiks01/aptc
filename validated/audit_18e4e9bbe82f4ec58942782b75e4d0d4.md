# Audit Report

## Title
State KV Pruner Off-By-One Error: Incorrect Deletion of Tombstones at min_readable_version Boundary

## Summary
The state KV pruner contains an off-by-one boundary error where tombstones (deletion markers) at exactly `min_readable_version` are incorrectly pruned, causing state queries at that version to return stale data instead of correctly indicating deleted keys. This creates a state inconsistency between what the system marks as "readable" and what data is actually available.

## Finding Description

The vulnerability stems from a semantic mismatch in the boundary condition used by the state pruning system. The system explicitly allows queries at `min_readable_version` (using `>=` comparison) but the pruner deletes data AT that same version (using `<=` comparison for stale entries).

**The Off-By-One Error:**

First, the pruner sets its target version equal to `min_readable_version`, which semantically represents the oldest version that should still be queryable: [1](#0-0) 

Second, the pruning logic uses an inclusive boundary condition that deletes entries where `stale_since_version <= target_version`: [2](#0-1) 

Third, when a key is deleted at version V, the system creates a tombstone with both `stale_since_version = V` and `version = V`, with an explicit comment stating it "can be pruned once this `version` goes out of the pruning window": [3](#0-2) 

However, the system's validation logic explicitly allows queries at `min_readable_version` using a `>=` comparison: [4](#0-3) 

**Exploitation Scenario:**

When a key K is deleted at version 100 and the pruning window advances such that `min_readable_version = 100`:

1. The pruner calculates `target_version = 100`
2. It deletes all entries with `stale_since_version <= 100`, including the tombstone at version 100
3. When querying state at version 100, the validation passes (since `100 >= 100`)
4. The query seeks to `(state_key, version 100)` but the tombstone was deleted
5. The iterator returns the next available entry from version 99 or earlier
6. The query incorrectly returns stale data instead of indicating the key was deleted [5](#0-4) 

The pruner deletes both the stale index entry AND the actual StateValue entry (which stores deletions as `Option<StateValue>` with None indicating deletion): [6](#0-5) 

## Impact Explanation

**Severity: Medium** - This constitutes a "Limited protocol violation" / "State inconsistency requiring manual intervention" under the Aptos bug bounty criteria.

**Impacts:**

1. **Historical State Query Incorrectness**: All state queries at exactly `min_readable_version` will return incorrect data for keys deleted at that version, affecting REST API endpoints, blockchain explorers, and indexers.

2. **State Synchronization Risk**: If a syncing node reconstructs state from `min_readable_version` (explicitly marked as readable), it receives incorrect state values for deleted keys, potentially computing incorrect state roots.

3. **Data Integrity Violation**: The system promises that `min_readable_version` is readable but delivers corrupted data, breaking the integrity guarantee.

This does NOT directly cause consensus failure (state roots are computed from current state, not pruned historical data) and does NOT affect validator operations (validators don't query historical boundary versions). Therefore, it qualifies as Medium rather than High or Critical severity.

## Likelihood Explanation

**Likelihood: High** - This bug triggers automatically during normal pruning operations:

1. **Automatic Occurrence**: No attacker action required; happens whenever the pruning window advances
2. **Frequent Trigger**: Every key deletion at a version that later becomes `min_readable_version` is affected
3. **Production Impact**: All nodes running with pruning enabled (standard configuration) experience this issue
4. **Detection Difficulty**: Only affects queries at the exact boundary version, which are uncommon in practice

The bug has likely been occurring in production but remains undetected because historical queries at exact boundary versions are rare, state sync typically uses snapshots from non-boundary versions, and the impact window is limited to one version at a time.

## Recommendation

Fix the off-by-one error by changing the pruning condition from inclusive (`<=`) to strict (`<`):

```rust
// In state_kv_metadata_pruner.rs, change line 46:
if index.stale_since_version >= target_version {  // Changed from > to >=
    break;
}
```

This ensures that entries at exactly `min_readable_version` are retained, making the data available consistent with what the validation layer promises as "readable."

Alternatively, adjust the target version calculation to set `target_version = min_readable_version - 1`, but the first approach is cleaner as it maintains the semantic meaning of `min_readable_version`.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a state key at version 99
2. Deleting the key at version 100 (creating tombstone)
3. Advancing the pruning window so `min_readable_version = 100`
4. Running the pruner to delete entries with `stale_since_version <= 100`
5. Querying the state key at version 100
6. Observing that the query returns the value from version 99 instead of None

A full Rust test would require setting up the storage infrastructure, but the logical flow is verifiable through code inspection of the cited files.

## Notes

The root cause is a classic off-by-one boundary error where the pruning logic and validation logic use different inequality operators (`<=` vs `>=`) on the same boundary value. The comment in the state store code explicitly states tombstones should be pruned "once this `version` goes out of the pruning window," but the current implementation prunes them while they're still AT the boundary, not after they go OUT of it.

This finding represents a genuine state consistency issue that should be addressed to maintain data integrity guarantees, even though it doesn't directly threaten consensus or validator operations.

### Citations

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L130-141)
```rust
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L46-63)
```rust
                    if index.stale_since_version > target_version {
                        break;
                    }
                }
            }
        } else {
            let mut iter = self
                .state_kv_db
                .metadata_db()
                .iter::<StaleStateValueIndexSchema>()?;
            iter.seek(&current_progress)?;
            for item in iter {
                let (index, _) = item?;
                if index.stale_since_version > target_version {
                    break;
                }
                batch.delete::<StaleStateValueIndexSchema>(&index)?;
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L947-950)
```rust
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-314)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** storage/aptosdb/src/schema/state_value/mod.rs (L35-39)
```rust
define_schema!(
    StateValueSchema,
    Key,
    Option<StateValue>,
    STATE_VALUE_CF_NAME
```
