# Audit Report

## Title
Byzantine Validators Can Evade OptQS Accountability Through Timeout Reason Masking During State Synchronization

## Summary
The consensus protocol loses timeout reason information when aggregating timeout certificates, causing validators that sync via `SyncInfo` to default to `RoundTimeoutReason::Unknown` instead of the actual reason. This allows Byzantine validators who intentionally cause `PayloadUnavailable` timeouts to evade OptQS exclusion on syncing validators, creating inconsistent reputation states and enabling sustained performance degradation attacks.

## Finding Description

This vulnerability represents a design flaw in the timeout certificate aggregation protocol where timeout reason information is lost during certificate formation.

**Root Cause - Architectural Design Flaw:**

The `TwoChainTimeoutCertificate` structure only contains the timeout object and aggregated signatures, with no field for the timeout reason: [1](#0-0) 

Similarly, `SyncInfo` propagates these certificates without timeout reason information: [2](#0-1) 

**Critical Flow - Timeout Reason Loss During Sync:**

When a validator receives a timeout certificate through state synchronization without having locally collected timeout votes, the system defaults the timeout reason to `Unknown`. This occurs in the `process_certificates()` function: [3](#0-2) 

When `prev_round_timeout_votes` is `None` (because the validator synced from a certificate rather than collecting individual votes), line 274 defaults to `RoundTimeoutReason::Unknown`.

**Impact on OptQS Exclusion:**

The timeout reason is critical because the `ExponentialWindowFailureTracker` uses it to determine OptQS exclusions. Only `PayloadUnavailable` triggers exclusion: [4](#0-3) 

All other reasons including `Unknown` are treated as successes. The test suite explicitly validates this behavior: [5](#0-4) 

**Integration with RoundManager:**

The timeout reason is pushed to the proposal status tracker which controls OptQS behavior: [6](#0-5) 

**Attack Flow:**

1. Byzantine validator withholds transaction payload batches
2. Online validators detect `PayloadUnavailable`, form timeout certificate, exclude Byzantine validator via failure tracker
3. Validator that was offline/lagging syncs via `SyncInfo`, receives timeout certificate but no individual votes
4. Syncing validator's `pending_votes` is empty, so `drain_votes()` returns `None` for timeout votes
5. Defaults to `Unknown` reason (line 274 in round_state.rs), treats as success, doesn't exclude Byzantine validator
6. When syncing validator proposes, includes Byzantine validator's batches via OptQS
7. Byzantine validator repeats payload withholding attack
8. Network has inconsistent validator reputation states

**Note on Timeout Reason Aggregation:**

While the timeout reason aggregation logic in individual votes is Byzantine-resistant: [7](#0-6) 

This aggregation is bypassed entirely when validators sync from certificates rather than collecting votes directly, as the certificate structure does not preserve this information.

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty "Limited Protocol Violations" category:

1. **State Inconsistencies Requiring Intervention**: Different validators maintain divergent OptQS exclusion lists, violating the assumption of consistent Byzantine detection across the network.

2. **Sustained Performance Degradation**: Byzantine validators can repeatedly cause timeouts on proposals from validators that haven't excluded them, leading to measurable throughput reduction.

3. **Liveness Reduction**: Increased timeouts extend block production times, degrading overall network performance.

4. **Accountability Evasion**: The OptQS exclusion mechanism, designed to penalize validators with unavailable payloads, fails network-wide when validators sync via certificates.

This does **not** break consensus safety, cause fund loss, or enable double-spending. However, it creates exploitable performance degradation requiring manual investigation to identify malicious validators. The impact is concrete and measurable through increased timeout rates and reduced throughput.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high likelihood because:

1. **Normal Operations Trigger It**: Validators routinely sync after brief disconnections, network partitions, or epoch transitions. Any validator that wasn't online during a timeout round will rely on `SyncInfo` without local votes.

2. **No Preconditions Required**: Byzantine validators need only withhold payloads (< 1/3 stake sufficient). No cryptographic breaks, specific network state, or precise timing required.

3. **Persistent Impact**: Once a validator has the wrong timeout reason in its failure tracker, it persists until sufficient subsequent rounds update the window. Meanwhile, Byzantine validators can continue attacks when that validator proposes.

4. **Observable and Exploitable**: Byzantine validators can monitor network participation and time attacks when they identify validators catching up through sync.

The vulnerability is inherent to the protocol design where timeout certificates lack reason metadata.

## Recommendation

**Add timeout reason to TwoChainTimeoutCertificate:**

Modify the `TwoChainTimeoutCertificate` structure to include an aggregated timeout reason field:

```rust
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
    // Add aggregated timeout reason
    aggregated_reason: RoundTimeoutReason,
}
```

**Update certificate creation to preserve reason:**

In `TwoChainTimeoutWithPartialSignatures::aggregate_signatures()`, compute and include the aggregated timeout reason using the same logic as `TwoChainTimeoutVotes::aggregated_timeout_reason()`.

**Update SyncInfo and certificate verification:**

Ensure `SyncInfo` includes the timeout reason when propagating certificates, and update verification logic to validate the aggregated reason matches the individual timeout reasons with sufficient voting power.

**Update process_certificates() to use certificate reason:**

Modify `process_certificates()` to extract the timeout reason from the certificate itself rather than relying on local vote collection:

```rust
let prev_round_timeout_reason = sync_info
    .highest_2chain_timeout_cert()
    .map(|tc| tc.aggregated_reason())
    .unwrap_or(RoundTimeoutReason::Unknown);
```

This ensures validators that sync via certificates maintain consistent OptQS exclusion states with validators that collected votes directly.

## Proof of Concept

A proof of concept would demonstrate:

1. Set up a network with 4 validators (requiring 3 for quorum)
2. Have one Byzantine validator withhold payload batches
3. Have 3 validators online during timeout, collecting votes with `PayloadUnavailable` reason
4. Have the 4th validator offline during this round
5. Verify online validators exclude the Byzantine validator from OptQS
6. Bring the 4th validator online, let it sync via `SyncInfo`
7. Verify the 4th validator receives the timeout certificate but defaults to `Unknown` reason
8. Verify the 4th validator does NOT exclude the Byzantine validator from OptQS
9. When the 4th validator becomes proposer, verify it includes the Byzantine validator's batches
10. Demonstrate the Byzantine validator can repeat the attack against the 4th validator's proposals

The key evidence is in the code paths cited above, showing the structural loss of timeout reason information during certificate aggregation and synchronization.

## Notes

This vulnerability is a **protocol design issue** rather than an implementation bug. The timeout certificate structure was designed to aggregate signatures efficiently but inadvertently loses the critical timeout reason information needed for Byzantine accountability in the OptQS mechanism. This creates a fundamental inconsistency in validator reputation states across the network, where validators that were present during timeout rounds have different OptQS exclusion lists than validators that synced afterward.

The vulnerability affects consensus performance and liveness but does not compromise safety guarantees, making it appropriately categorized as Medium severity under Aptos bug bounty guidelines.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L109-112)
```rust
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
}
```

**File:** consensus/consensus-types/src/sync_info.rs (L14-25)
```rust
#[derive(Deserialize, Serialize, Clone, Eq, PartialEq)]
/// This struct describes basic synchronization metadata.
pub struct SyncInfo {
    /// Highest quorum certificate known to the peer.
    highest_quorum_cert: QuorumCert,
    /// Highest ordered cert known to the peer.
    highest_ordered_cert: Option<WrappedLedgerInfo>,
    /// Highest commit cert (ordered cert with execution result) known to the peer.
    highest_commit_cert: WrappedLedgerInfo,
    /// Optional highest timeout certificate if available.
    highest_2chain_timeout_cert: Option<TwoChainTimeoutCertificate>,
}
```

**File:** consensus/src/liveness/round_state.rs (L264-276)
```rust
            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();

            // The new round reason is QCReady in case both QC.round + 1 == new_round, otherwise
            // it's Timeout and TC.round + 1 == new_round.
            let new_round_reason = if sync_info.highest_certified_round() + 1 == new_round {
                NewRoundReason::QCReady
            } else {
                let prev_round_timeout_reason =
                    prev_round_timeout_reason.unwrap_or(RoundTimeoutReason::Unknown);
                NewRoundReason::Timeout(prev_round_timeout_reason)
            };
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L66-78)
```rust
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L200-202)
```rust
        tracker.push(NewRoundReason::Timeout(RoundTimeoutReason::Unknown));
        assert_eq!(tracker.window, 2);
        assert_eq!(tracker.last_consecutive_success_count, 6);
```

**File:** consensus/src/round_manager.rs (L469-470)
```rust
        self.proposal_status_tracker
            .push(new_round_event.reason.clone());
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```
