# Audit Report

## Title
Missing Signature Verification in Signing Phase Allows Invalid Signatures to Propagate Through Consensus

## Summary
The signing phase extracts signatures from `commit_vote_fut` and pairs them with potentially different LedgerInfo instances from `commit_ledger_info` without cryptographic verification. During network upgrades with mixed `order_vote_enabled` configurations, this creates invalid signatures that propagate through consensus, triggering expensive parallel signature filtering operations and causing validator slowdowns.

## Finding Description

The vulnerability exists where two independent code paths create LedgerInfo instances that differ in their `consensus_data_hash` field:

**Path 1 - CommitVote Creation:**

In `sign_and_broadcast_commit_vote()`, a `select!` statement races three futures to determine the `consensus_data_hash`: [1](#0-0) 

The selected hash depends on which future completes first. If `order_vote_enabled` is false, the hash from the `select!` is used directly. If `commit_proof_fut` completes first with a proof from a validator using `order_vote_enabled=true`, it returns `HashValue::zero()`.

**Path 2 - Partial Commit Proof Creation:**

The `generate_commit_ledger_info()` function uses deterministic logic based solely on the local validator's `order_vote_enabled` flag: [2](#0-1) 

When `order_vote_enabled=false`, it uses the `consensus_data_hash` from `ordered_proof`, which may be non-zero.

**The Vulnerability:**

The signing phase extracts a signature from `commit_vote_fut` and pairs it with `commit_ledger_info` from the SigningRequest without verification: [3](#0-2) 

The SigningRequest's `commit_ledger_info` comes from the signature aggregator created in the executed phase: [4](#0-3) 

**Attack Scenario:**

During a rolling network upgrade where validators transition between different `order_vote_enabled` settings:

1. Validator A (new version) with `order_vote_enabled=true` creates commit proofs using `HashValue::zero()`
2. Validator B (old version) with `order_vote_enabled=false` receives this commit proof via `commit_proof_fut`
3. In `sign_and_broadcast_commit_vote()`, the `select!` completes on `commit_proof_fut`, using `HashValue::zero()`
4. A signature is created for a LedgerInfo with `HashValue::zero()`
5. Meanwhile, `generate_commit_ledger_info()` with `order_vote_enabled=false` creates a LedgerInfo using the non-zero hash from `ordered_proof`
6. The signature (valid for `HashValue::zero()`) is paired with a LedgerInfo containing a different hash

**Propagation:**

The invalid signature is added to the aggregator without verification: [5](#0-4) 

Verification only occurs during aggregation: [6](#0-5) 

When verification fails at line 529, `filter_invalid_signatures()` is triggered, which performs expensive parallel cryptographic verification: [7](#0-6) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty "Validator node slowdowns" category)

This vulnerability causes:

1. **Performance Degradation**: Invalid signatures force validators to execute `filter_invalid_signatures()`, which uses `into_par_iter()` for parallel cryptographic verification of each signature individually - an expensive operation compared to aggregate verification.

2. **Consensus Delays**: Failed aggregation attempts require retries with filtering (lines 530-533), delaying block commitment and potentially affecting finality times.

3. **Resource Waste**: Network bandwidth consumed broadcasting invalid signatures to all validators, with each validator potentially performing the expensive filtering operation.

4. **Amplification Effect**: During mixed-configuration upgrades, multiple validators simultaneously broadcast invalid signatures as they process blocks, compounding the slowdown across the network.

The impact aligns with the Aptos Bug Bounty HIGH severity category for validator node slowdowns affecting consensus performance.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability manifests under realistic operational conditions:

1. **Network Upgrades**: Rolling upgrades where validators transition between software versions with different `order_vote_enabled` configurations create the mismatch window. This is a standard operational procedure in blockchain networks.

2. **Race Conditions**: The `select!` statement creates non-deterministic behavior where `commit_proof_fut` can complete before `order_proof_fut`, especially when validators have varying network latencies or processing speeds.

3. **No Defensive Validation**: The absence of signature verification in the signing phase means the vulnerability triggers automatically when the conditions align - no additional exploitation required.

4. **Configuration Variance**: The `order_vote_enabled` flag is part of `OnChainConsensusConfig` and can legitimately differ between validators during upgrade periods.

Unlike theoretical vulnerabilities requiring malicious actors or Byzantine behavior, this occurs naturally during operational procedures (network upgrades) that are regularly performed on production networks.

## Recommendation

Add signature verification in the signing phase before pairing the signature with `commit_ledger_info`:

```rust
let signature_result = if let Some(fut) = blocks
    .last()
    .expect("Blocks can't be empty")
    .pipeline_futs()
{
    fut.commit_vote_fut
        .clone()
        .await
        .and_then(|vote| {
            // Verify the signature matches commit_ledger_info
            if vote.ledger_info() == &commit_ledger_info {
                Ok(vote.signature().clone())
            } else {
                Err(Error::InternalError(
                    "LedgerInfo mismatch between commit_vote_fut and commit_ledger_info".to_string()
                ))
            }
        })
        .map_err(|e| Error::InternalError(e.to_string()))
} else {
    self.safety_rule_handle
        .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
};
```

Alternatively, ensure deterministic `consensus_data_hash` calculation by avoiding the `select!` race and using only the local `order_vote_enabled` configuration.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up two validators with different `order_vote_enabled` configurations
2. Having Validator A (with `order_vote_enabled=true`) commit a block with `HashValue::zero()` as `consensus_data_hash`
3. Having Validator B (with `order_vote_enabled=false`) receive this commit proof
4. Observing that Validator B's `sign_and_broadcast_commit_vote` uses `HashValue::zero()` while `generate_commit_ledger_info` uses a non-zero hash
5. Monitoring the signature aggregation failure and subsequent call to `filter_invalid_signatures()`
6. Measuring the performance impact of parallel signature verification

The vulnerability is confirmed by code analysis showing no signature verification exists between extracting from `commit_vote_fut` and pairing with `commit_ledger_info`.

## Notes

This vulnerability represents a subtle consensus implementation issue where decoupled execution paths create inconsistent state that isn't validated until aggregation time. The use of `order_vote_enabled` as a configuration flag that can legitimately vary between validators during upgrades makes this a realistic operational concern rather than a theoretical issue.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L990-1006)
```rust
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L394-398)
```rust
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
```

**File:** consensus/src/pipeline/signing_phase.rs (L72-98)
```rust
    async fn process(&self, req: SigningRequest) -> SigningResponse {
        let SigningRequest {
            ordered_ledger_info,
            commit_ledger_info,
            blocks,
        } = req;

        let signature_result = if let Some(fut) = blocks
            .last()
            .expect("Blocks can't be empty")
            .pipeline_futs()
        {
            fut.commit_vote_fut
                .clone()
                .await
                .map(|vote| vote.signature().clone())
                .map_err(|e| Error::InternalError(e.to_string()))
        } else {
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
        };

        SigningResponse {
            signature_result,
            commit_ledger_info,
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L473-477)
```rust
            let request = self.create_new_request(SigningRequest {
                ordered_ledger_info: executed_item.ordered_proof.clone(),
                commit_ledger_info: executed_item.partial_commit_proof.data().clone(),
                blocks: executed_item.executed_blocks.clone(),
            });
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```
