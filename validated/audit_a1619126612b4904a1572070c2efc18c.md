# Audit Report

## Title
Missing Gas Price Bounds Validation in Governance Updates Allows Total Network Liveness Loss

## Summary
The Aptos Framework's `gas_schedule.move` module lacks critical validation to ensure `min_price_per_gas_unit ≤ max_price_per_gas_unit` when governance updates gas parameters. If an invalid gas schedule is applied where `min_price_per_gas_unit > max_price_per_gas_unit`, all transactions become invalid, causing complete network liveness loss requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the gas schedule update mechanism within the Aptos Framework. The `set_for_next_epoch` and `set_for_next_epoch_check_hash` functions accept governance proposals to update gas parameters but fail to validate the consistency of gas price bounds.

**Missing Validation in Aptos:**

The current implementation only validates that the gas schedule blob is non-empty and that the feature version is monotonically increasing. [1](#0-0) 

Multiple TODO comments throughout the module explicitly acknowledge that consistency validation should be implemented but remains unimplemented:
- In `initialize` function: [2](#0-1) 
- In `set_gas_schedule` function: [3](#0-2) 
- In `set_gas_schedule` else branch: [4](#0-3) 

**Comparison to Diem Framework:**

The legacy Diem framework (from which Aptos was derived) explicitly validates this constraint to prevent the exact issue described: [5](#0-4) 

**Enforcement Without Exemption:**

Once an invalid gas schedule is applied via `on_new_epoch`, the AptosVM enforces BOTH gas price bounds during transaction validation:
- Lower bound check: [6](#0-5) 
- Upper bound check: [7](#0-6) 

Critically, the `is_approved_gov_script` flag does NOT bypass these gas price checks - it only exempts transaction size and execution limits: [8](#0-7) 

**Exploitation Path:**

1. A governance proposal is created with a `GasScheduleV2` where `min_price_per_gas_unit > max_price_per_gas_unit` (through accidental misconfiguration or automated tooling bugs)
2. The proposal passes governance voting
3. Upon epoch transition, `on_new_epoch` applies the invalid gas schedule without validation: [9](#0-8) 
4. The gas schedule is applied during epoch transitions: [10](#0-9) 
5. All subsequent transactions are rejected because no valid gas price exists:
   - If `gas_unit_price ≥ min_price_per_gas_unit`, it will also be `> max_price_per_gas_unit` (since min > max), rejected as `GAS_UNIT_PRICE_ABOVE_MAX_BOUND`
   - If `gas_unit_price ≤ max_price_per_gas_unit`, it will also be `< min_price_per_gas_unit` (since min > max), rejected as `GAS_UNIT_PRICE_BELOW_MIN_BOUND`
6. The network cannot process ANY transactions, including governance recovery transactions, since `check_gas` is called during the prologue phase for all transactions: [11](#0-10) 
7. The network is permanently halted until a hard fork manually corrects the on-chain gas schedule

This represents a **logic vulnerability** - a missing validation that allows an impossible state to be created in the protocol, even when not triggered by malicious actors.

## Impact Explanation

This vulnerability meets the **Critical Severity** criteria per the Aptos Bug Bounty program:

**Total Loss of Liveness/Network Availability (Critical Severity #4):**
Once the invalid gas schedule is applied, no transactions can be validated or executed. The transaction validation layer in `check_gas` will reject all incoming transactions during the prologue phase, regardless of the gas price submitted, because it is mathematically impossible to satisfy both constraints simultaneously when min > max.

**Non-recoverable Network Partition (Critical Severity #3):**
Unlike temporary liveness issues that can be resolved through on-chain governance, this issue CANNOT be fixed through normal governance procedures because governance transactions themselves are subject to the same gas price validation and will be rejected. The only recovery mechanism is a coordinated hard fork where validators restart with manually corrected on-chain state.

This breaks the fundamental protocol invariant that the resource limit enforcement mechanism should always allow valid transactions to proceed with proper gas pricing.

## Likelihood Explanation

**Likelihood: Low to Medium**

**Factors Increasing Likelihood:**
- Accidental misconfiguration in governance proposals (typo swapping min/max values)
- Bugs in automated gas schedule generation tooling
- No client-side validation in proposal creation tools
- No on-chain validation to prevent submission
- Historical precedent: Diem developers explicitly added this validation, suggesting they recognized this risk

**Factors Decreasing Likelihood:**
- Governance proposals undergo community review and voting
- Multiple stakeholders would review parameters before voting
- The error would be obvious (min > max) during review
- Proposal generation tools would likely include basic sanity checks
- The parameters have default values that are correctly ordered

**Note on Threat Model:** This vulnerability can be triggered through accidental misconfiguration or tooling bugs, which do not constitute malicious behavior by governance participants. This represents a protocol defect (missing validation) rather than an attack on trusted actors.

## Recommendation

Add validation to ensure `min_price_per_gas_unit ≤ max_price_per_gas_unit` in all gas schedule update functions. Specifically:

1. **In `set_for_next_epoch` function**: After deserializing the `GasScheduleV2`, validate the gas price bounds before buffering the config.

2. **In `set_for_next_epoch_check_hash` function**: Add the same validation.

3. **In `initialize` and `set_gas_schedule` functions**: Implement the validation indicated by the TODO comments.

Example fix for `set_for_next_epoch`:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Add validation for gas price bounds consistency
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(gas_schedule: &GasScheduleV2) {
    // Extract min and max price parameters from entries
    let min_price = get_gas_param(gas_schedule, b"txn.min_price_per_gas_unit");
    let max_price = get_gas_param(gas_schedule, b"txn.max_price_per_gas_unit");
    
    assert!(
        option::is_none(&min_price) || option::is_none(&max_price) || 
        *option::borrow(&min_price) <= *option::borrow(&max_price),
        error::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
    );
}
```

Define a new error constant: `const EGAS_CONSTANT_INCONSISTENCY: u64 = 4;`

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
#[expected_failure(abort_code = 0x010004)] // EGAS_CONSTANT_INCONSISTENCY
fun test_invalid_gas_price_bounds_rejected(fx: signer) {
    use std::vector;
    use aptos_framework::gas_schedule;
    
    // Create a GasScheduleV2 with min > max
    let entries = vector::empty();
    vector::push_back(&mut entries, (string::utf8(b"txn.min_price_per_gas_unit"), 1000));
    vector::push_back(&mut entries, (string::utf8(b"txn.max_price_per_gas_unit"), 100));
    
    let invalid_schedule = GasScheduleV2 {
        feature_version: 1,
        entries: entries,
    };
    
    let invalid_bytes = bcs::to_bytes(&invalid_schedule);
    
    // This should abort with EGAS_CONSTANT_INCONSISTENCY
    gas_schedule::set_for_next_epoch(&fx, invalid_bytes);
}
```

Without the validation, this test would pass, allowing the invalid gas schedule to be buffered. Once applied via `on_new_epoch`, all subsequent transactions would be rejected, causing total network liveness loss.

## Notes

This is a **logic vulnerability** - a missing validation in the protocol that allows an impossible state to be created. The TODO comments in the codebase explicitly acknowledge this validation should exist but has not been implemented. The Diem framework, from which Aptos was derived, includes this exact validation, demonstrating that this risk was previously recognized.

The vulnerability does not require malicious governance participants - it can be triggered through human error or tooling bugs. However, it would result in catastrophic impact requiring a hard fork to recover, as there is no on-chain mechanism to fix the invalid gas schedule once applied.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-68)
```text
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-76)
```text
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/DiemVMConfig.move (L154-157)
```text
        assert!(
            min_price_per_gas_unit <= max_price_per_gas_unit,
            errors::invalid_argument(EGAS_CONSTANT_INCONSISTENCY)
        );
```

**File:** aptos-move/aptos-vm/src/gas.rs (L83-108)
```rust
    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L194-208)
```rust
    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L51-51)
```text
        gas_schedule::on_new_epoch(framework);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```
