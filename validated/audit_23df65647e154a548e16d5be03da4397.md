# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causes JWK Consensus Liveness Failure

## Summary
The `UnsupportedJWK` struct uses non-canonical JSON serialization when converting from `serde_json::Value`, causing validators that observe semantically identical JWKs with different JSON key orderings to fail consensus. This prevents JWK updates from reaching quorum, disrupting keyless account authentication.

## Finding Description

The vulnerability exists in the `UnsupportedJWK::from(serde_json::Value)` implementation where non-canonical JSON serialization is used. [1](#0-0) 

The implementation calls `.to_string()` on the `serde_json::Value`, which preserves the insertion order of JSON object keys. The developer explicitly acknowledges this issue with a TODO comment on line 53: `//TODO: canonical to_string.` This means semantically identical JWKs with different key orderings (e.g., `{"kid":"123","kty":"EC"}` vs `{"kty":"EC","kid":"123"}`) produce different payload byte arrays and different SHA3-256 hash IDs.

This vulnerability propagates through the JWK consensus protocol. When validators periodically fetch JWKs from OIDC providers, they parse the JSON responses and convert them to JWK objects. [2](#0-1) 

The fetched JSON values are converted to `JWK` objects, which for unsupported formats delegates to `UnsupportedJWK::from`. [3](#0-2) 

During the consensus observation aggregation phase, validators strictly enforce equality between their local view and peer observations. [4](#0-3) 

If validator A observes a JWK with keys ordered `["kid","kty"]` and validator B observes the same semantic JWK with keys ordered `["kty","kid"]`, their `UnsupportedJWK` objects will have different `payload` byte arrays and different `id` hashes. The equality check `self.local_view == peer_view` at line 82 will fail, causing validator A to reject validator B's observation with the error "adding peer observation failed with mismatched view".

Since `ProviderJWKs` derives `PartialEq` and contains a vector of `JWKMoveStruct` objects (which contain the `UnsupportedJWK`), different payload/ID combinations make the entire `ProviderJWKs` structures unequal. [5](#0-4) 

Even though validators sort JWKs by ID before sending observations, this doesn't help because the IDs themselves are computed from non-canonical payloads. [6](#0-5) 

When validators reject each other's observations due to view mismatches, they cannot accumulate sufficient voting power to reach the quorum threshold. The observation aggregation logic checks if the accumulated voting power exceeds the quorum threshold, and only then produces a `QuorumCertifiedUpdate`. [7](#0-6) 

Without reaching quorum, the JWK update cannot be committed to on-chain state, preventing keyless accounts that depend on the new JWK from authenticating.

**Realistic Trigger Scenarios:**
1. OIDC providers using load balancers with different backend servers that serialize JSON with different key orderings
2. OIDC providers rotating infrastructure between different geographic regions with different JSON library versions
3. Cloud providers using different JSON serialization implementations across availability zones
4. Normal infrastructure operations like A/B testing or gradual rollouts

These scenarios can occur without any malicious intent - they're standard internet infrastructure patterns.

## Impact Explanation

**Severity: Medium to High**

This vulnerability causes a consensus liveness failure specifically in the JWK consensus subsystem. Per Aptos Bug Bounty criteria:

- **Significant protocol violations**: The JWK consensus protocol cannot reach agreement on observed JWKs, preventing the system from fulfilling its core function of maintaining up-to-date OIDC provider keys
- **Limited DoS**: Keyless account authentication is disrupted for users whose OIDC providers' JWKs cannot be updated on-chain
- **Requires manual intervention**: Governance would need to manually patch affected JWKs or emergency-upgrade node software

This does NOT affect:
- Main AptosBFT consensus (blockchain continues operating normally)
- Direct fund loss or theft
- Total network liveness

The impact is limited to the JWK subsystem, which handles keyless authentication. While this is a critical feature, it's a subsystem-level issue rather than a core consensus failure. This aligns with either High severity ("Validator Node Slowdowns" - if JWK consensus attempts impact validator performance) or Medium severity ("Limited Protocol Violations" - state inconsistencies requiring manual intervention).

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered through:
1. **Infrastructure Variability**: Modern cloud infrastructure commonly exhibits JSON serialization differences across geographic regions, load balancer backends, or CDN cache nodes
2. **No Attack Required**: This can occur naturally without any malicious actor involvement
3. **Low Barrier**: No cryptographic attacks, no stake requirements, no complex coordination needed
4. **Acknowledged Issue**: The TODO comment indicates developers are aware but haven't prioritized fixing it

However, likelihood is reduced by:
1. Most production OIDC providers (Google, Facebook) likely maintain consistent JSON serialization
2. Would require validators in different regions to hit different backend servers simultaneously
3. May not affect all JWK updates, only those observed with different orderings

## Recommendation

Implement canonical JSON serialization for `UnsupportedJWK`. The recommended approach is to use a deterministic key ordering (e.g., alphabetical) when serializing JSON objects:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Canonicalize by converting to BTreeMap for alphabetical ordering
        let canonical_value = canonicalize_json(json_value);
        let payload = canonical_value.to_string().into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonicalize_json(value: serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::Object(map) => {
            let btree: std::collections::BTreeMap<_, _> = map.into_iter()
                .map(|(k, v)| (k, canonicalize_json(v)))
                .collect();
            serde_json::Value::Object(btree.into_iter().collect())
        }
        serde_json::Value::Array(arr) => {
            serde_json::Value::Array(arr.into_iter().map(canonicalize_json).collect())
        }
        other => other,
    }
}
```

Alternatively, use a dedicated canonical JSON library that provides RFC 8785 (JSON Canonicalization Scheme) compliance.

## Proof of Concept

```rust
#[test]
fn test_non_canonical_jwk_mismatch() {
    use aptos_types::jwks::unsupported::UnsupportedJWK;
    use std::str::FromStr;
    
    // Same semantic JWK with different key orderings
    let json_ordering_1 = r#"{"kid":"123","kty":"EC","use":"sig"}"#;
    let json_ordering_2 = r#"{"kty":"EC","kid":"123","use":"sig"}"#;
    
    let value_1 = serde_json::Value::from_str(json_ordering_1).unwrap();
    let value_2 = serde_json::Value::from_str(json_ordering_2).unwrap();
    
    let jwk_1 = UnsupportedJWK::from(value_1);
    let jwk_2 = UnsupportedJWK::from(value_2);
    
    // These should be equal semantically but are not due to non-canonical serialization
    assert_ne!(jwk_1.id, jwk_2.id, "IDs differ due to different key orderings");
    assert_ne!(jwk_1.payload, jwk_2.payload, "Payloads differ due to different key orderings");
    assert_ne!(jwk_1, jwk_2, "JWKs are unequal despite being semantically identical");
    
    // This would cause consensus failure when validators compare ProviderJWKs
    println!("JWK 1 ID: {:?}", hex::encode(&jwk_1.id));
    println!("JWK 2 ID: {:?}", hex::encode(&jwk_2.id));
}
```

## Notes

The vulnerability's root cause is in the `types/` directory which is explicitly in-scope. While the primary impact manifests in the JWK consensus subsystem (`crates/aptos-jwk-consensus/`), the core bug exists in a foundational type definition that affects consensus operations.

The report's framing around "malicious OIDC provider" is somewhat misleading - this vulnerability can and likely will be triggered by normal infrastructure behavior rather than malicious intent. The real issue is Aptos's failure to canonicalize JSON before hashing, not external actor behavior.

The TODO comment at line 53 demonstrates developer awareness of this issue, but it remains unfixed in the current codebase, indicating it may not have been prioritized despite its potential impact on keyless authentication reliability.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L94-118)
```rust
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(voters.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };

        info!(
            epoch = self.epoch_state.epoch,
            peer = sender,
            issuer = String::from_utf8(self.local_view.issuer.clone()).ok(),
            peer_power = peer_power,
            new_total_power = new_total_power,
            threshold = self.epoch_state.verifier.quorum_voting_power(),
            threshold_exceeded = power_check_result.is_ok(),
            "Peer vote aggregated."
        );

        if power_check_result.is_err() {
            return Ok(None);
        }
        let multi_sig = self.epoch_state.verifier.aggregate_signatures(partial_sigs.signatures_iter()).map_err(|e|anyhow!("adding peer observation failed with partial-to-aggregated conversion error: {e}"))?;
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L74-80)
```rust
                    let result = fetch_jwks(open_id_config_url.as_str(), my_addr).await;
                    debug!(issuer = issuer, "observe_result={:?}", result);
                    let secs = timer.elapsed().as_secs_f64();
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
```
