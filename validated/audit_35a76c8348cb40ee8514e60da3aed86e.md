Audit Report

## Title
KvOnly Mode State Restoration Bypasses Merkle Proof Verification Leading to Undetected State Corruption

## Summary
When an operator restores Aptos blockchain state using `StateSnapshotRestoreMode::KvOnly`, the system bypasses cryptographic Merkle proof verification intended to guarantee state integrity. This enables injection of corrupted state directly into storage, breaking core security guarantees and potentially leading to a consensus violation if others restore from the same compromised backup.

## Finding Description
In the Aptos state snapshot restore flow, there are distinct restore modes: `KvOnly`, `TreeOnly`, and `Full`. When running in `KvOnly` mode, the code only executes the provided `kv_fn` closure, which persists arbitrary key-value pairs directly to state storage. Critically, the `tree_fn` path—responsible for calling `JellyfishMerkleRestore::add_chunk_impl()`—is completely skipped in this mode. It is this `add_chunk_impl()` function that performs Merkle proof verification to ensure every chunk matches the expected global state root.

Inside `add_chunk_impl()`, there is a call to `self.verify(proof)?;` which performs the cryptographic check, and this is not reached by any path in `KvOnly` restore flow. Thus, a malicious backup source can inject arbitrary or subtly-corrupted state, and it will be accepted as valid state by the node, as long as the operator does not later finish the TreeOnly phase (a risk in operational practice).

This is a direct violation of:  
- **State Consistency**: State written does not have cryptographic linkage to the authentic chain state root.
- **Deterministic Execution**: Multiple validators restoring from a bad snapshot may reach the same, corrupted state, forming a bad quorum, resulting in consensus splits.

## Impact Explanation
This matches several "Critical" Aptos bug bounty impact categories:
- **Consensus/Safety Violation**: Multiple validators may create and vote on the same forked, corrupted state.
- **State Corruption Without Detection**: Loss of the fundamental security property that only state merkle-tree-consistent state is accepted.
- **Loss of Trust in Restored State**: Operators cannot ensure restorations yield the authentic, consensus-derived state.
- **Potential for Fund Theft**: Changing balances or resource data via backup manipulation could enable or facilitate theft after restoration.

## Likelihood Explanation
Risk is **medium to high**:
- Usage of `KvOnly` mode is operationally encouraged for performance and flexibility.
- The flaw can be exploited through compromised backup infrastructure or storage—scenarios plausible in real-world ops, especially in cloud setups.
- Restoration scripts may fail to enforce or check the completion of the two-phase (Kv+Tree) workflow.
- Detection is not automatic; the flaw may remain latent until real user impact or consensus split occurs.

## Recommendation
Enforce Merkle proof verification *unconditionally* for all data written into state during snapshot restoration, or ensure restoration in `KvOnly` mode is always followed by Tree phase before node operation resumes. At a minimum, make single-phase `KvOnly` restores impossible to use for node startup without extra proof steps.

Example fix:  
- Remove or disable `KvOnly` mode unless strictly required.
- Alternatively, fail state restore at startup if Tree phase has not completed and verified.

## Proof of Concept
1. Take a full state snapshot and extract the backup files.
2. Modify some key-value entries (e.g., balances or resources) in the snapshot.
3. Restore a validator node using only the `KvOnly` phase, skipping the tree/Merkle verification phase.
4. Node starts up and processes blocks with the corrupted state, observing inconsistent results versus authentic chain state.
5. If multiple validators do this, they can join consensus with the wrong state, splitting consensus.

---

Notes:

- The report is firmly in-scope (affecting `storage/aptosdb/`, notably state and merkle db logic).
- No trusted roles are required for the attack; it targets the restoration mechanism, not privileged access.
- The impact is severe as it corrupts core blockchain invariants, which is the highest tier in the bounty rules.
- Exploit is plausible in practical settings, especially where restoration scripts are automated and operator error is possible.
- Merkle proof bypass is marked and realized in the code via the path separation between `kv_fn` and `tree_fn`, and only the latter uses proof validation.
- None of the disqualifying "impossible" or out-of-scope requirements apply.

Citations: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3)

### Citations

**File:** storage/aptosdb/src/restore/mod.rs (L68-117)
```rust

```

**File:** storage/aptosdb/src/restore/mod.rs (L146-190)
```rust

```

**File:** storage/aptosdb/src/restore/mod.rs (L191-234)
```rust

```

**File:** storage/aptosdb/src/restore/jellyfish_merkle_restore.rs (L376-402)
```rust

```
