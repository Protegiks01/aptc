> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6)

### Citations

**File:** storage/aptosdb/src/utils/iterators.rs (L296-382)
```rust
pub struct AccountTransactionSummariesIter<'a> {
    inner: SchemaIterator<'a, TransactionSummariesByAccountSchema>,
    address: AccountAddress,
    start_version: Option<Version>,
    end_version: Option<Version>,
    limit: u64,
    direction: ScanDirection,
    prev_version: Option<Version>,
    ledger_version: Version,
    count: u64,
}

impl<'a> AccountTransactionSummariesIter<'a> {
    pub fn new(
        inner: SchemaIterator<'a, TransactionSummariesByAccountSchema>,
        address: AccountAddress,
        start_version: Option<Version>,
        end_version: Option<Version>,
        limit: u64,
        direction: ScanDirection,
        ledger_version: Version,
    ) -> Self {
        Self {
            inner,
            address,
            start_version,
            end_version,
            limit,
            direction,
            ledger_version,
            prev_version: None,
            count: 0,
        }
    }
}

impl AccountTransactionSummariesIter<'_> {
    fn next_impl(&mut self) -> Result<Option<(Version, IndexedTransactionSummary)>> {
        // If already iterated over `limit` transactions, return None.
        if self.count >= self.limit {
            return Ok(None);
        }

        Ok(match self.inner.next().transpose()? {
            Some(((address, version), txn_summary)) => {
                // No more transactions sent by this account.
                if address != self.address {
                    return Ok(None);
                }

                // This case ideally shouldn't occur if the iterator is initiated properly.
                if (self.direction == ScanDirection::Backward
                    && version > self.end_version.unwrap())
                    || (self.direction == ScanDirection::Forward
                        && version < self.start_version.unwrap())
                {
                    return Ok(None);
                }

                ensure!(
                    version == txn_summary.version(),
                    "DB corruption: version mismatch: version in key: {}, version in txn summary: {}",
                    version,
                    txn_summary.version(),
                );

                // No more transactions (in this view of the ledger).
                if version > self.ledger_version {
                    return Ok(None);
                }

                self.prev_version = Some(version);
                self.count += 1;
                Some((version, txn_summary))
            },
            None => None,
        })
    }
}

impl Iterator for AccountTransactionSummariesIter<'_> {
    type Item = Result<(Version, IndexedTransactionSummary)>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_impl().transpose()
    }
}
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L83-140)
```rust
    pub fn get_account_transaction_summaries_iter(
        &self,
        address: AccountAddress,
        start_version: Option<u64>,
        end_version: Option<u64>,
        limit: u64,
        ledger_version: Version,
    ) -> Result<AccountTransactionSummariesIter<'_>> {
        // Question[Orderless]: When start version is specified, we are current scanning forward from start version.
        // When start version is not specified we are scanning backward, so as to return the most recent transactions.
        // This doesn't seem to be a good design. Should we instead let the API take scan direction as input?
        if start_version.is_some() {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek(&(address, start_version.unwrap()))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                end_version,
                limit,
                ScanDirection::Forward,
                ledger_version,
            ))
        } else if end_version.is_some() {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .rev_iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek_for_prev(&(address, end_version.unwrap()))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                end_version,
                limit,
                ScanDirection::Backward,
                ledger_version,
            ))
        } else {
            let mut iter = self
                .ledger_db
                .transaction_db_raw()
                .rev_iter::<TransactionSummariesByAccountSchema>()?;
            iter.seek_for_prev(&(address, u64::MAX))?;
            Ok(AccountTransactionSummariesIter::new(
                iter,
                address,
                start_version,
                Some(u64::MAX),
                limit,
                ScanDirection::Backward,
                ledger_version,
            ))
        }
    }
```

**File:** api/src/transactions.rs (L407-449)
```rust
        path = "/accounts/:address/transaction_summaries",
        method = "get",
        operation_id = "get_account_transaction_summaries",
        tag = "ApiTags::Transactions"
    )]
    async fn get_accounts_transaction_summaries(
        &self,
        accept_type: AcceptType,
        /// Address of account with or without a `0x` prefix
        address: Path<Address>,
        /// Transaction version to start list of transactions
        ///
        /// If not provided, defaults to showing the latest transactions
        start_version: Query<Option<U64>>,
        /// Transaction version to end list of transactions
        ///
        /// If not provided, defaults to showing the latest transactions
        end_version: Query<Option<U64>>,
        /// Max number of transactions to retrieve.
        ///
        /// If not provided, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<TransactionSummary>> {
        fail_point_poem("endpoint_get_accounts_transaction_summaries")?;
        self.context
            .check_api_output_enabled("Get account transaction summaries", &accept_type)?;
        let limit = if let Some(limit) = limit.0 {
            min(limit, self.context.max_transactions_page_size())
        } else {
            self.context.max_transactions_page_size()
        };
        let api = self.clone();
        api_spawn_blocking(move || {
            api.list_txn_summaries_by_account(
                &accept_type,
                address.0,
                start_version.0,
                end_version.0,
                limit,
            )
        })
        .await
    }
```

**File:** api/src/context.rs (L940-960)
```rust
    pub fn get_account_transaction_summaries<E: NotFoundError + InternalError>(
        &self,
        address: AccountAddress,
        start_version: Option<u64>,
        end_version: Option<u64>,
        limit: u16,
        ledger_version: u64,
        ledger_info: &LedgerInfo,
    ) -> Result<Vec<IndexedTransactionSummary>, E> {
        self.db
            .get_account_transaction_summaries(
                address,
                start_version,
                end_version,
                limit as u64,
                ledger_version,
            )
            .context("Failed to retrieve account transaction summaries")
            .map_err(|err| E::internal_with_code(err, AptosErrorCode::InternalError, ledger_info))
    }

```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L197-220)
```rust
    fn get_account_transaction_summaries(
        &self,
        address: AccountAddress,
        start_version: Option<u64>,
        end_version: Option<u64>,
        limit: u64,
        ledger_version: Version,
    ) -> Result<Vec<IndexedTransactionSummary>> {
        gauged_api("get_account_transaction_summaries", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

            let txn_summaries_iter = self
                .transaction_store
                .get_account_transaction_summaries_iter(
                    address,
                    start_version,
                    end_version,
                    limit,
                    ledger_version,
                )?
                .map(|result| {
                    let (_version, txn_summary) = result?;
                    Ok(txn_summary)
                });
```

**File:** storage/storage-interface/src/lib.rs (L338-351)
```rust
        /// Each transaction summary contains the sender address, transaction hash, version, replay protector
        /// of the committed transaction.
        /// If `start_version` is provided, the returned list contains transactions starting from `start_version`.
        /// Or else if `end_version` is provided, the returned list contains transactions ending at `end_version`.
        /// The returned list contains at most `limit` transactions.
        /// The returned list is always sorted by version in ascending order.
        fn get_account_transaction_summaries(
            &self,
            address: AccountAddress,
            start_version: Option<u64>,
            end_version: Option<u64>,
            limit: u64,
            ledger_version: Version,
        ) -> Result<Vec<IndexedTransactionSummary>>;
```

**File:** storage/db-tool/src/replay_on_archive.rs (L318-349)
```rust
    fn get_start_and_limit(
        aptos_db: &Arc<dyn DbReader>,
        start_version: Version,
        end_version: Version,
    ) -> Result<(Version, u64)> {
        let db_start = aptos_db
            .get_first_txn_version()?
            .ok_or(AptosDbError::NotFound(
                "First txn version is None".to_string(),
            ))?;
        let start = std::cmp::max(db_start, start_version);

        let db_end = aptos_db
            .get_synced_version()?
            .ok_or(AptosDbError::NotFound("Synced version is None".to_string()))?;
        let end = std::cmp::min(end_version, db_end);

        let limit = if start <= end {
            end - start + 1
        } else {
            warn!(
                start = start_version,
                db_start = db_start,
                end = end_version,
                db_end = db_end,
                "No transactions to verify in requested range."
            );
            0
        };

        Ok((start_version, limit))
    }
```
