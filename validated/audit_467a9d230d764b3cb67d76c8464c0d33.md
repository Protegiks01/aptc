# Audit Report

## Title
Order Vote Creation Race Condition Causes Network Liveness Failure Due to Non-Deterministic BlockInfo

## Summary
The `order_vote_proposal()` method creates order votes with non-deterministic `BlockInfo` that varies based on execution completion timing. This causes validators with different execution speeds to generate incompatible order votes, preventing quorum formation and blocking consensus ordering.

## Finding Description

The Aptos consensus protocol implements decoupled execution where voting and execution occur asynchronously. Regular votes correctly use deterministic dummy state, but order votes have a critical flaw that breaks this determinism.

**Regular Vote Path (Correct):**
Regular votes explicitly use `vote_data_ordering_only()` which generates deterministic BlockInfo with dummy execution state. [1](#0-0) 

This is always enabled via `decoupled_execution: true` in VoteProposal construction. [2](#0-1) 

**Order Vote Path (Vulnerable):**
Order votes use a different code path that reads the current execution state from the mutex. [3](#0-2) 

The `block_info()` method calls `compute_result()` which returns whatever state is currently stored. [4](#0-3) [5](#0-4) 

**Asynchronous Execution Updates:**
The execution pipeline asynchronously updates this state via `set_compute_result()` after execution completes. [6](#0-5) [7](#0-6) 

**Safety Rules Validation:**
Safety rules explicitly validate that the order vote's BlockInfo matches the QC's certified block. [8](#0-7) 

**BlockInfo Structure:**
BlockInfo contains execution-specific fields (`executed_state_id` and `version`) that differ between dummy and executed states. [9](#0-8) 

The `is_ordered_only()` method confirms that dummy state uses ACCUMULATOR_PLACEHOLDER_HASH and version 0. [10](#0-9) 

**The Race Condition:**
1. Block inserted with dummy state (`new_dummy()` returns ACCUMULATOR_PLACEHOLDER_HASH) [11](#0-10) 
2. Execution starts asynchronously
3. Validators vote with dummy state → QC forms with dummy state
4. Order votes created immediately after QC formation [12](#0-11) 
5. Fast validators: execution completed → `block_info()` returns executed state → order vote rejected
6. Slow validators: execution not completed → `block_info()` returns dummy state → order vote accepted

## Impact Explanation

This vulnerability causes **temporary liveness failures** in the consensus ordering phase, qualifying as **HIGH severity** per Aptos Bug Bounty criteria ("Validator Node Slowdowns" or temporary consensus stalls).

**Consensus Determinism Violation:**
The fundamental invariant that all validators must sign identical data is broken. Validators sign different BlockInfo structs depending on execution timing rather than block content.

**Liveness Impact:**
If fewer than 2f+1 validators create valid order votes (those with dummy state matching the QC), no ordered certificate can form. The ordering phase blocks until enough validators' execution catches up or times out, causing:
- Increased block finalization latency
- Potential timeout cascades
- Network slowdown during periods of execution variance

**Not Critical Because:**
- Safety is preserved (no double-spend or chain split)
- Liveness eventually recovers when execution states converge
- No permanent network halt or fund loss

## Likelihood Explanation

**MODERATE to HIGH** likelihood due to natural network conditions:

1. **Hardware Variance**: Validators run on diverse hardware (cloud, bare metal, different specs). A validator with 128 cores can execute empty blocks in <10ms while an overloaded validator may take >1 second.

2. **Network Topology**: Validators receive blocks at different times based on network distance. A 500ms delay gives early-receiving validators more time to complete execution before QC formation.

3. **Empty Blocks**: Blocks with no transactions execute extremely fast, maximizing the probability that execution completes before voting finishes.

4. **No Synchronization**: The code has no mechanism to delay order vote creation or force dummy state usage like regular votes do.

5. **Observable Timing**: QC formation requires 2f+1 votes to arrive, typically taking 100-500ms. Fast execution on empty blocks can complete in 10-50ms, creating a race window.

## Recommendation

Force order votes to use deterministic dummy state like regular votes do. Modify `order_vote_proposal()` to use the same dummy state pattern:

```rust
pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
    // Use the BlockInfo from the QC that was certified with dummy state,
    // not the potentially-executed current state
    let block_info = self.block().gen_block_info(
        *ACCUMULATOR_PLACEHOLDER_HASH,
        0,
        None, // next_epoch_state should come from QC if needed
    );
    OrderVoteProposal::new(self.block.clone(), block_info, quorum_cert)
}
```

Alternatively, wait for execution to complete before creating order votes, but this would couple ordering to execution speed and defeat the purpose of decoupled execution.

## Proof of Concept

The vulnerability can be demonstrated by observing order vote rejection patterns on a network with mixed validator hardware:

1. Deploy a test network with validators of varying compute power (fast: 64 cores, slow: 4 cores)
2. Propose empty blocks or blocks with minimal transactions
3. Monitor order vote creation with instrumentation:
   - Log the `executed_state_id` in each validator's order vote BlockInfo
   - Track safety rules rejections with Error::InvalidOneChainQuorumCertificate
4. Observe that fast validators' order votes are rejected when their BlockInfo contains executed state (non-placeholder hash) while the QC contains dummy state
5. If >1/3 of validators are fast, order vote quorum fails, delaying ordering

## Notes

This vulnerability is particularly concerning because:

1. **Determinism by Design**: The codebase explicitly implements `vote_data_ordering_only()` and `is_ordered_only()` methods, showing the developers understood the need for dummy state determinism. However, this was not applied to order votes.

2. **Natural Occurrence**: Unlike many race conditions that require precise timing control, this occurs naturally due to hardware and network variance in production environments.

3. **Increased Likelihood with Optimizations**: As execution gets faster through optimizations, the race window widens, making the bug more likely to manifest.

4. **Silent Failures**: Order vote rejections may appear as network issues rather than a systematic protocol bug, making it harder to diagnose.

### Citations

**File:** consensus/consensus-types/src/vote_proposal.rs (L60-69)
```rust
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L277-330)
```rust
    pub fn set_compute_result(
        &self,
        state_compute_result: StateComputeResult,
        execution_time: Duration,
    ) {
        let mut to_commit = 0;
        let mut to_retry = 0;
        for txn in state_compute_result.compute_status_for_input_txns() {
            match txn {
                TransactionStatus::Keep(_) => to_commit += 1,
                TransactionStatus::Retry => to_retry += 1,
                _ => {},
            }
        }

        let execution_summary = ExecutionSummary {
            payload_len: self
                .block
                .payload()
                .map_or(0, |payload| payload.len_for_execution()),
            to_commit,
            to_retry,
            execution_time,
            root_hash: state_compute_result.root_hash(),
            gas_used: state_compute_result
                .execution_output
                .block_end_info
                .as_ref()
                .map(|info| info.block_effective_gas_units()),
        };
        *self.state_compute_result.lock() = state_compute_result;

        // We might be retrying execution, so it might have already been set.
        // Because we use this for statistics, it's ok that we drop the newer value.
        if let Some(previous) = self.execution_summary.get() {
            if previous.root_hash == execution_summary.root_hash
                || previous.root_hash == *ACCUMULATOR_PLACEHOLDER_HASH
            {
                warn!(
                    "Skipping re-inserting execution result, from {:?} to {:?}",
                    previous, execution_summary
                );
            } else {
                error!(
                    "Re-inserting execution result with different root hash: from {:?} to {:?}",
                    previous, execution_summary
                );
            }
        } else {
            self.execution_summary
                .set(execution_summary)
                .expect("inserting into empty execution summary");
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L440-442)
```rust
    pub fn compute_result(&self) -> StateComputeResult {
        self.state_compute_result.lock().clone()
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L461-469)
```rust
    pub fn vote_proposal(&self) -> VoteProposal {
        let compute_result = self.compute_result();
        VoteProposal::new(
            compute_result.extension_proof(),
            self.block.clone(),
            compute_result.epoch_state().clone(),
            true,
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/src/pipeline/execution_schedule_phase.rs (L70-77)
```rust
        let fut = async move {
            for b in ordered_blocks.iter_mut() {
                let (compute_result, execution_time) = b.wait_for_compute_result().await?;
                b.set_compute_result(compute_result, execution_time);
            }
            Ok(ordered_blocks)
        }
        .boxed();
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/block_info.rs (L209-214)
```rust
    pub fn is_ordered_only(&self) -> bool {
        *self != BlockInfo::empty()
            && self.next_epoch_state.is_none()
            && self.executed_state_id == *ACCUMULATOR_PLACEHOLDER_HASH
            && self.version == 0
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/round_manager.rs (L1805-1815)
```rust
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
```
