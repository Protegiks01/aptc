Based on my comprehensive analysis of the Aptos Core codebase, I can confirm this is a **VALID VULNERABILITY**. All claims have been verified against the actual implementation.

# Audit Report

## Title
Block Epilogue Failure Silently Skips Fee Distribution While Keeping Block

## Summary
The `process_block_epilogue()` function contains overly permissive error handling that returns a success status even when block epilogue execution fails, causing permanent loss of transaction fees for validators when validator set changes occur during epoch transitions.

## Finding Description
The vulnerability exists in the interaction between block execution, epoch reconfiguration, and fee distribution. The execution flow is:

**Normal Flow:**

1. Consensus sets proposer_index in transaction auxiliary_info based on the current validator set at block construction time, before any execution begins. [1](#0-0) 

2. Block prologue executes and checks if the epoch interval has elapsed, triggering reconfiguration if needed. [2](#0-1) 

3. During reconfiguration, `stake::on_new_epoch()` is called. [3](#0-2) 

4. The `on_new_epoch()` function creates a new validator set by filtering validators below minimum stake and clearing pending_inactive validators. [4](#0-3)  Then reassigns validator indices sequentially starting from 0 for the NEW active validator set. [5](#0-4) 

5. The `pending_fee_by_validator` map is cleared (asserted empty) and repopulated with aggregators only for the NEW active validators using their NEW indices. [6](#0-5) 

6. Block epilogue calls `block::block_epilogue` with fee distribution data containing the OLD proposer indices. [7](#0-6) 

7. Which calls `stake::record_fee` with proposer indices from before reconfiguration. [8](#0-7) 

8. `record_fee` calls `borrow_mut` on the map with the old proposer index. [9](#0-8) 

**Vulnerability Trigger:**

When validators leave during epoch reconfiguration (either by requesting to leave or falling below minimum stake), the new validator set has fewer validators. If the proposer_index from transactions is >= the new validator count, `borrow_mut` aborts with `EKEY_NOT_FOUND` because the key doesn't exist in the repopulated map. [10](#0-9) 

**Broken Error Handling:**

The error is caught and the system logs an error message but returns success with empty output, keeping the block but skipping all fee distribution. [11](#0-10) 

This breaks the security guarantee that validator rewards and penalties must be calculated correctly, as fees are permanently lost without any recovery mechanism.

## Impact Explanation

**Medium Severity** - Qualifies as "Limited funds loss or manipulation" under Aptos bug bounty Medium severity criteria.

**Specific Impacts:**

1. **Permanent Financial Loss**: All transaction fees from affected blocks are permanently lost to validators. There is no on-chain recovery mechanism.

2. **No Detection/Recovery**: Only error logs exist; validators have no way to detect they lost fees or recover them.

3. **State Inconsistency**: Violates the protocol invariant that all successful blocks must distribute transaction fees to the proposing validator.

4. **Silent Failure**: The block is kept as successful, creating a disconnect between block execution status and fee distribution status.

The impact is limited to fee loss from individual blocks (not total network funds) but is permanent and unrecoverable, justifying Medium severity under the bug bounty criteria.

## Likelihood Explanation

**Low to Medium** - Requires specific conditions but can occur naturally through normal protocol operation:

**Required Conditions:**
1. Block triggers epoch reconfiguration (happens at scheduled intervals)
2. At least one validator leaves the active set during reconfiguration (via pending_inactive or stake falling below minimum)
3. Proposer's old index becomes >= new validator count

**Likelihood Factors:**
- Epoch transitions are scheduled events that happen regularly
- Validator departures do occur in practice when validators request to leave or their stake falls below minimum requirements
- The specific index mismatch depends on which validators leave and which validator proposes the reconfiguration block
- No attacker control required - this happens naturally through protocol operation
- The vulnerability is deterministic once the conditions are met

**Real-World Scenario:**
If the last validator (or any high-indexed validator) in a 100-validator set proposes the block that triggers epoch reconfiguration, and 2 validators leave (reducing the set to 98 validators), the proposer_index of 99 would fail to find a match in the new map with indices 0-97, causing all fees from that block to be permanently lost.

## Recommendation

The fix should ensure that fee distribution uses validator indices that are valid in the post-reconfiguration state. Several approaches could work:

**Option 1**: Map old proposer indices to new indices during reconfiguration
- Maintain a mapping of oldâ†’new validator indices during `on_new_epoch`
- Apply this mapping when recording fees in the epilogue

**Option 2**: Record fees before reconfiguration
- Ensure fee recording happens before `on_new_epoch` reassigns indices
- This would require restructuring when fees are distributed

**Option 3**: Use validator addresses instead of indices for fee distribution
- Change `pending_fee_by_validator` to use validator pool addresses as keys
- This eliminates the index mismatch issue entirely

**Option 4**: Fail the block if epilogue fails
- Remove the fallback success return in `process_block_epilogue`
- This prevents silent fee loss but may impact liveness

The recommended approach is **Option 3** as it provides the most robust solution by eliminating the root cause of index mismatches during reconfiguration.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Deploy a test network with 100 validators
2. Configure 2 validators to request leaving the validator set
3. Ensure validator at index 99 is scheduled to propose the next block
4. Wait for epoch interval to elapse
5. Observe that the block with reconfiguration succeeds but fees are lost
6. Check error logs for "Unexpected error from BlockEpilogue txn"
7. Verify on-chain that the proposer did not receive fees for that block

The vulnerability is inherent in the code structure where proposer indices are frozen at block construction time but validator indices are reassigned during reconfiguration within the same block's execution.

## Notes

This vulnerability demonstrates a timing issue in the Aptos protocol where state changes during block execution (epoch reconfiguration) invalidate data prepared before block execution (proposer indices). The error handling in `process_block_epilogue` was designed to be defensive to prevent chain halts, but this creates a silent failure mode that permanently loses validator fees. The issue affects mainnet and requires no attacker involvement - it will occur naturally during epoch transitions when validator set size decreases.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L827-829)
```rust
        let proposer_index = block
            .author()
            .and_then(|proposer| validator.iter().position(|&v| v == proposer));
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L244-246)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L254-254)
```text
        stake::record_fee(vm, fee_distribution_validator_indices, fee_amounts_octa);
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L134-134)
```text
        stake::on_new_epoch();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L632-632)
```text
            pending_fee.pending_fee_by_validator.borrow_mut(&validator_index).add(fee_octa);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1409-1428)
```text
        let validator_index = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(validator_set.active_validators);
                invariant len(validator_set.pending_active) == 0;
                invariant len(validator_set.pending_inactive) == 0;
                invariant 0 <= validator_index && validator_index <= vlen;
                invariant vlen == len(validator_set.active_validators);
                invariant forall i in 0..validator_index:
                    global<ValidatorConfig>(validator_set.active_validators[i].addr).validator_index < validator_index;
                invariant forall i in 0..validator_index:
                    validator_set.active_validators[i].config.validator_index < validator_index;
                invariant len(validator_perf.validators) == validator_index;
            };
            validator_index < vlen
        }) {
            let validator_info = vector::borrow_mut(&mut validator_set.active_validators, validator_index);
            validator_info.config.validator_index = validator_index;
            let validator_config = borrow_global_mut<ValidatorConfig>(validator_info.addr);
            validator_config.validator_index = validator_index;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1454-1458)
```text
        if (exists<PendingTransactionFee>(@aptos_framework)) {
            let pending_fee_by_validator = &mut borrow_global_mut<PendingTransactionFee>(@aptos_framework).pending_fee_by_validator;
            assert!(pending_fee_by_validator.is_empty(), error::internal(ETRANSACTION_FEE_NOT_FULLY_DISTRIBUTED));
            validator_set.active_validators.for_each_ref(|v| pending_fee_by_validator.add(v.config.validator_index, aggregator_v2::create_unbounded_aggregator<u64>()));
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2593-2604)
```rust
        let output = match session
            .execute_function_bypass_visibility(
                &BLOCK_MODULE,
                BLOCK_EPILOGUE,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .or_else(|e| expect_only_successful_execution(e, BLOCK_EPILOGUE.as_str(), log_context))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2611-2617)
```rust
            Err(e) => {
                error!(
                    "Unexpected error from BlockEpilogue txn: {e:?}, fallback to return success."
                );
                let status = TransactionStatus::Keep(ExecutionStatus::Success);
                VMOutput::empty_with_status(status)
            },
```

**File:** aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move (L597-601)
```text
    public fun borrow_mut<K: drop + copy + store, V: store>(self: &mut BigOrderedMap<K, V>, key: &K): &mut V {
        let iter = self.internal_find(key);
        assert!(!iter.iter_is_end(self), error::invalid_argument(EKEY_NOT_FOUND));
        iter.iter_borrow_mut(self)
    }
```
