# Audit Report

## Title
Optimistic Proposal Equivocation Attack via Missing Signature Validation and Buffer Overwriting

## Summary
`OptProposalMsg` lacks cryptographic signature validation and uses a buffer with overwrite semantics, allowing a malicious proposer to send conflicting proposals to different validators, causing vote splitting and consensus liveness failures.

## Finding Description

**Validation Gap Between ProposalMsg and OptProposalMsg:**

For regular proposals, `ProposalMsg` requires BLS signature verification through `validate_signature()` [1](#0-0) 

In contrast, `OptProposalMsg` only verifies that the network-authenticated sender matches the claimed author, without cryptographic signature verification [2](#0-1) 

When converted to a Block, optimistic proposals explicitly have no signature [3](#0-2) 

Signature validation for `OptimisticProposal` blocks only verifies QCs, not the proposer's signature, as explicitly noted in the code comment [4](#0-3) 

**Buffer Overwriting Vulnerability:**

OptProposalMsg messages for future rounds are buffered in a `BTreeMap<Round, OptBlockData>` structure [5](#0-4) 

The critical issue is that `BTreeMap::insert()` overwrites any existing entry for the same round [6](#0-5) 

Before buffering, only `is_valid_proposer()` is called, which checks if the author is the designated proposer but does NOT detect equivocation [7](#0-6) 

The equivocation detection logic in `UnequivocalProposerElection::is_valid_proposal()` tracks previously seen proposals [8](#0-7) 

However, this check is only called later during `process_proposal()` [9](#0-8) , after the buffer has already been overwritten. Each validator only processes one proposal, so equivocation is never detected.

**Attack Scenario:**

1. Malicious validator M is elected proposer for round R
2. M crafts two different OptProposalMsg (A and B) with different payloads
3. M sends OptProposalMsg_A to validators V1, V2 and OptProposalMsg_B to validators V3, V4
4. Due to network timing or controlled message ordering, different validators end up with different proposals in their buffers
5. When validators advance to round R, they process different blocks from their buffers
6. Votes split between the conflicting proposals
7. Neither achieves 2/3+ quorum, causing round timeout and liveness failure

This is **not possible** with regular ProposalMsg because they are processed immediately or discarded as stale, not buffered [10](#0-9) 

## Impact Explanation

This vulnerability enables a **consensus liveness attack** with **High Severity** impact:

- **Significant Protocol Violation**: Malicious proposer can prevent consensus progress during their elected rounds
- **Repeated Attacks**: Can be executed every time the malicious validator is elected proposer
- **No Collusion Required**: Single malicious proposer (< 1/3 Byzantine assumption)
- **Temporary Network Unavailability**: Consensus cannot make progress during affected rounds, but recovers after timeout

According to Aptos bug bounty criteria, "Validator node slowdowns" and "Significant protocol violations" qualify as **High Severity** ($50,000). This fits the High category because it causes temporary liveness disruption but the network recovers after the round timeout.

## Likelihood Explanation

**High Likelihood** - This attack is realistic and straightforward:

1. **Attacker Requirements**: Only need to be a validator who occasionally gets elected as proposer
2. **Technical Complexity**: Low - simply craft two different OptProposalMsg and control network message timing
3. **Detection Difficulty**: Hard to distinguish from benign network delays or message reordering
4. **Frequency**: Occurs whenever malicious proposer is elected (probabilistic based on validator count)
5. **No Cryptographic Proof**: Unlike ProposalMsg equivocation (which leaves signed evidence), OptProposalMsg equivocation leaves no cryptographic trace, only network-level evidence

## Recommendation

Implement equivocation detection before buffering OptProposalMsg:

1. Track seen OptProposalMsg per round before inserting into buffer
2. Reject duplicate OptProposalMsg for the same round with different block IDs
3. Alternatively, add BLS signature requirement to OptProposalMsg similar to regular ProposalMsg

Example fix in `process_opt_proposal_msg()`:
- Before line 832, check if `pending_opt_proposals` already contains an entry for this round
- If yes, verify the block_data hash matches the existing entry
- If hashes differ, reject and log security event for equivocation attempt

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with 4 validators
2. Having a malicious proposer send two different OptProposalMsg (with different payloads but same round) to different subsets of validators
3. Using network layer controls to ensure validators receive messages in different orders
4. Observing that different validators buffer different proposals
5. Confirming vote splitting when the round is reached
6. Verifying that no equivocation is detected despite conflicting proposals

The attack succeeds because the equivocation check at line 1196 only sees one proposal per validator (the last one received), never both conflicting proposals simultaneously.

## Notes

This vulnerability represents a genuine gap in the optimistic proposal protocol's security model. While optimistic proposals are designed to improve latency by avoiding signature verification, the lack of equivocation detection at the buffering stage creates an exploitable window for consensus disruption. The fix should either add signature validation or implement proper equivocation detection before buffering.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L97-110)
```rust
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L103-108)
```rust
        ensure!(
            self.proposer() == sender,
            "OptProposal author {:?} doesn't match sender {:?}",
            self.proposer(),
            sender
        );
```

**File:** consensus/consensus-types/src/block.rs (L410-416)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
```

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/src/round_manager.rs (L330-330)
```rust
    pending_opt_proposals: BTreeMap<Round, OptBlockData>,
```

**File:** consensus/src/round_manager.rs (L743-764)
```rust
        let in_correct_round = self
            .ensure_round_and_sync_up(
                proposal_msg.proposal().round(),
                proposal_msg.sync_info(),
                proposal_msg.proposer(),
            )
            .await
            .context("[RoundManager] Process proposal")?;
        if in_correct_round {
            self.process_proposal(proposal_msg.take_proposal()).await
        } else {
            sample!(
                SampleRate::Duration(Duration::from_secs(30)),
                warn!(
                    "[sampled] Stale proposal {}, current round {}",
                    proposal_msg.proposal(),
                    self.round_state.current_round()
                )
            );
            counters::ERROR_COUNT.inc();
            Ok(())
        }
```

**File:** consensus/src/round_manager.rs (L825-831)
```rust
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
```

**File:** consensus/src/round_manager.rs (L832-833)
```rust
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```
