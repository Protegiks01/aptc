# Audit Report

## Title
Silent Error Suppression in Abort Hook Allows Uncharged State Modifications

## Summary
The `finish_aborted_transaction` function in AptosVM suppresses errors from `charge_change_set` during abort hook execution, allowing state modifications from account creation to be applied without full gas charging. This violates the protocol invariant that all state changes must be properly charged.

## Finding Description

The abort hook mechanism implements lazy account creation when transactions abort, ensuring senders can pay gas fees even if their account doesn't exist. However, a critical error handling flaw exists in the gas charging logic. [1](#0-0) 

When `charge_change_set` is called on the abort hook session's change set, errors are caught and only logged—execution continues regardless. This is problematic because:

**1. Iterative Charging with Early Exit**: The `charge_change_set` function charges gas sequentially for transaction size, events, and writes: [2](#0-1) 

Each charging operation uses the `?` operator, causing early return on failure. The gas meter is mutated incrementally, so partial charging occurs before the error.

**2. Gas Meter Incremental Mutation**: The charging operations in the gas algebra modify state incrementally: [3](#0-2) 

When `OUT_OF_GAS` or `IO_LIMIT_REACHED` occurs, previous charges have already been applied to the gas meter, but subsequent operations remain uncharged.

**3. Unmetered Retry Mechanism**: The abort hook includes fallback to unmetered execution: [4](#0-3) 

Account creation can succeed with `UnmeteredGasMeter`, producing a change set. When `charge_change_set` subsequently fails to charge for these operations, the error is suppressed.

**4. Validation Checks Total Fee, Not Individual Charges**: The validation only verifies the total fee meets a minimum threshold: [5](#0-4) 

Critically, `gas_used` reflects ALL gas charged during the transaction (including main execution), not just abort hook charges. If the main transaction consumed significant gas before aborting, the validation passes even when abort hook charges failed.

**5. Uncharged Changes Applied to Blockchain**: Despite charging failure, the abort hook change set is used as the base for the epilogue: [6](#0-5) [7](#0-6) 

The epilogue incorporates these changes and produces VMOutput that gets applied to blockchain state, including operations that were never charged.

**Attack Scenario**:
1. Attacker sends transaction to non-existent account that aborts after consuming significant IO gas
2. Abort hook triggers account creation with regular gas meter—fails due to insufficient gas
3. Account creation retries with `UnmeteredGasMeter`, succeeding
4. `charge_change_set` attempts to charge for the change set
5. After charging some operations (e.g., transaction size), it hits `IO_LIMIT_REACHED` or `OUT_OF_GAS`
6. Error is caught and logged (line 750-753), execution continues
7. Validation checks: `gas_used * price + storage_fee >= minimum_account_fee`
8. Validation passes because `gas_used` includes main transaction's 10,000+ gas units
9. Abort hook change set (with uncharged operations) applied to blockchain
10. Attacker successfully creates account while only paying for fraction of operations

## Impact Explanation

This vulnerability represents a **MEDIUM-HIGH severity** protocol violation:

**Protocol Invariant Violation**: Violates the fundamental requirement that all state modifications must be fully charged for. While account creation is relatively small (typically 1 write), the principle violation is significant.

**Gas Metering Bypass**: Allows transactions to apply state changes without full gas payment by exploiting error suppression during abort hook processing.

**Limited Practical Impact**: The uncharged operations are constrained to abort hook account creation. The attacker must still pay for meaningful transaction execution that consumes gas and aborts. This is not a complete bypass but rather a partial discount on account creation costs.

**Not Consensus-Breaking**: All validators execute the identical buggy code path deterministically, so no consensus split occurs. However, it undermines gas economics intended to prevent resource abuse.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability is exploitable under realistic conditions:

- **No Special Privileges**: Any transaction sender can trigger by sending to a non-existent account
- **Straightforward Setup**: Requires crafting transaction that consumes significant IO gas and aborts (achievable through large state reads)
- **Automatic Exploitation**: Once conditions met, error suppression automatically applies changes
- **Tuning Required**: Attacker must carefully calibrate gas consumption so that: (a) main transaction consumes enough for validation to pass, (b) gas meter state causes abort hook charging to fail partway through

The required gas consumption tuning elevates complexity from trivial to moderate, hence MEDIUM likelihood.

## Recommendation

Modify `finish_aborted_transaction` to propagate errors from `charge_change_set` instead of suppressing them:

```rust
// Replace lines 743-754 with:
self.charge_change_set(
    &mut abort_hook_session_change_set,
    gas_meter,
    txn_data,
    resolver,
    module_storage,
)?; // Propagate error instead of catching
```

Alternatively, if error suppression is intentional for specific edge cases, implement atomic charging where the gas meter is only updated if ALL charges succeed, or enhance validation to verify that all individual operations in the change set were successfully charged.

## Proof of Concept

No executable PoC provided. However, the vulnerability can be verified by:
1. Examining the code citations above confirming error suppression
2. Creating a transaction that consumes 95% of IO gas limit through state reads
3. Causing transaction to abort (e.g., assert failure)
4. Observing that account creation occurs but abort hook charges may fail with `IO_LIMIT_REACHED`
5. Validating that transaction succeeds despite charging failure due to error suppression

A complete Rust test would require mocking gas meter state and change sets to demonstrate partial charging scenario.

---

**Notes**:
- This vulnerability is constrained to abort hook account creation operations, not arbitrary state modifications
- The validation checking total fee vs. minimum threshold was likely designed as a safety check, but becomes insufficient when charging fails partway through
- The economic impact per transaction is limited since attackers still pay for main execution costs
- The cumulative impact could be more significant if exploited at scale across many transactions

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L722-730)
```rust
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L760-785)
```rust
            let gas_params = self.gas_params(log_context)?;
            let gas_unit_price = u64::from(txn_data.gas_unit_price());
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L786-786)
```rust
            (abort_hook_session_change_set, fee_statement)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L793-821)
```rust
        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );

        // Abort information is injected using the user defined error in the Move contract.
        let status = self.inject_abort_info_if_available(
            module_storage,
            traversal_context,
            log_context,
            status,
        );
        epilogue_session.execute(|session| {
            transaction_validation::run_failure_epilogue(
                session,
                module_storage,
                serialized_signers,
                gas_meter.balance(),
                fee_statement,
                self.features(),
                txn_data,
                log_context,
                traversal_context,
                self.is_simulation,
            )
        })?;
        epilogue_session.finish(fee_statement, status, change_set_configs, module_storage)
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1112-1139)
```rust
    fn charge_change_set(
        &self,
        change_set: &mut impl ChangeSetInterface,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<GasQuantity<Octa>, VMStatus> {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }

        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
        if !self.features().is_storage_deletion_refund_enabled() {
            storage_refund = 0.into();
        }

        Ok(storage_refund)
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L211-235)
```rust
    fn charge_io(
        &mut self,
        abstract_amount: impl GasExpression<VMGasParameters, Unit = InternalGasUnit>,
    ) -> PartialVMResult<()> {
        let amount = abstract_amount.evaluate(self.feature_version, &self.vm_gas_params);

        match self.balance.checked_sub(amount) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.io_gas_used += amount;
            },
            None => {
                let old_balance = self.balance;
                self.balance = 0.into();
                if self.feature_version >= 12 {
                    self.io_gas_used += old_balance;
                }
                return Err(PartialVMError::new(StatusCode::OUT_OF_GAS));
            },
        };

        if self.feature_version >= 7 && self.io_gas_used > self.max_io_gas {
            Err(PartialVMError::new(StatusCode::IO_LIMIT_REACHED))
        } else {
            Ok(())
```
