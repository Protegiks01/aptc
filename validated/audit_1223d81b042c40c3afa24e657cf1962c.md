# Audit Report

## Title
Event Sequence Number Collision When MODULE_EVENT_MIGRATION Flag Is Toggled

## Summary
When the `MODULE_EVENT_MIGRATION` feature flag is toggled between enabled and disabled states via governance, V1 events and translated V2 events can be assigned duplicate sequence numbers for the same event key, causing EventByKeySchema collisions, event loss, and indexer corruption.

## Finding Description

The Aptos event indexing system maintains two parallel event formats during the V1-to-V2 migration: EventHandle-based V1 events and directly-emitted V2 events. The `MODULE_EVENT_MIGRATION` feature flag controls which format is emitted at execution time.

**Critical Technical Gap:**

When V1 events are emitted via `emit_event`, the on-chain `EventHandle.counter` field is incremented: [1](#0-0) 

When V2 events are emitted via `emit`, EventHandles are bypassed entirely—no counter is incremented: [2](#0-1) 

The framework conditionally emits V1 or V2 events based on the feature flag: [3](#0-2) 

The indexer translates V2 events back to V1 format for backward compatibility. The sequence number assignment logic uses the on-chain EventHandle counter as a fallback when no cached or persisted value exists: [4](#0-3) [5](#0-4) 

**The Vulnerability:**

When the feature flag is toggled from enabled (V2) back to disabled (V1), the on-chain EventHandle counters have NOT been updated to account for V2 events emitted during the V2 period. This causes V1 events to reuse sequence numbers already assigned to translated V2 events by the indexer.

The EventByKeySchema uses `(EventKey, SeqNum)` as a unique key: [6](#0-5) 

When V1 events write to keys already used by translated V2 events, RocksDB overwrites the previous entries, causing the translated V2 events to be lost from the index. The indexer writes both V1 and translated V2 events to EventByKeySchema during batch processing: [7](#0-6) [8](#0-7) 

While the indexer persists sequence numbers to EventSequenceNumberSchema: [9](#0-8) 

The on-chain EventHandle counters operate independently and are not synchronized when the flag state changes.

## Impact Explanation

This qualifies as **MEDIUM to HIGH severity** based on data integrity impact:

1. **Event Loss**: The EventByKeySchema collision causes translated V2 events to be overwritten and become permanently unretrievable via sequence number queries, breaking event history guarantees that applications depend on.

2. **Indexer Corruption**: The same sequence number maps to different events at different versions, violating the invariant that sequence numbers must be unique and monotonic per event key.

3. **State Inconsistencies**: Applications querying historical events via `lookup_events_by_key` will receive incorrect data: [10](#0-9) 

4. **Infrastructure Impact**: This affects all nodes running the internal indexer with `enable_event_v2_translation=true`, impacting the network's event query infrastructure.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Normal Governance Operation**: The `MODULE_EVENT_MIGRATION` flag is explicitly designed to be toggled via governance proposals. The pattern is demonstrated throughout the framework, with examples in multiple modules checking the flag state: [11](#0-10) 

2. **No Protection Mechanisms**: No synchronization code exists that updates on-chain EventHandle counters based on the indexer's EventSequenceNumberSchema when the flag state changes. The on-chain counters and indexer state operate independently.

3. **Immediate Impact**: The collision occurs as soon as the first V1 event is emitted after toggling the flag back to OFF.

4. **Affects All Event Types**: Any event type using both V1 EventHandles and V2 emission (coin deposits/withdrawals, token events, governance events, staking events) is vulnerable.

## Recommendation

Implement a synchronization mechanism when the `MODULE_EVENT_MIGRATION` flag is toggled:

1. Add an on-chain record tracking the highest sequence number assigned by the indexer for each event key
2. When toggling from V2 to V1, update all relevant EventHandle counters to match the indexer's sequence numbers
3. Alternatively, prevent backward toggles once V2 migration begins, making it a one-way migration

## Proof of Concept

A Move integration test demonstrating the vulnerability would:

1. Create an account with a CoinStore (containing deposit_events EventHandle)
2. Emit V1 deposit events with flag OFF → counter increments to 5
3. Toggle flag ON via governance 
4. Emit V2 deposit events → indexer assigns seq 5, 6, 7 (on-chain counter still 5)
5. Toggle flag OFF via governance
6. Emit V1 deposit events → reuses seq 5, 6, 7 (counter still 5)
7. Query EventByKeySchema → V2-translated events at seq 5, 6, 7 are overwritten

### Citations

**File:** aptos-move/framework/aptos-framework/sources/event.move (L17-19)
```text
    public fun emit<T: store + drop>(msg: T) {
        write_module_event_to_store<T>(msg);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L54-60)
```text
    public fun emit_event<T: drop + store>(handle_ref: &mut EventHandle<T>, msg: T) {
        write_to_event_store<T>(bcs::to_bytes(&handle_ref.guid), handle_ref.counter, msg);
        spec {
            assume handle_ref.counter + 1 <= MAX_U64;
        };
        handle_ref.counter += 1;
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L219-233)
```text
            if (std::features::module_event_migration_enabled()) {
                emit(
                    DirectCoinTransferConfigUpdated {
                        account: addr,
                        new_allow_direct_transfers: allow
                    }
                );
            } else {
                emit_event(
                    &mut direct_transfer_config.update_coin_transfer_events,
                    DirectCoinTransferConfigUpdatedEvent {
                        new_allow_direct_transfers: allow
                    }
                );
            };
```

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L248-257)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L25-26)
```rust
type SeqNum = u64;
type Key = (EventKey, SeqNum);
```

**File:** storage/indexer/src/db_indexer.rs (L209-245)
```rust
    pub fn lookup_events_by_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        limit: u64,
        ledger_version: u64,
    ) -> Result<
        Vec<(
            u64,     // sequence number
            Version, // transaction version it belongs to
            u64,     // index among events for the same transaction
        )>,
    > {
        let mut iter = self.db.iter::<EventByKeySchema>()?;
        iter.seek(&(*event_key, start_seq_num))?;

        let mut result = Vec::new();
        let mut cur_seq = start_seq_num;
        for res in iter.take(limit as usize) {
            let ((path, seq), (ver, idx)) = res?;
            if path != *event_key || ver > ledger_version {
                break;
            }
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
            result.push((seq, ver, idx));
            cur_seq += 1;
        }

        Ok(result)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L434-446)
```rust
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
```

**File:** storage/indexer/src/db_indexer.rs (L448-483)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
```

**File:** storage/indexer/src/db_indexer.rs (L511-521)
```rust
            for event_key in event_keys {
                batch
                    .put::<EventSequenceNumberSchema>(
                        &event_key,
                        &self
                            .event_v2_translation_engine
                            .get_cached_sequence_number(&event_key)
                            .unwrap_or(0),
                    )
                    .expect("Failed to put events by key to a batch");
            }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L472-472)
```text
    public fun module_event_migration_enabled(): bool acquires Features {
```
