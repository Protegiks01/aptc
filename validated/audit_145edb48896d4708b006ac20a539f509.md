# Audit Report

## Title
Semantically Invalid PayloadUnavailable Timeout with All-Zeros BitVec Causes Incorrect Failure Tracking

## Summary
The timeout aggregation logic in the consensus layer can create a `PayloadUnavailable` timeout reason with an all-zeros `missing_authors` BitVec, which is semantically contradictory. This causes the failure tracker to degrade optimistic quorum store performance without excluding any problematic validators, leading to unnecessary liveness degradation.

## Finding Description

The vulnerability exists in the timeout reason aggregation logic where multiple validators report payload unavailability.

The `check_payload_availability` method correctly ensures that if all batches are available (all zeros BitVec), it returns `Ok(())` rather than an error. [1](#0-0) 

However, the `aggregated_timeout_reason` method in `TwoChainTimeoutVotes` aggregates timeout votes from multiple validators by accumulating voting power. [2](#0-1) 

When computing the aggregated missing authors BitVec, the code creates a new all-zeros BitVec and only sets bits for authors reported missing by validators with f+1 total voting power. [3](#0-2) 

**The vulnerability occurs when**: If f+1 validators report `PayloadUnavailable` (meeting the threshold at line 127-130), but each reports different missing authors such that NO single author reaches the f+1 threshold (checked at lines 138-141), the result is `PayloadUnavailable { missing_authors: <all zeros> }`.

This exact scenario is demonstrated in the test suite where validators report different missing authors, total PayloadUnavailable voting power reaches threshold, but no individual author reaches threshold, resulting in an all-zeros BitVec. [4](#0-3) 

This semantically invalid state is consumed by the failure tracker. The `compute_failure_window` method treats any `PayloadUnavailable` as a failure and doubles the failure window. [5](#0-4) 

However, when computing which authors to exclude, the `get_exclude_authors` method iterates over `missing_authors.iter_ones()`, which returns no authors for an all-zeros BitVec, resulting in an empty exclusion set. [6](#0-5) 

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring manual intervention" because:

1. **Liveness Degradation**: The system unnecessarily reduces optimistic proposal frequency by doubling the failure window without addressing the root cause
2. **Protocol Correctness**: Creates semantically contradictory state that violates the invariant that PayloadUnavailable should identify specific problematic validators
3. **Persistent Issue**: The problem can recur across multiple rounds, compounding the performance impact through exponential window growth
4. **No Automatic Recovery**: Requires manual investigation to understand why optimistic quorum store is degraded despite no validators being excluded

This does not reach High/Critical severity because:
- It does not affect consensus safety (validators still agree on blocks)
- It does not enable fund theft or loss
- It does not cause permanent network halt
- It affects performance/liveness optimization rather than core protocol safety

## Likelihood Explanation

**Likelihood: Medium**

This can occur naturally in production under realistic distributed system conditions:
- **Network partitions**: Different validators observe different batch availability due to network delays or partitions
- **Transient failures**: Temporary unavailability of batches from different validators at different times
- **No attack required**: The scenario emerges from normal distributed system asynchrony where f+1 validators experience payload issues but disagree on which specific authors are problematic

The test suite confirms this is not a theoretical edge case but an expected behavior under certain network conditions. The vulnerability does not require Byzantine behavior, just natural variance in network observations across validators.

## Recommendation

Add a validation check in `aggregated_timeout_reason` to prevent returning `PayloadUnavailable` with an all-zeros `missing_authors` BitVec. If the aggregated BitVec would be all-zeros, the method should either:

1. Return `RoundTimeoutReason::Unknown` instead, or
2. Fall back to the second-highest voted reason

Example fix in `pending_votes.rs`:

```rust
if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
    for (author_idx, voting_power) in missing_batch_authors {
        if verifier
            .check_aggregated_voting_power(voting_power, false)
            .is_ok()
        {
            aggregated_bitvec.set(author_idx as u16);
        }
    }
    // Prevent semantically invalid all-zeros PayloadUnavailable
    if aggregated_bitvec.all_zeros() {
        return RoundTimeoutReason::Unknown;
    }
    RoundTimeoutReason::PayloadUnavailable {
        missing_authors: aggregated_bitvec,
    }
} else {
    reason
}
```

## Proof of Concept

The existing test demonstrates the vulnerability. To verify the impact, add this test to `proposal_status_tracker.rs`:

```rust
#[test]
fn test_all_zeros_payload_unavailable_degrades_performance() {
    let (_signers, verifier) = random_validator_verifier(4, None, false);
    let mut tracker = ExponentialWindowFailureTracker::new(100, verifier.get_ordered_account_addresses());
    
    // Push successful rounds
    tracker.push(NewRoundReason::QCReady);
    tracker.push(NewRoundReason::QCReady);
    assert_eq!(tracker.window, 2);
    
    // Push PayloadUnavailable with all-zeros (the vulnerability)
    tracker.push(NewRoundReason::Timeout(
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: BitVec::with_num_bits(4), // all zeros
        },
    ));
    
    // Window doubles even though no specific authors are problematic
    assert_eq!(tracker.window, 4);
    
    // No authors are excluded despite the failure
    let exclude_authors = tracker.get_exclude_authors();
    assert!(exclude_authors.is_empty()); // This is the bug!
}
```

This demonstrates that the failure window increases without learning which validators to exclude, causing unnecessary performance degradation.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L420-424)
```rust
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/pending_votes.rs (L93-118)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
```

**File:** consensus/src/pending_votes.rs (L136-144)
```rust
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
```

**File:** consensus/src/pending_votes_test.rs (L125-161)
```rust
    // Not enough nodes vote for the same node.
    let timeout = TwoChainTimeout::new(epoch, round, QuorumCert::dummy());
    let mut two_chain_timeout_votes = TwoChainTimeoutVotes::new(timeout);

    let author = signers[2].author();
    let timeout = TwoChainTimeout::new(epoch, round, QuorumCert::dummy());
    let signature = signers[2].sign(&timeout.signing_format()).unwrap();
    two_chain_timeout_votes.add(
        author,
        timeout,
        signature,
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: vec![false, true, false, false].into(),
        },
    );

    let author = signers[3].author();
    let timeout = TwoChainTimeout::new(epoch, round, QuorumCert::dummy());
    let signature = signers[3].sign(&timeout.signing_format()).unwrap();
    two_chain_timeout_votes.add(
        author,
        timeout,
        signature,
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: vec![false, false, false, true].into(),
        },
    );

    let (_, aggregate_timeout_reason) = two_chain_timeout_votes.unpack_aggregate(&verifier);

    assert_eq!(
        aggregate_timeout_reason,
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: BitVec::with_num_bits(4)
        }
    );
}
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```
