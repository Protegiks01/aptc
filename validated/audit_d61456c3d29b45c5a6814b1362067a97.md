# Audit Report

## Title
Optimistic Proposal Race Condition Enables Vote Splitting Through Last-Write-Wins Buffer Semantics

## Summary
A malicious validator elected as round leader can exploit the optimistic proposal buffering mechanism to cause consensus liveness failures. By broadcasting multiple conflicting optimistic proposals for the same round, the attacker leverages the last-write-wins semantics of `pending_opt_proposals` to ensure different validators process different proposals, splitting votes and preventing quorum certificate formation.

## Finding Description

The vulnerability exists in the optimistic proposal buffering mechanism within the Aptos consensus layer. When an `OptProposalMsg` is received for a future round, it's stored in `pending_opt_proposals`, a `BTreeMap<Round, OptBlockData>` that maps rounds to block data. [1](#0-0) 

The critical flaw occurs during buffering in `process_opt_proposal_msg()`. When an optimistic proposal arrives for a future round, the code validates that the proposer is valid for that round, then unconditionally inserts the proposal into the buffer using `BTreeMap::insert()`: [2](#0-1) 

The `BTreeMap::insert()` method has last-write-wins semantics - it silently overwrites any existing value for the same round key. There is no check for whether a proposal already exists, and no validation that the new proposal has the same block ID as any previously buffered proposal.

**Attack Scenario:**

1. **Byzantine Validator Preparation**: Malicious validator V1 is elected leader for round R

2. **Crafting Conflicting Proposals**: V1 creates two distinct optimistic proposals with different transaction payloads. Since `OptBlockData` derives `CryptoHasher`, different payloads produce different block IDs: [3](#0-2) 

3. **Broadcasting**: V1 broadcasts both proposals to the network using the standard broadcast mechanism: [4](#0-3) 

4. **Non-deterministic Delivery**: The network broadcast has no ordering guarantees, causing different validators to receive messages in different orders

5. **Buffering with Overwrites**: Each validator buffers the proposals as they arrive. Due to `BTreeMap::insert()` semantics, only the last received proposal per round is retained. Different validators retain different "last" proposals.

6. **Round Advancement**: When validators advance to round R, each retrieves its single buffered proposal: [5](#0-4) 

7. **Processing**: Each validator processes its buffered proposal through `process_opt_proposal()`, which converts the `OptBlockData` to a `Block`: [6](#0-5) 

8. **Equivocation Check Bypass**: The `is_valid_proposal()` check in `process_proposal()` validates this is the first proposal from this proposer for this round: [7](#0-6) 

The equivocation detection in `UnequivocalProposerElection` tracks proposals using mutex-protected state: [8](#0-7) 

Since each validator only processes ONE buffered proposal (the others were overwritten), the equivocation check passes - each validator believes it's seeing the proposer's first and only proposal for that round.

9. **Vote Splitting**: Validators create votes containing `VoteData` with different proposed `BlockInfo` values: [9](#0-8) 

Votes for different block IDs cannot aggregate into a single quorum certificate. No block reaches the 2f+1 threshold for QC formation, causing the round to timeout.

**Invariant Violation:**

The `UnequivocalProposerElection` wrapper is explicitly designed to detect and reject proposer equivocation by ensuring a leader proposes only once per round. However, optimistic proposals bypass this protection during the buffering phase. The equivocation check only occurs when processing the proposal from the buffer, by which time different validators have already committed to different proposals due to last-write-wins semantics.

**Key Technical Detail:**

Optimistic proposals are intentionally not signed by the proposer. The `Block::new_from_opt()` method sets signature to `None`: [10](#0-9) 

This makes it trivial for a Byzantine validator to create multiple conflicting proposals without cryptographic traceability.

## Impact Explanation

**Severity: High** - Significant Protocol Violation

This vulnerability enables a single Byzantine validator to cause consensus liveness failures when elected as round leader. The impact includes:

1. **Liveness Degradation**: Each round where the attacker is leader results in a guaranteed timeout, degrading network performance
2. **Vote Splitting**: Honest validators waste voting power on conflicting blocks that cannot form a QC
3. **Equivocation Bypass**: The unequivocal proposer election mechanism is circumvented during the optimistic proposal window
4. **Reduced Throughput**: Network fails to achieve optimistic latency improvements, one of the key performance features

While this doesn't cause safety violations (no conflicting blocks get committed since no QC forms), it violates the protocol's explicit assumption of unequivocal proposer election. The optimistic proposal mechanism, designed to improve latency, becomes an attack vector for degrading network performance.

Per Aptos bug bounty criteria, this qualifies as **High Severity**: It represents a significant protocol violation where validator nodes experience degraded performance during malicious leader rounds, and the unequivocal proposer election guarantee is systematically bypassed.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Feature Enabled by Default**: Both `enable_optimistic_proposal_rx` and `enable_optimistic_proposal_tx` are set to `true` by default: [11](#0-10) 

2. **Low Attack Complexity**: Attacker only needs to broadcast two different `OptProposalMsg` messages with different payloads
3. **No Coordination Required**: Single Byzantine validator can execute the attack alone
4. **Deterministic Success**: Network timing naturally causes different delivery orders across validators, ensuring vote splitting
5. **Recurring Opportunity**: Each time the Byzantine validator is elected leader (probability 1/n per round)
6. **No Detection**: Current implementation provides no warning or logging when duplicate proposals overwrite existing buffered proposals

The attack requires only:
- Being a validator (assumed in BFT model with f < n/3 Byzantine validators)
- Being elected as round leader (happens regularly in round-robin or reputation-based election)
- Basic network broadcast capability (standard validator operation)

## Recommendation

Implement duplicate proposal detection during the buffering phase to prevent the last-write-wins behavior:

```rust
// In process_opt_proposal_msg(), before inserting:
if let Some(existing) = self.pending_opt_proposals.get(&proposal_msg.round()) {
    if existing.parent_id() != proposal_msg.block_data().parent_id() 
        || existing.hash() != proposal_msg.block_data().hash() {
        error!(
            SecurityEvent::InvalidConsensusProposal,
            "Detected conflicting optimistic proposal for round {} from proposer {}. Existing: {}, New: {}",
            proposal_msg.round(),
            proposal_msg.proposer(),
            existing.hash(),
            proposal_msg.block_data().hash()
        );
        bail!("Conflicting optimistic proposal detected");
    }
    // Same proposal, ignore duplicate
    return Ok(());
}
self.pending_opt_proposals
    .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

This ensures that if a validator receives multiple proposals for the same round, it only accepts the first one and rejects subsequent conflicting proposals, maintaining the unequivocal proposer election invariant during buffering.

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a test network with optimistic proposals enabled
2. Creating a Byzantine validator that broadcasts two `OptProposalMsg` with different payloads but the same round number
3. Observing that honest validators buffer different proposals based on network timing
4. Confirming that votes are split across different block IDs and no QC forms
5. Verifying the round times out despite having a valid leader

The attack succeeds because the buffering mechanism uses `BTreeMap::insert()` without checking for existing proposals, allowing last-write-wins behavior to split validator votes.

### Citations

**File:** consensus/src/round_manager.rs (L330-330)
```rust
    pending_opt_proposals: BTreeMap<Round, OptBlockData>,
```

**File:** consensus/src/round_manager.rs (L476-481)
```rust
        if let Some(opt_proposal) = self.pending_opt_proposals.remove(&new_round) {
            self.opt_proposal_loopback_tx
                .send(opt_proposal)
                .await
                .expect("Sending to a self loopback unbounded channel cannot fail");
        }
```

**File:** consensus/src/round_manager.rs (L825-833)
```rust
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
```

**File:** consensus/src/round_manager.rs (L843-874)
```rust
    async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
        ensure!(
            self.block_store
                .get_block_for_round(opt_block_data.round())
                .is_none(),
            "Proposal has already been processed for round: {}",
            opt_block_data.round()
        );
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
        let proposal = Block::new_from_opt(opt_block_data, hqc);
        observe_block(proposal.timestamp_usecs(), BlockStage::PROCESS_OPT_PROPOSAL);
        info!(
            self.new_log(LogEvent::ProcessOptProposal),
            block_author = proposal.author(),
            block_epoch = proposal.epoch(),
            block_round = proposal.round(),
            block_hash = proposal.id(),
            block_parent_hash = proposal.quorum_cert().certified_block().id(),
        );
        self.process_proposal(proposal).await
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L20-20)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher)]
```

**File:** consensus/src/network.rs (L441-445)
```rust
    pub async fn broadcast_opt_proposal(&self, proposal_msg: OptProposalMsg) {
        fail_point!("consensus::send::broadcast_opt_proposal", |_| ());
        let msg = ConsensusMsg::OptProposalMsg(Box::new(proposal_msg));
        self.broadcast(msg).await
    }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L61-86)
```rust
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
```

**File:** consensus/consensus-types/src/vote_data.rs (L11-16)
```rust
pub struct VoteData {
    /// Contains all the block information needed for voting for the proposed round.
    proposed: BlockInfo,
    /// Contains all the block information for the block the proposal is extending.
    parent: BlockInfo,
}
```

**File:** consensus/consensus-types/src/block.rs (L410-416)
```rust
    pub fn new_from_opt(opt_block_data: OptBlockData, quorum_cert: QuorumCert) -> Self {
        let block_data = BlockData::new_from_opt(opt_block_data, quorum_cert);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
```

**File:** config/src/config/consensus_config.rs (L384-385)
```rust
            enable_optimistic_proposal_rx: true,
            enable_optimistic_proposal_tx: true,
```
