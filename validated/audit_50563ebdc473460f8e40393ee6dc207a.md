# Audit Report

## Title
Consensus Split Due to Inconsistent Randomness Metadata Generation Across Config Versions

## Summary
Validators running different `OnChainConsensusConfig` versions generate different block metadata transactions when randomness is globally enabled, causing deterministic execution violations and consensus failure. This occurs because V4 configs always wait for randomness while V5 configs with `rand_check_enabled=true` conditionally skip randomness generation, leading to different `BlockMetadataExt` transactions with incompatible serialization.

## Finding Description
The vulnerability stems from version-dependent behavior in the consensus pipeline's randomness optimization logic. When randomness is enabled network-wide but validators operate with different consensus config versions, they produce non-deterministic block metadata transactions.

The `rand_check_enabled()` accessor returns hardcoded `false` for V1-V4 configs and the field value for V5 configs: [1](#0-0) 

During block execution in the pipeline, the `rand_check` function conditionally skips randomness generation based on this flag: [2](#0-1) 

At the critical branching point, if `rand_check_enabled && !has_randomness` evaluates to true, the function immediately returns `None` instead of awaiting randomness from the channel: [3](#0-2) 

This creates divergent execution paths:
- **V5 validators with `rand_check_enabled=true`**: For blocks without randomness-requiring transactions, return `(Some(None), false)`, leading to `BlockMetadataExt::V1` with `randomness: None`
- **V4 validators or V5 with `rand_check_enabled=false`**: Always await randomness, return `(Some(Some(actual_randomness)), _)`, leading to `BlockMetadataExt::V1` with `randomness: Some(value)`

The execute phase uses this result to create different metadata transactions: [4](#0-3) 

The `BlockMetadataWithRandomness` struct stores randomness as `Option<Randomness>`: [5](#0-4) 

Since `Transaction` enum derives `BCSCryptoHash`: [6](#0-5) 

Different `Option<Randomness>` values serialize to different bytes in BCS (Binary Canonical Serialization): `None` → `0x00`, `Some(value)` → `0x01 + serialized_value`. This produces different transaction hashes and ultimately different state roots, violating the **Deterministic Execution** invariant required for consensus.

The vulnerability becomes active when validators fall back to different config versions. When deserialization fails, validators use the default V4 config: [7](#0-6) 

Multiple consensus components use this fallback pattern: [8](#0-7)  and [9](#0-8) 

## Impact Explanation
**Critical Severity** - This vulnerability breaks consensus safety, the most fundamental blockchain invariant, meeting the "Consensus/Safety Violations" and "Non-recoverable Network Partition" criteria:

1. **Consensus Split**: Validators cannot achieve 2/3+ agreement on block execution results because they compute different state roots from identical input blocks
2. **Network Partition**: The network fragments into incompatible validator subsets based on config versions, each unable to validate the other's blocks
3. **Requires Hardfork**: Recovery requires coordinated intervention - either forced config rollback or mandatory validator upgrades - to restore consensus compatibility

This directly satisfies the Critical severity criteria for "Different validators commit different blocks" and "Network split requiring hardfork to resolve."

## Likelihood Explanation
**High Likelihood** during configuration transitions:

1. **Natural Occurrence During Upgrades**: Every consensus config upgrade to V5 with `rand_check_enabled=true` creates the vulnerable condition if any validator fails to deserialize the new config
2. **Deserialization Fragility**: Validators that fail to parse V5 config (due to BCS version mismatches, corrupted on-chain state, or node software incompatibilities) silently fall back to V4 default
3. **Persistent State**: Once triggered, the split persists across all subsequent blocks until manual intervention synchronizes all validators to compatible configs
4. **No Attack Required**: The vulnerability activates during normal block proposal when randomness is globally enabled but a block contains no `#[randomness]`-annotated transactions

The condition requires only:
- Global randomness enabled (`is_randomness_enabled=true`)
- Validator set with mixed configs (V5 with `rand_check_enabled=true` vs V4 or V5 with `rand_check_enabled=false`)
- A proposed block with no randomness-requiring transactions (common scenario)

## Recommendation
Implement consensus config version validation at epoch boundaries to ensure all validators operate with identical configurations:

1. **Mandatory Config Synchronization**: Before epoch start, validators should verify they can successfully deserialize the on-chain consensus config and abort if deserialization fails, preventing silent fallback to V4
2. **Config Version Consensus**: Include the consensus config version/hash in the epoch state and validate that all validators agree on it before processing blocks
3. **Deterministic Randomness Behavior**: Make randomness generation behavior independent of `rand_check_enabled` when randomness is globally enabled, or ensure the optimization only applies when all validators have matching V5 configs
4. **Remove Silent Fallback**: Replace `unwrap_or_default()` pattern with explicit error handling that prevents validators from participating in consensus with incompatible configs

## Proof of Concept
```rust
// Scenario: Mixed validator configs during block execution
// Validator A: V5 config with rand_check_enabled=true
// Validator B: V4 config (from failed deserialization)

// Given: Block with no randomness-requiring transactions
// Global randomness is enabled (is_randomness_enabled=true)

// Validator A execution path:
// 1. rand_check() at pipeline_builder.rs:775
//    Condition: rand_check_enabled(V5)=true && !has_randomness=true
//    Result: maybe_rand = None
//    Returns: (Some(None), false)
// 2. execute() at pipeline_builder.rs:807
//    Creates: BlockMetadataExt::V1 with randomness=None
//    BCS serialization: ...0x00 (None variant)

// Validator B execution path:
// 1. rand_check() at pipeline_builder.rs:775
//    Condition: rand_check_enabled(V4)=false && !has_randomness=true
//    Result: awaits rand_rx, receives Some(Randomness{...})
//    Returns: (Some(Some(randomness)), false)
// 2. execute() at pipeline_builder.rs:807
//    Creates: BlockMetadataExt::V1 with randomness=Some(...)
//    BCS serialization: ...0x01[randomness_bytes] (Some variant)

// Outcome: 
// - Different transaction hashes
// - Different state roots after execution
// - Validators cannot achieve 2/3+ consensus
// - Network split until manual intervention
```

## Notes
This vulnerability requires validators to have different consensus config versions during normal operation, which can occur through:
1. Deserialization failures during config upgrades
2. Partial rollouts where some validators successfully upgrade to V5 while others remain on V4
3. Network delays causing validators to read on-chain config at different times during epoch transitions

The vulnerability is particularly insidious because it occurs silently - validators continue operating normally but diverge on execution results without explicit error signals. The `unwrap_or_default()` pattern masks deserialization failures, allowing incompatible validators to participate in consensus.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L414-425)
```rust
    pub fn rand_check_enabled(&self) -> bool {
        match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. }
            | OnChainConsensusConfig::V4 { .. } => false,
            OnChainConsensusConfig::V5 {
                rand_check_enabled: rand_check,
                ..
            } => *rand_check,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L685-783)
```rust
    async fn rand_check(
        prepare_fut: TaskFuture<PrepareResult>,
        parent_block_execute_fut: TaskFuture<ExecuteResult>,
        rand_rx: oneshot::Receiver<Option<Randomness>>,
        executor: Arc<dyn BlockExecutorTrait>,
        block: Arc<Block>,
        is_randomness_enabled: bool,
        rand_check_enabled: bool,
        module_cache: Arc<Mutex<Option<CachedModuleView<CachedStateView>>>>,
    ) -> TaskResult<RandResult> {
        let mut tracker = Tracker::start_waiting("rand_check", &block);
        parent_block_execute_fut.await?;
        let (user_txns, _) = prepare_fut.await?;

        tracker.start_working();
        if !is_randomness_enabled {
            return Ok((None, false));
        }
        let grand_parent_id = block.quorum_cert().parent_block().id();
        let parent_state_view = executor
            .state_view(block.parent_id())
            .map_err(anyhow::Error::from)?;

        let mut has_randomness = false;
        // scope to drop the lock, compiler seems not able to figure out manual drop with async point
        {
            let mut cache_guard = module_cache.lock();
            if let Some(cache_mut) = cache_guard.as_mut() {
                // flush the cache if the execution state view is not linear
                // in case of speculative executing a forked block
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
            } else {
                *cache_guard = Some(CachedModuleView::new(parent_state_view));
            }
            let cache_ref = cache_guard.as_mut().expect("just set");

            for txn in user_txns.iter() {
                if let Some(txn) = txn.borrow_into_inner().try_as_signed_user_txn() {
                    if let Ok(TransactionExecutableRef::EntryFunction(entry_fn)) =
                        txn.executable_ref()
                    {
                        // use the deserialized API to avoid cloning the metadata
                        // should migrate once we move metadata into the extension and avoid cloning
                        if let Ok(Some(module)) = cache_ref.unmetered_get_deserialized_module(
                            entry_fn.module().address(),
                            entry_fn.module().name(),
                        ) {
                            if get_randomness_annotation_for_entry_function(
                                entry_fn,
                                &module.metadata,
                            )
                            .is_some()
                            {
                                has_randomness = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        let label = if has_randomness {
            "has_rand"
        } else {
            "no_rand"
        };
        counters::RAND_BLOCK.with_label_values(&[label]).inc();
        if has_randomness {
            info!(
                "[Pipeline] Block {} {} {} has randomness txn",
                block.id(),
                block.epoch(),
                block.round()
            );
        }
        drop(tracker);
        // if rand check is enabled and no txn requires randomness, we skip waiting for randomness
        let mut tracker = Tracker::start_waiting("rand_gen", &block);
        tracker.start_working();
        let maybe_rand = if rand_check_enabled && !has_randomness {
            None
        } else {
            rand_rx
                .await
                .map_err(|_| anyhow!("randomness tx cancelled"))?
        };
        Ok((Some(maybe_rand), has_randomness))
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L803-811)
```rust
        let (rand_result, _has_randomness) = rand_check.await?;

        tracker.start_working();
        // if randomness is disabled, the metadata skips DKG and triggers immediate reconfiguration
        let metadata_txn = if let Some(maybe_rand) = rand_result {
            block.new_metadata_with_randomness(&validator, maybe_rand)
        } else {
            block.new_block_metadata(&validator).into()
        };
```

**File:** types/src/block_metadata_ext.rs (L23-34)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockMetadataWithRandomness {
    pub id: HashValue,
    pub epoch: u64,
    pub round: u64,
    pub proposer: AccountAddress,
    #[serde(with = "serde_bytes")]
    pub previous_block_votes_bitvec: Vec<u8>,
    pub failed_proposer_indices: Vec<u32>,
    pub timestamp_usecs: u64,
    pub randomness: Option<Randomness>,
}
```

**File:** types/src/transaction/mod.rs (L2945-2970)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),

    /// Transaction that applies a WriteSet to the current storage, it's applied manually via aptos-db-bootstrapper.
    GenesisTransaction(WriteSetPayload),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is disabled.
    BlockMetadata(BlockMetadata),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    StateCheckpoint(HashValue),

    /// Transaction that only proposed by a validator mainly to update on-chain configs.
    ValidatorTransaction(ValidatorTransaction),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is enabled.
    BlockMetadataExt(BlockMetadataExt),
```

**File:** consensus/src/epoch_manager.rs (L1195-1201)
```rust
        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L160-166)
```rust
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain consensus config! Error: {:?}",
                error
            ))
        );
    }
    let consensus_config = onchain_consensus_config.unwrap_or_default();
```
