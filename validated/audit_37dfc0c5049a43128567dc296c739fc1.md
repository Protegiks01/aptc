# Audit Report

## Title
Cross-Shard Transaction Abort Causes Panic Due to Unimplemented Error Handler in Sequential Fallback

## Summary
The sharded block executor's `CrossShardCommitSender::on_execution_aborted` handler contains an unimplemented `todo!()` macro. When parallel execution fails and falls back to sequential execution, aborted transactions trigger this handler, causing a panic that prevents proper error propagation and potentially deadlocks dependent shards waiting for cross-shard values.

## Finding Description

The Aptos sharded block executor implements parallel transaction execution across multiple shards with cross-shard dependency coordination. A critical gap exists in the error handling path when transactions abort during sequential fallback execution.

**Technical Analysis:**

The vulnerability manifests through the following execution sequence:

1. **Cross-Shard Dependency Initialization**: When transactions have cross-shard dependencies, the system creates `RemoteStateValue` objects initialized in "Waiting" status for state keys that will be provided by other shards. [1](#0-0) 

2. **Blocking Read Mechanism**: Dependent transactions block when reading these state keys via `RemoteStateValue::get_value()`, which uses a condition variable to wait in a while loop until the value is set. [2](#0-1) 

3. **Parallel Execution with Fallback**: The sharded executor is configured with `allow_fallback: true` by default, enabling automatic fallback to sequential execution when parallel execution encounters errors. [3](#0-2) 

4. **Fallback Execution Path**: When parallel execution fails, the block executor attempts sequential execution as a fallback mechanism. [4](#0-3) 

5. **Sequential Abort Handling**: During sequential execution, when a transaction returns `ExecutionStatus::Abort`, the executor invokes the commit hook's `on_execution_aborted` method. [5](#0-4) 

6. **Unimplemented Handler**: The `CrossShardCommitSender::on_execution_aborted` implementation contains only a `todo!()` macro, which immediately panics when invoked. [6](#0-5) 

7. **Sequential Execution Still Uses Cross-Shard Infrastructure**: Critically, sequential fallback execution still uses the `CrossShardStateView` wrapped in `AggregatorOverriddenStateView`, meaning cross-shard blocking mechanisms remain active. [7](#0-6) 

**Impact Mechanism:**

When the panic occurs:
- The panicking shard cannot send abort notifications to dependent shards
- Dependent shards remain blocked in `RemoteStateValue::get_value()` waiting for values that will never arrive
- The panic prevents proper error propagation through the execution stack
- All validators processing the same block deterministically encounter the same failure

## Impact Explanation

**Severity: HIGH - Deterministic Execution Failure with Service Disruption**

This qualifies as HIGH severity under the Aptos bug bounty program for the following reasons:

1. **Deterministic Failure**: All validators using sharded execution will encounter the same panic when processing blocks containing cross-shard transactions that abort. This causes consensus nodes to fail deterministically rather than producing execution outputs.

2. **Service Impact**: While this may not cause total network halt (validators not using sharded execution can continue), it causes service disruption for any nodes that have enabled sharded execution via the `--num-executor-shards` configuration flag.

3. **Panic Instead of Error Handling**: The panic violates Rust best practices and blockchain reliability requirements. Execution errors should be handled gracefully and propagated as errors, not panics.

4. **Thread/Resource Issues**: The panic occurs in the execution thread pool, potentially leaving worker threads in undefined states and dependent threads blocked indefinitely.

The impact is somewhat mitigated by:
- Sharded execution appears to be an optional/experimental feature
- The `todo!()` message explicitly indicates the feature is incomplete
- Validators likely do not enable sharded execution in production given the incomplete implementation

However, the fact that the code is integrated into the main codebase with command-line configuration available makes this a valid security concern.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability triggers when:
1. Sharded execution is explicitly enabled (`--num-executor-shards > 1`)
2. A block contains transactions with cross-shard dependencies
3. A source transaction encounters any VM error causing abort

**Mitigating Factors:**
- Sharded execution may not be widely used in production
- The `todo!()` message suggests this is known incomplete functionality
- Validators would likely avoid enabling experimental features

**Aggravating Factors:**
- The feature is accessible via standard configuration flags
- No runtime warnings or guards prevent its use
- Cross-shard dependencies and transaction aborts are common in real workloads
- Any user can submit transactions that trigger VM errors

The likelihood is rated MEDIUM rather than HIGH because production validators likely do not enable this incomplete feature. However, if any validators do enable it, the vulnerability is guaranteed to manifest.

## Recommendation

Implement the `on_execution_aborted` handler to properly notify dependent shards when transactions abort:

```rust
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
        for (state_key, dependent_shard_ids) in edges.iter() {
            for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                    state_key.clone(),
                    None,  // Aborted transactions produce no value
                ));
                if *round_id == GLOBAL_ROUND_ID {
                    self.cross_shard_client.send_global_msg(message);
                } else {
                    self.cross_shard_client.send_cross_shard_msg(
                        *dependent_shard_id,
                        *round_id,
                        message,
                    );
                }
            }
        }
    }
}
```

Additionally, consider:
- Adding feature flags or runtime guards to prevent enabling incomplete sharded execution
- Adding documentation warnings about the incomplete status
- Implementing comprehensive error handling for cross-shard abort scenarios

## Proof of Concept

A proof of concept would require:
1. Configuring a test with `num_executor_shards > 1`
2. Creating a block with cross-shard transaction dependencies
3. Ensuring one source transaction triggers a VM abort (e.g., division by zero)
4. Observing the panic when sequential fallback invokes `on_execution_aborted`

The existing test infrastructure in `aptos-move/aptos-vm/tests/sharded_block_executor.rs` could be extended to demonstrate this by adding test cases that trigger transaction aborts with cross-shard dependencies during execution.

## Notes

This vulnerability represents a gap between feature implementation and production-readiness. While the code is integrated into the main codebase and accessible via configuration, the `todo!()` macro with the message "on_transaction_aborted not supported for sharded execution yet" indicates known incomplete functionality. This should either be completed before enabling sharded execution in production or clearly marked as experimental with appropriate guards to prevent accidental use.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L32-34)
```rust
        for key in cross_shard_keys {
            cross_shard_data.insert(key, RemoteStateValue::waiting());
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** types/src/block_executor/config.rs (L71-79)
```rust
    pub fn default_with_concurrency_level(concurrency_level: usize) -> Self {
        Self {
            blockstm_v2: false,
            concurrency_level,
            allow_fallback: true,
            discard_failed_blocks: false,
            module_cache_config: BlockExecutorModuleCacheLocalConfig::default(),
        }
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2248)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    error!(
                        "Sequential execution FatalVMError by transaction {}",
                        idx as TxnIndex
                    );
                    // Record the status indicating the unrecoverable VM failure.
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalVMError(err),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2576-2597)
```rust
            // If parallel gave us result, return it
            if let Ok(output) = parallel_result {
                return Ok(output);
            }

            if !self.config.local.allow_fallback {
                panic!("Parallel execution failed and fallback is not allowed");
            }

            // All logs from the parallel execution should be cleared and not reported.
            // Clear by re-initializing the speculative logs.
            init_speculative_logs(signature_verified_block.num_txns() + 1);

            // Flush all caches to re-run from the "clean" state.
            module_cache_manager_guard
                .environment()
                .runtime_environment()
                .flush_all_caches();
            module_cache_manager_guard.module_cache_mut().flush();

            info!("parallel execution requiring fallback");
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L123-126)
```rust
        let aggr_overridden_state_view = Arc::new(AggregatorOverriddenStateView::new(
            cross_shard_state_view.as_ref(),
            TOTAL_SUPPLY_AGGR_BASE_VAL,
        ));
```
