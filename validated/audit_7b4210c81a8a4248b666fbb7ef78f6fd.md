# Audit Report

## Title
Vote Counting Inconsistency Leading to Consensus Liveness Degradation via Invalid Signature Phantom Votes

## Summary
A validator can send a vote with an invalid signature that passes initial optimistic verification but fails during batch signature aggregation, creating a "phantom vote" that is recorded in the author tracking map but excluded from signature aggregation. This prevents the validator from correcting their vote and can cause rounds to fail to form Quorum Certificates (QCs), leading to consensus liveness degradation.

## Finding Description

The vulnerability exists in the interaction between optimistic signature verification and the vote aggregation logic in `insert_vote()`. When optimistic signature verification is enabled (the default configuration), the system exhibits the following critical flow:

**1. Optimistic Verification Allows Invalid Signatures Through**

By default, `optimistic_sig_verification` is enabled in production. [1](#0-0) 

When a vote is received and verified with optimistic mode enabled, the `optimistic_verify()` function returns `Ok()` without actually verifying the signature if the author is not in the pessimistic verify set. [2](#0-1) 

**2. Vote Added to Author Map Before Signature Verification**

In `insert_vote()`, the vote is immediately added to the `author_to_vote` map after basic duplicate checks. [3](#0-2) 

**3. Optimistic Voting Power Check Counts All Signatures**

The `check_voting_power()` call counts ALL voters in the signature aggregator regardless of whether their signatures are valid. [4](#0-3) 

This check uses `all_voters()` which returns all signatures without validation. [5](#0-4) 

**4. Batch Verification Filters Out Invalid Signatures**

When apparent quorum is reached, `aggregate_and_verify()` is called. [6](#0-5) 

Inside this function, if batch signature verification fails, `filter_invalid_signatures()` removes invalid signatures. [7](#0-6) 

The filtering process verifies each signature individually and removes those that fail. [8](#0-7) 

**5. Insufficient Voting Power After Filtering**

After filtering, `try_aggregate()` is called again, which can now fail with `TooLittleVotingPower` if the remaining valid signatures don't meet quorum. [9](#0-8) 

This error is caught and the reduced voting power is returned. [10](#0-9) 

**6. Phantom Vote: Cannot Resend Valid Signature**

The validator's vote remains in `author_to_vote` map, but their signature was removed from the aggregator. When the validator attempts to resend with a valid signature, duplicate detection only checks the ledger info digest, not the signature itself. [11](#0-10) 

This creates a desynchronization where the vote is "accepted" but doesn't contribute to QC formation, and cannot be corrected.

**Attack Scenario:**

Consider 4 validators with voting power: A(30%), B(30%), C(20%), D(20%), where quorum = 67%:

1. Validators A and B send valid votes (60% total)
2. Validator C sends a vote with an invalid signature (passes optimistic verification)
3. `check_voting_power()` sees 80% (A + B + C) ≥ 67%, proceeds to aggregate
4. Batch signature verification fails due to C's invalid signature
5. After filtering, only A and B remain (60% < 67%)
6. `TooLittleVotingPower` is returned with voting_power = 60
7. C's vote remains in `author_to_vote` but signature is removed from aggregator
8. C attempts to resend with valid signature → rejected as `DuplicateVote`
9. If D is offline or Byzantine, the round cannot form a QC
10. Round times out, forcing slower timeout-based consensus progression

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program, specifically category 8: "Validator Node Slowdowns."

**Concrete Impacts:**
- **Liveness Degradation**: Rounds repeatedly fail to form QCs when validators have invalid signatures, forcing timeout-based round progression which is significantly slower than normal consensus operation
- **Protocol Violation**: Votes are accepted (return `VoteAdded`) but don't contribute to QCs, violating the invariant that accepted votes with sufficient voting power should form QCs
- **Resource Waste**: Validators waste computational resources attempting aggregation that will fail, and the round wastes time waiting for a QC that cannot form

**Why NOT Critical:**
- Consensus safety is maintained (no double-signing or chain splits)
- The system eventually recovers after round timeout
- No funds are lost, stolen, or permanently frozen
- Network availability is degraded but not eliminated
- Requires only temporary manual intervention if persistent

## Likelihood Explanation

**For Honest Validators: Low to Medium**
- Could occur due to software bugs in signature generation libraries
- Key corruption or inconsistent cryptographic state during validator operations
- Implementation errors in BLS signature handling
- Race conditions during concurrent signature creation

**For Byzantine Validators: High**
- Trivially exploitable by any validator in the active set
- Requires no special privileges beyond validator status
- Can be triggered deterministically by sending intentionally invalid signatures
- No cryptographic complexity required
- Byzantine validators (up to f < n/3) can coordinate to amplify the effect

**Overall Likelihood: Medium** - While honest validators generating invalid signatures should be rare, the ease of exploitation by Byzantine actors (who are expected to exist within the < n/3 threshold) and the complete lack of recovery mechanism make this a realistic attack vector that could manifest in production.

## Recommendation

Implement one of the following fixes:

**Option 1: Remove Vote from author_to_vote Map on Signature Filtering**

Track which authors had their signatures filtered out during `aggregate_and_verify()` and remove their entries from `author_to_vote`, allowing them to resend with valid signatures.

**Option 2: Check Signature Validity in Duplicate Detection**

Modify duplicate detection to also verify if the previous vote's signature is still present in the aggregator. If not, allow the resend.

**Option 3: Force Non-Optimistic Verification for Initial Vote Processing**

Always verify signatures immediately when votes are first received, before adding to `author_to_vote`. This prevents phantom votes from being created but may impact performance.

**Recommended Fix: Option 1** - Remove filtered authors from tracking map:

```rust
// In pending_votes.rs, after aggregate_and_verify() fails with TooLittleVotingPower
Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
    // Remove authors whose signatures were filtered out
    let remaining_signers: HashSet<_> = sig_aggregator.all_voters().collect();
    self.author_to_vote.retain(|author, _| remaining_signers.contains(author));
    voting_power
}
```

## Proof of Concept

The existing test `test_qc_aggregation_with_unverified_votes` demonstrates invalid signature filtering but doesn't test the resend scenario. [12](#0-11) 

A complete PoC would extend this test to:
1. Create a validator verifier with optimistic verification enabled
2. Send a vote with an invalid signature that meets apparent quorum
3. Verify the vote is filtered and voting power reduced below quorum
4. Attempt to resend the same vote with a valid signature
5. Assert that the resend is rejected as `DuplicateVote` (demonstrating the vulnerability)
6. Verify the round cannot form a QC despite having sufficient valid voting power available

## Notes

This vulnerability is triggered by the combination of:
1. Optimistic signature verification being enabled by default in production
2. Optimistic voting power checks counting unverified signatures
3. Duplicate detection only checking ledger info digest, not signature validity
4. No cleanup mechanism when signatures are filtered out during aggregation

The vulnerability affects the core consensus path and is exploitable by Byzantine validators within the expected < n/3 threshold, making it a valid security concern per the Aptos bug bounty program guidelines.

### Citations

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pending_votes.rs (L287-296)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
```

**File:** consensus/src/pending_votes.rs (L315-316)
```rust
        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));
```

**File:** consensus/src/pending_votes.rs (L371-371)
```rust
                match sig_aggregator.check_voting_power(validator_verifier, true) {
```

**File:** consensus/src/pending_votes.rs (L383-388)
```rust
                            sig_aggregator.aggregate_and_verify(validator_verifier).map(
                                |(ledger_info, aggregated_sig)| {
                                    LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                                },
                            )
                        };
```

**File:** consensus/src/pending_votes.rs (L396-398)
```rust
                            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => {
                                voting_power
                            },
```

**File:** consensus/src/pending_votes.rs (L660-789)
```rust
    fn test_qc_aggregation_with_unverified_votes() {
        ::aptos_logger::Logger::init_for_testing();

        // set up 4 validators
        let (signers, validator_verifier) = random_validator_verifier(7, Some(3), false);
        let mut pending_votes = PendingVotes::new();

        // create random vote from validator[0]
        let mut li = random_ledger_info();
        let vote_data = random_vote_data();
        li.set_consensus_data_hash(vote_data.hash());
        let li_hash = li.hash();

        let mut partial_sigs = PartialSignatures::empty();

        let vote_0 = Vote::new(
            vote_data.clone(),
            signers[0].author(),
            li.clone(),
            &signers[0],
        )
        .unwrap();

        let vote_1 = Vote::new(
            vote_data.clone(),
            signers[1].author(),
            li.clone(),
            &signers[1],
        )
        .unwrap();

        let vote_2 = Vote::new_with_signature(
            vote_data.clone(),
            signers[2].author(),
            li.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let vote_3 = Vote::new(
            vote_data.clone(),
            signers[3].author(),
            li.clone(),
            &signers[3],
        )
        .unwrap();

        let vote_4 = Vote::new(
            vote_data.clone(),
            signers[4].author(),
            li.clone(),
            &signers[4],
        )
        .unwrap();

        // first time a new vote is added -> VoteAdded
        assert_eq!(
            pending_votes.insert_vote(&vote_0, &validator_verifier),
            VoteReceptionResult::VoteAdded(1)
        );
        partial_sigs.add_signature(signers[0].author(), vote_0.signature().clone());

        // same author voting for the same thing -> DuplicateVote
        assert_eq!(
            pending_votes.insert_vote(&vote_0, &validator_verifier),
            VoteReceptionResult::DuplicateVote
        );

        assert_eq!(
            pending_votes.insert_vote(&vote_1, &validator_verifier),
            VoteReceptionResult::VoteAdded(2)
        );
        partial_sigs.add_signature(signers[1].author(), vote_1.signature().clone());

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 0);

        assert_eq!(
            pending_votes.insert_vote(&vote_2, &validator_verifier),
            VoteReceptionResult::VoteAdded(2)
        );

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);
        let (_, vote_status) = pending_votes.li_digest_to_votes.get(&li_hash).unwrap();
        match vote_status {
            VoteStatus::NotEnoughVotes(sig_aggregator) => {
                assert_eq!(sig_aggregator.verified_voters().count(), 2);
                assert_eq!(sig_aggregator.unverified_voters().count(), 0);
            },
            _ => {
                panic!("QC should not be formed yet.");
            },
        }

        partial_sigs.add_signature(signers[3].author(), vote_3.signature().clone());
        let aggregated_sig = validator_verifier
            .aggregate_signatures(partial_sigs.signatures_iter())
            .unwrap();
        match pending_votes.insert_vote(&vote_3, &validator_verifier) {
            VoteReceptionResult::NewQuorumCertificate(qc) => {
                assert!(qc
                    .ledger_info()
                    .check_voting_power(&validator_verifier)
                    .is_ok());
                assert_eq!(
                    qc.ledger_info().signatures().clone(),
                    aggregated_sig.clone()
                );
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        match pending_votes.insert_vote(&vote_4, &validator_verifier) {
            VoteReceptionResult::NewQuorumCertificate(qc) => {
                assert!(qc
                    .ledger_info()
                    .check_voting_power(&validator_verifier)
                    .is_ok());
                assert_eq!(
                    qc.ledger_info().signatures().clone(),
                    aggregated_sig.clone()
                );
            },
            _ => {
                panic!("No QC formed.");
            },
        };

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);
    }
```

**File:** types/src/ledger_info.rs (L488-495)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }
```

**File:** types/src/ledger_info.rs (L529-534)
```rust
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
```
