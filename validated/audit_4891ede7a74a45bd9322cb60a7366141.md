# Audit Report

## Title
Incomplete Transaction Index Cleanup During Manual Database Truncation Leads to Stale Index Entries and Transaction Mismatches

## Summary
The manual database truncation command has a logic flaw where it only processes up to 2,000,000 transactions when deleting transaction index entries. For large truncations exceeding this limit, stale entries in `OrderedTransactionByAccountSchema` remain, causing subsequent queries by account address and sequence number to return incorrect transactions after the blockchain reaches the same version numbers with different content.

## Finding Description

The vulnerability exists in the transaction index cleanup logic during database truncation. When a node operator performs manual truncation for disaster recovery, the system must delete all transaction index entries for rolled-back transactions to maintain storage consistency. [1](#0-0) 

The `delete_transaction_index_data` function loads transactions using `get_transaction_iter` with a hardcoded limit of `MAX_COMMIT_PROGRESS_DIFFERENCE * 2`, which equals 2,000,000 transactions: [2](#0-1) 

The manual truncate command explicitly bypasses the safety check that would normally limit truncation depth: [3](#0-2) 

When `crash_if_difference_is_too_large=false`, the system skips the assertion: [4](#0-3) 

**Attack Scenario:**

1. **Initial State**: Blockchain at version 5,000,000. Account X has transaction with sequence number 10 at version 3,500,000.
   - Index: `OrderedTransactionByAccountSchema[(X, 10)] = 3,500,000`

2. **Truncation**: Operator truncates to version 100. Only versions [101, 2,000,101) are processed. Version 3,500,000's index entry is NOT deleted.

3. **Blockchain Resumes**: Chain progresses from version 101 and reaches version 3,500,000 with Account Y's transaction.

4. **Transaction Mismatch**: Query for (X, 10) returns version 3,500,000 from stale index. The API retrieves the transaction at that version without validation: [5](#0-4) [6](#0-5) 

The function returns the version from the index and retrieves the transaction at that version without verifying it matches the requested account and sequence number. Account Y's transaction is returned as if it belongs to Account X.

## Impact Explanation

**Severity: MEDIUM**

This vulnerability qualifies as **MEDIUM severity** under the Aptos bug bounty program as it represents "State inconsistencies requiring manual intervention."

The impact includes:

1. **Transaction Mismatch**: APIs return incorrect transactions when queried by account and sequence number, violating data integrity guarantees.

2. **State Inconsistency**: The storage layer provides incorrect data to higher-level components (APIs, wallets, explorers).

3. **Requires Manual Intervention**: Stale index entries persist until manually cleaned or overwritten through index rebuilding.

**Important Clarifications:**
- This does NOT affect consensus - validators execute transactions deterministically and don't rely on this index for consensus operations.
- This does NOT cause fund loss - the actual transaction data remains correct; only the index is corrupted.
- This does NOT cause permanent liveness issues - the blockchain continues operating normally.

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

The vulnerability requires:
1. Operator performing manual truncation (infrequent, disaster recovery only)
2. Truncation depth > 2,000,000 versions (rare but possible for major disasters)
3. Blockchain naturally reaching the same version numbers after recovery

While large-scale truncations are legitimate disaster recovery procedures, they are relatively infrequent. The 2,000,000 version limit becomes problematic only for very deep truncations, which increase in likelihood as the blockchain ages and accumulates more versions.

## Recommendation

Modify `delete_transaction_index_data` to process ALL transactions beyond the truncation point, not just the first 2,000,000:

1. **Option 1**: Process transactions in batches until all are deleted:
   ```rust
   let mut start = start_version;
   loop {
       let transactions = ledger_db
           .transaction_db()
           .get_transaction_iter(start, BATCH_SIZE)?
           .collect::<Result<Vec<_>>>()?;
       if transactions.is_empty() {
           break;
       }
       // Process batch...
       start += transactions.len() as u64;
   }
   ```

2. **Option 2**: Directly iterate and delete index entries without loading full transactions by querying the index schema directly.

3. **Option 3**: Add a verification step to detect and warn about incomplete index cleanup.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a blockchain with > 2,000,000 versions
2. Recording index entries for transactions beyond version 2,000,101
3. Performing truncation to version 100 using `db-tool debug truncate`
4. Verifying stale index entries remain using `OrderedTransactionByAccountSchema` queries
5. Advancing blockchain to same versions and querying by account/sequence
6. Observing incorrect transaction returns

Note: A full PoC would require significant blockchain state setup and is best implemented as an integration test within the Aptos test framework.

## Notes

This is a valid logic vulnerability in the storage layer's disaster recovery tooling. While it requires operator action (legitimate disaster recovery), it represents a bug in the Aptos Core codebase that causes state inconsistency. The vulnerability is triggerable in realistic scenarios and has concrete impact, though limited to API query correctness rather than consensus or fund security.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L363-392)
```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let transactions = ledger_db
        .transaction_db()
        .get_transaction_iter(start_version, MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2)?
        .collect::<Result<Vec<_>>>()?;
    let num_txns = transactions.len();
    if num_txns > 0 {
        info!(
            start_version = start_version,
            latest_version = start_version + num_txns as u64 - 1,
            "Truncate transaction index data."
        );
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;

        let transactions = (start_version..=start_version + transactions.len() as u64 - 1)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&transactions, batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L444-449)
```rust
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L143-161)
```rust
    fn get_account_ordered_transaction(
        &self,
        address: AccountAddress,
        seq_num: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
```
