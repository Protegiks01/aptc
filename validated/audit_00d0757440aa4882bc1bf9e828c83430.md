# Audit Report

## Title
Race Condition in Resource Group Initialization Creates Fake Empty Entries Breaking Consensus Determinism

## Summary
A critical race condition exists in the parallel block executor's resource group initialization logic where concurrent transactions can permanently corrupt base values by setting deletions for resources that actually exist in storage. This leads to non-deterministic execution across validators, breaking consensus safety.

## Finding Description

The vulnerability occurs in the multi-version concurrency control system used by Aptos's parallel block executor. When multiple transactions concurrently access a resource group during initialization, a specific race condition causes resources that exist in storage to be permanently marked as deleted.

**The Race Condition Flow:**

1. Transaction T1 begins initializing a resource group by calling `set_raw_base_values`, which creates an entry in the `group_sizes` DashMap at line 155, immediately marking the group as "initialized" for other threads. [1](#0-0) 

2. Before T1 completes setting base values for all tags in the loop (lines 176-182), Transaction T2 concurrently attempts to read a tag from the same group. [2](#0-1) 

3. T2's read path checks if the group is initialized using `contains_key` which returns TRUE because T1 created the entry. The code explicitly acknowledges this non-atomic access pattern in comments. [3](#0-2) 

4. When T2 fetches the tag data, it returns `Uninitialized` because T1 hasn't set that specific tag yet. The `convert_tagged_data` function interprets this as `TagNotFound` since the group appears initialized. [4](#0-3) 

5. T2's `TagNotFound` error handler assumes the tag legitimately doesn't exist in storage and sets a deletion (empty resource) as the base value. [5](#0-4) 

6. When T1 continues initialization and tries to set the real base value from storage, the `set_base_value` method encounters the already-set `Exchanged` deletion. The code explicitly does nothing in this case. [6](#0-5) 

7. **The deletion persists permanently** as the base value, causing all subsequent reads to see the resource as non-existent despite it existing in storage.

**Consensus Breaking Mechanism:**

The race condition is timing-dependent. Different validators executing the same block will experience different thread scheduling:
- Fast validator: No race occurs, correct base values set, transactions read correct data
- Slow validator: Race occurs, deletion incorrectly set, transactions read missing data

Transactions that read different values will produce different outputs, leading to different state roots. When validators attempt to reach consensus on the block commitment, they will have divergent state and cannot achieve quorum, violating the fundamental safety guarantee of AptosBFT consensus.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability meets the Critical severity criteria from the Aptos bug bounty program for "Consensus/Safety violations" because:

1. **Different validators produce different state roots** for identical blocks due to timing-dependent behavior in the parallel execution engine
2. **Consensus failure** occurs when validators cannot agree on state, potentially halting the chain or requiring manual intervention
3. **Transaction non-determinism** means the same transaction produces different results on different validators based purely on race timing
4. **No Byzantine behavior required** - this occurs during normal honest validator operation

This directly violates the deterministic execution invariant that is fundamental to blockchain consensus: given the same input (block), all validators must produce identical output (state root).

## Likelihood Explanation

**High Likelihood**

This race condition will occur naturally during production operation:

1. **No attacker required** - happens organically during high-throughput parallel execution
2. **Resource groups are widely used** in Aptos for efficiency (coin stores, NFT collections, token metadata)
3. **Large timing window** - initialization must iterate through all tags in a group, providing multiple opportunities for concurrent access
4. **Increased probability under load** - higher transaction throughput increases concurrent execution, making races more likely
5. **Persistent impact** - once the incorrect deletion is set, it affects all subsequent transactions in the block

The vulnerability requires no special permissions, attack setup, or coordination - it's a fundamental race in the parallel execution implementation.

## Recommendation

The initialization logic must be atomic with respect to the "initialized" flag. One approach:

1. Use a separate initialization lock or atomic flag before creating the `group_sizes` entry
2. Only mark the group as initialized (create `group_sizes` entry) AFTER all tag base values are set
3. Add validation to detect and reject attempts to set base values when an `Exchanged` value already exists with different semantics

Example fix approach:
```rust
// In set_raw_base_values, acquire exclusive initialization lock first
let mut initialization_guard = self.initialization_locks.entry(group_key.clone()).or_default();
initialization_guard.lock();

// Then proceed with setting values
// Only create group_sizes entry AFTER all tags are set
```

Additionally, add assertions to detect when `Exchanged` deletions are being set inappropriately during initialization.

## Proof of Concept

The vulnerability can be demonstrated through a Rust test that:
1. Creates a resource group in storage with multiple tags
2. Spawns two threads that concurrently:
   - Thread 1: Initializes the group
   - Thread 2: Reads a tag during initialization
3. Observes that Thread 2's read sees a deletion instead of the actual value
4. Verifies the deletion persists even after Thread 1 completes

The race timing can be controlled using synchronization primitives to reliably reproduce the issue in testing.

---

**Notes:**

This is a genuine critical vulnerability in the Aptos Core parallel execution engine. The code comments in `versioned_group_data.rs` acknowledge the non-atomic access pattern but incorrectly assume the ordering prevents issues. The actual implementation creates the `group_sizes` entry before setting tag values, violating the stated "write size after data" assumption in the comments. [7](#0-6) 

The vulnerability fundamentally breaks the deterministic execution guarantee required for blockchain consensus and qualifies as Critical severity under Aptos bug bounty criteria.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-155)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L176-182)
```rust
            for (tag, value) in base_values.into_iter() {
                superset_tags.insert(tag.clone());
                self.values.set_base_value(
                    (group_key.clone(), tag),
                    ValueWithLayout::RawFromStorage(Arc::new(value)),
                );
            }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L423-432)
```rust
        // We are accessing group_sizes and values non-atomically, hence the order matters.
        // It is important that initialization check happens before fetch data below. O.w.
        // we could incorrectly get a TagNotFound error (do not find data, but then find
        // size initialized in between the calls). In fact, we always write size after data,
        // and sometimes (e.g. during initialization) even hold the sizes lock during writes.
        // It is fine to observe initialized = false, but find data, in convert_tagged_data.
        let initialized = self.group_sizes.contains_key(group_key);

        let data_value = self.values.fetch_data_no_record(&key_ref, txn_idx);
        self.convert_tagged_data(data_value, initialized)
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L683-686)
```rust
            Err(MVDataError::Uninitialized) => Err(if initialized {
                MVGroupError::TagNotFound
            } else {
                MVGroupError::Uninitialized
```

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L586-588)
```rust
                        (Exchanged(_, _), RawFromStorage(_)) => {
                            // Stored value contains more info, nothing to do.
                        },
```
