# Audit Report

## Title
Consensus Split via Hardcoded max_loop_depth Configuration During Validator Version Upgrades

## Summary
The `max_loop_depth` bytecode verification parameter is hardcoded in production VM configuration without feature flag coordination. If this value changes in a future release, validators running different code versions during the upgrade window will produce divergent transaction execution results for module publishing transactions, causing consensus splits requiring hardfork intervention.

## Finding Description

This is a **logic/design vulnerability** in the validator coordination architecture.

**The Design Flaw:**

The `max_loop_depth` parameter is hardcoded to `Some(5)` without any feature flag coordination mechanism: [1](#0-0) 

**Architectural Inconsistency:**

Unlike other verification limits in the same configuration (`max_type_nodes`, `max_function_return_values`, `max_type_depth`) which ARE conditionally set based on feature flags, `max_loop_depth` remains constant: [2](#0-1) 

**Verification During Execution:**

Module verification occurs during transaction execution (after consensus ordering) via `build_locally_verified_module`: [3](#0-2) 

Which calls the verifier with the hardcoded config: [4](#0-3) 

**Loop Depth Check:**

The control flow verifier checks loop depth and returns `LOOP_MAX_DEPTH_REACHED` when exceeded: [5](#0-4) 

**Error Classification:**

`LOOP_MAX_DEPTH_REACHED` (status code 1111) is a Verification error: [6](#0-5) 

Verification errors are classified as `StatusType::Verification`: [7](#0-6) 

**Transaction Kept with Different Outcomes:**

Verification errors are KEPT (not discarded) and converted to `MiscellaneousError`: [8](#0-7) 

This means:
- **Validator with old limit:** Verification fails → transaction KEPT with `MiscellaneousError`, module NOT published
- **Validator with new limit:** Verification succeeds → transaction KEPT with `Success`, module IS published

Different state modifications lead to different state roots, causing consensus failure.

## Impact Explanation

**Critical Severity** - Non-recoverable Network Partition:

1. **Consensus Split:** When validators produce different state roots for the same block (one has module published, one doesn't), consensus cannot proceed. This violates the fundamental BFT consensus invariant that honest validators must agree on committed state.

2. **Hardfork Required:** The divergence is deterministic based on code version, not Byzantine behavior. Reconciliation requires forcing all validators to the same version via hardfork.

3. **Total Liveness Loss:** Block proposals fail to reach consensus. The network becomes unavailable for transaction processing until manual intervention.

This directly maps to Critical severity categories:
- Non-recoverable network partition (requires hardfork)
- Consensus/Safety violation 
- Total loss of liveness/network availability

## Likelihood Explanation

**Current State:** The vulnerability is LATENT - it cannot be triggered in the current codebase because all validators run `max_loop_depth=5`.

**Likelihood if Triggered:** If Aptos releases a future version changing `max_loop_depth`, the likelihood becomes HIGH because:

1. **Configurable Design:** The parameter is `Option<usize>`, indicating intentional configurability
2. **Upgrade Window:** Validators necessarily upgrade at different times (standard practice for safety)
3. **Trivial Trigger:** Any user can submit a module with appropriate loop nesting
4. **No Protection:** Unlike similar parameters, `max_loop_depth` lacks feature flag coordination

**Design Flaw:** This is a **logic vulnerability** - the architectural pattern demonstrates the team uses feature flags for similar parameters (`max_type_nodes`, etc.) but this coordination mechanism is missing for `max_loop_depth`. This oversight creates latent consensus risk.

## Recommendation

Add feature flag coordination for `max_loop_depth` changes:

```rust
max_loop_depth: if some_future_feature_flag_enabled {
    Some(10)
} else {
    Some(5)
},
```

Deploy the new code with the flag disabled, enable via governance at epoch boundary, ensuring all validators switch atomically.

## Proof of Concept

**Note:** This vulnerability cannot be demonstrated on current mainnet (all validators use same value). The PoC shows the architectural flaw:

```rust
// Scenario: Two validators with different max_loop_depth
// Validator A: max_loop_depth = Some(5)
// Validator B: max_loop_depth = Some(10)

// Module with 7 nested loops
module 0xCAFE::NestedLoops {
    fun seven_deep() {
        loop { loop { loop { loop { loop { loop { loop {
            break
        }}}}}}}
    }
}

// Result:
// Validator A: LOOP_MAX_DEPTH_REACHED → MiscellaneousError → module NOT published
// Validator B: Success → module IS published
// → Different state roots → Consensus failure
```

**Notes**

This is a **logic/design vulnerability** that creates latent consensus risk. While not currently exploitable (all validators run identical code), the lack of proper coordination architecture for `max_loop_depth` - in contrast to similar parameters that ARE feature-gated - represents a critical oversight that would cause consensus splits if the parameter is changed in any future release without implementing proper coordination mechanisms first.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L157-157)
```rust
        max_loop_depth: Some(5),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-192)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L252-257)
```rust
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L174-178)
```rust
        if let Some(max_depth) = verifier_config.max_loop_depth {
            if depth as usize > max_depth {
                return err(StatusCode::LOOP_MAX_DEPTH_REACHED, summary.block(head));
            }
        }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L300-301)
```rust
                    // A transaction that publishes code that cannot be verified will be charged.
                    StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L786-786)
```rust
    LOOP_MAX_DEPTH_REACHED = 1111,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L989-993)
```rust
        if major_status_number >= VERIFICATION_STATUS_MIN_CODE
            && major_status_number <= VERIFICATION_STATUS_MAX_CODE
        {
            return StatusType::Verification;
        }
```
