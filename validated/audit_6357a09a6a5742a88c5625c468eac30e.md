# Audit Report

## Title
MultiKey Filter Bypass via Decoy Public Key Inclusion

## Summary
The transaction filter system contains a logic vulnerability where `matches_account_authenticator_address()` checks for ANY public key presence in MultiKey authenticators without verifying that the matching key actually signed the transaction. This allows attackers to bypass FederatedKeyless-based access control filters by including decoy public keys.

## Finding Description

The transaction filter system enforces access control policies across multiple critical components (mempool, API, consensus quorum store). A semantic mismatch exists between filter validation and authentication verification.

**Filter Logic (Checks Presence):**
The `matches_account_authenticator_address()` function for MultiKey authenticators uses `.any()` to check if ANY public key matches the target address, regardless of whether that key signed: [1](#0-0) 

For FederatedKeyless public keys, the filter checks if the `jwk_addr` field matches the target address: [2](#0-1) 

**Authentication Logic (Verifies Only Signing Keys):**
The `MultiKeyAuthenticator.to_single_key_authenticators()` method only creates authenticators for keys indicated by the signatures bitmap (i.e., keys that actually signed): [3](#0-2) 

The verification ensures sufficient signatures met the threshold but does not validate which specific keys were used: [4](#0-3) 

**Attack Scenario:**
An enterprise operator configures a filter to allow only transactions from a trusted identity provider by filtering on `AccountAddress(trusted_jwk_address)`. An attacker can bypass this by:

1. Creating a MultiKey with:
   - A FederatedKeyless key with `jwk_addr = trusted_jwk_address` (decoy, not signing)
   - Their own Ed25519 key (actually signs)
   - `signatures_required = 1`
2. Signing the transaction with only their Ed25519 key
3. The filter's `.any()` check finds the decoy FederatedKeyless key and allows the transaction
4. Authentication succeeds because the Ed25519 signature is valid and threshold is met
5. The transaction bypasses the intended "must be authenticated by trusted provider" policy

**Critical System Usage:**
This filter is enforced at multiple critical layers:

- **Mempool**: [5](#0-4) 

- **API Simulation**: [6](#0-5) 

- **Consensus Quorum Store**: [7](#0-6) 

The same vulnerability affects the `PublicKey` matcher which also uses `.any()` for MultiKey authenticators: [8](#0-7) 

## Impact Explanation

**Medium Severity** - This qualifies as a "Limited Protocol Violation" under Aptos bug bounty criteria.

The vulnerability breaks the access control semantics of the transaction filter system. The filter cannot enforce "must be authenticated by" policies, only "must mention" policies. This affects:

1. **Enterprise/Regulated Environments**: Organizations using FederatedKeyless-based filters for compliance cannot reliably enforce identity provider restrictions
2. **Access Control Bypass**: Unauthorized transactions can enter mempool, execute in simulations, and be accepted in consensus batches
3. **Policy Violation**: Defeats the security purpose of the filter system in FederatedKeyless deployments

While this does not directly cause fund loss or consensus violations, it defeats security controls that may protect critical operations. The impact is limited to non-default configurations where FederatedKeyless-based filtering is explicitly enabled.

## Likelihood Explanation

**Medium Likelihood** in environments using FederatedKeyless-based access control; **Low Likelihood** in default configurations.

**Exploitation Requirements:**
- Node operators must configure filters based on FederatedKeyless JWK addresses (non-default)
- Attacker knowledge of target JWK address (often public for federated identity providers)
- Ability to create MultiKey authenticators (standard Aptos feature)

**Ease of Exploitation:**
- No special privileges required
- Trivial to construct the malicious MultiKey
- Standard transaction signing with attacker's own keys
- No cryptographic bypass needed

The likelihood increases significantly in enterprise deployments using federated identity for transaction authorization but remains low in default mainnet configurations.

## Recommendation

Modify the filter logic to verify that matching keys are actually part of the signature set. The filter should check the intersection of:
1. Keys that match the filter criteria
2. Keys that actually signed (indicated by the bitmap)

For MultiKey authenticators, instead of using `.any()` on all public keys, the filter should:
```rust
// Pseudocode fix
AccountAuthenticator::MultiKey { authenticator } => {
    let signing_indices: HashSet<_> = authenticator.signatures_bitmap.iter_ones().collect();
    authenticator.public_keys()
        .public_keys()
        .iter()
        .enumerate()
        .any(|(idx, any_public_key)| 
            signing_indices.contains(&idx) && 
            matches_any_public_key_address(any_public_key, address)
        )
}
```

This ensures the filter only matches keys that actually participated in authentication.

## Proof of Concept

A complete PoC would require:
1. Creating a MultiKey with a decoy FederatedKeyless key (target JWK address) and an attacker-controlled Ed25519 key
2. Signing a transaction with only the Ed25519 key
3. Submitting to a node with a filter configured to allow only the target JWK address
4. Demonstrating the transaction passes the filter despite not being authenticated by the trusted identity provider

The vulnerability is confirmed by the code analysis showing the semantic mismatch between filter checking (presence-based) and authentication verification (signature-based).

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L271-275)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L303-307)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|key| key == any_public_key),
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L320-322)
```rust
        AnyPublicKey::FederatedKeyless { public_key } => {
            // Check if the public key's JWK address matches the given address
            public_key.jwk_addr == *address
```

**File:** types/src/transaction/authenticator.rs (L1099-1102)
```rust
            self.signatures.len() >= self.public_keys.signatures_required() as usize,
            "Not enough signatures for verification, {} < {}.",
            self.signatures.len(),
            self.public_keys.signatures_required(),
```

**File:** types/src/transaction/authenticator.rs (L1105-1109)
```rust
            std::iter::zip(self.signatures_bitmap.iter_ones(), self.signatures.iter())
                .map(|(idx, sig)| SingleKeyAuthenticator {
                    public_key: self.public_keys.public_keys[idx].clone(),
                    signature: sig.clone(),
                })
```

**File:** mempool/src/shared_mempool/tasks.rs (L435-437)
```rust
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
```

**File:** api/src/transactions.rs (L622-624)
```rust
                && !api_filter
                    .transaction_filter()
                    .allows_transaction(&signed_transaction)
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L195-195)
```rust
                    if !transaction_filter.allows_transaction(
```
