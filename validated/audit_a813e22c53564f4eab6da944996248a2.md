# Audit Report

## Title
Unstable Bytecode Deployment Bypass via Missing Compilation Metadata Validation

## Summary
The `reject_unstable_bytecode` function in AptosVM contains a validation flaw that allows deployment of bytecode compiled with unstable compiler or language versions on mainnet. The function only validates the unstable flag when compilation metadata is present, but returns `Ok()` when metadata is absent, enabling attackers to bypass the stability check by removing compilation metadata from compiled bytecode.

## Finding Description

The Aptos blockchain implements a safety mechanism to prevent deployment of unstable code on production networks through the `reject_unstable_bytecode` function. This mechanism contains a critical design flaw where the validation is bypassed when compilation metadata is absent.

**The Vulnerability:**

The validation function uses an `if let Some(metadata)` pattern that only checks compilation metadata when it exists. [1](#0-0)  When no metadata is found, the inner validation at line 1746 is skipped entirely, and the function returns `Ok()` at line 1756 without any validation.

The `get_compilation_metadata` function returns `None` when the `COMPILATION_METADATA_KEY` is not found in the module's metadata vector. [2](#0-1) 

This validation is called as the first step during module publishing. [3](#0-2) 

**Unstable Versions:**

The codebase explicitly defines unstable versions and documents that they should not run on production networks. The latest stable versions are explicitly defined, with V2_0 for compiler and V2_3 for language. [4](#0-3) 

CompilerVersion::V2_1 is marked as unstable. [5](#0-4) 

LanguageVersion::V2_4 and V2_5 are marked as unstable. [6](#0-5) 

The documentation at multiple locations states: "should not be allowed on production networks" and "Unstable code may have restrictions for deployment on production networks." [7](#0-6) 

**Attack Path:**

1. Compile Move code using unstable compiler version (V2_1) or language version (V2_4, V2_5)
2. Deserialize the compiled bytecode
3. Remove entries with key `COMPILATION_METADATA_KEY` from the metadata vector
4. Re-serialize and submit to mainnet via module publishing transaction
5. The `reject_unstable_bytecode` check finds no metadata and returns `Ok()`
6. Module passes validation and deploys on mainnet

The `CompiledModule` structure's metadata field is a `Vec<Metadata>` that can be directly manipulated, as demonstrated in the codebase's own test infrastructure. [8](#0-7) 

**No Additional Protections:**

The `check_metadata_format` function validates metadata format but does NOT require compilation metadata to be present. [9](#0-8)  It only validates metadata IF present, allowing modules without compilation metadata to pass validation.

The feature flag `_REJECT_UNSTABLE_BYTECODE` is permanently enabled on mainnet and cannot be disabled, indicating the importance of this security control. [10](#0-9) 

## Impact Explanation

This vulnerability represents a **MEDIUM severity protocol violation** per Aptos bug bounty categories under "Limited Protocol Violations."

**Concrete Impact:**
- Circumvents the documented security policy that unstable compiler/language versions must not run on production networks
- Enables deployment of code compiled with experimental features that haven't undergone complete security review
- Violates the explicit principle documented throughout the codebase that unstable versions are restricted from production

**Risk Context:**
Unstable versions are explicitly marked as such because they may contain incomplete features or bugs. The validation flaw is systematic—any module without compilation metadata bypasses the unstable check, regardless of how it was compiled. While no specific exploitable vulnerability in current unstable versions (V2_1, V2_4, V2_5) is demonstrated, the policy bypass itself constitutes a security violation of the documented threat model.

## Likelihood Explanation

**Likelihood: High**

The attack has minimal barriers:
- **Low technical complexity**: Bytecode metadata manipulation requires only deserializing the module (using `CompiledModule::deserialize`), modifying the metadata vector, and re-serializing—operations already demonstrated in the codebase's test suite
- **No special privileges**: Any user can submit module deployment transactions to mainnet
- **Easily automated**: The attack can be fully scripted using existing Move/Rust APIs
- **No coordination needed**: Entirely client-side manipulation before transaction submission
- **Works on mainnet**: The chain ID check passes normally, but metadata absence bypasses validation
- **Low cost**: Only requires standard transaction gas fees

## Recommendation

Modify the `reject_unstable_bytecode` function to require compilation metadata on mainnet and reject modules that lack it:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "compilation metadata required for mainnet deployment".to_string(),
                    )
                    .finish(Location::Undefined)
            })?;
            
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script`.

## Proof of Concept

```rust
#[test]
fn test_unstable_bytecode_bypass_via_missing_metadata() {
    use move_binary_format::CompiledModule;
    use aptos_framework::BuildOptions;
    use move_model::metadata::CompilerVersion;
    
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());
    
    // Build package with unstable compiler
    let mut builder = PackageBuilder::new("Package");
    builder.add_source("m.move", r#"
        module 0xf00d::M {
            public fun foo(): u64 { 42 }
        }
    "#);
    let path = builder.write_to_temp().unwrap();
    
    let package = BuiltPackage::build(
        path.path().to_path_buf(),
        BuildOptions {
            compiler_version: Some(CompilerVersion::V2_1), // Unstable version
            ..BuildOptions::default()
        }
    ).expect("building package must succeed");
    
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    
    // Remove compilation metadata to bypass the check
    compiled_module.metadata.retain(|m| m.key != *COMPILATION_METADATA_KEY);
    
    let mut modified_code = vec![];
    compiled_module.serialize(&mut modified_code).unwrap();
    
    // Set to mainnet
    h.set_resource(
        CORE_CODE_ADDRESS,
        ChainId::struct_tag(),
        &ChainId::mainnet().id(),
    );
    
    // Attempt to publish on mainnet with metadata removed
    let result = h.run_transaction_payload_mainnet(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package.extract_metadata().unwrap()).unwrap(),
            vec![modified_code],
        ),
    );
    
    // This SHOULD fail but will succeed due to the bypass
    assert_success!(result); // Vulnerability: unstable bytecode accepted on mainnet
}
```

This PoC demonstrates that bytecode compiled with unstable CompilerVersion::V2_1 can be deployed to mainnet by simply removing the compilation metadata, bypassing the security check that should prevent it.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1700)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L310-317)
```rust
/// Extract compilation metadata from a compiled module or script.
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L17-24)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();

pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** third_party/move/move-model/src/metadata.rs (L148-157)
```rust
impl CompilerVersion {
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L285-294)
```rust
impl LanguageVersion {
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/metadata.rs (L104-139)
```rust
fn test_metadata_with_changes(f: impl Fn() -> Vec<Metadata>) -> TransactionStatus {
    let mut h = MoveHarness::new();
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xf00d").unwrap());

    let mut builder = PackageBuilder::new("Package");
    builder.add_source(
        "m.move",
        r#"
        module 0xf00d::M {
            #[view]
            fun foo(value: u64): u64 { value }
        }
        "#,
    );
    let path = builder.write_to_temp().unwrap();

    let package = BuiltPackage::build(path.path().to_path_buf(), BuildOptions::default())
        .expect("building package must succeed");
    let origin_code = package.extract_code();
    let mut compiled_module = CompiledModule::deserialize(&origin_code[0]).unwrap();
    let metadata = f();
    let mut invalid_code = vec![];
    compiled_module.metadata = metadata;
    compiled_module.serialize(&mut invalid_code).unwrap();

    let package_metadata = package
        .extract_metadata()
        .expect("extracting package metadata must succeed");
    h.run_transaction_payload(
        &account,
        aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&package_metadata).expect("PackageMetadata has BCS"),
            vec![invalid_code],
        ),
    )
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L79-80)
```rust
    /// Enabled on mainnet, can never be disabled.
    _REJECT_UNSTABLE_BYTECODE = 58,
```
