# Audit Report

## Title
Mempool State Inconsistency: Transactions Can Exist in Both Priority Index and Parking Lot Simultaneously

## Summary
A state inconsistency vulnerability exists in the mempool's `process_ready_seq_num_based_transactions()` function where transactions with `timeline_state = NonQualified` can be present in both `priority_index` and `parking_lot_index` simultaneously, violating mempool invariants.

## Finding Description

The vulnerability occurs when transactions with `timeline_state = NonQualified` are processed in `process_ready_seq_num_based_transactions()`. These transactions are created when validators receive transactions from peer validators with broadcasting disabled within the validator network. [1](#0-0) 

When such transactions are processed through `process_ready_transaction()`, they are always added to `priority_index` [2](#0-1)  but are NOT added to `timeline_index` because the condition specifically checks for `TimelineState::NotReady`, which is false for `NonQualified` transactions. [3](#0-2) 

Critically, since these transactions are never inserted into `timeline_index`, their `timeline_state` never changes to `Ready`. The state only changes to `Ready` when a transaction is inserted into the timeline index. [4](#0-3) 

**The Bug**: When sequence number gaps occur and `process_ready_seq_num_based_transactions()` is called again, the for loop checks if transactions have `timeline_state` that is NOT `Ready`, and adds them to `parking_lot_index` - but crucially does NOT remove them from `priority_index`. [5](#0-4) 

This is inconsistent with the correct pattern used in the GC function, which explicitly removes transactions from `priority_index` before parking them. [6](#0-5) 

**Attack Scenario**:
1. Transactions 5, 6, 7 exist with `timeline_state = NonQualified` (from peer validators)
2. First call processes all three, adding them to `priority_index` (timeline_state stays `NonQualified`)
3. Transaction 6 is removed (gas upgrade or rejection)
4. Second call processes txn 5, hits gap at 6, stops with `min_seq = 6`
5. For loop processes txn 7 (seq_num > 6), finds `timeline_state = NonQualified` (!= Ready)
6. **BUG**: Txn 7 is inserted into `parking_lot_index` WITHOUT removal from `priority_index`

The transaction now violates the mempool invariant of being in one index OR the other, never both.

## Impact Explanation

**Severity: Medium**

This violates mempool invariants and causes state inconsistency. Per Aptos bug bounty categories, this qualifies as **Medium Severity** - a "Limited Protocol Violation" with "State inconsistencies requiring manual intervention."

The impacts include:

1. **Incorrect Eviction**: When mempool is full, the eviction process removes transactions from parking lot [7](#0-6)  and calls `index_remove()` which removes the transaction from ALL indices including `priority_index`. [8](#0-7)  This means a transaction that was semantically "ready" for consensus gets evicted.

2. **State Inconsistency**: The transaction exists in two mutually exclusive states - both "ready" (in priority_index) and "not ready" (in parking_lot_index).

3. **Index Integrity Violation**: Breaks the fundamental assumption that ready and parked transactions are disjoint sets.

This does NOT qualify as High Severity because it does not cause validator node slowdowns, API crashes, consensus safety violations, or fund loss.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered through normal validator operations:

1. **NonQualified Transactions Exist**: Created when validators receive transactions from peer validators with broadcasting disabled. [9](#0-8) 

2. **Sequence Gaps Occur**: Through normal operations like gas upgrades or transaction rejections.

3. **Function Called Multiple Times**: `process_ready_seq_num_based_transactions()` is called on every transaction insertion and commit. [10](#0-9) [11](#0-10) 

These conditions occur naturally in production, making this a realistic scenario.

## Recommendation

Fix the bug by explicitly removing transactions from `priority_index` before adding them to `parking_lot_index`, following the same pattern used in the GC function:

```rust
for (_, txn) in txns.seq_num_range_mut((Bound::Excluded(min_seq), Bound::Unbounded)) {
    match txn.timeline_state {
        TimelineState::Ready(_) => {},
        _ => {
            self.parking_lot_index.insert(txn);
            self.priority_index.remove(txn); // ADD THIS LINE
            parking_lot_txns += 1;
        },
    }
}
```

## Proof of Concept

A full Rust test demonstrating this vulnerability would require setting up a mempool with NonQualified transactions and simulating sequence gaps. The key steps would be:

1. Create transactions with `TimelineState::NonQualified`
2. Insert them with consecutive sequence numbers (5, 6, 7)
3. Verify they are in `priority_index` but not `timeline_index`
4. Remove transaction 6 (simulating gas upgrade)
5. Call `process_ready_seq_num_based_transactions()` again
6. Assert that transaction 7 is now in BOTH `priority_index` and `parking_lot_index`

## Notes

This vulnerability specifically affects sequence number based transactions with `NonQualified` timeline state, which are created when validators receive transactions from peer validators in networks where broadcasting within the validator network is disabled. The bug exists because the parking logic at lines 615-622 does not follow the same pattern as the GC function at lines 958-960, which correctly removes from priority_index before parking.

### Citations

**File:** mempool/src/shared_mempool/coordinator.rs (L312-319)
```rust
    let ineligible_for_broadcast = (smp.network_interface.is_validator()
        && !smp.broadcast_within_validator_network())
        || smp.network_interface.is_upstream_peer(&peer, None);
    let timeline_state = if ineligible_for_broadcast {
        TimelineState::NonQualified
    } else {
        TimelineState::NotReady
    };
```

**File:** mempool/src/core_mempool/transaction_store.rs (L361-361)
```rust
                self.process_ready_seq_num_based_transactions(&address, account_sequence_number.expect("Account sequence number is always provided for transactions with sequence number"));
```

**File:** mempool/src/core_mempool/transaction_store.rs (L425-446)
```rust
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L557-557)
```rust
                self.priority_index.insert(txn);
```

**File:** mempool/src/core_mempool/transaction_store.rs (L559-567)
```rust
                // If timeline_state is `NonQualified`, then the transaction is never added to the timeline_index,
                // and never broadcasted to the shared mempool.
                let ready_for_mempool_broadcast = txn.timeline_state == TimelineState::NotReady;
                if ready_for_mempool_broadcast {
                    self.timeline_index
                        .get_mut(&sender_bucket)
                        .unwrap()
                        .insert(txn);
                }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L615-622)
```rust
            for (_, txn) in txns.seq_num_range_mut((Bound::Excluded(min_seq), Bound::Unbounded)) {
                match txn.timeline_state {
                    TimelineState::Ready(_) => {},
                    _ => {
                        self.parking_lot_index.insert(txn);
                        parking_lot_txns += 1;
                    },
                }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L688-688)
```rust
                self.process_ready_seq_num_based_transactions(account, new_account_seq_number);
```

**File:** mempool/src/core_mempool/transaction_store.rs (L739-743)
```rust
    fn index_remove(&mut self, txn: &MempoolTransaction) {
        counters::CORE_MEMPOOL_REMOVED_TXNS.inc();
        self.system_ttl_index.remove(txn);
        self.expiration_time_index.remove(txn);
        self.priority_index.remove(txn);
```

**File:** mempool/src/core_mempool/transaction_store.rs (L958-960)
```rust
                    for (_, t) in txns.seq_num_range_mut((park_range_start, park_range_end)) {
                        self.parking_lot_index.insert(t);
                        self.priority_index.remove(t);
```

**File:** mempool/src/core_mempool/index.rs (L371-378)
```rust
    pub(crate) fn insert(&mut self, txn: &mut MempoolTransaction) {
        self.timeline.insert(
            self.next_timeline_id,
            (txn.get_sender(), txn.get_replay_protector(), Instant::now()),
        );
        txn.timeline_state = TimelineState::Ready(self.next_timeline_id);
        self.next_timeline_id += 1;
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L140-146)
```rust
    let ineligible_for_broadcast =
        smp.network_interface.is_validator() && !smp.broadcast_within_validator_network();
    let timeline_state = if ineligible_for_broadcast {
        TimelineState::NonQualified
    } else {
        TimelineState::NotReady
    };
```
