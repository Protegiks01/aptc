# Audit Report

## Title
Gas Undercharging Vulnerability in BLS12-381 Public Key Subgroup Check Operation

## Summary
The `bls12381_pk_subgroub_check` function incorrectly charges `BLS12381_PER_PUBKEY_DESERIALIZE` (400,684 gas) instead of `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` (1,360,120 gas), resulting in a 959,436 gas undercharge (~70.5% discount) per operation. This allows attackers to consume significantly more computational resources than they pay for, enabling validator node resource exhaustion attacks.

## Finding Description

The BLS12-381 gas metering implementation contains a critical bug where the wrong gas parameter constant is used for the public key subgroup check operation. This bug breaks the gas metering security guarantee that ensures users pay proportionally for computational resources consumed.

**Root Cause:** The `bls12381_pk_subgroub_check` function charges the wrong gas constant at line 158. [1](#0-0) 

**Expected Behavior:** The function should charge `BLS12381_PER_PUBKEY_SUBGROUP_CHECK` as defined in the GasParameters struct. [2](#0-1) 

The correct gas value is defined as 1,360,120 gas units. [3](#0-2) 

**Actual Behavior:** It incorrectly charges `BLS12381_PER_PUBKEY_DESERIALIZE` (400,684 gas). [4](#0-3) 

**Attack Paths:**

1. **Direct validation path:** Attacker calls the public Move function `bls12381::public_key_from_bytes()`. [5](#0-4) 

2. This invokes the native function `validate_pubkey_internal`. [6](#0-5) 

3. Which calls the Rust implementation `native_bls12381_validate_pubkey` that executes the buggy subgroup check at line 409. [7](#0-6) 

4. **Signature verification path:** Attacker calls `verify_normal_signature()`. [8](#0-7) 

5. This calls `native_bls12381_verify_normal_signature` which sets `check_pk_subgroup = true`. [9](#0-8) 

6. The helper function calls the buggy subgroup check at line 225. [10](#0-9) 

7. The buggy function performs the expensive `pk.subgroup_check()` operation documented to take ~39 microseconds. [11](#0-10) 

**Developer Intent Confirmed:** Function documentation explicitly states that `per_pubkey_subgroup_check_cost` should be charged. [12](#0-11) [13](#0-12) 

**Comparison with Correct Implementation:** The signature subgroup check correctly uses `BLS12381_PER_SIG_SUBGROUP_CHECK`. [14](#0-13) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty: "Validator node slowdowns" - up to $50,000)

This vulnerability enables resource exhaustion attacks against validator nodes through a computational asymmetry:

- **Gas Undercharge:** 959,436 gas per operation (70.5% of correct cost)
- **Computational Asymmetry:** Attacker pays ~400K gas but consumes ~1.36M gas worth of CPU
- **Attack Multiplier:** 3.4x - attacker can perform 3.4 times more operations than they pay for

**Attack Scenario:**
An attacker crafts transactions repeatedly calling these public Move functions with valid BLS12-381 public key bytes. Each call triggers the undercharged subgroup check, allowing the attacker to:
1. Slow down validator block processing by consuming excessive CPU cycles
2. Reduce network transaction throughput
3. Increase block processing time, affecting liveness
4. Cause sustained validator performance degradation with economically viable attacks

This directly matches the Aptos Bug Bounty HIGH severity category for "Validator node slowdowns" as it enables DoS through protocol-level resource exhaustion (distinct from network DoS which is out of scope).

## Likelihood Explanation

**Likelihood: High**

- **No Privileges Required:** Any user can submit transactions calling these public Move functions
- **Easy to Exploit:** Simply call `bls12381::public_key_from_bytes()` or `verify_normal_signature()` repeatedly with valid BLS12-381 public key bytes
- **Low Detection:** Appears as legitimate cryptographic operations in transaction logs
- **Repeatable:** Can execute across multiple transactions or within large transaction batches
- **Economic Incentive:** Attack is ~70% cheaper than intended, making sustained attacks economically viable where they otherwise wouldn't be

The vulnerability has been present since BLS12-381 native functions were implemented and affects all nodes processing transactions containing these calls.

## Recommendation

Fix the gas charging in `bls12381_pk_subgroub_check` function by replacing line 158 with:
```rust
context.charge(BLS12381_PER_PUBKEY_SUBGROUP_CHECK * NumArgs::one())?;
```

This ensures the function charges the correct 1,360,120 gas for the computationally expensive subgroup membership check operation.

## Proof of Concept

```move
#[test_only]
module test_addr::gas_undercharge_poc {
    use aptos_std::bls12381;
    use std::vector;
    
    #[test]
    fun test_repeated_subgroup_checks() {
        // Valid BLS12-381 public key bytes
        let pk_bytes = x"94209a296b739577cb076d3bfb1ca8ee936f29b69b7dae436118c4dd1cc26fd43dcd16249476a006b8b949bf022a7858";
        
        // Call public_key_from_bytes repeatedly
        // Each call triggers the undercharged subgroup check
        let i = 0;
        while (i < 100) {
            let _pk = bls12381::public_key_from_bytes(pk_bytes);
            i = i + 1;
        };
        
        // With the bug: pays ~40M gas (100 * 400K)
        // Should pay: ~136M gas (100 * 1.36M)
        // Attacker saves: ~96M gas (~70% discount)
    }
}
```

This PoC demonstrates how an attacker can repeatedly call the public Move function to exploit the gas undercharging, consuming validator CPU resources at a 70% discount.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L49-68)
```rust
#[derive(Debug, Clone)]
pub struct GasParameters {
    pub base: InternalGas,

    pub per_pubkey_deserialize: InternalGasPerArg,
    pub per_pubkey_aggregate: InternalGasPerArg,
    pub per_pubkey_subgroup_check: InternalGasPerArg,

    pub per_sig_deserialize: InternalGasPerArg,
    pub per_sig_aggregate: InternalGasPerArg,
    pub per_sig_subgroup_check: InternalGasPerArg,

    pub per_sig_verify: InternalGasPerArg,
    pub per_pop_verify: InternalGasPerArg,

    pub per_pairing: InternalGasPerArg, // a size-n BLS aggregate signature requires n+1 pairings

    pub per_msg_hashing: InternalGasPerArg,
    pub per_byte_hashing: InternalGasPerByte, // signature verification involves signing |msg| bytes
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L153-161)
```rust
fn bls12381_pk_subgroub_check(
    pk: &bls12381::PublicKey,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    // NOTE(Gas): constant-time; around 39 microseconds on Apple M1
    context.charge(BLS12381_PER_PUBKEY_DESERIALIZE * NumArgs::one())?;

    Ok(pk.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L163-171)
```rust
/// Checks prime-order subgroup membership on a bls12381::Signature struct.
fn bls12381_sig_subgroub_check(
    sig: &bls12381::Signature,
    context: &mut SafeNativeContext,
) -> SafeNativeResult<bool> {
    context.charge(BLS12381_PER_SIG_SUBGROUP_CHECK * NumArgs::one())?;

    Ok(sig.subgroup_check().is_ok())
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L195-202)
```rust
/// Gas cost: base_cost + per_pubkey_deserialize_cost
///                     +? ( per_pubkey_subgroup_check_cost * check_pk_subgroup
///                          +? ( per_sig_deserialize_cost
///                              +? ( per_sig_verify_cost + per_msg_hashing_cost
///                                   + per_byte_hashing_cost * |msg| ) ) )
///
/// where +? indicates that the expression stops evaluating there if the previous gas-charging step
/// failed.
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L203-239)
```rust
pub fn bls12381_verify_signature_helper(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
    check_pk_subgroup: bool,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 3);

    context.charge(BLS12381_BASE)?;

    let msg_bytes = safely_pop_arg!(arguments, Vec<u8>);
    let aggpk_bytes = safely_pop_arg!(arguments, Vec<u8>);
    let multisig_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(aggpk_bytes, context)? {
        Some(pk) => pk,
        None => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    if check_pk_subgroup && !bls12381_pk_subgroub_check(&pk, context)? {
        return Ok(smallvec![Value::bool(false)]);
    }

    let sig = match bls12381_deserialize_sig(multisig_bytes, context)? {
        Some(sig) => sig,
        None => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    let verify_result = signature_verify(&sig, &pk, msg_bytes, context)?;

    Ok(smallvec![Value::bool(verify_result)])
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L384-391)
```rust
/***************************************************************************************************
 * native fun bls12381_validate_pubkey
 *
 *   gas cost: base_cost + per_pubkey_deserialize_cost +? per_pubkey_subgroup_check_cost
 *
 * where +? indicates that the expression stops evaluating there if the previous gas-charging step
 * failed
 **************************************************************************************************/
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L392-412)
```rust
fn native_bls12381_validate_pubkey(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.is_empty());
    debug_assert!(arguments.len() == 1);

    context.charge(BLS12381_BASE)?;

    let pk_bytes = safely_pop_arg!(arguments, Vec<u8>);

    let pk = match bls12381_deserialize_pk(pk_bytes, context)? {
        Some(key) => key,
        None => return Ok(smallvec![Value::bool(false)]),
    };

    let valid = bls12381_pk_subgroub_check(&pk, context)?;

    Ok(smallvec![Value::bool(valid)])
}
```

**File:** aptos-move/framework/src/natives/cryptography/bls12381.rs (L536-546)
```rust
pub fn native_bls12381_verify_normal_signature(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // For normal (non-aggregated) signatures, PK's typically don't come with PoPs and the caller
    // might forget to check prime-order subgroup membership of the PK. Therefore, we always enforce
    // it here.
    let check_pk_subgroup = true;
    bls12381_verify_signature_helper(context, ty_args, arguments, check_pk_subgroup)
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L174-174)
```rust
        [bls12381_per_pubkey_deserialize: InternalGasPerArg, "bls12381.per_pubkey_deserialize", 400684],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L176-176)
```rust
        [bls12381_per_pubkey_subgroup_check: InternalGasPerArg, "bls12381.per_pubkey_subgroup_check", 1360120],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L87-95)
```text
    public fun public_key_from_bytes(bytes: vector<u8>): Option<PublicKey> {
        if (validate_pubkey_internal(bytes)) {
            option::some(PublicKey {
                bytes
            })
        } else {
            option::none<PublicKey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L229-235)
```text
    public fun verify_normal_signature(
        signature: &Signature,
        public_key: &PublicKey,
        message: vector<u8>
    ): bool {
        verify_normal_signature_internal(signature.bytes, public_key.bytes, message)
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L390-390)
```text
    native fun validate_pubkey_internal(public_key: vector<u8>): bool;
```
