# Audit Report

## Title
CommitVote Signature Aggregation DoS via LedgerInfo Mismatch

## Summary

A malicious validator can trigger expensive O(N) BLS signature verifications by sending CommitVotes with matching `commit_info` but different `consensus_data_hash` values. The vulnerability exists because `add_signature_if_matched()` only validates the `commit_info` portion of the LedgerInfo structure, not the complete LedgerInfo, creating an inconsistency that allows mismatched signatures to enter the SignatureAggregator.

## Finding Description

The vulnerability occurs in the consensus pipeline's CommitVote processing where signatures are aggregated for commit decisions. The `LedgerInfo` structure contains two fields: `commit_info` (BlockInfo) and `consensus_data_hash` (HashValue). [1](#0-0) 

The critical flaw lies in the inconsistent validation between signature aggregator initialization and subsequent signature additions. When creating a signature aggregator, the full LedgerInfo is validated: [2](#0-1) 

However, `add_signature_if_matched()` only checks the `commit_info` portion for Executed and Signed states: [3](#0-2) 

**Attack Execution Path:**

1. A malicious validator constructs a CommitVote signed over a LedgerInfo with correct `commit_info` but altered `consensus_data_hash`
2. The vote is verified via `optimistic_verify()` which, when optimistic verification is enabled and the validator is not in the pessimistic set, skips cryptographic validation: [4](#0-3) 
3. The vote passes the partial check in `add_signature_if_matched()` because only `commit_info` is compared
4. When `try_advance_to_aggregated()` is called, it invokes `aggregate_and_verify()` on the aggregator: [5](#0-4) 
5. The aggregated signature verification fails because signatures were computed over different LedgerInfo values (different `consensus_data_hash`)
6. This triggers `filter_invalid_signatures()` which performs parallel individual BLS verification for ALL signatures in the aggregator: [6](#0-5) 
7. The malicious validator is added to `pessimistic_verify_set`, but the expensive O(N) computation has already occurred

Each malicious vote triggers individual BLS signature verification for every signature in the aggregator (up to N validators), where each BLS pairing operation is cryptographically expensive.

## Impact Explanation

This vulnerability enables **Validator Node Slowdowns** through CPU exhaustion, qualifying as **HIGH Severity** per the Aptos bug bounty framework. [7](#0-6) 

The attack causes:
- **Resource Exhaustion**: O(N) expensive BLS pairing operations per malicious vote
- **Performance Degradation**: Validator nodes experience CPU saturation during signature filtering
- **Consensus Impact**: Slowdowns can delay block processing and consensus progress

While built-in mitigation exists (pessimistic_verify_set prevents repeated attacks from the same validator), the initial attack succeeds unconditionally. The framework explicitly classifies "Validator Node Slowdowns" as HIGH severity, as significant performance degradation affects consensus participation and network health.

## Likelihood Explanation

**Likelihood: Medium**

The attack is moderately likely because:

1. **Attacker Requirements**: Requires active validator status, limiting the attack surface to validators (untrusted actors in the threat model)
2. **Technical Simplicity**: Attack only requires constructing a CommitVote with one modified field
3. **Guaranteed Initial Success**: The attack succeeds at least once before pessimistic verification activates
4. **Detection**: After first occurrence, the malicious validator is added to pessimistic_verify_set, preventing subsequent attacks from that validator
5. **Network Constraints**: Message rate limits and consensus protocols reduce attack frequency

## Recommendation

Fix the validation inconsistency by making `add_signature_if_matched()` validate the full LedgerInfo structure, not just `commit_info`:

For Executed state (line 394):
```rust
if executed.partial_commit_proof.data() == &LedgerInfo::new(*target_commit_info.clone(), vote.ledger_info().consensus_data_hash())
```

For Signed state (line 402):
```rust
if signed.partial_commit_proof.data() == vote.ledger_info()
```

Alternatively, verify signatures immediately during `add_signature_if_matched()` by calling `optimistic_verify()` with the aggregator's LedgerInfo rather than relying solely on structural checks.

## Proof of Concept

```rust
#[test]
fn test_commit_info_mismatch_dos() {
    let (validator_signers, validator_verifier) = create_validators();
    let pipelined_block = create_pipelined_block();
    let block_info = pipelined_block.block_info();
    let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
    let ordered_proof = LedgerInfoWithSignatures::new(ledger_info.clone(), AggregateSignature::empty());
    
    // Create valid votes for validators 0-3
    let mut commit_votes = create_valid_commit_votes(validator_signers[0..4].to_vec(), ledger_info.clone());
    
    // Create malicious vote: same commit_info but different consensus_data_hash
    let malicious_ledger_info = LedgerInfo::new(block_info.clone(), HashValue::random());
    let malicious_vote = CommitVote::new(
        validator_signers[4].author(),
        malicious_ledger_info.clone(),
        &validator_signers[4]
    ).unwrap();
    
    let mut cached_votes = HashMap::new();
    cached_votes.insert(commit_votes[0].author(), commit_votes[0].clone());
    
    let mut ordered_item = BufferItem::new_ordered(
        vec![pipelined_block.clone()],
        ordered_proof.clone(),
        cached_votes,
    );
    
    // Add valid votes
    for vote in &commit_votes[1..4] {
        ordered_item.add_signature_if_matched(vote.clone()).unwrap();
    }
    
    // Add malicious vote - this succeeds because only commit_info is checked
    assert!(ordered_item.add_signature_if_matched(malicious_vote).is_ok());
    
    let mut executed_item = ordered_item.advance_to_executed_or_aggregated(
        vec![pipelined_block.clone()],
        &validator_verifier,
        None,
        true,
    );
    
    // Try to aggregate - this triggers expensive filter_invalid_signatures
    let result = executed_item.try_advance_to_aggregated(&validator_verifier);
    
    // Verify the malicious validator was added to pessimistic_verify_set
    assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);
    
    // The attack succeeded in triggering O(N) individual BLS verifications
}
```

This test demonstrates that a CommitVote with matching `commit_info` but different `consensus_data_hash` can be added to the aggregator, triggering expensive signature filtering operations when aggregation is attempted.

### Citations

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L294-348)
```rust
    pub fn try_advance_to_aggregated(self, validator: &ValidatorVerifier) -> Self {
        match self {
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
            },
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
            },
            _ => self,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L374-416)
```rust
    pub fn add_signature_if_matched(&mut self, vote: CommitVote) -> anyhow::Result<()> {
        let target_commit_info = vote.commit_info();
        let author = vote.author();
        let signature = vote.signature_with_status();
        match self {
            Self::Ordered(ordered) => {
                if ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(target_commit_info)
                {
                    // we optimistically assume the vote will be valid in the future.
                    // when advancing to executed item, we will check if the sigs are valid.
                    // each author at most stores a single sig for each item,
                    // so an adversary will not be able to flood our memory.
                    ordered.unverified_votes.insert(author, vote);
                    return Ok(());
                }
            },
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
            },
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
            },
            Self::Aggregated(aggregated) => {
                // we do not need to do anything for aggregated
                // but return true is helpful to stop the outer loop early
                if aggregated.commit_proof.commit_info() == target_commit_info {
                    return Ok(());
                }
            },
        }
        Err(anyhow!("Inconsistent commit info."))
    }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L736-822)
```rust
    fn process_commit_message(&mut self, commit_msg: IncomingCommitRequest) -> Option<HashValue> {
        let IncomingCommitRequest {
            req,
            protocol,
            response_sender,
        } = commit_msg;
        match req {
            CommitMessage::Vote(vote) => {
                // find the corresponding item
                let author = vote.author();
                let commit_info = vote.commit_info().clone();
                debug!("Receive commit vote {} from {}", commit_info, author);
                let target_block_id = vote.commit_info().id();
                let current_cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if current_cursor.is_some() {
                    let mut item = self.buffer.take(&current_cursor);
                    let new_item = match item.add_signature_if_matched(vote) {
                        Ok(()) => {
                            let response =
                                ConsensusMsg::CommitMessage(Box::new(CommitMessage::Ack(())));
                            if let Ok(bytes) = protocol.to_bytes(&response) {
                                let _ = response_sender.send(Ok(bytes.into()));
                            }
                            item.try_advance_to_aggregated(&self.epoch_state.verifier)
                        },
                        Err(e) => {
                            error!(
                                error = ?e,
                                author = author,
                                commit_info = commit_info,
                                "Failed to add commit vote",
                            );
                            reply_nack(protocol, response_sender);
                            item
                        },
                    };
                    self.buffer.set(&current_cursor, new_item);
                    if self.buffer.get(&current_cursor).is_aggregated() {
                        return Some(target_block_id);
                    } else {
                        return None;
                    }
                } else if self.try_add_pending_commit_vote(vote) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_vote() doesn't care about the response and this should be direct send not RPC
                }
            },
            CommitMessage::Decision(commit_proof) => {
                let target_block_id = commit_proof.ledger_info().commit_info().id();
                info!(
                    "Receive commit decision {}",
                    commit_proof.ledger_info().commit_info()
                );
                let cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if cursor.is_some() {
                    let item = self.buffer.take(&cursor);
                    let new_item = item.try_advance_to_aggregated_with_ledger_info(
                        commit_proof.ledger_info().clone(),
                    );
                    let aggregated = new_item.is_aggregated();
                    self.buffer.set(&cursor, new_item);

                    reply_ack(protocol, response_sender);
                    if aggregated {
                        return Some(target_block_id);
                    }
                } else if self.try_add_pending_commit_proof(commit_proof.into_inner()) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_proof() doesn't care about the response and this should be direct send not RPC
                }
            },
            CommitMessage::Ack(_) => {
                // It should be filtered out by verify, so we log errors here
                error!("Unexpected ack message");
            },
            CommitMessage::Nack => {
                error!("Unexpected NACK message");
            },
        }
        None
    }
```
