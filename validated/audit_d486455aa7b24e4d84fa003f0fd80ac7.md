# Audit Report

## Title
Panic in Move Resource Viewer When Processing Closures with Enum Types Causes API and Indexer Crashes

## Summary
A panic vulnerability exists in the Move resource viewer library when processing closures that capture enum (variant) types. An `.unwrap()` call on an error-returning function triggers when handling `FatType::RuntimeVariants`, causing API server and indexer crashes.

## Finding Description
The vulnerability stems from improper error handling when converting `FatType` to `TypeTag` in the resource annotation logic. When closures capture values of enum types (or vectors containing enums), the captured value layouts are preserved as `MoveStructLayout::RuntimeVariants`. [1](#0-0) 

The `from_runtime_layout` function converts `MoveStructLayout::RuntimeVariants` to `FatType::RuntimeVariants`: [2](#0-1) 

However, the `type_tag()` method explicitly returns an error for `RuntimeVariants`: [3](#0-2) 

The attack path is:

1. Attacker deploys a Move module with a closure capturing a `vector<MyEnum>` where `MyEnum` is an enum type
2. The closure has `store` ability (via `#[persistent]` attribute or public function visibility) - supported since bytecode v8
3. Stores this closure in a resource on-chain
4. When the API or indexer processes this data via `view_value`, it calls `annotate_closure`: [4](#0-3) 

5. For captured values, the layout is converted to `FatType` and `annotate_value` is called with the type `FatType::Vector(Box<FatType::RuntimeVariants(...)>)`
6. When annotating the vector, line 911 calls `.unwrap()` on `type_tag()` which returns an error for `RuntimeVariants`, causing a panic: [5](#0-4) 

The vulnerability affects:
- API servers using `MoveConverter` through the `view_value` path: [6](#0-5) 

- Legacy storage indexer through `parse_struct` and `parse_table_item`: [7](#0-6) [8](#0-7) 

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria as it causes "API crashes". The REST API servers and storage indexer are production node components that process on-chain data. When these components attempt to view/parse a resource containing a closure that captured a `vector<enum>`, the panic crashes the service.

The vulnerability breaks the availability guarantee of the API layer and indexer infrastructure. While it does not directly affect consensus or cause fund loss, it can prevent users from querying blockchain state and disrupt indexer operation, impacting the overall network's usability and observability.

## Likelihood Explanation
**High likelihood**. The attack is trivial to execute:

- Enums are standard Move features enabled in bytecode v7
- Closures with `store` ability are enabled in bytecode v8 via the `#[persistent]` attribute: [9](#0-8) 

- No special permissions required - any user can deploy such a module
- Attack payload is small and inexpensive to deploy (single Move module with closure)
- The vulnerable code path is triggered automatically when querying resources via API or during indexer processing
- The closure checker imposes no restrictions on capturing enum values, only on capturing references: [10](#0-9) 

## Recommendation
Replace the `.unwrap()` call at line 911 with proper error handling. The fix should either:

1. **Handle the error gracefully**: Convert the `Result` to an error that propagates up the call stack instead of panicking
2. **Use `RawStruct` representation**: For `RuntimeVariants` types in vectors, fall back to a raw representation similar to how structs are handled at line 920-921

Suggested fix:
```rust
_ => AnnotatedMoveValue::Vector(
    ty.type_tag(limit).map_err(|e| anyhow!("cannot derive type tag: {}", e))?,
    a.iter()
        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
        .collect::<anyhow::Result<_>>()?,
),
```

## Proof of Concept
```move
module 0x1::exploit {
    enum MyEnum has copy, drop, store {
        Variant1 { x: u64 },
        Variant2 { y: u64 }
    }
    
    struct Container has key {
        closure: |u64| u64 has store
    }
    
    #[persistent]
    fun process(vec: vector<MyEnum>, x: u64): u64 {
        // Process the vector somehow
        x + 1
    }
    
    public entry fun deploy(account: &signer) {
        let my_vec = vector[MyEnum::Variant1 { x: 42 }];
        // This closure captures a vector<MyEnum>
        let closure = |x: u64| process(my_vec, x);
        move_to(account, Container { closure });
    }
}
```

When any API call attempts to view the `Container` resource (e.g., `GET /v1/accounts/{addr}/resource/0x1::exploit::Container`), the API server will panic at line 911 when processing the captured `vector<MyEnum>` value.

## Notes
This vulnerability is distinct from network DoS attacks (which are out of scope). It is a code-level panic bug in the resource viewer that crashes the service when processing specific but valid on-chain data structures. The crash occurs in production API and indexer components, making it a legitimate HIGH severity issue per the Aptos bug bounty program criteria for "API crashes".

### Citations

**File:** third_party/move/move-core/types/src/function.rs (L256-262)
```rust
pub struct MoveClosure {
    pub module_id: ModuleId,
    pub fun_id: Identifier,
    pub ty_args: Vec<TypeTag>,
    pub mask: ClosureMask,
    pub captured: Vec<(MoveTypeLayout, MoveValue)>,
}
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L94-98)
```rust
    // `Runtime` and `RuntimeVariants` are used for typing
    // captured structures in closures, for which we only know
    // the raw layout (no struct name, no field names).
    Runtime(Vec<FatType>),
    RuntimeVariants(Vec<Vec<FatType>>),
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L458-463)
```rust
            Reference(_) | MutableReference(_) | TyParam(_) | RuntimeVariants(_) | Runtime(..) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("cannot derive type tag for {:?}", self)),
                )
            },
```

**File:** third_party/move/tools/move-resource-viewer/src/fat_type.rs (L494-498)
```rust
            Struct(MoveStructLayout::RuntimeVariants(vars)) => FatType::RuntimeVariants(
                vars.iter()
                    .map(|tys| Self::from_layout_slice(tys, limit))
                    .collect::<PartialVMResult<Vec<Vec<_>>>>()?,
            ),
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L863-870)
```rust
        let captured = captured
            .iter()
            .map(|(layout, value)| {
                let fat_type = FatType::from_runtime_layout(layout, limit)
                    .map_err(|e| anyhow!("failed to annotate captured value: {}", e))?;
                self.annotate_value(value, &fat_type, limit)
            })
            .collect::<anyhow::Result<Vec<_>>>()?;
```

**File:** third_party/move/tools/move-resource-viewer/src/lib.rs (L910-915)
```rust
                _ => AnnotatedMoveValue::Vector(
                    ty.type_tag(limit).unwrap(),
                    a.iter()
                        .map(|v| self.annotate_value(v, ty.as_ref(), limit))
                        .collect::<anyhow::Result<_>>()?,
                ),
```

**File:** api/types/src/convert.rs (L1011-1013)
```rust
    pub fn try_into_move_value(&self, typ: &TypeTag, bytes: &[u8]) -> Result<MoveValue> {
        self.inner.view_value(typ, bytes)?.try_into()
    }
```

**File:** storage/indexer/src/lib.rs (L194-200)
```rust
    fn parse_struct(&mut self, struct_tag: StructTag, bytes: &Bytes) -> Result<()> {
        self.parse_move_value(
            &self
                .annotator
                .view_value(&TypeTag::Struct(Box::new(struct_tag)), bytes)?,
        )
    }
```

**File:** storage/indexer/src/lib.rs (L211-224)
```rust
    fn parse_table_item(&mut self, handle: TableHandle, bytes: &Bytes) -> Result<()> {
        match self.get_table_info(handle)? {
            Some(table_info) => {
                self.parse_move_value(&self.annotator.view_value(&table_info.value_type, bytes)?)?;
            },
            None => {
                self.pending_on
                    .entry(handle)
                    .or_default()
                    .push(bytes.clone());
            },
        }
        Ok(())
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/closure_checker.rs (L45-50)
```rust
                        if required_abilities.has_ability(Ability::Store)
                            && fun_env.visibility() != Visibility::Public
                            && !fun_env.has_attribute(|attr| {
                                env.symbol_pool().string(attr.name()).as_str()
                                    == well_known::PERSISTENT_ATTRIBUTE
                            })
```
