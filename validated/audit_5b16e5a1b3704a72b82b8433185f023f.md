# Audit Report

## Title
Storage Fee Double-Counting in Lazy Account Creation Fee Validation

## Summary
The `finish_aborted_transaction` function in `aptos_vm.rs` incorrectly double-counts storage fees when validating minimum fee requirements for lazy account creation. This allows accounts to be created with systematically underpaid storage fees during failed transactions with sequence number 0.

## Finding Description

During lazy account creation for aborted transactions, the fee validation logic contains an arithmetic error that double-counts storage fees. The vulnerable validation check calculates: [1](#0-0) 

However, `gas_used` already includes storage fees converted to gas units. The official FeeStatement documentation explicitly confirms this: [2](#0-1) 

The gas meter's internal consistency check proves this relationship by verifying that total gas consumed equals execution + IO + storage fees in internal units: [3](#0-2) 

The storage fee conversion from Octa to internal gas units occurs via: [4](#0-3) 

The Move epilogue implementation confirms the correct formula uses only `gas_used * gas_unit_price` without adding storage fees again: [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Attacker submits transaction with sequence number 0 to non-existent account
2. Transaction aborts during execution, triggering lazy account creation check: [7](#0-6) 

3. Account creation proceeds, potentially using `UnmeteredGasMeter` if initial attempt fails: [8](#0-7) 

4. Fee validation uses the inflated `actual` value at line 767, causing the check to pass when `actual_correct < expected ≤ actual_inflated`
5. Due to double-counting: `actual_inflated = actual_correct + storage_fee`
6. Account created with underpayment up to `storage_fee` amount

The minimum expected fee is calculated via: [9](#0-8) 

## Impact Explanation

**Medium Severity** - This vulnerability enables protocol-level economic loss through systematic storage fee underpayment:

- **Economic Loss**: Each lazy account creation can underpay by up to the full storage fee amount (difference between actual fee paid and documented minimum)
- **State Manipulation**: Accounts created without meeting the documented minimum storage fee requirements, violating fee policy invariants
- **State Bloat Vector**: Exploitable at scale to create accounts at discounted rates subsidized by the protocol

The impact is bounded per account but exploitable repeatedly. While not causing direct fund theft or consensus violations, it violates resource pricing invariants by allowing state growth without proper fee payment. This aligns with **Medium severity** per Aptos bug bounty criteria: "Limited protocol violations" with "bounded economic impact" per transaction but repeatable across the network.

## Likelihood Explanation

**High Likelihood** - This bug triggers deterministically under common conditions:

**Trigger Requirements:**
- Transaction with sequence number 0 (standard for all new accounts)
- Account does not exist at sender address (common scenario)
- Transaction aborts during execution (trivially achievable)
- Lazy account creation feature enabled (production default setting)

**Exploitability:**
- No special privileges required - any network participant can exploit
- Simple transaction submission via standard API
- Deterministic behavior across all validators (not a consensus issue)
- No timing dependencies or race conditions required
- Economically viable: cost of exploitation < storage fee savings
- Attack can be repeated for multiple accounts

The vulnerability exists in the core transaction failure path and affects every lazy account creation scenario where minimum fee validation is performed.

## Recommendation

Fix the fee validation formula to match the documented specification and Move epilogue implementation. Change line 767 from:

```rust
let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

To:

```rust
let actual = gas_used * gas_unit_price - storage_refund;
```

This removes the double-counting of storage fees, as `gas_used * gas_unit_price` already includes the storage fee component per the FeeStatement documentation.

## Proof of Concept

The mathematical proof demonstrates the vulnerability:

Given:
- `gas_used` includes storage fees converted to gas units (per FeeStatement documentation)
- `gas_used * gas_unit_price ≈ execution_fee + io_fee + storage_fee_octas`
- Expected minimum fee = E
- Storage fee = S

Current buggy validation:
- `actual = gas_used * gas_unit_price + S - refund ≈ (exec + io + S) + S = exec + io + 2S`
- Check passes if: `exec + io + 2S ≥ E`

Correct validation should be:
- `actual = gas_used * gas_unit_price - refund ≈ exec + io + S`
- Check should pass if: `exec + io + S ≥ E`

This allows accounts to be created when total fees paid are in range `[E - S, E)` instead of the required `[E, ∞)`, enabling underpayment of up to the full storage fee amount per account.

## Notes

This vulnerability is a logic bug in the fee validation arithmetic, not a consensus issue. All validators execute the same buggy code deterministically, so there is no state divergence. The economic impact is real and measurable, with each exploitation saving the attacker up to the storage fee amount at the protocol's expense.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L705-706)
```rust
        let should_create_account_resource =
            should_create_account_resource(txn_data, self.features(), resolver, module_storage)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L722-730)
```rust
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L767-767)
```rust
                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
```

**File:** types/src/fee_statement.rs (L19-24)
```rust
///        - storage fee charge (storage space): `storage_fee_octas`, to be included in
///          `total_charge_gas_unit`, this number is converted to gas units according to the user
///          specified `gas_unit_price` on the transaction.
///    - storage deletion refund: `storage_fee_refund_octas`, this is not included in `gas_used` or
///      `total_charge_gas_units`, the net charge / refund is calculated by
///      `total_charge_gas_units` * `gas_unit_price` - `storage_fee_refund_octas`.
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L152-153)
```rust
        let total_calculated =
            self.execution_gas_used + self.io_gas_used + self.storage_fee_in_internal_units;
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L260-280)
```rust
        let gas_consumed_internal = div_ceil(
            (u64::from(amount) as u128) * (u64::from(txn_params.gas_unit_scaling_factor) as u128),
            u64::from(gas_unit_price) as u128,
        );
        let gas_consumed_internal = InternalGas::new(
            if gas_consumed_internal > u64::MAX as u128 {
                error!(
                    "Something's wrong in the gas schedule: gas_consumed_internal ({}) > u64::MAX",
                    gas_consumed_internal
                );
                u64::MAX
            } else {
                gas_consumed_internal as u64
            },
        );

        match self.balance.checked_sub(gas_consumed_internal) {
            Some(new_balance) => {
                self.balance = new_balance;
                self.storage_fee_in_internal_units += gas_consumed_internal;
                self.storage_fee_used += amount;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L597-603)
```text
        let gas_used = txn_max_gas_units - gas_units_remaining;

        assert!(
            (txn_gas_price as u128) * (gas_used as u128) <= MAX_U64,
            error::out_of_range(EOUT_OF_GAS)
        );
        let transaction_fee_amount = txn_gas_price * gas_used;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L620-626)
```text
            if (transaction_fee_amount > storage_fee_refunded) {
                let burn_amount = transaction_fee_amount - storage_fee_refunded;
                transaction_fee::burn_fee(gas_payer, burn_amount);
            } else if (transaction_fee_amount < storage_fee_refunded) {
                let mint_amount = storage_fee_refunded - transaction_fee_amount;
                transaction_fee::mint_and_refund(gas_payer, mint_amount);
            };
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L229-239)
```rust
    pub fn hack_account_creation_fee_lower_bound(&self, params: &TransactionGasParameters) -> Fee {
        match self {
            Self::V1 => params.legacy_storage_fee_per_state_slot_create * NumSlots::new(1),
            Self::V2 => {
                // This is an underestimation of the fee for account creation, because AccountResource has a
                // vector and two optional addresses in it which will expand to more bytes on-chain
                params.storage_fee_per_state_slot * NumSlots::new(1)
                    + params.storage_fee_per_state_byte
                        * NumBytes::new(std::mem::size_of::<AccountResource>() as u64)
            },
        }
```
