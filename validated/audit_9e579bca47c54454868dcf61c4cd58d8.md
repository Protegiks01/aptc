# Audit Report

## Title
Race Condition in Order Vote Creation Causes Consensus Liveness Failure Due to Non-Deterministic Block Info

## Summary
A critical race condition exists in the order vote creation flow where different validators sign order votes with different `BlockInfo` values (placeholder vs. actual execution results) depending on execution timing. This prevents order vote aggregation and causes consensus liveness failure, as blocks cannot be ordered or committed without reaching order vote quorum.

## Finding Description

The vulnerability stems from a fundamental design inconsistency between how regular votes and order votes handle decoupled execution:

**Regular votes correctly use placeholders:** The `VoteProposal` struct includes a `decoupled_execution` flag that, when enabled, ensures all validators vote with identical placeholder values (`ACCUMULATOR_PLACEHOLDER_HASH` and version 0) regardless of execution timing. [1](#0-0) [2](#0-1) [3](#0-2) 

**Order votes lack this protection:** The `OrderVoteProposal` struct has no such mechanism and simply passes through whatever `BlockInfo` is currently in the block's `state_compute_result`. [4](#0-3) 

**The race condition occurs as follows:**

1. Blocks are created with dummy execution results containing `ACCUMULATOR_PLACEHOLDER_HASH` and version 0: [5](#0-4) [6](#0-5) 

2. Block execution runs asynchronously in the pipeline: [7](#0-6) [8](#0-7) 

3. When a QC is formed, `broadcast_order_vote` is immediately called WITHOUT waiting for execution: [9](#0-8) 

4. Order vote creation reads `block_info()` which retrieves the current `state_compute_result`: [10](#0-9) [11](#0-10) [12](#0-11) 

5. `BlockInfo` contains execution-dependent fields (`executed_state_id` and `version`) that differ based on timing: [13](#0-12) 

6. Order votes are embedded in `LedgerInfo` via `guarded_construct_and_sign_order_vote`: [14](#0-13) 

7. Order votes are aggregated by `LedgerInfo` hash, causing votes with different `BlockInfo` to split into separate buckets: [15](#0-14) 

**Critical constraint:** Blocks must be ordered before they can be committed. The system enforces this invariant: [16](#0-15) 

**Why this differs from commit votes:** Commit votes properly wait for the `ledger_update_fut` to complete before creating votes, ensuring all validators use actual execution results: [17](#0-16) 

## Impact Explanation

This vulnerability causes **Total loss of liveness/network availability**, which is **Critical Severity** per Aptos bug bounty criteria:

- **Consensus halts:** When order votes split across different `LedgerInfo` hashes, neither group reaches the 2/3+1 quorum threshold required for aggregation
- **Blocks cannot be ordered:** Without order vote quorum, ordered certificates cannot be formed
- **Blocks cannot be committed:** The invariant `highest_ordered_round() >= highest_commit_round()` prevents committing blocks that haven't been ordered
- **Network stops processing transactions:** No new transactions can be finalized despite validators continuing to produce blocks
- **Timeout doesn't recover:** Safety rules prevent creating order votes for rounds that have timed out, so blocks remain permanently unordered [18](#0-17) 

This violates the **Deterministic Execution** invariant where all honest validators must produce identical signatures for consensus mechanisms.

## Likelihood Explanation

**High likelihood** - This vulnerability can trigger during normal network operation:

- **Natural occurrence:** Validators have varying hardware specifications (CPU, memory, storage), network latency, and system loads, causing different execution speeds
- **No attacker required:** Normal timing variations between validators are sufficient to trigger the race condition
- **Wide execution window:** The gap between QC formation and execution completion provides ample opportunity for timing misalignment
- **No synchronization:** The code path contains no mechanism to wait for execution completion before creating order votes
- **Always active:** Decoupled execution is hardcoded to always return `true`: [19](#0-18) 

- **Enabled by default:** Order votes are enabled in genesis and default configurations

The vulnerability can also be amplified maliciously by proposing blocks with varying transaction complexity to maximize timing differences between validators.

## Recommendation

Implement the same placeholder mechanism for order votes that already exists for regular votes:

1. Add a `decoupled_execution` flag to `OrderVoteProposal`
2. Modify `PipelinedBlock::order_vote_proposal()` to pass the decoupled execution configuration
3. Create a method similar to `vote_data_ordering_only()` that generates `BlockInfo` with placeholder values when decoupled execution is enabled
4. Ensure all validators use placeholder values (`ACCUMULATOR_PLACEHOLDER_HASH`, version 0) for order votes, regardless of execution timing

Alternative approach: Make order votes explicitly wait for execution completion before creating the vote, similar to how commit votes wait for `ledger_update_fut`.

## Proof of Concept

The vulnerability manifests in production when:
1. A block is proposed and validators begin voting
2. QC forms when 2/3+1 validators vote
3. All validators immediately broadcast order votes
4. Approximately half the validators have completed execution (actual hash/version), while half haven't (placeholder hash/version 0)
5. Order votes split: Group A votes with placeholder values, Group B with actual values
6. Neither group reaches 2/3+1 quorum (e.g., if split 50/50, each has only ~33% instead of required 67%)
7. Consensus cannot form ordered certificate
8. Block remains unordered indefinitely
9. Subsequent blocks also fail to order (same race condition repeats)
10. Network stops committing transactions

This can be observed in validator logs showing `ORDER_VOTE_ADDED` counters incrementing without corresponding `NewLedgerInfoWithSignatures` formation.

## Notes

The root cause is that `VoteProposal` was properly designed to handle decoupled execution with the `decoupled_execution` flag and `vote_data_ordering_only()` method, but `OrderVoteProposal` was not given equivalent treatment. This creates a determinism break specifically in the order voting phase while regular voting remains deterministic.

### Citations

**File:** consensus/consensus-types/src/vote_proposal.rs (L27-27)
```rust
    decoupled_execution: bool,
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/vote_proposal.rs (L88-101)
```rust
    pub fn gen_vote_data(&self) -> anyhow::Result<VoteData> {
        if self.decoupled_execution {
            Ok(self.vote_data_ordering_only())
        } else {
            let proposed_block = self.block();
            let new_tree = self.accumulator_extension_proof().verify(
                proposed_block
                    .quorum_cert()
                    .certified_block()
                    .executed_state_id(),
            )?;
            Ok(self.vote_data_with_extension_proof(&new_tree))
        }
    }
```

**File:** consensus/consensus-types/src/order_vote_proposal.rs (L15-30)
```rust
pub struct OrderVoteProposal {
    #[serde(bound(deserialize = "Block: Deserialize<'de>"))]
    block: Block,
    /// BlockInfo for the above block
    block_info: BlockInfo,
    /// QuorumCert for the above block
    quorum_cert: Arc<QuorumCert>,
}

impl OrderVoteProposal {
    pub fn new(block: Block, block_info: BlockInfo, quorum_cert: Arc<QuorumCert>) -> Self {
        Self {
            block,
            block_info,
            quorum_cert,
        }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L394-398)
```rust
    pub fn new_ordered(block: Block, window: OrderedBlockWindow) -> Self {
        let input_transactions = Vec::new();
        let state_compute_result = StateComputeResult::new_dummy();
        Self::new(block, input_transactions, state_compute_result).with_block_window(window)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L74-76)
```rust
    pub fn new_dummy() -> Self {
        Self::new_dummy_with_root_hash(*ACCUMULATOR_PLACEHOLDER_HASH)
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L390-405)
```rust
    pub fn build_for_consensus(
        &self,
        pipelined_block: &PipelinedBlock,
        parent_futs: PipelineFutures,
        block_store_callback: Box<
            dyn FnOnce(WrappedLedgerInfo, LedgerInfoWithSignatures) + Send + Sync,
        >,
    ) {
        Self::build(
            self,
            pipelined_block,
            parent_futs,
            block_store_callback,
            false,
        );
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L502-511)
```rust
        let ledger_update_fut = spawn_shared_fut(
            Self::ledger_update(
                rand_check_fut.clone(),
                execute_fut.clone(),
                parent.ledger_update_fut.clone(),
                self.executor.clone(),
                block.clone(),
            ),
            None,
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L978-1029)
```rust
    async fn sign_and_broadcast_commit_vote(
        ledger_update_fut: TaskFuture<LedgerUpdateResult>,
        order_vote_rx: oneshot::Receiver<()>,
        order_proof_fut: TaskFuture<WrappedLedgerInfo>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        signer: Arc<ValidatorSigner>,
        block: Arc<Block>,
        order_vote_enabled: bool,
        network_sender: Arc<NetworkSender>,
    ) -> TaskResult<CommitVoteResult> {
        let mut tracker = Tracker::start_waiting("sign_commit_vote", &block);
        let (compute_result, _, epoch_end_timestamp) = ledger_update_fut.await?;
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
        tracker.start_working();

        let mut block_info = block.gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        );
        if let Some(timestamp) = epoch_end_timestamp {
            info!(
                "[Pipeline] update block timestamp from {} to epoch end timestamp {}",
                block_info.timestamp_usecs(),
                timestamp
            );
            block_info.change_timestamp(timestamp);
        }
        let ledger_info = LedgerInfo::new(block_info, consensus_data_hash);
        info!("[Pipeline] Signed ledger info {ledger_info}");
        let signature = signer.sign(&ledger_info).expect("Signing should succeed");
        let commit_vote = CommitVote::new_with_signature(signer.author(), ledger_info, signature);
        network_sender
            .broadcast_commit_vote(commit_vote.clone())
            .await;
        Ok(commit_vote)
```

**File:** consensus/src/round_manager.rs (L1626-1651)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;

        fail_point!("consensus::create_invalid_order_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_order_vote = OrderVote::new_with_signature(
                order_vote.author(),
                order_vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_order_vote)
        });
        Ok(order_vote)
    }
```

**File:** consensus/src/round_manager.rs (L1795-1815)
```rust
                if self.onchain_config.order_vote_enabled() {
                    // This check is already done in safety rules. As printing the "failed to broadcast order vote"
                    // in humio logs could sometimes look scary, we are doing the same check again here.
                    if let Some(last_sent_vote) = self.round_state.vote_sent() {
                        if let Some((two_chain_timeout, _)) = last_sent_vote.two_chain_timeout() {
                            if round <= two_chain_timeout.round() {
                                return Ok(());
                            }
                        }
                    }
                    // Broadcast order vote if the QC is successfully aggregated
                    // Even if broadcast order vote fails, the function will return Ok
                    if let Err(e) = self.broadcast_order_vote(vote, qc.clone()).await {
                        warn!(
                            "Failed to broadcast order vote for QC {:?}. Error: {:?}",
                            qc, e
                        );
                    } else {
                        self.broadcast_fast_shares(qc.certified_block()).await;
                    }
                }
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L113-114)
```rust
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/src/pending_order_votes.rs (L68-81)
```rust
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });
```

**File:** consensus/consensus-types/src/sync_info.rs (L158-165)
```rust
        ensure!(
            self.highest_ordered_round() >= self.highest_commit_round(),
            format!(
                "HOC {} has lower round than HLI {}",
                self.highest_ordered_cert(),
                self.highest_commit_cert()
            )
        );
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```
