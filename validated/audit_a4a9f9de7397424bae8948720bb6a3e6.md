# Audit Report

## Title
Race Condition in Asynchronous OIDC Provider Removal During DKG Reconfiguration

## Summary
A race condition exists during DKG-based epoch transitions where governance's removal of a compromised OIDC provider is undermined. Provider removal is buffered (asynchronous) while JWK removal is immediate, but validators continue watching the provider during the DKG window and can re-add malicious JWKs before the provider is fully removed, enabling unauthorized transaction authentication.

## Finding Description

The vulnerability stems from inconsistent timing models for OIDC provider removal during DKG reconfiguration:

**Asynchronous Provider Removal**: The `remove_oidc_provider_for_next_epoch()` function uses a config buffer pattern where provider changes are staged but only applied when `on_new_epoch()` is called at epoch transition. [1](#0-0) 

**Synchronous JWK Removal**: The `remove_issuer_from_observed_jwks()` function immediately removes JWKs from the `ObservedJWKs` resource and regenerates `PatchedJWKs`. [2](#0-1) 

**DKG Timing Issue**: When DKG is enabled, `aptos_governance::reconfigure()` calls `reconfiguration_with_dkg::try_start()` which starts DKG but does NOT immediately trigger the epoch change. [3](#0-2)  The epoch only changes when `finish()` is called after DKG completes. [4](#0-3) 

**Validator Behavior**: Validators read `SupportedOIDCProviders` from on-chain config at epoch start and spawn JWKObserver instances for each provider. [5](#0-4)  These observers continue running throughout the epoch watching their assigned providers. [6](#0-5) 

**Missing Validation**: The `upsert_into_observed_jwks()` function has no validation check to verify that the issuer is in the current `SupportedOIDCProviders` list. [7](#0-6)  Validator transaction verification similarly lacks such checks. [8](#0-7) 

**Authentication Impact**: Updated JWKs immediately flow to `PatchedJWKs` which is used for keyless transaction authentication. [9](#0-8) [10](#0-9) 

**Attack Flow**:
1. Governance executes removal proposal: buffers provider removal, immediately removes JWKs, starts DKG
2. During DKG window (minutes): validators remain in old epoch, continue watching based on old provider list
3. Attacker publishes malicious JWKs at compromised provider endpoint
4. Validators' JWKObservers fetch malicious JWKs, reach consensus, submit `upsert_into_observed_jwks()` validator transaction
5. Malicious JWKs re-added to `ObservedJWKs` and immediately regenerated into `PatchedJWKs`
6. Keyless transactions authenticated using malicious JWKs until DKG completes and epoch changes
7. When `finish()` is called post-DKG, `on_new_epoch()` finally applies buffered provider removal

## Impact Explanation

This constitutes a **MEDIUM severity** vulnerability representing a **Limited Protocol Violation** per Aptos bug bounty categories:

- **Authentication Bypass Window**: During the DKG window (potentially several minutes), a compromised OIDC provider that governance explicitly voted to remove can have its JWKs re-introduced, allowing unauthorized keyless transaction authentication
- **Governance Intent Violation**: The system fails to enforce governance's security decision during the critical transition period when protection is most needed
- **State Consistency Violation**: The system enters an inconsistent state where `SupportedOIDCProviders` (what validators should watch) and `ObservedJWKs` (what authenticates transactions) diverge from governance intent

While this doesn't directly enable fund theft or consensus violations (which would be Critical severity), it creates a time-bounded window where the keyless authentication system's security posture is compromised, violating transaction validation invariants and undermining governance authority.

## Likelihood Explanation

**Likelihood: MODERATE**

The attack is technically feasible and requires specific but realistic timing:

1. **Triggering Condition**: OIDC provider compromise requiring rapid governance response - realistic security scenario in practice
2. **Attack Window**: DKG duration provides minutes for exploitation - substantial time for attacker
3. **No Special Privileges**: Only requires control of the already-compromised OIDC provider
4. **Automatic Execution**: Validators automatically continue watching and proposing JWK updates without manual intervention
5. **Timing Requirement**: Requires provider removal to occur during an active DKG reconfiguration period, which reduces likelihood from HIGH to MODERATE

The moderate likelihood stems from the fact that while OIDC provider compromises do occur, they must coincide with governance action during a DKG-enabled reconfiguration to be exploitable.

## Recommendation

Implement synchronous validation in `upsert_into_observed_jwks()` to check that the issuer exists in the current `SupportedOIDCProviders` before accepting JWK updates:

```move
public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches, SupportedOIDCProviders {
    system_addresses::assert_aptos_framework(fx);
    
    // NEW: Validate issuers against current supported providers
    let supported_providers = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    let supported_issuer_set = /* create set from supported_providers.providers */;
    
    vector::for_each_ref(&provider_jwks_vec, |provider_jwks| {
        assert!(
            /* issuer in supported_issuer_set */,
            error::invalid_argument(EISSUER_NOT_IN_SUPPORTED_PROVIDERS)
        );
    });
    
    // ... rest of existing logic
}
```

Alternative: Shut down JWKObservers immediately when `remove_issuer_from_observed_jwks()` is called, rather than waiting for epoch change.

## Proof of Concept

The attack can be demonstrated through the following sequence:

1. Deploy test OIDC provider X with initial JWK set
2. Submit governance proposal calling: `remove_oidc_provider_for_next_epoch()`, `remove_issuer_from_observed_jwks()`, `reconfigure()` with DKG enabled
3. During DKG window (before `finish()` is called), publish malicious JWKs at provider X endpoint
4. Observe validators' JWKObservers fetch and propose the malicious JWKs
5. Verify malicious JWKs are added to `ObservedJWKs` and `PatchedJWKs` via `upsert_into_observed_jwks()`
6. Submit keyless transaction using malicious JWK - transaction is accepted
7. After DKG completes and `finish()` is called, verify provider X is finally removed

The vulnerability is confirmed by the absence of issuer validation checks in both the Move function [7](#0-6)  and Rust validator transaction processing [8](#0-7) , combined with the asynchronous nature of DKG-based epoch transitions [11](#0-10) .

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L352-363)
```text
    public fun remove_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };
        let ret = remove_oidc_provider_internal(&mut provider_set, name);
        config_buffer::upsert(provider_set);
        ret
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L510-520)
```text
    public fun remove_issuer_from_observed_jwks(fx: &signer, issuer: vector<u8>): Option<ProviderJWKs> acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);
        let old_value = remove_issuer(&mut observed_jwks.jwks, issuer);

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();

        old_value
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L685-692)
```text
    public entry fun reconfigure(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-195)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-179)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L91-94)
```rust
fn get_jwks_onchain(resolver: &impl AptosMoveResolver) -> anyhow::Result<PatchedJWKs, VMStatus> {
    PatchedJWKs::fetch_config(resolver)
        .ok_or_else(|| value_deserialization_error!("could not deserialize PatchedJWKs"))
}
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L244-246)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration_with_dkg::try_start();
        };
```
