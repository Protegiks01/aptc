# Audit Report

## Title
ObjectCore Deletion Race Condition Causes Indexer Event Data Corruption and Sequence Number Collisions

## Summary
The event indexer's `TransferTranslator` uses `latest_state_checkpoint_view()` to query `ObjectCore` resources when translating V2 Transfer events to V1 format. This creates a race condition where an object can be transferred and then deleted before the indexer processes the transfer event. When ObjectCore is not found, the translator falls back to a deterministic creation number with sequence 0, causing events to be indexed with incorrect sequence numbers, leading to data corruption and API query failures.

## Finding Description
The vulnerability exists in the V2-to-V1 event translation mechanism used by the indexer for backward compatibility. The `TransferTranslator` implementation attempts to look up the `ObjectCore` resource to obtain the correct event key and sequence number. [1](#0-0) 

The critical flaw is that the state lookup uses `latest_state_checkpoint_view()`, which returns a state view at the latest committed checkpoint version, not at the version when the event was originally emitted. [2](#0-1) [3](#0-2) 

This is confirmed by the `latest_state_checkpoint_view()` implementation which explicitly retrieves the latest checkpoint version. [4](#0-3) 

**Attack Scenario:**

1. **Version V**: User transfers a deletable object, emitting Transfer event (ObjectCore exists)
2. **Version V+1**: User deletes the object via `delete()`, removing ObjectCore from storage [5](#0-4) 
3. **Version V+2+**: Indexer processes the Transfer event from version V
4. Indexer queries ObjectCore at latest state (V+2+) where it no longer exists
5. Lookup fails, translator falls back to deterministic creation number `0x4000000000000` with sequence `0` [6](#0-5) 
6. Multiple transfers for the same object all get indexed with sequence 0, causing database overwrites

**Data Corruption Mechanism:**

Events are stored in `EventByKeySchema` with key `(EventKey, sequence_number)`. [7](#0-6)  When multiple events claim the same sequence number, RocksDB's put operation overwrites previous entries. [8](#0-7) 

When clients query events, the system validates that sequence numbers are continuous. [9](#0-8)  If events are missing due to overwrites, queries fail with "DB corruption: Sequence number not continuous" errors.

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

1. **API Crashes (HIGH)**: When clients query events for affected objects, the indexer returns "DB corruption: Sequence number not continuous" errors, causing API failures and preventing event data retrieval.

2. **Indexer Data Corruption**: Event history becomes permanently corrupted with missing or overwritten events. Original transfer events are silently lost when later events overwrite them in the database.

3. **Incorrect Query Results**: APIs return incomplete event histories, breaking applications that rely on complete event data for NFT provenance, gaming state tracking, or audit trails.

The vulnerability does not reach Critical severity as it does not directly affect consensus, fund security, or core blockchain operation. However, it severely degrades the indexer subsystem which is critical for application functionality and ecosystem usability.

## Likelihood Explanation
**High Likelihood** - This vulnerability is easily exploitable:

**Attacker Requirements:**
- Ability to create deletable objects (standard Move framework feature available to all users)
- Ability to submit transactions (any network participant)
- No special permissions required

**Triggering Conditions:**
- Objects with `can_delete=true` are common in NFT marketplaces and gaming applications
- Indexer processing naturally lags behind block production during high load or node catchup
- Any deletion after transfer triggers the vulnerability

**Realistic Scenarios:**
- NFT marketplaces where tokens are transferred and then burned
- Gaming applications with temporary items that are created, moved, and destroyed
- Any protocol pattern involving object lifecycle management

The vulnerability is deterministic and will occur whenever an object is deleted after being transferred but before the indexer processes the transfer event, making it a systemic issue rather than an edge case.

## Recommendation
Fix the state lookup to use a versioned state view that corresponds to the event's emission version rather than the latest checkpoint:

1. **Short-term**: Modify `translate_event_v2_to_v1` to accept the event's version as a parameter and use `state_view_at_version(event_version)` instead of `latest_state_checkpoint_view()`.

2. **Long-term**: Consider caching ObjectCore metadata (event keys and counts) at event emission time to avoid state lookups during translation, or storing the correct sequence number in the V2 event data itself.

3. **Data Recovery**: Provide tooling to detect and recover from corrupted event indices by reprocessing events from the original transaction data.

## Proof of Concept
The vulnerability can be demonstrated with the following Move test scenario:

```move
// 1. Create deletable object
let constructor_ref = object::create_object(creator_addr);
let delete_ref = object::generate_delete_ref(&constructor_ref);

// 2. Transfer object multiple times
object::transfer(&creator, obj, @recipient1);
object::transfer(&recipient1_signer, obj, @recipient2);

// 3. Delete object
object::delete(delete_ref);

// 4. Indexer processes events after deletion
// - Both transfer events fail ObjectCore lookup
// - Both fallback to sequence 0
// - Second transfer overwrites first in EventByKeySchema
// - Querying events returns "DB corruption: Sequence number not continuous"
```

A complete Rust integration test would need to:
1. Execute transactions that transfer and delete objects
2. Force indexer to process events after deletion
3. Query the event API to demonstrate the corruption
4. Verify "DB corruption: Sequence number not continuous" error is returned

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L207-214)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L221-224)
```rust
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
```

**File:** storage/indexer/src/event_v2_translator.rs (L392-428)
```rust
struct TransferTranslator;
impl EventV2Translator for TransferTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let transfer = Transfer::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x1::object::ObjectCore".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(transfer.object(), &struct_tag)?
        {
            let object_core_resource: ObjectCoreResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_core_resource.transfer_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_core_resource.transfer_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of TransferEvent is deterministically 0x4000000000000
            // because the INIT_GUID_CREATION_NUM in the Move module is 0x4000000000000.
            static TRANSFER_EVENT_CREATION_NUMBER: u64 = 0x4000000000000;
            (
                EventKey::new(TRANSFER_EVENT_CREATION_NUMBER, *transfer.object()),
                0,
            )
        };
        let transfer_event =
            TransferEvent::new(*transfer.object(), *transfer.from(), *transfer.to());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TRANSFER_EVENT_TYPE.clone(),
            bcs::to_bytes(&transfer_event)?,
        )?)
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L82-90)
```rust
    fn latest_state_checkpoint_view(&self) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version: self
                .get_latest_state_checkpoint_version()
                .map_err(Into::<StateViewError>::into)?,
            maybe_verify_against_state_root_hash: None,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L414-428)
```text
    public fun delete(self: DeleteRef) acquires Untransferable, ObjectCore {
        let object_core = move_from<ObjectCore>(self.self);
        let ObjectCore {
            guid_creation_num: _,
            owner: _,
            allow_ungated_transfer: _,
            transfer_events,
        } = object_core;

        if (exists<Untransferable>(self.self)) {
            let Untransferable {} = move_from<Untransferable>(self.self);
        };

        event::destroy_handle(transfer_events);
    }
```

**File:** storage/indexer_schemas/src/schema/event_by_key/mod.rs (L23-29)
```rust
define_pub_schema!(EventByKeySchema, Key, Value, EVENT_BY_KEY_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, SeqNum);

type Index = u64;
type Value = (Version, Index);
```

**File:** storage/indexer/src/db_indexer.rs (L464-469)
```rust
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
```

**File:** storage/aptosdb/src/event_store/mod.rs (L130-137)
```rust
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
```
