# Audit Report

## Title
Unbounded Memory Growth in VM Validator Module Cache Leading to Resource Exhaustion

## Summary
The `CachedModuleView` used in `vm-validator` for transaction validation has no memory bounds on its module cache. An attacker can cause unbounded memory growth by deploying many large Move modules and sending transactions that reference them, leading to memory exhaustion across all validator nodes.

## Finding Description
The vm-validator component uses a `PooledVMValidator` that maintains a pool of `VMValidator` instances for concurrent transaction validation. Each `VMValidator` contains a `CachedModuleView` that caches loaded Move modules to avoid repeated deserialization. [1](#0-0) 

The `CachedModuleView` uses an `UnsyncModuleCache` internally, which is implemented as a simple `RefCell<HashMap>` with no size limits: [2](#0-1) [3](#0-2) 

**Critical Issue**: The cache persists across block commits in the normal case. When `notify_commit()` is called after a block commit, if the state versions are compatible (linear progression), it only calls `reset_state_view()` which does NOT flush the module cache: [4](#0-3) [5](#0-4) 

**Contrast with Block Executor**: The block executor uses `GlobalModuleCache` which tracks `size_in_bytes` and enforces a configurable memory limit (default 1GB): [6](#0-5) [7](#0-6) [8](#0-7) [9](#0-8) 

The vm-validator has NO such bounds checking.

**Attack Path**:
1. Attacker deploys many large Move modules (production config has unlimited struct/function definitions): [10](#0-9) 

2. Attacker sends transactions to mempool that call functions in these modules
3. Each VMValidator loads modules into its unbounded cache during validation
4. Pool size multiplies impact (set to `num_cpus::get()`): [11](#0-10) 

5. Modules accumulate across commits (cache not flushed in normal case)
6. Memory exhaustion occurs, degrading validator performance or causing crashes

The cache is only cleared during incompatible state transitions or reconfig events via `reset_all()`, not during normal block processing: [12](#0-11) 

## Impact Explanation
**High Severity** per Aptos bug bounty criteria:

This vulnerability directly matches the HIGH severity category: "Validator Node Slowdowns (High): Significant performance degradation affecting consensus, DoS through resource exhaustion."

- **Validator node slowdowns**: Memory exhaustion causes performance degradation as nodes approach OOM conditions, impacting transaction validation throughput
- **Potential node crashes**: Severe memory exhaustion can trigger OOM killer, causing validator unavailability
- **Network-wide impact**: All validators are affected simultaneously as they process the same transactions

This is resource exhaustion DoS (in scope), not network DoS (out of scope). The attack uses valid transactions to cause memory exhaustion, not network packet flooding.

## Likelihood Explanation
**High Likelihood**:
- Attack requires only standard user capabilities (module deployment + transaction submission)
- No rate limiting on module cache growth in the vm-validator
- Exploit is deterministic and reproducible
- Cost is bounded by gas fees for module deployment (one-time cost per module)
- Impact persists across blocks until incompatible state transition or reconfig event
- Affects all validators simultaneously, maximizing damage
- Module size limits in production are lenient (unlimited struct/function definitions per module)

## Recommendation
Implement memory bounds for the vm-validator module cache similar to `GlobalModuleCache`:

1. Add a `size: usize` field to track total cached module sizes
2. Implement a configurable `max_vm_validator_cache_size_in_bytes` limit
3. Add cache eviction logic when the limit is exceeded (e.g., LRU eviction)
4. Alternatively, share the bounded `GlobalModuleCache` between block executor and vm-validator
5. Add monitoring metrics for vm-validator cache size

Example fix structure:
```rust
pub struct CachedModuleView<S> {
    pub state_view: S,
    pub environment: AptosEnvironment,
    pub module_cache: UnsyncModuleCache<...>,
    cache_size_bytes: usize,  // Track total size
    max_cache_size_bytes: usize,  // Configurable limit
}
```

## Proof of Concept
A proof of concept would involve:

1. Deploy multiple large Move modules (each ~60KB, totaling sufficient size to cause memory pressure)
2. Submit transactions to mempool that reference these modules
3. Monitor validator memory usage growth over time
4. Observe that memory continues to grow across block commits
5. Demonstrate performance degradation or OOM conditions

**Notes**
This vulnerability represents a design flaw where the vm-validator's unbounded module cache contrasts with the block executor's bounded `GlobalModuleCache`. The asymmetry creates an exploitable resource exhaustion vector that affects all validator nodes simultaneously, matching the HIGH severity criteria for validator node slowdowns through resource exhaustion DoS.

### Citations

**File:** vm-validator/src/vm_validator.rs (L42-45)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L101-103)
```rust
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L122-125)
```rust
    /// the VM.
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L134-138)
```rust
    pub fn reset_all(&mut self, state_view: S) {
        self.state_view = state_view;
        self.environment = AptosEnvironment::new(&self.state_view);
        self.module_cache = UnsyncModuleCache::empty();
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L211-213)
```rust
pub struct UnsyncModuleCache<K, DC, VC, E, V> {
    module_cache: RefCell<HashMap<K, VersionedModuleCode<DC, VC, E, V>>>,
}
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L92-93)
```rust
    /// Sum of serialized sizes (in bytes) of all cached modules.
    size: usize,
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L150-153)
```rust
    /// Returns the sum of serialized sizes of modules stored in cache.
    pub fn size_in_bytes(&self) -> usize {
        self.size
    }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L216-216)
```rust
                self.size += module.extension().size_in_bytes();
```

**File:** types/src/block_executor/config.rs (L36-37)
```rust
            // of writing this comment, 13.11.24).
            max_module_cache_size_in_bytes: 1024 * 1024 * 1024,
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```

**File:** mempool/src/shared_mempool/runtime.rs (L104-107)
```rust
    let vm_validator = Arc::new(RwLock::new(PooledVMValidator::new(
        Arc::clone(&db),
        num_cpus::get(),
    )));
```
