# Audit Report

## Title
Temporal Inconsistency in Multi-Layer State Reads Causes Non-Deterministic Transaction Execution

## Summary
The `CachedStateView` implementation reads from hot state without version validation while the hot state can be concurrently updated by a background committer thread, creating temporal inconsistencies where a single state view reads different keys from different blockchain versions, violating deterministic execution guarantees and causing potential consensus divergence across validators.

## Finding Description

The `CachedStateView` employs a three-layer state lookup architecture (speculative → hot → cold) where the `get_unmemorized()` method queries these layers sequentially: [1](#0-0) 

The hot state lookup returns values without any version validation, while the cold state explicitly queries at `base_version` to ensure consistency. The hot state is accessed through an `Arc<dyn HotStateView>` which references a shared `HotStateBase` structure.

The `HotState::get_committed()` method returns an Arc-cloned reference to the shared `HotStateBase`, not a snapshot: [2](#0-1) 

This shared reference can be modified by the background committer thread, which asynchronously updates the `HotStateBase` in the `commit()` method: [3](#0-2) 

The `HotStateBase::get_state_slot()` implementation retrieves values directly from the DashMap without any version checking: [4](#0-3) 

The `StateSlot` structure contains `value_version` and `hot_since_version` fields: [5](#0-4) 

However, the `value_version` is never validated against `base_version` in the hot state read path.

**Race Condition:**

1. Validator V1 calls `get_persisted_state()` at time T1, receives `(hot_arc, persisted_state@v100)`
2. V1 creates `CachedStateView` with `base_version = 100`
3. At time T2, the Committer completes processing version 101, updating the shared `HotStateBase` via the Arc
4. At time T3, V1 executes transactions reading state:
   - Key A found in hot state → returns value@v101 (newly committed)
   - Key B not in hot state → queries cold storage@v100 → returns value@v100
   - **Result: Temporal inconsistency - mixed versions in same state view**

5. Validator V2 executes the same block at a different time, potentially seeing different combinations of hot/cold state versions depending on when `get_persisted_state()` was called relative to the Committer updates.

## Impact Explanation

**Critical Severity** - This vulnerability directly violates the **Deterministic Execution** invariant that all validators must produce identical state roots for identical blocks.

The impact includes:

1. **Consensus Safety Violation**: Different validators executing the same block at different times relative to the background commit pipeline will compute different state roots due to race conditions with the hot state committer thread. This matches the Critical Severity category "Consensus/Safety violations" in the Aptos bug bounty program.

2. **Non-Deterministic Transaction Execution**: Transaction outcomes depend on the timing of background committer updates rather than solely on transaction inputs and prior committed state.

3. **State Merkle Tree Inconsistency**: The computed state root will not correctly represent a consistent snapshot of any single version, as it combines data from multiple versions.

4. **Potential Chain Split**: Validators computing different state roots will disagree on block validity, potentially causing network partition if the split is deterministic based on validator execution timing patterns.

## Likelihood Explanation

**High Likelihood** - This race condition occurs naturally during normal blockchain operation without requiring any attacker action:

- Block execution and hot state commits happen continuously and concurrently as part of normal operation
- The race window exists whenever a `CachedStateView` is created while the committer thread is in the process of updating hot state
- No special preconditions required - the vulnerability is inherent in the system's asynchronous commit architecture
- Higher transaction throughput increases collision probability as commits happen more frequently
- All validators are affected non-deterministically based on their execution timing relative to commit completion

The vulnerability is timing-dependent but inevitable given sufficient transaction volume, making it a deterministic eventual failure rather than a theoretical edge case.

## Recommendation

Implement version validation in the hot state read path to ensure values returned from hot state are not newer than the `base_version`. Options include:

1. **Snapshot Approach**: Make `get_committed()` return a true snapshot of `HotStateBase` rather than a shared Arc reference
2. **Version Validation**: Add version checking in `HotStateBase::get_state_slot()` to reject values where `value_version > max_allowed_version`
3. **Read Lock**: Implement a read-write lock that prevents hot state updates during active `CachedStateView` reads
4. **Version-Tagged Hot State**: Include version metadata with hot state Arc so readers can validate consistency

Example fix for option 2:

```rust
impl HotStateView for HotStateBase<StateKey, StateSlot> {
    fn get_state_slot(&self, state_key: &StateKey, max_version: Option<Version>) -> Option<StateSlot> {
        let shard_id = state_key.get_shard_id();
        self.get_from_shard(shard_id, state_key).and_then(|slot| {
            if let Some(max_ver) = max_version {
                if slot.expect_value_version() > max_ver {
                    return None; // Reject values from future versions
                }
            }
            Some(slot.clone())
        })
    }
}
```

## Proof of Concept

While a complete PoC would require significant test infrastructure setup, the vulnerability can be demonstrated through code analysis showing:

1. The `get_committed()` method returns Arc references that are shared across threads
2. The Committer thread modifies these shared structures without synchronization with readers
3. The `get_unmemorized()` method has no version validation for hot state reads
4. The `base_version()` used for cold reads can be stale relative to hot state contents

The race condition is inherent in the architecture and will manifest under normal high-throughput conditions where block execution and commit pipeline run concurrently.

## Notes

The vulnerability is particularly concerning because:
- It affects the core deterministic execution guarantee required for blockchain consensus
- It requires no attacker intervention - it's a natural consequence of the asynchronous architecture
- The temporal inconsistency violates the fundamental assumption that a state view represents a consistent snapshot at a specific version
- The shared Arc pattern in `get_committed()` creates a race condition window that cannot be prevented by the current architecture

### Citations

**File:** storage/storage-interface/src/state_store/state_view/cached_state_view.rs (L233-253)
```rust
    fn get_unmemorized(&self, state_key: &StateKey) -> Result<StateSlot> {
        COUNTER.inc_with(&["sv_unmemorized"]);

        let ret = if let Some(slot) = self.speculative.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_speculative"]);
            slot
        } else if let Some(slot) = self.hot.get_state_slot(state_key) {
            COUNTER.inc_with(&["sv_hit_hot"]);
            slot
        } else if let Some(base_version) = self.base_version() {
            COUNTER.inc_with(&["sv_cold"]);
            StateSlot::from_db_get(
                self.cold
                    .get_state_value_with_version_by_version(state_key, base_version)?,
            )
        } else {
            StateSlot::ColdVacant
        };

        Ok(ret)
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L100-105)
```rust
impl HotStateView for HotStateBase<StateKey, StateSlot> {
    fn get_state_slot(&self, state_key: &StateKey) -> Option<StateSlot> {
        let shard_id = state_key.get_shard_id();
        self.get_from_shard(shard_id, state_key).map(|v| v.clone())
    }
}
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L131-136)
```rust
    pub fn get_committed(&self) -> (Arc<dyn HotStateView>, State) {
        let state = self.committed.lock().clone();
        let base = self.base.clone();

        (base, state)
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L235-275)
```rust
    fn commit(&mut self, to_commit: &State) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["hot_state_commit"]);

        let mut n_insert = 0;
        let mut n_update = 0;
        let mut n_evict = 0;

        let delta = to_commit.make_delta(&self.committed.lock());
        for shard_id in 0..NUM_STATE_SHARDS {
            for (key, slot) in delta.shards[shard_id].iter() {
                if slot.is_hot() {
                    let key_size = key.size();
                    self.total_key_bytes += key_size;
                    self.total_value_bytes += slot.size();
                    if let Some(old_slot) = self.base.shards[shard_id].insert(key, slot) {
                        self.total_key_bytes -= key_size;
                        self.total_value_bytes -= old_slot.size();
                        n_update += 1;
                    } else {
                        n_insert += 1;
                    }
                } else if let Some((key, old_slot)) = self.base.shards[shard_id].remove(&key) {
                    self.total_key_bytes -= key.size();
                    self.total_value_bytes -= old_slot.size();
                    n_evict += 1;
                }
            }
            self.heads[shard_id] = to_commit.latest_hot_key(shard_id);
            self.tails[shard_id] = to_commit.oldest_hot_key(shard_id);
            assert_eq!(
                self.base.shards[shard_id].len(),
                to_commit.num_hot_items(shard_id)
            );

            debug_assert!(self.validate_lru(shard_id).is_ok());
        }

        COUNTER.inc_with_by(&["hot_state_insert"], n_insert);
        COUNTER.inc_with_by(&["hot_state_update"], n_update);
        COUNTER.inc_with_by(&["hot_state_evict"], n_evict);
    }
```

**File:** types/src/state_store/state_slot.rs (L24-40)
```rust
pub enum StateSlot {
    ColdVacant,
    HotVacant {
        hot_since_version: Version,
        lru_info: LRUEntry<StateKey>,
    },
    ColdOccupied {
        value_version: Version,
        value: StateValue,
    },
    HotOccupied {
        value_version: Version,
        value: StateValue,
        hot_since_version: Version,
        lru_info: LRUEntry<StateKey>,
    },
}
```
