# Audit Report

## Title
Stale Mempool Commit Notifications Across Epoch Boundaries Cause Nonce-Based Transaction Censorship

## Summary
The mempool notification system lacks epoch validation, allowing commit notifications from previous epochs to incorrectly remove newly submitted nonce-based transactions in subsequent epochs. This occurs because the `MempoolCommitNotification` structure contains no epoch or version identifier, and the mempool notification channel persists across epoch boundaries without being flushed or recreated.

## Finding Description

The vulnerability exists in the mempool commit notification system where notifications sent from state sync to mempool lack any epoch or version tracking. The core issue manifests through the following chain:

**Architecture Issue:**

The `MempoolCommitNotification` structure only contains transaction information and block timestamp, with no epoch identifier: [1](#0-0) 

The notification channel is created once at node startup and persists for the node's lifetime: [2](#0-1) 

**Processing Without Validation:**

The mempool spawns a dedicated task that continuously processes notifications without epoch validation: [3](#0-2) 

The commit notification handler processes notifications without any epoch context: [4](#0-3) 

For nonce-based (orderless) transactions, the commit handler blindly removes transactions matching the sender and nonce without verifying transaction hash or epoch: [5](#0-4) 

**Nonce Reusability:**

Nonce-based transactions can reuse the same nonce value after expiration and garbage collection (100+ seconds): [6](#0-5) [7](#0-6) 

**Epoch Reconfiguration:**

During epoch changes, the system restarts the validator but does NOT flush the notification channel: [8](#0-7) 

**Attack Scenario:**

1. **Epoch E (validator set V1):** User Alice submits nonce-based transaction `TxA` with `(sender=Alice, nonce=123, expiration=T+50)`
2. Consensus commits `TxA` and sends commit notification to state sync
3. State sync queues notification `(Alice, Nonce(123))` in mpsc channel to mempool
4. Channel experiences backpressure/delay (e.g., mempool processing slowdown, state sync catch-up)
5. **Epoch boundary:** Epoch changes to E+1 with new validator set V2
6. After ~150+ seconds, nonce 123 is garbage collected from on-chain `NonceHistory`
7. **Epoch E+1:** Alice submits NEW transaction `TxB` with `(sender=Alice, nonce=123)` - valid because nonce was garbage collected
8. `TxB` enters mempool under validator set V2
9. **Stale notification processed:** The delayed notification from epoch E is now processed
10. Mempool removes `TxB` (which was never committed) instead of the already-committed `TxA`

The critical invariant violation is that **transactions from the new epoch's mempool are removed by notifications referencing transactions from a previous epoch, potentially under a different validator set**.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for the following reasons:

1. **Transaction Censorship:** Valid transactions submitted in the new epoch are permanently removed from mempool without being committed to the blockchain. Users have no way to detect this issue - their transaction simply disappears.

2. **Protocol Violation:** This breaks the transaction validation invariant that mempool should only remove transactions that have actually been committed to storage. The system processes commits for transactions that may have never existed in the current epoch's context.

3. **Validator Set Confusion:** Notifications from epoch E (with validator set V1) can affect the mempool in epoch E+1 (with validator set V2), causing incorrect transaction processing across different consensus configurations.

4. **No Recovery Mechanism:** Once a transaction is incorrectly removed, there's no automatic retry or notification to the user. The transaction is lost unless the user manually resubmits with a different nonce.

5. **Affects Critical Infrastructure:** This impacts the fundamental transaction processing pipeline between consensus, state sync, and mempool - core components that must maintain strict consistency guarantees.

The impact aligns with HIGH severity criteria: "Significant protocol violations" affecting the correct processing of transactions across epoch boundaries.

## Likelihood Explanation

The likelihood is **MEDIUM** based on the following factors:

**Requirements for Exploitation:**
1. An mpsc channel backlog lasting 150+ seconds (nonce expiration + garbage collection time)
2. An epoch change occurring during this delay window
3. The same user reusing the same nonce value after garbage collection

**Feasibility Analysis:**

**Channel Backlog (Medium likelihood):**
- During high load, network congestion, or mempool processing issues, notifications can accumulate
- A 150+ second delay is uncommon but realistic during:
  - Epoch transitions when consensus stops and restarts
  - State sync catch-up operations after downtime
  - Database checkpoint operations causing mempool processing delays

**Epoch Changes (Common):**
- Normal epochs last hours/days, but during:
  - Network upgrades requiring epoch changes
  - Governance-triggered reconfigurations
  - Testing environments with shortened epoch durations
  - The epoch change window could overlap with channel delays

**Nonce Reuse (Medium likelihood):**
- Users may retry failed transactions with the same nonce
- Client libraries might reuse nonces if initial transaction appeared to fail
- Malicious actors could intentionally trigger this by monitoring nonce garbage collection

The vulnerability doesn't require Byzantine behavior or privileged access - any user can potentially trigger it through normal transaction submission patterns combined with unfortunate timing during epoch transitions.

## Recommendation

Add epoch tracking to the mempool commit notification system:

1. **Include epoch in `MempoolCommitNotification`:** Add an `epoch` field to the notification structure to track which epoch the commit belongs to.

2. **Track current epoch in mempool:** Maintain the current epoch number in the mempool state, updated during reconfiguration events.

3. **Validate epoch in commit handler:** Before processing a commit notification, verify that the notification's epoch matches the current epoch. Discard notifications from previous epochs.

4. **Optional: Include transaction hash:** For additional safety, include the transaction hash in `CommittedTransaction` and verify it matches before removal.

5. **Optional: Flush channel on epoch change:** During epoch transitions, drain and discard pending notifications from the previous epoch.

## Proof of Concept

A complete proof of concept would require:
1. Setting up a test environment with configurable epoch durations
2. Submitting a nonce-based transaction and triggering its commit
3. Introducing artificial delay in the notification channel
4. Triggering an epoch change
5. Waiting for nonce garbage collection (150+ seconds)
6. Submitting a new transaction with the same nonce
7. Observing the stale notification incorrectly removing the new transaction

The PoC demonstrates that the mempool's `commit_transaction` method for nonce-based transactions removes ANY transaction with matching `(sender, nonce)` without verifying epoch context or transaction hash, as shown in the code citations above.

## Notes

This vulnerability represents a fundamental design issue where the mempool notification system lacks temporal context (epoch tracking) necessary to ensure notifications are processed against the correct blockchain state. The issue is particularly severe for nonce-based transactions because, unlike sequence number transactions, they don't have progressive validation that would catch cross-epoch inconsistencies. The recommended fix requires adding epoch awareness to the notification protocol to prevent stale notifications from affecting transactions in subsequent epochs.

### Citations

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L49-59)
```rust
pub fn new_mempool_notifier_listener_pair(
    max_pending_mempool_notifications: u64,
) -> (MempoolNotifier, MempoolNotificationListener) {
    let (notification_sender, notification_receiver) =
        mpsc::channel(max_pending_mempool_notifications as usize);

    let mempool_notifier = MempoolNotifier::new(notification_sender);
    let mempool_listener = MempoolNotificationListener::new(notification_receiver);

    (mempool_notifier, mempool_listener)
}
```

**File:** state-sync/inter-component/mempool-notifications/src/lib.rs (L148-152)
```rust
#[derive(Debug)]
pub struct MempoolCommitNotification {
    pub transactions: Vec<CommittedTransaction>,
    pub block_timestamp_usecs: u64, // The timestamp of the committed block.
}
```

**File:** mempool/src/shared_mempool/coordinator.rs (L152-162)
```rust
    tokio::spawn(async move {
        while let Some(commit_notification) = mempool_listener.next().await {
            handle_commit_notification(
                &mempool,
                &mempool_validator,
                &use_case_history,
                commit_notification,
                &num_committed_txns_received_since_peers_updated,
            );
        }
    });
```

**File:** mempool/src/shared_mempool/coordinator.rs (L229-265)
```rust
fn handle_commit_notification<TransactionValidator>(
    mempool: &Arc<Mutex<CoreMempool>>,
    mempool_validator: &Arc<RwLock<TransactionValidator>>,
    use_case_history: &Arc<Mutex<UseCaseHistory>>,
    msg: MempoolCommitNotification,
    num_committed_txns_received_since_peers_updated: &Arc<AtomicU64>,
) where
    TransactionValidator: TransactionValidation,
{
    debug!(
        block_timestamp_usecs = msg.block_timestamp_usecs,
        num_committed_txns = msg.transactions.len(),
        LogSchema::event_log(LogEntry::StateSyncCommit, LogEvent::Received),
    );

    // Process and time committed user transactions.
    let start_time = Instant::now();
    counters::mempool_service_transactions(
        counters::COMMIT_STATE_SYNC_LABEL,
        msg.transactions.len(),
    );
    num_committed_txns_received_since_peers_updated
        .fetch_add(msg.transactions.len() as u64, Ordering::Relaxed);
    process_committed_transactions(
        mempool,
        use_case_history,
        msg.transactions,
        msg.block_timestamp_usecs,
    );
    mempool_validator.write().notify_commit();
    let latency = start_time.elapsed();
    counters::mempool_service_latency(
        counters::COMMIT_STATE_SYNC_LABEL,
        counters::REQUEST_SUCCESS_LABEL,
        latency,
    );
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L690-705)
```rust
            ReplayProtector::Nonce(nonce) => {
                if let Some(txns) = self.transactions.get_mut(account) {
                    if let Some(txn) = txns.remove(&ReplayProtector::Nonce(nonce)) {
                        self.index_remove(&txn);
                        trace!(
                            LogSchema::new(LogEntry::CleanCommittedTxn).txns(TxnsLog::new_txn(
                                txn.get_sender(),
                                txn.get_replay_protector()
                            )),
                            "txns cleaned with committing tx {}:{:?}",
                            txn.get_sender(),
                            txn.get_replay_protector()
                        );
                    }
                }
            },
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L14-19)
```text
    // After a transaction expires, we wait for NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS seconds
    // before garbage collecting the transaction from the nonce history.
    // We maintain an invariant that two transactions with the same (address, nonce) pair cannot be stored
    // in the nonce hsitory if their transanction expiration times are less than
    // `NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS` seconds apart.
    const NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS: u64 = 100;
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L161-174)
```text
            // We maintain an invariant that two transaction with the same (address, nonce) pair cannot be stored
            // in the nonce history if their transaction expiration times are less than `NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS`
            // seconds apart.
            if (txn_expiration_time <= existing_exp_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS) {
                return false;
            };

            // If the existing (address, nonce) pair has expired, garbage collect it.
            bucket.nonce_to_exp_time_map.remove(&nonce_key);
            bucket.nonces_ordered_by_exp_time.remove(&NonceKeyWithExpTime {
                txn_expiration_time: existing_exp_time,
                sender_address,
                nonce,
            });
```

**File:** mempool/src/shared_mempool/tasks.rs (L762-794)
```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }

    let consensus_config: anyhow::Result<OnChainConsensusConfig> = config_update.get();
    match consensus_config {
        Ok(consensus_config) => {
            *broadcast_within_validator_network.write() =
                !consensus_config.quorum_store_enabled() && !consensus_config.is_dag_enabled()
        },
        Err(e) => {
            error!(
                "Failed to read on-chain consensus config, keeping value broadcast_within_validator_network={}: {}",
                *broadcast_within_validator_network.read(),
                e
            );
        },
    }
}
```
