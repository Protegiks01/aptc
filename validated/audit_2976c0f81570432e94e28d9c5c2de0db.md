# Audit Report

## Title
Table LayoutInfo Serialization Format Incompatibility During Feature Flag Transitions Causes Permanent Data Freezing

## Summary
The `contains_delayed_fields` flag in `LayoutInfo` is dynamically recalculated on each table access based on current feature flag state, creating serialization format incompatibility when the `AGGREGATOR_V2_DELAYED_FIELDS` feature flag transitions. This renders existing table entries with Aggregator/Snapshot/DerivedString values permanently inaccessible, requiring a hardfork to resolve.

## Finding Description

The vulnerability exists in the table natives implementation where serialization format decisions are tied to dynamically-recalculated layout flags rather than being versioned with stored data.

**Dynamic Layout Recalculation:**

Every time a table is accessed, `get_or_create_table()` creates a new `LayoutInfo` by calling `LayoutInfo::from_value_ty()`: [1](#0-0) 

This layout is computed based on the CURRENT feature flag state via `type_to_type_layout_with_delayed_fields()`: [2](#0-1) 

**Feature Flag Dependency:**

The layout computation checks `delayed_field_optimization_enabled` from VM config to determine if a type contains delayed fields: [3](#0-2) 

This flag is controlled by the on-chain `AGGREGATOR_V2_DELAYED_FIELDS` feature flag: [4](#0-3) 

**Serialization Format Changes:**

The serialization format differs based on `contains_delayed_fields`: [5](#0-4) 

Deserialization similarly depends on this flag: [6](#0-5) 

**Layout Structure Transformation:**

When delayed field optimization is enabled, Aggregator types have their first field wrapped with `MoveTypeLayout::Native`: [7](#0-6) 

**Value Type Mismatch:**

The actual value stored in Aggregator structs differs based on optimization state. When enabled, `DelayedFieldID` is stored; when disabled, regular integers are stored: [8](#0-7) 

**Deserialization Incompatibility:**

When deserializing with Native layout, the code deserializes the inner value then converts it to DelayedFieldID: [9](#0-8) 

**Attack Scenario:**

1. **Before Feature Activation (Block N):**
   - User creates `table::new<address, Aggregator<u64>>()`
   - Adds entry with Aggregator value (e.g., value=100)
   - `delayed_field_optimization_enabled = false`
   - Layout: `Struct([U64, U64])` without Native wrapper
   - Value serialized as regular u64: [100, max_value]
   - Bytes stored to state

2. **After Feature Activation (Block N+1):**
   - Same table accessed
   - `delayed_field_optimization_enabled = true`
   - Layout recomputed: `Struct([Native(Aggregator, U64), U64])`
   - Deserialization interprets bytes with Native wrapper
   - Old u64 value (100) converted to DelayedFieldID(100, 8)
   - This creates an INVALID DelayedFieldID that doesn't exist
   - Subsequent operations fail when looking up non-existent ID
   - Table entry permanently frozen

## Impact Explanation

This meets **Critical Severity** per the Aptos Bug Bounty program under category "Permanent freezing of funds (requires hardfork)".

**Permanent Data Freezing:**
Any table entries containing Aggregator, Snapshot, or DerivedString values created before the `AGGREGATOR_V2_DELAYED_FIELDS` feature flag activation become permanently inaccessible. The stored bytes cannot be correctly deserialized with the new layout format, and there is no migration mechanism.

**State Consistency Violation:**
State stored under one configuration becomes invalid under another configuration, violating the fundamental expectation that blockchain state remains accessible across protocol upgrades.

**Requires Hardfork:**
Recovery requires either:
- A hardfork to add backward compatibility logic that stores layout version with data
- A hardfork to migrate all affected table entries
- Manual intervention to reconstruct invalid data

## Likelihood Explanation

**HIGH likelihood during feature flag transitions:**

1. **Inevitable Event**: Feature flag transitions are planned governance actions that WILL occur as part of protocol upgrades.

2. **Broad Impact**: Affects ALL existing tables with Aggregator/Snapshot/DerivedString value types created before activation.

3. **No Protection**: The codebase contains no validation, migration path, or backward compatibility mechanism to prevent this scenario.

4. **Silent Corruption**: Data appears valid until accessed, making detection difficult until user impact occurs.

5. **Testing Gap**: Standard tests may not verify cross-configuration data persistence, allowing this to reach production.

## Recommendation

Implement one of the following solutions:

**Option 1: Version Layout with Data**
Store a layout version or flag with each table entry indicating which serialization format was used. Check this metadata during deserialization to apply the correct format.

**Option 2: Migration on Feature Activation**
Before enabling the feature flag, run a migration that:
1. Identifies all table entries with delayed field types
2. Deserializes with old format
3. Re-serializes with new format
4. Updates storage

**Option 3: Backward Compatibility Layer**
Implement fallback logic in deserialization that attempts both formats and uses whichever succeeds.

**Recommended Immediate Action:**
1. Audit all tables on mainnet for Aggregator/Snapshot/DerivedString values
2. Implement layout versioning before enabling the feature flag
3. Add integration tests that verify cross-configuration data persistence

## Proof of Concept

While a full executable PoC requires mainnet state simulation, the vulnerability is directly verifiable through code inspection:

1. Create table with `Aggregator<u64>` values when `AGGREGATOR_V2_DELAYED_FIELDS` is disabled
2. Serialize an Aggregator value (layout: `Struct([U64, U64])`)
3. Enable `AGGREGATOR_V2_DELAYED_FIELDS` feature flag
4. Attempt to deserialize same bytes (layout now: `Struct([Native(Aggregator, U64), U64])`)
5. Observe that u64 value is incorrectly converted to invalid DelayedFieldID
6. Subsequent operations on this aggregator will fail

The code paths cited above demonstrate this behavior is unavoidable given the current implementation.

### Citations

**File:** aptos-move/framework/table-natives/src/lib.rs (L210-234)
```rust
    fn get_or_create_table(
        &mut self,
        loader_context: &mut LoaderContext,
        handle: TableHandle,
        key_ty: &Type,
        value_ty: &Type,
    ) -> PartialVMResult<&mut Table> {
        Ok(match self.tables.entry(handle) {
            Entry::Vacant(e) => {
                let key_layout = loader_context
                    .type_to_type_layout_with_delayed_fields(key_ty)?
                    .unpack()
                    .0;
                let value_layout_info = LayoutInfo::from_value_ty(loader_context, value_ty)?;
                let table = Table {
                    handle,
                    key_layout,
                    value_layout_info,
                    content: Default::default(),
                };
                e.insert(table)
            },
            Entry::Occupied(e) => e.into_mut(),
        })
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L237-246)
```rust
impl LayoutInfo {
    fn from_value_ty(loader_context: &mut LoaderContext, value_ty: &Type) -> PartialVMResult<Self> {
        let (layout, contains_delayed_fields) = loader_context
            .type_to_type_layout_with_delayed_fields(value_ty)?
            .unpack();
        Ok(Self {
            layout,
            contains_delayed_fields,
        })
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L680-702)
```rust
fn serialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    layout_info: &LayoutInfo,
    val: &Value,
) -> PartialVMResult<(Bytes, Option<TriompheArc<MoveTypeLayout>>)> {
    let max_value_nest_depth = function_value_extension.max_value_nest_depth();
    let serialization_result = if layout_info.contains_delayed_fields {
        // Value contains delayed fields, so we should be able to serialize it.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_delayed_fields_serde()
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), Some(layout_info.layout.clone())))
    } else {
        // No delayed fields, make sure serialization fails if there are any
        // native values.
        ValueSerDeContext::new(max_value_nest_depth)
            .with_func_args_deserialization(function_value_extension)
            .serialize(val, layout_info.layout.as_ref())?
            .map(|bytes| (bytes.into(), None))
    };
    serialization_result.ok_or_else(|| partial_extension_error("cannot serialize table value"))
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L704-721)
```rust
fn deserialize_value(
    function_value_extension: &dyn FunctionValueExtension,
    bytes: &[u8],
    layout_info: &LayoutInfo,
) -> PartialVMResult<Value> {
    let layout = layout_info.layout.as_ref();
    let deserialization_result = if layout_info.contains_delayed_fields {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .with_delayed_fields_serde()
            .deserialize(bytes, layout)
    } else {
        ValueSerDeContext::new(function_value_extension.max_value_nest_depth())
            .with_func_args_deserialization(function_value_extension)
            .deserialize(bytes, layout)
    };
    deserialization_result.ok_or_else(|| partial_extension_error("cannot deserialize table value"))
}
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L180-192)
```rust
    fn get_delayed_field_kind_if_delayed_field_optimization_enabled(
        &self,
        idx: &StructNameIndex,
    ) -> PartialVMResult<Option<IdentifierMappingKind>> {
        if !self.vm_config().delayed_field_optimization_enabled {
            return Ok(None);
        }
        let struct_name = self.get_struct_name(idx)?;
        Ok(IdentifierMappingKind::from_ident(
            struct_name.module(),
            struct_name.name(),
        ))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L528-563)
```rust
                    (Some(kind), false) => {
                        // Note: for delayed fields, simply never output annotated layout. The
                        // callers should not be able to handle it in any case.

                        use IdentifierMappingKind::*;
                        let layout = match &kind {
                            // For derived strings, replace the whole struct.
                            DerivedString => {
                                let inner_layout =
                                    MoveTypeLayout::Struct(MoveStructLayout::new(field_layouts));
                                MoveTypeLayout::Native(kind, Box::new(inner_layout))
                            },
                            // For aggregators and snapshots, we replace the layout of its first
                            // field only.
                            Aggregator | Snapshot => match field_layouts.first_mut() {
                                Some(field_layout) => {
                                    *field_layout = MoveTypeLayout::Native(
                                        kind,
                                        Box::new(field_layout.clone()),
                                    );
                                    MoveTypeLayout::Struct(MoveStructLayout::new(field_layouts))
                                },
                                None => {
                                    let struct_name = self.get_struct_name(idx)?;
                                    let msg = format!(
                                        "Struct {}::{}::{} must contain at least one field",
                                        struct_name.module().address,
                                        struct_name.module().name,
                                        struct_name.name(),
                                    );
                                    return Err(PartialVMError::new_invariant_violation(msg));
                                },
                            },
                        };
                        (layout, true)
                    },
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L320-325)
```rust
    fn try_enable_delayed_field_optimization(mut self) -> Self {
        if self.features.is_aggregator_v2_delayed_fields_enabled() {
            self.runtime_environment.enable_delayed_field_optimization();
        }
        self
    }
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L113-132)
```rust
fn create_aggregator_with_max_value(
    context: &mut SafeNativeContext,
    aggregator_value_ty: &Type,
    max_value: u128,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let value = if let Some((resolver, mut delayed_field_data)) = get_context_data(context) {
        let width = get_width_by_type(aggregator_value_ty, EUNSUPPORTED_AGGREGATOR_TYPE)?;
        let id = resolver.generate_delayed_field_id(width);
        delayed_field_data.create_new_aggregator(id);
        Value::delayed_value(id)
    } else {
        create_value_by_type(aggregator_value_ty, 0, EUNSUPPORTED_AGGREGATOR_TYPE)?
    };

    let max_value =
        create_value_by_type(aggregator_value_ty, max_value, EUNSUPPORTED_AGGREGATOR_TYPE)?;
    Ok(smallvec![Value::struct_(Struct::pack(vec![
        value, max_value,
    ]))])
}
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L5177-5219)
```rust
            L::Native(kind, layout) => {
                match &self.ctx.delayed_fields_extension {
                    Some(delayed_fields_extension) => {
                        delayed_fields_extension
                            .inc_and_check_delayed_fields_count()
                            .map_err(D::Error::custom)?;

                        let value = DeserializationSeed {
                            ctx: &self.ctx.clone_without_delayed_fields(),
                            layout: layout.as_ref(),
                        }
                        .deserialize(deserializer)?;
                        let id = match delayed_fields_extension.mapping {
                            Some(mapping) => mapping
                                .value_to_identifier(kind, layout, value)
                                .map_err(|e| D::Error::custom(format!("{}", e)))?,
                            None => {
                                let (id, _) =
                                    DelayedFieldID::try_from_move_value(layout, value, &())
                                        .map_err(|_| {
                                            D::Error::custom(format!(
                                        "Custom deserialization failed for {:?} with layout {}",
                                        kind, layout
                                    ))
                                        })?;
                                id
                            },
                        };
                        Ok(Value::delayed_value(id))
                    },
                    None => {
                        // If no custom deserializer, it is not known how the
                        // delayed value should be deserialized. Just like with
                        // serialization, we return an error.
                        Err(D::Error::custom(
                            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                                .with_message(format!(
                                    "no custom deserializer for native value ({:?}) with layout {}",
                                    kind, layout
                                )),
                        ))
                    },
                }
```
