# Audit Report

## Title
Non-Atomic Version Reads in OldSyncRequest Validation Cause Incorrect Error Classification and Consensus Sync Failures

## Summary
The state-sync driver validates consensus sync target requests by performing two separate, non-atomic storage reads to fetch pre-committed and committed versions. Due to separate locks that explicitly allow concurrent pre-commit and commit operations, these reads can observe inconsistent state where `committed_version > pre_committed_version`, violating storage invariants. This causes incorrect OldSyncRequest error responses to consensus, leading to validator panics at epoch transitions.

## Finding Description

The consensus sync target validation performs two separate storage reads that are not protected by a common lock. When `handle_consensus_sync_target_notification` is invoked, it fetches the pre-committed version and synced ledger info through separate function calls: [1](#0-0) 

These reads access different storage locations with separate locking mechanisms:

1. **Pre-committed version** is read from the state store's current state: [2](#0-1) 

2. **Committed version** is read from the ledger metadata database: [3](#0-2) 

The storage system uses **two separate locks** that explicitly allow concurrent pre-commit and commit operations: [4](#0-3) [5](#0-4) 

The comments explicitly confirm this concurrent design: [6](#0-5) [7](#0-6) 

**Storage Invariant**: The storage system enforces that `pre_committed_version >= committed_version`: [8](#0-7) 

**Race Condition Scenario**:
1. Thread A (sync handler) reads `pre_committed_version = 100`
2. Thread B executes `pre_commit_ledger()`, advancing state_store to version 110
3. Thread B executes `commit_ledger()`, advancing metadata_db to version 110
4. Thread A reads `committed_version = 110`
5. Thread A observes impossible state: `(pre_committed=100, committed=110)`

The validation logic then incorrectly evaluates this inconsistent state: [9](#0-8) 

This returns an OldSyncRequest error that propagates back to consensus.

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria (Validator Node Slowdowns/Crashes - up to $50,000):

1. **Validator Panics at Epoch Transitions**: When consensus receives the incorrect OldSyncRequest error during epoch transitions, the validator panics: [10](#0-9) 

The `.expect("Failed to sync to new epoch")` causes immediate validator termination, disrupting network consensus participation.

2. **Consensus Coordination Failures**: The incorrect error response breaks the consensus/state-sync handover protocol. State-sync signals that a valid sync target is "old", causing:
   - Failed epoch transitions
   - Validators falling behind the network
   - Disruption of consensus participation during critical epoch changes

3. **Observable Storage Invariant Violations**: The error message exposes impossible state where committed > pre_committed: [11](#0-10) 

This error message would display something like "Received an old sync request for version 105, but our pre-committed version is: 100 and committed version: 110", exposing the invariant violation.

## Likelihood Explanation

**HIGH Likelihood**: This race condition occurs naturally during normal validator operations:

- **No attacker required**: The race happens between legitimate concurrent operations (commits and sync request handling)
- **Common during normal operation**: Consensus frequently commits new blocks while state-sync processes sync requests
- **Wide race window**: The window exists between the two storage reads in `handle_consensus_sync_target_notification`, spanning multiple function calls
- **High throughput amplifies risk**: More frequent commits increase the probability of observing inconsistent state
- **Critical during epoch transitions**: Sync-to-target operations are essential during epoch changes, when this bug causes validator panics

The separate lock design explicitly enables concurrent pre-commit and commit operations, making this race condition an inherent property of the current architecture rather than a rare edge case.

## Recommendation

Implement atomic reads for version consistency checks by:

1. **Add a read lock or snapshot mechanism** that ensures both `pre_committed_version` and `committed_version` are read atomically from a consistent storage state
2. **Reorder validation logic** to handle cases where the node has already committed beyond the sync target (which should return success, not an error)
3. **Add retry logic** in `handle_consensus_sync_target_notification` to re-fetch versions if an invariant violation is detected

Example fix pseudocode:
```rust
// Add a method to storage that returns both versions atomically
let (latest_pre_committed_version, latest_committed_version) = 
    self.storage.get_versions_snapshot()?;

// Or add validation to detect and handle race condition
if latest_committed_version > latest_pre_committed_version {
    // Race detected - retry the read
    continue;
}
```

## Proof of Concept

The vulnerability can be triggered during normal validator operations, particularly during epoch transitions when:
1. High transaction throughput causes frequent `pre_commit_ledger` and `commit_ledger` calls
2. Consensus sends a `sync_to_target` request for epoch transition
3. The sync handler reads versions during the race window between separate locks

A reproduction would require:
1. Setting up a validator node under load
2. Triggering an epoch transition
3. Observing the validator panic with "Failed to sync to new epoch" when the race condition occurs
4. Examining logs to confirm the OldSyncRequest error with `committed > pre_committed`

The race window is inherent to the architecture where state-sync reads are not atomic with respect to concurrent commits, making this a reliability issue that will manifest in production environments.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L413-416)
```rust
        let latest_pre_committed_version =
            utils::fetch_pre_committed_version(self.storage.clone())?;
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L125-129)
```rust
    fn get_latest_ledger_info_option(&self) -> Result<Option<LedgerInfoWithSignatures>> {
        gauged_api("get_latest_ledger_info_option", || {
            Ok(self.ledger_db.metadata_db().get_latest_ledger_info_option())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L46-49)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L50-53)
```rust
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L85-88)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L89-92)
```rust
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L531-536)
```rust
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L276-286)
```rust
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }
```

**File:** consensus/src/epoch_manager.rs (L558-565)
```rust
        self.execution_client
            .sync_to_target(ledger_info.clone())
            .await
            .context(format!(
                "[EpochManager] State sync to new epoch {}",
                ledger_info
            ))
            .expect("Failed to sync to new epoch");
```

**File:** state-sync/state-sync-driver/src/error.rs (L39-40)
```rust
    #[error("Received an old sync request for version {0}, but our pre-committed version is: {1} and committed version: {2}")]
    OldSyncRequest(Version, Version, Version),
```
