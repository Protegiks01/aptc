# Audit Report

## Title
Aggregator V1 Validation Errors Incorrectly Classified as User Aborts Instead of Speculative Execution Errors

## Summary
During parallel execution in BlockSTM, the `abort_error()` function incorrectly converts aggregator validation failures (`Overflow`/`Underflow`) to `ABORTED` status instead of `SPECULATIVE_EXECUTION_ABORT_ERROR`. This prevents transaction retry when speculative reads become stale, causing legitimate transactions to fail permanently instead of being retried with fresh data.

## Finding Description

The vulnerability exists in the error handling logic for Aggregator V1 delta validation. During parallel execution, transactions read aggregator values speculatively. When the base value changes before validation completes, the delta history becomes incompatible with the new base value, requiring transaction re-execution.

**Location 1: Aggregator Read Validation**

The `validate_history()` function explicitly converts `Overflow` and `Underflow` errors to `ABORTED` status via `abort_error()`: [1](#0-0) 

The `abort_error()` helper function creates `StatusCode::ABORTED`: [2](#0-1) 

**Location 2: Delta Materialization**

The `try_convert_aggregator_v1_delta_into_write_op()` function applies the same incorrect conversion, with a misleading comment claiming "aggregator V1 never underflows or overflows": [3](#0-2) 

**The Core Issue: Inconsistent Error Handling**

The delta validation in `validate_against_base_value()` returns four error types to indicate stale speculative reads: [4](#0-3) 

However, these errors are handled inconsistently:
- `Overflow`/`Underflow` → Explicitly converted to `ABORTED` (lines 112, 118 in `aggregator_v1_extension.rs`)
- `ExpectedOverflow`/`ExpectedUnderflow` → Fall through to line 120, propagate as `DelayedFieldsSpeculativeError`

When `DelayedFieldsSpeculativeError` propagates naturally, it correctly converts to `SPECULATIVE_EXECUTION_ABORT_ERROR`: [5](#0-4) 

**VM Wrapper Behavior**

The VM wrapper only triggers retry for `SPECULATIVE_EXECUTION_ABORT_ERROR`: [6](#0-5) 

When `ABORTED` is returned, the transaction proceeds to the `Success` path and is committed as failed.

**Affected Operations**

Aggregator V1 is used for coin supply tracking. All mint/burn operations update supply counters via aggregators: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This vulnerability causes **Limited Protocol Violations** qualifying as Medium severity per the Aptos bug bounty program:

1. **State Inconsistency**: Transactions that should succeed after retry are permanently marked as `ABORTED`, creating semantic incorrectness in transaction results.

2. **Spurious Transaction Failures**: During high throughput on popular coins (AptosCoin, stablecoins), legitimate mint/burn operations fail incorrectly when aggregator base values change during parallel execution.

3. **User Experience Degradation**: Applications expecting eventual success receive permanent failures for operations that should have succeeded after retry with fresh data.

**Important Limitations**:
- Does NOT cause consensus divergence (all validators execute deterministically)
- Does NOT enable fund theft or unauthorized minting
- Does NOT cause network partition or liveness failures
- Impact is limited to incorrect transaction outcomes requiring manual retry

## Likelihood Explanation

**Likelihood: Medium-High**

This condition occurs naturally during normal network operation:

1. **Triggering Conditions**:
   - High transaction throughput on popular coins
   - Parallel execution of multiple mint/burn operations  
   - Any scenario where aggregator base values change between speculative read and validation

2. **No Attacker Required**: The vulnerability triggers during legitimate high-load scenarios without malicious coordination.

3. **Probability Increases with Load**: Higher transaction volume directly increases the probability of stale reads causing validation failures with incorrect error codes.

4. **Realistic Scenarios**:
   - Peak trading periods for stablecoins
   - Mass staking reward distributions
   - High-frequency DeFi operations updating coin supplies

## Recommendation

Convert `Overflow` and `Underflow` delta validation errors to `SPECULATIVE_EXECUTION_ABORT_ERROR` to match the handling of `ExpectedOverflow` and `ExpectedUnderflow`:

```rust
// In aggregator_v1_extension.rs, validate_history()
if let Err(e) = history.validate_against_base_value(base_value, self.max_value) {
    // All delta validation failures indicate stale speculative reads
    // and should trigger retry, not user-level aborts
    return Err(e.into()); // Let the natural conversion to SPECULATIVE_EXECUTION_ABORT_ERROR occur
}
```

Similarly in `resolver.rs`:

```rust
// In try_convert_aggregator_v1_delta_into_write_op()
delta_op.apply_to(base)
    .map_err(|e| e.into()) // Remove special handling for Overflow/Underflow
    .map(|result| WriteOp::legacy_modification(serialize(&result).into()))
```

Remove the comment claiming "aggregator V1 never underflows or overflows" as it's incorrect during parallel execution with stale reads.

## Proof of Concept

While a full executable PoC requires setting up parallel execution infrastructure, the code path is demonstrable:

```move
// Scenario: Two transactions updating AptosCoin supply in parallel
// Transaction A: Reads aggregator speculatively with base_value=1000
//                Records delta history: added +500
// Transaction B: Commits, changing base_value to 100
// Transaction A: Re-executes, validate_history(100) is called
//                History shows +500 was achieved, but 100+500 may violate bounds
//                Returns Overflow error → converted to ABORTED
//                Transaction permanently fails instead of retrying
```

The execution flow through the cited code locations confirms:
1. Native read triggers validation with changed base value
2. Validation fails with Overflow/Underflow  
3. Error converted to ABORTED instead of SPECULATIVE_EXECUTION_ABORT_ERROR
4. VM wrapper commits transaction as failed instead of retrying

### Citations

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L96-125)
```rust
    fn validate_history(&self, base_value: u128) -> PartialVMResult<()> {
        let history = self
            .history
            .as_ref()
            .expect("History should be set for validation");

        // To validate the history of an aggregator, we want to ensure
        // that there was no violation of postcondition (i.e. overflows or
        // underflows). We can do it by emulating addition and subtraction.

        if let Err(e) = history.validate_against_base_value(base_value, self.max_value) {
            match e {
                DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Overflow,
                    ..
                } => {
                    return Err(abort_error("overflow", EADD_OVERFLOW));
                },
                DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Underflow,
                    ..
                } => {
                    return Err(abort_error("underflow", ESUB_UNDERFLOW));
                },
                _ => Err(e)?,
            }
        }

        Ok(())
    }
```

**File:** aptos-move/aptos-aggregator/src/aggregator_v1_extension.rs (L373-377)
```rust
fn abort_error(message: impl ToString, code: u64) -> PartialVMError {
    PartialVMError::new(StatusCode::ABORTED)
        .with_message(message.to_string())
        .with_sub_status(code)
}
```

**File:** aptos-move/aptos-aggregator/src/resolver.rs (L80-106)
```rust
    fn try_convert_aggregator_v1_delta_into_write_op(
        &self,
        id: &Self::Identifier,
        delta_op: &DeltaOp,
    ) -> PartialVMResult<WriteOp> {
        let base = self.get_aggregator_v1_value(id)?.ok_or_else(|| {
            PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                .with_message("Cannot convert delta for deleted aggregator".to_string())
        })?;
        delta_op
            .apply_to(base)
            .map_err(|e| match &e {
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Overflow,
                    ..
                }) => addition_v1_error(e),
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Underflow,
                    ..
                }) => subtraction_v1_error(e),
                // Because aggregator V1 never underflows or overflows, all other
                // application errors are bugs.
                _ => code_invariant_error(format!("Unexpected delta application error: {:?}", e))
                    .into(),
            })
            .map(|result| WriteOp::legacy_modification(serialize(&result).into()))
    }
```

**File:** aptos-move/aptos-aggregator/src/delta_math.rs (L148-197)
```rust
    pub fn validate_against_base_value(
        &self,
        base_value: u128,
        max_value: u128,
    ) -> Result<(), DelayedFieldsSpeculativeError> {
        let math = BoundedMath::new(max_value);
        // We need to make sure the following 4 conditions are satisified.
        //     base_value + max_achieved_positive_delta <= self.max_value
        //     base_value >= min_achieved_negative_delta
        //     base_value + min_overflow_positive_delta > self.max_value
        //     base_value < max_underflow_negative_delta
        math.unsigned_add(base_value, self.max_achieved_positive_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Positive(self.max_achieved_positive_delta),
                reason: DeltaApplicationFailureReason::Overflow,
            })?;
        math.unsigned_subtract(base_value, self.min_achieved_negative_delta)
            .map_err(|_e| DelayedFieldsSpeculativeError::DeltaApplication {
                base_value,
                max_value,
                delta: SignedU128::Negative(self.min_achieved_negative_delta),
                reason: DeltaApplicationFailureReason::Underflow,
            })?;

        if let Some(min_overflow_positive_delta) = self.min_overflow_positive_delta {
            if base_value <= max_value - min_overflow_positive_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Positive(min_overflow_positive_delta),
                    reason: DeltaApplicationFailureReason::ExpectedOverflow,
                });
            }
        }

        if let Some(max_underflow_negative_delta) = self.max_underflow_negative_delta {
            if base_value >= max_underflow_negative_delta {
                return Err(DelayedFieldsSpeculativeError::DeltaApplication {
                    base_value,
                    max_value,
                    delta: SignedU128::Negative(max_underflow_negative_delta),
                    reason: DeltaApplicationFailureReason::ExpectedUnderflow,
                });
            }
        }

        Ok(())
    }
```

**File:** types/src/error.rs (L90-100)
```rust
impl<T: std::fmt::Debug> From<PanicOr<T>> for PartialVMError {
    fn from(err: PanicOr<T>) -> Self {
        match err {
            PanicOr::CodeInvariantError(msg) => {
                PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
                    .with_message(msg)
            },
            PanicOr::Or(err) => PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                .with_message(format!("{:?}", err)),
        }
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L68-97)
```rust
            Ok((vm_status, vm_output)) => {
                if vm_output.status().is_discarded() {
                    speculative_trace!(
                        &log_context,
                        format!("Transaction discarded, status: {:?}", vm_status),
                    );
                }
                if vm_status.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        vm_status.message().cloned().unwrap_or_default(),
                    )
                } else if vm_status.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        vm_status.message().cloned().unwrap_or_default(),
                    )
                } else if AptosVM::should_restart_execution(vm_output.events()) {
                    speculative_info!(
                        &log_context,
                        "Reconfiguration occurred: restart required".into()
                    );
                    ExecutionStatus::SkipRest(AptosTransactionOutput::new(vm_output))
                } else {
                    assert!(
                        Self::is_transaction_dynamic_change_set_capable(txn),
                        "DirectWriteSet should always create SkipRest transaction, validate_waypoint_change_set provides this guarantee"
                    );
                    ExecutionStatus::Success(AptosTransactionOutput::new(vm_output))
                }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1193-1226)
```text
    fun mint_internal<CoinType>(amount: u64): Coin<CoinType> acquires CoinInfo {
        if (amount == 0) {
            return Coin<CoinType> { value: 0 }
        };

        let maybe_supply =
            &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;
        if (option::is_some(maybe_supply)) {
            let supply = option::borrow_mut(maybe_supply);
            spec {
                use aptos_framework::optional_aggregator;
                use aptos_framework::aggregator;
                assume optional_aggregator::is_parallelizable(supply) ==>
                    (
                        aggregator::spec_aggregator_get_val(
                            option::borrow(supply.aggregator)
                        ) + amount
                            <= aggregator::spec_get_limit(
                                option::borrow(supply.aggregator)
                            )
                    );
                assume !optional_aggregator::is_parallelizable(supply) ==>
                    (
                        option::borrow(supply.integer).value + amount
                            <= option::borrow(supply.integer).limit
                    );
            };
            optional_aggregator::add(supply, (amount as u128));
        };
        spec {
            update supply<CoinType> = supply<CoinType> + amount;
        };
        Coin<CoinType> { value: amount }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1228-1242)
```text
    fun burn_internal<CoinType>(coin: Coin<CoinType>): u64 acquires CoinInfo {
        spec {
            update supply<CoinType> = supply<CoinType> - coin.value;
        };
        let Coin { value: amount } = coin;
        if (amount != 0) {
            let maybe_supply =
                &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;
            if (option::is_some(maybe_supply)) {
                let supply = option::borrow_mut(maybe_supply);
                optional_aggregator::sub(supply, (amount as u128));
            };
        };
        amount
    }
```
