# Audit Report

## Title
Byzantine Validators Can Prevent Randomness Aggregation Due to Incorrect Weight Threshold Calculation

## Summary
The DKG rounding algorithm incorrectly uses the secrecy threshold parameter (0.5) instead of the reconstruction threshold parameter (2/3) when calculating the weight-based reconstruction threshold. When combined with an unsafe capping operation and insufficient validation, this can produce a configuration requiring 100% validator participation, allowing Byzantine validators controlling less than 1/3 of stake to prevent randomness aggregation by withholding shares.

## Finding Description

The vulnerability exists in the weight threshold calculation logic within the DKG (Distributed Key Generation) rounding system that converts validator stakes to discrete weights for the on-chain randomness beacon.

**Root Cause**: The `compute_profile_fixed_point()` function calculates the reconstruction threshold using the wrong threshold parameter: [1](#0-0) 

The formula uses `secrecy_threshold_in_stake_ratio` (default 0.5) instead of a value derived from `reconstruct_threshold_in_stake_ratio` (default 2/3). This value is then capped at `weight_total`, which can result in requiring 100% validator participation.

**Validation Gap**: The `is_valid_profile()` function only validates that the calculated stake ratio doesn't exceed the target reconstruction threshold, but fails to verify that the actual weight threshold allows reconstruction by validators with that stake ratio: [2](#0-1) 

**Attack Execution Path**:

1. During epoch initialization, `DKGRounding::new()` is called to calculate validator weights: [3](#0-2) 

2. When the validator set has stakes distributed such that `weight_total ≈ num_validators` and rounding errors accumulate (delta_up approaches 0.5 × weight_total), the formula produces: `threshold ≈ ceil(0.5 × weight_total + delta_up) + 1 ≥ weight_total`

3. The capping operation sets `reconstruct_threshold_in_weights = weight_total`, requiring unanimous participation.

4. This misconfigured threshold is embedded into `RandConfig` and `WeightedConfigBlstrs`: [4](#0-3) 

5. During randomness share aggregation, the system checks if collected weight meets the threshold: [5](#0-4) 

6. The threshold comes from `RandConfig::threshold()`: [6](#0-5) 

7. Byzantine validators controlling <1/3 stake can withhold their shares, preventing honest validators from reaching `weight_total`, thus blocking randomness aggregation.

**Why This Breaks Security Guarantees**: The randomness beacon is designed to guarantee liveness as long as validators with ≥2/3 stake participate (tolerating <1/3 Byzantine). By miscalculating the threshold to require 100% participation, the system violates this fundamental BFT liveness assumption, giving Byzantine validators veto power over randomness generation.

The `infallible()` fallback method has the same flaw, making this vulnerability more likely when edge-case validator distributions cause binary search to fail: [7](#0-6) 

## Impact Explanation

**Severity: High**

This vulnerability constitutes a **Consensus Liveness Violation** for the randomness beacon subsystem, meeting the High severity criteria per Aptos bug bounty program.

**Specific Impacts**:

1. **Randomness Beacon Liveness Failure**: Byzantine validators controlling less than 1/3 of stake can prevent the generation of on-chain randomness, breaking the core BFT assumption that <1/3 Byzantine actors can be tolerated.

2. **Denial of Service to Randomness-Dependent Applications**: Any smart contract or protocol feature requiring on-chain randomness (leader election, fair ordering, randomized selection) will fail to receive randomness values, rendering them non-functional.

3. **Validator Transaction (VTxn) Impact**: Since randomness generation is integrated into the consensus flow, this could impact the processing of validator transactions that depend on randomness availability.

4. **Protocol Integrity Violation**: The system's stated security guarantees (BFT with <1/3 Byzantine tolerance) are violated for the randomness subsystem, which is a critical consensus component.

While the blockchain may continue processing regular transactions, the failure of the randomness beacon represents a significant protocol violation. The ability of <1/3 Byzantine validators to prevent a consensus subsystem from functioning contradicts Aptos's fundamental BFT security model.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability manifests when:
1. Validator stake distribution results in `weight_total ≈ num_validators` (minimum weight configuration)
2. Rounding errors during weight calculation accumulate significantly (delta_up approaches 0.5 × weight_total)
3. At least one Byzantine validator exists to withhold shares

**Factors Increasing Likelihood**:

- The `infallible()` method, designed as a guaranteed fallback when binary search fails, contains the same flaw. This method is invoked for edge-case stake distributions, making the vulnerability more likely in unusual validator set configurations.

- Byzantine validators are expected in any BFT system per the threat model. Withholding shares requires no special capabilities—a Byzantine validator simply doesn't broadcast valid randomness shares.

- The attack complexity is low: once the misconfigured threshold is set during epoch initialization, Byzantine validators can exploit it throughout the entire epoch by passive non-participation.

- The validation gap means the misconfiguration passes all checks and becomes embedded in the epoch's randomness configuration, remaining exploitable until the next epoch change.

**Factors Decreasing Likelihood**:

- Requires specific stake distributions where minimum weight configurations occur
- May not manifest in every epoch, depending on validator set composition

## Recommendation

**Fix the Weight Threshold Calculation Formula**:

The formula should use a value closer to the reconstruction threshold rather than the secrecy threshold to ensure liveness. The calculation should guarantee that any validator subset with stake ≥ `reconstruct_threshold_in_stake_ratio` can achieve weight ≥ `reconstruct_threshold_in_weights`.

One approach is to calculate:
```rust
let reconstruct_threshold_in_weights_fixed =
    (reconstruct_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight - delta_down_fixed)
        .floor();
```

This ensures validators with ≥ reconstruction threshold stake can always meet the weight requirement.

**Add Validation to Prevent Unsafe Capping**:

Enhance `is_valid_profile()` to verify that `reconstruct_threshold_in_weights < weight_total`, ensuring unanimous participation is never required:

```rust
fn is_valid_profile(
    profile: &DKGRoundingProfile,
    reconstruct_threshold_in_stake_ratio: U64F64,
) -> bool {
    profile.reconstruct_threshold_in_stake_ratio <= reconstruct_threshold_in_stake_ratio
        && profile.reconstruct_threshold_in_weights < profile.validator_weights.iter().sum::<u64>()
        && (profile.fast_reconstruct_threshold_in_stake_ratio.is_none()
            || profile.fast_reconstruct_threshold_in_weights.unwrap() < profile.validator_weights.iter().sum::<u64>())
}
```

## Proof of Concept

The vulnerability can be demonstrated by examining the formula behavior:

Given:
- `num_validators = 100`
- All validators have equal stake
- `weight_total = 100` (minimum configuration, each validator weight = 1)
- `secrecy_threshold = 0.5`
- Maximum `delta_up ≈ 0.5 × 100 = 50` (when all validators round up)

Formula calculation:
- `threshold = ceil(0.5 × 100 + 50) + 1 = ceil(100) + 1 = 101`
- Capped: `threshold = min(100, 101) = 100`

Result: Requires 100% validator participation, allowing Byzantine validators (<1/3) to block randomness by withholding shares, violating the BFT liveness guarantee that ≥2/3 honest validators should suffice.

**Test to reproduce** (add to `types/src/dkg/real_dkg/rounding/tests.rs`):

```rust
#[test]
fn test_threshold_can_equal_total_weight() {
    // Create scenario where rounding errors cause threshold = weight_total
    let validator_stakes = vec![1; 100]; // 100 validators with equal stake
    let profile = DKGRoundingProfile::infallible(
        &validator_stakes,
        *DEFAULT_SECRECY_THRESHOLD,      // 0.5
        *DEFAULT_RECONSTRUCT_THRESHOLD,   // 2/3
        None,
    );
    
    let weight_total: u64 = profile.validator_weights.iter().sum();
    
    // If threshold equals weight_total, Byzantine validators can prevent aggregation
    if profile.reconstruct_threshold_in_weights == weight_total {
        panic!("Vulnerability confirmed: threshold requires 100% participation, \
                allowing <1/3 Byzantine validators to block randomness aggregation");
    }
}
```

## Notes

This vulnerability represents a logical flaw where the formula uses the wrong security parameter (secrecy instead of reconstruction threshold) combined with insufficient validation. The issue affects the core consensus mechanism for randomness generation and violates the stated BFT security guarantees of the Aptos protocol.

### Citations

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L61-129)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );

        let total_weight_min = total_weight_lower_bound(validator_stakes);
        let total_weight_max = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );

        let (profile, rounding_error, rounding_method) = match DKGRoundingProfile::new(
            validator_stakes,
            total_weight_min,
            total_weight_max,
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        ) {
            Ok(profile) => (profile, None, "binary_search".to_string()),
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
        };
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();

        let fast_wconfig = profile.fast_reconstruct_threshold_in_weights.map(
            |fast_reconstruct_threshold_in_weights| {
                WeightedConfigBlstrs::new(
                    fast_reconstruct_threshold_in_weights as usize,
                    profile
                        .validator_weights
                        .iter()
                        .map(|w| *w as usize)
                        .collect(),
                )
                .unwrap()
            },
        );

        Self {
            rounding_method,
            profile,
            wconfig,
            fast_wconfig,
            rounding_error,
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L285-293)
```rust
fn is_valid_profile(
    profile: &DKGRoundingProfile,
    reconstruct_threshold_in_stake_ratio: U64F64,
) -> bool {
    // ensure the reconstruction is below threshold, and the fast path threshold is valid
    profile.reconstruct_threshold_in_stake_ratio <= reconstruct_threshold_in_stake_ratio
        && (profile.fast_reconstruct_threshold_in_stake_ratio.is_none()
            || profile.fast_reconstruct_threshold_in_stake_ratio.unwrap() <= U64F64::from_num(1))
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L324-331)
```rust
    let reconstruct_threshold_in_weights_fixed =
        (secrecy_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight + delta_up_fixed)
            .ceil()
            + one;
    let reconstruct_threshold_in_weights: u64 = min(
        weight_total,
        reconstruct_threshold_in_weights_fixed.to_num::<u64>(),
    );
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L47-49)
```rust
        if self.total_weight < rand_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/rand_gen/types.rs (L683-685)
```rust
    pub fn threshold(&self) -> u64 {
        self.wconfig.get_threshold_weight() as u64
    }
```
