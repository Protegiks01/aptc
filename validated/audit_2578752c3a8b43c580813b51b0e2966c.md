# Audit Report

## Title
Circular Package Dependencies Can Be Published On-Chain When Lazy Loading Is Enabled, Violating DAG Invariant and Causing State Inconsistency

## Summary
When the lazy loading feature (Feature Flag #95) is enabled by default, the Move package publishing mechanism fails to detect circular dependencies, allowing packages with cyclic dependency graphs to be published on-chain. This violates the documented system invariant that module dependencies must form a Directed Acyclic Graph (DAG) and creates state inconsistencies where modules become valid or invalid depending on the feature flag state.

## Finding Description

The vulnerability exists across multiple validation layers that fail to detect circular dependencies when lazy loading is enabled:

**Layer 1 - Move Framework Validation:**
The `check_dependencies` function only validates immediate dependencies (existence and upgrade policies) but does not recursively traverse the dependency graph to detect cycles. [1](#0-0) 

**Layer 2 - Publishing Verification with Lazy Loading:**
During module publishing, when lazy loading is enabled, the code explicitly skips cycle detection. The implementation comment at line 259 states: "Note that we do not check cyclic dependencies here." [2](#0-1) 

The lazy verification only performs local bytecode verification and immediate dependency linking checks without traversing the full dependency graph. [3](#0-2) 

**Layer 3 - Eager Verification (When Lazy Loading Disabled):**
In contrast, when lazy loading is disabled, the eager verification path explicitly detects and rejects circular dependencies through recursive traversal. [4](#0-3) 

The cycle detection logic maintains a visited set and returns `CYCLIC_MODULE_DEPENDENCY` error when a cycle is detected. [5](#0-4) 

**System Invariant Violation:**
The codebase documents an explicit assumption that cycles should not exist: "If dependencies form a cycle (which should not be the case as we check this when modules are added to the module cache), an error is returned." [6](#0-5) 

This assumption is violated when lazy loading is enabled.

**Feature Flag Configuration:**
The lazy loading feature is controlled by Feature Flag #95 (`ENABLE_LAZY_LOADING`). [7](#0-6) 

It is enabled by default and can be toggled via on-chain governance. [8](#0-7) 

**Test Evidence:**
The integration test `test_cyclic_dependencies` confirms that with lazy loading enabled, cyclic dependencies are allowed to be published (but not called), while without lazy loading, they are rejected with `CYCLIC_MODULE_DEPENDENCY` error. [9](#0-8) 

**Attack Path:**
1. Attacker publishes Package A at address 0xA with dependency on Package B at 0xB
2. Attacker publishes Package B at address 0xB with dependency on Package A at 0xA
3. Both packages pass Move framework validation (check_dependencies doesn't detect cycles)
4. Both packages pass VM validation (lazy loading skips cycle detection)
5. Modules are permanently stored on-chain with circular dependencies
6. If lazy loading is later disabled, these modules cannot be accessed - any transaction attempting to load them will fail with `CYCLIC_MODULE_DEPENDENCY` error

## Impact Explanation

**Severity Assessment: MEDIUM**

This vulnerability constitutes a **protocol invariant violation** that creates state inconsistencies, aligning with MEDIUM severity under Aptos bug bounty criteria for "State inconsistencies requiring manual intervention":

1. **Protocol Invariant Violation**: The system explicitly assumes DAG structure for module dependencies. The code comment confirms this is a design invariant that lazy loading violates.

2. **State Inconsistency**: Modules become valid or invalid depending on feature flag state, creating a class of "zombie modules" that exist on-chain but cannot be accessed under certain configurations. This requires manual intervention to resolve.

3. **Operational Risk**: If the feature flag is toggled after circular dependencies exist on-chain:
   - Any transaction attempting to load these modules will fail
   - Existing packages depending on these modules become unusable
   - Requires governance action or manual cleanup to resolve

**Why Not Higher Severity:**
- **Not Consensus Breaking**: All validators run the same feature flag configuration at any given time (feature flags are part of on-chain consensus), so validators will not disagree on module validity
- **No Funds Loss**: Does not enable theft, unauthorized minting, or permanent freezing of user funds
- **No Liveness Impact**: Network continues operating; only specific modules become unusable
- **Localized Impact**: Only affects modules with circular dependencies, not the entire network

## Likelihood Explanation

**Likelihood: HIGH**

1. **Feature Enabled by Default**: Lazy loading is in the default enabled feature flag list
2. **No Special Privileges Required**: Any user can publish packages through the `publish_package_txn` entry function without validator or governance permissions
3. **Simple Attack Vector**: Requires only two package publication transactions
4. **Permanent Impact**: Once published, circular dependencies persist on-chain
5. **No Detection**: Current validation layers do not detect or prevent this scenario

The attack is straightforward, does not require precise timing or coordination, and can be executed by any network participant with sufficient gas to publish two packages.

## Recommendation

Implement cycle detection for lazy loading during module publishing. The fix should be applied in the `StagingModuleStorage::create_with_compat_config` function to perform cycle detection even when lazy loading is enabled:

1. After local bytecode verification and immediate dependency linking (lines 245-275), add an additional pass that traverses the dependency graph to detect cycles
2. Alternatively, enhance the `check_dependencies` function at the Move framework level to recursively traverse and detect cycles before calling the native publishing functions
3. Consider adding a feature flag to control whether cycle detection should be enforced, allowing for backward compatibility while fixing the invariant violation

## Proof of Concept

The existing test in the codebase already demonstrates this vulnerability: [9](#0-8) 

To reproduce on-chain:
1. Create Package A with a single module that declares dependency on Package B
2. Create Package B with a single module that declares dependency on Package A
3. Publish both packages via `code::publish_package_txn` transactions while lazy loading is enabled (default)
4. Both packages will be successfully published despite the circular dependency
5. Attempting to disable lazy loading and access these modules will result in `CYCLIC_MODULE_DEPENDENCY` errors

## Notes

This vulnerability represents a genuine protocol invariant violation where the system's documented assumption that module dependencies form a DAG can be violated in practice. While the immediate impact is limited (no consensus breaks or fund loss), it creates state inconsistencies that require manual intervention and represents a deviation from the intended system design. The vulnerability is exacerbated by lazy loading being enabled by default, making it trivial for any user to exploit.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L298-344)
```text
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L245-275)
```rust
            if is_lazy_loading_enabled {
                // Local bytecode verification.
                staged_runtime_environment.paranoid_check_module_address_and_name(
                    compiled_module,
                    compiled_module.self_addr(),
                    compiled_module.self_name(),
                )?;
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;

                // Linking checks to immediate dependencies. Note that we do not check cyclic
                // dependencies here.
                let mut verified_dependencies = vec![];
                for (dep_addr, dep_name) in locally_verified_code.immediate_dependencies_iter() {
                    // INVARIANT:
                    //   Immediate dependency of the module in a bundle must be metered at the
                    //   caller side.
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
                }
                staged_runtime_environment.build_verified_module_with_linking_checks(
                    locally_verified_code,
                    &verified_dependencies,
                )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L276-289)
```rust
            } else {
                // Verify the module and its dependencies, and that they do not form a cycle.
                staged_module_storage
                    .unmetered_get_eagerly_verified_module(addr, name)?
                    .ok_or_else(|| {
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(format!(
                                "Staged module {}::{} must always exist",
                                compiled_module.self_addr(),
                                compiled_module.self_name()
                            ))
                            .finish(Location::Undefined)
                    })?;
            }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L332-333)
```rust
/// Visits the dependencies of the given module. If dependencies form a cycle (which should not be
/// the case as we check this when modules are added to the module cache), an error is returned.
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L409-415)
```rust
        } else {
            // We must have found a cycle otherwise.
            return Err(module_cyclic_dependency_error!(
                dependency_id.address(),
                dependency_id.name()
            ));
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L148-148)
```rust
    ENABLE_LAZY_LOADING = 95,
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```

**File:** third_party/move/move-vm/integration-tests/src/tests/module_storage_tests.rs (L217-240)
```rust
fn test_cyclic_dependencies(enable_lazy_loading: bool) {
    let mut module_bytes_storage = in_memory_storage(enable_lazy_loading);

    let c_id = ModuleId::new(AccountAddress::ZERO, Identifier::new("c").unwrap());

    add_module_bytes(&mut module_bytes_storage, "a", vec!["b"], vec![]);
    add_module_bytes(&mut module_bytes_storage, "b", vec!["c"], vec![]);
    add_module_bytes(&mut module_bytes_storage, "c", vec!["a"], vec![]);

    let module_storage = module_bytes_storage.into_unsync_module_storage();

    if enable_lazy_loading {
        // With lazy loading, cyclic dependencies are allowed to be published (but not called).
        assert_ok!(module_storage.unmetered_get_lazily_verified_module(&c_id));
        module_storage.assert_cached_state(vec![], vec![&c_id]);
    } else {
        let result =
            module_storage.unmetered_get_eagerly_verified_module(c_id.address(), c_id.name());
        assert_eq!(
            assert_err!(result).major_status(),
            StatusCode::CYCLIC_MODULE_DEPENDENCY
        );
    }
}
```
