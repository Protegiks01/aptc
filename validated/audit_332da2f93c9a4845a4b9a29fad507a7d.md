# Audit Report

## Title
Message-Agnostic Signature Verification Status Allows Invalid Commit Votes to Bypass Cryptographic Verification

## Summary
The `SignatureWithStatus` structure uses an `Arc<AtomicBool>` to track verification status without binding it to the specific message being verified. When `CommitVotes` are added to a `SignatureAggregator` after the Executed stage, only `BlockInfo` equality is checked rather than full `LedgerInfo` equality. This allows a malicious validator to create a `CommitVote` with matching `BlockInfo` but different `consensus_data_hash`, have it verified against their chosen message, then inject it into an aggregator expecting a different message. The stale verification status causes `filter_invalid_signatures` to skip cryptographic verification, allowing invalid signatures to persist and be committed to storage without verification.

## Finding Description

This vulnerability stems from three interconnected design flaws in the consensus pipeline's signature verification mechanism:

**Issue 1: Message-Agnostic Verification Status**

The `SignatureWithStatus` struct stores verification status as a simple boolean flag that doesn't track which message was verified against. [1](#0-0) 

Once `verification_status` is set to `true` via `set_verified()`, it remains trusted regardless of the message context. The status is excluded from equality comparisons (via `#[derivative(PartialEq = "ignore")]`) and persists across different verification contexts.

**Issue 2: Incomplete Validation in add_signature_if_matched**

When commit votes are added to buffer items in Executed state, only `BlockInfo` equality is checked, not the full `LedgerInfo`. [2](#0-1) 

However, a `LedgerInfo` contains both `commit_info` (BlockInfo) and `consensus_data_hash` (HashValue). [3](#0-2) 

Two different `LedgerInfo` instances can have identical `commit_info` but different `consensus_data_hash` values, yet signatures are cryptographically bound to the entire `LedgerInfo` structure.

**Issue 3: Verification Status Short-Circuit in Filtering**

When `filter_invalid_signatures` processes signatures, it checks `is_verified()` first and skips cryptographic verification via short-circuit evaluation. [4](#0-3) 

The short-circuit OR means if `signature.is_verified()` returns true, the `verify()` call is never executed, regardless of whether the signature is valid for the current message being verified.

**Issue 4: No Verification After Filtering**

After filtering invalid signatures, `aggregate_and_verify` calls `try_aggregate` again but crucially does not verify the resulting aggregated signature before returning it as successful. [5](#0-4) 

**Issue 5: No Signature Verification Before Storage Commit**

The storage layer's `check_and_put_ledger_info` method validates version, root hash, and epoch continuity, but does NOT verify the cryptographic signatures before committing the `LedgerInfoWithSignatures` to the database. [6](#0-5) 

**Attack Execution Path:**

1. Honest node has a buffer item in Executed state with `LedgerInfo(commit_info: B, consensus_data_hash: H_honest)`

2. Malicious validator M creates a `CommitVote` with `LedgerInfo(commit_info: B, consensus_data_hash: H_malicious)` where `H_malicious â‰  H_honest`

3. M properly signs their vote, creating a valid BLS signature for their malicious `LedgerInfo`

4. The vote undergoes verification in the buffer manager's verification task. [7](#0-6) 

5. The verification calls `CommitVote::verify()` which verifies the signature against the vote's own `self.ledger_info` (M's malicious LedgerInfo). [8](#0-7) 

6. If pessimistic verification is triggered, the signature is cryptographically verified against M's malicious LedgerInfo and `verification_status` is set to `true`. [9](#0-8) 

7. The vote passes the `BlockInfo` equality check in `add_signature_if_matched` and is added to the aggregator expecting the honest LedgerInfo

8. When `aggregate_and_verify` is called and the aggregated signature fails, `filter_invalid_signatures` is invoked

9. During filtering, M's signature bypasses verification because `is_verified()` returns `true`, even though it's being verified against a different message (the honest LedgerInfo)

10. After filtering, `try_aggregate` is called again but does not verify the resulting aggregated signature before returning it as successful

11. The invalid `LedgerInfoWithSignatures` is sent to the persisting phase. [10](#0-9) 

12. The storage layer commits this to the database without verifying the signatures

## Impact Explanation

**HIGH Severity** (potentially CRITICAL) - This vulnerability enables serious consensus integrity violations:

1. **Invalid Commit Proof Creation**: The vulnerability allows creation of `LedgerInfoWithSignatures` containing cryptographically invalid aggregated signatures that the local node incorrectly believes are valid.

2. **Storage Corruption Without Verification**: The invalid commit proof is persisted to storage without signature verification, potentially corrupting the node's local state.

3. **Consensus Progress Disruption**: Nodes with invalid commit proofs will fail verification by other validators, preventing legitimate consensus progress and affecting network liveness.

4. **Voting Power Manipulation**: Invalid signatures contribute to voting power calculations in `check_voting_power` before aggregation. [11](#0-10) 

5. **Network Propagation**: Invalid commit proofs may be propagated to consensus observers and state sync mechanisms, causing network-wide inconsistencies. [12](#0-11) 

This aligns with **HIGH Severity** impacts per Aptos bug bounty criteria: validator node issues and consensus disruption affecting network availability.

## Likelihood Explanation

**Medium Likelihood** with specific preconditions:

1. **Triggering Conditions**: The attack requires pessimistic signature verification to be active for the malicious validator, which occurs when:
   - Optimistic verification is disabled globally (non-default configuration), OR
   - The validator is in the `pessimistic_verify_set` (added after submitting invalid signatures)

2. **Attack Simplicity**: Once preconditions are met, any validator can craft malicious `CommitVotes` with matching `BlockInfo` but arbitrary `consensus_data_hash` values

3. **No Collusion Required**: A single malicious validator can exploit this vulnerability without coordinating with other validators

4. **Deterministic Exploitation**: This is a logical flaw rather than a race condition, making it reliably exploitable whenever the preconditions are satisfied

## Recommendation

1. **Bind verification status to message**: Modify `SignatureWithStatus` to store a hash of the verified message alongside the boolean status, and check this hash before trusting `is_verified()`

2. **Full LedgerInfo validation**: In `add_signature_if_matched`, check full `LedgerInfo` equality (including `consensus_data_hash`), not just `BlockInfo` equality

3. **Verify after filtering**: After calling `filter_invalid_signatures` and `try_aggregate` in `aggregate_and_verify`, verify the resulting aggregated signature before returning

4. **Storage-layer verification**: Add signature verification in `check_and_put_ledger_info` before committing to storage

## Proof of Concept

A full PoC would require setting up a test network with validators, but the attack mechanism is:

1. Configure a validator node with pessimistic verification enabled
2. Create a `CommitVote` with matching `BlockInfo` but different `consensus_data_hash` than expected
3. Send this vote through the consensus pipeline
4. Observe that the vote passes BlockInfo validation and is added to the aggregator
5. Observe that the signature bypasses re-verification due to `is_verified()` short-circuit
6. Observe that the invalid aggregated signature is returned as valid
7. Observe that the invalid `LedgerInfoWithSignatures` is committed to storage without verification

## Notes

This vulnerability represents a critical breakdown in defense-in-depth. Multiple validation layers (signature aggregation, filtering, and storage) all fail to properly verify signatures before accepting them as valid. The storage layer particularly should act as a final safeguard but currently does not verify cryptographic signatures at all.

### Citations

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L384-413)
```rust
#[derive(Clone, Debug, Derivative)]
#[derivative(PartialEq, Eq)]
pub struct SignatureWithStatus {
    signature: bls12381::Signature,
    #[derivative(PartialEq = "ignore")]
    // false if the signature not verified.
    // true if the signature is verified.
    verification_status: Arc<AtomicBool>,
}

impl SignatureWithStatus {
    pub(crate) fn set_verified(&self) {
        self.verification_status.store(true, Ordering::SeqCst);
    }

    pub fn signature(&self) -> &bls12381::Signature {
        &self.signature
    }

    pub fn from(signature: bls12381::Signature) -> Self {
        Self {
            signature,
            verification_status: Arc::new(AtomicBool::new(false)),
        }
    }

    pub fn is_verified(&self) -> bool {
        self.verification_status.load(Ordering::SeqCst)
    }
}
```

**File:** types/src/ledger_info.rs (L488-508)
```rust
    pub fn check_voting_power(
        &self,
        verifier: &ValidatorVerifier,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let all_voters = self.all_voters();
        verifier.check_voting_power(all_voters, check_super_majority)
    }

    fn try_aggregate(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<AggregateSignature, VerifyError> {
        self.check_voting_power(verifier, true)?;

        let all_signatures = self
            .signatures
            .iter()
            .map(|(voter, sig)| (voter, sig.signature()));
        verifier.aggregate_signatures(all_signatures)
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** types/src/validator_verifier.rs (L270-285)
```rust
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L514-518)
```rust
                if let Some(consensus_publisher) = &self.consensus_publisher {
                    let message =
                        ConsensusObserverMessage::new_commit_decision_message(commit_proof.clone());
                    consensus_publisher.publish_message(message);
                }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L523-529)
```rust
                self.persisting_phase_tx
                    .send(self.create_new_request(PersistingRequest {
                        blocks: blocks_to_persist,
                        commit_ledger_info: aggregated_item.commit_proof,
                    }))
                    .await
                    .expect("Failed to send persist request");
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```
