# Audit Report

## Title
Epoch State Validation Bypass in State Sync Chunk Verification Allows Unauthorized Epoch Transitions

## Summary
The `StateSyncChunkVerifier::maybe_select_chunk_ending_ledger_info()` function contains a critical validation gap that allows ledger infos with incorrect epoch semantics to be committed to storage. When the target ledger info's version matches the chunk, the function validates only the transaction accumulator hash without verifying that the `next_epoch_state` field matches the locally computed execution output. This enables different nodes to commit conflicting epoch states for the same version, causing permanent consensus divergence.

## Finding Description

The vulnerability exists in the first conditional branch of `maybe_select_chunk_ending_ledger_info()` [1](#0-0) , which only validates that the version and transaction accumulator hash match, then returns the `verified_target_li` without any epoch semantic validation.

The critical missing validations are:
1. Whether `li.ends_epoch()` matches the locally computed `next_epoch_state.is_some()`
2. Whether `li.next_epoch_state()` equals the locally computed `next_epoch_state`

In stark contrast, the second branch properly validates all epoch semantics [2](#0-1) , checking both that the ledger info ends the epoch and that the next epoch state matches local computation.

The `ends_epoch()` method directly reflects whether `next_epoch_state` exists [3](#0-2) .

**Root Cause:** The `next_epoch_state` field is part of the `BlockInfo` structure [4](#0-3)  and is NOT included in the transaction accumulator. The transaction accumulator only commits to `TransactionInfo` structures [5](#0-4)  which contain gas usage, state changes, and events—but not epoch state information. Therefore, two ledger infos can have identical transaction accumulator hashes but different `next_epoch_state` values.

**Attack Vectors:**

1. **False Epoch Ending**: A node executes transactions producing `next_epoch_state = None`. An attacker provides a `verified_target_li` with valid BLS signatures, correct version and accumulator hash, but `next_epoch_state = Some(malicious_validator_set)`. The first branch matches and returns it without validation.

2. **Suppressed Epoch Ending**: A node executes transactions triggering an epoch change with `next_epoch_state = Some(new_validators)`. The attacker provides a `verified_target_li` with `next_epoch_state = None`. The epoch transition is suppressed.

The ledger info is committed through the storage layer [6](#0-5) , which validates version, root hash, epoch continuity, and state snapshot existence, but does NOT validate the semantic correctness of the `next_epoch_state` content.

Signature verification occurs through `EpochState::verify()` [7](#0-6) , which checks epoch number and cryptographic signatures but cannot detect semantic incorrectness—a validly-signed ledger info with wrong epoch semantics will pass verification.

## Impact Explanation

This vulnerability constitutes **Critical Severity** per the Aptos bug bounty criteria:

**Consensus Safety Violation**: Different nodes can commit different epoch states (different validator sets) for the same ledger version. This violates the fundamental consensus invariant that all honest nodes agree on the blockchain state. Nodes will diverge on which validators are authoritative for the next epoch.

**Non-Recoverable Network Partition**: Once nodes commit conflicting epoch states, they have incompatible views of validator authority. Nodes cannot sync with each other because they disagree on which signatures are valid for subsequent blocks. This creates a permanent fork requiring a hard fork to resolve—the network cannot self-heal through normal consensus mechanisms.

**Validator Set Manipulation**: An attacker can force victim nodes to recognize an incorrect validator set by providing crafted ledger infos during state sync. This breaks the core security assumption that 2f+1 honest validators control consensus progression.

This meets the explicit Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium**

**Attacker Requirements:**
- Network-level access to act as a state sync peer (any network participant)
- A `LedgerInfoWithSignatures` object with (a) valid 2f+1 BLS signatures, (b) correct version and transaction accumulator hash for the target chunk, (c) incorrect `next_epoch_state` relative to deterministic execution

**Feasibility Analysis:**

Such ledger infos can exist due to:
1. **Historical Network Forks**: During transient network partitions before consensus finalization, different validator subsets may sign conflicting proposals with the same version but different epoch states
2. **Byzantine Equivocation**: <1/3 Byzantine validators signing multiple conflicting blocks (within threat model)
3. **Non-Deterministic Execution Bugs**: If execution is non-deterministic, different validators compute different `next_epoch_state` values, and both get 2f+1 signatures

The attack does NOT require:
- >1/3 Byzantine validators (equivocation by <1/3 is sufficient)
- Compromised core infrastructure
- Cryptographic breaks

**Complexity: Low** - Once a suitable ledger info is obtained, exploitation is deterministic. The validation gap is systematic and predictable.

## Recommendation

Add epoch semantic validation to the first branch to match the protection in the second branch:

```rust
if li.version() + 1 == txn_accumulator.num_leaves() {
    ensure!(
        li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
        "Root hash in target ledger info does not match local computation."
    );
    
    // ADD THESE CHECKS:
    ensure!(
        li.ends_epoch() == next_epoch_state.is_some(),
        "Target LI epoch ending status doesn't match local execution. LI ends_epoch: {}, local next_epoch_state present: {}",
        li.ends_epoch(),
        next_epoch_state.is_some()
    );
    ensure!(
        li.next_epoch_state() == next_epoch_state,
        "Target LI next_epoch_state doesn't match local execution. LI: {:?}, local: {:?}",
        li.next_epoch_state(),
        next_epoch_state
    );
    
    Ok(Some(self.verified_target_li.clone()))
}
```

This ensures defense-in-depth: even if a validly-signed ledger info with incorrect semantics reaches the chunk executor, it will be rejected if it doesn't match the deterministic execution output.

## Proof of Concept

A complete PoC would require:
1. Setting up two validator groups that produce conflicting ledger infos during a simulated network partition
2. Having one group sign a ledger info with `next_epoch_state = Some(validator_set_A)`
3. Having another group sign a ledger info with same version/accumulator but `next_epoch_state = Some(validator_set_B)` or `None`
4. Providing these to syncing nodes via state sync and observing divergence

The code evidence demonstrates the vulnerability exists—the missing validation is clear from code inspection across multiple files cited above.

## Notes

This is a defense-in-depth vulnerability. While Aptos execution should be deterministic and validly-signed ledger infos should be semantically correct under normal operation, the code should not trust that cryptographic validity implies semantic correctness. The asymmetry between the first branch (missing checks) and second branch (proper checks) indicates this was likely an oversight rather than intentional design. The storage layer also trusts the epoch semantics of signed ledger infos, making this a systemic validation gap across multiple layers of the codebase.

### Citations

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L80-88)
```rust
        if li.version() + 1 == txn_accumulator.num_leaves() {
            // If the chunk corresponds to the target LI, the target LI can be added to storage.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash in target ledger info does not match local computation. {:?} != {:?}",
                li,
                txn_accumulator,
            );
            Ok(Some(self.verified_target_li.clone()))
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L106-116)
```rust
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
```

**File:** types/src/ledger_info.rs (L145-147)
```rust
    pub fn ends_epoch(&self) -> bool {
        self.next_epoch_state().is_some()
    }
```

**File:** types/src/block_info.rs (L29-44)
```rust
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** types/src/transaction/mod.rs (L2025-2051)
```rust
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```
