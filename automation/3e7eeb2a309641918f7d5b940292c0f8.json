[
  {
    "question": "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Loop termination] Is the fixed-point loop at lines 252-264 guaranteed to terminate for all valid inputs, or can certain bytecode patterns cause non-termination? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4d53b9f4-4c44-487a-bfac-2da30a8a56a4?mode=deep",
    "timestamp": "2026-01-21 11:21:40.828722",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: get_source_map()] [Fallback path] Does the fallback to empty_source_map at lines 146-147 properly handle all error cases, or can certain failures leave the system in an invalid state? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_c2049c62-3339-44cc-839d-3cf4c8cbc005?mode=deep",
    "timestamp": "2026-01-21 11:21:53.909591",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [File handle leaks] Are all file handles properly closed in error paths throughout the run function, or can handle leaks occur under exceptional conditions? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5fa25f32-dc58-4edb-b35e-39734d282e74?mode=deep",
    "timestamp": "2026-01-21 11:22:07.128663",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/third_party\n\n### Citations\n\n**File:** third_party/move/tools/move-decompiler/src/lib.rs (L1-311)\n```rust\n// Copyright (c) Aptos Foundation\n// Parts of the project are originally copyright (c) Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse anyhow::{Context, Result};\nuse clap::Parser;\nuse codespan::Span;\nuse codespan_reporting::{\n    diagnostic::Severity,\n    term::termcolor::{Buffer, WriteColor},\n};\nuse move_binary_format::{file_format::CompiledScript, module_script_conversion, CompiledModule};\nuse move_bytecode_source_map::source_map::SourceMap;\nuse move_command_line_common::files::FileHash;\nuse move_model::{\n    metadata::LanguageVersion,\n    model::{GlobalEnv, Loc, ModuleId},\n    sourcifier::Sourcifier,\n};\nuse move_stackless_bytecode::{\n    astifier,\n    function_target_pipeline::{FunctionTargetsHolder, FunctionVariant},\n};\nuse std::{collections::BTreeMap, fs, io::Write, mem, path::Path, rc::Rc, vec};\n\n#[derive(Parser, Clone, Debug, Default)]\n#[clap(author, version, about)]\npub struct Options {\n    /// Language version of the produced output. The decompiler will not produce source\n    /// which requires a newer version. If the decompiled bytecode requires\n    /// language features beyond this version, decompilation will fail.\n    #[clap(long, value_parser = clap::value_parser!(LanguageVersion))]\n    pub language_version: Option<LanguageVersion>,\n\n    /// By default, the decompiler detects conditionals (`if` and `match`) in\n    /// the bytecode. With this flag, the behavior can be turned off.\n    #[clap(long, default_value =",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_daac62bf-d957-4eeb-8015-197cdab8d15e?mode=deep",
    "timestamp": "2026-01-21 11:22:21.240107",
    "report_generated": false
  }
]