[
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_table_info()] [Last version semantics] last_version is computed as first_version + write_sets.len() but this represents one past the last write set, can this cause state_view to read from an incorrect version? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a42f3d14-b167-4e6d-a237-62337a020412?mode=deep",
    "timestamp": "2026-01-25 20:21:32.122300",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_struct()] [TypeTag construction] Box::new(struct_tag) creates boxed TypeTag::Struct, but can deeply nested generic types cause excessive boxing and stack overflow in the annotator? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_26796b56-2810-49ce-bc70-abe8c9b520b8?mode=deep",
    "timestamp": "2026-01-25 20:21:45.130487",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: save_table_info()] [Type info validation] TableInfo with key_type and value_type is stored without checking if the types are valid Move types, can this lead to corrupted type metadata? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f28c1771-8618-4e5b-b56d-69335ad46260?mode=deep",
    "timestamp": "2026-01-25 20:21:58.375666",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Lines: 4-7] [Migration concern] The file comment states this is a copy that will be moved to ecosystem/indexer-grpc, can the dual existence of this code cause confusion about which version is canonical and lead to bugs? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_e375c410-fa6c-496b-a036-deb0307de07b?mode=deep",
    "timestamp": "2026-01-25 20:22:12.124643",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Lines: 50-56] [Pending_on comment] The comment describes pending_on usage, but can the described scenario of nested tables create circular dependencies that are not properly handled? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_1ff2113c-541c-48f9-9826-c77dda35fa0e?mode=deep",
    "timestamp": "2026-01-25 20:22:26.715545",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_with_annotator()] [No version validation] The function doesn't validate that first_version equals self.next_version, can this allow out-of-order indexing causing gaps or duplicates in table info? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_681fa8e2-f3b2-4c3e-a54f-c2eddb406a6d?mode=deep",
    "timestamp": "2026-01-25 20:22:42.487808",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: update_next_version()] [No bounds checking] end_version is not validated to be greater than current next_version,\n\n### Citations\n\n**File:** storage/indexer/src/db_v2.rs (L1-341)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/// This file is a copy of the file storage/indexer/src/lib.rs.\n/// At the end of the migration to migrate table info mapping\n/// from storage critical path to indexer, the other file will be removed\n/// and this file will be moved to /ecosystem/indexer-grpc/indexer-grpc-table-info.\nuse aptos_db_indexer_schemas::{\n    metadata::{MetadataKey, MetadataValue},\n    schema::{indexer_metadata::IndexerMetadataSchema, table_info::TableInfoSchema},\n};\nuse aptos_logger::{info, sample, sample::SampleRate};\nuse aptos_resource_viewer::{AptosValueAnnotator, MoveTableInfo};\nuse aptos_schemadb::{batch::SchemaBatch, DB};\nuse aptos_storage_interface::{\n    db_other_bail as bail, state_store::state_view::db_state_view::DbStateViewAtVersion,\n    AptosDbError, DbReader, Result,\n};\nuse aptos_types::{\n    access_path::Path,\n    state_store::{\n        state_key::{inner::StateKeyInner, StateKey},\n        table::{TableHandle, TableInfo},\n        StateView,\n    },\n    transaction::Version,\n    write_set::{WriteOp, WriteSet},\n};\nuse bytes::Bytes;\nuse dashmap::{DashMap, DashSet};\nuse move_core_types::language_storage::{StructTag, TypeTag};\nuse std::{\n    collections::{BTreeMap, HashMap},\n    fs,\n    path::PathBuf,\n    sync::{\n        atomic::{AtomicU64, Ordering},\n        Arc,\n    },\n    time::Duration,\n};\n\nconst TABLE_INFO_RETRY_TIME_MILLIS: u64 = 10;\n\n#[derive(Debug)]\npub struct IndexerAsyncV2 {\n    pub db: DB,\n    // Next version to be processed\n    next_version: AtomicU64,\n    // It is used in the context of processing write ops and extracting table information.\n    // As the code iterates through the write ops, it checks if the state key corresponds to a table item.\n    // If it does, the associated bytes are added to the pending_on map under the corresponding table handle.\n    // Later, when the table information becomes available, the pending items can be retrieved and processed accordingly.\n    // One example could be a nested table item, parent table contains child table, so when parent table is first met and parsed,\n    // is obscure and will be stored as bytes with parent table's handle, once parent table's parsed with instructions,\n    // child table handle will be parsed accordingly.\n    pending_on: DashMap<TableHandle, DashSet<Bytes>>,\n}\n\nimpl IndexerAsyncV2 {\n    pub fn new(db: DB) -> Result<Self> {\n        let next_version = db\n            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?\n            .map_or(0, |v| v.expect_version());\n\n        Ok(Self {\n            db,\n            next_version: AtomicU64::new(next_version),\n            pending_on: DashMap::new(),\n        })\n    }\n\n    pub fn index_table_info(\n        &self,\n        db_reader: Arc<dyn DbReader>,\n        first_version: Version,\n        write_sets: &[&WriteSet],\n    ) -> Result<()> {\n        let last_version = first_version + write_sets.len() as Version;\n        let state_view = db_reader.state_view_at_version(Some(last_version))?;\n        let annotator = AptosValueAnnotator::new(&state_view);\n        self.index_with_annotator(&annotator, first_version, write_sets)\n    }\n\n    /// Index write sets with the move annotator to parse obscure table handle and key value types\n    /// After the current batch's parsed, write the mapping to the rocksdb, also update the next version to be processed\n    pub fn index_with_annotator<R: StateView>(\n        &self,\n        annotator: &AptosValueAnnotator<R>,\n        first_version: Version,\n        write_sets: &[&WriteSet],\n    ) -> Result<()> {\n        let end_version = first_version + write_sets.len() as Version;\n        let mut table_info_parser = TableInfoParser::new(self, annotator, &self.pending_on);\n        for write_set in write_sets {\n            for (state_key, write_op) in write_set.write_op_iter() {\n                table_info_parser.collect_table_info_from_write_op(state_key, write_op)?;\n            }\n        }\n        let mut batch = SchemaBatch::new();\n        match self.finish_table_info_parsing(&mut batch, &table_info_parser.result) {\n            Ok(_) => {},\n            Err(err) => {\n                aptos_logger::error!(\n                    first_version = first_version,\n                    end_version = end_version,\n                    error = ?&err,",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_c72e63bf-d4ee-44e7-be24-7404705c8bea?mode=deep",
    "timestamp": "2026-01-25 20:22:59.140437",
    "report_generated": false
  }
]