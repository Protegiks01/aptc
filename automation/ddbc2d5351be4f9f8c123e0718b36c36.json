[
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: AccessPathTree::new()] [Initial Allocation] At line 709, creating root node vector - can failure to allocate leave tree in inconsistent state? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_ee27ffa2-2938-4f74-913d-b5319c107033?mode=deep",
    "timestamp": "2026-01-26 05:54:08.979281",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: init_entry()] [Entry References] At lines 684-691, classifying parameter references - can misclassified parameters bypass reference safety? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_45fae305-56e8-412d-9090-cafb6c8244ea?mode=deep",
    "timestamp": "2026-01-26 05:54:22.066643",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: init_entry()] [Empty Caller Map] At line 693, creating empty caller_ref_param_map - is this correct for entrypoint where there's no caller? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_25987c16-ee55-4bf0-8497-8acbbb6993b1?mode=deep",
    "timestamp": "2026-01-26 05:54:35.568078",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: get_or_create_descendant_node()] [Path Traversal] At lines 1167-1169, iterating over access_path - can excessively long paths cause timeout or stack overflow? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9018bb50-c000-404e-9870-d7685dc43c48?mode=deep",
    "timestamp": "2026-01-26 05:54:49.877461",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: destructive_write_via_mut_ref()] [Ancestor Poisoning] At line 1054, poisoning strict ancestors - should parent mutable refs also be poisoned? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_cd8252d0-d66f-4d9e-ab82-8c8e5d4b78d0?mode=deep",
    "timestamp": "2026-01-26 05:55:05.246988",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: FrameRefState::new()] [Debug Assert] At lines 951-960, debug_asserts for validation - are these enforced in release builds? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5ad2b41f-aef5-406e-a84f-271270451eed?mode=deep",
    "timestamp": "2026-01-26 05:55:21.152174",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: post_execution_transition()] [VecPack] At line 631, using safe_unwrap_err for conversion - can large n values cause conversion failures? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b9bc745e-7b40-4a04-9dca-6e78fea3e57e?mode=deep",
    "timestamp": "2026-01-26 05:55:38.507578",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: post_execution_transition()] [VecUnpack] At line 651, similar conversion - can this fail silently? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_1450617a-04a1-4dc6-9c3d-c928e5951233?mode=deep",
    "timestamp": "2026-01-26 05:55:58.801646",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: post_execution_transition()] [Arithmetic Shadow Stack] At lines 594-601, arithmetic ops manipulate shadow stack - are all cases handled correctly? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_db4a737b-9809-451e-bb4a-91839f5de5a1?mode=deep",
    "timestamp": "2026-01-26 05:56:20.248720",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: pre_execution_transition()] [BrTrue/BrFalse] At line 328, branches pop from shadow stack - can branch target validation ensure consistency? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_02f5946c-f1b8-42fa-a640-d4b263fa4617?mode=deep",
    "timestamp": "2026-01-26 05:56:43.295104",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: pre_execution_transition()] [Abort] At line 328, Abort pops value - can abort handling ensure proper cleanup of references? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b4516851-ea94-4deb-b264-9ff4d704a86b?mode=deep",
    "timestamp": "2026-01-26 05:57:07.770468",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: copy_loc()] [Double Borrow] Can CopyLoc at line 1315 allow multiple mutable references to the same location if poison check fails to detect existing borrows? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a64232df-7249-4d39-a35d-eb44b58f6d48?mode=deep",
    "timestamp": "2026-01-26 05:57:33.777276",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: st_loc()] [Overwrite Race] At lines 1387-1419, can concurrent st_loc operations race to overwrite the same local, corrupting reference tracking? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_be16e13d-b7b1-44d3-80ba-44b88db2af4c?mode=deep",
    "timestamp": "2026-01-26 05:58:01.779830",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Cross-Function] [Reference Escaping] Can a reference be smuggled across function boundaries by hiding it in non-reference values, bypassing param validation in core_call? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_14ebc5df-fe85-4f94-8356-b9c19eccb725?mode=deep",
    "timestamp": "2026-01-26 05:58:30.416470",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Cross-Function] [Tree Synchronization] When multiple frames share reference param trees, can modifications in one frame corrupt trees used by another? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a0f363af-2ccb-43fc-b65c-5df3bb8de733?mode=deep",
    "timestamp": "2026-01-26 05:58:56.965466",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Cross-Function] [Lock Inheritance] Can locks acquired in a callee frame leak to caller frame through reference transformation, causing unexpected lock conflicts? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f1d639e1-cc9e-48e7-93d1-e5cf623f923e?mode=deep",
    "timestamp": "2026-01-26 05:59:26.687159",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_global()] [Cross-Transaction] Globals are abstracted by type only - can references from one transaction leak into another through global tree reuse? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f675a1ce-da26-49e3-ad43-50fc71603243?mode=deep",
    "timestamp": "2026-01-26 05:59:56.017444",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: move_from()] [Global Cleanup] After move_from poisons global refs at line 1566, is the global tree cleaned up or can stale trees accumulate? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a7480b43-ef05-449a-9200-927d223c1914?mode=deep",
    "timestamp": "2026-01-26 06:00:26.993426",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: return_()] [Lifetime Extension] Can returned references extend lifetime of values beyond their natural scope, causing use-after-free in caller? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_8fe1ca69-5d37-4e55-8b92-2fba07ff57ba?mode=deep",
    "timestamp": "2026-01-26 06:00:57.205452",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: core_call()] [Lifetime Shortening] Can passing a reference with long expected lifetime to a function that quickly purges it cause confusion? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9e68faf2-5632-4ed5-8a05-b0afd1153163?mode=deep",
    "timestamp": "2026-01-26 06:01:27.016761",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Macro: ref_check_failure] [Error Propagation] At lines 102-110, reference safety errors use UNKNOWN_INVARIANT_VIOLATION - can this mask the true error source? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2adafab5-1b8c-4375-9284-8dfcb307a788?mode=deep",
    "timestamp": "2026-01-26 06:01:56.039930",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Throughout] [Partial Failures] When operations fail mid-execution, are partial state changes rolled back or can they leave inconsistent state? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_c457c078-53b7-4773-a706-52ebd6dc0358?mode=deep",
    "timestamp": "2026-01-26 06:02:27.059378",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: b\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/runtime_ref_checks.rs (L1-1877)\n```rust\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module implements the runtime reference checks for Move bytecode.\n//!\n//! Move bytecode has a bytecode verifier pass for enforcing reference safety rules:\n//! the runtime checks implemented here are the relaxed dynamic semantics of that pass.\n//! If the bytecode verifier pass succeeds, then the runtime checks should also succeed\n//! for any execution path.\n//! However, there may be Move bytecode that the bytecode verifier pass rejects, but\n//! the runtime checks may still succeed, as long as reference-safety rules are not\n//! violated (i.e., relaxed semantics).\n//!\n//! This checker maintains shadow state as the execution proceeds: the shadow state\n//! contains information needed about the references in order to check for reference safety.\n//! Note that simpler techniques such as reference counting are insufficient to\n//! implement the dynamic relaxed semantics of the bytecode verifier pass.\n//!\n//! The shadow state contains:\n//! - A shadow stack of values. Values which can either be non-references (we don't\n//!   keep track of their type or actual value) or references (represented by a\n//!   unique-per-caller-frame identifier). The shadow stack is shared across all\n//!   active frames in the call stack.\n//! - A shadow frame stack of per-function data structures (described below).\n//!   The shadow frame stack grows and shrinks with the call stack.\n//!\n//! An access path tree, which is built out lazily as needed (for performance\n//! reasons), represents a non-reference value. A reference always points to a node\n//! in some access path tree.\n//!\n//! Consider, for example, a value of type `A`:\n//! ```move\n//! struct A {\n//!     x: B\n//! }\n//!\n//! struct B {\n//!    y: vector<u64>\n//!    z: u64\n//! }\n//! ```\n//! An access path tree for a value of type `A` would look like this:\n//! ```tree\n//! root\n//!   └──0── .x\n//!           ├──0── .y\n//!           │       └──0── all elements of the vector\n//!           └──1── .z\n//! ```\n//! The edges are ordered by labels, given by field offsets for structs and variants.\n//! For vectors, we use `0` to abstract all elements, instead of tracking\n//! each element of the vector separately. This is done for performance reasons.\n//!\n//! The per-function frame data structure contains:\n//! - A shadow list of values for all locals.\n//! - An access path tree for:\n//!   - each local that is not a reference\n//!   - each resource type globally borrowed by the function\n//!   - each value behind reference parameters passed to the function\n//! - A map from reference identifiers to the following info:\n//!   - whether the reference is mutable or immutable\n//!   - whether the reference is poisoned or not\n//!   - the access path tree node corresponding to the reference\n//! - A map from each reference parameter index to the corresponding access path tree\n//!   node in the caller's frame (if it exists)\n//!\n//! The informal idea is that we allow borrowing of references (mutable or immutable),\n//! but poison references when the underlying value is moved, or when a destructive\n//! update is performed via a mutable reference. Later, any use of a poisoned reference\n//! will result in an invariant violation error.\n//!\n//! When a call is made with reference parameters, the corresponding access path tree\n//! node subtree is locked (with exclusive lock for mutable references, and shared\n//! lock for immutable references). This is to make sure that values behind mutable\n//! references are unique at function call boundaries.\n//!\n//! When we return references on the shadow stack, we ensure that they are derived from\n//! one of the reference parameters. They are also transformed to point to the\n//! corresponding access path tree node in the caller's frame (if it exists).\n\nuse crate::{frame::Frame, frame_type_cache::FrameTypeCache, LoadedFunction};\nuse fxhash::FxBuildHasher;\nuse hashbrown::HashMap;\nuse move_binary_format::{\n    errors::{PartialVMError, PartialVMResult},\n    safe_assert, safe_unwrap, safe_unwrap_err,\n};\nuse move_core_types::{\n    function::ClosureMask,\n    vm_status::{sub_status::unknown_invariant_violation::EREFERENCE_SAFETY_FAILURE, StatusCode},\n};\nuse move_vm_types::{instr::Instruction, loaded_data::runtime_types::Type};\nuse std::{collections::BTreeSet, slice};\n\n/// A deterministic hash map (used in the Rust compiler), expected to perform well.\n/// Not resistant to hash collision attacks, nor is it cryptographically secure.\n/// Should not be used for iterating over keys without sorting first.\ntype UnorderedMap<K, V> = HashMap<K, V, FxBuildHasher>;\n\n/// `ref_check_failure!(msg)` will return a `PartialVMError` with the given message\n/// and a sub-status code indicating a reference safety failure.\nmacro_rules! ref_check_failure {\n    ($msg:ident) => {\n        Err(\n            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)\n                .with_message($msg)\n                .with_sub_status(EREFERENCE_SAFETY_FAILURE),\n        )\n    };\n}\n\n/// Represents a value in the shadow stack or shadow locals list.\n#[derive(Clone, Copy)]\nenum Value {\n    /// A non-reference value\n    NonRef,\n    /// A reference value\n    Ref(RefID),\n}\n\n/// Unique (within a frame) identifier for a reference.\n#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct RefID(usize);\n\n/// Access Path Tree, representing the access paths corresponding\n/// to a value (local, global, or value behind a reference parameter) in a frame.\n/// It is built up lazily as needed.\nstruct AccessPathTree {\n    nodes: Vec<AccessPathTreeNode>,\n}\n\n/// Node ID in a given access path tree, acts an index into the access path tree's\n/// node list.\ntype NodeID = usize;\n/// Edge label for an edge between two nodes in a given access path tree.\ntype EdgeLabel = usize;\n\n/// A node in the access path tree.\nstruct AccessPathTreeNode {\n    /// Parent node id and edge label (`None` for root nodes)\n    parent: Option<(NodeID, EdgeLabel)>,\n    /// Child nodes, edge label is the index in this vector\n    children: Vec<Option<NodeID>>,\n    /// References to this node\n    refs: BTreeSet<RefID>,\n    /// Current lock on this node\n    lock: Option<Lock>,\n}\n\n/// Represents the type of lock on an access path tree node.\n#[derive(Copy, Clone, PartialEq, Eq)]\nenum Lock {\n    /// Shared lock - multiple shared locks on the same node are allowed\n    Shared,\n    /// Exclusive lock - conflicts with any other lock\n    Exclusive,\n}\n\n/// Different kinds of root nodes in a frame.\n#[derive(Clone)]\nenum AccessPathTreeRoot {\n    /// Root representing a local (non-ref) value\n    Local { index: usize },\n    /// Root representing a global type\n    Global { type_: Type },\n    /// Special node representing the value behind a reference parameter\n    ReferenceParameter { param_index: usize },\n}\n\n/// Collection of access path tree roots information for a frame.\nstruct AccessPathTreeRootsInfo {\n    /// Mapping from local index to the corresponding access path tree\n    locals: UnorderedMap<usize, AccessPathTree>,\n    /// Mapping from global type to the corresponding access path tree\n    globals: UnorderedMap<Type, AccessPathTree>,\n    /// Mapping from reference parameter index to the corresponding access path tree\n    reference_params: UnorderedMap<usize, AccessPathTree>,\n}\n\n/// The root of the access path tree and the node ID within that tree.\n#[derive(Clone)]\nstruct QualifiedNodeID {\n    root: AccessPathTreeRoot,\n    node_id: NodeID,\n}\n\n/// Per frame reference checking state.\nstruct FrameRefState {\n    /// Shadow list of local values.\n    locals: Vec<Value>,\n    /// Roots of the Access Path Tree for this frame.\n    access_path_tree_roots: AccessPathTreeRootsInfo,\n    /// Mapping from references to their information.\n    /// Reference ID is unique within the frame.\n    ref_table: UnorderedMap<RefID, ReferenceInfo>,\n    /// Next available reference ID.\n    next_ref_id: usize,\n    /// Map the reference parameter's index to the access path tree node\n    /// (in the caller's `FrameRefState`) corresponding to the reference parameter.\n    caller_ref_param_map: UnorderedMap<usize, QualifiedNodeID>,\n}\n\n/// Filter for references when applying actions such as poisoning.\nenum ReferenceFilter {\n    /// Apply action to mutable references only\n    MutOnly,\n    /// Apply action to immutable references only\n    ImmutOnly,\n    /// Apply action to all references\n    All,\n}\n\nenum VisitKind {\n    /// Visit the node itself\n    SelfOnly,\n    /// Visit strict descendants of the node\n    StrictDescendants,\n    /// Visit strict ancestors of the node\n    StrictAncestors,\n}\n\n/// Various information about a reference.\nstruct ReferenceInfo {\n    /// Whether this reference is mutable\n    is_mutable: bool,\n    /// Whether this reference is poisoned\n    poisoned: bool,\n    /// The access path tree node this reference points to\n    access_path_tree_node: QualifiedNodeID,\n}\n\n/// State associated with the reference checker.\n/// This state is transitioned and checked as the bytecode is executed.\npub(crate) struct RefCheckState {\n    /// Shadow stack of ref/non-ref values.\n    /// This is shared between all the frames in the call stack.\n    shadow_stack: Vec<Value>,\n\n    /// Stack of per-frame reference states.\n    frame_stack: Vec<FrameRefState>,\n}\n\n/// A trait for determining the behavior of the runtime reference checks.\npub(crate) trait RuntimeRefCheck {\n    /// Transitions the reference check state before executing a bytecode instruction.\n    fn pre_execution_transition(\n        frame: &Frame,\n        instruction: &Instruction,\n        ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()>;\n\n    /// Transitions the reference check state after executing a bytecode instruction.\n    fn post_execution_transition(\n        frame: &Frame,\n        instruction: &Instruction,\n        ref_state: &mut RefCheckState,\n        ty_cache: &mut FrameTypeCache,\n    ) -> PartialVMResult<()>;\n\n    /// Transitions the reference check state during various forms of function calls.\n    fn core_call_transition(\n        num_params: usize,\n        num_locals: usize,\n        mask: ClosureMask,\n        ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()>;\n\n    /// Initializes the reference check state on the entrypoint function.\n    fn init_entry(function: &LoadedFunction, ref_state: &mut RefCheckState) -> PartialVMResult<()>;\n}\n\n/// A no-op implementation of the `RuntimeRefCheck` trait, which does not perform\n/// any runtime reference checks.\npub(crate) struct NoRuntimeRefCheck;\n\n/// An implementation of the `RuntimeRefCheck` trait that performs the reference checks\n/// as described in the module documentation.\npub(crate) struct FullRuntimeRefCheck;\n\nimpl RuntimeRefCheck for NoRuntimeRefCheck {\n    fn pre_execution_transition(\n        _frame: &Frame,\n        _instruction: &Instruction,\n        _ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn post_execution_transition(\n        _frame: &Frame,\n        _instruction: &Instruction,\n        _ref_state: &mut RefCheckState,\n        _ty_cache: &mut FrameTypeCache,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn core_call_transition(\n        _num_params: usize,\n        _num_locals: usize,\n        _mask: ClosureMask,\n        _ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn init_entry(\n        _function: &LoadedFunction,\n        _ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n}\n\nimpl RuntimeRefCheck for FullRuntimeRefCheck {\n    /// It may be preferred to have as many transitions in the `post_execution_transition`, because\n    /// gas is charged during execution, but we may want to validate this preference.\n    fn pre_execution_transition(\n        frame: &Frame,\n        instruction: &Instruction,\n        ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()> {\n        use Instruction::*;\n        match instruction {\n            Call(_) | CallGeneric(_) | Branch(_) => {\n                // `Call` and `CallGeneric` are handled by calling `core_call_transition` elsewhere\n            },\n            BrFalse(_) | BrTrue(_) | CallClosure(_) | Abort => {\n                // remove the top value from the shadow stack\n                let _ = ref_state.pop_from_shadow_stack()?;\n            },\n            Ret => {\n                ref_state.return_(frame.function.return_tys().len())?;\n            },\n            ReadRef => {\n                ref_state.pop_ref_push_non_ref()?;\n            },\n            StLoc(_)\n            | Pop\n            | LdU8(_)\n            | LdU16(_)\n            | LdU32(_)\n            | LdU64(_)\n            | LdU128(_)\n            | LdU256(_)\n            | LdI8(_)\n            | LdI16(_)\n            | LdI32(_)\n            | LdI64(_)\n            | LdI128(_)\n            | LdI256(_)\n            | LdTrue\n            | LdFalse\n            | LdConst(_)\n            | CopyLoc(_)\n            | MoveLoc(_)\n            | MutBorrowLoc(_)\n            | ImmBorrowLoc(_)\n            | ImmBorrowField(_)\n            | MutBorrowField(_)\n            | ImmBorrowFieldGeneric(_)\n            | MutBorrowFieldGeneric(_)\n            | PackClosure(..)\n            | PackClosureGeneric(..)\n            | Pack(_)\n            | PackGeneric(_)\n            | Unpack(_)\n            | UnpackGeneric(_)\n            | WriteRef\n            | CastU8\n            | CastU16\n            | CastU32\n            | CastU64\n            | CastU128\n            | CastU256\n            | CastI8\n            | CastI16\n            | CastI32\n            | CastI64\n            | CastI128\n            | CastI256\n            | Add\n            | Sub\n            | Mul\n            | Mod\n            | Div\n            | Negate\n            | BitOr\n            | BitAnd\n            | Xor\n            | Or\n            | And\n            | Shl\n            | Shr\n            | Lt\n            | Le\n            | Gt\n            | Ge\n            | Eq\n            | Neq\n            | MutBorrowGlobal(_)\n            | ImmBorrowGlobal(_)\n            | MutBorrowGlobalGeneric(_)\n            | ImmBorrowGlobalGeneric(_)\n            | Exists(_)\n            | ExistsGeneric(_)\n            | MoveTo(_)\n            | MoveToGeneric(_)\n            | MoveFrom(_)\n            | MoveFromGeneric(_)\n            | FreezeRef\n            | Nop\n            | Not\n            | VecPack(_, _)\n            | VecLen(_)\n            | VecImmBorrow(_)\n            | VecMutBorrow(_)\n            | VecPushBack(_)\n            | VecPopBack(_)\n            | VecUnpack(_, _)\n            | VecSwap(_)\n            | PackVariant(_)\n            | PackVariantGeneric(_)\n            | UnpackVariant(_)\n            | UnpackVariantGeneric(_)\n            | TestVariant(_)\n            | TestVariantGeneric(_)\n            | MutBorrowVariantField(_)\n            | MutBorrowVariantFieldGeneric(_)\n            | ImmBorrowVariantField(_)\n            | ImmBorrowVariantFieldGeneric(_) => {\n                // handled in `post_execution_transition`\n            },\n        };\n        Ok(())\n    }\n\n    fn post_execution_transition(\n        frame: &Frame,\n        instruction: &Instruction,\n        ref_state: &mut RefCheckState,\n        ty_cache: &mut FrameTypeCache,\n    ) -> PartialVMResult<()> {\n        use Instruction::*;\n        match instruction {\n            Pop => {\n                let top = ref_state.pop_from_shadow_stack()?;\n                if let Value::Ref(ref_id) = top {\n                    ref_state.purge_reference(ref_id)?;\n                }\n            },\n            Ret | BrTrue(_) | BrFalse(_) | Branch(_) => {\n                // not reachable here, transition is handled in `pre_execution_transition`\n            },\n            CastU8 | CastU16 | CastU32 | CastU64 | CastU128 | CastU256 | CastI8 | CastI16\n            | CastI32 | CastI64 | CastI128 | CastI256 | Not | Nop | Exists(_)\n            | ExistsGeneric(_) => {\n                // no-op\n            },\n            LdU8(_) | LdU16(_) | LdU32(_) | LdU64(_) | LdU128(_) | LdU256(_) | LdI8(_)\n            | LdI16(_) | LdI32(_) | LdI64(_) | LdI128(_) | LdI256(_) | LdConst(_) | LdTrue\n            | LdFalse => {\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            CopyLoc(index) => {\n                ref_state.copy_loc(*index)?;\n            },\n            MoveLoc(index) => {\n                ref_state.move_loc(*index)?;\n            },\n            StLoc(index) => {\n                ref_state.st_loc(*index)?;\n            },\n            Call(_) | CallGeneric(_) | CallClosure(_) => {\n                // not reachable here, transition handled in `core_call_transition`\n            },\n            Pack(index) => {\n                let num_fields = frame.field_count(*index).into();\n                ref_state.pop_many_from_shadow_stack(num_fields)?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            PackGeneric(index) => {\n                let num_fields = frame.field_instantiation_count(*index).into();\n                ref_state.pop_many_from_shadow_stack(num_fields)?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            PackVariant(index) => {\n                let struct_variant_info = frame.get_struct_variant_at(*index);\n                let num_fields = struct_variant_info.field_count.into();\n                ref_state.pop_many_from_shadow_stack(num_fields)?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            PackVariantGeneric(index) => {\n                let struct_variant_info = frame.get_struct_variant_instantiation_at(*index);\n                let num_fields = struct_variant_info.field_count.into();\n                ref_state.pop_many_from_shadow_stack(num_fields)?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            Unpack(index) => {\n                ref_state.pop_from_shadow_stack()?;\n                let num_fields = frame.field_count(*index).into();\n                ref_state.push_non_refs_to_shadow_stack(num_fields);\n            },\n            UnpackGeneric(index) => {\n                ref_state.pop_from_shadow_stack()?;\n                let num_fields = frame.field_instantiation_count(*index).into();\n                ref_state.push_non_refs_to_shadow_stack(num_fields);\n            },\n            UnpackVariant(index) => {\n                ref_state.pop_from_shadow_stack()?;\n                let struct_variant_info = frame.get_struct_variant_at(*index);\n                let num_fields = struct_variant_info.field_count.into();\n                ref_state.push_non_refs_to_shadow_stack(num_fields);\n            },\n            UnpackVariantGeneric(index) => {\n                ref_state.pop_from_shadow_stack()?;\n                let struct_variant_info = frame.get_struct_variant_instantiation_at(*index);\n                let num_fields = struct_variant_info.field_count.into();\n                ref_state.push_non_refs_to_shadow_stack(num_fields);\n            },\n            TestVariant(_) => {\n                ref_state.pop_ref_push_non_ref()?;\n            },\n            TestVariantGeneric(_) => {\n                ref_state.pop_ref_push_non_ref()?;\n            },\n            ReadRef => {\n                // Transition handled in `pre_execution_transition`\n            },\n            WriteRef => {\n                ref_state.write_ref()?;\n            },\n            FreezeRef => {\n                ref_state.freeze_ref()?;\n            },\n            MutBorrowLoc(index) => {\n                ref_state.borrow_loc(*index, true)?;\n            },\n            ImmBorrowLoc(index) => {\n                ref_state.borrow_loc(*index, false)?;\n            },\n            MutBorrowField(index) => {\n                let label = frame.field_offset(*index);\n                ref_state.borrow_child_with_label::<true>(label)?;\n            },\n            MutBorrowVariantField(index) => {\n                let field_info = frame.variant_field_info_at(*index);\n                let label = field_info.offset;\n                ref_state.borrow_child_with_label::<true>(label)?;\n            },\n            MutBorrowFieldGeneric(index) => {\n                let label = frame.field_instantiation_offset(*index);\n                ref_state.borrow_child_with_label::<true>(label)?;\n            },\n            MutBorrowVariantFieldGeneric(index) => {\n                let field_info = frame.variant_field_instantiation_info_at(*index);\n                let label = field_info.offset;\n                ref_state.borrow_child_with_label::<true>(label)?;\n            },\n            ImmBorrowField(index) => {\n                let label = frame.field_offset(*index);\n                ref_state.borrow_child_with_label::<false>(label)?;\n            },\n            ImmBorrowVariantField(index) => {\n                let field_info = frame.variant_field_info_at(*index);\n                let label = field_info.offset;\n                ref_state.borrow_child_with_label::<false>(label)?;\n            },\n            ImmBorrowFieldGeneric(index) => {\n                let label = frame.field_instantiation_offset(*index);\n                ref_state.borrow_child_with_label::<false>(label)?;\n            },\n            ImmBorrowVariantFieldGeneric(index) => {\n                let field_info = frame.variant_field_instantiation_info_at(*index);\n                let label = field_info.offset;\n                ref_state.borrow_child_with_label::<false>(label)?;\n            },\n            MutBorrowGlobal(index) => {\n                let struct_ty = frame.get_struct_ty(*index);\n                ref_state.borrow_global::<true>(struct_ty)?;\n            },\n            MutBorrowGlobalGeneric(index) => {\n                let struct_ty = ty_cache.get_struct_type(*index, frame)?.0;\n                ref_state.borrow_global::<true>(struct_ty.clone())?;\n            },\n            ImmBorrowGlobal(index) => {\n                let struct_ty = frame.get_struct_ty(*index);\n                ref_state.borrow_global::<false>(struct_ty)?;\n            },\n            ImmBorrowGlobalGeneric(index) => {\n                let struct_ty = ty_cache.get_struct_type(*index, frame)?.0;\n                ref_state.borrow_global::<false>(struct_ty.clone())?;\n            },\n            Add | Sub | Mul | Mod | Div | BitOr | BitAnd | Xor | Or | And | Lt | Gt | Le | Ge\n            | Shl | Shr => {\n                // pop two non-ref values from the shadow stack, push a new non-ref value\n                let _ = ref_state.pop_from_shadow_stack()?;\n            },\n            Negate => {\n                // leaves shadow stack at same value\n            },\n            Eq | Neq => {\n                // pop two values from the shadow stack (which can be ref or non-ref values)\n                let top_1 = ref_state.pop_from_shadow_stack()?;\n                let top_2 = ref_state.pop_from_shadow_stack()?;\n                if let (Value::Ref(ref_1), Value::Ref(ref_2)) = (top_1, top_2) {\n                    ref_state.purge_reference(ref_1)?;\n                    ref_state.purge_reference(ref_2)?;\n                }\n                // push a non-ref value onto the shadow stack\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            Abort => {\n                // not reachable here, transition handled in `pre_execution_transition`\n            },\n            MoveFrom(index) => {\n                let struct_ty = frame.get_struct_ty(*index);\n                ref_state.move_from(struct_ty)?;\n            },\n            MoveFromGeneric(index) => {\n                let struct_ty = ty_cache.get_struct_type(*index, frame)?.0;\n                ref_state.move_from(struct_ty.clone())?;\n            },\n            MoveTo(_) => {\n                ref_state.move_to()?;\n            },\n            MoveToGeneric(_) => {\n                ref_state.move_to()?;\n            },\n            VecPack(_, n) => {\n                ref_state.pop_many_from_shadow_stack(safe_unwrap_err!((*n).try_into()))?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            VecLen(_) => {\n                ref_state.vec_len()?;\n            },\n            VecImmBorrow(_) => {\n                ref_state.vec_borrow::<false>()?;\n            },\n            VecMutBorrow(_) => {\n                ref_state.vec_borrow::<true>()?;\n            },\n            VecPushBack(_) => {\n                ref_state.vec_push_back()?;\n            },\n            VecPopBack(_) => {\n                ref_state.vec_pop_back()?;\n            },\n            VecUnpack(_, n) => {\n                let _ = ref_state.pop_from_shadow_stack()?;\n                ref_state.push_non_refs_to_shadow_stack(safe_unwrap_err!((*n).try_into()));\n            },\n            VecSwap(_) => {\n                ref_state.vec_swap()?;\n            },\n            PackClosure(_, mask) => {\n                let captured = mask.captured_count();\n                // note: we are not checking that values captured are non-ref values, as this belongs\n                // to type checks.\n                ref_state.pop_many_from_shadow_stack(captured.into())?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n            PackClosureGeneric(_, mask) => {\n                let captured = mask.captured_count();\n                ref_state.pop_many_from_shadow_stack(captured.into())?;\n                ref_state.push_non_refs_to_shadow_stack(1);\n            },\n        };\n        Ok(())\n    }\n\n    fn core_call_transition(\n        num_params: usize,\n        num_locals: usize,\n        mask: ClosureMask,\n        ref_state: &mut RefCheckState,\n    ) -> PartialVMResult<()> {\n        ref_state.core_call(num_params, num_locals, mask)\n    }\n\n    fn init_entry(function: &LoadedFunction, ref_state: &mut RefCheckState) -> PartialVMResult<()> {\n        let num_locals = function.local_tys().len();\n        let mut mut_ref_indexes = vec![];\n        let mut immut_ref_indexes = vec![];\n        for (i, ty) in function.param_tys().iter().enumerate() {\n            match ty {\n                Type::Reference(_) => immut_ref_indexes.push(i),\n                Type::MutableReference(_) => mut_ref_indexes.push(i),\n                _ => continue,\n            }\n        }\n        // Empty map, references are not transformed when returning from the entrypoint function.\n        let caller_ref_param_map = UnorderedMap::with_hasher(FxBuildHasher::default());\n        ref_state.push_new_frame(\n            num_locals,\n            mut_ref_indexes,\n            immut_ref_indexes,\n            caller_ref_param_map,\n        )?;\n\n        Ok(())\n    }\n}\n\nimpl AccessPathTree {\n    /// Create a new Access Path Tree with a fresh root node.\n    fn new() -> Self {\n        Self {\n            nodes: vec![AccessPathTreeNode::fresh_root()],\n        }\n    }\n\n    /// Make a new child node in the access path tree, given the parent node ID\n    /// and the label for the edge.\n    fn make_new_node(&mut self, parent_id: NodeID, label: EdgeLabel) -> NodeID {\n        let new_node = AccessPathTreeNode::fresh_node(parent_id, label);\n        self.nodes.push(new_node);\n        self.nodes.len() - 1\n    }\n\n    /// Get a reference to the node at `node_id`.\n    fn get_node(&self, node_id: NodeID) -> PartialVMResult<&AccessPathTreeNode> {\n        Ok(safe_unwrap!(self.nodes.get(node_id)))\n    }\n\n    /// Get a mutable reference to the node at `node_id`.\n    fn get_node_mut(&mut self, node_id: NodeID) -> PartialVMResult<&mut AccessPathTreeNode> {\n        Ok(safe_unwrap!(self.nodes.get_mut(node_id)))\n    }\n\n    /// Given the parent node ID and the label, get the existing child node or create a new one.\n    fn get_or_create_child_node(\n        &mut self,\n        parent_id: NodeID,\n        label: EdgeLabel,\n    ) -> PartialVMResult<NodeID> {\n        let parent_node = self.get_node_mut(parent_id)?;\n        let child_id = parent_node.children.get(label);\n        // Should we resize the children vector?\n        let resize = match child_id {\n            // child slot exists and is occupied, return its ID\n            Some(Some(child_id)) => return Ok(*child_id),\n            // child slot exists but is unoccupied, no need to resize, just occupy it\n            Some(None) => false,\n            // child slot does not exist, we need to resize and then occupy it\n            None => true,\n        };\n\n        if resize {\n            parent_node\n                .children\n                .resize(safe_unwrap!(label.checked_add(1)), None);\n        }\n\n        // Create a new child node, and update the parent's children slot.\n        let new_child_id = self.make_new_node(parent_id, label);\n        // Re-borrow to satisfy Rust's borrow checker.\n        let parent_node = self.get_node_mut(parent_id)?;\n        *safe_unwrap!(parent_node.children.get_mut(label)) = Some(new_child_id);\n        Ok(new_child_id)\n    }\n\n    /// Visit the strict descendants (i.e., exclude self) of the node and apply `f` to each.\n    fn visit_strict_descendants<F>(&mut self, node_id: NodeID, mut f: F) -> PartialVMResult<()>\n    where\n        F: FnMut(&mut AccessPathTreeNode) -> PartialVMResult<()>,\n    {\n        // We need to collect the descendants first, because we are mutating nodes while visiting.\n        for descendant in self\n            .get_descendants_iter(node_id)\n            .skip(1)\n            .collect::<Vec<_>>()\n        {\n            let node = self.get_node_mut(descendant)?;\n            f(node)?;\n        }\n        Ok(())\n    }\n\n    /// Visit the node itself and apply `f` to it.\n    fn visit_self<F>(&mut self, node_id: NodeID, mut f: F) -> PartialVMResult<()>\n    where\n        F: FnMut(&mut AccessPathTreeNode) -> PartialVMResult<()>,\n    {\n        let node = self.get_node_mut(node_id)?;\n        f(node)?;\n        Ok(())\n    }\n\n    /// Visit the strict ancestors of the node (i.e., excluding self) and apply `f` to each.\n    fn visit_strict_ancestors<F>(&mut self, node_id: NodeID, mut f: F) -> PartialVMResult<()>\n    where\n        F: FnMut(&mut AccessPathTreeNode) -> PartialVMResult<()>,\n    {\n        let mut current_node_id = node_id;\n        while let Some((parent_id, _label)) = self.get_node(current_node_id)?.parent {\n            let parent_node = self.get_node_mut(parent_id)?;\n            f(parent_node)?;\n            current_node_id = parent_id;\n        }\n        Ok(())\n    }\n\n    /// Get the list of edge labels that can be used to get from the root node to the given node.\n    fn get_access_path_from_root(&self, node_id: NodeID) -> PartialVMResult<Vec<EdgeLabel>> {\n        let mut current_node_id = node_id;\n        let mut path = Vec::new();\n        while let Some((parent_id, label)) = self.get_node(current_node_id)?.parent {\n            current_node_id = parent_id;\n            path.push(label);\n        }\n        path.reverse();\n        Ok(path)\n    }\n\n    /// Get an iterator over the descendants (including self) of the given node.\n    fn get_descendants_iter<'a>(&'a self, node_id: NodeID) -> DescendantsTraversalIter<'a> {\n        DescendantsTraversalIter {\n            stack: vec![node_id],\n            access_path_tree: self,\n        }\n    }\n}\n\n/// An iterator for traversing the descendants of an access path tree node.\nstruct DescendantsTraversalIter<'a> {\n    stack: Vec<NodeID>,\n    access_path_tree: &'a AccessPathTree,\n}\n\nimpl<'a> Iterator for DescendantsTraversalIter<'a> {\n    type Item = NodeID;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let node_id = self.stack.pop()?;\n        // When processing a node, its children are added to the stack in reverse order.\n        if let Some(node) = self.access_path_tree.nodes.get(node_id) {\n            self.stack.extend(node.children.iter().rev().flatten());\n        } // else should be unreachable, as we should not have invalid node IDs\n        Some(node_id)\n    }\n}\n\nimpl AccessPathTreeNode {\n    /// Create a fresh root node for the access path tree.\n    fn fresh_root() -> Self {\n        Self {\n            parent: None,\n            children: Vec::new(),\n            refs: BTreeSet::new(),\n            lock: None,\n        }\n    }\n\n    /// Create a fresh child node with the given parent and edge label.\n    fn fresh_node(parent_id: NodeID, label: EdgeLabel) -> Self {\n        Self {\n            parent: Some((parent_id, label)),\n            children: Vec::new(),\n            refs: BTreeSet::new(),\n            lock: None,\n        }\n    }\n}\n\nimpl AccessPathTreeRootsInfo {\n    /// Get a reference to the access path tree for the given root.\n    /// Should be called when the root is guaranteed to exist.\n    fn get_access_path_tree(&self, root: &AccessPathTreeRoot) -> PartialVMResult<&AccessPathTree> {\n        match root {\n            AccessPathTreeRoot::Local { index } => Ok(safe_unwrap!(self.locals.get(index))),\n            AccessPathTreeRoot::Global { type_ } => Ok(safe_unwrap!(self.globals.get(type_))),\n            AccessPathTreeRoot::ReferenceParameter { param_index } => {\n                Ok(safe_unwrap!(self.reference_params.get(param_index)))\n            },\n        }\n    }\n\n    /// Get a mutable reference to the access path tree for the given root.\n    /// Should be called when the root is guaranteed to exist.\n    fn get_mut_access_path_tree(\n        &mut self,\n        root: &AccessPathTreeRoot,\n    ) -> PartialVMResult<&mut AccessPathTree> {\n        Ok(safe_unwrap!(self.maybe_get_mut_access_path_tree(root)))\n    }\n\n    /// Get a mutable reference to the access path tree for the given root, if it exists.\n    fn maybe_get_mut_access_path_tree(\n        &mut self,\n        root: &AccessPathTreeRoot,\n    ) -> Option<&mut AccessPathTree> {\n        match root {\n            AccessPathTreeRoot::Local { index } => self.locals.get_mut(index),\n            AccessPathTreeRoot::Global { type_ } => self.globals.get_mut(type_),\n            AccessPathTreeRoot::ReferenceParameter { param_index } => {\n                self.reference_params.get_mut(param_index)\n            },\n        }\n    }\n\n    /// Get a mutable reference to the given node in the access path tree.\n    fn get_mut_access_path_tree_node(\n        &mut self,\n        node: &QualifiedNodeID,\n    ) -> PartialVMResult<&mut AccessPathTreeNode> {\n        let access_path_tree = self.get_mut_access_path_tree(&node.root)?;\n        Ok(safe_unwrap!(access_path_tree.nodes.get_mut(node.node_id)))\n    }\n}\n\nimpl QualifiedNodeID {\n    /// A root node corresponding to a local with the given index.\n    fn local_root(index: usize) -> Self {\n        Self {\n            root: AccessPathTreeRoot::Local { index },\n            node_id: 0, // root is always at 0\n        }\n    }\n\n    /// A root node corresponding to a global type.\n    fn global_root(type_: Type) -> Self {\n        Self {\n            root: AccessPathTreeRoot::Global { type_ },\n            node_id: 0, // root is always at 0\n        }\n    }\n\n    /// A root node corresponding to a reference parameter with the given index.\n    fn reference_param_root(param_index: usize) -> Self {\n        Self {\n            root: AccessPathTreeRoot::ReferenceParameter { param_index },\n            node_id: 0, // root is always at 0\n        }\n    }\n}\n\nimpl FrameRefState {\n    /// Create a new `FrameRefState`.\n    /// - `num_locals` is the number of locals in the frame.\n    /// - `mut_ref_indexes` are the indexes of mutable reference parameters.\n    /// - `immut_ref_indexes` are the indexes of immutable reference parameters.\n    /// - `caller_ref_param_map` maps the reference parameter's index to the access path tree\n    ///    node corresponding to the reference parameter in the caller's `FrameRefState`.\n    fn new(\n        num_locals: usize,\n        mut_ref_indexes: Vec<usize>,\n        immut_ref_indexes: Vec<usize>,\n        caller_ref_param_map: UnorderedMap<usize, QualifiedNodeID>,\n    ) -> PartialVMResult<Self> {\n        debug_assert!(\n            num_locals >= mut_ref_indexes.len() + immut_ref_indexes.len(),",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_7dc299e7-59f3-4a97-9714-d3a23326467f?mode=deep",
    "timestamp": "2026-01-26 06:02:59.050163",
    "report_generated": false
  }
]