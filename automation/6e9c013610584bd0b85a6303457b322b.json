[
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_test_variants()] [Boolean temp reuse] Can the reused bool_temp across multiple variant tests cause state corruption if previous test results aren't properly cleared? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_3347ffd5-e0b0-4b99-a1eb-9565fdc0e8ae?mode=deep",
    "timestamp": "2026-01-23 03:49:36.742578",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match()] [Probing mode bypass] Can crafted match expressions with conditions bypass the probing mode logic to consume values prematurely, causing double-move or use-after-move bugs? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_7012dee8-449a-4b8d-863c-4ee4319b8d4e?mode=deep",
    "timestamp": "2026-01-23 03:49:49.702546",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match()] [Exhaustiveness bypass] Does the incomplete match abort code (well_known::INCOMPLETE_MATCH_ABORT_CODE) get properly emitted, or can control flow bypass it allowing undefined behavior? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_03d734d7-35fd-4863-9bbb-997bcb28b4c9?mode=deep",
    "timestamp": "2026-01-23 03:50:02.774789",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match()] [Reference creation leak] For non-reference match values, can the BorrowLoc operation for creating value_refs cause temp leaks or incorrect lifetime management? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_53028c34-5162-4561-b698-a1f46fa7948f?mode=deep",
    "timestamp": "2026-01-23 03:50:17.240750",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match_probe()] [Scope injection] Can the probe_scope creation with lifted reference types be exploited to inject variables with incorrect types into subsequent match execution? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_63fb2d18-42ad-42a2-a356-6f9787d7a73e?mode=deep",
    "timestamp": "2026-01-23 03:50:31.992907",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match_probe()] [Expression rewriting attack] Can the ExpRewriter used to replace LocalVar with Deref(LocalVar) be exploited to inject malicious operations or bypass safety checks? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_508b365a-59ca-4568-828d-fdb5fd9c7a2f?mode=deep",
    "timestamp": "2026-01-23 03:50:47.015761",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match_from_temp()] [Variant test bypass] For refutable matches with variants, can the TestVariant operation be skipped or manipulated to match incorrect variants? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f1e620bc-fb40-483a-b377-dca359cbfdea?mode=deep",
    "timestamp": "2026-01-23 03:51:05.793133",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_match_from_temp()] [Unpack vs BorrowField confusion] Can the uses_unpack determination based on ref_kind be manipulated to generate incorrect destructuring bytecode? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0d450caa-09df-46f0-a97a-7c212c4dccff?mode=deep",
    "timestamp": "2026-01-23 03:51:23.787152",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_borrow_field_for_unpack_ref()] [Field position mismatch] Can incorrect positional mapping in sub_matches cause wrong fields to be borrowed when unpacking struct references? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_316f4852-5d54-4d53-8eab-2fe1866237aa?mode=deep",
    "timestamp": "2026-01-23 03:51:42.062736",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_assign()] [Scope confusion] Can the optional next_scope parameter be exploited to shadow variables and cause incorrect bindings in pattern assignments? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_7120fbb6-365f-46bf-a5c0-fa6e5c377ee3?mode=deep",
    "timestamp": "2026-01-23 03:52:01.638732",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_tuple_assign()] [Simultaneous assignment bypass] Can the have_overlapping_vars check be fooled by complex nested patterns to skip temporary creation, causing incorrect simultaneous assignment semantics? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d2c50a7a-3683-4e2f-a600-63ec55063c3a?mode=deep",
    "timestamp": "2026-01-23 03:52:20.637250",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_tuple_assign()] [Arity mismatch] In tuple-to-tuple assignment, can arity mismatches bypass validation and cause out-of-bounds access or incorrect assignments? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_8b598b67-2139-49ba-977a-2bb7fa706492?mode=deep",
    "timestamp": "2026-01-23 03:52:42.665704",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: have_overlapping_vars()] [False negative] Can the overlap detection using free_vars_and_used_params miss overlaps due to complex expression nesting or closure captures? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_ed68c358-d3d4-4bff-8ee4-46c85515cb13?mode=deep",
    "timestamp": "2026-01-23 03:53:04.416466",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: collect_sub_match()] [Type confusion in probing] Does effective_var_type properly lift all non-reference types to references in probing mode, or can edge cases cause type mismatches? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_41f413b8-68b8-4352-8a86-bd80f935b000?mode=deep",
    "timestamp": "2026-01-23 03:53:26.995892",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: with_reference_mode()] [Counter overflow] Can nested reference mode calls cause reference_mode_counter to overflow, leading to incorrect reference mode detection? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4aca9d0b-85fe-4e6d-97c9-d4f005bc8e87?mode=deep",
    "timestamp": "2026-01-23 03:53:51.443101",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: without_reference_mode()] [State corruption] Can exceptions or early returns during without_reference_mode execution leave the generator in inconsistent state with wrong reference_mode_counter? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_25114388-930f-4d09-97af-35dbe3931f9d?mode=deep",
    "timestamp": "2026-01-23 03:54:16.029978",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_auto_ref_arg()] [Unnecessary BorrowLoc] Can the logic that decides whether to introduce BorrowLoc be bypassed to generate references where values are expected, violating type safety? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_89b25ed1-0e46-4fe2-8788-b9b39e9d4d1f?mode=deep",
    "timestamp": "2026-01-23 03:54:42.361236",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_escape_auto_ref_arg()] [Reference leakage] Can forced temporary creation with with_forced_temp cause reference escapes from reference mode that violate borrow checker invariants? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_495e8c2d-e81b-4f99-b981-a8474a25aea7?mode=deep",
    "timestamp": "2026-01-23 03:55:10.048652",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_borrow()] [Deref-Borrow optimization bypass] Does the Borrow(Deref(x)) => x optimization properly check reference kinds match, or can it generate incorrect borrows? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_6c1e196b-1af1-406c-a44a-2223a70a0841?mode=deep",
    "timestamp": "2026-01-23 03:55:38.191390",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_borrow_field()] [Recursive field access] For deeply nested field selections, can stack depth limits be exceeded causing compilation failures or incorrect bytecode? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5ac49e49-db2a-48aa-b808-117bdbaafb9a?mode=deep",
    "timestamp": "2026-01-23 03:56:06.346529",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_arg_list()] [Evaluation order violation] Does left-to-right argument evaluation hold for all expression types, or can side-effecting expressions be reordered causing semantic bugs? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_aa77554c-c91c-4596-bf19-cd1e8cdc80f0?mode=deep",
    "timestamp": "2026-01-23 03:56:34.679346",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_arg_list()] [Last arg optimization bypass] Can the special handling of last arg to avoid temp creation cause issues if the last arg needs forced evaluation for correctness? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b4054b33-ead4-4ec7-919e-54754ddd08ec?mode=deep",
    "timestamp": "2026-01-23 03:57:03.485790",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_arg()] [Select in reference mode] When Operation::Select appears in reference mode, can the special reference-to-field logic cause type confusion between field value and field reference? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_ade5eba2-3791-4a9f-83c9-af86f9281035?mode=deep",
    "timestamp": "2026-01-23 03:57:33.056997",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: gen_tuple()] [Tuple flattening bypass] Can non-Tuple expressions with tuple types bypass proper temp allocation, causing incorrect tuple handling in bytecode? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d7665afc-2ebd-44d8-a553-390fa7884252?mode=deep",
    "timestamp": "2026-01-23 03:58:01.523263",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/bytecode_generator.rs] [Function: new_label()] [Label exhaustion] When label_counter reaches u16::MAX, does the error handling prevent label reuse, or can label collision cause incorrect control flow? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_168e4afd-980c-41db-9e20-7ec6e9dc1058?mode=deep",
    "timestamp": "2026-01-23 03:58:27.924411",
    "report_generated": false
  }
]