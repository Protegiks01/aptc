[
  {
    "question": "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Type: TypeVar_] [Type variable shadowing] Can inner type variables shadow outer ones with same name but different constraints, causing type inference errors? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5898f531-3e6c-4766-ad2e-72229c02b72f?mode=deep",
    "timestamp": "2026-01-25 18:31:02.166533",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/third_party/move/\n\n### Citations\n\n**File:** third_party/move/move-ir/types/src/ast.rs (L1-1819)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    location::*,\n    spec_language_ast::{Condition, Invariant, SyntheticDefinition},\n};\nuse move_core_types::{\n    account_address::AccountAddress, identifier::Identifier, int256, language_storage::ModuleId,\n    value::MoveValue,\n};\nuse move_symbol_pool::Symbol;\nuse once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::{BTreeSet, HashSet, VecDeque},\n    fmt,\n};\n//**************************************************************************************************\n// Program\n//**************************************************************************************************\n\n#[derive(Debug, Clone)]\n/// A set of Move modules and a Move transaction script\npub struct Program {\n    /// The modules to publish\n    pub modules: Vec<ModuleDefinition>,\n    /// The transaction script to execute\n    pub script: Script,\n}\n\n//**************************************************************************************************\n// ScriptOrModule\n//**************************************************************************************************\n\n#[derive(Debug, Clone)]\n/// A script or a module, used to represent the two types of transactions.\npub enum ScriptOrModule {\n    /// The script to execute.\n    Script(Script),\n    /// The module to publish.\n    Module(ModuleDefinition),\n}\n\n//**************************************************************************************************\n// Script\n//**************************************************************************************************\n\n#[derive(Debug, Clone)]\n/// The Move transaction script to be executed\npub struct Script {\n    /// The source location for this script\n    pub loc: Loc,\n    /// The dependencies of `main`, i.e. of the transaction script\n    pub imports: Vec<ImportDefinition>,\n    /// Explicit declaration of dependencies. If not provided, will be inferred based on given\n    /// dependencies to the IR compiler\n    pub explicit_dependency_declarations: Vec<ModuleDependency>,\n    /// the constants that the module defines. Only a utility, the identifiers are not carried into\n    /// the Move bytecode\n    pub constants: Vec<Constant>,\n    /// The transaction script's `main` procedure\n    pub main: Function,\n}\n\n//**************************************************************************************************\n// Modules\n//**************************************************************************************************\n\n/// Newtype for a name of a module\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct ModuleName(pub Symbol);\n\n/// Newtype of the address + the module name\n/// `addr.m`\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct ModuleIdent {\n    /// Name for the module. Will be unique among modules published under the same address\n    pub name: ModuleName,\n    /// Address that this module is published under\n    pub address: AccountAddress,\n}\n\n/// A Move module\n#[derive(Clone, Debug, PartialEq)]\npub struct ModuleDefinition {\n    /// The location of this module\n    pub loc: Loc,\n    /// name and address of the module\n    pub identifier: ModuleIdent,\n    /// the module's friends\n    pub friends: Vec<ModuleIdent>,\n    /// the module's dependencies\n    pub imports: Vec<ImportDefinition>,\n    /// Explicit declaration of dependencies. If not provided, will be inferred based on given\n    /// dependencies to the IR compiler\n    pub explicit_dependency_declarations: Vec<ModuleDependency>,\n    /// the structs (including resources) that the module defines\n    pub structs: Vec<StructDefinition>,\n    /// the constants that the script defines. Only a utility, the identifiers are not carried into\n    /// the Move bytecode\n    pub constants: Vec<Constant>,\n    /// the procedure that the module defines\n    pub functions: Vec<(FunctionName, Function)>,\n    /// the synthetic, specification variables the module defines.\n    pub synthetics: Vec<SyntheticDefinition>,\n}\n\n/// Explicitly given dependency\n#[derive(Clone, Debug, PartialEq)]\npub struct ModuleDependency {\n    /// Qualified identifer of the dependency\n    pub name: ModuleName,\n    /// The structs (including resources) that the dependency defines\n    pub structs: Vec<StructDependency>,\n    /// The signatures of functions that the dependency defines\n    pub functions: Vec<FunctionDependency>,\n}\n\n//**************************************************************************************************\n// Imports\n//**************************************************************************************************\n\n/// A dependency/import declaration\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ImportDefinition {\n    /// the dependency\n    /// `addr.m`\n    pub ident: ModuleIdent,\n    /// the alias for that dependency\n    /// `m`\n    pub alias: ModuleName,\n}\n\n//**************************************************************************************************\n// Vars\n//**************************************************************************************************\n\n/// Newtype for a variable/local\n#[derive(Debug, PartialEq, Hash, Eq, Clone, Ord, PartialOrd)]\npub struct Var_(pub Symbol);\n\n/// The type of a variable with a location\npub type Var = Spanned<Var_>;\n\n/// New type that represents a type variable. Used to declare type formals & reference them.\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\npub struct TypeVar_(pub Symbol);\n\n/// The type of a type variable with a location.\npub type TypeVar = Spanned<TypeVar_>;\n\n//**************************************************************************************************\n// Abilities\n//**************************************************************************************************\n\n/// The abilities of a type. Analogous to `move_binary_format::file_format::Ability`.\n#[derive(Debug, Clone, Eq, Copy, Hash, Ord, PartialEq, PartialOrd)]\npub enum Ability {\n    /// Allows values of types with this ability to be copied\n    Copy,\n    /// Allows values of types with this ability to be dropped or if left in a local at return\n    Drop,\n    /// Allows values of types with this ability to exist inside a struct in global storage\n    Store,\n    /// Allows the type to serve as a key for global storage operations\n    Key,\n}\n//**************************************************************************************************\n// Types\n//**************************************************************************************************\n\n/// The type of a single value\n#[derive(Debug, PartialEq, Clone)]\npub enum Type {\n    /// `address`\n    Address,\n    /// `signer`\n    Signer,\n    /// `u8`\n    U8,\n    /// `u16`\n    U16,\n    /// `u32`\n    U32,\n    /// `u64`\n    U64,\n    /// `u128`\n    U128,\n    /// `u256`\n    U256,\n    /// `bool`\n    Bool,\n    /// `vector`\n    Vector(Box<Type>),\n    /// A module defined struct\n    Struct(QualifiedStructIdent, Vec<Type>),\n    /// A reference type, the bool flag indicates whether the reference is mutable\n    Reference(bool, Box<Type>),\n    /// A type parameter\n    TypeParameter(TypeVar_),\n}\n\n//**************************************************************************************************\n// Structs\n//**************************************************************************************************\n\n/// Identifier for a struct definition. Tells us where to look in the storage layer to find the\n/// code associated with the interface\n#[derive(Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct QualifiedStructIdent {\n    /// Module name and address in which the struct is contained\n    pub module: ModuleName,\n    /// Name for the struct class. Should be unique among structs published under the same\n    /// module+address\n    pub name: StructName,\n}\n\n/// The field newtype\n#[derive(Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct Field_(pub Symbol);\n\n/// A field coupled with source location information\npub type Field = Spanned<Field_>;\n\n/// A fully-qualified field identifier.\n///\n/// Rather than simply referring to a field `f` with a single identifier and\n/// relying on type inference to determine the type of the struct being\n/// accessed, this type refers to the field `f` on the explicit struct type\n/// `S<T>` -- that is, `S<T>::f`.\n#[derive(Clone, Debug, PartialEq)]\npub struct FieldIdent_ {\n    /// The name of the struct type on which the field is declared.\n    pub struct_name: StructName,\n    /// For generic struct types, the type parameters used to instantiate the\n    /// struct type (this is an empty vector for non-generic struct types).\n    pub type_actuals: Vec<Type>,\n    /// The name of the field.\n    pub field: Field,\n}\n\npub type FieldIdent = Spanned<FieldIdent_>;\n\n/// A field map\npub type Fields<T> = Vec<(Field, T)>;\n\n/// Newtype for the name of a struct\n#[derive(Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\npub struct StructName(pub Symbol);\n\n/// A struct type parameter with its constraints and whether it's declared as phantom.\npub type StructTypeParameter = (bool, TypeVar, BTreeSet<Ability>);\n\n/// A Move struct\n#[derive(Clone, Debug, PartialEq)]\npub struct StructDefinition_ {\n    /// The declared abilities for the struct\n    pub abilities: BTreeSet<Ability>,\n    /// Human-readable name for the struct that also serves as a nominal type\n    pub name: StructName,\n    /// The list of formal type arguments\n    pub type_formals: Vec<StructTypeParameter>,\n    /// the fields each instance has\n    pub fields: StructDefinitionFields,\n    /// the invariants for this struct\n    pub invariants: Vec<Invariant>,\n}\n/// The type of a StructDefinition along with its source location information\npub type StructDefinition = Spanned<StructDefinition_>;\n\n/// An explicit struct dependency\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct StructDependency {\n    /// The declared abilities for the struct\n    pub abilities: BTreeSet<Ability>,\n    /// Human-readable name for the struct that also serves as a nominal type\n    pub name: StructName,\n    /// The list of formal type arguments\n    pub type_formals: Vec<StructTypeParameter>,\n}\n\n/// The fields of a Move struct definition\n#[derive(Clone, Debug, PartialEq)]\npub enum StructDefinitionFields {\n    /// The fields are declared\n    Move { fields: Fields<Type> },\n    /// The struct is a type provided by the VM\n    Native,\n}\n\n//**************************************************************************************************\n// Structs\n//**************************************************************************************************\n\n/// Newtype for the name of a constant\n#[derive(Debug, Serialize, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Clone)]\npub struct ConstantName(pub Symbol);\n\n/// A constant declaration in a module or script\n#[derive(Clone, Debug, PartialEq)]\npub struct Constant {\n    /// The constant's name. Not carried through to the Move bytecode\n    pub name: ConstantName,\n    /// The type of the constant's value\n    pub signature: Type,\n    /// The constant's value\n    pub value: MoveValue,\n}\n\n//**************************************************************************************************\n// Functions\n//**************************************************************************************************\n\n/// Newtype for the name of a function\n#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Clone)]\npub struct FunctionName(pub Symbol);\n\n/// The signature of a function\n#[derive(PartialEq, Debug, Clone)]\npub struct FunctionSignature {\n    /// Possibly-empty list of (formal name, formal type) pairs. Names are unique.\n    pub formals: Vec<(Var, Type)>,\n    /// Optional return types\n    pub return_type: Vec<Type>,\n    /// Possibly-empty list of type parameters and their constraints\n    pub type_formals: Vec<(TypeVar, BTreeSet<Ability>)>,\n}\n\n/// An explicit function dependency\n#[derive(PartialEq, Debug, Clone)]\npub struct FunctionDependency {\n    /// Name of the function dependency\n    pub name: FunctionName,\n    /// Signature of the function dependency\n    pub signature: FunctionSignature,\n}\n\n/// Public or internal modifier for a procedure\n#[derive(PartialEq, Eq, Debug, Clone)]\npub enum FunctionVisibility {\n    /// The procedure can be invoked anywhere\n    /// `public`\n    Public,\n    /// The procedure can be invoked internally as well as by modules in the friend list\n    /// `public(friend)`\n    Friend,\n    /// The procedure can be invoked only internally\n    /// `<no modifier>`\n    Internal,\n}\n\n/// The body of a Move function\n#[derive(PartialEq, Debug, Clone)]\npub enum FunctionBody {\n    /// The body is declared\n    /// `locals` are all of the declared locals\n    /// `code` is the code that defines the procedure\n    Move {\n        locals: Vec<(Var, Type)>,\n        code: Vec<Block>,\n    },\n    Bytecode {\n        locals: Vec<(Var, Type)>,\n        code: BytecodeBlocks,\n    },\n    /// The body is provided by the runtime\n    Native,\n}\n\n/// A Move function/procedure\n#[derive(PartialEq, Debug, Clone)]\npub struct Function_ {\n    /// The visibility\n    pub visibility: FunctionVisibility,\n    /// Is entry function\n    pub is_entry: bool,\n    /// The type signature\n    pub signature: FunctionSignature,\n    /// List of nominal resources (declared in this module) that the procedure might access\n    /// Either through: BorrowGlobal, MoveFrom, or transitively through another procedure\n    /// This list of acquires grants the borrow checker the ability to statically verify the safety\n    /// of references into global storage\n    pub acquires: Vec<StructName>,\n    /// List of specifications for the Move prover (experimental)\n    pub specifications: Vec<Condition>,\n    /// The code for the procedure\n    pub body: FunctionBody,\n}\n\n/// The type of a Function coupled with its source location information.\npub type Function = Spanned<Function_>;\n\n//**************************************************************************************************\n// Statements\n//**************************************************************************************************\n\n/// Builtin",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_7f3e7646-6901-4f49-998e-38fd957f6ad8?mode=deep",
    "timestamp": "2026-01-25 18:31:14.639301",
    "report_generated": false
  }
]