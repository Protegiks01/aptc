[
  {
    "question": "[File: aptos-core/config/src/config/quorum_store_config.rs] [Function: Default::default()] [Magic numbers] Many defaults are unexplained magic numbers (e.g., backlog_txn_limit_count: 36_000) - can lack of documentation lead to operators setting wrong values? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_ba37f023-334a-4c98-89ad-9aceb586c933?mode=deep",
    "timestamp": "2026-01-26 22:15:04.977840",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/config/src/config/quorum_store_config.rs] [Line 115] [Subtraction underflow] sender_max_batch_bytes calculation '1024 * 1024 - BATCH_PADDING_BYTES' can underflow if BATCH_PADDING_BYTES > 1MB, wrapping to huge value - is this checked? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_1dd6fedb-d3a4-466e-9759-bc22ac0983bd?mode=deep",
    "timestamp": "2026-01-26 22:15:18.149288",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/config/src/config/quorum_store_config.rs] [Line 119] [Multiplication overflow] sender_max_total_bytes calculation '4 * 1024 * 1024 - DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES' - can the multiplication overflow before subtraction? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_634fc92a-251f-44de-97e9-0863212cf7c9?mode=deep",
    "timestamp": "2026-01-26 22:15:31.749545",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/config/\n\n### Citations\n\n**File:** config/src/config/quorum_store_config.rs (L1-467)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::config::{\n    config_sanitizer::ConfigSanitizer, node_config_loader::NodeType, Error, NodeConfig,\n};\nuse aptos_global_constants::DEFAULT_BUCKETS;\nuse aptos_types::chain_id::ChainId;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\npub const BATCH_PADDING_BYTES: usize = 160;\npub const DEFEAULT_MAX_BATCH_TXNS: usize = 50;\nconst DEFAULT_MAX_NUM_BATCHES: usize = 10;\n\n#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(default, deny_unknown_fields)]\npub struct QuorumStoreBackPressureConfig {\n    pub backlog_txn_limit_count: u64,\n    pub backlog_per_validator_batch_limit_count: u64,\n    pub decrease_duration_ms: u64,\n    pub increase_duration_ms: u64,\n    pub decrease_fraction: f64,\n    pub dynamic_min_txn_per_s: u64,\n    pub dynamic_max_txn_per_s: u64,\n    pub additive_increase_when_no_backpressure: u64,\n}\n\nimpl Default for QuorumStoreBackPressureConfig {\n    fn default() -> QuorumStoreBackPressureConfig {\n        QuorumStoreBackPressureConfig {\n            // QS will be backpressured if the remaining total txns is more than this number\n            // Roughly, target TPS * commit latency seconds\n            backlog_txn_limit_count: 36_000,\n            // QS will create batches at the max rate until this number is reached\n            backlog_per_validator_batch_limit_count: 20,\n            decrease_duration_ms: 1000,\n            increase_duration_ms: 1000,\n            decrease_fraction: 0.5,\n            dynamic_min_txn_per_s: 160,\n            dynamic_max_txn_per_s: 12000,\n            // When the QS is no longer backpressured, we increase number of txns to be pulled from mempool\n            // by this amount every second until we reach dynamic_max_txn_per_s\n            additive_increase_when_no_backpressure: 2000,\n        }\n    }\n}\n\n#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]\n#[serde(default, deny_unknown_fields)]\npub struct QuorumStoreConfig {\n    pub channel_size: usize,\n    pub proof_timeout_ms: usize,\n    pub batch_generation_poll_interval_ms: usize,\n    pub batch_generation_min_non_empty_interval_ms: usize,\n    pub batch_generation_max_interval_ms: usize,\n    /// The maximum number of transactions that the batch generator puts in a batch.\n    pub sender_max_batch_txns: usize,\n    /// The maximum number of bytes that the batch generator puts in a batch.\n    pub sender_max_batch_bytes: usize,\n    /// The maximum number of batches that the batch generator creates every time it pull transactions\n    /// from the mempool. This is NOT the maximum number of batches that the batch generator can create\n    /// per second.\n    pub sender_max_num_batches: usize,\n    /// The maximum number of transactions that the batch generator pulls from the mempool at a time.\n    /// After the transactions are pulled, the batch generator splits them into multiple batches. This is NOT\n    /// the maximum number of transactions the batch generator includes in batches per second.\n    pub sender_max_total_txns: usize,\n    /// The maximum number of bytes that the batch generator pulls from the mempool at a time. This is NOT\n    /// the maximum number of bytes the batch generator includes in batches per second.\n    pub sender_max_total_bytes: usize,\n    /// The maximum number of transactions a single batch received from peers could contain.\n    pub receiver_max_batch_txns: usize,\n    /// The maximum number of bytes a single batch received from peers could contain.\n    pub receiver_max_batch_bytes: usize,\n    /// The maximum number of batches a BatchMsg received from peers can contain.\n    pub receiver_max_num_batches: usize,\n    /// The maximum number of transactions a BatchMsg received from peers can contain. Each BatchMsg can contain\n    /// multiple batches.\n    pub receiver_max_total_txns: usize,\n    /// The maximum number of bytes a BatchMsg received from peers can contain. Each BatchMsg can contain\n    /// multiple batches.\n    pub receiver_max_total_bytes: usize,\n    pub batch_request_num_peers: usize,\n    pub batch_request_retry_limit: usize,\n    pub batch_request_retry_interval_ms: usize,\n    pub batch_request_rpc_timeout_ms: usize,\n    /// Duration for expiring locally created batches.\n    pub batch_expiry_gap_when_init_usecs: u64,\n    /// Duration for expiring remotely created batches. The txns are filtered to prevent dupliation across validators.\n    pub remote_batch_expiry_gap_when_init_usecs: u64,\n    pub memory_quota: usize,\n    pub db_quota: usize,\n    pub batch_quota: usize,\n    pub back_pressure: QuorumStoreBackPressureConfig,\n    pub num_workers_for_remote_batches: usize,\n    pub batch_buckets: Vec<u64>,\n    pub allow_batches_without_pos_in_proposal: bool,\n    pub enable_opt_quorum_store: bool,\n    pub opt_qs_minimum_batch_age_usecs: u64,\n    pub enable_payload_v2: bool,\n    pub enable_batch_v2: bool,\n}\n\nimpl Default for QuorumStoreConfig {\n    fn default() -> QuorumStoreConfig {\n        QuorumStoreConfig {\n            channel_size: 1000,\n            proof_timeout_ms: 10000,\n            batch_generation_poll_interval_ms: 25,\n            batch_generation_min_non_empty_interval_ms: 50,\n            batch_generation_max_interval_ms: 250,\n            sender_max_batch_txns: DEFEAULT_MAX_BATCH_TXNS,\n            // TODO: on next release, remove BATCH_PADDING_BYTES\n            sender_max_batch_bytes: 1024 * 1024 - BATCH_PADDING_BYTES,\n            sender_max_num_batches: DEFAULT_MAX_NUM_BATCHES,\n            sender_max_total_txns: 1500,\n            // TODO: on next release, remove DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES\n            sender_max_total_bytes: 4 * 1024 * 1024 - DEFAULT_MAX_NUM_BATCHES * BATCH_PADDING_BYTES,\n            receiver_max_batch_txns: 100,\n            receiver_max_batch_bytes: 1024 * 1024 + BATCH_PADDING_BYTES,\n            receiver_max_num_batches: 20,\n            receiver_max_total_txns: 2000,\n            receiver_max_total_bytes: 4 * 1024 * 1024\n                + DEFAULT_MAX_NUM_BATCHES\n                + BATCH_PADDING_BYTES,\n            batch_request_num_peers: 5,\n            batch_request_retry_limit: 10,\n            batch_request_retry_interval_ms: 500,\n            batch_request_rpc_timeout_ms: 5000,\n            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,\n            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,\n            memory_quota: 120_000_000,\n            db_quota: 300_000_000,\n            batch_quota: 300_000,\n            back_pressure: QuorumStoreBackPressureConfig::default(),\n            // number of batch coordinators to handle QS batch messages, should be >= 1\n            num_workers_for_remote_batches: 10,\n            batch_buckets: DEFAULT_BUCKETS.to_vec(),\n            allow_batches_without_pos_in_proposal: true,\n            enable_opt_quorum_store: true,\n            opt_qs_minimum_batch_age_usecs: Duration::from_millis(50).as_micros() as u64,\n            enable_payload_v2: false,\n            enable_batch_v2: false,\n        }\n    }\n}\n\nimpl QuorumStoreConfig {\n    /// Since every validator can contribute to every round, the quorum store\n    /// batches should be small enough to fit in a DAG node. And, since proof\n    /// broadcasting is disabled, Quorum Store needs to create only enough\n    /// batches to fit the self proposed nodes. These configs below reflect\n    /// this behavior.\n    pub fn default_for_dag() -> Self {\n        Self {\n            sender_max_batch_txns: 300,\n            sender_max_batch_bytes: 4 * 1024 * 1024,\n            sender_max_num_batches: 5,\n            sender_max_total_txns: 500,\n            sender_max_total_bytes: 8 * 1024 * 1024,\n            receiver_max_batch_txns: 300,\n            receiver_max_batch_bytes: 4 * 1024 * 1024,\n            receiver_max_num_batches: 5,\n            receiver_max_total_txns: 500,\n            receiver_max_total_bytes: 8 * 1024 * 1024,\n            back_pressure: QuorumStoreBackPressureConfig {\n                backlog_txn_limit_count: 100000,\n                backlog_per_validator_batch_limit_count: 20,\n                dynamic_min_txn_per_s: 100,\n                dynamic_max_txn_per_s: 200,\n                ..Default::default()\n            },\n            ..Default::default()\n        }\n    }\n\n    fn sanitize_send_recv_batch_limits(\n        sanitizer_name: &str,\n        config: &QuorumStoreConfig,\n    ) -> Result<(), Error> {\n        let send_recv_pairs = [\n            (\n                config.sender_max_batch_txns,\n                config.receiver_max_batch_txns,",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_245751be-35fa-4796-b08e-ad99256552c7?mode=deep",
    "timestamp": "2026-01-26 22:15:46.414533",
    "report_generated": false
  }
]