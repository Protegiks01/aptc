[
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_constant()] [Constant visibility] Can constants from other modules be accessed even when they should be private, bypassing module encapsulation? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b1d8b353-bdad-4685-94e1-4e897f4cf375?mode=deep",
    "timestamp": "2026-01-23 21:53:08.266394",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_name() - spec vars] [Ghost memory access] Does spec variable translation through ghost memory properly isolate ghost state from execution state, or can they interact in unsafe ways? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_bf6b3074-f73b-4b55-a602-ecea465730f0?mode=deep",
    "timestamp": "2026-01-23 21:53:20.470580",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_name() - inline functions] [Inline expansion safety] Does inline function handling prevent recursive inline expansion that could cause infinite loop or stack overflow? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_29383a58-ea82-4898-ad54-4d86e5b6b43b?mode=deep",
    "timestamp": "2026-01-23 21:53:33.224097",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_special_function_name()] [Lambda wrapper safety] Can the lambda wrapper for special vector functions capture incorrect context or have wrong variance, causing type safety violations? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_8427ad12-52d8-4643-bc1d-97a7bbc5fe65?mode=deep",
    "timestamp": "2026-01-23 21:53:46.464268",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - had_errors] [Error state corruption] Can the RefCell-wrapped had_errors flag be borrowed mutably in nested contexts, causing panic or leaving translator in inconsistent state? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9c5a24ba-ae7f-4bd3-bf03-c134dad352e0?mode=deep",
    "timestamp": "2026-01-23 21:54:01.463996",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: new_error_exp()] [Error propagation] Do error expressions properly poison type checking, or can they unify with any type, potentially hiding security-critical type errors? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_6204010f-78d5-4b61-89e9-bb1aae594f60?mode=deep",
    "timestamp": "2026-01-23 21:54:16.734641",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: report_unification_error()] [Error message injection] Can malformed type names in error messages cause terminal escape sequence injection or other information disclosure? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_434c648f-55f7-4a0a-ae95-0deff5dd3a71?mode=deep",
    "timestamp": "2026-01-23 21:54:32.359153",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: error_with_notes_and_labels()] [Error accumulation] Can excessive errors accumulate unbounded, causing memory exhaustion when malformed code generates thousands of cascading errors? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0df61aa1-bb88-4517-ab66-529db09e8275?mode=deep",
    "timestamp": "2026-01-23 21:54:49.507686",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_call() - inline variance] [Variance violation] Does inline function variance checking properly prevent covariant/contravariant misuse that could allow invalid type substitutions? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_08bb77a5-4a36-440a-be31-d5e71bd94a57?mode=deep",
    "timestamp": "2026-01-23 21:55:07.378911",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - fun_is_inline field] [Inline state tracking] Can fun_is_inline state become stale during nested function translation, causing variance to be incorrectly computed for nested calls? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_108fd5a8-2105-4b2e-93c1-0e59ed859542?mode=deep",
    "timestamp": "2026-01-23 21:55:26.274670",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_fun_call_special_cases() - function pointers] [Function pointer safety] Can function pointer table entries be corrupted, causing invocation to call wrong function with incompatible signature? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0e087009-8ac9-4ddd-85d8-1090c48eb3cd?mode=deep",
    "timestamp": "2026-01-23 21:55:44.578408",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - called_spec_funs] [Spec function tracking] Can the called_spec_funs set be manipulated to hide spec function calls, causing verification to miss critical specifications? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_e80d8abb-318e-4746-98e9-32be58b75a59?mode=deep",
    "timestamp": "2026-01-23 21:56:05.144623",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_macro_call()] [Macro expansion safety] Does macro expansion properly prevent recursive or deeply nested macros from causing stack overflow or exponential expansion? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b081ded0-1a8b-4b24-8f39-61988668d1fd?mode=deep",
    "timestamp": "2026-01-23 21:56:26.860826",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_macro_call() - type arguments] [Macro type confusion] Can macros that shouldn't accept type arguments be given type arguments through parsing ambiguities, causing type confusion? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f55957e0-e64f-4e2c-b022-e42b5b1e0f3e?mode=deep",
    "timestamp": "2026-01-23 21:56:49.377724",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: expand_macro()] [Macro hygiene] Does macro expansion maintain proper hygiene, or can expanded macro code capture variables from the call site that should be inaccessible? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_72dbbade-0382-4e6d-bf67-9e3d3cb64c66?mode=deep",
    "timestamp": "2026-01-23 21:57:11.900327",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_fun_call() - old handling] [Temporal logic bypass] Can nested old() expressions bypass the InsideOld check through indirect function calls, allowing invalid temporal references? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b79e4afb-1408-48ac-9cb2-cf653801df92?mode=deep",
    "timestamp": "2026-01-23 21:57:35.343325",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: OldExpStatus] [Old status tracking] Can old_status state machine be corrupted through exception paths or early returns, leaving status in InsideOld when it should be OutsideOld? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_3184bfc4-9dae-4bd3-9393-2db86a11a0eb?mode=deep",
    "timestamp": "2026-01-23 21:57:59.927645",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: lookup_local() - old parameter] [Old variable access] Does old parameter tracking properly prevent accessing mutable variables in old context, which could violate snapshot semantics? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2210f96a-72f1-42b2-9a37-fb3a9a0887da?mode=deep",
    "timestamp": "2026-01-23 21:58:25.313598",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Trait: AbilityContext - struct_signature()] [Ability inference] Can ability inference for struct instantiation produce weaker abilities than required, allowing structs without 'key' to be treated as resources? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4e257090-b74f-463b-b31a-92ba1d2e30a0?mode=deep",
    "timestamp": "2026-01-23 21:58:51.200693",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: add_type_param_constraints() - spec mode] [Spec mode bypass] Does spec mode skip ability constraints that are security-critical, allowing specs to assume abilities that aren't actually present? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_adab7ae6-13f0-41b3-a1c7-94349d95b407?mode=deep",
    "timestamp": "2026-01-23 21:59:16.861622",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_type() - vector constraints] [Vector ability propagation] Are ability constraints properly propagated to vector element types, or can vectors of non-storable types be created? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a6caa179-c29c-4c17-b010-e48d014ec6a7?mode=deep",
    "timestamp": "2026-01-23 21:59:42.156557",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Cast] [Cast safety] Does cast operation properly restrict conversions to numeric types only, or can casts be used to reinterpret bit patterns of arbitrary types? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_8f99107a-cb1a-485d-813e-369f524c2bfa?mode=deep",
    "timestamp": "2026-01-23 22:00:07.904703",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Cast constraint] [Cast domain] Can cast operations accept source types that aren't actually numbers, such as addresses or bools, causing invalid conversions? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b22f5c5d-2296-4581-86b4-27ccc98ee823?mode=deep",
    "timestamp": "2026-01-23 22:00:34.294181",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Annotate] [Type annotation override] Can type annotations force incorrect types on expressions, bypassing normal type inference and creating type confusion? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_469f9a58-b588-4677-8a17-6d77e46319e6?mode=deep",
    "timestamp": "2026-01-23 22:00:59.495735",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Return] [Return type mismatch] Can return expressions in lambdas vs functions get confused, causing wrong result_type to be validated and allowing type mismatches? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f72b82f9-27ee-4162-b420-03f8917f5735?mode=deep",
    "timestamp": "2026-01-23 22:01:24.350083",
    "report_generated": false
  }
]