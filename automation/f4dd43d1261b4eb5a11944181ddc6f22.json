[
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Atomicity: Multiple fields] [Inconsistent state] Can last_consecutive_success_count at line 66 and window at line 73 be updated non-atomically, causing get_params() to see mismatched values? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5b910a23-bd3f-44e1-86c7-ab444ac89f8f?mode=deep",
    "timestamp": "2026-01-27 02:19:37.785922",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Synchronization: Mutex ordering] [Deadlock] Can multiple Mutex locks be acquired in different orders across consensus components, potentially causing deadlocks when both push() and get_params() are called concurrently? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2b28d608-3ac0-415e-ad1f-576f259e85c6?mode=deep",
    "timestamp": "2026-01-27 02:19:50.593030",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Synchronization: Arc cloning] [Reference leak] Can excessive Arc::clone() operations on failure_tracker at line 122 cause reference count overflow, preventing proper cleanup? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a0f86329-1b7f-4c44-a908-96390a04b73d?mode=deep",
    "timestamp": "2026-01-27 02:20:03.572080",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: max_window bounds] [Invalid configuration] Can max_window be configured to 0 or 1 at line 42, breaking the exponential backoff algorithm since window starts at 2? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_08f3c5c8-427d-419c-85cf-0f3764fc6f5e?mode=deep",
    "timestamp": "2026-01-27 02:20:17.260416",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: enable_opt_qs toggle] [Runtime disable] If enable_opt_qs is changed from true to false at runtime at line 129, does this permanently disable OptQS even if failures were temporary? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_5f297083-6445-4180-b55e-4582aae79598?mode=deep",
    "timestamp": "2026-01-27 02:20:31.672881",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: minimum_batch_age_usecs] [Time manipulation] Can minimum_batch_age_usecs be set to 0 at line 158, bypassing the batch age requirement and allowing premature batch proposals? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_66066eac-bab5-44db-ba12-c5aab55c7c59?mode=deep",
    "timestamp": "2026-01-27 02:20:47.169371",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: ordered_authors update] [Epoch transition] During epoch transitions when validator set changes, can ordered_authors become stale, causing get_exclude_authors() to exclude wrong validators? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_75c49992-8608-4ab1-ad82-1a196664fa28?mode=deep",
    "timestamp": "2026-01-27 02:21:03.828659",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: Conflicting settings] [Misconfiguration] Can enable_opt_qs=true but max_window=1 create conflicting configuration where OptQS is enabled but immediately disabled on first failure? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_c761bf11-4351-4d2a-bd7f-118654f79cf9?mode=deep",
    "timestamp": "2026-01-27 02:21:22.548481",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: ordered_authors staleness] [Validator mismatch] If ordered_authors at line 45 is not updated during epoch transitions, can author_idx at line 90 map to validators from the previous epoch, incorrectly excluding new validators? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2bcc0205-2988-421d-9b50-d194b4ece5e5?mode=deep",
    "timestamp": "2026-01-27 02:21:41.093604",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: State reset] [History loss] Should past_round_statuses be cleared at line 33 during epoch transitions, or can stale data from previous epochs affect OptQS decisions in the new epoch? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_030f3d9b-aa43-46f6-8ce1-555ab6ef2d3a?mode=deep",
    "timestamp": "2026-01-27 02:22:02.011311",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: Window persistence] [Configuration carry-over] Should window be reset to 2 at line 41 during epoch transitions, or can a large window from previous epoch unfairly disable OptQS for new validators? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9bfe3db2-3753-4ec3-942a-f63099c67626?mode=deep",
    "timestamp": "2026-01-27 02:22:24.110700",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: Concurrent updates] [Race during transition] Can ordered_authors be updated at line 45 concurrently with get_exclude_authors() accessing it at line 90, causing index mismatches? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2fe1a05c-888a-4971-9575-16c7b441458a?mode=deep",
    "timestamp": "2026-01-27 02:22:47.319449",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: BitVec size change] [Size mismatch] If validator set size changes between epochs, can missing_authors BitVec size at line 86 become inconsistent with new ordered_authors length? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4c4dae2d-a011-4582-bb96-1178179ad993?mode=deep",
    "timestamp": "2026-01-27 02:23:10.604949",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_\n\n### Citations\n\n**File:** consensus/src/liveness/proposal_status_tracker.rs (L1-232)\n```rust\n// Copyright (c) Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse super::round_state::NewRoundReason;\nuse crate::counters;\nuse aptos_collections::BoundedVecDeque;\nuse aptos_consensus_types::{\n    common::Author, payload_pull_params::OptQSPayloadPullParams, round_timeout::RoundTimeoutReason,\n};\nuse aptos_infallible::Mutex;\nuse aptos_logger::warn;\nuse aptos_short_hex_str::AsShortHexStr;\nuse std::{collections::HashSet, sync::Arc};\n\npub trait TPastProposalStatusTracker: Send + Sync {\n    fn push(&self, status: NewRoundReason);\n}\n\npub trait TOptQSPullParamsProvider: Send + Sync {\n    fn get_params(&self) -> Option<OptQSPayloadPullParams>;\n}\n\n/// A exponential window based algorithm to decide whether to go optimistic or not, based on\n/// configurable number of past proposal statuses\n///\n/// Initialize the window at 2.\n/// - For each proposal failure, double the window up to a MAX size\n/// - If there are no failures within the window, then propose optimistic batch\n/// - If there are no failures up to MAX proposals, reset the window to 2.\npub struct ExponentialWindowFailureTracker {\n    window: usize,\n    max_window: usize,\n    past_round_statuses: BoundedVecDeque<NewRoundReason>,\n    last_consecutive_success_count: usize,\n    ordered_authors: Vec<Author>,\n}\n\nimpl ExponentialWindowFailureTracker {\n    pub(crate) fn new(max_window: usize, ordered_authors: Vec<Author>) -> Self {\n        Self {\n            window: 2,\n            max_window,\n            past_round_statuses: BoundedVecDeque::new(max_window),\n            last_consecutive_success_count: 0,\n            ordered_authors,\n        }\n    }\n\n    pub(crate) fn push(&mut self, status: NewRoundReason) {\n        self.past_round_statuses.push_back(status);\n        self.compute_failure_window();\n    }\n\n    fn last_consecutive_statuses_matching<F>(&self, matcher: F) -> usize\n    where\n        F: Fn(&NewRoundReason) -> bool,\n    {\n        self.past_round_statuses\n            .iter()\n            .rev()\n            .take_while(|reason| matcher(reason))\n            .count()\n    }\n\n    fn compute_failure_window(&mut self) {\n        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {\n            !matches!(\n                reason,\n                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })\n            )\n        });\n        if self.last_consecutive_success_count == 0 {\n            self.window *= 2;\n            self.window = self.window.min(self.max_window);\n        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {\n            self.window = 2;\n        }\n    }\n\n    fn get_exclude_authors(&self) -> HashSet<Author> {\n        let mut exclude_authors = HashSet::new();\n\n        let limit = self.window;\n        for round_reason in self.past_round_statuses.iter().rev().take(limit) {\n            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {\n                missing_authors,\n            }) = round_reason\n            {\n                for author_idx in missing_authors.iter_ones() {\n                    if let Some(author) = self.ordered_authors.get(author_idx) {\n                        exclude_authors.insert(*author);\n                    }\n                }\n            }\n        }\n\n        exclude_authors\n    }\n}\n\nimpl TPastProposalStatusTracker for Mutex<ExponentialWindowFailureTracker> {\n    fn push(&self, status: NewRoundReason) {\n        self.lock().push(status)\n    }\n}\n\npub struct OptQSPullParamsProvider {\n    enable_opt_qs: bool,\n    minimum_batch_age_usecs: u64,\n    failure_tracker: Arc<Mutex<ExponentialWindowFailureTracker>>,\n}\n\nimpl OptQSPullParamsProvider {\n    pub fn new(\n        enable_opt_qs: bool,\n        minimum_batch_age_usecs: u64,\n        failure_tracker: Arc<Mutex<ExponentialWindowFailureTracker>>,\n    ) -> Self {\n        Self {\n            enable_opt_qs,\n            minimum_batch_age_usecs,\n            failure_tracker,\n        }\n    }\n}\n\nimpl TOptQSPullParamsProvider for OptQSPullParamsProvider {\n    fn get_params(&self) -> Option<OptQSPayloadPullParams> {\n        if !self.enable_opt_qs {\n            return None;\n        }\n\n        let tracker = self.failure_tracker.lock();\n\n        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT\n            .observe(tracker.last_consecutive_success_count as f64);\n        if tracker.last_consecutive_success_count < tracker.window {\n            warn!(",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_79081120-7250-4d6b-b983-0abcd934897d?mode=deep",
    "timestamp": "2026-01-27 02:23:36.057131",
    "report_generated": false
  }
]