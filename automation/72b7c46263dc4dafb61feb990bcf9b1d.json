[
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Same kind exemption] At lines 1781-1783, sibling edges of the same Call kind are exempted - can this be abused by creating calls that return multiple references to the same location, then freezing one while keeping others mutable? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_3f6e306c-691a-451b-83ef-0744dd7254b9?mode=deep",
    "timestamp": "2026-01-23 06:37:17.728201",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Derived temps exclusion] Lines 1814-1873 exclude derived temps from the mutable reference check - can manipulating the derived_from map allow freezing while mutable references exist? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d3ecc4cf-e144-4902-a5c8-13f265452b43?mode=deep",
    "timestamp": "2026-01-23 06:37:30.724236",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Transitive children bypass] At lines 1822-1823, transitive children of the label are checked - but can non-transitive mutable borrows (siblings of ancestors) escape this check? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_bc656aae-0a5f-4d0e-be42-8424fde46978?mode=deep",
    "timestamp": "2026-01-23 06:37:44.090040",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: assign()] [Inferred assignment confusion] The AssignKind::Inferred logic at lines 1534-1542 decides between move and copy based on heuristics - can edge cases cause incorrect classification, allowing move of a borrowed value? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d7443f49-c799-4306-802d-a964cf30854c?mode=deep",
    "timestamp": "2026-01-23 06:37:58.969922",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: move_ref()] [Label transfer race] At lines 790-796, the label is removed from src and added to dest non-atomically - can this create a window where neither temp owns the label? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9298f2f4-6bbe-4ae0-9ba1-48b39dc07cd5?mode=deep",
    "timestamp": "2026-01-23 06:38:13.937657",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: copy_ref()] [Derived marking bypass] Copy_ref at lines 800-805 marks the destination as derived from source - but can this marking be lost during graph joins, causing the copied ref to bypass v1 semantics checks? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_318c74b9-d0d8-4f6b-9ac6-b2fdeab4c3db?mode=deep",
    "timestamp": "2026-01-23 06:38:30.384337",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: replace_ref()] [Non-release on borrowed] Replace_ref at lines 775-787 releases the old reference, but what if it's still borrowed? Can this cause the borrow graph to incorrectly drop active borrow edges? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b01343b4-377d-4e13-bb26-6b6a477568fa?mode=deep",
    "timestamp": "2026-01-23 06:38:47.580773",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [Parameter index bypass] At line 1915, the check is `local >= get_parameter_count()` - can off-by-one errors or incorrect parameter indexing allow returning references to locals? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_b284787f-7ee0-4a05-a666-fe3472abecc3?mode=deep",
    "timestamp": "2026-01-23 06:39:07.127701",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [Root confusion] The roots() call at line 1902 finds ancestors - can a graph structure with multiple roots cause some to be missed, allowing return of global-derived references? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_cbcc2977-8b4a-4d71-9626-30a925be034b?mode=deep",
    "timestamp": "2026-01-23 06:39:28.282141",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [External bypass] At line 1927, External and Derived locations are exempted - can all references be marked as External through manipulation, bypassing all return restrictions? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_54bca2e1-2619-49ac-be48-ffd66aec5d28?mode=deep",
    "timestamp": "2026-01-23 06:39:50.183492",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: read_ref()] [Missing safety check] Read_ref at lines 1937-1942 doesn't call check_borrow_safety - can reading through a reference violate safety if the graph is in an unsafe state? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9fdca22c-956f-4d99-97db-b4651fd6002e?mode=deep",
    "timestamp": "2026-01-23 06:40:12.892130",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: write_ref()] [Insufficient borrow check] Write_ref at lines 1945-1958 only checks if dest has children, not if it's part of an unsafe borrow pattern - can this allow writes that violate borrow safety? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d4887968-001e-4550-9cc1-69252b04cdf8?mode=deep",
    "timestamp": "2026-01-23 06:40:38.185737",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: move_from()] [Resource extraction race] The move_from check at lines 1878-1893 verifies no borrows exist, but can concurrent operations create borrows after the check but before extraction? (Note: This is a compiler, not runtime, so probably not applicable) (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_af2ec8f0-7eaa-48c3-a927-4771c4a9831c?mode=deep",
    "timestamp": "2026-01-23 06:41:05.063933",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: could_overlap()] [Field overlap logic] The overlap check at lines 258-264 only considers field identity - can different paths to the same field through generic type instantiation bypass this check? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_a2cac06f-080d-4978-b43d-7073f720a0b0?mode=deep",
    "timestamp": "2026-01-23 06:41:33.350529",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: any_could_overlap()] [Short-circuit bypass] At lines 267-270, if any pair overlaps the function returns true - but can the cartesian product logic miss overlaps due to set ordering? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9dd581d3-a81a-4035-8744-b480e1a0f742?mode=deep",
    "timestamp": "2026-01-23 06:42:01.768451",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: is_mut()] [Edge kind checking] The is_mut check at lines 240-249 pattern matches - can new edge kinds be added without updating this, causing mutable edges to be treated as immutable? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_048f70a5-27e2-485c-9d40-10e91359ab2f?mode=deep",
    "timestamp": "2026-01-23 06:42:30.100548",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: new_from_code_offset()] [Label collision] Code offset labels at lines 278-280 use 16-bit offset and 8-bit qualifier - can programs with >64K bytecode or >256 qualifiers cause label collisions? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_98032126-96b0-475a-b7c8-debcc7428e67?mode=deep",
    "timestamp": "2026-01-23 06:42:59.646774",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: new_from_counter()] [Counter collision] Counter labels at lines 284-287 shift by 24 bits - can this collide with code offset labels if counter exceeds certain values? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_daa0ce6a-08ea-4dc3-9e78-631621f582e4?mode=deep",
    "timestamp": "2026-01-23 06:43:31.788380",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: roots()] [Incomplete traversal] The roots() function at lines 831-854 uses a todo list - can cycles in the parent graph cause infinite loops despite the 'done' set? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4d7d4fbd-f8a4-4ecd-8e7b-5e4fd4fb0132?mode=deep",
    "timestamp": "2026-01-23 06:44:04.209581",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: transitive_children()] [Cycle handling] Transitive children at lines 857-871 includes the starting node - can cycles cause the result set to be incorrect? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_fdac550a-df29-4393-8357-78aa186b99ed?mode=deep",
    "timestamp": "2026-01-23 06:44:35.807236",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: error_with_hints()] [Error suppression bypass] Errors are suppressed if suppress_errors is true at lines 1396-1404 - can this be exploited to compile unsafe code in production by manipulating compiler flags? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_39bd0452-1e7a-4c11-af0f-58c5d8e04687?mode=deep",
    "timestamp": "2026-01-23 06:45:06.227221",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: diverging_edge_error()] [Error ordering] At lines 1295-1296, edges are ordered by location for error messages - can this ordering affect which error is reported first, potentially hiding more critical issues? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_2b289ab3-5abb-4fee-aaca-d3c97293e8c0?mode=deep",
    "timestamp": "2026-01-23 06:45:37.316706",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: release_refs_not_alive_after()] [Liveness annotation trust] The code trusts LiveVarAnnotation at line 885 - can incorrect liveness analysis from a prior pass cause safety violations to go undetected? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_61ca9426-55ac-4945-a595-da6efcece1b6?mode=deep",
    "timestamp": "2026-01-23 06:46:08.809209",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: release_refs_not_alive_after()] [Alive.after check] Only refs in alive.after are kept at lines 1109 - can temporaries that should be alive be incorrectly marked as dead, causing premature release? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d3705b00-8b7f-4a9e-bc3d-efb070949334?mode=deep",
    "timestamp": "2026-01-23 06:46:38.013595",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: execute()] [Instruction preprocessing] Borrow safety is checked before processing at lines 1976-2008 - can the state after preprocessing but before execution differ, causing TOCTOU issues? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_6ed10e2f-dea4-4a1d-a149-ca0c25b8b9d3?mode=deep",
    "timestamp": "2026-01-23 06:47:05.198832",
    "report_generated": false
  }
]