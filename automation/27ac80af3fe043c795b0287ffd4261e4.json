[
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Atomicity: Multiple fields] [Inconsistent state] Can last_consecutive_success_count at line 66 and window at line 73 be updated non-atomically, causing get_params() to see mismatched values? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_bd4119e0-247e-4519-b356-83a6cf1c8335?mode=deep",
    "timestamp": "2026-01-20 20:38:11.043087",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Synchronization: Mutex ordering] [Deadlock] Can multiple Mutex locks be acquired in different orders across consensus components, potentially causing deadlocks when both push() and get_params() are called concurrently? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0d746f24-5139-4d20-b8c7-f1879e8245c0?mode=deep",
    "timestamp": "2026-01-20 20:38:23.333108",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Synchronization: Arc cloning] [Reference leak] Can excessive Arc::clone() operations on failure_tracker at line 122 cause reference count overflow, preventing proper cleanup? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_3c863d19-2f74-4202-8cbd-b7dd4a58a1c7?mode=deep",
    "timestamp": "2026-01-20 20:38:36.005810",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: max_window bounds] [Invalid configuration] Can max_window be configured to 0 or 1 at line 42, breaking the exponential backoff algorithm since window starts at 2? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9c90fb67-9171-4d93-9fb0-60f908494311?mode=deep",
    "timestamp": "2026-01-20 20:38:49.170496",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: enable_opt_qs toggle] [Runtime disable] If enable_opt_qs is changed from true to false at runtime at line 129, does this permanently disable OptQS even if failures were temporary? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_6fa2984d-8a77-4b2d-be95-9b7ed332c1ba?mode=deep",
    "timestamp": "2026-01-20 20:39:03.114906",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: minimum_batch_age_usecs] [Time manipulation] Can minimum_batch_age_usecs be set to 0 at line 158, bypassing the batch age requirement and allowing premature batch proposals? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_e8567af5-0fa7-4982-bb46-e305e9648046?mode=deep",
    "timestamp": "2026-01-20 20:39:17.966977",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: ordered_authors update] [Epoch transition] During epoch transitions when validator set changes, can ordered_authors become stale, causing get_exclude_authors() to exclude wrong validators? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_68867243-e23b-46ce-a3a6-a0bf66b422ee?mode=deep",
    "timestamp": "2026-01-20 20:39:33.515922",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Config: Conflicting settings] [Misconfiguration] Can enable_opt_qs=true but max_window=1 create conflicting configuration where OptQS is enabled but immediately disabled on first failure? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_41a1d933-6162-467c-8e70-ae60e407bb40?mode=deep",
    "timestamp": "2026-01-20 20:39:51.413455",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: ordered_authors staleness] [Validator mismatch] If ordered_authors at line 45 is not updated during epoch transitions, can author_idx at line 90 map to validators from the previous epoch, incorrectly excluding new validators? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_25d5526a-1174-451b-92c1-586b3e929b74?mode=deep",
    "timestamp": "2026-01-20 20:40:09.401219",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: State reset] [History loss] Should past_round_statuses be cleared at line 33 during epoch transitions, or can stale data from previous epochs affect OptQS decisions in the new epoch? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_fb220d2b-8b0d-447b-8182-6a540097281f?mode=deep",
    "timestamp": "2026-01-20 20:40:28.853283",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: Window persistence] [Configuration carry-over] Should window be reset to 2 at line 41 during epoch transitions, or can a large window from previous epoch unfairly disable OptQS for new validators? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_d62a1d98-965b-4f04-b60d-41e1f2eea2ae?mode=deep",
    "timestamp": "2026-01-20 20:40:49.269740",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: Concurrent updates] [Race during transition] Can ordered_authors be updated at line 45 concurrently with get_exclude_authors() accessing it at line 90, causing index mismatches? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_c695c801-0a91-41da-9b9b-30aea541c6db?mode=deep",
    "timestamp": "2026-01-20 20:41:10.834989",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_tracker.rs] [Epoch: BitVec size change] [Size mismatch] If validator set size changes between epochs, can missing_authors BitVec size at line 86 become inconsistent with new ordered_authors length? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_db82ad16-78f0-4ffe-8db6-8202cbf215bb?mode=deep",
    "timestamp": "2026-01-20 20:41:32.992317",
    "report_generated": false
  },
  {
    "question": "[File: consensus/src/liveness/proposal_status_\n\n### Citations\n\n**File:** consensus/src/liveness/proposal_status_tracker.rs (L1-232)\n```rust\n// Copyright (c) Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse super::round_state::NewRoundReason;\nuse crate::counters;\nuse aptos_collections::BoundedVecDeque;\nuse aptos_consensus_types::{\n    common::Author, payload_pull_params::OptQSPayloadPullParams, round_timeout::RoundTimeoutReason,\n};\nuse aptos_infallible::Mutex;\nuse aptos_logger::warn;\nuse aptos_short_hex_str::AsShortHexStr;\nuse std::{collections::HashSet, sync::Arc};\n\npub trait TPastProposalStatusTracker: Send + Sync {\n    fn push(&self, status: NewRoundReason);\n}\n\npub trait TOptQSPullParamsProvider: Send + Sync {\n    fn get_params(&self) -> Option<OptQSPayloadPullParams>;\n}\n\n/// A exponential window based algorithm to decide whether to go optimistic or not, based on\n/// configurable number of past proposal statuses\n///\n/// Initialize the window at 2.\n/// - For each proposal failure, double the window up to a MAX size\n/// - If there are no failures within the window, then propose optimistic batch\n/// - If there are no failures up to MAX proposals, reset the window to 2.\npub struct ExponentialWindowFailureTracker {\n    window: usize,\n    max_window: usize,\n    past_round_statuses: BoundedVecDeque<NewRoundReason>,\n    last_consecutive_success_count: usize,\n    ordered_authors: Vec<Author>,\n}\n\nimpl ExponentialWindowFailureTracker {\n    pub(crate) fn new(max_window: usize, ordered_authors: Vec<Author>) -> Self {\n        Self {\n            window: 2,\n            max_window,\n            past_round_statuses: BoundedVecDeque::new(max_window),\n            last_consecutive_success_count: 0,\n            ordered_authors,\n        }\n    }\n\n    pub(crate) fn push(&mut self, status: NewRoundReason) {\n        self.past_round_statuses.push_back(status);\n        self.compute_failure_window();\n    }\n\n    fn last_consecutive_statuses_matching<F>(&self, matcher: F) -> usize\n    where\n        F: Fn(&NewRoundReason) -> bool,\n    {\n        self.past_round_statuses\n            .iter()\n            .rev()\n            .take_while(|reason| matcher(reason))\n            .count()\n    }\n\n    fn compute_failure_window(&mut self) {\n        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {\n            !matches!(\n                reason,\n                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })\n            )\n        });\n        if self.last_consecutive_success_count == 0 {\n            self.window *= 2;\n            self.window = self.window.min(self.max_window);\n        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {\n            self.window = 2;\n        }\n    }\n\n    fn get_exclude_authors(&self) -> HashSet<Author> {\n        let mut exclude_authors = HashSet::new();\n\n        let limit = self.window;\n        for round_reason in self.past_round_statuses.iter().rev().take(limit) {\n            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {\n                missing_authors,\n            }) = round_reason\n            {\n                for author_idx in missing_authors.iter_ones() {\n                    if let Some(author) = self.ordered_authors.get(author_idx) {\n                        exclude_authors.insert(*author);\n                    }\n                }\n            }\n        }\n\n        exclude_authors\n    }\n}\n\nimpl TPastProposalStatusTracker for Mutex<ExponentialWindowFailureTracker> {\n    fn push(&self, status: NewRoundReason) {\n        self.lock().push(status)\n    }\n}\n\npub struct OptQSPullParamsProvider {\n    enable_opt_qs: bool,\n    minimum_batch_age_usecs: u64,\n    failure_tracker: Arc<Mutex<ExponentialWindowFailureTracker>>,\n}\n\nimpl OptQSPullParamsProvider {\n    pub fn new(\n        enable_opt_qs: bool,\n        minimum_batch_age_usecs: u64,\n        failure_tracker: Arc<Mutex<ExponentialWindowFailureTracker>>,\n    ) -> Self {\n        Self {\n            enable_opt_qs,\n            minimum_batch_age_usecs,\n            failure_tracker,\n        }\n    }\n}\n\nimpl TOptQSPullParamsProvider for OptQSPullParamsProvider {\n    fn get_params(&self) -> Option<OptQSPayloadPullParams> {\n        if !self.enable_opt_qs {\n            return None;\n        }\n\n        let tracker = self.failure_tracker.lock();\n\n        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT\n            .observe(tracker.last_consecutive_success_count as f64);\n        if tracker.last_consecutive_success_count < tracker.window {\n            warn!(",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0a79f5bb-9734-4f19-ba7f-c753ff695626?mode=deep",
    "timestamp": "2026-01-20 20:41:55.991850",
    "report_generated": false
  }
]