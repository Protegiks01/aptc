[
  {
    "question": "[File: aptos-core/storage\n\n### Citations\n\n**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L1-347)\n```rust\n// Copyright © Aptos Foundation\n// Parts of the project are originally copyright © Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module implements `JellyfishMerkleIterator`. Initialized with a version and a key, the\n//! iterator generates all the key-value pairs in this version of the tree, starting from the\n//! smallest key that is greater or equal to the given key, by performing a depth first traversal\n//! on the tree.\n\n#[cfg(test)]\nmod iterator_test;\n\nuse crate::{\n    node_type::{Child, InternalNode, Node, NodeKey},\n    TreeReader,\n};\nuse aptos_crypto::HashValue;\nuse aptos_storage_interface::{db_ensure as ensure, db_other_bail, AptosDbError, Result};\nuse aptos_types::{\n    nibble::{nibble_path::NibblePath, Nibble, ROOT_NIBBLE_HEIGHT},\n    transaction::Version,\n};\nuse std::{marker::PhantomData, sync::Arc};\n\n/// `NodeVisitInfo` keeps track of the status of an internal node during the iteration process. It\n/// indicates which ones of its children have been visited.\n#[derive(Debug)]\nstruct NodeVisitInfo {\n    /// The key to this node.\n    node_key: NodeKey,\n\n    /// The node itself.\n    node: InternalNode,\n\n    /// The bitmap indicating which children exist. It is generated by running\n    /// `self.node.generate_bitmaps().0` and cached here.\n    children_bitmap: u16,\n\n    /// This integer always has exactly one 1-bit. The position of the 1-bit (from LSB) indicates\n    /// the next child to visit in the iteration process. All the ones on the left have already\n    /// been visited. All the children on the right (including this one) have not been visited yet.\n    next_child_to_visit: u16,\n}\n\nimpl NodeVisitInfo {\n    /// Constructs a new `NodeVisitInfo` with given node key and node. `next_child_to_visit` will\n    /// be set to the leftmost child.\n    fn new(node_key: NodeKey, node: InternalNode) -> Self {\n        let (children_bitmap, _) = node.generate_bitmaps();\n        assert!(children_bitmap != 0);\n        Self {\n            node_key,\n            node,\n            children_bitmap,\n            next_child_to_visit: 1 << children_bitmap.trailing_zeros(),\n        }\n    }\n\n    /// Same as `new` but points `next_child_to_visit` to a specific location. If the child\n    /// corresponding to `next_child_to_visit` does not exist, set it to the next one on the\n    /// right.\n    fn new_next_child_to_visit(\n        node_key: NodeKey,\n        node: InternalNode,\n        next_child_to_visit: Nibble,\n    ) -> Self {\n        let (children_bitmap, _) = node.generate_bitmaps();\n        let mut next_child_to_visit = 1 << u8::from(next_child_to_visit);\n        assert!(children_bitmap >= next_child_to_visit);\n        while next_child_to_visit & children_bitmap == 0 {\n            next_child_to_visit <<= 1;\n        }\n        Self {\n            node_key,\n            node,\n            children_bitmap,\n            next_child_to_visit,\n        }\n    }\n\n    /// Whether the next child to visit is the rightmost one.\n    fn is_rightmost(&self) -> bool {\n        assert!(self.next_child_to_visit.leading_zeros() >= self.children_bitmap.leading_zeros());\n        self.next_child_to_visit.leading_zeros() == self.children_bitmap.leading_zeros()\n    }\n\n    /// Advances `next_child_to_visit` to the next child on the right.\n    fn advance(&mut self) {\n        assert!(!self.is_rightmost(),",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_86557b21-2066-4e04-83da-be2d78e4809c?mode=deep",
    "timestamp": "2026-01-19 20:06:18.010543",
    "report_generated": false
  }
]