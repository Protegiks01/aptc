[
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Abort Codes] [Error Consistency] Are abort codes (ETRANSACTION_CONTEXT_NOT_AVAILABLE=1, EMONOTONICALLY_INCREASING_COUNTER_OVERFLOW=2, ETRANSACTION_INDEX_NOT_AVAILABLE=5) properly documented and unique across the codebase? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_364e0272-61e7-426c-afe6-a1951ba6701e?mode=deep",
    "timestamp": "2026-01-20 06:27:53.963465",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_monotonically_increasing_counter_internal()] [Error Handling] At line 165-169, does aborting on counter overflow provide sufficient information for debugging, or can this hide attack vectors? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_24919a41-e67e-44b0-89f2-5e557f83a1b0?mode=deep",
    "timestamp": "2026-01-20 06:28:07.065440",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_sender_internal()] [Error Path] At lines 264-267, does aborting when context is unavailable properly distinguish between expected and unexpected error conditions? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_443bc356-969a-4b2e-8326-eafe4db185e0?mode=deep",
    "timestamp": "2026-01-20 06:28:19.984773",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Multiple Functions] [Consistent Error Handling] Do all functions that access user_transaction_context_opt abort with the same error code, ensuring consistent behavior? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_0f942cd7-ae35-4a7e-a9fc-db30c91c2583?mode=deep",
    "timestamp": "2026-01-20 06:28:33.350467",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_get_txn_hash()] [Gas] Is TRANSACTION_CONTEXT_GET_TXN_HASH_BASE sufficient to cover the cost of cloning and returning session_hash? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_67fe98fa-bd97-4476-a16d-6d0454cbcf0a?mode=deep",
    "timestamp": "2026-01-20 06:28:47.802778",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_generate_unique_address()] [Gas] Does TRANSACTION_CONTEXT_GENERATE_UNIQUE_ADDRESS_BASE account for cryptographic operations in AuthenticationKey::auid? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9d2e3d80-f560-431f-815f-9aff16d3f80a?mode=deep",
    "timestamp": "2026-01-20 06:29:03.157333",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_monotonically_increasing_counter_internal()] [Gas] Is TRANSACTION_CONTEXT_MONOTONICALLY_INCREASING_COUNTER_BASE sufficient for bit manipulation operations? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_1b9ac109-9263-441c-b4a1-a47b4eda699a?mode=deep",
    "timestamp": "2026-01-20 06:29:19.787810",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_secondary_signers_internal()] [Gas] At lines 280-283, can the per-signer gas charge be bypassed by providing an empty signers list? (Low)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9fbd367a-33c8-4e01-a817-bdb9231865e2?mode=deep",
    "timestamp": "2026-01-20 06:29:38.828592",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_entry_function_payload_internal()] [Gas] At lines 435-437, can the per-byte gas charge be manipulated by crafting payloads with unexpected size calculations? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_be7df070-df2c-4b20-9099-67f796e01ec1?mode=deep",
    "timestamp": "2026-01-20 06:29:58.474501",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_multisig_payload_internal()] [Gas] At lines 465-468, is nested payload gas charging sufficient to prevent DoS with deeply nested structures? (Medium)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_4a4cf516-fde0-496e-b40d-1d970d560a8d?mode=deep",
    "timestamp": "2026-01-20 06:30:19.434927",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Gas Metering] [Ordering] Are gas charges applied before expensive operations, or can out-of-gas errors occur after partial execution? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_bf2a84f4-d8a7-41e0-aba3-fd3a2a967f49?mode=deep",
    "timestamp": "2026-01-20 06:30:41.368108",
    "report_generated": false
  },
  {
    "question": "[File: aptos-core/aptos-move/framework/src/natives/transaction_context.rs] [Function: native_generate_unique_address()] [Crypto] Does AuthenticationKey::auid at lines 140\n\n### Citations\n\n**File:** aptos-move/framework/src/natives/transaction_context.rs (L1-572)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse aptos_gas_schedule::gas_params::natives::aptos_framework::*;\nuse aptos_native_interface::{\n    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeError,\n    SafeNativeResult,\n};\nuse aptos_types::{\n    error,\n    transaction::{\n        authenticator::AuthenticationKey,\n        user_transaction_context::{EntryFunctionPayload, UserTransactionContext},\n    },\n};\nuse better_any::{Tid, TidAble};\nuse move_binary_format::errors::PartialVMResult;\nuse move_core_types::gas_algebra::{NumArgs, NumBytes};\nuse move_vm_runtime::{native_extensions::SessionListener, native_functions::NativeFunction};\nuse move_vm_types::{\n    loaded_data::runtime_types::Type,\n    values::{Struct, Value},\n};\nuse smallvec::{smallvec, SmallVec};\nuse std::collections::VecDeque;\n\npub mod abort_codes {\n    pub const ETRANSACTION_CONTEXT_NOT_AVAILABLE: u64 = 1;\n    pub const EMONOTONICALLY_INCREASING_COUNTER_OVERFLOW: u64 = 2;\n    pub const ETRANSACTION_INDEX_NOT_AVAILABLE: u64 = 5;\n}\n\nuse move_core_types::language_storage::{OPTION_NONE_TAG, OPTION_SOME_TAG};\n\n/// The native transaction context extension. This needs to be attached to the\n/// NativeContextExtensions value which is passed into session functions, so it\n/// is accessible from natives of this extension.\n#[derive(Tid)]\npub struct NativeTransactionContext {\n    session_hash: Vec<u8>,\n    /// The number of AUIDs (Aptos unique identifiers) issued during the\n    /// execution of this transaction.\n    auid_counter: u64,\n    /// The local counter to support the monotonically increasing counter feature.\n    /// The monotically increasing counter outputs `<reserved_byte> timestamp || transaction_index || session counter || local_counter`.\n    local_counter: u16,\n\n    script_hash: Vec<u8>,\n    chain_id: u8,\n    /// A transaction context is available upon transaction prologue/execution/epilogue. It is not available\n    /// when a VM session is created for other purposes, such as for processing validator transactions.\n    user_transaction_context_opt: Option<UserTransactionContext>,\n    /// A number to represent the sessions inside the execution of a transaction. Used for computing the `monotonically_increasing_counter` method.\n    session_counter: u8,\n}\n\nimpl SessionListener for NativeTransactionContext {\n    fn start(&mut self, session_hash: &[u8; 32], script_hash: &[u8], session_counter: u8) {\n        self.session_hash = session_hash.to_vec();\n        self.auid_counter = 0;\n        self.local_counter = 0;\n        self.script_hash = script_hash.to_vec();\n        // Chain ID is persisted.\n        // User transaction context is persisted.\n        self.session_counter = session_counter;\n    }\n\n    fn finish(&mut self) {\n        // No state changes to save.\n    }\n\n    fn abort(&mut self) {\n        // No state changes to abort. Context will be reset on new session's start.\n    }\n}\n\nimpl NativeTransactionContext {\n    /// Create a new instance of a native transaction context. This must be passed in via an\n    /// extension into VM session functions.\n    pub fn new(\n        session_hash: Vec<u8>,\n        script_hash: Vec<u8>,\n        chain_id: u8,\n        user_transaction_context_opt: Option<UserTransactionContext>,\n        session_counter: u8,\n    ) -> Self {\n        Self {\n            session_hash,\n            auid_counter: 0,\n            local_counter: 0,\n            script_hash,\n            chain_id,\n            user_transaction_context_opt,\n            session_counter,\n        }\n    }\n\n    pub fn chain_id(&self) -> u8 {\n        self.chain_id\n    }\n}\n\n/***************************************************************************************************\n * native fun get_txn_hash\n *\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_get_txn_hash(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_GET_TXN_HASH_BASE)?;\n    let transaction_context = context.extensions().get::<NativeTransactionContext>();\n\n    Ok(smallvec![Value::vector_u8(\n        transaction_context.session_hash.clone()\n    )])\n}\n\n/***************************************************************************************************\n * native fun generate_unique_address\n *\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_generate_unique_address(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_GENERATE_UNIQUE_ADDRESS_BASE)?;\n\n    let transaction_context = context\n        .extensions_mut()\n        .get_mut::<NativeTransactionContext>();\n    transaction_context.auid_counter += 1;\n\n    let auid = AuthenticationKey::auid(\n        transaction_context.session_hash.clone(),\n        transaction_context.auid_counter,\n    )\n    .account_address();\n    Ok(smallvec![Value::address(auid)])\n}\n\n/***************************************************************************************************\n * native fun monotonically_increasing_counter_internal\n *\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_monotonically_increasing_counter_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    mut args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_MONOTONICALLY_INCREASING_COUNTER_BASE)?;\n\n    let transaction_context = context\n        .extensions_mut()\n        .get_mut::<NativeTransactionContext>();\n    if transaction_context.local_counter == u16::MAX {\n        return Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(\n                abort_codes::EMONOTONICALLY_INCREASING_COUNTER_OVERFLOW,\n            ),\n        });\n    }\n    transaction_context.local_counter += 1;\n    let local_counter = transaction_context.local_counter as u128;\n    let session_counter = transaction_context.session_counter as u128;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(user_transaction_context) = user_transaction_context_opt {\n        // monotonically_increasing_counter (128 bits) = `<reserved_byte (8 bits) = 0 for block/chunk execution, 1 for validation/simulation> || timestamp_us (64 bits) || transaction_index (32 bits) || session counter (8 bits) || local_counter (16 bits)`\n        let timestamp_us = safely_pop_arg!(args, u64);\n        let transaction_index = user_transaction_context.transaction_index();\n\n        if let Some(transaction_index) = transaction_index {\n            let mut monotonically_increasing_counter: u128 = (timestamp_us as u128) << 56;\n            monotonically_increasing_counter |= (transaction_index as u128) << 24;\n            monotonically_increasing_counter |= session_counter << 16;\n            monotonically_increasing_counter |= local_counter;\n            Ok(smallvec![Value::u128(monotonically_increasing_counter)])\n        } else {\n            Err(SafeNativeError::Abort {\n                abort_code: error::invalid_state(abort_codes::ETRANSACTION_INDEX_NOT_AVAILABLE),\n            })\n        }\n    } else {\n        // When transaction context is not available, return an error\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\n/***************************************************************************************************\n * native fun monotonically_increasing_counter_internal_for_test_only\n *\n *   gas cost: base_cost\n *\n *   This is a test-only version that returns increasing counter values without requiring\n *   a user transaction context. Used when COMPILE_FOR_TESTING flag is enabled.\n *\n **************************************************************************************************/\nfn native_monotonically_increasing_counter_internal_for_test_only(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_MONOTONICALLY_INCREASING_COUNTER_BASE)?;\n\n    let transaction_context = context\n        .extensions_mut()\n        .get_mut::<NativeTransactionContext>();\n    if transaction_context.local_counter == u16::MAX {\n        return Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(\n                abort_codes::EMONOTONICALLY_INCREASING_COUNTER_OVERFLOW,\n            ),\n        });\n    }\n    transaction_context.local_counter += 1;\n    let local_counter = transaction_context.local_counter as u128;\n\n    // For testing, return just the local counter value to verify monotonically increasing behavior\n    Ok(smallvec![Value::u128(local_counter)])\n}\n\n/***************************************************************************************************\n * native fun get_script_hash\n *\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_get_script_hash(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_GET_SCRIPT_HASH_BASE)?;\n\n    let transaction_context = context.extensions().get::<NativeTransactionContext>();\n\n    Ok(smallvec![Value::vector_u8(\n        transaction_context.script_hash.clone()\n    )])\n}\n\nfn native_sender_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_SENDER_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        Ok(smallvec![Value::address(transaction_context.sender())])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_secondary_signers_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_SECONDARY_SIGNERS_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        let secondary_signers = transaction_context.secondary_signers();\n        context.charge(\n            TRANSACTION_CONTEXT_SECONDARY_SIGNERS_PER_SIGNER\n                * NumArgs::new(secondary_signers.len() as u64),\n        )?;\n        Ok(smallvec![Value::vector_address(secondary_signers)])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_gas_payer_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_FEE_PAYER_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        Ok(smallvec![Value::address(transaction_context.gas_payer())])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_max_gas_amount_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_MAX_GAS_AMOUNT_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        Ok(smallvec![Value::u64(transaction_context.max_gas_amount())])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_gas_unit_price_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_GAS_UNIT_PRICE_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        Ok(smallvec![Value::u64(transaction_context.gas_unit_price())])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_chain_id_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_CHAIN_ID_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    if let Some(transaction_context) = user_transaction_context_opt {\n        Ok(smallvec![Value::u8(transaction_context.chain_id())])\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn create_option_some(enum_option_enabled: bool, value: Value) -> PartialVMResult<Value> {\n    Ok(if enum_option_enabled {\n        Value::struct_(Struct::pack_variant(OPTION_SOME_TAG, vec![value]))\n    } else {\n        // Note: the collection is homogeneous because it contains only one value.\n        Value::struct_(Struct::pack(vec![Value::vector_unchecked(vec![value])?]))\n    })\n}\n\nfn create_option_none(enum_option_enabled: bool) -> PartialVMResult<Value> {\n    Ok(if enum_option_enabled {\n        Value::struct_(Struct::pack_variant(OPTION_NONE_TAG, vec![]))\n    } else {\n        // We are creating empty vector - this is safe to do.\n        Value::struct_(Struct::pack(vec![Value::vector_unchecked(vec![])?]))\n    })\n}\n\nfn create_string_value(s: String) -> Value {\n    Value::struct_(Struct::pack(vec![Value::vector_u8(s.as_bytes().to_vec())]))\n}\n\nfn num_bytes_from_entry_function_payload(entry_function_payload: &EntryFunctionPayload) -> usize {\n    entry_function_payload.account_address.len()\n        + entry_function_payload.module_name.len()\n        + entry_function_payload.function_name.len()\n        + entry_function_payload\n            .ty_arg_names\n            .iter()\n            .map(|s| s.len())\n            .sum::<usize>()\n        + entry_function_payload\n            .args\n            .iter()\n            .map(|v| v.len())\n            .sum::<usize>()\n}\n\nfn create_entry_function_payload(\n    entry_function_payload: EntryFunctionPayload,\n) -> PartialVMResult<Value> {\n    let args = entry_function_payload\n        .args\n        .into_iter()\n        .map(Value::vector_u8)\n        .collect::<Vec<_>>();\n\n    let ty_args = entry_function_payload\n        .ty_arg_names\n        .into_iter()\n        .map(create_string_value)\n        .collect::<Vec<_>>();\n\n    Ok(Value::struct_(Struct::pack(vec![\n        Value::address(entry_function_payload.account_address),\n        create_string_value(entry_function_payload.module_name),\n        create_string_value(entry_function_payload.function_name),\n        // SAFETY: both type arguments and arguments are homogeneous collections.\n        Value::vector_unchecked(ty_args)?,\n        Value::vector_unchecked(args)?,\n    ])))\n}\n\nfn native_entry_function_payload_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_ENTRY_FUNCTION_PAYLOAD_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    let enum_option_enabled = context.get_feature_flags().is_enum_option_enabled();\n    if let Some(transaction_context) = user_transaction_context_opt {\n        if let Some(entry_function_payload) = transaction_context.entry_function_payload() {\n            let num_bytes = num_bytes_from_entry_function_payload(&entry_function_payload);\n            context.charge(\n                TRANSACTION_CONTEXT_ENTRY_FUNCTION_PAYLOAD_PER_BYTE_IN_STR\n                    * NumBytes::new(num_bytes as u64),\n            )?;\n            let payload = create_entry_function_payload(entry_function_payload)?;\n            Ok(smallvec![create_option_some(enum_option_enabled, payload)?])\n        } else {\n            Ok(smallvec![create_option_none(enum_option_enabled)?])\n        }\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn native_multisig_payload_internal(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    context.charge(TRANSACTION_CONTEXT_MULTISIG_PAYLOAD_BASE)?;\n\n    let user_transaction_context_opt = get_user_transaction_context_opt_from_context(context);\n    let enum_option_enabled = context.get_feature_flags().is_enum_option_enabled();\n    if let Some(transaction_context) = user_transaction_context_opt {\n        if let Some(multisig_payload) = transaction_context.multisig_payload() {\n            let inner_entry_fun_payload =\n                if let Some(entry_function_payload) = multisig_payload.entry_function_payload {\n                    let num_bytes = num_bytes_from_entry_function_payload(&entry_function_payload);\n                    context.charge(\n                        TRANSACTION_CONTEXT_MULTISIG_PAYLOAD_PER_BYTE_IN_STR\n                            * NumBytes::new(num_bytes as u64),\n                    )?;\n                    let inner_entry_fun_payload =\n                        create_entry_function_payload(entry_function_payload)?;\n                    create_option_some(enum_option_enabled, inner_entry_fun_payload)?\n                } else {\n                    create_option_none(enum_option_enabled)?\n                };\n            let multisig_payload = Value::struct_(Struct::pack(vec![\n                Value::address(multisig_payload.multisig_address),\n                inner_entry_fun_payload,\n            ]));\n            Ok(smallvec![create_option_some(\n                enum_option_enabled,\n                multisig_payload\n            )?])\n        } else {\n            Ok(smallvec![create_option_none(enum_option_enabled)?])\n        }\n    } else {\n        Err(SafeNativeError::Abort {\n            abort_code: error::invalid_state(abort_codes::ETRANSACTION_CONTEXT_NOT_AVAILABLE),\n        })\n    }\n}\n\nfn get_user_transaction_context_opt_from_context<'a>(\n    context: &'a SafeNativeContext,\n) -> &'a Option<UserTransactionContext> {\n    &context\n        .extensions()\n        .get::<NativeTransactionContext>()\n        .user_transaction_context_opt\n}\n\n/***************************************************************************************************\n * module\n *\n **************************************************************************************************/\npub fn make_all(\n    builder: &SafeNativeBuilder,\n) -> impl Iterator<Item = (String, NativeFunction)> + '_ {\n    let natives = [\n        (",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_f9d46281-cab0-4371-9224-94db4b0dce5d?mode=deep",
    "timestamp": "2026-01-20 06:31:04.664446",
    "report_generated": false
  }
]