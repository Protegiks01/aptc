[
  {
    "question": "[File: third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs] [Function: verify_common()] [Ability Checking] Are Move abilities (copy, drop, store, key) validated during verification, or can bytecode bypass ability restrictions? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_203a6f21-f1ea-4cf1-92da-b2aa493a57f3?mode=deep",
    "timestamp": "2026-01-25 13:33:01.475593",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs] [Function: verify_common()] [Global Access] Can verifiers detect illegal access to global storage or system accounts that should be restricted? (Critical)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_ca68cc1e-6106-4df5-865a-bd7cc3c8400f?mode=deep",
    "timestamp": "2026-01-25 13:33:13.825563",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs] [Function: verify_common()] [Cross-Module Calls] Does verification validate that calls to other modules are safe, or can attacker exploit inter-module dependencies? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_99d8a420-5a4c-456f-a06f-7bba1f4f6d37?mode=deep",
    "timestamp": "2026-01-25 13:33:26.614172",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs] [Function: verify_common()] [Gas Calculation] Is gas cost calculated during verification to prevent DoS through expensive operations, or only at execution time? (High)",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_199a260f-be10-4ef0-a903-4de6a977407f?mode=deep",
    "timestamp": "2026-01-25 13:33:41.041932",
    "report_generated": false
  },
  {
    "question": "[File: third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs] [Function: verify_module_impl()] [\n\n### Citations\n\n**File:** third_party/move/move-bytecode-verifier/src/code_unit_verifier.rs (L1-194)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module implements the checker for verifying correctness of function bodies.\n//! The overall verification is split between stack_usage_verifier.rs and\n//! abstract_interpreter.rs. CodeUnitVerifier simply orchestrates calls into these two files.\nuse crate::{\n    acquires_list_verifier::AcquiresVerifier,\n    control_flow, locals_safety,\n    meter::{BoundMeter, Meter, Scope},\n    reference_safety,\n    stack_usage_verifier::StackUsageVerifier,\n    type_safety,\n    verifier::VerifierConfig,\n};\nuse move_binary_format::{\n    access::ModuleAccess,\n    binary_views::{BinaryIndexedView, FunctionView},\n    control_flow_graph::ControlFlowGraph,\n    errors::{Location, PartialVMError, PartialVMResult, VMResult},\n    file_format::{\n        CompiledModule, CompiledScript, FunctionDefinition, FunctionDefinitionIndex,\n        IdentifierIndex, TableIndex,\n    },\n    IndexKind,\n};\nuse move_core_types::vm_status::StatusCode;\nuse std::collections::HashMap;\n\npub struct CodeUnitVerifier<'a> {\n    resolver: BinaryIndexedView<'a>,\n    function_view: FunctionView<'a>,\n    name_def_map: &'a HashMap<IdentifierIndex, FunctionDefinitionIndex>,\n}\n\nimpl<'a> CodeUnitVerifier<'a> {\n    pub fn verify_module(\n        verifier_config: &VerifierConfig,\n        module: &'a CompiledModule,\n    ) -> VMResult<()> {\n        Self::verify_module_impl(verifier_config, module)\n            .map_err(|e| e.finish(Location::Module(module.self_id())))\n    }\n\n    fn verify_module_impl(\n        verifier_config: &VerifierConfig,\n        module: &CompiledModule,\n    ) -> PartialVMResult<()> {\n        let mut meter = BoundMeter::new(verifier_config);\n        let mut name_def_map = HashMap::new();\n        for (idx, func_def) in module.function_defs().iter().enumerate() {\n            let fh = module.function_handle_at(func_def.function);\n            name_def_map.insert(fh.name, FunctionDefinitionIndex(idx as u16));\n        }\n        let mut total_back_edges = 0;\n        for (idx, function_definition) in module.function_defs().iter().enumerate() {\n            let index = FunctionDefinitionIndex(idx as TableIndex);\n            let num_back_edges = Self::verify_function(\n                verifier_config,\n                index,\n                function_definition,\n                module,\n                &name_def_map,\n                &mut meter,\n            )\n            .map_err(|err| err.at_index(IndexKind::FunctionDefinition, index.0))?;\n            total_back_edges += num_back_edges;\n        }\n        if let Some(limit) = verifier_config.max_back_edges_per_module {\n            if total_back_edges > limit {\n                return Err(PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES));\n            }\n        }\n        Ok(())\n    }\n\n    pub fn verify_script(\n        verifier_config: &VerifierConfig,\n        module: &'a CompiledScript,\n    ) -> VMResult<()> {\n        Self::verify_script_impl(verifier_config, module).map_err(|e| e.finish(Location::Script))\n    }\n\n    fn verify_script_impl(\n        verifier_config: &VerifierConfig,\n        script: &'a CompiledScript,\n    ) -> PartialVMResult<()> {\n        let mut meter = BoundMeter::new(verifier_config);\n        // create `FunctionView` and `BinaryIndexedView`\n        let function_view = control_flow::verify_script(verifier_config, script)?;\n        let resolver = BinaryIndexedView::Script(script);\n        let name_def_map = HashMap::new();\n\n        if let Some(limit) = verifier_config.max_basic_blocks_in_script {\n            if function_view.cfg().blocks().len() > limit {\n                return Err(PartialVMError::new(StatusCode::TOO_MANY_BASIC_BLOCKS));\n            }\n        }\n\n        if let Some(limit) = verifier_config.max_back_edges_per_function {\n            if function_view.cfg().num_back_edges() > limit {\n                return Err(PartialVMError::new(StatusCode::TOO_MANY_BACK_EDGES));\n            }\n        }\n\n        //verify\n        meter.enter_scope(",
    "url": "https://deepwiki.com/search/-you-are-an-elite-aptos-blockc_9bb702c3-1516-4523-885d-28809897dae4?mode=deep",
    "timestamp": "2026-01-25 13:33:55.208284",
    "report_generated": false
  }
]