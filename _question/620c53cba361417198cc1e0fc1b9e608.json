[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Resource cleanup] At lines 222-224, stream cleanup happens in three steps - if any step fails, can streams leak in connection_manager's tracking? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Update frequency] At line 171-172, update_stream_progress() is called on every iteration - can high-frequency updates cause contention or performance degradation in connection_manager? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: get_connection_manager()] [Unsafe exposure] At lines 144-146, get_connection_manager() returns a reference without validation - can this be used to bypass access controls elsewhere? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [UUID collision] At line 75, Uuid::new_v4() generates stream IDs, but with many concurrent requests, can UUID collisions cause stream data to be mixed between different clients? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [ID predictability] Stream ID is logged at line 79 but is uuid::v4 cryptographically secure - can attackers predict or brute-force stream IDs to hijack other streams? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [ID lifetime] Stream ID is used for logging and tracking, but is it sanitized before logging to prevent log injection attacks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: new()] [Parameter validation] At lines 33-50, constructor accepts config parameters without validation - can malicious config values cause integer overflows or invalid state? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: new()] [Chain ID trust] At line 34, chain_id is stored without validation - can incorrect chain_id cause cross-chain transaction confusion? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: new()] [Size limit bypass] At line 37, max_transaction_filter_size_bytes is stored but not validated to be non-zero - can zero value bypass size limits? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: new()] [Initialization race] At line 39, known_latest_version is fetched during construction - if connection_manager hasn't completed initialization, can stale or zero version be used? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Information leakage] At line 79, full request details are logged including potentially sensitive filter criteria - can this leak private query patterns? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Timing leakage] At lines 175, 205, verbose logging reveals exact version progress - can attackers use this to infer blockchain state or index service performance? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Error message leakage] At lines 212-213, error messages reveal internal state like 'data too old' - can this leak cache eviction policies to attackers? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Debug information] At line 84, error details are logged with {:?} which might expose internal structure - can this aid in reconnaissance attacks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Constant: MAX_BYTES_PER_BATCH] [Resource limit] At line 23, MAX_BYTES_PER_BATCH is hardcoded to 20MB - can this be bypassed by requesting multiple concurrent streams, each getting 20MB batches? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Magic number] At line 80, the future version buffer is hardcoded to 10000 - why this specific value and can it be exploited near version boundaries? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Sleep duration] At line 176, 100ms sleep is hardcoded - can attackers exploit this predictable timing for side-channel attacks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Default batch size] At line 117, default batch_size of 10000 transactions is hardc\n\n### Citations\n\n**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L1-230)\n```rust\n// Copyright (c) Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nmod data_client;\nmod data_manager;\nmod fetch_manager;\nmod in_memory_cache;\n\nuse crate::{\n    config::LiveDataServiceConfig,\n    connection_manager::ConnectionManager,\n    live_data_service::in_memory_cache::InMemoryCache,\n    metrics::{COUNTER, TIMER},\n};\nuse aptos_protos::indexer::v1::{GetTransactionsRequest, ProcessedRange, TransactionsResponse};\nuse aptos_transaction_filter::BooleanTransactionFilter;\nuse std::{sync::Arc, time::Duration};\nuse tokio::sync::mpsc::{Receiver, Sender};\nuse tonic::{Request, Status};\nuse tracing::info;\nuse uuid::Uuid;\n\nconst MAX_BYTES_PER_BATCH: usize = 20 * (1 << 20);\n\npub struct LiveDataService<'a> {\n    chain_id: u64,\n    in_memory_cache: InMemoryCache<'a>,\n    connection_manager: Arc<ConnectionManager>,\n    max_transaction_filter_size_bytes: usize,\n}\n\nimpl<'a> LiveDataService<'a> {\n    pub fn new(\n        chain_id: u64,\n        config: LiveDataServiceConfig,\n        connection_manager: Arc<ConnectionManager>,\n        max_transaction_filter_size_bytes: usize,\n    ) -> Self {\n        let known_latest_version = connection_manager.known_latest_version();\n        Self {\n            chain_id,\n            connection_manager: connection_manager.clone(),\n            in_memory_cache: InMemoryCache::new(\n                connection_manager,\n                known_latest_version,\n                config.num_slots,\n                config.size_limit_bytes,\n            ),\n            max_transaction_filter_size_bytes,\n        }\n    }\n\n    pub fn run(\n        &'a self,\n        mut handler_rx: Receiver<(\n            Request<GetTransactionsRequest>,\n            Sender<Result<TransactionsResponse, Status>>,\n        )>,\n    ) {\n        info!("
]