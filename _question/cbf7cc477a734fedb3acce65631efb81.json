[
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: notify_listeners_if_bootstrapped()] [Chunk executor finish] At line 408, finish_chunk_executor() is called when bootstrapped, but if this fails, are resources leaked and can the node be bootstrapped multiple times causing state duplication? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: initialize_active_data_stream()] [Reset chunk executor failure] At line 459, if reset_chunk_executor() fails, does it propagate the error or allow the stream to be initialized with stale executor state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [State synchronizer initialization] At lines 996-1000, initialize_state_synchronizer() is called but the return value (_join_handle) is discarded - can the initialization task fail asynchronously without detection? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Bootstrapping mode mismatch] At lines 1123-1137, if bootstrapping mode is checked but changes mid-processing through config update, can the wrong payload type be processed, mixing transactions and outputs? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Fast sync transaction output check] At lines 1139-1148, fast sync expects transaction output but only checks is_fast_sync() and transaction_output_to_sync.is_some() - can these conditions be met with mismatched data? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Speculative state expected version] At lines 1151-1160, if speculative_stream_state.expected_next_version() fails or returns an incorrect version due to race condition, can out-of-order transactions be processed? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [End of epoch ledger info mismatch] At lines 1168-1175, get_end_of_epoch_ledger_info() may return None or Some, but is the epoch transition handled atomically with transaction processing to prevent split epochs? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Payload type switching] At lines 1178-1255, different bootstrapping modes process different payload types, but can an attacker cause mode transition mid-payload processing, applying outputs as transactions or vice versa? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Synced version update race] At lines 1256-1262, after processing, synced_version is calculated and speculative_stream_state is updated, but can concurrent stream resets invalidate this state update? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: get_end_of_epoch_ledger_info()] [Num versions mismatch] At lines 1383-1431, num_versions is extracted from different proof types based on bootstrapping mode, but what if transaction_list_with_proof and transaction_outputs_with_proof both exist with different lengths? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: get_end_of_epoch_ledger_info()] [Epoch ending version lookup] At lines 1440-1442, the function queries verified_epoch_states for epoch ending ledger info at payload_end_version, but what if this version was never verified, returning None when an epoch actually ended? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [Stream creation race] At lines 749-810, multiple streaming_client calls create different data streams based on bootstrapping mode, but can rapid mode changes cause stream type confusion? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [End version calculation] At lines 743-748, end_version uses next_epoch_ending_version() which may be far in the future, but can this cause memory exhaustion when streaming client allocates resources for the full range? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_values()] [State value range manipulation] At lines 721-726, get_all_state_values() is called with next_state_index_to_process, but can an attacker manipulate advertised data to cause the client to request more data than exists, triggering errors? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_epoch_ending_ledger_infos()] [Epoch ending stream creation] At lines 857-861, get_all_epoch_ending_ledger_infos() creates a stream from next_epoch_end, but what if Byzantine peers advertise fake epoch endings, causing the stream to fetch non-existent epochs? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_values()] [Transaction output version mismatch] At lines 689-697, get_all_transaction_outputs() is called with target_ledger_info_version three times (start, end, proof version), but can these be different causing proof verification to use wrong version? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: get_highest_known_ledger_info()] [Ledger info version comparison] At lines 1446-1463, the function compares versions from storage and verified_epoch_states, but can race conditions during epoch transitions cause inconsistent version ordering? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: should_fetch_epoch_ending_ledger_infos()] [Fetch condition bypass] At lines 446-451, the function returns true if epoch endings not fetched OR waypoint not verified, but can partial verification states cause incorrect fetch decisions? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: VerifiedEpochStates::new()] [Initial epoch state trust] At lines 61-69, VerifiedEpochStates is initialized with latest_epoch_state from storage, but what if storage was corrupted before restart - is this epoch state trusted without verification? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_epoch_ending_ledger_infos()] [Epoch comparison logic] At lines 848-874, if highest_local_epoch_end equals highest_advertised_epoch_end but waypoint is unverified (lines 862-874), an error is returned, but can this block valid bootstrap scenarios? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [Invalid payload notification] At lines 971-979, if an unexpected payload is received, InvalidPayloadData feedback is sent, but can an attacker cause repeated invalid payloads to exhaust feedback handling resources? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_states_values_indices()] [Index verification feedback timing] At lines 927-936, if first_index is invalid, the stream resets with InvalidPayloadData, but what if the reset fails - does invalid state persist in memory? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_epoch_ending_payload()] [Proof failed feedback] At lines 1096-1107, if verification fails, PayloadProofFailed feedback is sent, but are the partial epoch state updates rolled back before sending feedback? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: handle_end_of_stream_or_invalid_payload()] [Feedback calculation logic] At lines 1472-1478, feedback is determined by matching data_payload, but can DataPayload variants be spoofed to send incorrect feedback types? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_waypoint()] [Version too high panic] At lines 145-150, if ledger_info_version > waypoint_version, the code panics, but can this be triggered by Byzantine peers on honest validators, causing network-wide halt? (Critical)"
]