[
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: new()] [My_index out of bounds] At line 96, my_index: usize is accepted without validation against epoch_state validator count - can providing my_index >= validator_count cause panics or buffer overflows when DKG::generate_transcript() uses it at line 336? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [Start_time_us overflow] At line 302, Duration::from_micros(start_time_us) - if start_time_us is u64::MAX or near overflow, can subsequent duration arithmetic at lines 304 and 348 wrap around or panic, crashing the validator? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_dkg_start_event()] [Missing start_time validation] At line 436, start_time_us is used directly without checking if it's in the past or unreasonably far future - can attackers specify start_time_us = 0 or u64::MAX to cause metric calculation underflows/overflows? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: run()] [In_progress_session malicious data] At lines 140-162, in_progress_session: Option<DKGSessionState> is trusted without validation - if loaded from corrupted storage, can malicious metadata cause setup_deal_broadcast() to crash or produce invalid transcripts? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_peer_rpc_msg()] [Missing message size limit] At line 455, IncomingRpcRequest msg is accepted without size validation - can Byzantine peers send enormous DKGMessage::TranscriptRequest payloads to exhaust memory when processing the response? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: new()] [Pull_notification channel poisoning] At lines 102-103, pull_notification_tx is created and shared with vtxn_pool - if vtxn_pool is compromised or buggy, can it spam pull_notification_rx with fake notifications to trigger incorrect state transitions? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: run()] [Rpc_msg_rx unbounded processing] At lines 172-176, rpc_msg_rx processes messages without rate limiting - can Byzantine peers flood RPC requests to consume CPU in process_peer_rpc_msg(), degrading validator performance? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [Agg_trx_tx unwrap panic] At lines 359-365, agg_trx_tx.clone() is passed to start_produce() - if self.agg_trx_tx is None due to initialization bug, this will panic when start_produce() tries to use it, crashing the validator? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_aggregated_transcript()] [Channel.push failure handling] At lines 73-83 in agg_trx_producer.rs, if agg_trx_tx.push() fails, the error is only logged - does DKGManager detect this failure and retry aggregation, or does it silently fail leaving DKG incomplete? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: new()] [QueueStyle::KLAST message loss] At line 103, QueueStyle::KLAST with capacity 1 means newer messages overwrite older ones - if multiple DKG transactions are pulled simultaneously, can lost notifications cause 'proposed' flag to never be set, breaking metrics? (Low)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_dkg_start_event()] [Fail point in production] At line 433, fail_point!('dkg::process_dkg_start_event') - if fail points are accidentally enabled in production builds, can attackers trigger them to cause validators to skip DKG initialization and halt epoch transitions? (Critical)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [Smoke-test feature in production] At line 325, cfg!(feature = 'smoke-test') gates deterministic RNG - if this feature is enabled in production due to build misconfiguration, all validators would generate predictable transcripts, completely breaking DKG security? (Critical)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Struct: InnerState] [Test-only my_node_cloned panic] At lines 82-89, my_node_cloned() panics on NotStarted - if this test-only method is accidentally called in production code paths, can it crash validators in legitimate NotStarted state? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: observe()] [Debug logging overhead] At line 212, debug! logs the entire self.state - if debug logging is enabled in production, can the frequent logging (every 5s per line 135) cause performance degradation or disk exhaustion? (Low)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_aggregated_transcript()] [Non-deterministic transcript submission] At lines 397-404, validators independently decide when to submit aggregated transcripts based on local aggregation - can network delays cause validators to submit different transcripts to consensus, leading to forks or safety violations? (Critical)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: run()] [State persistence missing] The InnerState at line 70 is never persisted to disk - if a validator crashes in InProgress state and restarts, it transitions to NotStarted, potentially generating a new transcript and equivocating. Does this violate safety guarantees? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [No quorum check before dealing] At lines 293-375, transcripts are dealt without verifying sufficient honest validators are online - if < 2/3 validators participate, can DKG complete with insufficient threshold, breaking randomness security? (Critical)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_aggregated_transcript()] [No transcript validation before submission] At lines 378-424, the aggregated transcript agg_trx is serialized and submitted without local verification - can Byzantine agg_trx_producer send invalid transcripts that validators blindly submit, corrupting on-chain state? (Critical)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_peer_rpc_msg()] [No authentication on transcript requests] At lines 454-478, TranscriptRequest responses contain full transcripts without verifying requester identity - can non-validator attackers request transcripts to learn validator set composition and plan targeted attacks? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: run()] [In_progress_session replay] At lines 147-154, if metadata.dealer_epoch == self.epoch_state.epoch, the session is resumed - can an attacker manipulate on-chain storage to replay old in_progress_session data and force validators to regenerate transcripts from previous epochs? (High)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [My_transcript not persisted] At line 341, my_transcript is created but never saved to disk - if all validators crash simultaneously before aggregation completes, is DKG progress lost, requiring complete restart and delaying epoch transition? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_aggregated_transcript()] [Vtxn_pool persistence assumption] At lines 405-409, validators assume vtxn_pool persists transactions - if the pool loses data before consensus commits, can this cause the aggregated transcript to be lost, requiring DKG restart? (Medium)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [Duration arithmetic overflow] At line 304, deal_start.as_secs_f64() - dkg_start_time.as_secs_f64() - if system time is adjusted backwards between these calls, can this produce negative durations that corrupt metrics or cause panics? (Low)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: process_dkg_txn_pulled_notification()] [Secs_since_dkg_start underflow] At line 268, proposed_time.as_secs_f64() - start_time.as_secs_f64() - if start_time is in the future due to clock skew, can negative values corrupt DKG_STAGE_SECONDS metrics and break monitoring? (Low)",
  "[File: aptos-core/dkg/src/dkg_manager/mod.rs] [Function: setup_deal_broadcast()] [My_index cast to u64] At line 336, my_index as u64 casts usize to u64 - on 64-bit systems this is safe, but does DKG implementation handle u64 indices correctly if my_index is near usize::MAX? (Low)"
]