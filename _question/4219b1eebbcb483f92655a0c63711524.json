[
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Vector append vulnerability] On line 48, processors.append(&mut vec![...]) takes ownership of a new vector - can this cause use-after-move bugs if the original processors vector is accessed afterward, potentially causing processor ordering corruption? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Processor double-addition] If processors.push() on lines 45 or 61 is called multiple times due to control flow bugs, can the same processor be added twice, causing redundant or conflicting instrumentation that breaks verification soundness? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Loop processor duplication] Can the conditional addition of LoopAnalysisProcessor (lines 44-46) combined with the vec append (line 48) cause the processor to be added twice if control flow is manipulated, leading to incorrect loop analysis? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Pipeline mutation safety] The pipeline construction in lines 68-72 iterates over processors and adds them - can concurrent access to the ProverOptions during this loop cause race conditions that result in incomplete or corrupted pipelines? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Empty pipeline vulnerability] If all conditional branches (lines 44-46, 60-62, 64-66) result in skipping processors, can an empty or near-empty pipeline be created that performs minimal verification, allowing vulnerable contracts to pass? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Pipeline initialization failure] Does FunctionTargetPipeline::default() on line 68 properly initialize the pipeline state, or can uninitialized fields cause subsequent add_processor calls to fail silently, resulting in incomplete verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Processor ownership transfer] When iterating over processors in lines 69-71 and calling res.add_processor(p), does the ownership transfer properly complete, or can partial transfers cause processors to be dropped, creating gaps in verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [Return value validation] The function returns res on line 72 without validation - can the returned pipeline be in an invalid state if any add_processor calls failed, leading to unsound verification of contracts? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline()] [Unsafe default options] Does the #[allow(unused)] attribute on line 75 indicate this function is not actively used, and if it becomes used with ProverOptions::default() (line 77), could default option values be insecure for production verification? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline()] [Default options vulnerability] Can ProverOptions::default() on line 77 result in security-critical flags like check_inconsistency or skip_loop_analysis being set to unsafe values that allow vulnerable contracts to pass verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline()] [Function unused risk] If this function marked with #[allow(unused)] (line 75) is suddenly called in production code, could it create pipelines with suboptimal security configurations compared to default_pipeline_with_options()? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Experimental bypass] Can the experimental_pipeline() function on line 80 be called in production contexts, using a pipeline with different processor ordering (lines 82-102) that may have weaker security guarantees than the default pipeline? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [BorrowAnalysis configuration difference] Does BorrowAnalysisProcessor::new() on line 89 (without borrow_natives parameter) use different borrow checking semantics than line 37's new_borrow_natives(), potentially missing borrow violations in experimental mode? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Processor ordering difference] In experimental_pipeline, DataInvariantInstrumentationProcessor (line 97) runs before GlobalInvariantAnalysisProcessor (line 98), opposite to default_pipeline (lines 51, 54) - can this ordering cause data invariants to be checked without global context, missing violations? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Missing inconsistency check] The experimental pipeline (lines 82-102) never includes InconsistencyCheckInstrumenter, unlike the default pipeline (lines 60-62) - can this cause inconsistent contracts to pass verification in experimental mode? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Missing number operation check] The experimental pipeline lacks NumberOperationProcessor entirely (compare to lines 64-66) - can this allow arithmetic overflow/underflow vulnerabilities in contracts verified using experimental mode? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [WellFormed omission] WellFormedInstrumentationProcessor present in default pipeline (line 53) is missing from experimental pipeline - can this cause resource wellformedness violations to go undetected in experimental verification? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Unconditional loop analysis] The experimental pipeline always includes LoopAnalysisProcessor (line 94) with no skip option - if this pipeline is used where loop analysis should be skipped, could this cause verification failures or infinite analysis loops? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: experimental_pipeline()] [Pipeline selection attack] Can an attacker manipulate which pipeline function is called (default vs experimental) to use the weaker experimental pipeline for verifying production contracts, bypassing critical security checks? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options() / experimental_pipeline()] [Pipeline variant confusion] Can code that calls these functions accidentally use experimental_pipeline() when default_pipeline_with_options() is required, resulting in weaker verification for production contracts deployed to Aptos mainnet? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options() / experimental_pipeline()] [Processor version mismatch] Do both pipelines use compatible versions of shared processors like CleanAndOptimizeProcessor (lines 39, 91), or could version mismatches cause different verification results for the same contract? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Module-level] [Processor import vulnerability] The use statements on lines 5-26 import various processors - can malicious or compromised processor implementations be injected through dependency confusion, causing incorrect verification of contracts? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Module-level] [Options import attack] The import of ProverOptions on line 14 - can this options structure be tampered with at compile-time or through compromised dependencies to modify default verification behavior? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Module-level] [FunctionTargetProcessor trait vulnerability] The trait import on line 22 defines the processor interface - can malicious processors implement this trait incorrectly, causing verification soundness issues while appearing to work correctly? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/pipeline_factory.rs] [Function: default_pipeline_with_options()] [EliminateImmRefs impact on MutRef] Can EliminateImmRefsProcessor (line 33) remove immutable references that MutRefInstrumenter (line 34) needs to track for correct mutable borrow analysis, causing aliasing violations to go undetected? (Critical)"
]