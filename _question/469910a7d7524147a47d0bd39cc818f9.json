[
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: is_full()] [Race Between Size Checks] At line 460, two separate checks are performed. Can race condition cause both checks to pass while mempool is actually full, allowing overflow? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: track_indices()] [Metric Calculation Overhead] At lines 371-411, extensive metric tracking is performed. Can attacker trigger this frequently to cause performance degradation? (Low)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Memory Leak on Partial Removal] If index_remove() fails midway, are there any memory leaks where transactions remain in some data structures but are inaccessible? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: get_by_hash()] [Hash Collision] At lines 179-184, hash_index is used to lookup transactions by committed hash. Can hash collision in get_committed_hash() cause wrong transaction to be returned? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [Hash Index Overwrite] At lines 350-351, hash_index.insert() is called. If hash collision occurs with existing transaction, does this silently overwrite previous entry causing transaction loss? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: get_by_hash()] [Committed Hash vs Transaction Hash] Code uses 'committed hash' for indexing. Is there a difference between committed hash and transaction hash that attacker can exploit? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: reject_transaction()] [Hash Index Verification] At lines 717-720, hash_index is checked before rejection. Can attacker submit rejection for wrong hash to cause denial of service for legitimate transactions? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: sender_bucket()] [Bucket Distribution Attack] At lines 43-48, sender bucket is calculated as address's last byte % num_sender_buckets. Can attacker generate addresses with specific last bytes to cause uneven distribution across buckets? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: sender_bucket()] [Bucket Overflow] At line 47, modulo operation is used. Can attacker provide num_sender_buckets = 0 to cause division by zero panic? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: get_bucket()] [Timeline Index Panic] At lines 215-224, timeline_index.get() uses unwrap(). Can attacker cause panic by manipulating sender_bucket calculation? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: new()] [Timeline Index Initialization] At lines 106-112, timeline_index is initialized for each sender_bucket. Can invalid num_sender_buckets configuration cause missing buckets? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_seq_num_based_transactions()] [Parking Lot State Inconsistency] At lines 616-624, transactions are added to parking lot if not Ready. Can transaction be in both parking_lot_index and priority_index simultaneously due to race conditions? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_is_full_after_eviction()] [Parking Lot as Eviction Source] Parking lot is used as eviction source, but what if all transactions in parking lot are critical? Can this cause legitimate transactions to be evicted? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: parking_lot_index.get_poppable()] [Poppable Transaction Selection] Code calls get_poppable() but doesn't show its implementation. Can attacker manipulate which transactions are considered poppable to prevent eviction of malicious transactions? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: gc()] [Parking Lot Flooding via GC] At lines 959-976, transactions after GC'd sequence number are parked. Can attacker repeatedly trigger GC of low sequence numbers to flood parking lot with transactions that can never become ready? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [Sequence Number Overflow] At line 302, txn_seq_num is compared with acc_seq_num. Can integer overflow in sequence number cause incorrect comparisons and acceptance of invalid transactions? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: commit_transaction()] [Sequence Number Increment Overflow] At line 682, txn_sequence_number + 1 is calculated. Can this overflow if txn_sequence_number is u64::MAX? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Size Bytes Underflow] At line 757, size_bytes is decremented. If get_estimated_bytes() changes between insert and remove, can this cause underflow? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: read_timeline()] [Batch Bytes Saturation] At line 816, saturating_add is used. Can attacker rely on saturation to bypass max_batch_bytes check and send oversized batches? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_seq_num_based_transactions()] [Min Sequence Overflow] At line 611, min_seq is incremented in loop. Can this overflow if attacker submits transactions with sequence numbers near u64::MAX? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [Account Sequence Number Source] At lines 245-250, account_sequence_number uses max() to combine values. If provided seq_num is malicious, can it permanently corrupt account_sequence_numbers HashMap? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: commit_transaction()] [Account Sequence Numbers Growth] account_sequence_numbers HashMap grows on every commit but how is it cleaned? Can it grow unbounded causing memory exhaustion? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Account Sequence Number Cleanup] At line 764, account_sequence_numbers.remove() is called when account has no transactions. Can race condition cause this to remove entry while new transaction is being inserted? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: get_account_sequence_number()] [Stale Sequence Numbers] Code returns reference to u64 in HashMap. Can this reference become invalid if HashMap is modified during usage? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [Check-Time-of-Use-Time-of-Check] At line 257, code checks if txns.get_mut(&txn_replay_protector) exists. Between check and action at line 277, can another thread remove or modify this transaction? (Critical)"
]