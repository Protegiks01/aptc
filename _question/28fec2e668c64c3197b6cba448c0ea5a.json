[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/lib.rs] [Module: compiler] [Access control] The compiler module is exposed as public - can malicious external code directly call compilation functions to generate invalid bytecode that bypasses Move VM safety checks, potentially leading to arbitrary code execution? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/lib.rs] [Module: context] [Information leakage] The context module is private but used by public compiler - can internal compilation state leak through error messages or side channels, exposing validator private keys or sensitive blockchain state? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/lib.rs] [Module: parser] [Input validation] The parser module is public - can attackers supply maliciously crafted IR input that causes parser to generate invalid AST, leading to type confusion and bypassing Move's resource safety during compilation? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/lib.rs] [Module: compiler] [Determinism] Since compiler is public, can different nodes compile the same IR differently due to environment-dependent behavior, causing consensus failures and chain splits across validators? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::push()] [Integer overflow] The stack depth tracking uses i64 and checks for i64::MAX overflow - can an attacker craft deeply nested expressions that cause integer overflow before reaching i64::MAX, corrupting stack accounting and bypassing gas metering? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::push()] [Stack overflow] At line 148-150, the function bails on i64::MAX but the actual bytecode format uses u16 for stack depth - can attacker create functions with stack depth between u16::MAX and i64::MAX that compile successfully but crash the VM during execution? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::pop()] [Stack underflow] Lines 156-161 check for i64::MIN underflow but don't validate against actual stack contents - can compiler generate bytecode with negative logical stack depth that causes VM to read from invalid memory? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression()] [Stack accounting mismatch] Multiple expression compilation functions call push() but may fail before matching pop() - can error paths leave stack accounting in inconsistent state, causing subsequent bytecode to have incorrect stack depth and crash validators? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Struct: FunctionFrame] [Race condition] Stack depth fields max_stack_depth and cur_stack_depth are not synchronized - in concurrent compilation scenarios, can race conditions cause stack depth miscalculation leading to buffer overflows in VM execution? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_move_function_body()] [Label bypass] Lines 225-257 verify labels are declared and used correctly - can attacker insert duplicate labels with zero-width unicode characters that pass duplicate detection but reference different code locations? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_bytecode_function_body()] [Branch target manipulation] Lines 260-293 verify bytecode labels - can malicious IR specify branch targets that point outside function boundaries, causing VM to jump to arbitrary code locations and achieve RCE? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: label_verification_error()] [Error handling bypass] Lines 195-223 format error messages for label issues - can attackers craft label names that cause format string vulnerabilities or inject code through error message display? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_function()] [Incomplete validation] Lines 298-304 only verify label correctness but not stack balance or type safety - can functions with correct labels but invalid bytecode sequences bypass verification and cause VM crashes? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_blocks()] [Label resolution] Lines 920-939 remap fake label indices to actual offsets - can integer overflow in label_to_index HashMap cause labels to map to wrong offsets, creating unintended control flow that bypasses security checks? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: remap_branch_offsets()] [Offset corruption] Lines 1930-1939 update branch offsets in-place - if fake_to_actual mapping is incomplete, can unmapped offsets remain unchanged, causing branches to wrong locations and potential code execution exploits? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type()] [Type confusion] Lines 661-707 compile IR types to signature tokens - can attacker specify malformed generic types that compile to wrong SignatureToken variants, bypassing Move's type safety and allowing arbitrary resource access? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type()] [Reference safety bypass] Lines 681-688 compile reference types - can mutable references be compiled as immutable or vice versa, allowing write access to supposedly read-only resources and breaking Move's borrow semantics? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_types()] [Type parameter confusion] Lines 651-659 compile type lists - can type parameter indices get confused between function and struct type parameters, causing generic instantiation with wrong types and breaking resource safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: type_parameter_indexes()] [Index overflow] Lines 609-623 assign TypeParameterIndex by casting usize to u16 - can functions with more than 65535 type parameters cause index overflow, resulting in duplicate type parameter bindings that break type system? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type()] [Recursive type exploit] Lines 676-680 handle Vector types recursively - can attackers create deeply nested vector types that cause stack overflow during compilation, DoSing validator nodes during transaction verification? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: struct_type_parameters()] [Phantom type bypass] Lines 625-633 process phantom type parameters - can non-phantom types be marked as phantom to bypass ability checks, allowing storage of non-storable types and breaking Move's resource model? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: abilities()] [Ability escalation] Lines 635-640 fold abilities from AST - can malicious IR specify conflicting abilities (e.g., Copy but not Drop) that compiler accepts but VM rejects, causing transaction failures that waste gas and DoS validators? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Type layout mismatch] Lines 1571-1596 serialize constants using type layouts - can attacker provide constants whose serialized representation doesn't match their declared type, causing VM to deserialize wrong type and achieve type confusion? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Struct constant bypass] Line 1588-1590 explicitly disallows struct constants - can attacker use alternative compilation paths to inject struct constants, potentially embedding malicious code or breaking resource uniqueness? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Reference constant] Lines 1584-1585 reject reference constants - but can reference-like values be encoded through other types (e.g., U256 addresses) that VM interprets as references, bypassing borrow checking? (High)"
]