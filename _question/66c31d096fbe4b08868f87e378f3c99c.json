[
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: TypeRepr] [Equality semantics] Does TypeRepr's Hash implementation (line 23) produce identical hashes across different architectures and Rust versions, or can endianness or hash algorithm changes cause consensus splits when validators upgrade? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Out of bounds] At line 263 `subst[*idx as usize]`, can a malicious bytecode provide a TyParam index larger than the subst array length, causing panic or out-of-bounds read that crashes the validator during transaction execution? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Type parameter injection] Can an attacker craft bytecode with TyParam indices that reference unintended types in the subst array, bypassing Move's type checker and allowing illegal type substitutions like replacing a resource type with u64? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Recursive explosion] Can cyclically-defined types cause instantiate_and_intern() to recurse infinitely (lines 264-298), eventually stack overflowing and crashing the validator when processing malicious Move bytecode? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Type confusion] In struct instantiation at lines 277-282, can incorrect type argument mapping cause a Struct<T, U> to be instantiated as Struct<U, T>, breaking Move's type safety and allowing resource duplication or theft? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Function type abuse] Can attackers exploit function type instantiation at lines 284-297 to create function signatures that violate Move's capabilities model, such as functions that return borrowed references to signer types? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: intern_ty_args()] [Panic condition] Does line 235's comment 'Panics if there are non-instantiated type arguments' mean the function can panic during normal execution, allowing attackers to craft transactions that deliberately trigger panics and halt validator execution? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: InternMap] [Hash collision] Can hash collisions in the HashMap<T, I> at line 54 cause two different types to map to the same ID, breaking type identity and allowing attackers to exploit type confusion vulnerabilities in Move execution? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Insertion race] At line 100 `inner.interned.insert(repr, id)`, can a hash collision cause the HashMap to evict a previous entry, making that TypeId unreachable and causing dangling type references in active execution contexts? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Key collision] Can two different Arc<[TypeId]> values with the same hash collide in the HashMap, causing intern() to return the wrong TypeVecId and breaking struct instantiation correctness? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: InternMap] [Invariant violation] Can the HashMap and Vec fall out of sync if interned.insert() succeeds but data.push() fails (or vice versa), causing interned.len() != data.len() and breaking the bijection between types and IDs? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Arc equality] At lines 120 and 128, does HashMap lookup use Arc pointer equality or content equality, and can this cause duplicate entries if the same type vector is represented by different Arc instances? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush()] [Dangling references] After flush() clears all interned types, can existing TypeIds held by active VM execution contexts become dangling references pointing to invalid/recycled type data, causing use-after-free style bugs? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush_impl()] [Atomicity] Is the flush operation at lines 200-206 atomic across both ty_interner and ty_vec_interner, or can a partial flush leave the pool in an inconsistent state where TypeIds reference cleared TypeVecIds? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush()] [Timing vulnerability] Can attackers trigger flush() at inopportune moments (e.g., mid-transaction) to force re-interning of types with different IDs, breaking type equality checks and causing transaction failures or incorrect execution? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternMap::clear()] [Memory leaks] Does clear() at lines 68-71 properly deallocate all HashMap buckets and Vec capacity, or can repeated flush cycles cause memory fragmentation and gradual performance degradation over days of validator operation? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::warmup()] [Warmup inconsistency] Can warmup() at lines 210-230 produce different initial TypeIds across validators if system load affects execution timing, causing validators to disagree on basic type IDs like Bool and U64? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush()] [State inconsistency] Between flush_impl() and warmup() (lines 194-195), is there a brief window where the pool is empty and concurrent VM operations could crash trying to look up TypeIds in empty data structures? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: ref_of()] [Reference confusion] Can incorrect usage of ref_of() vs ref_mut_of() at lines 301-307 allow immutable and mutable references to be confused, breaking Move's borrow checker semantics and allowing concurrent mutable access to resources? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: ref_mut_of()] [Mutable aliasing] Can ref_mut_of() at line 305-307 be called multiple times with the same TypeId to create multiple mutable reference types that all point to the same underlying type, violating Rust's aliasing rules at the Move VM level? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Enum: TypeRepr] [Reference nesting] Can TypeRepr::Reference(TypeId) and TypeRepr::MutableReference(TypeId) be nested arbitrarily (e.g., &mut &mut T), and does this violate Move's reference safety rules that prohibit nested mutable borrows? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Reference instantiation] In lines 268-274 for Reference and MutableReference types, can type parameter substitution incorrectly convert an immutable reference into a mutable one (or vice versa), breaking Move's ownership model? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: vec_of()] [Vector type confusion] Can vec_of() at line 309-311 be used to create vectors of references (Vector<&T>) which may be prohibited in Move, potentially allowing storage of references that outlive their referents? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Vector recursion] At lines 264-267, can infinite recursion occur if Vector<T> where T itself is Vector<Vector<...>>, causing stack overflow during type instantiation that crashes validators? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Empty vector] Does intern(&[]) at line 227 get special treatment, or can empty type argument vectors cause issues when used with generic structs that require non-zero type parameters? (Medium)"
]