[
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: encoded()] [Encoding cache poisoning] Lines 57-59 return reference to cached encoded bytes—if Entry is created with malicious encoded data that doesn't match deserialized content, can this cause validators to commit wrong state to Merkle tree? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Struct: StateKey] [Hash preimage attack] The StateKey stores both deserialized and encoded forms—can an attacker find second preimages where different StateKeyInner values encode to bytes with same hash, enabling state substitution attacks? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: PartialEq] [Pointer equality bypass] Lines 261-265 use Arc::ptr_eq for equality—can an attacker exploit this by creating multiple Arc instances of identical StateKey content to bypass deduplication in BTreeSet/HashMap collections? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: Ord] [Ordering inconsistency] Lines 283-287 order by deserialized content while equality uses Arc pointers—can this violate Ord/Eq contract requirements, causing BTreeMap corruption and incorrect state ordering? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: PartialOrd] [Ordering non-determinism] Lines 275-280 order StateKeys by deserialized StateKeyInner—if StateKeyInner ordering is non-deterministic across validators, can this cause different state orderings and Merkle tree divergence? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: Hash] [Hash/Eq mismatch] Lines 269-273 hash based on crypto hash while Eq uses pointer equality—can this violate Hash/Eq invariants, causing HashMap lookups to fail for semantically identical keys? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: size()] [Size overflow attack] Lines 101-107 calculate size by summing component sizes—can an attacker craft StateKeys with components that cause integer overflow, resulting in incorrect size reporting for gas metering? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: size()] [Size underestimation exploit] For TableItem (line 104), size is handle.size() + key.len()—if handle.size() doesn't account for all memory overhead, can attackers create underpriced large keys to DoS storage? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: size()] [Raw bytes size manipulation] Line 105 returns raw bytes length directly—can an attacker abuse Raw keys with gigabyte-sized payloads to exhaust storage while only paying for minimal gas? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: is_aptos_code()] [System address spoofing] Lines 221-231 check for hardcoded addresses ONE, THREE, FOUR—can an attacker exploit missing checks for other system addresses (like ZERO, TWO) to bypass system code protections? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: is_aptos_code()] [Code path confusion] Line 224 checks is_code() on AccessPath—can an attacker craft a Resource or ResourceGroup with code-like characteristics to bypass is_aptos_code() checks while still executing as code? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: is_aptos_code()] [Address constant attack] The hardcoded addresses (ONE, THREE, FOUR) at lines 225-227—if these AccountAddress constants change in future versions, can upgrade transitions cause system code misidentification? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: Serialize] [Serialization inconsistency] Lines 242-248 serialize inner StateKeyInner—if serialization produces different bytes than the cached encoded form, can this cause state commitment mismatches across validators? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Impl: Deserialize] [Deserialization error handling] Lines 251-258 call from_deserialized() which can fail—if deserialization error handling differs across validators (e.g., different error message formats), can this cause non-deterministic failures? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: from_deserialized()] [Path deserialization failure] Lines 115-124 handle BCS path deserialization errors—in non-fuzzing mode (line 122), can error propagation timing allow partially constructed StateKeys to leak into the registry? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: from_deserialized()] [Type variant mismatch] Lines 125-129 match Path variants to create different StateKey types—can an attacker craft a Path that matches as Code during deserialization but gets treated as Resource after caching? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: resource_typed()] [Type tag manipulation] Lines 152-154 use T::struct_tag()—can an attacker exploit generic type parameter manipulation to create resource keys for wrong types, bypassing Move type safety? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: on_chain_config()] [Config address spoofing] Lines 156-158 use T::address() and T::struct_tag()—can an attacker implement malicious OnChainConfig trait to return wrong addresses, redirecting config reads to attacker-controlled state? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: module_id()] [ModuleId collision] Lines 186-188 create module keys from ModuleId—can an attacker craft ModuleId values with same address but different names that collide after hashing, causing module substitution? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: resource()] [AccessPath creation failure] Line 144 calls AccessPath::resource_access_path which can fail—if this fails inconsistently across validators due to resource exhaustion, can it cause state divergence? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: resource()] [TOCTOU in get_or_add] Lines 140-141 get from REGISTRY then potentially add—can time-of-check-to-time-of-use race allow duplicate entries with different hashes to exist simultaneously in different shards? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Struct: StateKey] [Arc clone race] StateKey uses Arc<Entry> (line 48)—can concurrent cloning during Entry drop cause use-after-free if weak pointer upgrade happens between drop check and actual deallocation? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: table_item()] [Concurrent key insertion] Lines 191-200 have expect() on registry errors—can concurrent insertions of same table item with different keys cause registry inconsistencies that violate the expect() assumption? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: module()] [Module name race] Lines 175-177 access registry with address and name—can concurrent module additions with same address but different names racing on shard locks cause name corruption? (High)",
  "[File: aptos-core/types/src/state_store/state_key/mod.rs] [Function: decode()] [Multi-stage decode attack] Can an attacker chain multiple decode operations with crafted inputs such that first decode succeeds and caches malicious Entry, then second decode reuses that Entry bypassing validation in registry? (Critical)"
]