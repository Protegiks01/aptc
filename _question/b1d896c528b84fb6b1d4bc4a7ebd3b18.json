[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MoveLoc] [Use after move] Does state.move_loc() at line 262 properly invalidate the source local, or can attackers continue using the moved local causing use-after-free? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::StLoc] [Overwrite borrowed local] Can malicious bytecode use StLoc to overwrite a borrowed local variable, invalidating existing borrows and causing dangling references? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::FreezeRef] [Freeze mutable borrow] Can attackers freeze a mutable reference while it has outstanding mutable borrows, violating the single-writer invariant and causing data races? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::FreezeRef] [Reference ID reuse] Does state.freeze_ref() at line 271 create a new ID that could collide with existing IDs, causing reference confusion? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::Eq/Neq] [Reference comparison bypass] Can attackers compare references while they have mutable borrows (lines 274-279), reading data that should be locked? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::Eq/Neq] [Type confusion] Can malicious bytecode compare a reference with a non-reference value, bypassing type safety checks? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ReadRef] [Read during write] Does state.read_ref() at line 282 properly check for outstanding mutable borrows, or can attackers read data being modified concurrently? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::WriteRef] [Write during read] Can malicious bytecode use WriteRef while immutable borrows exist, violating read-only invariants and causing data corruption? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::WriteRef] [Value validation bypass] In line 288, does the safe_assert properly validate val_operand.is_value(), or can attackers write references into reference targets causing double indirection vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowLoc] [Double mutable borrow] Can attackers create multiple mutable borrows of the same local using MutBorrowLoc at line 292-295, violating single-writer guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowLoc] [Immutable during mutation] Can malicious bytecode create immutable borrows while a mutable borrow exists on the same local, enabling aliasing violations? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowLoc] [Local index bounds] Does state.borrow_loc() validate the local index is within bounds, or can attackers provide out-of-bounds indices accessing arbitrary memory? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowField] [Field aliasing] Can attackers create overlapping mutable field borrows at lines 300-311, violating disjoint borrowing requirements? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowField] [Parent reference leak] Does popping the parent reference and borrowing a field properly track the parent's lifetime, or can the parent be freed while the field borrow exists? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowFieldGeneric] [Type parameter injection] Can malicious bytecode provide crafted type parameters in field_inst at line 314-316 that bypass field type safety checks? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowField] [Field read during write] Can attackers create immutable field borrows while mutable borrows exist on overlapping fields, enabling data races? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowFieldGeneric] [Generic instantiation bypass] Does field_inst resolution at line 340-342 properly validate generic parameters, or can attackers inject arbitrary types causing memory corruption? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowVariantField] [Wrong variant access] Can attackers borrow fields from an inactive variant at lines 352-363, accessing uninitialized memory or wrong-typed data? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowVariantFieldGeneric] [Variant type confusion] Can malicious bytecode use generic instantiation to bypass variant tag checks, accessing fields of the wrong variant type? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowVariantField] [Variant safety bypass] Does get_member_index() at lines 387-391 properly validate the variant is active before allowing field access? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowVariantFieldGeneric] [Cross-variant aliasing] Can attackers create references to fields across different variants of the same enum, causing memory overlap issues? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowGlobal] [Global double borrow] Can malicious bytecode create multiple mutable global borrows of the same resource type at line 410-413, violating single-writer invariant for global state? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowGlobal] [Address manipulation] Does the address operand popped at line 411 get properly validated, or can attackers provide crafted addresses to borrow unauthorized resources? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::MutBorrowGlobalGeneric] [Generic resource bypass] Can attackers use struct_instantiation_at at line 417 to bypass access control on generic resources? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/reference_safety/mod.rs] [Function: execute_inner() - Bytecode::ImmBorrowGlobal] [Read during acquisition] Can malicious bytecode borrow global resources immutably while they're acquired by calling functions, violating Move's acquires semantics? (Critical)"
]