[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Separator injection] The sep parameter at line 149 is used directly at line 163 without sanitization - can malicious separators containing newlines or special characters disrupt output parsing or cause format corruption? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::comma()] [Callback recursion] At lines 176-179, comma() calls list() with closure f that processes items - can deeply nested data structures cause f to recursively call comma() again, leading to stack overflow? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::comma()] [Iterator exhaustion] The comma() method passes items to list() which calls into_iter() - can this cause iterator exhaustion issues if the same iterator is used multiple times, leading to incomplete AST output? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::semicolon()] [Excessive newlines] At line 189, semicolon() returns true for needs_newline, causing new_line() to be called for each item - can this cause unbounded growth of the lines vector for large item lists, exhausting memory? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::semicolon()] [Stack recursion] Similar to comma(), can semicolon() at lines 182-191 cause recursive calls through closure f, leading to stack exhaustion when processing deeply nested AST structures? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: std::fmt::Display::fmt()] [Format string vulnerability] At lines 196-198, the Display trait iterates over all lines and uses writeln! macro - can extremely long lines cause buffer overflow or format string vulnerabilities in the writeln! implementation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: std::fmt::Display::fmt()] [Error handling] The writeln! at line 197 returns early with ? operator on error - can formatting errors leave the AstWriter in an inconsistent state, affecting subsequent compilation attempts? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: std::fmt::Display::fmt()] [Memory amplification] The loop at line 196 processes all lines in self.lines without bounds - can malicious AST structures with millions of lines cause O(nÂ²) memory usage during display formatting? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: print()] [Unbounded output] At lines 38-42, print() writes directly to stdout without size limits - can malicious AST structures cause the compiler to emit gigabytes of debug output, filling disk or overwhelming logging systems? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: print_verbose()] [Resource exhaustion] At lines 44-48, print_verbose() enables verbose mode which adds annotations to every node - can this cause exponential output growth for large AST structures, exhausting system resources? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: print()] [Output injection] The print! macro at line 41 outputs AstWriter content directly - can malicious AST content containing terminal escape codes or control characters compromise the developer's terminal or corrupt log files? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: display()] [String allocation] At lines 50-54, display() converts the entire AstWriter to String then calls trim() and to_string() again - can this cause multiple large allocations for huge AST structures, leading to memory exhaustion? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: display_verbose()] [Incorrect mode] At lines 56-60, display_verbose() creates AstWriter::normal() instead of verbose() - is this a bug that causes verbose display to not actually enable verbose mode, potentially hiding important AST information needed for security audits? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: display()] [Memory leak] The to_string() calls at lines 53 and 59 create String copies - can repeated display() calls on large AST structures cause memory fragmentation or leak detection issues in long-running compiler processes? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: Box<T>::ast_debug()] [Recursion depth] At lines 32-36, the Box<T> implementation calls self.as_ref().ast_debug(w) - can deeply nested Box wrappers in AST structures cause stack overflow through recursive ast_debug calls? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: Box<T>::ast_debug()] [Cyclic references] Does the Box<T> implementation handle cyclic Box references in AST nodes? Can circular Box structures cause infinite recursion at line 34, crashing the compiler? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: Spanned<T>::ast_debug()] [Location information loss] At lines 203-207, the Spanned<T> implementation only calls ast_debug on the inner value, ignoring location information - can this cause security-critical location data to be lost in debug output, making it harder to track exploit origins? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: Spanned<T>::ast_debug()] [Recursion continuation] The implementation at line 205 delegates to self.value.ast_debug(w) - can this propagate recursion issues from the wrapped type, amplifying stack overflow risks in deeply nested spanned structures? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::new()] [Initial state] At lines 69-75, new() creates a vector with one empty String - can this initial state cause issues if methods are called in unexpected order, leading to panics in cur() or write()? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::normal()] [Mode confusion] The normal() and verbose() constructors at lines 77-83 only differ in boolean flag - can mode confusion cause sensitive AST information to be leaked or hidden inappropriately? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Multiple functions] [Compound recursion] Can an attacker craft AST structures that cause indent() to call block() which calls annotate() which calls list(), creating a deep recursion chain that exceeds stack limits and crashes the compiler? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Multiple functions] [Memory exhaustion chain] Can combining large margin values from indent(), many new_line() calls, and long strings in write() cause multiplicative memory growth, exhausting compiler memory even for moderately-sized AST structures? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Multiple functions] [State machine corruption] Can interleaving calls to write(), new_line(), and indent() in unexpected orders cause the lines vector and margin value to desynchronize, producing corrupt output or causing panics? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Multiple functions] [Iterator invalidation] Can modifications to AstWriter state during list() iteration (through closure f calling write/indent/etc) invalidate iterator assumptions about size_hint() or enumeration count? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::write()] [Empty string handling] What happens when write() is called with an empty string at line 99? Can this cause issues with margin tracking or line state management? (Low)"
]