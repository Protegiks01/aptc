[
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [State Corruption] Can concurrent calls to new() for the same shard_id create race conditions where multiple pruner instances operate on the same shard simultaneously, causing conflicting pruning operations and Merkle tree corruption? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Progress Inconsistency] In get_or_initialize_subpruner_progress() call, if metadata_progress is ahead of actual pruning state, can this cause the pruner to skip versions and create gaps in state history leading to state unavailability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [DoS/Resource Exhaustion] The initialization calls prune() with usize::MAX as max_nodes_to_prune - can a large backlog of stale nodes cause unbounded memory consumption during initialization, leading to OOM crashes and node unavailability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Atomicity Violation] If the node crashes during the catch-up prune() call, is the progress properly persisted, or can partial pruning leave the database in an inconsistent state with some nodes deleted but progress not recorded? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Integer Overflow] Can metadata_progress parameter overflow when passed to get_or_initialize_subpruner_progress(), causing wraparound and incorrect progress initialization that breaks pruning logic? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Progress Corruption] If get_or_initialize_subpruner_progress() returns a progress value greater than metadata_progress, can the subsequent prune() call with inverted version range cause database corruption or panic? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Shard ID Validation] Is shard_id validated against the actual number of shards in the database? Can an attacker provide an out-of-bounds shard_id that causes panics or accesses wrong database shards? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Database Handle Safety] The db_shard Arc<DB> is cloned - if the underlying database is closed or corrupted during initialization, can this lead to undefined behavior or data corruption? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Error Propagation] If get_or_initialize_subpruner_progress() or the initial prune() call fails, are the errors properly handled, or can partially constructed pruners remain in memory causing future issues? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: new()] [Concurrent Initialization] Can multiple threads call new() with the same shard_id simultaneously, and if so, can this cause duplicate progress metadata writes that lead to inconsistent state? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Infinite Loop DoS] The loop at line 64 continues until 'done' is true - can a malicious state or corrupted stale indices cause this loop to never terminate, hanging the pruner thread indefinitely? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Version Validation] Are current_progress and target_version properly validated before entering the loop? Can target_version < current_progress cause undefined behavior or integer underflow? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Max Nodes Bypass] Can max_nodes_to_prune be set to 0, causing get_stale_node_indices() to return empty results but the loop to continue infinitely checking the same range? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Progress Tracking Race] If prune() is called concurrently for the same shard from different threads, can race conditions in progress updates cause versions to be skipped or pruned multiple times? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [State Inconsistency] The loop doesn't update current_progress within iterations - if next_version is returned but not used to advance progress, can this cause the same version range to be queried repeatedly? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Iterator Corruption] StateMerklePruner::get_stale_node_indices() creates a database iterator - can concurrent writes to the database during iteration cause the iterator to return corrupted or duplicate indices? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Version Boundary Attack] If stale_since_version equals target_version exactly, are boundary conditions handled correctly, or can off-by-one errors cause nodes to be pruned prematurely or retained incorrectly? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Empty Result Handling] If get_stale_node_indices() returns an empty indices vector but next_version is Some, does the logic correctly handle this case, or can it cause incorrect progress updates? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Next Version Overflow] Can next_version overflow Version type (u64) and wrap around, causing the done check at line 80 to incorrectly determine completion? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Database Read Errors] If get_stale_node_indices() encounters database read errors mid-iteration, are partial results properly handled, or can this cause incomplete pruning with progress still being updated? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Atomic Deletion Failure] The batch deletes both JellyfishMerkleNodeSchema and stale index schema S - if one deletion succeeds but the other fails, can this create inconsistency where nodes exist without indices or vice versa? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Merkle Tree Integrity] When deleting JellyfishMerkleNodeSchema entries via index.node_key, is there verification that the node is actually stale and not part of a current state root? Can premature deletion corrupt active Merkle tree paths? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Batch Size Limits] SchemaBatch has internal size limits - can large indices vectors exceed batch capacity causing write failures? Are oversized batches properly detected and split? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Index Double Deletion] If the same StaleNodeIndex appears multiple times in indices vector (due to bugs elsewhere), can double-deletion cause errors or inconsistent batch application? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs] [Function: prune()] [Node Key Collision] Can malicious or corrupted index.node_key values collide with non-stale node keys, causing active Merkle tree nodes to be incorrectly deleted? (Critical)"
]