[
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Exp_::Move] [Move semantics] Does Move expression properly invalidate the source variable to prevent use-after-move errors in subsequent code? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Exp_::Copy] [Copy ability validation] Can Copy expression be used on types lacking Copy ability, violating resource uniqueness constraints? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Exp_::BorrowLocal] [Variable existence] Does BorrowLocal validate that the Var being borrowed exists and is in scope to prevent references to undefined variables? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Exp_::FunctionCall] [Argument type validation] Can FunctionCall pass arguments of incompatible types to the callee, causing type mismatches during function invocation? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Exp_::ExprList] [Length validation] Does ExprList validate consistency when used as function arguments or tuple returns to prevent arity mismatches? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Function: Exp_::add()] [Overflow checking] Does the add() helper properly check for addition overflow to prevent silent wrapping in arithmetic expressions? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Function: Exp_::sub()] [Underflow checking] Does sub() validate against underflow when subtracting unsigned integers to prevent wrap-around to large values? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: CopyableVal_] [Address validation] Does CopyableVal_::Address validate that AccountAddress values are well-formed and don't contain invalid byte patterns? (Medium)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: CopyableVal_] [Integer bounds] Are integer variants (U8-U256) validated to ensure values fit within their declared bit widths to prevent silent truncation? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: CopyableVal_::ByteArray] [Size limits] Does ByteArray validate maximum size to prevent memory exhaustion attacks through oversized constant byte arrays? (Medium)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: CopyableVal_::U256] [Large integer handling] Can U256 values cause arithmetic overflow in operations or comparisons due to their 256-bit size? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_] [Instruction validation] Does each Bytecode_ variant validate its operands to ensure they conform to expected types and constraints? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::BrTrue/BrFalse] [Label validity] Can branch instructions reference invalid or non-existent BlockLabel_ targets, causing jumps to arbitrary code locations? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::LdConst] [Type-value consistency] Does LdConst validate that the MoveValue matches the declared Type to prevent type confusion when loading constants? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::Call] [Function signature matching] Can Call bytecode invoke functions with mismatched type_actuals that don't satisfy the callee's type constraints? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::Pack/Unpack] [Field count validation] Do Pack and Unpack bytecodes validate that the correct number of values are on the stack for the struct definition? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::ReadRef/WriteRef] [Reference validity] Can ReadRef/WriteRef operate on invalid or dangling references, causing memory safety violations? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::MutBorrowField] [Mutability validation] Does MutBorrowField verify that the struct reference is mutable before creating mutable field references? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::MutBorrowGlobal] [Authorization check] Can MutBorrowGlobal bypass signer validation to obtain mutable references to resources the caller doesn't own? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::Exists] [Type instantiation] Does Exists bytecode properly instantiate generic structs with type_actuals before checking existence in global storage? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::MoveFrom] [Resource extraction] Can MoveFrom extract resources without proper signer authority, allowing unauthorized resource theft? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::MoveTo] [Duplicate prevention] Does MoveTo prevent publishing duplicate resource instances to the same account address? (Critical)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::CastU8-CastU256] [Safe casting] Do cast bytecodes handle overflow/underflow safely when converting between integer types of different sizes? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::VecPack] [Count validation] Does VecPack validate that the u64 count matches stack depth to prevent stack underflow or overflow? (High)",
  "[File: aptos-core/third_party/move/move-ir/types/src/ast.rs] [Enum: Bytecode_::VecUnpack] [Type consistency] Can VecUnpack be exploited with mismatched Type and count to cause type confusion when unpacking vectors? (High)"
]