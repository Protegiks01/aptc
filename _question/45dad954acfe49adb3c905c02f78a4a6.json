[
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 269-311] [Author verification bypass] Can an attacker craft a SignedBatchInfo where signed_batch_info.author() matches peer_id at line 274 but the actual batch author differs, bypassing the WrongAuthor check? (Critical)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 277-283] [Batch existence race] Between checking batch_reader.exists() at line 278 and inserting into batch_info_to_proof at line 290, can an attacker delete the batch causing state inconsistencies? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 281-283] [Author mismatch exploitation] If batch_author != signed_batch_info.author() at line 281, the function returns WrongAuthor error, but has a timeout already been added at line 285-288? This could cause memory leaks from orphaned timeouts. (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 285-288] [Timeout poisoning] Can an attacker initialize timeouts for batch_info before validation completes, then fail validation, causing timeouts to remain in the Timeouts structure and eventually expire incorrectly? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 289-301] [Version confusion attack] Can an attacker exploit the is_v2() check at line 289 to trigger incorrect aggregator initialization (BatchInfo vs BatchInfoExt), causing type confusion in signature aggregation? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: init_proof() lines 302-304] [Timestamp race condition] The or_insert(Instant::now()) at line 304 uses entry API, but can concurrent init_proof calls for the same batch cause multiple timestamps to be created, leading to incorrect time measurements? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: add_signature() lines 318-323] [Double initialization] When init_proof is called from add_signature at line 322, can an attacker trigger init_proof multiple times to reset the aggregator state and discard previously collected signatures? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: add_signature() lines 324-351] [Missing entry handling] If batch_info_to_proof.get_mut() returns None at line 349 despite passing the contains_key check at line 319, can this cause a SignedBatchInfoError::NotFound to be returned after signatures were already processed? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: expire() lines 369-402] [Expiration race condition] Can a proof complete between timeouts.expire() at line 371 and batch_info_to_proof.remove() at line 372, causing a completed proof to be incorrectly removed and stats to be wrong? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: expire() lines 374-376] [Batch ID collection logic] Only incomplete proofs are added to batch_ids at lines 374-375, but can an attacker manipulate the completed flag to prevent batch expiration notifications from being sent? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: update_counters_on_expire() lines 355-367] [Counter manipulation] Can an attacker exploit the counter update logic to incorrectly classify late votes vs. timeout batches, affecting monitoring and potentially hiding DoS attacks? (Low)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: expire() lines 378-383] [Metrics skip vulnerability] When !state.completed && !state.self_voted at line 380, metrics are skipped with continue - can an attacker exploit this to hide failed proofs from monitoring systems? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: expire() lines 394-401] [Channel send failure] When batch_generator_cmd_tx.send() fails at line 398, only a warning is logged - can repeated failures cause batch expirations to be silently lost, leading to memory leaks? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: new() lines 246-267] [Timeout configuration] The proof_timeout_ms parameter at line 247 is stored as usize, but can an attacker manipulate configuration to set an extremely small or large timeout causing proofs to expire prematurely or never? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: expire() lines 369-402] [Incomplete state cleanup] Does expire() properly clean up batch_info_to_time entries for expired batches, or can the HashMap grow unbounded if timestamps are not removed? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 404-511] [Shutdown race condition] Can an attacker send commands after Shutdown at line 415 is received but before the loop breaks at line 420, causing commands to be processed in an inconsistent shutdown state? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 422-442] [CommitNotification processing] Can an attacker send malicious CommitNotification with batches that don't exist in batch_info_to_proof to cause spurious log messages or exhaust log storage? (Low)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 426-441] [Batch comparison vulnerability] The batch == existing_proof.get().batch_info() comparison at line 427 could be expensive for large batches - can an attacker send commit notifications with huge batches to cause performance degradation? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 444-503] [Empty signature message] When signed_batch_infos.first() returns None at line 446, the function returns early instead of breaking - does this cause the main loop to exit prematurely, halting the ProofCoordinator? (Critical)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 450-455] [Timestamp approximation] The approx_created_ts_usecs calculation at lines 451-453 uses saturating_sub with batch_expiry_gap_when_init_usecs - can an attacker manipulate expiration to cause timestamp underflow or incorrect batch age calculations? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 457-481] [Filter_map proof iterator] Can an attacker send a mix of valid and invalid signed_batch_infos to cause some to succeed and others to fail, resulting in partial proof generation that leaves the system in an inconsistent state? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 461-480] [Error handling in iterator] When add_signature returns an error at line 471, the error is logged but iteration continues - can attackers flood with invalid signatures to fill logs and hide legitimate errors? (Medium)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 473-476] [Self-signature error logging] Why is there different logging for self.peer_id vs. other peers at lines 473-476? Can an attacker impersonate self to get info-level logs instead of debug, affecting log analysis? (Low)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 482-499] [Proof broadcast logic] The broadcast_proofs flag at line 484 determines whether proofs are broadcast or sent to self - can an attacker manipulate this configuration to prevent proof propagation across the network? (High)",
  "[File: aptos-core/consensus/src/quorum_store/proof_coordinator.rs] [Function: start() lines 485-494] [V2 proof detection] Can an attacker exploit the is_v2() check at line 485 to cause proofs to be broadcast using the wrong protocol version, leading to network consensus failures? (High)"
]