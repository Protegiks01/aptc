[
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Deadlock vulnerability] Can concurrent calls to collect() from multiple Prometheus scrape threads cause lock contention on the Arc<Mutex<System>>, potentially blocking validator node metrics collection and degrading consensus participation if metrics collection stalls? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Race condition] If collect() is called concurrently while system.refresh_cpu() is executing, can race conditions in the underlying sysinfo library cause inconsistent CPU usage readings that misrepresent validator node health to monitoring systems? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: new()] [Shared state corruption] Since the System object is wrapped in Arc<Mutex> and shared, can multiple collector instances created through Registry registration corrupt shared CPU state through concurrent refresh operations? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Lock poisoning] If system.refresh_cpu() panics while holding the mutex lock (e.g., due to FFI errors in sysinfo), does the poisoned mutex permanently break all future metrics collection, causing complete loss of CPU monitoring visibility? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Blocking operation] Does the call to system.refresh_cpu() block for an unbounded time when reading from /proc filesystem on Linux, potentially causing Prometheus HTTP handler threads to hang and degrade validator API responsiveness? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: new()] [Panic vulnerability] The unwrap() call on line 40 after describe() can panic if metric descriptor creation fails - can an attacker trigger this panic through environment manipulation (e.g., invalid metric names in NAMESPACE constant) to crash the validator node? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: new()] [Panic vulnerability] The unwrap() call on line 46 after describe() for cpu_info descriptor can panic - if this fails during validator startup, does it crash the entire node preventing it from participating in consensus? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Panic vulnerability] Lines 80 and 92 contain unwrap() calls on ConstMetric::new_gauge() - can malicious or malformed CPU information from sysinfo (e.g., extremely long CPU names or special characters) cause metric creation to fail and panic, crashing the validator? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Panic vulnerability] The unwrap() call on line 105 for cpu_info metric creation - if global_cpu_info().brand() or vendor_id() return values that violate Prometheus label constraints, can this panic crash the node during metrics collection? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Error propagation] None of the unwrap() calls have error handling - if any metric creation fails, the entire collect() method panics rather than returning partial metrics. Can this be exploited to deny metrics visibility during critical validator operations? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Memory exhaustion] Lines 82-95 iterate over system.cpus() and create a gauge for each CPU core - on a system with thousands of virtual CPUs (cloud VMs with hyperthreading), can this allocate unbounded memory in the per_cpu_usage vector, causing OOM and validator crash? (High)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Vector allocation] Line 107 pre-allocates a vector with capacity 2 + per_cpu_usage.len(), but per_cpu_usage is already a fully allocated Vec<MetricFamily> - on high-core-count systems, does this cause double memory allocation amplifying memory pressure? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [CPU resource exhaustion] The call to system.refresh_cpu() on line 72 reads CPU statistics from kernel - on systems under high I/O pressure or with slow /proc filesystem, can this operation take excessive time (seconds), causing Prometheus scrapes to timeout and metrics collection to fail repeatedly? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Repeated allocation] Each collect() call creates new ConstMetric instances and Vec allocations - if Prometheus scrapes occur at high frequency (e.g., every second), does this cause memory allocation churn that increases GC pressure and degrades validator performance during consensus-critical operations? (Low)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: new()] [System resource leak] System::new_with_specifics() on lines 32-34 initializes system information structures - if this allocates kernel resources (file descriptors, memory buffers) but CpuMetricsCollector is created and dropped repeatedly, can this leak system resources over time? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Metric cardinality explosion] Line 90 creates CPU labels using format!(\\",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Label injection] Lines 78-79 use global_cpu_info().name() directly as a metric label - if the CPU name contains newlines, null bytes, or Prometheus special characters, can this break metric parsing or inject malicious label values into the metrics endpoint? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Label injection] Lines 101-102 use global_cpu_info().brand() and vendor_id() as labels - these strings come from CPUID instructions and /proc/cpuinfo which could be virtualized or manipulated. Can malicious hypervisors inject exploit payloads through CPU identification strings? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Label validation bypass] The CPU_ID_LABEL, CPU_BRAND_LABEL, and CPU_VENDOR_LABEL are declared as variable_label() in the descriptor (lines 38, 43-44) - does Prometheus validate these labels properly, or can injection of = or , characters break label parsing? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Unicode injection] CPU names and brands may contain Unicode characters from localized system info - can attackers use Unicode normalization attacks or bidirectional text overrides in CPU labels to disguise malicious validators or confuse monitoring dashboards? (Low)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Type conversion loss] Line 77 converts global_cpu_info().cpu_usage() as f64 - if cpu_usage() returns a value outside f64's precision range or is NaN/Infinity from hardware errors, can this cause incorrect CPU usage reporting that masks validator overload? (Medium)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Type conversion loss] Line 89 converts cpu.cpu_usage() as f64 for per-CPU metrics - if individual CPU usage values have precision loss during f32 to f64 conversion, can this cause accumulated inaccuracies in aggregate CPU monitoring affecting validator capacity planning? (Low)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Index overflow] Line 90 calculates idx + 1 where idx is from enumerate() - on systems with usize::MAX CPUs (theoretical), can idx + 1 overflow causing incorrect CPU numbering in labels? (Low)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Gauge value constraint] ConstMetric::new_gauge() on line 97-99 sets value 1.0 for cpu_info - if this is later changed to a dynamic value, can negative or infinite gauge values break Prometheus aggregation rules or trigger scrape failures? (Low)",
  "[File: aptos-core/crates/node-resource-metrics/src/collectors/cpu_metrics_collector.rs] [Function: collect()] [Type safety] cpu_usage() returns f32 in sysinfo library but is cast to f64 - does this conversion properly handle CPU usage values >100% from buggy kernel reporting or hardware counters, which could indicate compromised system metrics? (Low)"
]