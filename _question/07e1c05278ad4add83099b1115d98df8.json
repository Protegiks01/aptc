[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: Address] [Type Confusion] Can an attacker craft a Move module with Address::Numerical and Address::NamedUnassigned variants that compare as equal despite representing different addresses, allowing module identity confusion and unauthorized access to restricted modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Address::eq (lines 633-641)] [Address Spoofing] Does the PartialEq implementation for Address correctly handle the case where a Numerical address with optional Name could match a NamedUnassigned address, potentially allowing an attacker to bypass address-based access controls in the Aptos framework? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Address::cmp (lines 651-663)] [Ordering Inconsistency] Can the Ord implementation for Address create inconsistent ordering between Numerical and NamedUnassigned variants, allowing an attacker to manipulate dependency resolution order and inject malicious modules earlier in the compilation pipeline? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Address::hash (lines 665-672)] [Hash Collision] Does the Hash implementation for Address properly prevent hash collisions between Numerical(None, addr) and NamedUnassigned variants, or can an attacker craft addresses that hash to the same value to bypass UniqueMap/UniqueSet deduplication in module tracking? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Address::anonymous (lines 679-681)] [Address Construction] Can the anonymous() constructor be exploited to create Numerical addresses without proper validation, allowing attackers to generate system addresses (0x0, 0x1) that bypass Aptos framework access controls? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Address::into_addr_bytes (lines 683-689)] [Address Resolution] Does into_addr_bytes() return DEFAULT_ERROR_ADDRESS for NamedUnassigned addresses without validation, potentially allowing unresolved addresses to silently map to a default address that could be exploited for unauthorized module access? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: ModuleIdent_] [Module Spoofing] Can an attacker create two ModuleIdent_ instances with semantically identical but syntactically different Address representations that bypass duplicate module detection in UniqueMap, allowing duplicate module definitions to corrupt the module registry? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: ModuleIdent_::new (lines 691-694)] [Module Identity] Does the new() constructor validate that the address parameter is properly resolved before creating a ModuleIdent_, or can attackers inject NamedUnassigned addresses that later resolve to different values across validators, causing consensus failures? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Trait: TName for ModuleIdent (lines 591-606)] [Key Comparison] Can the TName trait implementation for ModuleIdent be exploited through location manipulation to create module identifiers that compare as different in UniqueMap but represent the same logical module, allowing multiple conflicting module definitions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Display: ModuleIdent_ (lines 902-906)] [Display Injection] Does the Display implementation for ModuleIdent_ properly escape special characters in address and module names, or can attackers inject formatting strings that corrupt log outputs or diagnostic messages to hide malicious module loading? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: AbilitySet] [Ability Bypass] Can an attacker manipulate the AbilitySet wrapper around UniqueSet to add duplicate abilities or bypass ability constraint checking, allowing resources without 'store' ability to be stored in global storage and violating Move's resource safety model? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::add (lines 736-738)] [Constraint Violation] Does the add() method properly validate that abilities are only added once and with correct locations, or can duplicate ability additions with different locations corrupt the ability constraint system and allow type-unsafe operations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::intersect (lines 749-751)] [Ability Weakening] Can the intersect() operation be exploited to weaken ability constraints by incorrectly computing the intersection, allowing types to gain abilities they shouldn't have and bypassing Move's type system safety guarantees? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::union (lines 754-756)] [Ability Escalation] Does the union() operation validate that combining ability sets doesn't create invalid ability combinations (e.g., Key without Store), or can attackers escalate abilities to create resource types that violate safety invariants? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::is_subset (lines 758-760)] [Subset Check Bypass] Can the is_subset() check be circumvented through ability set manipulation to make a more restrictive type appear compatible with a less restrictive context, allowing unauthorized type substitutions in Move bytecode? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::from_abilities (lines 766-770)] [Duplicate Abilities] Does from_abilities() properly reject duplicate ability specifications with different locations, or can attackers inject conflicting ability declarations that create ambiguous type signatures causing validation inconsistencies across validators? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Constants: AbilitySet::ALL/PRIMITIVES/REFERENCES (lines 709-722)] [Constant Tampering] Are the predefined ability constant arrays (ALL, PRIMITIVES, REFERENCES, SIGNER, COLLECTION) immutable and validated at compilation time, or can they be modified to grant incorrect default abilities to built-in types, breaking fundamental Move type system assumptions? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::all (lines 779-781)] [Ability Inflation] Can the all() constructor be misused to grant all four abilities to types that shouldn't have them (e.g., giving 'key' ability to non-resource types), allowing attackers to bypass resource tracking and create unauthorized global storage entries? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: AbilitySet::has_ability_ (lines 744-746)] [Ability Query Bypass] Does has_ability_() correctly distinguish between Copy/Drop/Store/Key abilities, or can ability value confusion allow an attacker to query for one ability but check another, bypassing ability constraints in type checking? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Iterator: AbilitySetIter (lines 824-845)] [Iterator Manipulation] Can the AbilitySetIter iterator be exploited to skip or duplicate ability values during iteration, causing incomplete ability validation in type checking passes and allowing ability constraint violations? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: Type_] [Type Confusion] Can an attacker exploit the Type_ enum variants (Unit, Multiple, Apply, Ref, Fun, UnresolvedError) to create type confusion attacks where a reference type is treated as an owned type, bypassing Move's borrow checking and allowing use-after-free vulnerabilities? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Type_::Apply] [Generic Type Injection] Can the Apply variant be exploited with malicious type arguments to instantiate generic types with incorrect abilities, allowing attackers to store non-storable types in global storage or copy non-copyable resources? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Type_::Ref] [Reference Safety] Does the Ref(bool, Box<Type>) variant properly validate that the inner type is referenceable and the mutability flag is consistent with ability constraints, or can attackers create mutable references to immutable data causing memory safety violations? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Type_::Fun] [Function Type Safety] Can the Fun(Vec<Type>, Box<Type>, AbilitySet) variant be manipulated to create function types with incorrect ability constraints, allowing first-class functions to violate Move's resource safety model by capturing non-droppable resources incorrectly? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Type_::Multiple] [Tuple Type Confusion] Can the Multiple(Vec<Type>) variant be exploited to create tuples with inconsistent type counts or ordering that bypass signature matching, allowing function calls with mismatched argument types that could corrupt the stack or cause runtime panics? (High)"
]