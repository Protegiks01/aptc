[
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_events()] [No Version Validation] The version parameter is not validated (line 312). Can state sync accidentally or maliciously call with version 0, u64::MAX, or out-of-order versions, causing subscribers to process events incorrectly? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_subscriber_of_events()] [Version in Notification] The version is included in EventNotification (line 353), but subscribers might process notifications out of order due to channel buffering. Can this cause event reordering issues in subscribers? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Version Parameter] The version passed to notify_subscriber_of_configs (line 272) must match read_on_chain_configs version. Can version drift cause configs to be read at one version but reported as another? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_initial_configs()] [Initial vs Ongoing] This function is for startup scenarios (line 329-331), but can it be called during normal operation? Can malicious state sync components abuse this to reset subscribers to arbitrary historical states? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [V1 vs V2 Event Handling] The code handles both ContractEvent::V1 and V2 differently (lines 218-224). Can events be crafted to match both types simultaneously, or can type confusion cause events to be misprocessed? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [to_canonical_string()] The V2 event tag is converted using to_canonical_string() (line 221). Can collisions in canonical string representations cause different event types to be treated as identical? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Empty Subscription Check] The check event_keys.is_empty() && event_v2_tags.is_empty() prevents zero subscriptions (line 116), but can an attacker pass vectors with invalid or malformed keys that pass validation but never match events? (Low)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Duplicate Keys] If event_keys contains duplicates, are they inserted multiple times into event_key_subscriptions? Can this cause the same subscription ID to be registered multiple times unnecessarily? (Low)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [is_new_epoch_event()] The function relies on event.is_new_epoch_event() (line 243). Can a compromised Move module emit events that falsely trigger this check, causing spurious reconfigurations? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Struct: EventSubscriptionService] [Unbounded HashMaps] All three subscription HashMaps can grow without limit (lines 78-80, 83). Can an attacker create millions of subscriptions to exhaust validator memory? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [HashSet Growth] Each EventKey can have unbounded HashSet<SubscriptionId> (lines 143-148). Can an attacker subscribe to the same event key millions of times to cause memory exhaustion? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [HashSet Allocation] A new HashSet is created for event_subscription_ids_to_notify (line 214). For batches with thousands of events and subscribers, can this cause excessive allocations and GC pressure? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Event Buffer Accumulation] Events are buffered in event_subscription.event_buffer (line 234) before notification. Can large event batches cause memory spikes as all subscriptions accumulate their buffers? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: EventSubscription::buffer_event()] [Vec::push()] Events are pushed without capacity pre-allocation (line 347). Can this cause frequent reallocations and memory fragmentation during high-throughput periods? (Low)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Channel Creation] Channels are created with aptos_channel::new (lines 120-121). Can channel creation fail under resource pressure, and if so, is the failure handled gracefully? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_reconfigurations()] [KLAST Behavior] With QueueStyle::KLAST (line 176), can reconfig notifications be lost if subscribers are slow? Given RECONFIG_NOTIFICATION_CHANNEL_SIZE is 1, can missing epoch transitions cause validators to desynchronize? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Receiver Lifecycle] If EventNotificationListener is dropped without consuming messages, can this cause the channel to fill and block the sender, potentially halting event processing? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_subscriber_of_events()] [notification_sender.push()] The push() operation can fail (line 356-358). Can repeated failures cause events to be permanently lost, and is there any retry or recovery mechanism? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_subscriber_of_configs()] [push() Error Handling] Reconfiguration push failures return UnexpectedErrorEncountered (line 382). Can this generic error hide critical information about why epoch transitions are failing? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Struct: NotificationListener] [Stream Implementation] The Stream trait is implemented at lines 448-454. Can improper polling cause notifications to be missed or processed out of order? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: NotificationListener::poll_next()] [FusedStream] The stream is fused (line 456-459), but can premature termination cause subscribers to stop receiving critical updates during validator operation? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: NotificationListener::is_terminated()] [Termination Check] If notification_receiver.is_terminated() returns true unexpectedly, can this cause silent failures where components think they're subscribed but receive no notifications? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Governance Impact] If reconfiguration notifications fail during governance proposal execution, can this cause voting power calculations to be based on stale state, leading to incorrect proposal outcomes? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_events()] [Staking Impact] If epoch transition events (reconfigurations) are not properly delivered, can validators miss staking reward distributions or slashing events, causing economic losses? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: read_on_chain_configs()] [Validator Set Updates] If ConfigurationResource reading fails during validator set changes, can this cause the network to operate with incorrect validator sets, violating BFT assumptions? (Critical)"
]