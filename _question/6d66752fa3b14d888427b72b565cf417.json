[
  "[File: aptos-core/network/memsocket/src/lib.rs] [Static: SWITCHBOARD] [Race Condition] Can multiple threads simultaneously call MemoryListener::bind() with port 0, causing race conditions in the port allocation loop that result in duplicate port assignments or infinite loops when next_port_to_check wraps around? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Static: SWITCHBOARD] [Deadlock] Can recursive or nested calls to functions that acquire the SWITCHBOARD lock (bind/connect/drop) cause deadlock scenarios, particularly when Drop::drop() is called while holding other locks? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Static: SWITCHBOARD] [Lock Contention] Can an attacker cause severe lock contention by rapidly calling bind() and connect() operations from multiple threads, degrading validator network performance during critical consensus operations? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Static: SWITCHBOARD] [Memory Leak] If a thread panics while holding the SWITCHBOARD Mutex lock, does the poisoned lock permanently prevent all future bind() and connect() operations, causing complete network test failure? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [Port Exhaustion] Can an attacker exhaust all 65534 available ports (port 1 to u16::MAX) by repeatedly calling bind() without dropping listeners, causing all subsequent bind(0) calls to fail with AddrInUse error? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [Integer Overflow] In the port allocation loop, when next_port_to_check reaches u16::MAX, does the checked_add(1).unwrap_or(PORT_TO_START_AT) logic correctly wrap to port 1, or can edge cases cause incorrect port selection? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [Off-by-One Error] The check 'Some(switchboard.port_to_sender_map.len()) == u16::MAX.checked_sub(1).map(usize::from)' allows 65534 ports but excludes port 0 - can this off-by-one calculation be exploited to bind to invalid ports? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [Race Window] Between checking if a port is available with contains_key() and actually inserting it with insert(), can another thread steal the port, causing the first thread to overwrite an active listener? (Critical)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [Port Prediction] Since next_port_to_check is sequential and shared globally, can an attacker predict which port will be allocated next for bind(0) and preemptively bind to it, causing DoS? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: bind()] [NonZeroU16 Panic] When port is non-zero, the code uses NonZeroU16::new(port).unwrap_or_else(|| unreachable!()) - is this truly unreachable, or can port somehow be 0 after the if port != 0 check due to race conditions? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: connect()] [Connection Flooding] Can an attacker flood a MemoryListener by rapidly calling connect() to send unlimited MemorySocket instances through the unbounded channel, exhausting memory? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: connect()] [Port 0 Connection] Does connect(0) properly return AddrNotAvailable error via NonZeroU16::new(port).ok_or(), or can edge cases allow connection to invalid port 0? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: connect()] [TOCTOU Race] Between get_mut(&port) to retrieve the sender and unbounded_send(), can the listener be dropped by another thread, causing the send to fail with a disconnected error that's mishandled? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: connect()] [Unreachable Branch] The code has 'unreachable!()' after checking e.is_disconnected() in the error path - can any error variant besides Disconnected occur that would trigger this unreachable, causing a panic? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Function: connect()] [Resource Leak] If unbounded_send() succeeds but socket_b construction fails afterward (though unlikely), is socket_a permanently leaked in the listener's queue? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: Drop for MemoryListener] [Port Reuse Race] Can a port be re-bound immediately after MemoryListener::drop() removes it from port_to_sender_map but before the incoming channel is fully cleaned up, causing connection confusion? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: Drop for MemoryListener] [Panic in Drop] If SWITCHBOARD.lock() panics in the Drop implementation (due to poisoned lock), does the port remain permanently registered, preventing future use of that port? (High)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: Drop for MemoryListener] [Concurrent Drop] Can two threads simultaneously drop MemoryListeners bound to the same port (if somehow duplicated), causing double-removal attempts or inconsistent state? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: Drop for MemoryListener] [Channel Cleanup] When a listener is dropped, are all pending MemorySocket instances in the incoming UnboundedReceiver properly cleaned up, or can they leak if not consumed? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [EOF Handling] Can the seen_eof flag logic be exploited where poll_read() first returns Ok(0) for EOF, then returns UnexpectedEof on the next call, causing inconsistent behavior in protocol handlers? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [Buffer Overflow] In the loop that copies data with 'current_buffer.take(bytes_to_read).copy_to_slice(&mut buf[bytes_read..(bytes_read + bytes_to_read)])', can integer overflow in bytes_read + bytes_to_read cause out-of-bounds writes? (Critical)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [State Inconsistency] If incoming.is_terminated() returns true but current_buffer still has data, does the function correctly drain the buffer before returning EOF, or can data be lost? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [Partial Read] When Poll::Pending is returned after reading some bytes (bytes_read > 0), can the caller incorrectly assume no data was read, causing protocol desynchronization? (Medium)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [Race with Close] Can poll_read() race with poll_close() on the peer socket, causing is_terminated() to return inconsistent results across multiple poll_read() calls? (Low)",
  "[File: aptos-core/network/memsocket/src/lib.rs] [Impl: AsyncRead::poll_read()] [Zero-Length Buffer] What happens when poll_read() is called with buf.len() == 0? Does it immediately return Ok(0), potentially causing infinite loops in callers expecting progress? (Low)"
]