[
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Integer Overflow] Can an attacker trigger integer overflow when computing the capacity '(end - start) as usize' in get_pruning_candidate_transactions() if target_version wraps around, causing memory exhaustion or incorrect pruning bounds? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [State Inconsistency] If current_progress > target_version due to corrupted metadata, does the ensure! check in get_pruning_candidate_transactions() properly prevent backwards pruning that could resurrect already-pruned transactions? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Atomicity Violation] If prune_transaction_by_hash_indices() succeeds but prune_transactions() fails mid-batch, can this create inconsistent state where hash indices are deleted but transaction data remains, breaking transaction lookup invariants? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Progress Corruption] If write_schemas() fails after updating DbMetadataKey::TransactionPrunerProgress in the batch, can the pruner progress be permanently desynchronized from actual pruned data, causing re-pruning or skipped versions? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Indexer Desync] If internal_indexer_db.transaction_enabled() returns true but the indexer write fails after main DB write succeeds, can this cause permanent inconsistency between ledger_db and indexer_db transaction indices? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Partial Write] Are all batch.put/delete operations truly atomic? Can a crash during write_schemas() leave the database in a state where some transactions are pruned but progress metadata is not updated? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Transaction Hash Collision] If multiple transactions share the same hash (collision or bug), does prune_transaction_by_hash_indices() correctly handle this edge case, or could it prune hash indices for non-target transactions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Memory Exhaustion] Can an attacker force pruning of an extremely large version range, causing get_pruning_candidate_transactions() to allocate unbounded memory in the Vec::with_capacity() call, leading to OOM and node crash? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Error Propagation] If prune_transaction_summaries_by_account() fails partway through iterating candidate_transactions, is the batch correctly rolled back, or could partial deletions corrupt the TransactionSummariesByAccountSchema? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Race Condition] Can concurrent calls to prune() with overlapping version ranges cause double-deletion attempts or inconsistent progress updates in the database metadata? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Indexer Branch Logic] Does the conditional logic at line 58-71 properly handle the case where indexer_db is Some() but transaction_enabled() changes state mid-operation, potentially writing to wrong database? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Metadata Inconsistency] If IndexerMetadataKey::TransactionPrunerProgress and DbMetadataKey::TransactionPrunerProgress diverge due to partial failure, can this cause queries to return inconsistent results between ledger and indexer APIs? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Double Write] When transaction_enabled() is false, prune_transaction_by_account() is called with &mut batch (line 70), but this batch is then written to ledger_db - could this accidentally write indexer schema to wrong database? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Write Order] The indexer writes happen before ledger writes (line 67 vs 73) - if indexer succeeds but ledger fails, can this leave indexer ahead of ledger causing query failures? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: prune()] [Schema Validation] Does write_schemas() at line 73 validate that all schemas in the batch are compatible with ledger_db, or could indexer schemas accidentally written cause database corruption? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: new()] [Progress Initialization] Can get_or_initialize_subpruner_progress() be exploited to set arbitrary initial progress values if the metadata is corrupted or missing, causing mass transaction deletion on first prune? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: new()] [Catch-up Attack] If metadata_progress >> actual database content due to restoration from backup, does the catch-up prune() call at line 101 attempt to prune non-existent versions, potentially corrupting progress tracking? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: new()] [Initialization Race] Can concurrent new() calls during node startup cause multiple pruners to initialize with the same progress value, leading to redundant pruning operations or lock contention? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: new()] [Error Recovery] If the catch-up prune() at line 101 fails, does new() return an error or silently create a pruner with stale progress, causing future pruning to skip versions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: new()] [Arc Sharing] The Arc<TransactionStore> and Arc<LedgerDb> are cloned - can malicious code holding these Arcs interfere with pruning operations by directly modifying shared state? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: get_pruning_candidate_transactions()] [Boundary Validation] The ensure! at line 111 checks 'end >= start' but not if start/end are within valid ledger bounds - can this cause iterator to read non-existent or future transactions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: get_pruning_candidate_transactions()] [Iterator Corruption] If the TransactionSchema iterator encounters corrupted data mid-iteration, does the error propagate correctly or could partial transaction list be returned, causing incomplete pruning? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: get_pruning_candidate_transactions()] [Version Gap] If transactions are missing in the range [start, end) due to corruption, does the iterator skip them silently, or are gaps detected and reported to prevent incomplete pruning? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: get_pruning_candidate_transactions()] [Memory Allocation] The Vec::with_capacity() at line 121 trusts (end-start) calculation - can u64 to usize cast overflow on 32-bit systems or with extreme version ranges? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs] [Function: get_pruning_candidate_transactions()] [Off-by-One] The loop breaks when 'version >= end' (line 124) - does this correctly implement half-open range [start, end), or could it miss or double-count boundary transactions? (Low)"
]