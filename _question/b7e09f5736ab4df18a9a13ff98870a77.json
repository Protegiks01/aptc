[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Source map unwrap vulnerability] Can get_code_location().unwrap_or(loc) hide verification errors if the source map is malformed, causing security-critical verification failures to be attributed to wrong locations? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Non-deterministic bytecode generation] If serialize() produces different bytecode for the same input on different validator nodes (due to bytecode_version inconsistencies), can this cause state root divergence and consensus failures? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize_source_map()] [BCS non-determinism] Can bcs::to_bytes() produce non-deterministic serialization for SourceMaps containing BTreeMap or other ordered collections, causing source map hash mismatches across validators? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [BTreeMap ordering non-determinism] Can the used_lambda_funs BTreeMap have non-deterministic iteration order if Symbol comparison has edge cases, causing spec verification to behave differently across nodes? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [SpecId ordering dependency] Does spec_info BTreeMap iteration order affect verification results, and can attackers exploit this to cause consensus divergence by crafting SpecId values that order differently? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Non-deterministic error aggregation] Does verify_units() aggregate diagnostics in a deterministic order, or can error ordering differences cause validators to reject different subsets of modules? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Bytecode size explosion] Can an attacker craft a CompiledModule with exponentially expanding bytecode that causes serialize() to allocate unbounded memory, crashing validator nodes? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize_debug()] [Debug format memory exhaustion] Can format!(\\",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize_source_map()] [Source map size attack] Can an attacker create SourceMaps with millions of location mappings that cause bcs::to_bytes() to consume excessive memory during serialization? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Lambda function explosion] Can the used_lambda_funs BTreeMap be populated with an unbounded number of lambda remappings, causing memory exhaustion when processing specs? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Spec info accumulation] Can an attacker create functions with thousands of SpecInfo entries in spec_info BTreeMap, exhausting memory during compilation or verification? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Diagnostic accumulation DoS] Does verify_units() bound the number of diagnostics accumulated in diags.extend(), or can attackers submit batches with thousands of verification errors to exhaust memory? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Clone safety for sensitive data] Does the #[derive(Clone)] on SpecInfo properly handle sensitive lambda function remappings, or can cloning expose or duplicate security-critical mappings unsafely? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Clone-based spec duplication] Can cloning FunctionInfo cause spec_info entries to be shared across multiple functions, enabling cross-function spec pollution attacks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Clone of CompiledModule] Does cloning NamedCompiledModule create deep copies of the underlying CompiledModule, or can shared references cause modifications to affect multiple module instances? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledModule] [Clone with location metadata] Can cloning AnnotatedCompiledModule preserve malicious location metadata that should be reset, enabling location-based attacks after cloning? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Enum: CompiledUnitEnum] [Clone-based type confusion] Can cloning a CompiledUnitEnum and then modifying the variant create type confusion between Module and Script variants? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Unauthorized bytecode serialization] Can serialize() be called by untrusted code to generate bytecode for unverified modules, bypassing compilation and verification pipelines? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_id()] [System address bypass] Can module_id() be exploited to create ModuleId instances claiming system addresses (0x1, 0x2, 0x3) for untrusted modules, bypassing address-based privilege checks? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: into_compiled_unit()] [Security metadata stripping] Does into_compiled_unit() strip security-critical annotations when converting AnnotatedCompiledUnit to CompiledUnit, allowing attackers to remove security enforcement metadata? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify()] [Verification bypass via direct access] Can code skip calling verify() and directly access the CompiledModule/CompiledScript, deploying unverified bytecode? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Direct module field access] Can direct access to the module field in NamedCompiledModule bypass verification, allowing manipulation of CompiledModule contents after verification? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Code offset overflow] Can the F::CodeOffset type in SpecInfo overflow if spec blocks are placed at extremely large bytecode positions, causing incorrect offset calculations? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Offset array bounds] Does accessing e.offsets().first() properly handle empty offset arrays, or can this cause out-of-bounds access in edge cases? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Lambda function index overflow] Can the Vec<Var> in used_lambda_funs contain indices that overflow when used to access lambda parameters, causing incorrect variable captures? (Medium)"
]