[
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: ConfigV1::default()] [Integer precision loss] Can the fixed point division operations U64F64::from_num(1) / U64F64::from_num(2) and U64F64::from_num(2) / U64F64::from_num(3) introduce rounding errors that cause validators to compute different threshold values, leading to consensus failures during DKG secret sharing? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: ConfigV2::default()] [Precision inconsistency] Does the fast_path_secrecy_threshold calculation U64F64::from_num(2) / U64F64::from_num(3) produce identical binary representation across different CPU architectures, or can floating point inconsistencies cause validator disagreement on whether fast path randomness should be enabled? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v1()] [Division by zero] Can an attacker pass secrecy_threshold_in_percentage or reconstruct_threshold_in_percentage values that cause division by 100 to produce zero thresholds, bypassing DKG security requirements and allowing single validators to reconstruct secrets? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v1()] [Integer overflow] If secrecy_threshold_in_percentage is set to u64::MAX, does U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100) overflow or wrap, potentially creating invalid threshold values that break cryptographic security assumptions? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v2()] [Threshold boundary violation] Can an attacker set secrecy_threshold_in_percentage > 100 to create secrecy thresholds > 1.0, breaking the invariant that secrecy_threshold should be in [0, 1] and causing undefined behavior in DKG protocols? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v1()] [Threshold inversion attack] Can a malicious governance proposal set secrecy_threshold > reconstruction_threshold (e.g., 75% secrecy, 60% reconstruction), violating the cryptographic requirement that secrecy < reconstruction and causing DKG protocol failures or security breaches? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v1()] [Zero threshold attack] Is there validation preventing secrecy_threshold_in_percentage = 0, which would allow any single validator to learn the shared secret and predict future randomness, breaking Byzantine Fault Tolerance assumptions? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v1()] [Maximum threshold DoS] Can an attacker set reconstruct_threshold_in_percentage = 100, requiring all validators to participate in randomness reconstruction and causing total loss of liveness if even one validator goes offline? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v2()] [Fast path threshold inconsistency] Can fast_path_secrecy_threshold be set lower than secrecy_threshold, creating an insecure fast path that leaks secrets through the optimized randomness generation pathway while maintaining security in the slow path? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::new_v2()] [Fast path bypass] If fast_path_secrecy_threshold > reconstruction_threshold, can this create a situation where the fast path is cryptographically impossible to use but still marked as enabled, causing randomness generation failures and liveness issues? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::from_configs()] [Sequence number manipulation] Can a malicious validator manipulate their local_seqnum to be artificially high (e.g., local_seqnum = u64::MAX) to force all nodes to disable randomness via the condition local_seqnum > onchain_seqnum, causing permanent loss of randomness functionality? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::from_configs()] [Integer overflow in comparison] Does the comparison local_seqnum > onchain_seqnum handle the case where onchain_seqnum wraps around from u64::MAX to 0, potentially causing all validators to incorrectly disable randomness after 2^64 configuration updates? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::from_configs()] [Race condition on epoch boundary] During epoch transitions when both local_seqnum and onchain_seqnum are updated, can race conditions cause different validators to read inconsistent sequence numbers, leading to some validators enabling and others disabling randomness, causing consensus failures? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::from_configs()] [Sequence number desynchronization] If a validator crashes and restarts with stale local_seqnum while onchain_seqnum has advanced, will the condition local_seqnum > onchain_seqnum incorrectly fail, causing the restarted validator to use outdated randomness configuration and diverge from network consensus? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::from_configs()] [Default fallback vulnerability] When local_seqnum > onchain_seqnum triggers default_disabled(), does this create a permanent state where randomness cannot be re-enabled without a hardfork, causing irreversible loss of randomness functionality? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: TryFrom<RandomnessConfigMoveStruct>] [Type confusion attack] Can an attacker craft a RandomnessConfigMoveStruct with variant.type_name that partially matches ConfigV1::MOVE_TYPE_NAME (e.g., '0x1::randomness_config::ConfigV1<T>'), bypassing the exact string match in line 162 and causing the unpack operation to fail silently, defaulting to Off and disabling randomness? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: TryFrom<RandomnessConfigMoveStruct>] [Malformed variant handling] If MoveAny::unpack() fails with an error in lines 163-164 or 168-169, does the error message leak sensitive information about internal state that could help an attacker craft more sophisticated exploits? (Low)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: TryFrom<RandomnessConfigMoveStruct>] [Unknown variant exploitation] When variant_type_name doesn't match any known types (line 172), does returning Err(anyhow!('unknown variant type')) allow an attacker to inject malicious configuration data that gets silently ignored by unwrap_or_else(default_if_missing), potentially masking governance attacks? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: TryFrom<RandomnessConfigMoveStruct>] [Version downgrade attack] Can a malicious governance proposal submit a RandomnessConfigMoveStruct with ConfigV1 type after V2 has been activated, causing a downgrade that removes fast_path_secrecy_threshold checks and creates a security regression? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: From<OnChainRandomnessConfig>] [Encoding inconsistency] Does MoveAny::pack() guarantee deterministic serialization, or can different validators produce different byte representations of the same configuration, causing Merkle root mismatches and consensus failures? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: ConfigV1::default()] [Hardcoded threshold weakness] Are the default thresholds (1/2 for secrecy, 2/3 for reconstruction) cryptographically sound for all validator set sizes, or can small validator sets (<10 validators) with these thresholds become vulnerable to collusion attacks? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: ConfigV2::default()] [Fast path security assumption] Does setting fast_path_secrecy_threshold to 2/3 by default provide sufficient security, or can this threshold be too low for large validator sets where 1/3 Byzantine validators could more easily collude to break fast path randomness? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::default_if_missing()] [Silent failure mode] When on-chain configuration is missing and defaults to Off, does this create an attack vector where an attacker who can cause configuration reads to fail can permanently disable randomness without triggering alerts or governance votes? (High)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: OnChainRandomnessConfig::default_for_genesis()] [Genesis misconfiguration] Does hardcoding genesis to use ConfigV2::default() without validation create a risk that if V2 has security flaws discovered post-launch, the genesis configuration cannot be changed without a hardfork? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/randomness_config.rs] [Function: RandomnessConfigSeqNum::default_if_missing()] [Initial sequence number attack] Starting seq_num at 0 when configuration is missing - can this be exploited during network initialization to inject malicious configurations before legitimate governance activates? (Medium)"
]