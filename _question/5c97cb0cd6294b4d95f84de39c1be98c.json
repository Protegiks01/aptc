[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Trait: Unpin] [Pin safety] Does implementing Unpin for FuturesUnorderedX guarantee that the struct can be safely moved in memory, or could internal FuturesUnordered state rely on stable addresses? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Pin semantics] Does poll_next_unpin() correctly handle pinning semantics when polling in_progress, or could moving FuturesUnorderedX while futures are in_progress violate Pin contracts? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Self-referential data] Could VecDeque operations that reallocate memory invalidate internal references or pins, causing undefined behavior when futures reference their storage? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Trait: Unpin] [Memory safety] Is it safe to implement Unpin unconditionally, or could futures with !Unpin bounds (e.g., self-referential futures) cause undefined behavior when stored in queued? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Pin projection] Does Pin<&mut Self> properly project to Pin<&mut FuturesUnordered> when calling poll_next_unpin(), or could incorrect pin projection cause memory safety issues? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Generic constraint] Does requiring only T: Future provide sufficient bounds, or should Output: Send/Sync be required for safe concurrent backup operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Type safety] Can pushing futures with different Output types cause type confusion, or does Rust's type system prevent mixing incompatible future types in the same FuturesUnorderedX instance? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Lifetime bounds] Are there missing lifetime bounds on Fut that could allow dangling references if futures contain borrowed data outlived by the struct? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Generic bounds] Does extend() properly constrain I: IntoIterator<Item = Fut> to prevent iterator types that could cause infinite loops or memory exhaustion? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Trait: Stream] [Output type] Could Fut::Output being a complex type (e.g., large structs) cause excessive memory usage in queued_outputs buffer, leading to backup node OOM? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: fmt()] [Information leak] Does the Debug implementation obscure internal state (\\",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: fmt()] [Incomplete debug] Could the minimal Debug implementation make it difficult to diagnose backup hangs or deadlocks by not exposing queue lengths and in_progress counts? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Observability] Are there metrics or logging for queue saturation, allowing operators to detect when max_in_progress is too low and backups are bottlenecked? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Monitoring] Could relying on len() for backup progress monitoring give incorrect progress due to the function not distinguishing between queued, in_progress, and completed-but-unbuffered futures? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Deadlock detection] If poll_next() hangs due to a logic bug, are there timeout mechanisms or watchdogs to detect and recover from backup process deadlocks? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Concurrency testing] Does the proptest adequately cover edge cases like max_in_progress = 1, num_tasks = usize::MAX, or zero tasks to ensure correctness under extreme conditions? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Race condition detection] Does the test's use of AtomicUsize properly detect race conditions in concurrent future execution, or could subtle bugs slip through due to memory ordering issues? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Assertion coverage] Does the test assertion (r > 0 && r <= min(max_in_progress, num_tasks)) catch all possible concurrency limit violations, or could off-by-one errors evade detection? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Output validation] Does the test verify that all outputs are received exactly once (outputs.sort + equality check), or could duplicate or missing outputs indicate data loss bugs? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Timeout handling] Is the MAX_WAIT_MS timeout sufficient to detect hangs in poll_next(), or could slow CI environments cause false failures masking real deadlock bugs? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Await point safety] If futures in in_progress await on I/O operations that never complete (e.g., network timeout), could this cause poll_next() to return Pending forever, hanging backups? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Future cancellation] If FuturesUnorderedX is dropped while futures are in queued or in_progress, are futures properly cancelled, or could they continue executing and cause use-after-free? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Async drop] Does dropping FuturesUnorderedX with queued_outputs containing undelivered results cause those outputs to be silently lost, potentially losing backup chunks? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Future abortion] If a future in in_progress panics, does FuturesUnordered properly handle the panic and allow poll_next() to continue, or does it propagate causing backup process crash? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Async recursion] Could adding futures that recursively call push() on the same FuturesUnorderedX cause stack overflow or reentrancy issues during backup operations? (Medium)"
]