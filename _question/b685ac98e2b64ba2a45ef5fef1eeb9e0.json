[
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Address collision] Can an attacker craft an input address that, when combined with AccountAddress::TEN via create_derived_object_address(), produces a collision with an existing primary APT store, allowing theft of funds from the victim's account? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Determinism violation] Does primary_apt_store() guarantee deterministic address generation across all validators, or can differences in AccountAddress::TEN interpretation lead to state divergence where validators compute different primary store addresses for the same account? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Seed manipulation] Can a malicious validator manipulate the AccountAddress::TEN seed value during address derivation to redirect a user's primary APT store to an attacker-controlled address, enabling fund theft? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Hash collision] Given that create_derived_object_address uses SHA3-256, what is the practical collision resistance? Can an attacker precompute input addresses that hash to the same derived store address, allowing double-spending across multiple accounts? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Address predictability] Can an attacker predict future primary_apt_store addresses before accounts are created, pre-occupying those addresses with malicious stores that intercept funds intended for legitimate users? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Race condition] In concurrent transaction execution via Block-STM, can two transactions simultaneously derive the same primary_apt_store address for different user accounts due to race conditions in address generation? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [BCS serialization] Does the BCS serialization within create_derived_object_address handle AccountAddress encoding consistently? Can serialization discrepancies cause the same logical address to produce different derived stores across validator nodes? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: primary_apt_store()] [Scheme byte manipulation] Can an attacker exploit the Scheme::DeriveObjectAddressFromObject byte appended in create_derived_object_address to forge store addresses that bypass access controls? (Medium)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: FungibleStoreResource] [Integer overflow] Can the u64 balance field overflow during deposit operations, wrapping from u64::MAX to 0 and causing massive loss of funds for users holding maximum balance? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: FungibleStoreResource] [Integer underflow] Can withdrawal operations cause the u64 balance to underflow from 0 to u64::MAX, creating unlimited funds out of thin air for the attacker? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: new()] [Validation bypass] Does FungibleStoreResource::new() validate that the initial balance doesn't exceed reasonable bounds? Can an attacker create a store with balance=u64::MAX to mint unlimited tokens? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: new()] [Frozen state bypass] Can an attacker create a FungibleStoreResource with frozen=false while simultaneously freezing the associated metadata, creating an inconsistent state that allows withdrawals from frozen accounts? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: balance()] [Race condition] In parallel execution, can concurrent reads via balance() and writes to self.balance create TOCTOU (Time-of-Check-Time-of-Use) vulnerabilities where balance checks pass but are invalidated before withdrawal? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: balance()] [Stale read] Does balance() guarantee linearizable reads in concurrent environments, or can it return stale balance values that have already been spent, causing double-spending? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: frozen()] [State inconsistency] Can the frozen flag be modified directly without proper authorization checks, allowing an attacker to unfreeze their own store after regulatory freeze or exploit frozen accounts by toggling the flag? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: metadata()] [Metadata swap] Can an attacker modify the metadata AccountAddress after store creation to point to a different fungible asset, effectively converting APT tokens to attacker-controlled tokens? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: metadata()] [Dangling reference] If the metadata address points to a destroyed or non-existent fungible asset resource, can this cause undefined behavior or allow manipulation of store balance without corresponding asset backing? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: FungibleStoreResource] [Serialization] Does Serde serialization/deserialization of FungibleStoreResource handle malformed data correctly? Can an attacker craft serialized bytes that bypass balance/frozen checks when deserialized? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: FungibleStoreResource] [Clone semantics] The struct derives Clone - can cloning a FungibleStoreResource in memory lead to double-spending if both the original and clone are used in separate transactions? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: ConcurrentFungibleBalanceResource] [Aggregator overflow] The AggregatorResource is initialized with max_value=u64::MAX - can this lead to unchecked overflow when balance increments reach maximum value, causing balance wrapping? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: new()] [Initial value validation] Does ConcurrentFungibleBalanceResource::new() validate that initial balance doesn't exceed u64::MAX? Can passing balance=u64::MAX+1 (through type confusion) cause overflow during initialization? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: balance()] [Dereference safety] The balance() method dereferences self.balance.get() - can this panic if the aggregator is in an invalid state, causing transaction failures that halt consensus? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Function: balance()] [Concurrent modification] Can concurrent modifications to the underlying AggregatorResource cause balance() to return inconsistent values between two sequential reads within the same transaction? (High)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: ConcurrentFungibleBalanceResource] [Aggregator bypass] Can an attacker directly manipulate the AggregatorResource<u64> inner value field, bypassing the max_value limit and creating unlimited funds? (Critical)",
  "[File: aptos-core/types/src/account_config/resources/fungible_store.rs] [Struct: ConcurrentFungibleBalanceResource] [Max value enforcement] Does the AggregatorResource enforce max_value=u64::MAX during additions/subtractions, or is this limit purely advisory? Can operations exceed the maximum without checks? (Critical)"
]