[
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_AUD_VAL_BYTES] [Integer overflow] Can the MAX_AUD_VAL_BYTES constant (120 bytes) be exploited if an attacker provides a JWT with an 'aud' field larger than this limit, causing truncation that results in address collision where different aud values hash to the same identity commitment? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_AUD_VAL_BYTES] [Circuit mismatch] If the hardcoded MAX_AUD_VAL_BYTES value (120) doesn't match the actual circuit constraint from commit 125522b4b226f8ece3e3162cecfefe915d13bc30, can an attacker craft proofs that verify on-chain but represent invalid JWT claims, enabling unauthorized account access? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_UID_KEY_BYTES] [Address derivation attack] Since MAX_UID_KEY_BYTES is set to 30 and used for keyless address derivation, can an attacker find two different uid_key values (e.g., 'sub' vs 'email') that when padded/hashed produce identical results, allowing them to claim the same address through different identity providers? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_UID_VAL_BYTES] [Collision attack] With MAX_UID_VAL_BYTES set to 330 bytes, can an attacker exploit the Poseidon hash padding scheme to find uid_val collisions, where two different user identifiers produce the same identity commitment and steal another user's account? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_ISS_VAL_BYTES] [Type confusion] The MAX_ISS_VAL_BYTES is defined as u16 (120) while other constants use usize - can this type inconsistency cause integer conversion vulnerabilities when comparing or validating issuer field sizes across different architectures? (Medium)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_EXTRA_FIELD_BYTES] [Type confusion] The MAX_EXTRA_FIELD_BYTES is u16 (350) instead of usize - can this cause truncation on 64-bit systems when extra_field data exceeds u16::MAX, allowing attackers to bypass validation and inject malicious extra fields? (High)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_JWT_HEADER_B64_BYTES] [Type confusion] MAX_JWT_HEADER_B64_BYTES is u32 (300) - can the mixed type usage (u16/u32/usize) across constants cause arithmetic overflow when summing field sizes during JWT parsing, leading to buffer overflows? (High)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_COMMITED_EPK_BYTES] [Arithmetic overflow] The calculation '3 * poseidon_bn254::keyless::BYTES_PACKED_PER_SCALAR as u16' could overflow if BYTES_PACKED_PER_SCALAR is modified - can this cause EPK commitment truncation allowing attackers to submit proofs with malformed ephemeral public keys? (High)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_COMMITED_EPK_BYTES] [Circuit consistency] If the implicit EPK commitment size in the circom circuit doesn't match the calculated MAX_COMMITED_EPK_BYTES value, can an attacker craft proofs that verify with incorrectly sized EPK data, enabling signature forgery? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_AUD_VAL_BYTES] [Immutability violation] The comment states MAX_AUD_VAL_BYTES 'should not be changed' as address derivation depends on it - is there any runtime check preventing accidental changes that would cause all existing keyless addresses to become inaccessible? (High)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_UID_KEY_BYTES] [Backward compatibility] If MAX_UID_KEY_BYTES is ever increased in a future version, will existing keyless accounts with uid_key values hashed under the old limit become permanently locked, causing fund loss? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_UID_VAL_BYTES] [Padding attack] Can an attacker exploit differences between the constant MAX_UID_VAL_BYTES (330) and actual JWT uid_val lengths to manipulate Poseidon hash padding, creating uid_val preimages that collide after padding? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constants: All size limits] [Circuit version mismatch] If these constants are updated but the circuit from commit 125522b4b226f8ece3e3162cecfefe915d13bc30 is not redeployed, can an attacker exploit the mismatch to create proofs that validate with incorrect field size assumptions? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_ISS_VAL_BYTES] [Issuer impersonation] With MAX_ISS_VAL_BYTES at 120, can an attacker craft two different issuer URLs that hash to the same value after truncation/padding, allowing them to impersonate a trusted OIDC provider? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Constant: MAX_EXTRA_FIELD_BYTES] [Extra field injection] Can the 350-byte MAX_EXTRA_FIELD_BYTES limit be exploited to inject malicious data in the extra_field that gets included in the circuit proof but bypasses on-chain validation? (Medium)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Malicious VK] The hardcoded verification key points could be maliciously crafted - can an attacker who compromises the circuit repository replace these points with a VK where they know the trapdoor, allowing them to forge proofs for arbitrary JWTs? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Testing in production] The function name suggests testing usage - if this verification key is accidentally used in production instead of the on-chain VK, can an attacker exploit the known test parameters to forge keyless signatures? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Point of infinity] Can an attacker modify the alpha_g1 point coordinates to represent the point at infinity (0,0), causing all Groth16 proof verifications to incorrectly pass and enabling universal signature forgery? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Subgroup attack] If the g1_projective_str_to_affine() conversion for alpha_g1 doesn't properly validate subgroup membership, can an attacker provide points in a larger group to break the discrete log assumption and forge proofs? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Beta_g2 malleability] The beta_g2 point uses two coordinate arrays - can an attacker exploit coordinate encoding ambiguities (e.g., using -y instead of y) to create equivalent but distinct verification keys that validate different proof sets? (High)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Gamma_g2 invalid] If the gamma_g2 point coordinates don't satisfy the BN254 curve equation, can this cause undefined behavior during pairing operations that an attacker exploits to bypass proof verification? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Delta_g2 twist attack] Can an attacker exploit the quadratic twist structure of G2 in the delta_g2 point to submit proofs that verify under weak pairing checks but don't represent valid circuit satisfactions? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Gamma_abc_g1 length] The gamma_abc_g1 vector has exactly 2 elements hardcoded - if the actual circuit has a different number of public inputs, can this cause proof verification to fail for all legitimate users or succeed for invalid proofs? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Gamma_abc_g1 ordering] Can an attacker exploit incorrect ordering of the two gamma_abc_g1 points to create proofs where public inputs are interpreted in the wrong order, allowing authentication with swapped aud/uid values? (Critical)",
  "[File: aptos-core/types/src/keyless/circuit_constants.rs] [Function: prepared_vk_for_testing()] [Coordinate parsing] The g1/g2_projective_str_to_affine() functions parse decimal string coordinates - can an attacker inject specially crafted strings (e.g., with scientific notation, leading zeros, or Unicode digits) to bypass validation? (High)"
]