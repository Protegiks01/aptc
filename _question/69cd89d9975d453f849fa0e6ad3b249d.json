[
  "[File: aptos-core/storage/aptosdb/src/pruner/mod.rs] [Module Exports] [Access Control] Are the pub(crate) visibility modifiers on LedgerPrunerManager, PrunerManager, StateKvPrunerManager, and StateMerklePrunerManager sufficient to prevent external modules from bypassing pruning invariants or manipulating pruner state directly? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/mod.rs] [Module Structure] [State Corruption] Can an attacker exploit the module boundary between mod.rs exports and internal implementations to access pruner internals and corrupt the min_readable_version counters, causing historical data to become accessible that should have been pruned? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/db_pruner.rs] [Function: prune()] [Integer Overflow] In the prune() method that takes batch_size as usize, can an attacker provide a maliciously large batch_size that causes integer overflow when calculating version ranges, potentially skipping critical data deletion and violating pruning guarantees? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/db_pruner.rs] [Function: get_current_batch_target()] [Math Logic] In calculating min(self.progress() + max_versions, self.target_version()), can overflow occur when progress is near u64::MAX, causing the pruner to wrap around and delete data from the beginning of the chain instead of old data? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/db_pruner.rs] [Function: set_target_version()] [Race Condition] Is set_target_version() atomic with respect to concurrent prune() operations? Can a race condition allow target_version to be updated mid-pruning, causing the pruner to delete more data than intended and break state availability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/db_pruner.rs] [Function: record_progress()] [Progress Tracking] If record_progress() is called with a version less than current progress due to concurrent operations, can this cause the pruner to think it needs to re-prune already pruned data, leading to database corruption or panic? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/db_pruner.rs] [Function: is_pruning_pending()] [Logic Error] Can the boolean logic in is_pruning_pending() (target_version > progress) be exploited when versions wrap around or when target_version is reset to a lower value, causing the pruner to incorrectly report no pending work while data accumulates? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_worker.rs] [Struct: PrunerWorkerInner] [Thread Safety] The quit_worker AtomicBool uses Ordering::SeqCst - can a malicious thread exploit weaker memory orderings in the work() loop to cause the worker to continue pruning after it should have stopped, potentially deleting critical recent data? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_worker.rs] [Function: work()] [Error Handling] When pruner.prune() returns an error, the worker logs it and sleeps, but continues - can an attacker trigger persistent pruning errors (e.g., through database corruption) that cause the pruner to fall behind indefinitely while still reporting it's running, violating storage SLAs? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_worker.rs] [Function: work()] [Timing Attack] The sleep duration is 100ms in test mode vs 1ms in production - can this timing difference be exploited in tests to pass tests that would fail in production due to race conditions between pruning and state queries? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_worker.rs] [Function: set_target_db_version()] [Monotonicity Violation] The function only updates target if target_db_version > current target - but what if the blockchain reorganizes and needs to prune to an earlier version? Can this prevent proper cleanup during chain reorgs? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_worker.rs] [Function: Drop::drop()] [Resource Leak] During drop(), the worker joins the thread - but if the thread panics or is in an infinite loop due to database errors, can this cause the entire node to hang during shutdown, preventing graceful restarts? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Version Calculation] When calculating when to wake the pruner (latest_version >= min_readable_version + batch_size + prune_window), can integer overflow in this addition cause the pruner to never wake up, leading to unbounded storage growth? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_manager.rs] [Function: get_min_viable_version()] [Unimplemented] The default implementation has unimplemented!() - can this cause runtime panics if called on a pruner that doesn't override it, crashing validator nodes during sync operations? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_manager.rs] [Function: wait_for_pruner()] [Timeout Logic] The test-only wait_for_pruner() uses a 60-second timeout - can this cause flaky tests that sometimes pass when the system is slow, hiding real race conditions that would manifest in production? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/pruner_manager.rs] [Function: save_min_readable_version()] [Atomicity] Is saving min_readable_version to both memory (AtomicVersion) and disk (database) atomic? Can a crash between these operations cause the in-memory and on-disk values to diverge, leading to incorrect pruning on restart? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Function: prune()] [Race Condition] The sub_pruners are executed in parallel using rayon's par_iter() - can concurrent sub-pruners interfere with each other's database writes, causing partial prunes where some data types are deleted but others aren't for the same version range? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Function: prune()] [Error Propagation] If one sub_pruner fails during parallel execution, the function returns an error - but have the other sub_pruners already partially committed their changes? Can this cause inconsistent pruning state where some ledger components are pruned further than others? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Function: prune()] [Progress Update] The progress is updated after all sub_pruners complete - if the node crashes mid-pruning, will it re-prune the same range on restart? Can repeated partial prunes corrupt the database through duplicate deletions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Function: new()] [Initialization Race] During initialization, metadata_progress is read and used to initialize all sub_pruners - but what if new data is written between reading metadata_progress and initializing the sub_pruners? Can this cause sub_pruners to miss data that should be pruned? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Struct: LedgerPruner] [AtomicVersion Usage] target_version and progress use AtomicVersion with SeqCst ordering - but can the gap between loading these two values in different operations cause inconsistent views where progress appears to exceed target? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/mod.rs] [Function: prune()] [Batch Boundary] The pruning uses min(progress + max_versions, target_version) for batching - can this create alignment issues with transaction boundaries, potentially deleting partial transactions and breaking transaction integrity? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Window Offset] The function subtracts user_pruning_window_offset from prune_window using saturating_sub - can an attacker with config control set an offset larger than the window to make min_viable_version equal to latest_version, effectively disabling pruning? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Lock Contention] The function locks latest_version mutex - if this is called frequently from the commit path, can lock contention cause the main thread to stall, degrading consensus performance and potentially causing validator timeouts? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Calculation Order] min_readable_version is calculated as latest_version.saturating_sub(prune_window) and stored in memory before being sent to the worker - can a crash here cause the worker to prune to a version that hasn't been recorded as min_readable in persistent storage? (Critical)"
]