[
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_script_ret] [Panic/DoS] The test uses compile_script_string which calls unwrap() on parse_script - can an attacker craft malformed Move IR that causes panic during parsing, potentially DoSing the compiler or causing undefined behavior? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_script_let] [Serialization bypass] The compilation pipeline serializes then deserializes the script - can an attacker exploit inconsistencies between serialization formats to create bytecode that has different CFG structure after deserialization, bypassing verification? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if] [Verification bypass] The tests assert CFG properties but don't verify that malicious code in unreachable blocks gets caught - can an attacker hide exploit code in blocks that CFG marks as unreachable but are actually executable? (Critical)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else] [CFG construction error] Tests assume VMControlFlowGraph::new() correctly identifies all blocks - can specially crafted jump patterns cause VMControlFlowGraph to merge distinct blocks, allowing control flow to bypass security checks? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_else_return] [Block boundary bug] The test verifies 4 blocks are created but doesn't validate block boundaries - can an attacker craft bytecode where block_start/block_end are incorrectly calculated, causing instructions to be analyzed in wrong context? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_nested_if] [Reachability analysis bypass] Test calls reachable_from(8) expecting 3 blocks - can an attacker exploit incorrect reachability calculation to hide malicious code in blocks CFG thinks are unreachable but are actually reachable via indirect jumps? (Critical)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_if_return] [Successor calculation error] Test validates reachable_from() for different starting blocks - can an attacker craft jump_if patterns where successors() returns incomplete or wrong successor list, causing verification to miss dangerous control flow paths? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_two_returns] [Multiple exit points] Test has 3 return statements but doesn't verify all are detected as proper exits - can an attacker add hidden return paths that CFG doesn't recognize, allowing early exit from code that should complete security checks? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_else_abort] [Abort handling bypass] Tests abort statements but doesn't verify abort is properly terminal - can an attacker craft bytecode where abort doesn't terminate control flow, allowing execution to continue and bypass invariant checks? (Critical)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_if_abort] [Mixed termination] Test mixes abort and jump but doesn't verify mutually exclusive paths - can an attacker create control flow where both abort and continued execution are possible, causing inconsistent state? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if_else_with_two_aborts] [Dead code detection] Test has unreachable b3 label with abort - does CFG properly mark unreachable code, or can attacker hide malicious operations in dead code that later becomes reachable through bytecode manipulation? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Integer overflow] CFG uses CodeOffset (u16) for block IDs - can an attacker create Move code with >65535 instructions causing block_id overflow, leading to incorrect CFG structure and verification bypass? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Jump target validation] Tests use jump and jump_if but don't verify target validation - can an attacker specify jump targets outside valid block boundaries, causing CFG to create edges to invalid code locations? (Critical)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_nested_if] [Loop detection bypass] Test has nested conditionals but no loops - can an attacker craft jump patterns that create hidden loops that CFG doesn't detect, causing infinite execution and gas exhaustion? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Block count mismatch] Tests assert blocks().len() == num_blocks() - can an attacker exploit inconsistency between these methods to cause verification to use wrong block count, missing security-critical blocks? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_script_let] [Variable assignment ordering] Test uses move(x), copy(y) in expression - does CFG properly model data flow, or can attacker reorder operations to use uninitialized/moved values bypassing type safety? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Display method side effects] Tests call cfg.display() which prints CFG - can this leak sensitive bytecode structure information that helps attacker craft CFG-confusing exploits? (Low)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Verification error suppression] compile_script_string asserts no verification errors but tests don't check what verification does - can attacker craft code that passes CFG tests but fails verification in unexpected ways? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_if] [Conditional expression bypass] Test uses (42 > 0) as constant condition - does CFG properly handle constant folding, or can attacker use constant conditions to create unreachable-seeming code that's actually reachable? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Label ordering dependency] Tests define labels in specific order (b0, b1, b2, b3) - does CFG depend on label ordering, or can attacker reorder labels to confuse block identification? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_nested_if] [Entry block assumptions] Test assumes entry block is deterministic - can attacker manipulate entry point to start execution at arbitrary block, bypassing initialization code? (Critical)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Missing loop tests] No tests cover while/loop constructs - can attacker craft loop bytecode that CFG misanalyzes, creating back-edges that verification doesn't detect allowing infinite loops? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Missing function call tests] No tests cover call/return across functions - can attacker exploit interprocedural control flow that CFG doesn't model, bypassing single-function verification? (High)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [All tests] [Exception handling gaps] Tests only cover abort, not other error paths - can attacker trigger runtime errors (div by zero, overflow) that create control flow paths CFG doesn't model? (Medium)",
  "[File: third_party/move/move-ir-compiler/src/unit_tests/cfg_tests.rs] [Function: cfg_compile_script_ret] [Single block assumptions] Test expects single block for simple return - can attacker add nop instructions that cause CFG to split into multiple blocks, confusing optimization passes? (Low)"
]