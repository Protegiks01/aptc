[
  "[File: consensus/safety-rules/src/local_client.rs] [All Functions] [State Reset Attack] Can a Byzantine validator call initialize() with a manipulated EpochChangeProof while other methods are executing, causing safety_data to be reset to epoch 0 values mid-operation and enabling double-signing across the reset boundary? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: consensus_state()] [State Observation] Can a Byzantine validator repeatedly call consensus_state() to observe transient intermediate states during concurrent operations, gaining timing information to precisely schedule malicious sign_proposal() calls that exploit safety_data update windows? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_proposal()] [Panic Propagation] If sign_proposal() panics after acquiring the write lock but before releasing it, does the RwLock poison permanently, preventing all future SafetyRules operations and causing validator liveness failure? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: initialize()] [Partial Initialization] If initialize() fails after updating waypoint but before setting validator_signer, can subsequent operations proceed with mismatched epoch state, allowing signing operations with incorrect keys? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_vote_two_chain()] [Vote Caching Error] If the cached last_vote check returns a vote but safety_data is subsequently corrupted, can this bypass the verify_and_update_last_vote_round() safety check on retry, enabling equivocation? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [All Functions] [Lock Poisoning Recovery] Is there any recovery mechanism if the RwLock becomes poisoned due to a panic, or does this permanently disable the validator requiring manual restart? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_commit_vote()] [Verification Failure] If ledger_info.verify_signatures() fails but new_ledger_info is already signed, can this create a partially-committed state where some validators have commit signatures and others don't, causing commit certificate formation failures? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_timeout_with_qc()] [TC Verification Panic] If verify_tc() panics while processing a malformed TwoChainTimeoutCertificate, does this poison the write lock and halt all timeout operations across the network, potentially preventing timeout certificate formation needed for liveness? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_proposal()] [Signature Timing] Does the write lock remain held during BLS signature generation in the underlying SafetyRules, creating timing side-channels where an attacker can measure lock acquisition delays to infer private key operations? (Low)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_vote_two_chain()] [Vote Signature Race] Can concurrent vote signing operations interleave in a way that causes nonce reuse or signature malleability in the BLS signing process, potentially exposing validator private keys? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_commit_vote()] [Commit Signature] Does sign_commit_vote() verify that the BLS signature is generated for the correct new_ledger_info and not accidentally reused from a cached signature, preventing signature replay attacks? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [All Functions] [Key Material Exposure] While holding the write lock, are validator private keys ever exposed through the internal SafetyRules reference in a way that concurrent operations could access or leak them through side-channels? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_vote_two_chain()] [Storage Lag] If set_safety_data() persists asynchronously, can releasing the write lock before persistence completes allow concurrent operations to observe stale safety_data, bypassing last_voted_round constraints? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_proposal()] [Persistence Failure] If sign_proposal() returns a signature but the underlying preferred_round update fails to persist, can a subsequent crash and restart allow re-signing proposals that violate the 2-chain rule? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: initialize()] [Storage Race] Can concurrent initialize() calls race in accessing PersistentSafetyStorage, causing epoch_state and safety_data to be written non-atomically and enabling cross-epoch equivocation? (Critical)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_timeout_with_qc()] [Timeout Persistence] Does sign_timeout_with_qc() ensure highest_timeout_round is durably persisted before returning the signature, or can power loss cause timeout state to be lost while signatures are distributed, violating timeout consistency? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_order_vote()] [Order Vote Storage] If construct_and_sign_order_vote() updates one_chain_round but crashes before persisting, can restart allow re-voting with inconsistent QC tracking state? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_timeout_with_qc()] [Round Arithmetic] Does the underlying next_round() check in timeout validation properly handle u64::MAX round numbers, or can integer overflow allow signing timeouts that wrap around to round 0, bypassing epoch boundaries? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_vote_two_chain()] [Round Overflow] If proposed_block.round() is u64::MAX, can the 2-chain voting rule's round+1 check overflow, allowing votes that violate the consecutive round requirement? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: sign_proposal()] [Round Comparison] Are round comparisons in verify_and_update_last_vote_round() vulnerable to integer overflow, allowing a Byzantine validator to propose blocks with wrapped-around round numbers that bypass last_voted_round checks? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Struct: LocalClient] [Arc Reference Count] Can excessive Arc::clone() operations on the internal SafetyRules reference cause reference count overflow, potentially leading to use-after-free if the count wraps? (Low)",
  "[File: consensus/safety-rules/src/local_client.rs] [All Functions] [Unwinding Safety] If any underlying SafetyRules method panics during unwinding after a previous panic, can this cause double-panic abort that crashes the validator process? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: construct_and_sign_vote_two_chain()] [Borrow Checker Bypass] Does the write lock guarantee exclusive access to SafetyRules internal state, or can unsafe code in the underlying implementation create mutable aliasing that violates Rust's safety guarantees? (Medium)",
  "[File: consensus/safety-rules/src/local_client.rs] [All Functions] [Call Ordering] Is there an enforced calling sequence for TSafetyRules methods (e.g., initialize() before sign_proposal()), or can out-of-order calls bypass initialization checks and operate with uninitialized validator_signer or epoch_state? (High)",
  "[File: consensus/safety-rules/src/local_client.rs] [Function: initialize()] [Re-initialization] Can initialize() be called multiple times with different EpochChangeProof values, and if so, does this properly handle resetting all safety_data or can stale state from previous epochs persist? (High)"
]