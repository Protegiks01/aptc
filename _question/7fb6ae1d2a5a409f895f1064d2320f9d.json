[
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Lines 100-101] [Graceful Shutdown] Does the axum server configured at lines 100-101 implement graceful shutdown signals (SIGTERM/SIGINT), or can abrupt termination cause in-flight requests to fail, database transactions to remain uncommitted, or connection pool resources to leak? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Line 88] [Information Disclosure] The config is logged at line 88 with debug formatting - does this leak sensitive configuration like database credentials, API keys embedded in ServerConfig variants, or internal network topology information to log files accessible by attackers? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Lines 87-104] [Retry Loop DoS] If run() returns an error, does the calling code implement exponential backoff for retries, or can an attacker trigger rapid restart loops by causing persistent errors (e.g., invalid database credentials) that consume CPU and prevent service recovery? (Low)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Trait: Server, Lines 24-28] [Trait Implementation Gap] The Server trait is implemented via enum_dispatch on ServerContext - can an attacker exploit cases where a context variant doesn't properly implement build_router(), causing the enum_dispatch macro to generate unsafe code paths that lead to undefined behavior? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Enum: ServerContext, Lines 48-55] [Type Safety Violation] The enum_dispatch attribute generates trait implementations automatically - are there type safety guarantees that prevent mixing incompatible ServerConfig and ServerContext variants (e.g., Parser config with AssetUploaderApi context) during the build_context() call? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Enum: ServerContext, Line 48] [Clone Safety] ServerContext derives Clone but contains contexts that may hold database connections or other non-cloneable resources - can cloning a context create shared mutable state that violates Rust's ownership rules or causes use-after-free when one clone is dropped? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Trait: Server, Line 27] [Router Immutability] The build_router() trait method returns a Router by value - can an attacker exploit timing between router creation and server binding to modify the router's routes, middleware, or state, potentially injecting malicious handlers into the API surface? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 63-65] [Parser Context DoS] The ParserContext::new() is async and may perform expensive initialization - can an attacker trigger repeated Parser context creation by sending crafted configuration updates, causing CPU exhaustion and preventing legitimate parser operations? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 66-70] [AssetUploader Worker Isolation] AssetUploaderWorkerContext doesn't use the provided connection pool unlike other variants - does this create inconsistent database access patterns that could allow the worker to bypass connection limits or transaction isolation guarantees? (Low)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 71-73] [AssetUploader API Vulnerability] AssetUploaderApiContext receives the connection pool directly - can API endpoints exposed through this context perform unrestricted database queries, allowing attackers to craft SQL queries that cause table scans, lock contention, or information disclosure? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 74-79] [Throttler Config Manipulation] The AssetUploaderThrottlerContext receives both config and pool - can an attacker manipulate the throttler_config to bypass rate limiting (e.g., setting limits to u64::MAX), enabling resource exhaustion attacks on downstream services? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 58-82] [Context Clone Attack] Each context variant calls .clone() on its config before passing to the constructor - are these clones deep copies, or do they share mutable state that could allow one context to modify another context's configuration through shared references? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Struct: NFTMetadataCrawlerConfig, Lines 40-46] [Missing Validation] The struct fields lack validation constraints (e.g., database_url format, server_port range) - can an attacker provide invalid configurations (empty database_url, port 0, port > 65535) that cause runtime panics or undefined behavior when the service starts? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Struct: NFTMetadataCrawlerConfig, Field: database_url] [Protocol Restriction] Is the database_url restricted to PostgreSQL connections only, or can an attacker specify alternative database protocols (mysql://, sqlite://, file://) that the connection pool library accepts but the migrations don't support, causing schema corruption? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Struct: NFTMetadataCrawlerConfig, Field: server_port] [Port Zero] Can server_port be set to 0 to let the OS assign an ephemeral port, and if so, does the service properly communicate the assigned port to dependent services, or does this break service discovery and API accessibility? (Low)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Enum: ServerConfig, Lines 30-37] [Configuration Complexity] Each ServerConfig variant can contain nested configuration structs - can an attacker provide infinitely recursive or circular configuration structures that cause stack overflows during deserialization or context building? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Line 91] [Pool Initialization Race] The connection pool is created synchronously but used asynchronously - can concurrent access immediately after creation cause race conditions where contexts attempt to acquire connections before the pool is fully initialized with available connections? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Line 91] [Pool Configuration Override] Does establish_connection_pool() use hardcoded pool size limits, or can the database_url connection string override these limits (e.g., ?pool_size=1000000) to cause memory exhaustion by creating excessive connection objects? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Lines 91-99] [Pool Lifetime] The connection pool is created in run() and passed to contexts - does the pool outlive all contexts, or can contexts hold pool references that become dangling pointers if the pool is dropped early due to service shutdown? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 58-82] [Pool Exhaustion] All context variants share a single connection pool - can one resource-intensive context (e.g., Parser) exhaust all connections, starving other contexts (e.g., AssetUploaderApi) and causing API unavailability? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Line 58] [Async Context Safety] The build_context() function is async but doesn't specify thread safety constraints - can contexts be safely sent across thread boundaries when the tokio runtime schedules tasks, or do they contain non-Send types that could cause runtime panics? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Lines 87-104] [Tokio Runtime Dependency] The RunnableConfig::run() implementation is async and requires a tokio runtime - if called outside a tokio context or with an incompatible runtime, does it panic gracefully or cause undefined behavior in async operations? (Low)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Line 101] [Concurrent Request Handling] The axum server serves requests concurrently - does the build_router() implementation return a router with thread-safe handlers, or can concurrent requests cause data races in shared state within the ServerContext? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: build_context(), Lines 62-80] [Async Cancellation] If the build_context() async function is cancelled mid-execution (e.g., server shutdown), are partial initializations properly cleaned up, or do contexts leak database connections and other resources? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/config.rs] [Function: run(), Lines 87-104] [Error Recovery Path] The run() function returns anyhow::Result but doesn't implement retry logic - if transient errors occur (network issues, database connection failures), does the service immediately fail without recovery, or are there automatic retry mechanisms that could mask persistent attack-induced failures? (Low)"
]