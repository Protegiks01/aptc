[
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinDepositTranslator::translate_event_v2_to_v1()] [BCS Serialization DoS] Can an attacker provide a CoinDeposit with extreme amount values that cause bcs::to_bytes() to allocate excessive memory during DepositEvent serialization, triggering OOM? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinWithdrawTranslator::translate_event_v2_to_v1()] [Withdraw-Deposit Sequence Mismatch] Can an attacker exploit different sequence number logic between CoinWithdrawTranslator (creation 3) and CoinDepositTranslator (creation 2) to create withdraw events that appear to happen before their corresponding deposits? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinWithdrawTranslator::translate_event_v2_to_v1()] [Negative Amount Encoding] Can the amount field in WithdrawEvent wrap around or be negative if CoinWithdraw contains u64::MAX, creating fake withdraw events that appear to deposit funds? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinWithdrawTranslator::translate_event_v2_to_v1()] [CoinStore Deserialization Race] If the CoinStore resource is modified between bcs::from_bytes() and get_next_sequence_number(), can the sequence number be based on stale count values? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinRegisterTranslator::translate_event_v2_to_v1()] [Hardcoded Account StructTag] Is the hardcoded struct_tag_str '0x1::account::Account' vulnerable to protocol changes where Account resource moves to a different module, breaking all register event translation? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinRegisterTranslator::translate_event_v2_to_v1()] [TypeInfo Cloning Attack] Can an attacker manipulate the TypeInfo returned by coin_register.type_info() to reference system or privileged coin types, creating fake registration events for restricted assets? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CoinRegisterTranslator::translate_event_v2_to_v1()] [Creation Number 0 Conflict] Does using COIN_REGISTER_EVENT_CREATION_NUMBER = 0 create conflicts with other event streams that also use creation number 0 for the same account? (Low)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: KeyRotationTranslator::translate_event_v2_to_v1()] [Authentication Key Size] Can oversized authentication keys in KeyRotation events cause buffer overflows during clone() operations when creating KeyRotationEvent, corrupting memory? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: KeyRotationTranslator::translate_event_v2_to_v1()] [Key Rotation Replay] If the sequence number logic fails, can an attacker replay historical KeyRotation events to confuse indexers about which authentication key is currently active for an account? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: KeyRotationTranslator::translate_event_v2_to_v1()] [Same Key Rotation] Does the translator validate that old_authentication_key != new_authentication_key, or can attackers emit no-op rotation events that pollute event logs? (Low)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TransferTranslator::translate_event_v2_to_v1()] [Magic Creation Number] Can the hardcoded TRANSFER_EVENT_CREATION_NUMBER (0x4000000000000) collide with user-generated GUIDs if the INIT_GUID_CREATION_NUM in Move changes, causing transfer event key conflicts? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TransferTranslator::translate_event_v2_to_v1()] [ObjectCore Missing Fallback] When ObjectCore resource is not found, does the fallback logic correctly handle objects that haven't been transferred before vs. objects that were deleted, potentially creating events for non-existent objects? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TransferTranslator::translate_event_v2_to_v1()] [Circular Transfer Detection] Can an attacker create transfer events where from == to, and does this translator detect and reject such circular transfers that could be used for fake volume generation? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TransferTranslator::translate_event_v2_to_v1()] [Object Address Validation] Does the translator verify that transfer.object() is a valid object address and not a system or account address, preventing transfer events for invalid object types? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TokenMutationTranslator::translate_event_v2_to_v1()] [Burned Token Event Creation] The code explicitly returns an error if Token resource is not found (may be burned), but can this be exploited to suppress mutation events for tokens being burned in the same transaction, hiding malicious metadata changes? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TokenMutationTranslator::translate_event_v2_to_v1()] [Field Name Injection] Can an attacker provide a malicious mutated_field_name string that exploits parsers downstream when TokenMutationEvent is indexed, injecting commands or breaking indexer queries? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TokenMutationTranslator::translate_event_v2_to_v1()] [Value Size DoS] Can extremely large old_value or new_value strings in TokenMutation cause bcs::to_bytes() to allocate excessive memory, DoSing the indexer? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: TokenMutationTranslator::translate_event_v2_to_v1()] [ObjectGroup vs Direct Resource] Does using get_state_value_bytes_for_object_group_resource correctly handle all token types, or can tokens stored differently bypass this lookup and fail translation? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionMutationTranslator::translate_event_v2_to_v1()] [Collection Inner Address] Can an attacker manipulate collection_mutation.collection().inner() to point to an arbitrary address that doesn't contain a Collection resource, causing misleading mutation events? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionMutationTranslator::translate_event_v2_to_v1()] [Missing Collection Error Handling] When Collection resource is not found, does returning an error prevent the entire transaction's events from being indexed, or are other events processed normally? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionMutationTranslator::translate_event_v2_to_v1()] [Mutated Field Validation] Does the translator validate that mutated_field_name is a legitimate collection field, or can arbitrary field names be recorded as mutations? (Low)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: MintTranslator::translate_event_v2_to_v1()] [Supply Type Confusion] Can an attacker exploit the if-else chain checking FixedSupply then UnlimitedSupply by creating a collection with both supply types, causing the translator to use the wrong mint_events() key? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: MintTranslator::translate_event_v2_to_v1()] [ConcurrentSupply Bypass] The code explicitly mentions collections with ConcurrentSupply return an error, but can an attacker switch supply types mid-transaction to bypass mint event tracking entirely? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: MintTranslator::translate_event_v2_to_v1()] [Index Value Overflow] Can mint.index().value overflow when cast to the MintEvent index field, causing index wraparound and mint event collisions? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: MintTranslator::translate_event_v2_to_v1()] [Token Address Validation] Does the translator verify that mint.token() is a valid newly-created token address and not an existing token or system address? (Medium)"
]