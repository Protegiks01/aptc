[
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: get_random_player()] [Production Misuse] The comment at line 75 says 'For testing only' but the function is pub - could production code accidentally call this with weak RNG, introducing predictable player selection in live DKG? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: get_random_eligible_subset_of_players()] [Test/Production Boundary] Although marked for testing at line 85, could this function be used in benchmarking code that runs on production validators, potentially leaking information about validator selection strategies? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Module: test] [Test Coverage] The test at lines 144-153 only tests valid configurations (t <= n) - could missing tests for edge cases like t=usize::MAX, n=0, or t>n allow bugs to slip into production? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: new()] [Minimum Threshold] Does the code enforce a minimum threshold relative to n for security (e.g., t >= n/3 + 1 for Byzantine tolerance), or could very low thresholds like t=1 for n=100 be created, providing insufficient fault tolerance? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: new()] [Maximum Player Count] Is there an upper limit on n to prevent resource exhaustion? Could n=2^30 pass validation but cause domain initialization to allocate terabytes of memory for roots of unity? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Invariant Violation] After construction, could the t or n fields be modified through unsafe code or memory corruption, violating the invariant t <= n and causing undefined behavior in PVSS operations? (Critical)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: new()] [Domain Validation] Does the code validate that the constructed domains (dom and batch_dom) have consistent parameters, or could domain construction bugs cause mismatched omega values that break FFT correctness? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Equality Operator Weakness] The PartialEq at line 20 only compares t and n (since dom/batch_dom are skipped) - could two configs with same t,n but corrupted domains compare equal, causing validators to accept incompatible configurations? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Small Subgroup Attack] If the evaluation domain's roots of unity lie in a small subgroup of the scalar field, could this enable small-subgroup attacks on polynomial interpolation, allowing attackers to forge shares that pass verification? (Critical)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Root of Unity Collision] Could different values of n map to the same set of roots of unity (due to domain size rounding to powers of 2), allowing cross-instance attacks where shares from one DKG are replayed in another? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [FFT Length Extension] If the FFT domain size N (power of 2) is much larger than n (actual players), could attackers insert extra evaluations at unused roots of unity to manipulate the polynomial reconstruction? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Polynomial Degree Attack] Does the code verify that dealt polynomials have degree exactly t-1? Could an attacker provide higher-degree polynomials that pass verification but enable share forgery attacks? (Critical)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Lagrange Coefficient Overflow] During Lagrange interpolation with roots of unity, could coefficient calculations overflow the scalar field modulus, causing wraparound and incorrect secret reconstruction? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: new()] [Computational DoS] For large n requiring N=2^k evaluations, could FFT operations take excessive CPU time (O(N log N)), allowing attackers to DoS validators by requesting configs with huge n values? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: new()] [Memory DoS] Since BatchEvaluationDomain stores all N-th roots of unity in a Vec, could large N values (e.g., N=2^30) consume gigabytes of memory per config, enabling memory exhaustion attacks? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Struct: ThresholdConfigBlstrs] [Clone Amplification] If ThresholdConfigBlstrs is cloned repeatedly (e.g., for each PVSS transcript), could memory amplification from copying large domain Vecs cause validator OOM crashes during high DKG activity? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/threshold_config.rs] [Function: deserialize()] [Deserialization Bomb] Could an attacker craft serialized data with small t,n values that explode into massive domains during\n\n### Citations\n\n**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L1-154)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n//! Threshold secret sharing configuration for BLSTRS-based PVSS.\n\nuse crate::{\n    blstrs::evaluation_domain::{BatchEvaluationDomain, EvaluationDomain},\n    player::Player,\n    traits::{self, ThresholdConfig as _},\n};\nuse anyhow::anyhow;\nuse rand::{seq::IteratorRandom, Rng};\nuse rand_core::{CryptoRng, RngCore};\nuse serde::{Deserialize, Deserializer, Serialize};\nuse std::fmt::{Display, Formatter};\n\n/// Encodes the *threshold configuration* for a normal/unweighted PVSS: i.e., the threshold $t$ and\n/// the number of players $n$ such that any $t$ or more players can reconstruct a dealt secret given\n/// a PVSS transcript. Due to the last fields, this struct should only be used in the context of `blstrs`\n#[derive(Clone, PartialEq, Serialize, Debug, Eq)]\npub struct ThresholdConfigBlstrs {\n    /// The reconstruction threshold $t$ that must be exceeded in order to reconstruct the dealt\n    /// secret; i.e., $t$ or more shares are needed\n    pub t: usize,\n    /// The total number of players involved in the PVSS protocol\n    pub n: usize,\n    /// Evaluation domain consisting of the $N$th root of unity and other auxiliary information\n    /// needed to compute an FFT of size $N$.\n    #[serde(skip)]\n    dom: EvaluationDomain,\n    /// Batch evaluation domain, consisting of all the $N$th roots of unity (in the scalar field),\n    /// where N is the smallest power of two such that n <= N.\n    #[serde(skip)]\n    batch_dom: BatchEvaluationDomain,\n}\n\nimpl<'de> Deserialize<'de> for ThresholdConfigBlstrs {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Deserialize only the serializable fields (t, n)\n        #[derive(Deserialize)]\n        struct SerializedFields {\n            t: usize,\n            n: usize,\n        }\n\n        let serialized = SerializedFields::deserialize(deserializer)?;\n\n        // Rebuild the skipped fields using `new`\n        ThresholdConfigBlstrs::new(serialized.t, serialized.n).map_err(serde::de::Error::custom)\n    }\n}\n\nimpl ThresholdConfigBlstrs {\n    /// Returns a reference to the precomputed batch evaluation domain.\n    pub fn get_batch_evaluation_domain(&self) -> &BatchEvaluationDomain {\n        &self.batch_dom\n    }\n\n    /// Returns a reference to the primary evaluation domain.\n    pub fn get_evaluation_domain(&self) -> &EvaluationDomain {\n        &self.dom\n    }\n}\n\nimpl Display for ThresholdConfigBlstrs {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f,"
]