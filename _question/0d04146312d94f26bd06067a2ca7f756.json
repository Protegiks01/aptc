[
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: dequeue_rand_ready_prefix()] [Unwrap Safety] Line 122 uses unwrap() on pop_first() - while comment claims safety, can concurrent thread empty queue between check and pop causing panic and validator crash? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: dequeue_rand_ready_prefix()] [Debug Assert Bypass] Line 127-130 debug_assert! only runs in debug builds - can production build allow blocks without randomness to be dequeued, violating protocol invariant and causing execution failures? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: dequeue_rand_ready_prefix()] [Prefix Attack] Function assumes first items in BTreeMap form valid prefix - can attacker manipulate round numbers to place malicious blocks at front, getting them dequeued before legitimate blocks? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: dequeue_rand_ready_prefix()] [DropGuard Drop Timing] When QueueItem is dropped at line 126, broadcast_handle DropGuards abort tasks - can premature abort cause in-flight randomness broadcasts to fail, breaking consensus agreement? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: dequeue_rand_ready_prefix()] [Observability Race] Line 124 logs BlockStage::RAND_READY for blocks - can race between logging and actual dequeue cause timing inconsistencies in performance monitoring? (Low)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: item_mut()] [Range Query Inefficiency] Lines 142-145 use range_mut(0..=round).last() which scans all items up to round - can attacker spam low round numbers to make lookups O(n) causing validator slowdown? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: item_mut()] [Mutable Aliasing] item_mut() returns &mut QueueItem allowing caller to mutate offsets_by_round or num_undecided_blocks directly - can this break invariants if caller bypasses set_randomness() validation logic? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: item_mut()] [Filter Logic Bug] Line 145 filters by offsets_by_round.contains_key(&round) after finding last item - can off-by-one error in range query return wrong QueueItem if rounds span multiple items? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: item_mut()] [Concurrent Modification] While holding mutable reference from item_mut(), can another thread call push_back() or dequeue_rand_ready_prefix() causing UB through aliasing violations? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: BlockQueue::set_randomness()] [Silent Failure] Lines 149-155 return false if item_mut() returns None without logging - can Byzantine validators silently inject randomness for non-existent rounds to confuse honest nodes? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: BlockQueue::set_randomness()] [No Authentication] set_randomness() doesn't verify the caller has authority to set randomness for the given round - can any component call this to inject malicious randomness values? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: BlockQueue::set_randomness()] [Replay Attack] No check if randomness was already set with different value - can attacker repeatedly call set_randomness() with different Randomness objects attempting to replace valid randomness? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: QueueItem] [Counter Desync] num_undecided_blocks counter at line 20 can desync from actual block state if set_randomness() is called without going through proper validation - can this cause dequeue_rand_ready_prefix() to hang forever? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: QueueItem] [HashMap Consistency] offsets_by_round HashMap at line 19 is built once in constructor but blocks can be modified - can block replacement cause offsets to point to wrong indices? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: BlockQueue] [BTreeMap Invariant] BTreeMap keys are first_round() values - if blocks are reordered after insertion, can key no longer match actual first round causing lookup failures? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: BlockQueue] [Missing Synchronization] BlockQueue has no Mutex or RwLock - can concurrent access from multiple consensus threads cause data races on BTreeMap modifications? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: QueueItem] [Arc Mutation] blocks_mut() at line 88-90 returns &mut [Arc<PipelinedBlock>] - can mutation of Arc contents violate Rust's aliasing rules if other threads hold clones? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: set_randomness()] [TOCTOU Window] Between checking has_randomness() and calling set_randomness() on PipelinedBlock, can another thread set different randomness causing assertion failure? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: set_randomness()] [Underflow Wrap] num_undecided_blocks -= 1 at line 77 without bounds check - can underflow wrap to MAX_USIZE causing dequeue to never trigger? (Critical)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: QueueItem::new()] [Offset Overflow] enumerate() index at line 31 can overflow usize on 32-bit systems with huge block vectors - can this cause offset() to return wrong values? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: num_blocks()] [Len Overflow] blocks().len() at line 43 assumes vector length fits in usize - can extremely large OrderedBlocks cause len overflow on 32-bit platforms? (Low)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: QueueItem] [DropGuard Leak] broadcast_handle Option<Vec<DropGuard>> at line 21 - if QueueItem is never dropped, do DropGuards leak preventing task abortion and resource cleanup? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: push_back()] [Unbounded Growth] No maximum queue size enforced - can Byzantine validator flood with OrderedBlocks causing unbounded memory growth until OOM? (High)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Function: all_rand_metadata()] [Allocation Attack] Creating Vec with collect() allocates new vector - can repeated calls with large QueueItems cause memory pressure and allocation failures? (Medium)",
  "[File: aptos-core/consensus/src/rand/rand_gen/block_queue.rs] [Struct: BlockQueue] [BTreeMap Memory] BTreeMap nodes allocate heap memory - can attacker insert many small QueueItems to fragment heap and degrade allocator performance? (Low)"
]