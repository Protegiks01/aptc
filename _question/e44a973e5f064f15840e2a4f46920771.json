[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: make_loc()] [Integer overflow] Can an attacker craft Move source code with extremely large start/end positions causing integer overflow when casting to u32, leading to incorrect location tracking and potential parser confusion? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: current_token_loc()] [Location manipulation] Can malicious input cause start_loc() to return a value that when added to content().len() overflows, corrupting location information and potentially bypassing validation checks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: unexpected_token_error_()] [DoS via error generation] Can deeply nested or repeated unexpected tokens cause unbounded error message generation, exhausting memory and causing compiler DoS? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: adjust_token()] [Token manipulation] Can the GreaterGreater to Greater token replacement be exploited to create ambiguous type parameter parsing, allowing malformed generic type declarations to bypass validation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: require_move_2()] [Version bypass] Can an attacker craft code that uses Move 2 features without proper version checks by exploiting race conditions or ordering issues in the language version flag validation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: require_language_version_msg()] [Downgrade attack] Can manipulation of the language_version() flag allow downgrading security features from newer Move versions, enabling exploitation of fixed vulnerabilities? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: require_move_version_and_advance()] [State inconsistency] Can the advance() call succeed while require_move_version fails, leaving the parser in an inconsistent state where tokens are consumed but validation is incomplete? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_identifier()] [Symbol injection] Can extremely long identifiers cause symbol pool exhaustion or hash collisions, allowing different identifiers to be treated as identical and bypassing uniqueness checks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_identifier_or_positional_field()] [Type confusion] Can the positional field check be bypassed by crafting numeric identifiers that pass is_ascii_digit() but are not valid positional fields, causing type confusion in struct field access? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: next_token_is_positional_field()] [Validation bypass] Can specially crafted numeric strings with leading zeros or special characters bypass the is_ascii_digit() check while still being parsed as identifiers elsewhere? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_address_bytes()] [Address validation bypass] Can NumericalAddress::parse_str() accept malformed addresses that later cause vulnerabilities when used in module resolution or access control checks? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_address_bytes()] [Error masking] When parse_str() fails, the code returns DEFAULT_ERROR_ADDRESS - can this mask critical address parsing errors and allow invalid addresses to be used in module imports? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_leading_name_access()] [Wildcard abuse] Can the wildcard acceptance (Tok::Star) be exploited to create overly permissive import statements that grant unintended access to private module members? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_name_access_chain_()] [Chain length DoS] Can unlimited :: chain depth cause stack overflow through recursive parsing or validation, enabling compiler DoS attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_name_access_chain_()] [Four-level variant bypass] Does the NameAccessChain_::Four variant for fully qualified variant names have proper validation, or can it be abused to access internal/private variants? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_module_ident()] [Module resolution attack] Can ColonColon token be missing or duplicated to create ambiguous module identifiers that resolve to unexpected modules, bypassing access controls? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_comma_list()] [Unbounded list DoS] Can an attacker create extremely long comma-separated lists (type arguments, function parameters, etc.) without bounds checking, causing memory exhaustion? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_comma_list_after_start()] [Leading comma exploit] The code errors on leading commas at line 301-307, but can edge cases in lookahead allow leading commas to be parsed, creating malformed AST nodes? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_comma_list_after_start()] [Trailing comma ambiguity] Does allowing optional trailing commas create ambiguity in parsing that could lead to different interpretations of the same source code? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_module_member_modifiers()] [Duplicate modifier bypass] While duplicate checks exist (lines 608-616), can modifiers be added through different code paths to bypass uniqueness validation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_module_member_modifiers()] [Modifier ordering attack] Can the order of visibility/native/entry modifiers affect semantic meaning or bypass validation checks designed for specific orderings? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_visibility()] [Visibility confusion] Can the public(script)/public(friend)/public(package) distinctions be confused through lookahead manipulation, granting unintended access levels? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_visibility()] [Script visibility deprecation bypass] The deprecation warning for Visibility::Script (lines 2820-2833) - can old script visibility be used to bypass newer access control mechanisms? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_visibility()] [Empty public() exploit] Can public() with empty parentheses or malformed content bypass visibility validation and default to unintended access levels? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_attribute()] [Attribute injection] Can :: in attribute names (line 739-743) be exploited to inject module-qualified attributes that bypass attribute validation? (High)"
]