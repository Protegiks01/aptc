[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Serialization failure] Line 1594-1595 returns error if serialization fails - but is this checked consistently? Can unserialized constants enter constant pool and cause VM crashes when loaded? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Value case] [Address constant exploit] Lines 1117-1122 compile address constants - can malicious addresses (e.g., reserved system addresses) be embedded in bytecode to impersonate privileged accounts? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - ByteArray case] [Buffer overflow] Lines 1148-1155 compile byte arrays as vector<u8> - can oversized byte arrays cause buffer overflows in constant pool or VM memory, potentially achieving RCE? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function()] [Visibility bypass] Lines 844-886 process function visibility - can attacker craft functions marked as Private that actually expose Public interfaces, bypassing module encapsulation and accessing private state? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function()] [Acquires mismatch] Lines 871-875 compile acquires list - can functions acquire resources they don't declare, or declare acquires for resources they don't touch, causing runtime failures or bypassing access control? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: function_signature()] [Parameter count overflow] Lines 709-730 compile function signatures - can functions with too many parameters (>255) cause index overflow when accessing parameters, corrupting stack or local variables? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function_body()] [Local variable overflow] Lines 888-914 define local variables - can functions with >65535 locals cause local index wraparound, aliasing different variables and breaking Move's linear type system? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::define_local()] [Variable shadowing] Lines 171-187 check for variable redefinition - but do nested scopes allow shadowing that causes wrong variable binding and use-after-move violations? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function_body_impl()] [Native function bypass] Lines 797-842 handle native functions - can attacker mark malicious functions as native to skip bytecode generation, allowing unverified code to execute with full privileges? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_structs()] [Field order manipulation] Lines 732-755 compile struct definitions - can fields be reordered during compilation compared to declaration, causing Pack/Unpack operations to access wrong fields and break resource safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_fields()] [Native struct bypass] Lines 757-781 distinguish native vs declared fields - can attacker create fake native structs that VM treats as having internal fields, bypassing Move's encapsulation? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Pack case] [Field order validation] Lines 1180-1186 verify fields are in declaration order - but what if multiple fields have same name with different unicode normalization? Can this bypass check and corrupt struct layout? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Unpack case] [Binding mismatch] Lines 1028-1052 unpack structs to variables - can unpack bind to wrong variables if field count doesn't match struct definition, causing type confusion? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_fields()] [Field handle duplication] Lines 768-777 declare field handles - can duplicate field names in different structs share same field handle, causing cross-struct field access and breaking encapsulation? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Move case] [Use after move] Lines 1095-1099 compile MoveLoc - can moved variables be accessed again through aliased local indices, violating Move's linear type system and causing double-free? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Copy case] [Non-copyable copy] Lines 1101-1105 compile CopyLoc - can non-copyable types be copied by manipulating type metadata, breaking resource uniqueness and allowing double-spending? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - BorrowLocal case] [Borrow lifetime] Lines 1107-1114 compile local borrows - are borrow lifetimes tracked correctly? Can references outlive their referents, causing dangling pointers and memory corruption? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Borrow case] [Field borrow bypass] Lines 1278-1329 compile field borrows - can attacker borrow fields from moved structs, accessing deallocated memory and achieving read/write primitive for RCE? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - Dereference case] [Invalid dereference] Lines 1274-1277 compile ReadRef - can non-reference types be dereferenced by type confusion, reading arbitrary memory as if it were valid Move values? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_lvalues() - Mutate case] [WriteRef safety] Lines 1071-1076 compile WriteRef - can immutable references be written through by manipulating reference type tags, breaking Rust borrow rules and corrupting state? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - BinopExp case] [Arithmetic overflow] Lines 1209-1272 compile binary operations - do Add/Sub/Mul operations check for overflow? Can integer overflow in bytecode cause state corruption or bypass gas metering? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - BinopExp case] [Division by zero] Lines 1227-1229 compile Div/Mod - can division by zero pass compilation but crash validators during execution, causing liveness failures? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() - BinopExp case] [Shift overflow] Lines 1239-1244 compile Shl/Shr - can shift amounts >=256 cause undefined behavior or wrap around, producing unexpected results that break economic logic? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Abort case] [Abort code manipulation] Lines 971-977 compile Abort - can attacker control abort codes to spoof legitimate error conditions, hiding malicious behavior or framing honest validators? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Assert case] [Assert bypass] Lines 978-1002 compile Assert with conditional branching - can branch target manipulation cause asserts to be skipped even when condition is false, bypassing critical safety checks? (Critical)"
]