[
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: secondary_signers()] [Secondary signer duplication] At lines 136-138, secondary_signers are cloned and returned - can attacker include duplicate addresses in secondary_signers causing double authentication or skipped checks for duplicates, enabling privilege escalation? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Secondary signer count mismatch] At lines 47-53, secondary_signers length may not match secondary_authentication_proofs length if iter().map().collect() filters out items - can this mismatch bypass authentication for some secondary signers? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: is_multi_agent()] [Multi-agent flag bypass] At lines 179-181, is_multi_agent checks for non-empty secondary_signers OR fee_payer presence - can attacker craft transaction with empty secondary_signers and None fee_payer that still executes multi-agent logic due to stale metadata? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: authentication_proofs()] [Proof-signer mapping] At lines 146-150, proofs are collected in order (sender, then secondary) - does downstream code maintain this mapping correctly, or can reordering cause authentication proof to be checked against wrong account in multi-agent transaction? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Secondary signer capacity] At line 21, secondary_signers is Vec<AccountAddress> with no size limit in struct - can attacker provide thousands of secondary signers causing excessive iteration in authentication_proofs() or senders(), leading to gas metering bypass? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Script hash collision] At lines 65-71, script_hash uses SHA3-256 of script code - can attacker find hash collision to execute malicious script that has same hash as approved script, bypassing script whitelist or governance restrictions? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Script executable type confusion] At lines 65-67, executable_ref() is called and pattern matched - can attacker craft payload where executable_ref() returns Ok(Script) during metadata construction but different type during execution, bypassing script validation? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Empty script hash acceptance] At lines 65-71, non-script payloads get empty vec![] for script_hash - does downstream code properly handle empty hash, or will it incorrectly match against uninitialized or default hash values allowing unauthorized script execution? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Script size zero bypass] At lines 72-78, non-script payloads get NumBytes::zero() - can attacker exploit this by crafting transaction that reports zero script_size during metadata construction but has actual script during execution, bypassing size-based gas charges? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: script_size()] [Script size underflow] At lines 128-130, script_size is returned - if NumBytes type allows negative values or underflows, can cached zero size cause gas calculation to underflow allowing free script execution? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Entry function extraction race] At lines 82-90, entry_function_payload checks is_multisig() first then extracts EntryFunction - can race condition cause is_multisig() to return false but payload becomes multisig before extraction, causing type confusion in execution? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Multisig payload type confusion] At lines 91-111, multisig_payload has complex matching logic with TransactionPayload::Multisig and TransactionPayloadInner::V1 - can attacker craft payload that matches both branches causing duplicate multisig extraction or bypassed validation? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Multisig address mismatch] At lines 96-101, multisig_address is extracted from extra_config but used to construct Multisig - can this address differ from actual multisig account causing authorization bypass where wrong account's threshold is checked? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Entry function clone overhead] At lines 86 and 105, entry function is cloned with TODO comment about avoiding clone - if entry function is very large, can attacker exploit excessive cloning to cause memory exhaustion or performance degradation affecting validator consensus participation? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: entry_function_payload()] [Payload staleness] At lines 187-189, entry_function_payload() clones cached payload - if transaction payload mutates after metadata construction, can stale cached entry function execute different logic than current payload causing authorization or validation bypass? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: multisig_payload()] [Multisig payload staleness] At lines 191-193, multisig_payload() clones cached value - similar to entry function, can stale multisig metadata cause execution to use outdated threshold or signer set allowing unauthorized multisig execution? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Multisig None transaction_payload] At lines 100-108, transaction_payload can be None for non-EntryFunction executables - does multisig execution properly handle None payload, or will it panic or execute with undefined behavior? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Chain ID bypass] At line 64, chain_id is extracted from transaction - can attacker craft transaction with chain_id that doesn't match network chain_id but still gets accepted, enabling cross-chain replay attacks where transaction valid on testnet is replayed on mainnet? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: chain_id()] [Chain ID mutation] At lines 175-177, chain_id is returned by value as copy - if ChainId type is not Copy but implements it incorrectly, can the returned value differ from stored value causing inconsistent chain validation? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Expiration timestamp overflow] At line 63, expiration_timestamp_secs is extracted as u64 - can attacker set maximum u64 value causing timestamp comparison to overflow when checked against current time, making transaction never expire and enabling delayed replay attacks? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: expiration_timestamp_secs()] [Timestamp past acceptance] At lines 171-173, expiration timestamp is returned - if current time calculation overflows or wraps, can expired transactions be accepted allowing attacker to execute transactions with outdated exchange rates or stale oracle data? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Keyless authenticator detection] At lines 79-81, is_keyless uses get_authenticators() and checks if result is non-empty - can attacker craft transaction where get_authenticators() returns empty Vec but keyless authentication is still used, bypassing keyless-specific security checks like JWT validation? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: is_keyless()] [Keyless flag caching] At lines 183-185, is_keyless returns cached bool value - if keyless status changes after metadata construction (e.g., authenticator mutation), can stale flag cause non-keyless transaction to bypass normal authentication or vice versa? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Keyless unwrap panic] At line 81, unwrap_or(false) is used after get_authenticators() - if get_authenticators() returns Ok but with panic-inducing value, can attacker cause consensus-participating validators to crash when processing transaction metadata? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Keyless flag without proof] At line 35, is_keyless is stored separately from authentication_proof - can attacker set is_keyless=true but provide traditional authentication proof, causing confused validation where keyless checks pass but traditional auth is used for actual signing? (Critical)"
]