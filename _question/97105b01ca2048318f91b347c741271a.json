[
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Integer overflow] In the calculation `(flag as u64 / 8) as usize` at line 305, can an attacker exploit integer overflow by providing a maliciously large FeatureFlag enum value that causes the division to overflow when cast to usize on 32-bit systems, leading to out-of-bounds access in the features vector? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Integer truncation] In `1 << (flag as u64 % 8)` at line 306, can the modulo operation combined with left shift cause integer truncation or unexpected behavior when flag values approach u64::MAX, potentially enabling or disabling incorrect feature bits? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable()] [Out-of-bounds write] After resize_for_flag() returns byte_index and bit_mask at line 314, does the bitwise OR operation `self.features[byte_index] |= bit_mask` properly validate that byte_index is within bounds before writing, or can an attacker trigger a panic or memory corruption by enabling features with crafted enum values? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: disable()] [Out-of-bounds write] In the bitwise AND operation `self.features[byte_index] &= !bit_mask` at line 320, can an attacker cause out-of-bounds memory access by disabling features that result in invalid byte_index calculations, potentially corrupting adjacent memory regions? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Unbounded allocation] The while loop at lines 307-309 continuously pushes 0 bytes to self.features. Can an attacker provide a FeatureFlag with extremely large enum value (e.g., casting u64::MAX) to force the allocation of gigabytes of memory, causing validator node OOM crashes and loss of liveness? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_enabled()] [Integer arithmetic] At lines 335-338, the calculation `(val / 8) as usize` followed by `1 << (val % 8)` could result in incorrect bit checking if val is close to u64::MAX. Can this cause critical security features like _REJECT_UNSTABLE_BYTECODE or _DISALLOW_USER_NATIVES to be incorrectly reported as disabled, allowing malicious bytecode execution? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Shift overflow] The bit_mask calculation `1 << (flag as u64 % 8)` at line 306 performs a left shift. Can an attacker exploit undefined behavior if the shift amount equals 8 or exceeds it through integer wrapping, causing incorrect feature flag state manipulation? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: into_flag_vec()] [Integer conversion] At line 330, `FeatureFlag::from_repr(feature_idx).unwrap()` converts feature_idx to FeatureFlag. If feature_idx exceeds the maximum valid FeatureFlag value (105), this unwrap() will panic. Can an attacker craft a Features instance with bits set beyond valid feature range to cause validator node crashes during feature flag enumeration? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: Default::default()] [Buffer underflow] The default features vector is initialized with `vec![0; 5]` at line 279, allocating only 40 bits (5 bytes). However, the highest FeatureFlag is ENABLE_FUNCTION_REFLECTION = 105, requiring at least 14 bytes. Can this cause out-of-bounds access when default_features() enables flags beyond index 40? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable()] [Race condition on resize] If multiple threads concurrently call enable() for different high-index features requiring resize, the while loop at lines 307-309 could execute multiple times. Can this race condition cause one thread's resize to be lost, resulting in inconsistent feature states across validator nodes and consensus failure? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_aggregator_v2_delayed_fields_enabled()] [Dependency bypass] At lines 374-380, this function requires both AGGREGATOR_V2_DELAYED_FIELDS and RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET to be enabled. Can an attacker enable AGGREGATOR_V2_DELAYED_FIELDS first, then disable RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET through governance, breaking the dependency and causing state corruption in parallel execution? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_storage_deletion_refund_enabled()] [Transitive dependency] At lines 366-370, this function transitively depends on MODULE_EVENT (via is_emit_fee_statement_enabled). If MODULE_EVENT is disabled after STORAGE_DELETION_REFUND is enabled, does this create an inconsistent state where storage refunds are processed without proper fee statement emissions, allowing fund drainage attacks? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_emit_fee_statement_enabled()] [Circular dependency] At lines 361-364, EMIT_FEE_STATEMENT requires MODULE_EVENT to be enabled. However, there's no check preventing MODULE_EVENT from being disabled after EMIT_FEE_STATEMENT is enabled. Can this inconsistency cause validators to diverge on fee calculations, leading to consensus failure and chain splits? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default_features()] [Missing critical features] The default_features() list at lines 162-266 includes many features but might be missing newly added critical security features. If a new security-critical feature is added to the FeatureFlag enum but not to default_features(), will new validators start with that security protection disabled, creating a window for exploitation? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_zk_keyless_enabled() and is_zkless_keyless_enabled()] [Authentication bypass] At lines 388-400, these two functions check independent flags (KEYLESS_ACCOUNTS and KEYLESS_BUT_ZKLESS_ACCOUNTS). Can an attacker enable only KEYLESS_BUT_ZKLESS_ACCOUNTS without KEYLESS_ACCOUNTS to bypass ZK signature verification while still gaining keyless access, breaking authentication guarantees? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: get_max_binary_format_version()] [Version inconsistency] At lines 478-490, the function checks VM_BINARY_FORMAT_V9 through V6 flags sequentially. If an attacker enables both V9 and V6 through governance manipulation, which version takes precedence? Can this cause validators to execute transactions with different bytecode versions, leading to state divergence? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag enum] [Immutable flag bypass] Flags like _SIGNATURE_CHECKER_V2 (line 38), _REJECT_UNSTABLE_BYTECODE (line 80), and _DISALLOW_USER_NATIVES (line 95) are documented as 'enabled on mainnet and cannot be disabled'. However, the disable() function at line 318 has no enforcement preventing their disabling. Can malicious governance proposals disable these critical security features, allowing unstable bytecode or user-defined natives execution? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_calculate_transaction_fee_for_distribution_enabled() and is_distribute_transaction_fee_enabled()] [Economic attack] At lines 454-460, these two fee-related flags are independent. Can an attacker enable DISTRIBUTE_TRANSACTION_FEE without CALCULATE_TRANSACTION_FEE_FOR_DISTRIBUTION, causing validators to distribute uncalculated or zero fees, breaking economic incentives and causing validator losses? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: get_max_identifier_size()] [Identifier confusion] At lines 470-476, the function returns IDENTIFIER_SIZE_MAX (128) or LEGACY_IDENTIFIER_SIZE_MAX (larger value) based on LIMIT_MAX_IDENTIFIER_LENGTH flag. If this flag is toggled mid-epoch, can validators disagree on maximum identifier sizes, accepting different sets of transactions and causing consensus failure? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default_for_tests()] [Test-production confusion] At lines 297-302, default_for_tests() disables ENABLE_TRUSTED_CODE. If production code accidentally uses default_for_tests() instead of default(), will trusted code optimizations be disabled on mainnet, causing performance degradation and potential liveness issues? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Serialization bypass] The features field uses `#[serde(with = 'serde_bytes')]` at line 272. Can an attacker craft a malicious serialized Features object with arbitrary byte sequences that, when deserialized, bypass feature flag checks and enable disabled security features? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Size mismatch] At line 273, features is defined as Vec<u8> with no size validation. Can an attacker submit a governance proposal with a Features instance containing an excessively large byte vector (e.g., 1GB), causing all validators to OOM when deserializing the on-chain config? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Empty vector attack] What happens if the features vector is completely empty (Vec::new())? Will is_enabled() always return false for all features including critical security flags like _REJECT_UNSTABLE_BYTECODE, allowing arbitrary bytecode execution? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [Genesis manipulation] At lines 493-507, this function creates a ChangeSet with Features::default_for_tests(). Can an attacker who controls genesis initialization use this test function in production to start the chain with ENABLE_TRUSTED_CODE disabled, degrading security posture? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [Panic on serialization] At line 494, bcs::to_bytes() uses unwrap(). If Features::default_for_tests() returns a struct that cannot be serialized (due to size limits or invalid state), will this panic cause genesis initialization to fail, preventing network bootstrap? (High)"
]