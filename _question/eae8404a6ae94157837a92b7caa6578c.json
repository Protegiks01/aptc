[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Assert case] [Label collision] Lines 988 generates unique assert labels - but can label name collisions with user-defined labels cause control flow to jump to wrong locations and skip validation? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Jump case] [Unconditional jump exploit] Lines 1010-1013 compile Jump - can infinite loops be created that waste gas or cause validators to hang during execution, DoSing the network? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Return case] [Return value mismatch] Lines 1024-1027 compile Return - can functions return wrong number of values or wrong types, causing calling code to access garbage values and corrupt state? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() - Assign case] [Assignment type mismatch] Lines 1003-1006 compile assignment - can right-hand side type differ from left-hand side, causing type confusion when values are read back? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::Exists] [Exists bypass] Lines 1353-1370 compile Exists builtin - can type parameter manipulation cause Exists to check wrong resource type, allowing access to resources that shouldn't be accessible? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::BorrowGlobal] [Global borrow exploit] Lines 1371-1398 compile BorrowGlobal - can immutable borrows be upgraded to mutable, or can borrows access wrong account's resources, enabling theft of arbitrary assets? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::MoveFrom] [MoveFrom theft] Lines 1399-1414 compile MoveFrom - can attacker MoveFrom resources they don't own by manipulating address arguments, directly stealing tokens and NFTs from victims? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::MoveTo] [MoveTo duplication] Lines 1415-1432 compile MoveTo - can calling MoveTo when resource already exists overwrite existing resource, destroying user funds or creating duplicate resources? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecPack] [Vector size overflow] Lines 1433-1442 compile VecPack with element count - can attacker specify num>actual pushed values, causing VM to read uninitialized memory as vector elements? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecLen] [Length manipulation] Lines 1443-1450 compile VecLen - can vector length be manipulated to return wrong values, bypassing bounds checks in subsequent code? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecImmBorrow/VecMutBorrow] [Vector index OOB] Lines 1451-1468 compile vector borrows - can out-of-bounds indices pass compilation but cause crashes or arbitrary memory access during execution? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecPushBack] [Type confusion push] Lines 1469-1476 compile VecPushBack - can wrong type be pushed by type parameter mismatch, corrupting vector contents and breaking type safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecPopBack] [Pop underflow] Lines 1477-1484 compile VecPopBack - can popping from empty vector pass compilation, causing underflow and returning uninitialized memory? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::VecSwap] [Swap OOB] Lines 1495-1503 compile VecSwap - can swap indices be out of bounds or equal, causing undefined behavior or no-op that breaks transaction logic? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::Freeze] [Freeze bypass] Lines 1504-1508 compile FreezeRef - can already-frozen references be frozen again, causing double-freeze that corrupts reference counting? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - Builtin::ToU*] [Cast overflow] Lines 1509-1538 compile integer casts - can casting large integers to small types (e.g., U256->U8) silently truncate values, causing economic calculations to be wrong and enabling fund theft? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - ModuleFunctionCall] [Cross-module call] Lines 1545-1568 compile module function calls - can attacker call private functions by manipulating function handles, bypassing access control? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() - ModuleFunctionCall] [Type argument mismatch] Lines 1550-1560 handle type arguments for generic calls - can wrong type arguments cause generic function to instantiate with incorrect types, breaking type safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [Direct bytecode injection] Lines 1651-1928 compile raw bytecode instructions - can attacker use bytecode mode to inject arbitrary instructions that bypass high-level IR validation, achieving unrestricted code execution? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - CopyLoc/MoveLoc] [Local index manipulation] Lines 1689-1691 compile local operations - can bytecode specify invalid local indices that access outside function frame, reading/writing arbitrary stack memory? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - Call] [Direct call bypass] Lines 1692-1706 compile calls - can bytecode directly call any function including private or native ones, completely bypassing module boundaries and access control? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - Pack/Unpack] [Struct manipulation] Lines 1707-1736 compile Pack/Unpack - can bytecode pack/unpack with wrong field counts or types, corrupting struct layout and breaking resource safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - BorrowField] [Field borrow manipulation] Lines 1746-1789 compile field borrows - can bytecode borrow fields that don't exist or from wrong struct types, achieving arbitrary memory access? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - BorrowGlobal] [Global resource access] Lines 1790-1819 compile global borrows - can bytecode access global resources without proper authorization checks, stealing any account's assets? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() - MoveFrom/MoveTo] [Resource manipulation] Lines 1853-1882 compile resource moves - can bytecode MoveFrom/MoveTo violate resource uniqueness, duplicating or destroying resources arbitrarily? (Critical)"
]