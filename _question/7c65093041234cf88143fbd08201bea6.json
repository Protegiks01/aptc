[
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: EventsByVersionIter::next_impl()] [Boundary check] When expected_next_version >= end_version at line 264, can an attacker manipulate end_version to be 0, causing all events to be skipped? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Limit bypass] At line 335-337, can an attacker set limit to 0 to bypass iteration limits, or set it to u64::MAX to cause excessive memory consumption when collecting summaries? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Address validation] At line 340-344, if address != self.address, iteration stops - can an attacker craft database entries with similar addresses to cause premature termination? (Low)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Direction confusion] At line 347-353, different logic for Backward vs Forward direction - can an attacker exploit the unwrap() on Optional values to cause panics when start_version or end_version is None? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Version mismatch] At line 355-360, a DB corruption check ensures version matches - but if this check passes with manipulated data, can it lead to incorrect transaction history reconstruction? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Ledger version bypass] At line 363-365, transactions beyond ledger_version are excluded - can an attacker set ledger_version to u64::MAX to expose uncommitted or future transactions? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::next_impl()] [Count overflow] At line 368, self.count += 1 increments without overflow checking - can an attacker iterate exactly u64::MAX times to wrap count back to 0 and bypass the limit check? (Low)",
  "[File: aptos-core/storage/aptosdb/src/utils/iterators.rs] [Function: AccountTransactionSummariesIter::new()] [Invalid range] Can start_version > end_version create an invalid range that causes unexpected iteration behavior or infinite loops? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: get_state_kv_commit_progress()] [Progress spoofing] At line 57-62, can a Byzantine validator manipulate StateKvCommitProgress in their local DB to report false progress, causing inconsistent state across the network? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: get_state_merkle_commit_progress()] [Progress desync] At line 64-71, if state_merkle and state_kv progress drift apart beyond MAX_COMMIT_PROGRESS_DIFFERENCE, can this cause state inconsistency during recovery? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_ledger_db()] [Atomicity violation] At line 73-79, truncation is performed in a single batch - if the batch write fails midway, can partial truncation corrupt the ledger and cause chain splits? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_ledger_db()] [Version boundary] At line 76, start_version = target_version + 1 - can integer overflow when target_version = u64::MAX cause start_version to wrap to 0, truncating the entire ledger? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_ledger_db_single_batch()] [Batch ordering] At line 325-361, multiple delete operations occur before progress update - if a crash happens after deletion but before progress update, can the DB become inconsistent? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_ledger_db_single_batch()] [Progress write timing] At line 353-358, progress is written to metadata_db before main batch - can this create a window where progress indicates truncation but data still exists, causing read inconsistencies? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db()] [Batch size validation] At line 87, assert!(batch_size > 0) - but can batch_size = 1 cause excessive DB writes, degrading validator performance and potentially causing liveness issues? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db()] [Progress-first vulnerability] At line 99-101, progress is written BEFORE actual truncation - if truncation fails, can this leave the DB in a state where progress indicates completion but data still exists? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db()] [Loop termination] At line 94-113, can the loop fail to terminate if current_version becomes less than target_version due to integer underflow in saturating_sub at line 96? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db()] [Assertion failure] At line 114, assert_eq!(current_version, target_version) - can this assertion fail if the loop terminates early due to errors, causing node panics? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db_shards()] [Parallel truncation race] At line 122-127, parallel truncation via rayon - can concurrent shard truncation cause race conditions where shards end up at different versions, breaking state consistency? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db_single_shard()] [Shard isolation] At line 129-142, each shard is truncated independently - can a failure in one shard leave other shards truncated, causing shard version misalignment? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_kv_db_single_shard()] [Version arithmetic] At line 137, target_version + 1 is used as start_version for deletion - can overflow cause all data to be deleted instead of data after target_version? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db()] [Infinite loop] At line 150-179, the loop continues while current_version > target_version - can database corruption cause current_version to never decrease, creating an infinite loop? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db()] [Version assertion] At line 154, assert_ge!(current_version, target_version) - can this panic if concurrent operations modify current_version, crashing the validator node? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db()] [Node version lookup] At line 159-163, find_closest_node_version_at_or_before must succeed (unwrap .expect()) - can missing node data cause panics during truncation? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db()] [Top-level commit timing] At line 174, top_levels_batch is committed before shards - can this create inconsistency where top levels are at version_before but shards are still at current_version? (Critical)"
]