[
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Epoch transition race] During epoch reconfiguration when previous_epoch_ending_version changes, can concurrent commit operations see inconsistent epoch boundary values and misclassify stale nodes, causing some nodes to be lost from both schemas and creating gaps in state history? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Retroactive epoch boundary change] If a blockchain reorganization changes which version is considered the epoch boundary, can already-committed StaleNodeIndexCrossEpochSchema entries become invalidated without being migrated to StaleNodeIndexSchema, causing incorrect pruning behavior? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Cross-epoch node resurrection] Can a malicious validator craft a transaction that creates a new merkle node with the same NodeKey as a previously stale cross-epoch node, causing the old stale index entry to incorrectly reference the new active node and trigger its premature deletion during pruning? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [State root verification bypass] If the pruner deletes JellyfishMerkleNodes based on corrupted StaleNodeIndexCrossEpochSchema entries (e.g., due to encoding bugs), can this cause state root verification to fail for historical epochs, preventing validators from syncing and potentially causing network partition? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: encode_key()] [Key determinism violation] If encode_key() produces non-deterministic output (e.g., due to uninitialized memory or platform-specific serialization), can different validators store the same StaleNodeIndex under different keys, causing divergent pruning behavior and state root mismatches? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: decode_key()] [Partial decode corruption] If decode_key() succeeds despite receiving corrupted or truncated data (e.g., due to disk corruption), can this create StaleNodeIndex instances with invalid fields that cause crashes or incorrect behavior in pruning logic? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Atomic commit failure] If a transaction batch that writes multiple StaleNodeIndexCrossEpochSchema entries is only partially committed (e.g., due to crash mid-commit), can this create an inconsistent database state where some stale indices are recorded but others are missing, causing incomplete pruning? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Schema migration vulnerability] If the schema definition changes in a future version (e.g., key format modification), can existing StaleNodeIndexCrossEpochSchema entries become unreadable without migration, causing pruning to fail and garbage to accumulate until disk exhaustion? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Write-write conflict] Can concurrent commits to the same shard write conflicting StaleNodeIndexCrossEpochSchema entries for the same NodeKey at different stale_since_versions, causing later entries to overwrite earlier ones and losing pruning information? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Read-prune race] If the epoch_snapshot_pruner is reading StaleNodeIndexCrossEpochSchema entries via iterator while concurrent commits are adding new entries, can this cause the iterator to skip entries or see inconsistent snapshots, leading to incomplete pruning? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Delete-read race] Can a race between pruner deletion of a StaleNodeIndexCrossEpochSchema entry and concurrent read by another component (e.g., truncation helper) cause the reader to observe partially deleted state and make incorrect decisions? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Progress update race] If multiple pruner workers concurrently update the epoch_snapshot_pruner progress metadata after processing StaleNodeIndexCrossEpochSchema entries, can race conditions cause progress to be set to an incorrect version, leading to re-processing or skipping of entries? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Shard coordination failure] Since StaleNodeIndexCrossEpochSchema entries are sharded by node_key.get_shard_id(), can lack of coordination between shard pruners cause entries to be processed out of order relative to their stale_since_version, violating pruning invariants? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema definition] [Column family isolation] Since StaleNodeIndexCrossEpochSchema uses a separate column family (STALE_NODE_INDEX_CROSS_EPOCH_CF_NAME), can inconsistent configuration between validators (e.g., different compaction settings) cause divergent database layouts that affect key ordering or retrieval performance? (Low)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Referential integrity violation] Since StaleNodeIndexCrossEpochSchema references NodeKeys that exist in JellyfishMerkleNodeSchema, can deletion of a JellyfishMerkleNode without corresponding StaleNodeIndexCrossEpochSchema deletion (or vice versa) cause dangling references that corrupt database integrity? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Backup restoration corruption] If a backup includes StaleNodeIndexCrossEpochSchema entries but is missing corresponding JellyfishMerkleNode entries (e.g., due to partial backup), can restoration of such backup cause the pruner to attempt deletion of non-existent nodes, leading to database errors? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Truncation inconsistency] When truncating the database to an earlier version, if StaleNodeIndexCrossEpochSchema entries are deleted but the truncation fails to complete, can this leave the database in an inconsistent state with missing stale indices for extant merkle nodes? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: encode_key()] [Write amplification attack] Can an attacker trigger creation of excessive StaleNodeIndexCrossEpochSchema entries (e.g., by causing many nodes to become stale at epoch boundaries) to amplify write load and cause database performance degradation that affects consensus timing? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: encode_key()] [Version monotonicity violation] Can non-monotonic version assignment (e.g., due to system clock issues or blockchain reorg) cause stale_since_version values to be out of order, breaking the BigEndian key ordering assumption and causing pruner to process entries in wrong sequence? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: decode_key()] [Version wraparound] If the blockchain operates long enough for versions to approach u64::MAX, can version wraparound cause newly created stale nodes to have smaller version numbers than old stale nodes, corrupting the key ordering and causing catastrophic pruning failures? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Version gap handling] If there are gaps in version numbering (e.g., due to empty blocks or transaction failures), can the pruner's iteration over StaleNodeIndexCrossEpochSchema entries by version skip these gaps and fail to process all entries that should be pruned? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: encode_seek_key()] [Target version precision] When seeking to a target version for pruning, if the target is set between two actual stale_since_version values, does the seek correctly position to the next entry, or can rounding errors cause entries to be skipped? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Schema integration] [Version comparison semantics] Is the comparison node_key.version() <= previous_epoch_ending_version semantically correct for classifying cross-epoch nodes, or should it be < to avoid double-counting boundary nodes, potentially causing them to be stored in both schemas? (High)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: encode_key()] [Memory allocation attack] Can an attacker cause node_key.encode() to allocate excessively large buffers (e.g., via deep nibble paths) that consume validator memory during encode_key(), potentially triggering OOM kills and causing validator downtime? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs] [Function: decode_key()] [Stack overflow via deep recursion] Does NodeKey::decode() have maximum depth limits for nibble path parsing, or can extremely deep merkle trees cause stack overflow during decode_key() when validators read StaleNodeIndexCrossEpochSchema entries? (Medium)"
]