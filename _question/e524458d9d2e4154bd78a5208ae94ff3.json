[
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: check_params_args_types_vectors_need_freezeref()] [False Negative] At lines 1179-1195, the type comparison logic may return false for types that need freezing - can an attacker craft type pairs where t1 != t2 but the reference check doesn't detect mutability mismatch, bypassing FreezeRef insertion and violating reference safety? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: construct_inlined_call_expression()] [Partial Freeze] At lines 1196-1200, if all elements are false None is returned - can an attacker provide argument lists where only some elements need freezing but the check returns None, causing those elements to not be frozen and violating Move's reference safety guarantees? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_temporary()] [Index Out of Bounds] At line 1311, temporary index is compared to inlined_formal_params.len() - can an attacker provide bytecode with temporary indices exceeding the parameter count that bypass the bounds check, accessing invalid memory or causing undefined behavior? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_temporary()] [Function Type Abuse] At lines 1314-1322, lambda parameters used as temporaries trigger an error - can an attacker find edge cases where function-typed parameters are used as locals without triggering this check, allowing invalid operations on function values? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_temporary()] [Type Instantiation] At lines 1323-1330, parameter types are instantiated for temporaries - can incorrect type instantiation at line 1324 cause the temporary to have a different type than expected, leading to type confusion in subsequent operations? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_temporary()] [Shadow Symbol Bypass] At line 1326-1330, shadow symbols are retrieved for temporaries - can an attacker create scenarios where the shadow_stack incorrectly returns None for a temporary that should be shadowed, causing incorrect variable resolution? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_temporary()] [Error Handling] At lines 1332-1342, out-of-bounds temporaries trigger a Bug diagnostic - can an attacker craft inline functions where this error is triggered but compilation continues, producing invalid bytecode that crashes the VM at runtime? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: run_inlining()] [Call Graph Incompleteness] At lines 97-117, the call graph is built by visiting targets - can an attacker create inline functions that are called indirectly through function pointers or other mechanisms not captured by used_funs_with_uses(), causing incomplete call graph and missed inlining? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: run_inlining()] [Infinite Loop] At lines 105-116, targets are added to todo and visited_targets - can an attacker trigger a scenario where visited_targets.insert() returns false but the target is still added to call_graph, causing the while loop to run indefinitely? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: run_inlining()] [Target Insertion Race] At line 110, targets.entry() is called which may modify the targets map - can concurrent modification of targets during iteration cause inconsistent call graph construction leading to missed inline sites? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: targets_needing_inlining_in_order()] [Ordering Violation] At lines 223-326, targets are ordered bottom-up using postorder - can incorrect postorder implementation cause inline functions to be processed before their callees, resulting in incomplete inlining where nested inline calls are missed? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: postorder()] [Stack Manipulation] At lines 330-362, a stack-based DFS is used for postorder - can malformed call graphs with unexpected node connections cause the stack to become corrupted, producing incorrect traversal order and breaking inlining dependencies? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: lift_lambda_and_generate_spec_fun()] [Spec Mismatch] At lines 760-790, lifted lambdas are converted to spec functions - can the lifted function have different parameter counts or types than expected, causing assertion failures at line 1361 or incorrect spec function calls? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_invoke()] [Closure Mask Corruption] At lines 1362-1376, the closure mask determines which parameters are captured vs free - can an attacker manipulate the mask to cause captured parameters to be treated as free or vice versa, leading to incorrect argument passing in spec function calls? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_invoke()] [Spec vs Move Divergence] At lines 1378-1396, invoke expressions are rewritten to either spec or move function calls based on in_spec counter - can incorrect in_spec tracking cause spec functions to be called in move code or move functions in spec code, breaking the separation? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: lift_lambda_and_generate_spec_fun()] [Lifted Function Count] At line 779, the assertion checks that exactly one function is lifted - can an attacker craft lambda expressions that cause multiple or zero functions to be lifted, bypassing this assertion and causing undefined behavior? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_invoke()] [Parameter Position Mismatch] At lines 1366-1376, parameter positions are used to index into captured and free arguments - can off-by-one errors or incorrect position mapping cause arguments to be passed to wrong parameters, producing incorrect results in spec verification? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_pattern()] [Wildcard Pattern Bypass] At lines 1022-1025, wildcard patterns are created for underscore variables - can an attacker exploit wildcard pattern matching to skip necessary variable bindings, allowing uninitialized variables to be used in inlined code? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_pattern()] [Struct Pattern Instantiation] At lines 1465-1472, struct patterns have their struct_id instantiated - can incorrect struct_id instantiation cause pattern matching to succeed with wrong struct types, violating Move's type safety for resource types? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_pattern()] [Pattern Node Reuse] At line 1457, new_id_opt may be None causing old_id reuse - can node ID reuse cause multiple patterns to share the same node ID, leading to AST corruption and incorrect type information? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: make_lambda_pattern_a_tuple()] [Pattern Wrapping] At lines 1206-1217, non-tuple patterns are wrapped in singleton tuples - can this wrapping cause type mismatches when the wrapped pattern is later matched against non-tuple arguments? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_pattern()] [Error Pattern Handling] At line 1475, Error patterns return None - can Error patterns in critical positions cause pattern rewriting to fail silently, allowing malformed patterns to remain in the AST? (Low)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: rewrite_node_id()] [Location Tracking] At line 1297, node location is updated with inlined_from() - can incorrect location tracking cause error messages to point to wrong source locations, making debugging impossible for users? (Low)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: construct_inlined_call_expression()] [Node ID Creation] At lines 1064, 1130, new node IDs are created - can excessive node ID creation exhaust the node ID space or cause ID collisions leading to AST corruption? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/inliner.rs] [Function: parameter_list_to_pattern()] [Node Location Mixing] At line 1038, function_loc is combined with call_site_loc using inlined_from - can incorrect location mixing cause source mappings to become corrupted, breaking debugger support? (Low)"
]