[
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: signature_index] [Signature reuse attack] At lines 546-548, signature_index uses get_or_add_item to reuse existing signatures - can an attacker exploit this by crafting signatures that hash-collide with system signatures (e.g., empty signature, signer signature) to cause legitimate function calls to use attacker-controlled signatures, bypassing type safety checks? (Critical)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: struct_instantiation_index] [Type parameter overflow] At lines 441-454, struct_instantiation_index creates StructDefInstantiation with type_parameters as SignatureIndex, but there's no validation that the signature at that index actually contains valid type arguments or that the number of type arguments matches the struct's type parameter count - can this cause type confusion? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: function_instantiation_index] [Generic exploitation] At lines 456-470, function_instantiation_index doesn't validate that the type_parameters signature matches the function's declared type parameter count - can an attacker instantiate a generic function with wrong number of type arguments, causing VM execution errors or type confusion during bytecode verification? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: field_instantiation_index] [Field type mismatch] At lines 472-486, field_instantiation_index creates FieldInstantiation without validating that the field actually belongs to a generic struct or that the type_parameters are appropriate for that field - can this cause the VM to access fields with incorrect type assumptions? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: reindex_signature_token - TypeParameter case] [Type parameter bounds] At line 768, TypeParameter tokens are passed through unchanged during reindexing - can an attacker exploit this by having a type parameter index in a dependency that exceeds the current module's type parameter count, causing out-of-bounds access during type resolution? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: identifier_index] [Identifier injection] At lines 494-499, identifier_index uses ident_str() which performs validation, but can an attacker exploit the fact that Identifier.to_owned() is called for storage - if ident_str allows Unicode normalization tricks or null bytes, can this cause two visually identical but binary-different identifiers to map to different indices, bypassing name collision checks? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: address_index] [Address exhaustion] At lines 501-507, address_index adds addresses to a pool with TABLE_MAX_SIZE limit - can an attacker reference 65536 different addresses in a single module to exhaust the address pool, preventing legitimate modules from being compiled or causing address index wraparound? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: module_handle_index] [Invalid module reference] At lines 418-425, module_handle_index retrieves module handle and unwraps the result from module_handles.get() - can an attacker cause a panic by requesting a module_handle_index for a module that was added to the modules HashMap but failed to be added to module_handles due to pool exhaustion? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: module_alias] [Missing import] At lines 395-399, module_alias returns an error if the module isn't imported, but this error is only a format_err without state rollback - can an attacker exploit this by causing partial compilation failures that leave the Context in an inconsistent state where some pools have entries for the module but others don't? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: declare_import] [Alias shadowing] At lines 574-590, declare_import allows overwriting existing aliases (line 581 comment says 'don't care about duplicate aliases') - can an attacker shadow system module aliases (e.g., 'Self') to redirect code to attacker-controlled modules, bypassing access control checks? (Critical)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: constant_index] [Constant confusion] At lines 510-516, constant_index adds constants to the pool using get_or_add_item which reuses existing constants - can an attacker exploit this by crafting two semantically different constants (e.g., different types with same byte representation) that get deduplicated into the same pool entry, causing type confusion when the constant is used? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: declare_constant] [Name collision] At lines 689-693, declare_constant inserts into named_constants HashMap without checking for duplicates - can an attacker declare the same constant name twice with different values, causing the second declaration to silently overwrite the first and leading to incorrect constant values being used in bytecode? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: named_constant_index] [Missing constant] At lines 518-523, named_constant_index bails if constant is not found, but doesn't validate that the constant's type matches the expected usage - can an attacker reference a named constant expecting it to be a u64 when it's actually an address, causing type confusion during VM execution? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: label_index] [Label overflow] At lines 489-491, label_index uses get_or_add_item which can add up to TABLE_MAX_SIZE labels - can an attacker create a function with 65536 labels to exhaust the label pool, then cause label remapping (build_index_remapping at lines 379-388) to produce incorrect CodeOffset values due to u16 wraparound? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: build_index_remapping] [Label confusion] At lines 379-388, build_index_remapping creates a mapping from fake label offsets to actual code offsets, but uses std::mem::take to move labels out of context - if this function is called multiple times or if compilation continues after calling it, can this cause labels HashMap to be empty leading to label resolution failures or incorrect jumps? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: take_dependencies] [Lifetime violation] At lines 314-316, take_dependencies uses std::mem::take to move dependencies out of Context - if compilation code continues to call dependency resolution functions after this, can they access empty dependencies HashMap and cause panics or incorrect 'Dependency not provided' errors? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: restore_dependencies] [Assertion bypass] At lines 318-321, restore_dependencies asserts dependencies is empty before restoring, but if take_dependencies wasn't called first, can an attacker exploit this assertion to crash the validator by attempting to restore dependencies when some already exist? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: add_compiled_dependency] [Duplicate dependency] At lines 323-335, add_compiled_dependency bails on duplicate dependencies, but what if an attacker provides the same dependency twice with slightly different content (different bytecode but same ModuleIdent) - does the first one get cached and used, potentially allowing dependency confusion attacks? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Enum: CompiledDependency] [Lifetime confusion] At lines 184-205, CompiledDependency has Borrowed and Stored variants with different lifetimes - can an attacker exploit the variance in lifetimes to cause use-after-free by having Borrowed dependency reference a CompiledModule that gets dropped while Context still holds the reference? (Critical)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Struct: StoredCompiledDependency] [Self-referential unsafety] At lines 168-182, StoredCompiledDependency uses ouroboros crate for self-referential struct - can an attacker trigger memory unsafety by exploiting the self-referential borrow if the ouroboros-generated code has bugs or if the module Box gets moved while view is still borrowed? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: CompiledDependencyView::new] [Invalid self_handle] At lines 80-116, CompiledDependencyView::new assumes dep.self_handle_idx() returns a valid index, but doesn't validate it - can an attacker provide a malformed CompiledModule where self_handle_idx points to out-of-bounds module handle, causing the filter at line 101 to miss functions or include wrong functions? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: CompiledDependencyView::new - struct loop] [Integer overflow] At lines 86-93, the loop over struct_handles calls get_or_add_item which returns Result, but the loop doesn't properly handle errors - if get_or_add_item returns Err due to pool exhaustion, can this cause the function to early-return leaving structs HashMap partially populated with some but not all structs from the dependency? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: source_struct_info] [Bounds checking] At lines 119-143, source_struct_info performs multiple .get() operations on slices without validating indices - can an attacker provide a dependency with malformed indices where struct_pool has a StructHandle with out-of-bounds module or name indices, causing source_struct_info to return None and downstream code to fail unpredictably? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: source_struct_info - assertion] [Invariant violation] At line 131, there's an assertion that module != ModuleName::module_self(), but this is checked AFTER retrieving the module name from identifiers - can an attacker craft a dependency that violates this invariant by having a struct whose module handle points to a module named 'Self', causing the assertion to panic and crash the validator? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: struct_handle] [String conversion exploit] At lines 145-152, struct_handle converts ModuleName and StructName to IdentStr using ident_str(), which can fail if the names contain invalid characters - if this conversion fails, the function returns None instead of Error, can this cause silent failures where struct lookups fail but compilation continues with incorrect assumptions? (Low)"
]