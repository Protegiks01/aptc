[
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_resource()] [Deserialization vulnerability] Can an attacker craft malicious JSON data that causes serde_json::from_value() to panic or produce incorrect CoinInfoResource/CoinStoreResource objects, leading to indexer crashes or corrupted coin balance tracking? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_resource()] [Type confusion] Can an attacker supply a data_type string that matches the expected patterns ('0x1::coin::CoinInfo' or '0x1::coin::CoinStore') but contains malicious JSON data that exploits serde deserialization to inject incorrect supply or balance values? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_resource()] [Error handling bypass] The function returns Ok(None) for unsupported types at line 199, but then uses .context() expecting Some - can this logic lead to silent failures where invalid coin resources are processed without proper validation? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_write_resource()] [Data integrity] The function uses placeholder values (0) for write_index and state_key_hash - can these placeholders cause issues if MoveResource::from_write_resource() relies on these values for deduplication or ordering? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_write_resource()] [Null pointer] Line 232 uses resource.data.as_ref().unwrap() without checking if data is Some - can malformed WriteResource objects cause the indexer to panic, leading to DoS of the indexing service? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_name_trunc()] [Data loss] The function truncates coin names to 32 characters - can an attacker create multiple coins with identical 32-character prefixes to cause name collisions in the indexer database, making distinct coins indistinguishable? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_symbol_trunc()] [Collision attack] Symbol truncation to 10 characters - can an attacker register coins with symbols like 'USDT_FAKE_COIN' and 'USDT_SCAM_TOKEN' that both truncate to 'USDT_FAKE_', causing UI/database confusion and potential phishing attacks? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_coin_type_trunc()] [Hash collision] The COIN_TYPE_HASH_LENGTH constant is 5000 characters - can an attacker craft extremely long coin type strings that hash to identical truncated values, causing indexer to conflate different coins and report incorrect balances? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: to_hash()] [Determinism] The hash_str() function is called on coin_type - if this uses a non-deterministic hash (e.g., HashMap randomization), can different indexer nodes produce different hash values for the same coin, causing consensus failures in indexer state? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: CoinInfoResource] [Integer overflow] The decimals field is i32 - can an attacker create a coin with decimals = i32::MAX and then perform arithmetic causing overflow when converting amounts, leading to incorrect balance calculations? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: IntegerResource] [BigDecimal overflow] The value field uses deserialize_from_string with BigDecimal - can an attacker supply extremely large numeric strings (e.g., '9' repeated millions of times) that cause memory exhaustion or computational DoS during parsing? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: Coin] [Negative amounts] The Coin.value field is BigDecimal - does deserialization properly reject negative values, or can an attacker inject negative balances causing arithmetic underflows when computing total supply? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: WithdrawCoinEvent/DepositCoinEvent] [Amount validation] The amount fields use BigDecimal deserialization - can an attacker emit events with amounts exceeding the actual coin supply, causing the indexer to report inflated circulation numbers? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_supply()] [Precision loss] The function returns Option<BigDecimal> from IntegerResource - can precision loss during BigDecimal operations cause the indexer to report incorrect total supply for high-decimal coins? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_move_type()] [Type validation] The function extracts address from MoveType::Struct but returns an error for non-struct types - can an attacker supply a crafted MoveType that passes is_resource_supported() but fails here, causing inconsistent validation? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_move_type()] [Address parsing] Line 152 converts inner.address.to_string() - can malformed AccountAddress objects produce invalid address strings that bypass downstream validation checks? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: is_resource_supported()] [Pattern matching] The function only checks for exact string matches '0x1::coin::CoinInfo' and '0x1::coin::CoinStore' - can case variations, Unicode tricks, or whitespace injection bypass this check while still being valid Move types? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_write_resource()] [String formatting] Lines 215-220 construct type_str using format! macro - can malicious module/name values containing special characters (::, <, >) create malformed type strings that bypass validation? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_aggregator_metadata()] [Option handling] The function uses .first() on OptionalAggregatorWrapperResource.vec - if the vec is empty for a coin with tracked supply, does this cause silent failure where supply updates are not indexed? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: get_aggregator_metadata()] [Nested unwrapping] Lines 40-44 perform nested Option unwrapping (supply.vec.first() then inner.aggregator.get_aggregator_metadata()) - can partially initialized supply structures cause panics or incorrect None returns? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: AggregatorResource] [Key collision] The handle and key fields are plain Strings - can an attacker craft coins with colliding (handle, key) pairs that cause the indexer to conflate supplies of different coins? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: OptionalAggregatorResource] [Aggregator/Integer conflict] The struct contains both aggregator (table-based supply) and integer (direct supply) - which takes precedence if both are populated, and can this ambiguity cause supply tracking errors? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: EventGuidResource] [Integer overflow] The creation_num field is i64 deserialized from string - can an attacker supply creation_num values exceeding i64::MAX causing deserialization to wrap around or panic? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Struct: EventGuidResource] [Negative creation_num] The creation_num is signed i64 - does deserialization allow negative values, and if so, can this cause incorrect event ordering or GUID collisions in the indexer? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_utils.rs] [Function: from_event()] [Event type confusion] The function pattern matches on '0x1::coin::WithdrawEvent' and '0x1::coin::DepositEvent' - can an attacker deploy custom events with these exact type strings to inject fake withdraw/deposit events into the indexer? (Critical)"
]