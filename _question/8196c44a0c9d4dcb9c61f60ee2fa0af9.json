[
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::new()] [Integer Overflow] Can a malicious peer send a StreamHeader with num_fragments = 255 (u8::MAX) causing integer overflow when calculating expected_fragments + 1 in validation logic, potentially bypassing fragment count limits? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::new()] [Validation Bypass] Can an attacker craft a StreamHeader with num_fragments = 0 to bypass the max_fragments check (line 116) and create a stream that never completes, causing resource leaks? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::new()] [Type Confusion] The check at line 112 rejects NetworkMessage::Error but what prevents an attacker from wrapping malicious payloads in RpcRequest/RpcResponse/DirectSendMsg to bypass this validation? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::new()] [Resource Exhaustion] The max_fragments check (line 116) uses 'as usize' conversion - can an attacker exploit platform-dependent usize sizes to bypass this limit on 32-bit vs 64-bit systems? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::new()] [State Corruption] After passing validation, the StreamHeader.message is moved into InboundStream.message (line 123) - can this message be mutated during fragment assembly to violate the original header's integrity? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Integer Overflow] At line 133, the check 'self.current_fragment_id + 1 == fragment.fragment_id' could overflow when current_fragment_id = 254 and fragment_id = 255, potentially accepting wrong fragment ordering - can this be exploited? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Sequence Violation] The fragment_id validation (line 133) enforces strict sequential ordering, but what happens if fragment_id wraps around from 255 to 0? Can an attacker send 256+ fragments to cause undefined behavior? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Request ID Collision] The request_id check (line 129) only ensures matching IDs within a stream - can an attacker reuse request_ids across different streams to cause fragment mixing if InboundStreamBuffer is not properly isolated? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Memory Exhaustion] At lines 142-145, raw_data is appended to the message using Vec::append() which transfers ownership - can an attacker send extremely large fragments (up to max_frame_size each) to exhaust memory before hitting the max_message_size check in OutboundStream? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Panic Condition] Line 141 has a panic!() for Error messages - can an attacker trigger this panic by modifying the message type between header receipt and fragment assembly, crashing the validator node? (Critical)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Fragment ID Manipulation] After incrementing current_fragment_id at line 138, if this value exceeds num_fragments, the final check at line 146 would fail - but what prevents an attacker from sending num_fragments+1 fragments to cause arithmetic errors? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Data Corruption] The Vec::append() operation at lines 142-145 drains the source vector - if the fragment is processed multiple times or shared across threads, could this lead to data loss or corruption? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Return Value Confusion] The function returns Ok(true) when current_fragment_id == num_fragments (line 146) - but if num_fragments was 0, could this cause premature stream completion? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::new_stream()] [State Confusion] At line 77, Option::replace() discards an existing stream with a bail! error - can an attacker repeatedly send new headers to discard partially assembled legitimate messages, causing message loss and consensus disruption? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::new_stream()] [Race Condition] Is InboundStreamBuffer::new_stream() thread-safe? Multiple concurrent calls could race to replace self.stream, potentially causing data races or lost fragments if accessed from multiple async tasks. (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::new_stream()] [Resource Leak] When an old stream is discarded at line 78, are all its accumulated fragments properly dropped? Could repeated stream replacement cause memory leaks if fragment buffers are not freed? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::new_stream()] [Validation Timing] The InboundStream::new() validation happens after replacing the old stream - if validation fails, the old stream is already lost. Can this be exploited to cause denial of service by repeatedly sending invalid headers? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::new_stream()] [Request ID Reuse] The bail! message at line 79 logs old.request_id but doesn't validate that the new header has a different request_id - can an attacker send duplicate request_ids to confuse stream tracking? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::append_fragment()] [Null Pointer] At line 90, the code calls ok_or_else() to handle None case - but what if a fragment arrives before any header? The error message 'No stream exist' suggests this is expected - can attackers send fragments without headers to cause errors? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::append_fragment()] [Stream Completion] At line 95, when stream_end is true, the stream is taken with unwrap() - if the stream was somehow None between lines 93-95 (race condition), this would panic. Is this safe in concurrent contexts? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::append_fragment()] [Error Propagation] If InboundStream::append_fragment() returns an error at line 93, the stream remains in InboundStreamBuffer but in an inconsistent state - should the stream be cleared on error to prevent further fragments from being appended? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStreamBuffer::append_fragment()] [Return Value Handling] The function returns Option<NetworkMessage> - if Some() is returned, the stream is consumed. But what prevents receiving more fragments for the same request_id after completion? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::new()] [Buffer Overflow] At line 164, max_frame_size is reduced by 64 bytes for headers - but is this buffer sufficient for all header types? Could variable-length headers exceed this allocation causing buffer overflows? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::new()] [Assertion Panic] The assertion at line 165-170 checks 'max_frame_size * u8::MAX as usize >= max_message_size' - can configuration values be set to trigger this assertion and panic the node during initialization? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::new()] [Integer Overflow] The multiplication 'max_frame_size * u8::MAX as usize' at line 166 could overflow on platforms with large usize - should this use checked_mul()? (Medium)"
]