[
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_validate_pubkey()] [Validation completeness] Does this function check ONLY subgroup membership at line 409, or does it also verify point validity, cofactor clearing, and other security properties? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_validate_pubkey()] [PoP requirement bypass] This validates a PK without requiring a PoP - in the context of aggregate signatures, does this enable rogue key attacks if callers don't separately verify PoP? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_validate_pubkey()] [Caching issue] If a PK is validated once and cached in Move, but then the validation rules change, could old cached PKs bypass new security checks? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Message-PK mismatch] The check at line 463-465 verifies pks.len() == messages.len(), but if this is checked after gas charging for PKs, can an attacker waste gas by providing mismatched inputs? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Rogue key in aggregate] The verification at line 497-499 doesn't enforce that PKs have valid PoPs - can a rogue PK be included that makes the aggregate verify under a different message set? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Message duplication] If the same message appears multiple times with different PKs in messages/pks_serialized, does this enable a grinding attack to find colliding signatures? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Empty message handling] If one of the messages in the messages vector is empty (0 bytes), does hash-to-curve handle this securely or could it lead to collisions? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Gas overflow] The fold operation at lines 492-494 sums message lengths - can this overflow with extremely many small messages or a few giant messages? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Pairing count] Gas charges for messages.len() + 1 pairings at line 489 - is this accurate for the actual number of pairings computed, or could the implementation use fewer pairings and overcharge? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Batch verification] The verification at line 497-499 processes all message/PK pairs atomically - if verification fails, can the caller determine which pair was invalid, or does this hide malicious signers? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_aggregate_signature()] [Reference lifetime] The msgs_refs and pks_refs at lines 480-484 hold references - are these lifetimes correct to prevent use-after-free if verify_aggregate_arbitrary_msg holds references beyond the function scope? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_multisignature()] [Missing subgroup check] The function sets check_pk_subgroup=false at line 520 - in multisignature schemes, can this allow signatures from small-order PKs to pass verification? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_multisignature()] [Aggregate PK validation] Since this takes an aggregate PK, is there a check that it was properly formed via aggregate_pubkeys, or can an attacker provide an arbitrary G1 point as the aggregate PK? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_multisignature()] [Single message vulnerability] Multisignatures sign a single message - but is there domain separation to prevent a multisignature from being reinterpreted as a normal signature or signature share? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_normal_signature()] [Enforced subgroup check] The function enforces check_pk_subgroup=true at line 544 with a comment about forgetting to check - is this a band-aid fix for a deeper issue where callers should be checking themselves? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_normal_signature()] [PoP confusion] The comment at line 541 mentions PKs typically don't come with PoPs - but if a normal signature is later used in an aggregate scheme, does this create a rogue key vulnerability? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_normal_signature()] [Signature replay] For normal signatures, is there any nonce or domain separation to prevent the same signature from being replayed in different contexts? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_proof_of_possession()] [PoP verification] The pop.verify(&pk) at line 583 - does this check that the PoP was created correctly for the given PK, or can an attacker reuse someone else's PoP with a different PK? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_proof_of_possession()] [No subgroup check] The function doesn't call subgroup checks on PK before PoP verification - can this allow PoPs for small-order PKs to verify? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_proof_of_possession()] [Domain separation] Does PoP verification use a different hash-to-curve domain than normal signatures to prevent cross-protocol signature reuse? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_proof_of_possession()] [Gas estimation] Comment at line 581 says 2 pairings and hash-to-curve - but is the actual gas cost calibrated against real execution time to prevent undercharging? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_signature_share()] [PoP requirement] Comment at line 604-605 says caller REQUIRED to check PoP - but this isn't enforced in the function. Can malicious callers skip PoP checks and enable rogue key attacks? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_signature_share()] [Threshold signature context] For threshold signatures, are there additional checks needed beyond normal signature verification, such as verifying the share index or polynomial evaluation? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_bls12381_verify_signature_share()] [Share aggregation] If signature shares are later aggregated, is there validation that they're from distinct signers to prevent a single signer from contributing multiple shares? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/bls12381.rs] [Function: native_generate_keys()] [Production leak] The testing function at line 611 is gated by feature flag - but if this feature is accidentally enabled in production, can it leak validator private keys? (Critical)"
]