[
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_global_invariants_for_memory()] [Type Unification] At lines 1409-1413, type unification is performed with NoUnificationContext. Can an attacker exploit weaknesses in type unification to match invariants to unintended memory types, causing incorrect invariant application? (High)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_global_invariants_for_memory()] [Unbounded Iteration] The function iterates over all global_invariants_for_memory entries at line 1404. Can an attacker register invariants for millions of memory types, causing DoS during invariant lookup? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: is_spec_fun_recursive()] [Infinite Recursion] At lines 1446-1470, recursion detection uses BTreeSet to track visited functions. Can an attacker create mutually recursive spec functions that exhaust the visited set or cause stack overflow if the recursion detection fails? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: spec_fun_uses_generic_type_reflection()] [Cache Poisoning] At lines 1531-1544, generic type reflection is cached in a RefCell. Can concurrent accesses cause cache corruption where wrong results are cached for specific instantiations, leading to incorrect verification? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: spec_fun_uses_generic_type_reflection()] [Type Reflection Bypass] At lines 1503-1526, only specific well-known functions are considered for type reflection. Can an attacker create wrapper functions around type reflection primitives that bypass this detection and use generic type reflection unsafely? (High)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_used_modules()] [Cache Invalidation] At lines 3199-3235, used_modules_including_specs is cached in RefCell. When module specs are modified after caching, is the cache invalidated? Can stale cached data cause incorrect dependency tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: is_transitive_dependency()] [Stack Overflow] At line 3308, transitive dependency checking is recursive without depth limit. Can an attacker create circular module dependencies that cause stack overflow during dependency validation? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: need_to_be_friended_by()] [Friend Calculation] At lines 3243-3287, friend requirements are computed by traversing used functions. Can an attacker exploit inline function expansion to hide actual dependencies and bypass package visibility checks? (High)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: can_call_package_fun_in()] [Package Visibility Bypass] At lines 3291-3298, the check uses is_primary_target() and self_address() comparison. Can an attacker craft non-primary-target modules with matching addresses to bypass package visibility and call private functions? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_field_by_offset_optional_variant()] [Offset Confusion] At lines 4084-4095, fields are looked up by offset without validating the offset is in range. Can an attacker provide out-of-bounds offsets to access unrelated fields or cause panics? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_variant_idx()] [Variant Index Overflow] At line 4002, variant position is cast to VariantIndex. Can an attacker create structs with more variants than VariantIndex can represent, causing truncation and wrong variant selection? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: is_phantom_parameter()] [Phantom Type Confusion] At line 4100, phantom parameter checking uses simple index bounds. Can an attacker exploit type parameter positions to bypass phantom type restrictions and create invalid instantiations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: is_pragma_true()] [Pragma Inheritance] At lines 4126-4134, pragmas are checked in struct then module with a default. Can an attacker exploit pragma inheritance to override safety-critical pragmas set at module level with struct-level pragmas? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_calling_functions()] [RefCell Panic] At line 5322, calling_funs cache is accessed through RefCell. Can concurrent verification threads cause borrow_mut panics by accessing the cache simultaneously? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_transitive_closure_of_called_functions()] [Infinite Loop] At lines 5348-5369, transitive closure uses BFS but doesn't detect cycles. Can mutually recursive functions cause infinite loops if the visited set fails to prevent re-visitation? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_used_functions_with_transitive_inline()] [Inline Explosion] At lines 5273-5292, inline functions are transitively traversed. Can an attacker create deeply nested inline function chains that cause exponential blowup in the used function set? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: should_verify()] [Verification Bypass] At lines 5184-5207, verification scope checks pragmas with fallback to default scope. Can an attacker use VerificationScope::Only to override module-level verification settings and disable verification of critical functions? (High)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_local_name()] [Name Injection] At lines 5067-5092, local names are retrieved from source_map or synthesized. Can an attacker manipulate source_map to inject malicious variable names that collide with internal variables? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: is_temporary()] [Temporary Detection] At line 5101, temporaries are detected by checking for 'tmp#$' in the name. Can an attacker name user variables with this pattern to bypass temporary-specific optimizations or checks? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_local_type()] [Index Out of Bounds] At lines 5118-5130, local type lookup uses index without bounds checking before accessing locals_signature. Can an attacker provide invalid indices causing panics or wrong type retrieval? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: update_friend_decls_in_targets()] [Friend Injection] At lines 2659-2690, friend declarations are automatically added based on need_to_be_friended_by(). Can an attacker exploit this automatic friend addition to inject unwanted friend relationships and bypass package visibility? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: has_friend()] [Friend Validation] At line 3136, friend checking is a simple contains() check on friend_modules. Can an attacker exploit the separation between friend_decls and friend_modules to create friend relationships without proper declarations? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: get_friend_modules_from_bytecode()] [Friend Module Resolution] At lines 1896-1906, friend modules are resolved by ModuleName lookup. Can an attacker exploit missing friend modules (that return None from find_module) to create partially valid friend relationships? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: update_node_instantiation()] [Instantiation Corruption] At line 2499, node instantiation is updated with assertion that it was previously set. Can race conditions cause the assertion to pass but instantiation to be corrupted by concurrent updates? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/model.rs] [Function: globalize_signature()] [Signature Conversion] At lines 3562-3578, SignatureToken is converted to Type using struct_resolver. Can an attacker craft malformed SignatureTokens that cause the resolver to return invalid QualifiedIds? (High)"
]