[
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 56] [Fr deserialization malicious input] The fr_deser benchmark deserializes Fr from bytes without showing input validation - could production code deserialize non-canonical field element encodings (values >= modulus) that cause consensus divergence when validators disagree on scalar values? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 60] [Fr from_u64 overflow] The fr_from_u64 benchmark converts u64 to Fr - does production code validate u64 values before conversion, or could overflow in the conversion process cause incorrect scalar values in nonce generation or signature computations? (Medium - $10K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 72] [Fq division by zero] The fq_div benchmark performs base field division - since Fq operations are used in curve point arithmetic, could division by zero in production point doubling or addition formulas cause validator crashes when processing malicious curve points? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 76] [Fq inversion zero] The fq_inv benchmark inverts Fq elements - if curve point formulas use inversion without checking for zero (e.g., computing point tangents), could an attacker craft special curve points that crash validators during point operations? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 71] [Fq deserialization attack] The fq_deser benchmark deserializes Fq coordinates - could an attacker submit curve points with coordinates >= field modulus that are accepted by some validators but rejected by others, causing consensus failure? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 69-82] [Fq timing side-channel] Fq operations are benchmarked individually - could an attacker analyze benchmark results to determine which Fq values cause slower computations, then craft curve points with those coordinates to selectively slow down specific validators? (Medium - $10K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 87] [Fq12 division by zero] The fq12_div benchmark performs division in the pairing output field - since Fq12 division is used in pairing equality checks, could division by zero enable attackers to bypass pairing verification in Groth16 proofs or BLS signature verification? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 91] [Fq12 inversion degeneracy] The fq12_inv benchmark inverts pairing results - if the pairing output is 1 (identity), inversion succeeds but has no cryptographic meaning - could an attacker exploit this to create trivial 'valid' pairings that bypass security checks? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 94] [Fq12 exponentiation timing] The fq12_pow_u256 benchmark performs exponentiation in the target group - since final exponentiation is part of pairing computation, could timing variations in this operation leak information about secret pairing inputs through side-channel analysis? (Medium - $10K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 86] [Fq12 deserialization] The fq12_deser benchmark deserializes pairing outputs - could an attacker submit malicious serialized Fq12 values that cause buffer overflows, infinite loops, or consensus divergence when different validators parse them differently? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 84-97] [Fq12 multiplication chain] Multiple Fq12 operations are benchmarked - if production pairing verification chains multiple Fq12 multiplications without intermediate validation, could numerical instability or overflow cause incorrect verification results? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 100-107] [G1 affine deserialization attack] G1 affine points are deserialized in both compressed and uncompressed formats (lines 101-107) - does production code validate that deserialized points satisfy the curve equation y² = x³ + 3, or could an attacker inject off-curve points that break signature or proof verification? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 109-113] [G1 generator trusted setup] The g1_affine_generator benchmark retrieves the curve generator - if production code doesn't validate the generator is correct at startup, could a malicious build or dependency substitution attack replace the generator with a point of known discrete log? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 115-119] [G1 infinity point handling] The g1_affine_infinity benchmark uses zero() to get the point at infinity - does production code correctly handle infinity in all group operations (addition, scalar multiplication), or could attackers exploit infinity to create trivial 'valid' signatures or cause validator panics? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 121-128] [G1 scalar multiplication timing] The g1_affine_scalar_mul_to_proj benchmark multiplies curve points by scalars - if production signature or key derivation code doesn't use constant-time scalar multiplication, could an attacker extract private keys through timing side-channel attacks? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 130-137] [G1 negation malleability] The g1_affine_neg benchmark negates curve points - could an attacker exploit signature malleability by negating signature components, creating multiple valid signatures for the same message and enabling transaction replay attacks? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 139-146] [G1 compressed serialization] The g1_affine_serialize_comp benchmark uses compressed point encoding - does production code validate the compression flag and y-coordinate sign bit, or could an attacker flip bits to create two different serializations for the same point, causing signature verification inconsistencies? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 148-155] [G1 uncompressed serialization size] The g1_affine_serialize_uncomp benchmark serializes full (x, y) coordinates - does production code validate serialization size limits to prevent buffer overflows, or could an attacker send oversized serialized points to crash validators? (Medium - $10K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 157-164] [G1 affine to projective conversion] The g1_affine_to_proj benchmark converts coordinate systems - if this conversion has bugs (e.g., incorrect Z coordinate initialization), could production code produce invalid projective points that break subsequent cryptographic operations? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 99-164] [G1 affine subgroup check] None of the G1 affine benchmarks explicitly check subgroup membership - does production code validate that deserialized G1 points are in the prime-order subgroup, or could small subgroup attacks enable signature forgery or proof malleability? (Critical - $1M)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 166-177] [G1 projective addition edge cases] The g1_proj_add benchmark adds two random projective points - does production code handle all edge cases (P + P, P + (-P), P + 0), or could an attacker craft inputs that trigger unhandled cases causing validator panics? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 179-186] [G1 projective doubling degenerate case] The g1_proj_double benchmark doubles points - if a point with y=0 is doubled, the result should be infinity - does production code handle this correctly, or could malicious points cause infinite loops or crashes? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 188-199] [G1 projective equality non-constant time] The g1_proj_eq benchmark compares points for equality - if production code uses this for signature verification, could timing variations leak information about which validator signatures are being compared, enabling consensus manipulation? (Medium - $10K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 201-205] [G1 projective generator consistency] The g1_proj_generator benchmark gets the projective generator - if the projective and affine generators don't match when converted, could this cause validator consensus divergence when some use affine and others use projective coordinates? (High - $50K)",
  "[File: aptos-core/crates/aptos-crypto/benches/ark_bn254.rs] [Lines 207-211] [G1 projective infinity representation] The g1_proj_infinity benchmark uses zero() - projective infinity is (X:Y:0) - if production code doesn't properly detect infinity (checking Z=0), could attackers exploit non-canonical infinity representations? (High - $50K)"
]