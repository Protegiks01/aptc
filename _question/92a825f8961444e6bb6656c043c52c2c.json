[
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::delete()] [Orphaned nodes] When updating prev and next pointers during deletion, can errors in updating pending map cause nodes to become orphaned and unreachable, leaking memory? (Medium)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::delete()] [Head/tail inconsistency] When old_slot.prev() is None, head is updated, but can this leave tail pointing to deleted node if head == tail, corrupting the list? (High)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::get_slot()] [Cache bypass] The function checks pending, then overlay, then committed - can an attacker force cache misses by filling pending to bypass security checks in overlay/committed layers? (Medium)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::expect_hot_slot()] [Assertion attack] The function asserts slot.is_hot() after retrieval - can time-of-check-time-of-use (TOCTOU) race conditions allow cold slots to be returned, causing panic? (High)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::maybe_evict()] [Cold slot insertion] After eviction, slot.to_cold() is inserted into pending - can this contaminate the pending map and cause cold slots to be treated as hot in subsequent operations? (High)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Struct: HotStateLRU] [Capacity manipulation] The capacity field is NonZeroUsize, but can the hot_state_config be manipulated through governance to set capacity to 1, causing constant eviction and performance degradation? (Medium)",
  "[File: storage/storage-interface/src/state_store/hot_state.rs] [Function: HotStateLRU::new()] [Initial state validation] When initializing with existing head/tail/num_items, can inconsistent values cause the LRU to start in invalid state without validation? (High)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::new()] [Lineage validation] The function asserts current.is_descendant_of(&base), but only checks shard 0 - can attackers create deltas with inconsistent shard lineage that pass validation? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::new()] [Shard view creation] When creating shards with view_layers_after(), can overlapping or out-of-order layers cause the delta to include incorrect updates? (High)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::get_state_slot()] [Shard ID manipulation] The function uses state_key.get_shard_id() to index shards array - can a malicious StateKey return out-of-bounds shard_id to cause array index panic? (High)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::num_free_hot_slots()] [Assertion overflow] The function asserts num_items <= HOT_STATE_MAX_ITEMS_PER_SHARD and computes MAX - num_items - can corrupted num_items cause assertion failure or underflow? (High)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::num_free_hot_slots()] [Inconsistent limits] If hot_state_config allows different max_items_per_shard than HOT_STATE_MAX_ITEMS_PER_SHARD constant, can this cause validation errors across validators? (Medium)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Struct: StateDelta] [Arc clone overhead] The shards field is Arc<[LayeredMap; 16]> - can excessive cloning of StateDelta in hot paths cause memory pressure and slow down consensus? (Low)",
  "[File: storage/storage-interface/src/state_store/state_delta.rs] [Function: StateDelta::latest_hot_key()] [Metadata access] Functions directly access current.latest_hot_key(shard_id) without bounds checking shard_id - can out-of-bounds access cause panic? (Medium)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [CORRUPTION_SENTINEL check] The function asserts global_state_summary.root_hash() != CORRUPTION_SENTINEL before update - can an attacker bypass this by setting root hash to CORRUPTION_SENTINEL during update to prevent future updates? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Version ordering] The function asserts persisted.next_version() <= self.next_version() - can attackers exploit time-of-check-time-of-use to update with stale persisted summary, causing state fork? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [SMT update atomicity] The batch_update_sorted_uniq() call operates on global_state_summary - can partial updates or crashes leave the SMT in inconsistent state with invalid root hash? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [MakeHot filtering] The code filters out MakeHot ops with state_op.as_state_value_opt() - can attackers bypass this by crafting BaseStateOp variants that pass through but corrupt state? (High)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Hash computation] Updates are mapped to (k, value_opt.map(|v| v.hash())) - can hash collision attacks cause different state values to produce same hash, enabling state forgery? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Sorting assumption] The code assumes items within shards are sorted by key hash after sorted_by_key() - can unsorted items from malicious shards break batch_update_sorted_uniq() invariants? (High)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::is_descendant_of()] [Only global check] The function only checks global_state_summary.is_descendant_of() but ignores hot_state_summary - can hot state divergence go undetected? (High)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: LedgerStateSummary::update()] [Checkpoint bypass] When updates.for_last_checkpoint_batched() is None, last_checkpoint is cloned - can this allow skipping Merkle tree validation for checkpoint state? (Critical)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: LedgerStateSummary::assert_versions_match()] [Only assertion] This function only asserts but doesn't prevent mismatched versions from being constructed - can validators create LedgerState and LedgerStateSummary separately with mismatched versions? (High)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: ProvableStateSummary::get_proof()] [Random verification] The function only verifies proof 1 in 10000 times with rand::random() - can attackers exploit this by querying thousands of times to get unverified proofs, then providing fake proofs? (High)",
  "[File: storage/storage-interface/src/state_store/state_summary.rs] [Function: ProvableStateSummary::get_proof()] [Root depth manipulation] The function accepts root_depth parameter - can attackers request shallow proofs (large root_depth) to avoid verification of actual state, enabling state proof forgery? (High)"
]