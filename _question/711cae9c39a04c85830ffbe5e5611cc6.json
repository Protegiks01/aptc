[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_field_type_and_struct_type()] [Type confusion] Can a malicious bytecode craft a FieldInstantiationIndex that causes type confusion between the cached field type and actual field type during subsequent accesses, potentially breaking Move's resource safety guarantees and enabling unauthorized resource manipulation? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_variant_field_type_and_struct_type()] [Type confusion] Does the variant field instantiation cache properly validate that the cached struct type matches the actual variant definition, or can type parameter manipulation cause the cache to return incorrect types leading to type confusion vulnerabilities? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_type()] [Type safety violation] Can an attacker exploit the BTreeMap caching mechanism to cache an incorrect struct type for a StructDefInstantiationIndex, then reuse that poisoned cache entry to bypass Move's type system checks in subsequent operations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_variant_type()] [Type instantiation bypass] If frame.create_struct_instantiation_ty() fails during initial cache population but succeeds in frame.get_struct_variant_instantiation_at(), could this inconsistency lead to cached types that don't match the actual variant structure, breaking type safety? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: struct_def_instantiation_type] [Cache poisoning] Can malicious bytecode pre-populate the struct_def_instantiation_type cache with incorrect Type values that persist across multiple transaction executions in parallel execution scenarios, causing non-deterministic execution results? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_field_type_and_struct_type()] [Gas undercharging] Can an attacker craft type instantiations where ty.num_nodes() returns incorrect values (via integer overflow or type complexity manipulation), causing NumTypeNodes to be miscalculated and leading to systematic gas undercharging? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_fields_types()] [Gas metering bypass] Does the gas calculation for struct field types properly account for deeply nested generic types, or can an attacker create recursive type structures where num_nodes() saturates or wraps, allowing execution of expensive operations while paying minimal gas? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_signature_index_type()] [Integer overflow in gas] When computing NumTypeNodes::new(ty.num_nodes() as u64), can the u64 cast overflow if num_nodes() returns usize::MAX on 128-bit systems, resulting in gas calculations wrapping to zero and enabling free computation? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_variant_field_type_and_struct_type()] [Gas inconsistency] If the same type has different num_nodes() values when instantiated through different code paths, could this lead to non-deterministic gas charging across validators, breaking consensus? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Macro: get_or_insert!] [Gas caching bypass] Does the get_or_insert! macro properly charge gas for cache misses vs cache hits, or can an attacker force cache thrashing to exploit differential gas costs and execute more operations than their gas budget allows? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_fields_types()] [Cache poisoning] Can malicious bytecode trigger a scenario where instantiate_generic_struct_fields() returns different field types for the same StructDefInstantiationIndex across different executions, causing the cache to serve stale incorrect types? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: field_instantiation] [Cross-transaction pollution] In parallel execution environments (Block-STM), can cache entries from one transaction leak into another transaction's FrameTypeCache, causing non-deterministic execution where transactions see types from other transactions? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: per_instruction_cache] [Instruction cache corruption] Can an attacker craft bytecode that exploits the per_instruction_cache to store malicious PerInstructionCache::Call or CallGeneric entries that point to incorrect LoadedFunction instances, causing wrong function invocation? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Enum: PerInstructionCache] [Cache confusion] Can the PerInstructionCache enum be exploited where a bytecode instruction index that should cache Pack data instead gets CallGeneric data, leading to type confusion when the cache is read? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_variant_field_instantiation()] [Variant confusion] If variant field instantiation info changes between cache insertion and retrieval (due to module upgrade or state transition), does the cache properly invalidate, or will it serve stale variant type information? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [Memory exhaustion] Can an attacker craft transactions with massive numbers of unique type instantiations that fill all BTreeMap caches unboundedly, causing validator node memory exhaustion and consensus failure? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: make_rc_for_function()] [Per-instruction cache DoS] When per_instruction_cache.resize() is called with function.code_size(), can malicious bytecode with extremely large code_size values allocate unbounded vectors causing memory exhaustion before gas limits are enforced? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: struct_field_type_instantiation] [Amplification attack] Can an attacker craft struct instantiations with hundreds of generic fields that get cached as Vec<(Type, NumTypeNodes)>, where each instantiation creates megabytes of cached data, amplifying memory consumption beyond gas cost expectations? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_variant_fields_types()] [Vec allocation DoS] Does instantiate_generic_struct_variant_fields() have bounds on the number of fields returned, or can it allocate arbitrarily large Vec that gets cached, exhausting memory? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: function_cache] [Function cache explosion] Can recursive or mutually recursive function calls cause unbounded growth in function_cache BTreeMap entries, where each function's FrameTypeCache contains references to other functions' caches in a deeply nested structure? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [RefCell race condition] Since FrameTypeCache is wrapped in Rc<RefCell<_>>, can concurrent borrow_mut() calls from parallel transaction execution cause RefCell borrow panics, leading to validator crashes and consensus failure? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Enum: PerInstructionCache::Call] [Shared cache mutation] When PerInstructionCache::Call stores Rc<RefCell<FrameTypeCache>>, can multiple concurrent transactions mutate the shared FrameTypeCache simultaneously, causing cache corruption and non-deterministic execution? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_field_type_and_struct_type()] [TOCTOU vulnerability] Between checking the BTreeMap entry with Entry::Occupied/Vacant and inserting/reading the value, can another thread modify the cache state causing time-of-check-time-of-use bugs? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: instantiated_local_tys] [Arc clone race] When instantiated_local_tys is set to Some(Rc<[Type]>), can concurrent clone operations on the Rc cause reference count races that lead to use-after-free or double-free conditions? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Macro: get_or_insert!] [Reentrant mutation] If the $ty_func closure in get_or_insert! macro somehow triggers reentrant mutation of the same FrameTypeCache (via nested function calls), can this cause cache corruption or panic from RefCell borrow violations? (Medium)"
]