[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: should_remove_node()] [Attribute Ordering] Does the order of attributes in the attrs slice at line 52 affect filtering behavior? Can an attacker place #[verify_only] after other attributes to bypass the any() check at line 54? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: verification_attributes()] [Nested Attributes] At line 67, if attr.value.attribute_name().value contains nested or compound attribute names, can this cause KnownAttribute::resolve to fail or return incorrect results, bypassing filtering? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: should_remove_node()] [Attribute Duplication] If the same #[verify_only] attribute appears multiple times in attrs at line 50, does the flattening at line 52 handle duplicates correctly, or can duplicate attributes cause multiple evaluations that affect performance or correctness? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: should_remove_node()] [Memory Allocation] The Vec allocation at line 52 via collect() could allocate unbounded memory if attrs contains thousands of attribute groups - can this cause OOM on validator nodes during compilation of maliciously crafted Move code? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: verification_attributes()] [Iterator Performance] The filter_map operation at lines 66-71 iterates over all attributes - for modules with thousands of attributes, can this cause O(nÂ²) performance when combined with outer iterations in filter_program, causing compilation DoS? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: program()] [AST Traversal] The filter_program call at line 45 recursively traverses the entire AST - for deeply nested Move modules with thousands of definitions, can this cause stack overflow on validator nodes during compilation? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: should_remove_node()] [Non-Deterministic Filtering] If env.flags().is_verification() at line 56 can return different values on different validator nodes due to configuration differences, does this cause validators to compile the same Move code into different bytecode, breaking consensus? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: verification_attributes()] [Ordering Dependence] The collect() at line 72 preserves attribute ordering from iteration - if attribute order is non-deterministic (e.g., from HashMap iteration), can this cause different validators to produce different flattened_attrs, leading to consensus failures? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: program()] [Compilation Flags] The entire filtering behavior depends on CompilationEnv flags - if validators use different flag configurations (test mode vs production mode), can this cause them to accept different sets of transactions, splitting the network? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Type: P::Attributes] [Type Confusion] The P::Attributes type from parser::ast at line 29 - can type confusion between parser-level attributes and other attribute representations cause the wrong attributes to be filtered, leaking verification code? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Pattern Match: line 67] [Exhaustiveness] The match pattern at line 67 only handles Verification variant of KnownAttribute - are all other variants (Testing, Native, Deprecation, Lint, Execution) correctly ignored, or can they be confused with verification attributes? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Lifetime: Context<'env>] [Variance] The 'env lifetime in Context at line 14 - can lifetime variance rules be exploited to transmute or extend lifetimes, causing the Context to access freed CompilationEnv memory? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Iterator: line 52] [Lazy Evaluation] The flat_map at line 52 uses lazy iterator evaluation - can this cause verification_attributes() to be called multiple times with side effects, or can iterator invalidation occur if attrs is modified during iteration? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: verification_attributes()] [None Handling] When KnownAttribute::resolve returns None at line 67, the filter_map silently skips it - should there be error reporting for unknown attributes that look like verification attributes, or does silent skipping allow typos like #[verifiy_only] to pass through? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: should_remove_node()] [Panic Safety] If verification_attributes() panics at line 52 (e.g., due to malformed attributes), does this panic propagate and halt compilation, or is there panic handling to ensure validators can continue processing other transactions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Function: program()] [Return Value] The program function at line 43 returns the filtered P::Program - if filtering fails or produces an invalid AST, does the compiler detect this before bytecode generation, or can corrupted AST lead to invalid bytecode? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Pipeline: Pre-Expansion] This filter runs before expansion phase - can verification-only code affect name resolution, type inference, or other expansion-phase operations before being filtered, leaving security-relevant side effects in the compiled output? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Pipeline: Multi-Pass] If the compiler makes multiple passes over the AST, can verification_attributes() be called multiple times with different verification flag states, causing inconsistent filtering between passes? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Pipeline: Caching] If the compiler caches compilation results, can cached results from verification mode be incorrectly reused in production mode (or vice versa), including verify_only code in production bytecode? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Cross-Module: References] If verify_only code references are removed but non-verify code still references the removed symbols (functions, structs), does this cause linker errors or dangling references that could be exploited? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Cross-Module: Friend Declarations] If a verify_only module declares friends or is declared as a friend by production modules, does filtering handle these relationships correctly or can it create broken friend chains that bypass access control? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Cross-Module: Spec Blocks] The filter_program in parser::filter.rs handles spec blocks - if verify_only spec blocks reference filtered members, can this cause spec verification to fail or produce incorrect results? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Semantics: VerifyOnly] The VerifyOnly variant at line 55 marks code for verification mode only - is there any validation that verify_only code doesn't contain critical security checks that should also be present in production, preventing security regressions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Semantics: Attribute Position] According to known_attributes, verify_only can appear on modules, functions, structs, etc - does the filter correctly handle verify_only on all allowed positions, or can placing it on unexpected positions bypass filtering? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Semantics: Conditional Compilation] The filtering provides conditional compilation based on verify flag - is the inverse operation tested? Can production code be marked to only compile when NOT in verify mode using the same attributes? (Low)"
]