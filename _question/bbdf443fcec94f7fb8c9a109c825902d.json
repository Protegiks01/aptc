[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Struct: Lexer] [Integer Overflow] Can an attacker provide extremely large Move source files that cause integer overflow in cur_start, cur_end, or prev_end fields (usize), potentially leading to incorrect token boundary calculations and allowing malicious code to bypass parser validation? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: content()] [Out of Bounds Access] In the content() method that slices text[self.cur_start..self.cur_end], can an attacker craft input where cur_end < cur_start due to integer underflow, causing a panic and denial-of-service when compiling Move contracts? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: new()] [State Initialization] Does the Lexer::new() constructor properly initialize all position tracking fields (prev_end=0, cur_start=0, cur_end=0), or can race conditions in concurrent compilation lead to partially initialized lexer state? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: start_loc()] [Position Consistency] Can the start_loc() method return stale cur_start values if advance() fails midway, leading to incorrect source location reporting that masks actual syntax errors in malicious Move code? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: previous_end_loc()] [State Synchronization] Does previous_end_loc() correctly track prev_end after replace_token() is called, or can token replacement corrupt position tracking leading to misaligned token boundaries? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Stack Overflow] In the nested block comment handling using Vec<(usize, bool)> stack, can an attacker craft deeply nested /* /* /* ... */ */ */ comments that cause stack overflow or excessive memory consumption, leading to compiler DoS when deploying Move contracts? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Unclosed Comment Detection] When detecting unclosed block comments at line 270-278, does the error handling correctly prevent partial token extraction from within the unclosed comment, or can an attacker hide malicious Move code inside unclosed comments that gets improperly parsed? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Documentation Comment Injection] In the documentation comment detection logic (lines 284-289) that checks for '/**' but not '/***' or '/**/', can an attacker craft borderline cases like '/***/' that get misclassified, allowing injection of arbitrary documentation that could mislead contract auditors? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Comment Nesting State] In the nested comment parsing loop at lines 265-316, does the locs stack properly handle interleaved '/*' and '*/' sequences like '/*/ */*/', or can malformed sequences corrupt the stack leading to incorrect comment boundary detection? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Offset Calculation Overflow] The get_offset closure at line 251 calculates offset + len - substring.len(). Can extreme input sizes cause integer overflow in this calculation, leading to incorrect doc_comments map insertion positions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Substring Extraction] When extracting documentation comment content at line 303 using self.text[(loc.0 + 3)..(end - 2)], can boundary conditions where end < loc.0 + 5 cause panic or extract incorrect comment data? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Empty Stack Pop] At line 295 when calling locs.pop().unwrap() after finding '*/', what happens if the stack is empty due to mismatched comment delimiters, and can this panic be triggered by attacker-controlled input? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Documentation Comment Nesting] The condition locs.is_empty() at line 289 prevents doc comments inside nested comments. Can an attacker exploit edge cases where is_empty() check races with push/pop operations in concurrent compilation scenarios? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Line Comment Handling] In line comment parsing starting at line 321, does the trim_start_matches for newline properly handle all newline types (LF, CRLF), or can attacker use mixed line endings to hide code in what appears to be comments? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Documentation Comment Detection] The is_doc check at line 323 uses starts_with('///') && !starts_with('////'). Can an attacker use '////' at the start followed by malicious content that gets treated as code instead of comment? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [CRLF Trimming] At line 330, the comment is trimmed of '\\r' characters. Can Windows CRLF handling inconsistencies cause position tracking errors where reported error locations don't match actual source positions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: trim_whitespace_and_comments()] [Comment Map Insertion] When inserting into doc_comments map at line 332-333, can duplicate span keys cause comment overwrites, and could an attacker use this to suppress legitimate documentation comments? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead_with_span()] [State Mutation] Does lookahead_with_span() truly avoid mutating lexer state, or can trim_whitespace_and_comments() calls modify doc_comments map during lookahead, causing non-deterministic parsing behavior? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead_content()] [String Allocation] In lookahead_content() at line 358, does the String allocation and slicing of text[next_start..next_start + length] handle cases where length causes integer overflow in addition, potentially reading out of bounds? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead2()] [Consistency] In lookahead2() that looks ahead two tokens (lines 369-377), can inconsistent trim_whitespace_and_comments() results between first and second lookahead calls lead to different token sequences than actual advance() calls would produce? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead_nth()] [Performance Attack] The lookahead_nth() function (lines 381-393) loops n times calling trim_whitespace_and_comments(). Can an attacker request lookahead of extremely large n values causing excessive CPU consumption and compiler timeout? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead_nth()] [Loop Invariant] In the for loop at line 385 that goes 0..=n, does the use of inclusive range (0..=n) correctly handle n=0 case, or does it perform one extra iteration that could return wrong token? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: lookahead_nth()] [Offset Tracking] Does current_offset properly track position through multiple iterations in lookahead_nth(), or can accumulated errors in offset + length calculations lead to looking ahead to wrong positions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: match_doc_comments()] [Range Query] The range query at lines 408-409 uses (start, start)..(end, end) on doc_comments BTreeMap. Can edge cases where start == end cause empty ranges that skip valid documentation comments? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: match_doc_comments()] [Comment Removal Race] When removing matched comments from doc_comments map (lines 416-418), can concurrent match_doc_comments() calls from multiple parser threads lead to race conditions where comments are double-matched or lost? (High)"
]