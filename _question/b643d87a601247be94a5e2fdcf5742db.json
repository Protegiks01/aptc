[
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_closure_mask()] [ClosureMask bit manipulation] Can individual bits in ClosureMask be manipulated to capture unintended combinations of parameters? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Field visibility bypass] Does check_field_op() validate field visibility (private/public), or can private fields be accessed from outside their module? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Field offset calculation] Can field indices cause incorrect offset calculations during access, allowing reading/writing adjacent fields? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [Variant field initialization] Can variant fields be accessed before the variant is properly initialized, reading uninitialized memory? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [Cross-variant field access] Can field indices from one variant be used to access fields in a different variant of the same enum? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Pack field count mismatch] Can Pack instructions provide fewer or more values than the struct definition requires, causing padding or overflow? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Unpack field ordering] Does Unpack guarantee fields are unpacked in the correct order, or can field confusion occur? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [PackGeneric instantiation mismatch] Can PackGeneric be called with type arguments that don't match the struct's generic parameter constraints? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [UnpackGeneric type erasure] Can UnpackGeneric operations lose type information, allowing unpacked values to be used with incorrect types? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [PackVariant discriminant manipulation] Can PackVariant instructions manipulate the discriminant tag to create invalid variant states? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [UnpackVariant wrong variant] Can UnpackVariant be called on a variant different from what's actually stored, causing type confusion? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [TestVariant timing attack] Can TestVariant be used in timing attacks to infer private information about which variant is active? (Low)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [PackVariantGeneric constraint bypass] Can generic variant packing bypass ability constraints (copy, drop, store, key) through type parameter manipulation? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Call reentrancy] Can Call instructions create reentrancy vulnerabilities by calling back into the current function before it completes? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [CallGeneric monomorphization bomb] Can CallGeneric with complex type parameters cause exponential code expansion during monomorphization? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [CallClosure type safety] Although CallClosure is not validated here, can it be paired with improperly validated PackClosure to violate type safety? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Instruction ordering dependency] Can the order of instructions in bytecode be manipulated to bypass checks that depend on program state? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: verify_module_impl()] [Multiple verification passes] If verification runs multiple times on the same module, can state persist between passes causing inconsistent results? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Phantom type parameters] Can phantom type parameters in structs bypass the type_parameters.is_empty() check while still requiring generic opcodes? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_function_op()] [Function visibility bypass] Does check_function_op() validate that public/private function visibility rules are respected across module boundaries? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Bytecode version compatibility] Can newer bytecode instructions be injected that pass through the wildcard match but aren't properly supported by the VM? (High)",
  "[File: third_party/move/move-bytecode-verifier\n\n### Citations\n\n**File:** third_party/move/move-bytecode-verifier/src/instruction_consistency.rs (L1-259)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module defines the transfer functions for verifying consistency of each bytecode\n//! instruction, in particular, for the bytecode instructions that come in both generic and\n//! non-generic flavors. It also checks constraints on instructions like VecPack/VecUnpack.\n\nuse move_binary_format::{\n    access::ModuleAccess,\n    binary_views::BinaryIndexedView,\n    errors::{Location, PartialVMError, PartialVMResult, VMResult},\n    file_format::{\n        Bytecode, CodeOffset, CodeUnit, CompiledModule, CompiledScript, FieldHandleIndex,\n        FunctionDefinitionIndex, FunctionHandleIndex, StructDefinitionIndex,\n        StructVariantHandleIndex, TableIndex, VariantFieldHandleIndex,\n    },\n};\nuse move_core_types::{function::ClosureMask, vm_status::StatusCode};\n\npub struct InstructionConsistency<'a> {\n    resolver: BinaryIndexedView<'a>,\n    current_function: Option<FunctionDefinitionIndex>,\n}\n\nimpl<'a> InstructionConsistency<'a> {\n    pub fn verify_module(module: &'a CompiledModule) -> VMResult<()> {\n        Self::verify_module_impl(module).map_err(|e| e.finish(Location::Module(module.self_id())))\n    }\n\n    fn verify_module_impl(module: &'a CompiledModule) -> PartialVMResult<()> {\n        let resolver = BinaryIndexedView::Module(module);\n\n        for (idx, func_def) in module.function_defs().iter().enumerate() {\n            match &func_def.code {\n                None => (),\n                Some(code) => {\n                    let checker = Self {\n                        resolver,\n                        current_function: Some(FunctionDefinitionIndex(idx as TableIndex)),\n                    };\n                    checker.check_instructions(code)?\n                },\n            }\n        }\n        Ok(())\n    }\n\n    pub fn verify_script(module: &'a CompiledScript) -> VMResult<()> {\n        Self::verify_script_impl(module).map_err(|e| e.finish(Location::Script))\n    }\n\n    pub fn verify_script_impl(script: &'a CompiledScript) -> PartialVMResult<()> {\n        let checker = Self {\n            resolver: BinaryIndexedView::Script(script),\n            current_function: None,\n        };\n        checker.check_instructions(&script.code)\n    }\n\n    fn check_instructions(&self, code: &CodeUnit) -> PartialVMResult<()> {\n        for (offset, instr) in code.code.iter().enumerate() {\n            use Bytecode::*;\n\n            match instr {\n                MutBorrowField(field_handle_index) | ImmBorrowField(field_handle_index) => {\n                    self.check_field_op(offset, *field_handle_index, /* generic */ false)?;\n                },\n                MutBorrowFieldGeneric(field_inst_index)\n                | ImmBorrowFieldGeneric(field_inst_index) => {\n                    let field_inst = self.resolver.field_instantiation_at(*field_inst_index)?;\n                    self.check_field_op(offset, field_inst.handle, /* generic */ true)?;\n                },\n                MutBorrowVariantField(field_handle_index)\n                | ImmBorrowVariantField(field_handle_index) => {\n                    self.check_variant_field_op(\n                        offset,\n                        *field_handle_index,\n                        /* generic */ false,\n                    )?;\n                },\n                MutBorrowVariantFieldGeneric(field_inst_index)\n                | ImmBorrowVariantFieldGeneric(field_inst_index) => {\n                    let field_inst = self\n                        .resolver\n                        .variant_field_instantiation_at(*field_inst_index)?;\n                    self.check_variant_field_op(\n                        offset,\n                        field_inst.handle,\n                        /* generic */ true,\n                    )?;\n                },\n                Call(idx) => {\n                    self.check_function_op(offset, *idx, /* generic */ false)?;\n                },\n                CallGeneric(idx) => {\n                    let func_inst = self.resolver.function_instantiation_at(*idx);\n                    self.check_function_op(offset, func_inst.handle, /* generic */ true)?;\n                },\n                PackClosure(idx, mask) => {\n                    self.check_function_op(offset, *idx, /* generic */ false)?;\n                    self.check_closure_mask(offset, *idx, *mask)?\n                },\n                PackClosureGeneric(idx, mask) => {\n                    let func_inst = self.resolver.function_instantiation_at(*idx);\n                    self.check_function_op(offset, func_inst.handle, /* generic */ true)?;\n                    self.check_closure_mask(offset, func_inst.handle, *mask)?\n                },\n                Pack(idx) | Unpack(idx) => {\n                    self.check_struct_op(offset, *idx, /* generic */ false)?;\n                },\n                PackGeneric(idx) | UnpackGeneric(idx) => {\n                    let struct_inst = self.resolver.struct_instantiation_at(*idx)?;\n                    self.check_struct_op(offset, struct_inst.def, /* generic */ true)?;\n                },\n                PackVariant(idx) | UnpackVariant(idx) | TestVariant(idx) => {\n                    self.check_variant_op(offset, *idx, /* generic */ false)?;\n                },\n                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {\n                    let struct_inst = self.resolver.struct_variant_instantiation_at(*idx)?;\n                    self.check_variant_op(offset, struct_inst.handle, /* generic */ true)?;\n                },\n                MutBorrowGlobal(idx) | ImmBorrowGlobal(idx) => {\n                    self.check_struct_op(offset, *idx, /* generic */ false)?;\n                },\n                MutBorrowGlobalGeneric(idx) | ImmBorrowGlobalGeneric(idx) => {\n                    let struct_inst = self.resolver.struct_instantiation_at(*idx)?;\n                    self.check_struct_op(offset, struct_inst.def, /* generic */ true)?;\n                },\n                Exists(idx) | MoveFrom(idx) | MoveTo(idx) => {\n                    self.check_struct_op(offset, *idx, /* generic */ false)?;\n                },\n                ExistsGeneric(idx) | MoveFromGeneric(idx) | MoveToGeneric(idx) => {\n                    let struct_inst = self.resolver.struct_instantiation_at(*idx)?;\n                    self.check_struct_op(offset, struct_inst.def, /* generic */ true)?;\n                },\n                VecPack(_, num) | VecUnpack(_, num) => {\n                    if *num > u16::MAX as u64 {\n                        return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)\n                            .at_code_offset(self.current_function(), offset as CodeOffset)\n                            .with_message("
]