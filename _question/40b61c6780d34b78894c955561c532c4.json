[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Enum: Severity] [Integer representation vulnerability] The Severity enum uses integer values (Warning=0, NonblockingError=1, BlockingError=2, Bug=3). Can an attacker exploit comparison logic that relies on these numeric values to downgrade error severity, causing critical type safety violations to be treated as warnings? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Enum: Severity] [Ordering invariant violation] Does the PartialOrd/Ord implementation for Severity guarantee that Bug > BlockingError > NonblockingError > Warning? Could incorrect ordering allow the compiler to proceed with compilation despite ICE (Internal Compiler Error) conditions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Enum: Severity] [Default severity bypass] The Default trait implementation returns Severity::MIN (Warning). Can this default be exploited in uninitialized or missing severity contexts to allow dangerous code patterns to compile with only warnings instead of blocking errors? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Enum: Severity::into_codespan_severity()] [Severity downgrade] The mapping treats both BlockingError and NonblockingError as CSRSeverity::Error. Does this loss of granularity allow compilation to continue when it should be blocked, potentially allowing unsafe Move code to be deployed? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Struct: DiagnosticInfo] [Code collision vulnerability] The diagnostic code is stored as a u8, allowing only 256 unique codes per category. Can code collisions occur when new error types are added, causing critical type safety errors to be misidentified as lower-severity issues? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Function: DiagnosticInfo::render()] [Format string injection] The render() function constructs error codes using format!() with user-controlled category and code values. Can specially crafted error scenarios inject malicious format strings into diagnostic output that could exploit log parsers or monitoring systems? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Function: DiagnosticInfo::render()] [Integer overflow] The debug_assert!(cat_prefix <= 99) checks category bounds, but this only fires in debug builds. In release builds, can category values >= 100 cause integer overflow in format string generation, producing incorrect error codes that mask critical issues? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Trait: DiagnosticCode::into_info()] [Severity-code mismatch] The into_info() method calls both severity() and code_and_message() separately. Can race conditions in multithreaded compilation cause these to return inconsistent values, leading to error codes with mismatched severities? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Trait: DiagnosticCode] [Category constant validation] The CATEGORY constant uses a compile-time assertion that category <= 99. However, the assertion message access pattern ['Diagnostic Category must be a u8 <= 99'][!cat_is_leq_99 as usize] will panic out-of-bounds if the category is invalid. Can this cause compiler crashes that prevent security-critical error reporting? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Macro: codes!] [Enum representation vulnerability] The macro generates enums with #[repr(u8)] but starts each enum with DontStartAtZeroPlaceholder to avoid zero values. Can enum transmutation or unsafe casting bypass this protection, creating error codes with value 0 that could be misinterpreted as 'no error'? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Macro: codes! - severity() implementation] [Panic-based DoS] The severity() and code_and_message() functions panic if DontStartAtZeroPlaceholder is used. Can an attacker trigger compilation paths that accidentally invoke this placeholder, causing compiler crashes that prevent security audits of malicious Move code? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Macro: codes! - code_and_message()] [Debug assertion bypass] The debug_assert!(code > 0) in code_and_message() only validates in debug mode. In release builds, can the placeholder (code=0) be reached, returning incorrect error messages that hide the true nature of security vulnerabilities? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Enum: Category] [Category exhaustion] Categories are limited to u8 values <= 99. As the compiler evolves, can the category space become exhausted, forcing new security-critical error types to reuse existing category numbers and causing diagnostic collisions? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Uncategorized] [Severity downgrade bypass] The Uncategorized::DeprecatedWillBeRemoved error has severity Warning. Can deprecated but security-critical language features continue to be used in production Move code because they only generate warnings instead of blocking compilation? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidCharacter] [Encoding bypass] InvalidCharacter is marked as NonblockingError. Can malicious Move code contain invalid UTF-8 or control characters that generate non-blocking errors but still get parsed incorrectly, leading to semantic vulnerabilities in deployed contracts? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::UnexpectedToken] [Error recovery exploitation] UnexpectedToken is NonblockingError, allowing compilation to continue. Can carefully crafted syntax errors trigger incorrect error recovery that causes the compiler to skip security-critical validation checks in subsequent code? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidModifier] [Access control bypass] InvalidModifier is NonblockingError. Can malicious code use invalid visibility modifiers (public, private, friend) that generate non-blocking errors but still affect the compiled bytecode's access control, allowing unauthorized function calls? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidDocComment] [Metadata injection] InvalidDocComment is only a Warning. Can attackers inject malicious metadata or documentation strings that affect ABI generation, verification tools, or on-chain contract interfaces without failing compilation? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidAddress] [Address validation bypass] InvalidAddress is NonblockingError. Can malformed address literals in Move code (0x...) be partially parsed, allowing attacker-controlled address values to be used in resource operations despite generating errors? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidNumber] [Integer literal overflow] InvalidNumber is NonblockingError. Can extremely large numeric literals that overflow u64/u128 generate non-blocking errors but still compile to incorrect constant values, enabling integer overflow exploits in Move contracts? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidByteString] [Bytecode injection] InvalidByteString is NonblockingError. Can malformed byte string literals contain embedded bytecode sequences that survive compilation errors and get included in the compiled Move module, enabling code injection? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidHexString] [Hash collision] InvalidHexString is NonblockingError. Can invalid hex strings in hash literals or cryptographic constants be truncated or padded incorrectly, creating collision-prone hash values in deployed contracts? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidLValue] [Assignment bypass] InvalidLValue is NonblockingError. Can invalid left-hand side expressions in assignments (like assigning to constants or literals) generate errors but still produce bytecode that modifies supposedly immutable values? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::SpecContextRestricted] [Formal verification bypass] SpecContextRestricted is BlockingError. Does this adequately prevent specification language from being used in executable code, or can attackers mix spec and implementation to bypass formal verification checks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidSpecBlockMember] [Specification injection] InvalidSpecBlockMember is NonblockingError. Can invalid spec block members cause the compiler to skip verification of security-critical properties like requires/ensures/invariant conditions? (High)"
]