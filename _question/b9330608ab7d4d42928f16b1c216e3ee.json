[
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: hash] [Hash length DoS] Can attackers submit arbitrarily long vectors to sha2_256/sha3_256 to consume excessive gas, and is there a maximum input length enforced before hashing begins? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: hash] [Digest implementation trust] The code relies on external sha2::Sha256 and sha3::Sha3_256 crates - are these implementations audited and do they have constant-time properties to prevent timing attacks? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: hash] [Hash output consistency] Can different Rust compiler versions or CPU architectures produce different hash outputs for the same input, breaking deterministic execution across validators? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: hash] [Empty input handling] How do native_sha2_256 and native_sha3_256 handle empty input vectors - is the gas charged correctly and does it match Move contract expectations? (Low)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: signer] [Signer extraction bypass] The native_borrow_address function extracts addresses from signers - can malicious code create fake SignerRef values to extract arbitrary addresses and bypass authentication? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: signer] [SignerRef validation] Does native_borrow_address validate that the SignerRef is legitimate before calling borrow_signer(), or can type confusion allow non-signer values to be passed? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: signer] [Address immutability] Can the borrowed address from borrow_signer() be modified or does it properly return an immutable reference that prevents address tampering? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: signer] [Gas charging attack] SIGNER_BORROW_ADDRESS_BASE is a fixed cost - is this sufficient or can rapid repeated calls to borrow_address create a DoS condition despite proper gas charging? (Low)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: signer] [Signer copying] Does the Move VM prevent signers from being copied or stored in global storage, and can native_borrow_address be exploited to violate these invariants? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Feature gate bypass] native_move_range checks is_native_memory_operations_enabled() - can this feature flag be toggled during execution or can outdated nodes process transactions with this native, causing consensus splits? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Index overflow attack] native_move_range uses usize::try_from for u64 to usize conversion - can attackers on 32-bit platforms pass indices > 2^32 that fail conversion, bypassing checks? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Bounds check bypass] The bounds checking in native_move_range uses checked_add and is_none_or - can integer overflow in removal_position + length bypass these checks and cause out-of-bounds access? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Double gas charging] native_move_range fetches vector lengths for gas charging and then VectorRef::move_range repeats the checks - can race conditions between these two checks cause incorrect behavior? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Gas calculation overflow] The gas calculation for move_range sums (from_len - removal_position) + (to_len - insert_position) + length - can this sum overflow and result in under-charged operations? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Aliasing attack] If 'from' and 'to' VectorRef parameters point to the same vector, can native_move_range cause undefined behavior or memory corruption when moving elements within the same vector? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Type parameter bypass] native_move_range passes ty_args[0] to VectorRef::move_range - is type checking performed to ensure both vectors have the same element type, preventing type confusion? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: vector] [Error code confusion] EINDEX_OUT_OF_BOUNDS returns abort code 1 but also error::invalid_argument(EINDEX_OUT_OF_BOUNDS) - can these different error formats cause confusion in error handling? (Low)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [UTF-8 bypass] native_check_utf8 validates UTF-8 but other string natives use from_utf8_unchecked - can attackers bypass validation and inject invalid UTF-8 into strings, causing crashes or exploits? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Unsafe unchecked usage] Multiple functions use std::str::from_utf8_unchecked with the comment 'safe because we guarantee the bytes to be utf8' - is this guarantee enforced at the VM level or can malicious code violate it? (Critical)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Character boundary exploit] native_is_char_boundary uses unchecked UTF-8 conversion - if invalid UTF-8 is present, can this cause undefined behavior or return incorrect boundary information? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Substring bounds attack] native_sub_string checks j < i but does it validate that i and j are valid UTF-8 character boundaries, or can incorrect indices split multi-byte characters causing corruption? (High)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Gas charging bypass] native_sub_string charges gas based on (j - i) bytes - can attackers exploit byte vs character counting to perform under-priced operations on multi-byte Unicode strings? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Index-of performance attack] The TODO comment mentions KMP algorithm - the current find() implementation may be O(n*m) - can attackers exploit this with worst-case inputs to cause DoS despite gas limits? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [Search gas discrepancy] native_index_of charges based on 'pos' (position found) not total bytes searched - can attackers craft searches that examine the entire string but get charged minimal gas? (Medium)",
  "[File: aptos-move/framework/move-stdlib/src/natives/mod.rs] [Module: string] [VectorRef aliasing] String natives take VectorRef parameters - can passing the same VectorRef twice cause aliasing issues or unexpected behavior during string operations? (Medium)"
]