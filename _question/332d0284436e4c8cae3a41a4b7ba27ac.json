[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: iter()] [Access tracking bypass] Does iter() iteration mark keys as accessed in gotten_keys, or does it allow silent enumeration of all symbols without triggering access tracking? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: iter_mut()] [Concurrent modification] Can iter_mut() allow modification of values while iterating, potentially breaking compilation invariants if the iterator state becomes inconsistent with gotten_keys? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Struct: IntoIter] [Size hint consistency] Does IntoIter properly maintain size_hint consistency as it consumes the map, or can incorrect hints cause buffer overruns in code that relies on accurate size information? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Struct: Iter] [Lifetime safety] Can Iter return references with incorrect lifetimes that outlive the RememberingUniqueMap, causing use-after-free vulnerabilities in the compiler? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Struct: IterMut] [Mutation safety] Does IterMut properly prevent mutation of keys or locations while iterating, or can this break BTreeMap ordering invariants causing memory corruption? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: maybe_from_opt_iter()] [Duplicate handling] Does maybe_from_opt_iter() properly detect all duplicate keys and return errors with correct location information, or can subtle duplicates slip through causing compilation bugs? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: maybe_from_opt_iter()] [None handling] Can maybe_from_opt_iter() be exploited with carefully placed None values to bypass duplicate detection or create partially initialized maps? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: maybe_from_opt_iter()] [Initial state correctness] Does maybe_from_opt_iter() initialize gotten_keys as empty, or can it start with a non-empty set causing spurious 'accessed but not used' warnings? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: maybe_from_iter()] [Error propagation] Does maybe_from_iter() correctly propagate all three error tuple components (Key, Loc, Loc) without losing information that's critical for error reporting? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: maybe_from_iter()] [Resource exhaustion] Can maybe_from_iter() be exploited with extremely long iterators that cause memory exhaustion before duplicate detection triggers? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: into_inner()] [Access tracking loss] Does into_inner() consuming the RememberingUniqueMap and discarding gotten_keys allow bypassing unused symbol detection, potentially hiding dead code or malicious symbols? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: remember()] [Information disclosure] Can remember() be exploited to extract which symbols were accessed during compilation, revealing sensitive information about code structure or optimization passes? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Function: is_empty()] [State inconsistency] Can is_empty() return true while gotten_keys is non-empty, or vice versa, indicating a corrupted internal state that breaks compilation assumptions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: PartialEq] [Equality semantics] Does the PartialEq implementation comparing both map and gotten_keys cause two semantically identical maps to be considered unequal if access patterns differ, breaking compiler caching? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: PartialEq] [Non-determinism] Can gotten_keys ordering in BTreeSet affect equality comparisons, potentially causing non-deterministic behavior if BTreeSet comparison has platform-specific behavior? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: Eq] [Reflexivity violation] Does the Eq implementation maintain reflexivity, symmetry, and transitivity under all conditions, or can edge cases break these properties causing undefined behavior in collections? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: Clone] [Deep copy correctness] Does Clone create fully independent copies of both map and gotten_keys, or can interior mutability cause cloned instances to share state leading to spooky action at a distance? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: Clone] [Cost asymmetry] Can Clone be exploited with maps containing expensive-to-clone keys/values to cause compilation slowdowns when the compiler clones symbol tables? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Trait: Debug] [Information leak] Does the Debug implementation expose sensitive compiler internal state that could help attackers understand compilation internals or leak source code structure? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Generic: K: TName + Ord] [Ord consistency] Can malicious implementations of Ord for K violate ordering invariants, breaking BTreeSet correctness and causing gotten_keys to lose or duplicate entries? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Generic: K: TName] [TName implementation] Can custom TName implementations with inconsistent drop_loc/add_loc/borrow methods cause key mismatches between map and gotten_keys? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Generic: K::Key] [Key type confusion] Can different K types with identical K::Key types cause collisions in the underlying BTreeMap, allowing symbol shadowing attacks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Generic: K::Loc] [Location tampering] Can K::Loc being only Copy (not Clone) lead to inconsistencies if locations are modified after insertion, breaking error reporting? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Integration: UniqueMap] [Wrapper bypass] Can code bypass RememberingUniqueMap and access the inner UniqueMap directly through into_inner(), breaking access tracking invariants? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/remembering_unique_map.rs] [Integration: UniqueMap] [Error propagation] When UniqueMap::add() returns an error, does RememberingUniqueMap properly maintain consistency without leaking the attempted key into gotten_keys? (Medium)"
]