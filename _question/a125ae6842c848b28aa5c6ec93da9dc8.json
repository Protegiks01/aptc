[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidAccessSpecifier] [Visibility confusion] InvalidAccessSpecifier is NonblockingError. Can ambiguous or contradictory access specifiers (public(friend), public(script), etc.) compile with errors but still enforce incorrect visibility, enabling unauthorized access? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::UnsupportedLanguageItem] [Feature flag abuse] UnsupportedLanguageItem is BlockingError. Are all security-critical language features that haven't been fully vetted properly marked as unsupported, or can attackers enable experimental features with known vulnerabilities? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Syntax::InvalidVariantAccess] [Enum safety violation] InvalidVariantAccess is BlockingError. Does this catch all cases of accessing non-existent enum variants, or can type confusion allow accessing wrong variant data, bypassing Move's type safety? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::DuplicateItem] [Name collision attack] DuplicateItem is NonblockingError. Can duplicate function or struct names in different scopes compile despite errors, causing name resolution to bind to attacker-controlled definitions instead of legitimate ones? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::UnnecessaryItem] [Dead code exploitation] UnnecessaryItem is NonblockingError. Can 'unnecessary' code actually contain side effects that execute during compilation (const evaluation) but are silently ignored, enabling supply chain attacks? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidAddress] [Address block bypass] InvalidAddress in Declarations is NonblockingError. Can malformed address blocks allow Move modules to be compiled with incorrect address bindings, enabling impersonation of trusted system modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidModule] [Module structure tampering] InvalidModule is NonblockingError. Can malformed module declarations bypass linking checks, allowing attacker modules to masquerade as trusted framework modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidScript] [Script context escape] InvalidScript is NonblockingError. Can invalid script declarations allow code intended for script context to be included in modules, bypassing script-specific security restrictions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidConstant] [Const evaluation exploit] InvalidConstant is NonblockingError. Can invalid constant declarations still undergo partial evaluation that executes attacker-controlled code during compilation, enabling compiler exploits? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidFunction] [Function signature bypass] InvalidFunction is NonblockingError. Can functions with invalid signatures (wrong parameter types, missing returns) still generate callable bytecode, bypassing type safety and enabling type confusion attacks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidStruct] [Resource safety violation] InvalidStruct is NonblockingError. Can structs with invalid field declarations (duplicate fields, missing types) compile to bytecode that violates Move's resource safety guarantees, enabling double-spending? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidSpec] [Verification bypass] InvalidSpec is NonblockingError. Can invalid specification blocks be silently ignored, allowing Move contracts to deploy without their security properties being verified? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidName] [Name injection attack] InvalidName is BlockingError. Does this catch all forms of invalid identifiers including those with homoglyphs, zero-width characters, or Unicode confusables that could enable social engineering? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidFriendDeclaration] [Friend visibility abuse] InvalidFriendDeclaration is NonblockingError. Can invalid friend declarations still grant visibility to attacker modules, allowing unauthorized access to internal functions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidAcquiresItem] [Global state bypass] InvalidAcquiresItem is NonblockingError. Can functions with invalid acquires declarations still access global storage without proper annotations, bypassing Move's borrow checking and enabling reentrancy? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidPhantomUse] [Phantom type exploit] InvalidPhantomUse is NonblockingError. Can phantom type parameters be incorrectly used in struct fields, breaking the ability system and allowing resources to be copied when they should only be moved? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidNonPhantomUse] [Ability constraint bypass] InvalidNonPhantomUse is only a Warning. Can non-phantom type parameters be used in ways that violate ability constraints (copy, drop, store, key), allowing improper resource handling? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::InvalidAttribute] [Attribute injection] InvalidAttribute is NonblockingError. Can invalid attributes (like #[test], #[verify_only]) be partially processed, causing test-only or unverified code to be included in production bytecode? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: Declarations::UnknownAttribute] [Custom attribute exploit] UnknownAttribute is only a Warning (per comment about issue #9411). Can attackers define custom attributes that affect compilation behavior, ABI generation, or runtime checks without triggering errors? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::AddressWithoutValue] [Address binding attack] AddressWithoutValue is NonblockingError. Can named addresses without values be resolved to attacker-controlled addresses at deployment time, enabling module impersonation? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundModule] [Module confusion] UnboundModule is BlockingError. Are all unbound module references caught, or can circular dependencies or lazy loading allow references to non-existent modules that later resolve to attacker code? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundModuleMember] [Member injection] UnboundModuleMember is BlockingError. Can unbound member names be resolved later through dynamic linking, potentially binding to attacker-injected functions with matching signatures? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundType] [Type confusion exploit] UnboundType is BlockingError. Does this catch all cases of unbound generic type parameters, or can attackers exploit type inference to bind types to unexpected concrete types, bypassing ability checks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundUnscopedName] [Scope escape] UnboundUnscopedName is BlockingError. Can unbound names in nested scopes incorrectly resolve to outer scope bindings, allowing access to private variables or functions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::NamePositionMismatch] [Context confusion] NamePositionMismatch is BlockingError. Can type names be used where value names are expected (or vice versa) to create ambiguous expressions that compile incorrectly? (Medium)"
]