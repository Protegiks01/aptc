[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Cryptographic weakness] Can an attacker bypass the MINIMUM_SEED_LENGTH check of 16 bytes by providing exactly 16 bytes of low-entropy data (e.g., all zeros or sequential bytes), allowing weak key derivation that enables brute-force attacks on derived account keys and validator keys? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Entropy bypass] Does the extract() function validate the actual entropy quality of the ikm parameter beyond length, or can an attacker generate predictable keys by using 16+ bytes of predictable data (timestamp, counter values) for master seed generation? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_no_ikm_check()] [Validation bypass] Can internal code paths directly call extract_no_ikm_check() with seeds shorter than 16 bytes, bypassing the safety check in extract() and allowing weak key derivation for validator consensus keys or transaction signing keys? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [Weak entropy] Does extract_then_expand_no_ikm() for Noise protocol accept an empty ikm (zero-length byte array) which could result in deterministic key generation based solely on salt, making derived keys predictable to attackers who know the salt value? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Constant: MINIMUM_SEED_LENGTH] [Insufficient entropy] Is the MINIMUM_SEED_LENGTH constant of 16 bytes (128 bits) sufficient for all use cases in Aptos, or should Ed25519 validator key derivation require the recommended 32 bytes, preventing quantum-resistant key generation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Integer underflow] Can an attacker provide an ikm slice with usize::MAX length causing ikm.len() < MINIMUM_SEED_LENGTH to evaluate incorrectly due to integer overflow in comparison, bypassing seed validation? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Type confusion] Can generic type parameter D be instantiated with a weak hash function (e.g., MD5, SHA1) at compile time despite the IsGreaterOrEqual<DMinimumSize> constraint, allowing cryptographically broken key derivation for validator keys? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Seed reuse] Does the implementation prevent or detect seed reuse across different key derivation contexts, or can the same seed be used multiple times with different salts/info parameters, violating key independence and enabling related-key attacks? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Salt injection] Can an attacker manipulate the optional salt parameter (Some(&[u8])) to inject malicious values that weaken the HMAC-based extraction, such as using attacker-controlled salts to create collision-prone PRK values for validator authentication? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_no_ikm_check()] [Salt validation] Does extract_no_ikm_check() validate the salt length and entropy, or can an attacker provide a zero-length salt (Some(&[])) that degrades HKDF security by removing the salt's source-independent extraction properties? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Salt reuse] Can the same salt value be reused across multiple extract() operations with different seeds, potentially creating linkable keys that allow an attacker to correlate validator identities or user accounts across the blockchain? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand()] [Deterministic salt] If salt is None, does the HKDF fall back to a deterministic default value, making all key derivations without explicit salt values predictable to attackers who reverse-engineer the default salt generation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Salt length attack] Can an attacker provide an excessively long salt (e.g., megabytes) causing memory exhaustion or performance degradation in the underlying HMAC operation, leading to validator node crashes during key generation? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Domain separation bypass] Can an attacker exploit missing or weak 'info' parameter validation to derive keys from the same PRK for different purposes (e.g., using a network key PRK to derive transaction signing keys), breaking domain separation and enabling key misuse attacks? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Info collision] Can two different applications or key types use the same info parameter value, causing collision in derived keys where a validator consensus key accidentally matches a user account key, enabling unauthorized consensus participation? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Info manipulation] Does expand() allow empty info parameter (Some(&[]) or None) which removes application-specific binding, making derived keys generic and potentially reusable across different protocol contexts? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand()] [Info injection] Can an attacker inject malicious data into the info parameter (e.g., protocol numbers, key identifiers) to manipulate the derived key material in a way that produces weak keys or collisions with existing keys in the system? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Info length attack] Can providing an excessively long info parameter (e.g., gigabytes of data) cause the underlying hkdf::Hkdf::expand() to consume excessive memory or CPU, leading to DoS on validator nodes during key derivation operations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Output length bypass] Can an attacker request a zero-length output (length = 0) that passes validation but returns an empty okm vector, causing downstream key usage to fail silently or use uninitialized memory as cryptographic keys? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Maximum output violation] Does the check for length > D::OutputSize::to_usize() * 255 properly prevent output lengths exceeding RFC 5869 limits, or can integer overflow in the multiplication cause the check to pass for extremely large length values, leading to memory exhaustion? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Integer overflow in length] Can an attacker provide length = usize::MAX causing vec![0u8; length] allocation to panic or wrap around, leading to validator node crashes during key derivation or using truncated key material? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Inconsistent length] If the underlying hkdf.expand() fails but the error is not properly propagated, can partially filled okm vectors be returned containing uninitialized memory that gets used as cryptographic key material? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand()] [Length parameter manipulation] Can concurrent calls to extract_then_expand() with different length parameters for the same seed/salt/info combination create timing side-channels that leak information about the PRK or derived keys? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Weak PRK] Does Hkdf::from_prk() properly validate that the prk parameter meets minimum entropy requirements, or can an attacker provide a weak PRK (e.g., all zeros, predictable values) that generates predictable derived keys for validator authentication? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [PRK length bypass] Can an attacker provide a PRK shorter than the hash output length that still passes validation through hkdf::Hkdf::from_prk(), resulting in weak key expansion that makes derived validator keys vulnerable to brute-force attacks? (Critical)"
]