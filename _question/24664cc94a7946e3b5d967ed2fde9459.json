[
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_lazily_verified_module() impl] [Version conflict] insert_verified_module() (lines 322-327) uses a version parameter - if two transactions insert different versions of the same module concurrently, which version wins? Can this lead to non-deterministic execution across validators? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Cycle detection bypass] The visited HashSet (line 349) is meant to detect cycles - but if an attacker crafts modules A->B->C->A where each validates individually, can the cycle check fail if modules are verified out of order across concurrent transactions? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Recursive stack overflow] The function is recursive (lines 401-407 call itself) - can an attacker deploy a chain of modules with max-depth dependencies (e.g., 1000+ levels) to cause stack overflow and crash validator nodes? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Verification order manipulation] Dependencies are verified in iteration order (line 386) - can an attacker control dependency order through module structure to exploit race conditions in concurrent verification? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Paranoid check bypass] paranoid_check_module_address_and_name() (lines 372-376) validates module metadata - but is this check also performed on dependencies? Can an attacker inject a malicious dependency with mismatched address/name? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Build locally verified race] build_locally_verified_module() (lines 377-381) creates locally verified code - if this operation is not atomic with cache insertion, can concurrent transactions verify the same module multiple times, wasting resources? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Dependency resolution TOCTOU] Between resolving a dependency (lines 389-391) and verifying it (lines 401-407), can the dependency be replaced on-chain, causing validators to verify different dependency versions and produce non-deterministic state? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Cached verification trust] If dependency.code().is_verified() returns true (line 394), it's trusted immediately - can a prior transaction have poisoned the cache with a 'verified' module that's actually malicious? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Cycle detection false positive] The visited.insert() check (line 399) prevents revisiting - but in a valid DAG with multiple paths to the same node (A->B->D, A->C->D), could this incorrectly flag D as a cycle? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Cyclic dependency error timing] module_cyclic_dependency_error! (lines 411-414) is returned on cycle detection - but before this error, how many dependencies were already verified and cached? Can partial verification state corruption occur? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Linking verification bypass] build_verified_module_with_linking_checks() (lines 418-419) performs linking - but if this fails after dependencies are verified, are verified dependencies rolled back from cache? Can failed verifications leave cache in inconsistent state? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Insert verification race] insert_verified_module() (lines 420-425) inserts the verified module - if concurrent transactions both verify the same module, do both insertions succeed? Which version is kept? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Dependency vector exhaustion] verified_dependencies vec (line 385) collects all deps - for modules with thousands of dependencies, can this vector grow so large it exhausts memory before OOM protections trigger? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Immediate dependencies iterator] immediate_dependencies_iter() (line 386) walks dependencies - if the deserialized module is maliciously crafted to report incorrect dependencies, can this cause verification of wrong modules? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Extension clone cost] module.extension().clone() (line 423) clones extension data - if extensions contain large data structures, can repeated cloning during recursive verification cause memory spikes? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_skip_verification()] [Production leak] This entire function (lines 432-511) is #[cfg(fuzzing)] - but what if fuzzing features leak into production through conditional compilation errors? Would all verification be skipped? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_skip_verification()] [Unverified module creation] Module::new() (lines 493-501) creates unverified modules - if this fuzzing path is ever reachable in production, can attackers deploy completely unverified bytecode bypassing all security checks? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_skip_verification()] [Fuzzing cycle detection] The cycle detection logic (lines 473-489) in fuzzing mode is identical to verified mode - so cycles would still be caught, but can this give false security confidence while verification is actually skipped? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_skip_verification()] [Location::Undefined error] Errors are finished with Location::Undefined (line 501) - does this hide critical error context needed for debugging malicious modules discovered during fuzzing? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_skip_verification()] [Insert unverified modules] insert_verified_module() is called (lines 503-508) even though the module isn't actually verified - does the cache distinguish between truly verified and fuzzing-skipped modules? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Struct: FunctionValueExtensionAdapter] [Lifetime issues] The adapter (line 515) holds a reference to module_storage with lifetime 'a - can lifetime issues cause use-after-free if module_storage is dropped while adapter is still in use? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: create_from_serialization_data()] [Deserialization bomb] LazyLoadedFunction::new_unresolved() (line 537) creates functions from serialized data - can an attacker provide crafted SerializedFunctionData with malicious module_id/fun_id that doesn't exist, causing errors during lazy resolution? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: get_serialization_data()] [State borrow panic] state.borrow() (line 544) borrows function state - if function is being modified concurrently, can this panic and crash the validator? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: get_serialization_data()] [Unresolved data leak] When state is Unresolved (line 545), raw data is returned - can this leak sensitive information about function closures before they're resolved and validated? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: get_serialization_data()] [Captured layouts validation] Captured layouts must exist for storable closures (lines 556-560) - but what if captured_layouts is None due to a bug? Can this cause VALUE_SERIALIZATION_ERROR that's improperly handled? (Medium)"
]