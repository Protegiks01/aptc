[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [Version source confusion] At line 130, resolver.version() is checked but the resolver is created from script/module - if resolver caching or version detection is buggy, can resolver.version() return different value than script.version, causing wrong validation path? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Unbounded parameters] There's no explicit limit on parameters.len() - can an attacker craft signatures with millions of parameters causing excessive memory allocation during skip_while iteration, leading to OOM during verification? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature_by_name()] [Name ambiguity] At line 82, find() returns the first matching function name - can a module have multiple functions with the same name (through bytecode manipulation), causing verification of the first while execution uses the second? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Short-circuit bypass] At line 174, the condition is !all_args_have_valid_type || !has_valid_return_type - if all_args_have_valid_type evaluates to false early, does this skip important side effects in return type validation? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script()] [Resolver lifetime] BinaryIndexedView::Script(&script) takes a reference at line 44 - if the script is moved or deallocated before verification completes, can this cause use-after-free bugs in resolver.signature_at() calls? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [Module reference safety] BinaryIndexedView::Module(module) at line 106 - if module is modified by another thread during verification, can resolver access corrupted memory leading to crashes or security bypasses? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [Function pointer calling] At line 135, check_signature is called with 4 parameters - if the function pointer was incorrectly cast or points to a function with different signature, can this cause stack corruption or arbitrary code execution? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script()] [Error chain] At line 48, map_err converts PartialVMError to VMResult with Location::Script - if upstream code checks only error type and not location, can location spoofing allow malicious scripts to appear as valid modules? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [Error annotation] At line 118, e.at_index() adds index annotation - if this annotation overwrites critical error information, can it hide the root cause of validation failures leading to wrong security decisions? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Box dereference] At line 165, &**inner dereferences a boxed SignatureToken - can a corrupted box pointer cause segmentation fault, or can box reuse lead to type confusion if the same box is shared across signatures? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [skip_while side effects] At lines 165 and 170, skip_while is called on parameters.iter() - if skip_while is called twice or the iterator is cloned incorrectly, can this lead to double-validation or validation skipping? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [TableIndex bounds] FunctionDefinitionIndex(idx as TableIndex) at line 68 and 92 - if TableIndex is u16 and idx exceeds u16::MAX, truncation occurs - can this cause verification of function 0 when attacker intended function 65536? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Single error status] Only INVALID_MAIN_FUNCTION_SIGNATURE is returned for both invalid args and invalid return - can an attacker craft bytecode where error diagnosis is impossible, hiding whether attack targets parameters or returns? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [Check order dependency] At line 133, legacy checks run before custom checks - if custom checks assume legacy validation already passed and use unsafe operations, can the legacy check returning early cause custom checks to operate on invalid data? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [Handle vs definition] At line 107, fhandle is retrieved from fdef.function but parameters come from fhandle - can fhandle and fdef be inconsistent if bytecode is malformed, causing verification of wrong signature? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script()] [VERSION_5 early return] At line 41, VERSION_5+ scripts return Ok(()) immediately - can an attacker bypass all Aptos-specific entry point checks by simply setting version=5, allowing arbitrary entry point logic that violates platform security assumptions? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [VERSION_5 requirement] At line 56, only VERSION_5+ modules are checked - can an attacker deploy legacy modules with malicious entry functions that are never validated, then invoke them through module calls? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Struct with Signer field] If a SignatureToken::Struct contains Signer as a field type, does is_valid_for_constant() reject it, or can Signer be smuggled inside struct definitions that pass validation? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Function type injection] Can SignatureToken::Function types appear in parameters, and if so, does is_valid_for_constant() properly reject them to prevent function pointer injection attacks? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Future SignatureToken variants] If new SignatureToken variants are added to the enum (e.g., for language features), will they automatically be rejected by is_valid_for_constant(), or can they bypass validation if that method isn't updated? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature_by_name()] [Self-ID mismatch] If module.self_id() at line 88 returns a different module identity than the actual deployment address, can error messages mislead developers about which module failed, potentially causing them to trust malicious code? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [AND condition bypass] At line 130, deprecated_logic requires BOTH version < VERSION_5 AND is_entry==true - can an attacker set is_entry=false on old version scripts to bypass legacy checks while still having those scripts executed through indirect calls? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Empty parameters] If parameters is an empty vector, skip_while returns empty iterator and all() returns true - does this correctly validate scripts with no parameters, or can zero-parameter scripts bypass validation? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Empty returns] At line 173, return_types.is_empty() must be true - but if return_idx is Some but points to empty signature, does this correctly pass validation or is there an edge case? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [Cache poisoning] If verification results are cached based on module hash, can an attacker craft two modules with same hash but different function signatures, causing cached verification of valid module to be reused for malicious module? (Critical)"
]