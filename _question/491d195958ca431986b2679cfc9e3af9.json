[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Semantic difference] Does FuturesUnorderedX maintain the same poll semantics as FuturesUnordered, or could differences in queued_outputs buffering cause unexpected behavior for backup code expecting standard FuturesUnordered? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Performance regression] Could the additional queued_outputs buffering layer add latency compared to direct FuturesUnordered polling, causing backup operations to miss time windows? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Behavioral difference] Does len() return different values than FuturesUnordered::len() would, potentially breaking backup code that assumes standard FuturesUnordered behavior? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Trait: FusedStream] [Contract difference] Does FusedStream implementation differ from FuturesUnordered's FusedStream, causing issues for code using select! or other FusedStream-aware combinators? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [API compatibility] Could differences in push() behavior (queuing vs immediate execution) cause backup code ported from FuturesUnordered to behave unexpectedly? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Configuration error] If backup code sets max_in_progress too low (e.g., 1) for a high-throughput backup, could this create a bottleneck causing backup operations to miss their scheduled windows? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Resource allocation] If max_in_progress is set too high (e.g., 10000), could this allow too many concurrent network/disk operations, exhausting file descriptors or network sockets? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Dynamic adjustment] Is max_in_progress immutable after construction, preventing dynamic adjustment based on backup system load, potentially causing inefficient resource usage? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Capacity planning] Does the code provide guidance on choosing max_in_progress values for different backup scenarios (local disk vs cloud storage), or could misconfiguration cause failures? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Validation] Should new() enforce upper bounds on max_in_progress (e.g., max 10000) to prevent absurd configurations that cause resource exhaustion? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Backup atomicity] If backup operations use FuturesUnorderedX to stream chunks and the process crashes mid-stream, can partially completed backups corrupt the backup store? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Checkpoint consistency] If backup checkpointing relies on drained queued_outputs representing committed chunks, could poll_next() returning outputs before actual commitment cause inconsistent checkpoints? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Backup ordering] If backup chunks must be written in a specific order for restore correctness, does FuturesUnorderedX's unordered output violate this requirement, causing restore failures? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Progress tracking] If backup CLI uses len() to display progress bars, could incorrect len() values cause user confusion or premature backup cancellation? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: is_empty()] [Backup completion detection] If backup code uses is_empty() to detect backup completion, could bugs in is_empty() cause backups to be marked complete while chunks remain unprocessed? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Error handling] If a future in in_progress completes with an error result (e.g., Fut::Output = Result<T, E>), does poll_next() propagate this error correctly, or could errors be silently dropped? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Retry logic] If backup chunks fail and need retry, can failed futures be re-pushed to FuturesUnorderedX, or does the design prevent retry mechanisms from working correctly? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Partial failure] If some futures in in_progress complete successfully while others fail, does queued_outputs mix successful and failed results in a way that makes it hard to identify failures? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Batch error handling] If extend() is used to add a batch of futures and some fail immediately, does the failure affect remaining queued futures or are they processed independently? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Error recovery] If poll_next() encounters a panic in underlying FuturesUnordered, is there graceful recovery or does the entire backup operation fail catastrophically? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Memory ordering] Does using Ordering::Relaxed for n_running.fetch_add() risk missing concurrency violations due to weak ordering guarantees in the test? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Memory ordering] Could the mix of Ordering::Relaxed loads and Ordering::SeqCst fetch_sub create race conditions where seen_max_concurrency is set incorrectly? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Atomic operation] Is fetch_sub with SeqCst ordering necessary, or could weaker ordering be used without affecting test correctness (and potentially hiding bugs)? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Concurrency detection] Does the test's concurrent modification of atomics properly detect violations where more than max_in_progress futures run simultaneously? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Test: test_run] [Race window] Is there a race window between n_running.load() and seen_max_concurrency.store() where the actual max concurrency could be missed by the test? (Low)"
]