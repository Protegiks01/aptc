[
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: struct_borrow_nested()] [Memory aliasing] Can the same memory be referenced through multiple nested paths? Can attackers exploit aliasing to create two mutable references to the same value, violating memory safety? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: global_value_non_struct()] [Type enforcement] GlobalValue::cached() rejects non-struct values (lines 138-139), but does this check occur at all entry points? Can attackers use native functions to bypass this and store primitives in global storage? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: global_value_non_struct()] [Reference wrapping] The test rejects a reference to u8 (line 144), but what about references to structs containing primitives? Can attackers wrap primitives in structs to bypass the non-struct check? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: global_value_non_struct()] [Storage corruption] If a non-struct value somehow enters global storage, does deserialization properly fail or could it corrupt the global state tree, requiring emergency chain halt? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vm_value_vector_u64_casting()] [Type safety] Can vector_u64() accept values outside u64 range? If an attacker provides u128 or u256 values, does casting truncate or overflow, leading to incorrect balance calculations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vm_value_vector_u64_casting()] [Vector bounds] Does value_as::<Vec<u64>>() verify vector length limits? Can attackers create vectors with billions of elements causing memory exhaustion during unwrap? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vm_value_vector_u64_casting()] [Precision loss] When casting between vector types (e.g., Vec<u128> to Vec<u64>), can precision loss occur silently, causing incorrect token amounts in financial operations? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Type confusion] The test shows swap_values() succeeds between incompatible types in some cases (lines 221-227) - can attackers exploit this to swap a u64 with an address, bypassing type safety and causing memory corruption? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Resource double-spend] When swapping vector references containing resources (lines 194-201), does swap_values() properly track resource ownership? Can attackers duplicate resources through swap to double-spend tokens? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Reference invalidation] After swapping values between two locals (line 210), do all existing references to those locals remain valid? Can attackers exploit stale references to access swapped-out values? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Concurrent swap] Since values use Rc<RefCell<>>, what happens if two threads attempt to swap the same values concurrently? Can this cause RefCell panic or data races leading to validator crashes? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Signer confusion] The test swaps master_signer values (lines 178-179) - if an attacker can swap signers between transactions, can they impersonate other accounts and steal funds? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [DelayedFieldID swap] Swapping DelayedFieldID values (lines 184-193) - does swap_values() properly update external delayed field tracking? Can attackers create orphaned delayed fields or double-reference the same field? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Container ref type checking] Lines 220-230 show that ContainerRef swaps are not fully type-checked - can attackers swap containers of incompatible inner types to bypass Move's type system? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Address swap vulnerability] When swapping addresses (lines 162-163, 166-167), can an attacker swap AccountAddress::ZERO with their own address to bypass authentication checks in system transactions? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Vector element corruption] For vectors of DelayedFieldID (lines 184-193), if swap partially succeeds then fails, can the vector be left in an inconsistent state causing subsequent operations to fail? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_mem_swap()] [Gas metering bypass] Does swap_values() properly charge gas for complex swaps (nested structs, large vectors)? Can attackers perform expensive swaps under the gas cost of primitive swaps? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [Type restriction bypass] vector_unchecked() rejects primitive types (lines 239-254) but accepts complex types - can attackers use this to create vectors that violate Move's type system invariants? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [Unsafe construction] The name 'unchecked' suggests reduced validation - what checks are skipped? Can attackers create malformed vectors that crash the VM during element access? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [Nested vector limits] vector_unchecked() accepts nested vectors (lines 259-260) - is there a depth limit? Can attackers create infinitely nested vectors causing stack overflow during traversal? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [DelayedFieldID in vectors] Creating vectors of DelayedFieldID (line 256-258) - does this properly track external references? Can attackers create vectors of delayed fields then drop them, causing use-after-free in delayed field storage? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [Struct packing in vectors] Vectors of structs (lines 261-263) - if the struct contains a resource, does vector_unchecked() properly enforce resource semantics? Can this bypass resource uniqueness guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_vector_unchecked()] [Type erasure] Since vector_unchecked() accepts generic types, can attackers exploit type erasure to store values of mixed types in a single vector, causing type confusion on access? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_locals_indexed_ref()] [Reference type mismatch] The test distinguishes IndexedRef vs ContainerRef (lines 381-384) - can attackers exploit differences in their implementation to bypass reference safety checks? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/values/value_tests.rs] [Function: test_locals_indexed_ref()] [Primitive reference handling] IndexedRef is used for primitives - does it properly prevent multiple mutable borrows? Can attackers create aliased mutable references to the same primitive value? (Critical)"
]