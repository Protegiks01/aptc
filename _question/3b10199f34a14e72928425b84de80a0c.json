[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Memory safety] [Arc reference cycles] The Arc<ConnectionManager> shared between services - can circular references cause memory leaks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Memory safety] [Channel buffer overflow] When creating channels with user-provided size (line 142), can integer overflow cause smaller-than-expected allocations? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Async safety] [Task cancellation safety] If the async task executing get_transactions() is cancelled during await points, are resources properly cleaned up? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Async safety] [Future polling] Can the ResponseStream be polled multiple times after completion, causing undefined behavior? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Async safety] [Executor saturation] Can many concurrent get_transactions() calls saturate the async executor's thread pool causing service degradation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs] [Live service] [Min servable version] The min_servable_version fetched at line 173 - can this be manipulated to cause clients to request unavailable\n\n### Citations\n\n**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/service.rs (L1-200)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{config::LIVE_DATA_SERVICE, connection_manager::ConnectionManager};\nuse anyhow::Result;\nuse aptos_indexer_grpc_utils::timestamp_now_proto;\nuse aptos_protos::indexer::v1::{\n    data_service_server::DataService, ping_data_service_response::Info, raw_data_server::RawData,\n    GetTransactionsRequest, HistoricalDataServiceInfo, LiveDataServiceInfo, PingDataServiceRequest,\n    PingDataServiceResponse, StreamInfo, TransactionsResponse,\n};\nuse futures::{Stream, StreamExt};\nuse std::{pin::Pin, sync::Arc};\nuse tokio::sync::mpsc::{channel, Sender};\nuse tokio_stream::wrappers::ReceiverStream;\nuse tonic::{Request, Response, Status};\n\ntype ResponseStream = Pin<Box<dyn Stream<Item = Result<TransactionsResponse, Status>> + Send>>;\n\n// Note: We still allow starting both services together, so people don't have to rely on\n// GrpcManager for routing, and it's also make it easier to run in testing environment.\npub struct DataServiceWrapperWrapper {\n    live_data_service: Option<DataServiceWrapper>,\n    historical_data_service: Option<DataServiceWrapper>,\n}\n\nimpl DataServiceWrapperWrapper {\n    pub fn new(\n        live_data_service: Option<DataServiceWrapper>,\n        historical_data_service: Option<DataServiceWrapper>,\n    ) -> Self {\n        Self {\n            live_data_service,\n            historical_data_service,\n        }\n    }\n}\n\n#[tonic::async_trait]\nimpl DataService for DataServiceWrapperWrapper {\n    type GetTransactionsStream = ResponseStream;\n\n    async fn get_transactions(\n        &self,\n        req: Request<GetTransactionsRequest>,\n    ) -> Result<Response<Self::GetTransactionsStream>, Status> {\n        if let Some(live_data_service) = self.live_data_service.as_ref() {\n            if let Some(historical_data_service) = self.historical_data_service.as_ref() {\n                let request = req.into_inner();\n                let mut stream = live_data_service\n                    .get_transactions(Request::new(request.clone()))\n                    .await?\n                    .into_inner();\n                let peekable = std::pin::pin!(stream.as_mut().peekable());\n                if let Some(Ok(_)) = peekable.peek().await {\n                    return live_data_service\n                        .get_transactions(Request::new(request.clone()))\n                        .await;\n                }\n\n                historical_data_service\n                    .get_transactions(Request::new(request))\n                    .await\n            } else {\n                live_data_service.get_transactions(req).await\n            }\n        } else if let Some(historical_data_service) = self.historical_data_service.as_ref() {\n            historical_data_service.get_transactions(req).await\n        } else {\n            unreachable!("
]