[
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Vec reallocation] The callers_chain Vec is mutated with push/pop (lines 145, 150) - can repeated reallocation cause performance degradation or memory issues with deeply recursive code? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: report_error()] [Label collection ordering] Labels are collected via collect_vec() (line 194) - does the order matter for correct error reporting, and can attackers exploit ordering to make errors misleading? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_contains_ty_parameter()] [Option chain short-circuit] Using or_else() for function types (line 241) short-circuits on first Some - can this cause type parameters in result types to be ignored if args contain parameters? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Node location accuracy] The get_node_loc call (line 144) retrieves caller location - if location information is incorrect or stale, can this cause wrong code to be flagged or right code to be missed? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: gen_init_callers_chain()] [Function location validity] Does get_loc() (line 60) always return valid location data, or can missing source information cause the checker to skip functions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: report_error()] [Location display injection] The display_file_name_and_line call (line 191) formats locations - can malicious file names or line numbers cause injection attacks in error messages? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: get_inst()] [Node instantiation caching] Is get_node_instantiation (line 159) deterministic and cached, or can repeated calls return different results causing inconsistent checking? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Instantiation composition] When composing instantiations through multiple call levels, can accumulation errors cause types to be incorrectly instantiated, hiding cycles? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Instantiation vector length] Does Type::instantiate_vec (line 146) validate that the instantiation vector length matches the expected number of type parameters, or can length mismatches cause out-of-bounds access? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [QualifiedId comparison] The to_qualified_id() comparisons (lines 102, 105) strip instantiation info - is this correct, or can it cause distinct functions to appear identical? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: gen_init_callers_chain()] [Module ID consistency] Does mod_env.get_id() (line 59) return consistent IDs across checker invocations, or can ID instability cause cycles to be missed? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: def_not_recursive()] [Qualified ID lookup] The get_function(id) call (line 167) uses a QualifiedId - can cross-module ID collisions cause wrong functions to be analyzed? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Filter map early termination] The filter_map().next() call (lines 111-115) returns the first type parameter found - can this miss cases where later parameters are the problematic ones? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_contains_ty_parameter()] [Iterator short-circuit] Using next() on filter_map (line 238) for struct instantiations - can the short-circuit behavior miss important type parameters in complex generics? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: report_error()] [Map collection] The map().collect_vec() calls (lines 182-194) build label lists - can extremely large caller chains cause these collections to exhaust memory? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: def_not_recursive()] [Transitive closure completeness] Does get_transitive_closure_of_used_functions (line 168) include all call types (direct, indirect, through closures, through generics), or can some call patterns be missed? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: def_not_recursive()] [Closure staleness] Is the transitive closure computed fresh for each check, or can stale closure data from earlier compilation stages cause incorrect recursion detection? (High)",
  "[File: aptos-core/third_party/move\n\n### Citations\n\n**File:** third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs (L1-266)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse itertools::Itertools;\nuse move_model::{\n    ast::{ExpData, Operation, VisitorPosition},\n    model::{FunId, GlobalEnv, Loc, ModuleEnv, NodeId, QualifiedId, QualifiedInstId},\n    ty::Type,\n};\n\n/// Checks all modules in `env`\npub fn check_cyclic_instantiations(env: &GlobalEnv) {\n    for module in env.get_modules() {\n        if module.is_target() {\n            let checker = CyclicInstantiationChecker::new(module);\n            checker.check();\n        }\n    }\n}\n\n/// Module checker state\nstruct CyclicInstantiationChecker<'a> {\n    /// The module we are checking\n    mod_env: ModuleEnv<'a>,\n}\n\nimpl<'a> CyclicInstantiationChecker<'a> {\n    pub fn new(mod_env: ModuleEnv<'a>) -> Self {\n        Self { mod_env }\n    }\n\n    /// Checks all functions in the module\n    fn check(&self) {\n        for fun_env in self.mod_env.get_functions() {\n            self.check_fun(fun_env.get_id())\n        }\n    }\n\n    /// Checks the given function\n    fn check_fun(&self, fun_id: FunId) {\n        let fun_env = self.mod_env.get_function(fun_id);\n        if let Some(fun_body) = fun_env.get_def() {\n            let mut callers = self.gen_init_callers_chain(fun_id);\n            let insts = self.gen_generic_insts_for_fun(fun_id);\n            fun_body.visit_positions(&mut |pos, e| self.visit(pos, e, &insts, &mut callers));\n        }\n    }\n\n    /// Generates generic type instantiations for the given function\n    fn gen_generic_insts_for_fun(&self, fun_id: FunId) -> Vec<Type> {\n        let num_ty_params = self.mod_env.get_function(fun_id).get_type_parameter_count() as u16;\n        (0..num_ty_params).map(Type::TypeParameter).collect_vec()\n    }\n\n    /// Generates the initial callers chain for the given function,\n    /// which is the given function initialized with generic type parameters\n    fn gen_init_callers_chain(&self, fun_id: FunId) -> Vec<(Loc, QualifiedInstId<FunId>)> {\n        let insts = self.gen_generic_insts_for_fun(fun_id);\n        let root_caller = self.mod_env.get_id().qualified_inst(fun_id, insts);\n        let root_caller_loc = self.mod_env.get_function(fun_id).get_loc();\n        vec![(root_caller_loc, root_caller)]\n    }\n\n    /// Visits an expression and checks for cyclic type instantiations.\n    /// `insts`: the type parameters of the current expression\n    /// `callers_chain`: the chain of callers leading to the current expression\n    fn visit(\n        &self,\n        position: VisitorPosition,\n        e: &ExpData,\n        insts: &[Type],\n        callers_chain: &mut Vec<(Loc, QualifiedInstId<FunId>)>,\n    ) -> bool {\n        use ExpData::*;\n        use VisitorPosition::*;\n        match (position, e) {\n            (Pre, Call(nid, op, _)) => self.visit_call(nid, op, insts, callers_chain),\n            _ => true,\n        }\n    }\n\n    /// Visits a call expression and checks for cyclic type instantiations.\n    /// Other parameters are the same as in `visit`\n    fn visit_call(\n        &self,\n        nid: &NodeId,\n        op: &Operation,\n        insts: &[Type],\n        callers_chain: &mut Vec<(Loc, QualifiedInstId<FunId>)>,\n    ) -> bool {\n        if let Operation::MoveFunction(mod_id, fun_id) | Operation::Closure(mod_id, fun_id, _) = op\n        {\n            let callee_uninst = mod_id.qualified_inst(*fun_id, self.get_inst(*nid));\n            let callee = callee_uninst.instantiate(insts);\n            if *mod_id != self.mod_env.get_id() || self.def_not_recursive(callee.to_qualified_id())\n            {\n                // skips if callee from another module (since there is no cyclic module dependency),\n                // or if the callee is not recursive\n                true\n            } else {\n                for (_, ancestor_caller) in callers_chain.iter() {\n                    if ancestor_caller.to_qualified_id() == callee.to_qualified_id() {\n                        // we are checking for the root caller\n                        let (_, checking_for) = &callers_chain[0];\n                        if checking_for.to_qualified_id() != callee.to_qualified_id() {\n                            // check and report diagnostics when `callee` is checked\n                            // this happens when root caller `f` calls `g` which then calls `g` itself\n                            return true;\n                        } else {\n                            #[allow(clippy::collapsible_else_if)]\n                            if let Some(_ty_param) = callee\n                                .inst\n                                .iter()\n                                .filter_map(ty_properly_contains_ty_parameter)\n                                .next()\n                            {\n                                self.report_error(*nid, callee, callers_chain);\n                                return false;\n                            } else {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                self.visit_callees(*nid, callee, insts, callers_chain)\n            }\n        } else {\n            true\n        }\n    }\n\n    /// Visits a call expression and checks for cyclic type instantiations.\n    /// Other parameters are the same as in `visit`.\n    /// Precondition: `caller` defined in `self.mod_env`\n    fn visit_callees(\n        &self,\n        caller_node: NodeId,\n        caller: QualifiedInstId<FunId>,\n        insts: &[Type],\n        callers_chain: &mut Vec<(Loc, QualifiedInstId<FunId>)>,\n    ) -> bool {\n        let fun_env = self.mod_env.get_function(caller.id);\n        if let Some(caller_body) = fun_env.get_def() {\n            let caller_loc = self.mod_env.env.get_node_loc(caller_node);\n            callers_chain.push((caller_loc, caller));\n            let insts = Type::instantiate_vec(self.get_inst(caller_node), insts);\n            let res = caller_body.visit_positions_all_visits_return_true(&mut |pos, exp| {\n                self.visit(pos, exp, &insts, callers_chain)\n            });\n            callers_chain.pop();\n            res\n        } else {\n            true\n        }\n    }\n\n    /// Shortcut for getting the node instantiation\n    fn get_inst(&self, nid: NodeId) -> Vec<Type> {\n        self.mod_env.env.get_node_instantiation(nid)\n    }\n\n    /// Returns true if we are sure the function with given id is not recursive\n    fn def_not_recursive(&self, id: QualifiedId<FunId>) -> bool {\n        !self\n            .mod_env\n            .env\n            .get_function(id)\n            .get_transitive_closure_of_used_functions()\n            .contains(&id)\n    }\n\n    /// Reports a cyclic type instantiation error, in which the root caller eventually calls `callee`\n    /// with a cyclic type instantiation. `callee` is the callee of the last caller in `callers_chain`.\n    /// Precondition: `callers_chain` is not empty\n    fn report_error(\n        &self,\n        nid: NodeId,\n        callee: QualifiedInstId<FunId>,\n        callers_chain: &mut [(Loc, QualifiedInstId<FunId>)],\n    ) {\n        let root = callers_chain[0].1.id;\n        let mut labels = (0..callers_chain.len() - 1)\n            .map(|i| {\n                let (_caller_loc, caller) = &callers_chain[i];\n                // callee of `caller`\n                let (callee_loc, callee) = &callers_chain[i + 1];\n                format!("
]