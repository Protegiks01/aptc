[
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Usage context] [Cross-transaction persistence] If the interner persists across transactions in the same block, can earlier transactions poison the interner state to affect later transactions' execution? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Usage context] [Epoch boundary behavior] How does the interner handle epoch transitions? Can stale indices from a previous epoch be used in the new epoch, causing consensus disagreement between validators? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Function: alloc()] [Buffer address stability] When the buffer is moved to the pool vector, does the move preserve the memory addresses of all elements, or can vector reallocation cause elements to move to new addresses, invalidating 'static references? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Function: alloc()] [Multiple pool buffers] As more buffers accumulate in the pool, can memory fragmentation increase to the point where new allocations fail even with sufficient total free memory available? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Function: alloc()] [Capacity guarantee] The comment states 'no reallocations' after buffer swap - but is this actually guaranteed by Vec semantics, or can internal Vec optimizations violate this assumption? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/interner.rs] [Function: intern_deferred()]\n\n### Citations\n\n**File:** third_party/move/move-vm/types/src/interner.rs (L1-400)\n```rust\n// Copyright (c) Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse parking_lot::RwLock;\n#[cfg(test)]\nuse parking_lot::{MappedRwLockReadGuard, RwLockReadGuard};\nuse std::{borrow::Cow, collections::BTreeMap};\n\nconst INITIAL_SIZE: usize = 1024;\n\n/// Efficient generic interner implementation.\n///\n/// It uses the technique from https://matklad.github.io/2020/03/22/fast-simple-rust-interner.html\n/// to avoid making an additional copy of the interned value.\npub struct ConcurrentBTreeInterner<T: 'static> {\n    inner: RwLock<InternerPool<T>>,\n}\n\n/// Pool storing the interned values.\nstruct InternerPool<T: 'static> {\n    /// The size for the next allocation of the active buffer.\n    /// When the current buffer fills up, it will be moved into the pool and a new one will be allocated.\n    next_size: usize,\n\n    /// A mapping from interned values to their corresponding ids.\n    map: BTreeMap<&'static T, usize>,\n    /// A vector of interned values to allow reverse lookup of values by their ids.\n    vec: Vec<&'static T>,\n\n    /// The currently active buffer used to store new interned values.\n    buffer: Vec<T>,\n    /// A collection of previously filled (frozen) buffers that own interned values.\n    pool: Vec<Vec<T>>,\n}\n\nimpl<T> InternerPool<T> {\n    /// Creates a new empty interner.\n    pub fn new() -> Self {\n        Self {\n            next_size: INITIAL_SIZE * 2,\n            map: BTreeMap::new(),\n            vec: Vec::new(),\n            buffer: Vec::with_capacity(INITIAL_SIZE),\n            pool: Vec::new(),\n        }\n    }\n}\n\nimpl<T> Default for InternerPool<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> InternerPool<T>\nwhere\n    T: Ord,\n{\n    /// Flushes the pool, clearing all interned values.\n    ///\n    /// Note that this specifically does not reset the current buffer size, nor the next size,\n    /// as resetting gives no real benefit. Asymptotically, we are still using O(n) memory.\n    ///\n    /// Another way to think about this is that after a flush, we are starting with a larger\n    /// initial size.\n    fn flush(&mut self) {\n        self.map.clear();\n        self.vec.clear();\n        self.buffer.clear();\n        self.pool.clear();\n    }\n\n    /// Allocates a value in the internal buffer.\n    ///\n    /// In case the current buffer is full, a new one will be allocated, with double the capacity,\n    /// guaranteeing no reallocations. This allows us to store the reference to the value in other\n    /// data structures safely.\n    ///\n    /// SAFETY: this function is still UNSAFE, because the returned reference does not really have\n    /// a static lifetime -- it cannot outlive the interner itself. If you need to give the reference\n    /// out to an external caller, you need to shorten its lifetime to that of the interner.\n    unsafe fn alloc(&mut self, val: T) -> &'static T {\n        if self.buffer.len() >= self.buffer.capacity() {\n            let new_buffer = Vec::with_capacity(self.next_size);\n            self.next_size *= 2;\n\n            let old_buffer = std::mem::replace(&mut self.buffer, new_buffer);\n            self.pool.push(old_buffer);\n        }\n\n        self.buffer.push(val);\n        unsafe { &*(self.buffer.last().expect("
]