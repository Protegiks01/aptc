[
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ApiFilter] [Input Validation] Can a malicious indexer client send an ApiFilter with multiple filter variants set simultaneously, bypassing the oneof constraint and causing undefined behavior when the filter is applied to transaction queries? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ApiFilter::deserialize] [Duplicate Field Attack] In the ApiFilter deserialization logic, can an attacker send duplicate filter fields (e.g., both transactionRootFilter and userTransactionFilter) to exploit the duplicate field check at lines 100-118 and cause state confusion in the indexer? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ApiFilter::visit_map] [None Value Bypass] Does the ApiFilter deserialization properly handle the case where filter__ remains None after processing all fields (line 123), potentially allowing unfiltered transaction queries that could overwhelm the indexer? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ActiveStream::deserialize] [Integer Overflow] Can an attacker provide extremely large values for start_version or end_version fields (lines 265-274) that cause integer overflow when calculating version ranges, leading to incorrect stream boundaries and data corruption? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ActiveStream::visit_map] [Version Ordering] Does the ActiveStream deserialization validate that start_version <= end_version (lines 287-289), or can an attacker create streams with inverted version ranges causing infinite loops or resource exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: ActiveStream::serialize] [Default Value Leak] When start_version is 0 (line 144), it's not serialized - can this lead to ambiguity between 'not set' and 'genesis version', potentially causing indexers to skip critical genesis transactions? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: BooleanTransactionFilter] [Recursive Filter DoS] Can an attacker craft deeply nested LogicalNot filters wrapping LogicalOr/LogicalAnd filters (lines 318-322) to cause stack overflow during deserialization or filter evaluation, leading to indexer crash? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: BooleanTransactionFilter::visit_map] [Filter Type Confusion] In lines 397-424, can an attacker send multiple filter types (apiFilter, logicalAnd, logicalOr, logicalNot) in sequence to bypass the duplicate field check and create ambiguous filter state? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: BooleanTransactionFilter] [Empty Filter Bypass] If filter__ is None after deserialization (line 428), does this result in an unfiltered query that returns all transactions, potentially causing information disclosure or resource exhaustion? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EntryFunctionFilter::visit_map] [Address Validation Missing] Does the EntryFunctionFilter validate that the address field (line 535) is a valid Aptos address format, or can attackers inject malformed addresses that cause downstream parsing errors or bypass filtering logic? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EntryFunctionFilter] [Module Name Injection] Can an attacker provide malicious module_name values (line 541) containing special characters or path traversal sequences that exploit module resolution logic in the indexer? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EntryFunctionFilter] [Function Name Wildcard] If the function field is None (line 547), does this match all functions in the module, and can this be exploited to extract sensitive transaction data from protected entry points? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EventFilter::visit_map] [Substring Filter Injection] Can an attacker craft data_substring_filter values (line 658) with regex metacharacters or extremely long strings that cause ReDoS attacks or memory exhaustion during event filtering? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EventFilter] [Struct Type Validation] Does the struct_type field (line 652) properly validate Move struct tag format, or can malformed struct types bypass type checking and match unintended events? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: EventFilter] [Empty Filter Wildcard] If both struct_type and data_substring_filter are None (lines 663-664), does this match all events, potentially causing information disclosure or DoS when processing large blocks? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: FullnodeInfo::deserialize] [Chain ID Spoofing] Can a malicious data service report incorrect chain_id values (line 773) to cause indexers to process transactions from different chains, leading to cross-chain replay attacks? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: FullnodeInfo::visit_map] [Version Manipulation] Can an attacker provide a false known_latest_version (line 787) that is far ahead of the actual chain state, causing indexers to request non-existent transactions and stall? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: FullnodeInfo::serialize] [Timestamp Validation] Is the timestamp field (line 693) validated to be within reasonable bounds, or can future/past timestamps be used to manipulate indexer synchronization logic? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GetTransactionsRequest::visit_map] [Version Range Attack] Can an attacker specify starting_version close to u64::MAX and large transactions_count (lines 1100-1109) to cause integer overflow when calculating the end range, leading to incorrect data retrieval? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GetTransactionsRequest] [Batch Size DoS] Can an attacker request extremely large batch_size values (line 1116) combined with high transactions_count to overwhelm the data service with massive response messages? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GetTransactionsRequest] [Filter Complexity Attack] Can combining complex nested transaction_filter (line 1123) with large batch sizes cause exponential processing time during transaction matching, leading to DoS? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GrpcManagerInfo::visit_map] [Master Address Spoofing] Can an attacker provide a malicious master_address value (line 1272) to redirect indexer traffic to attacker-controlled services, enabling man-in-the-middle attacks? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GrpcManagerInfo] [Chain ID Mismatch] Does the system validate that chain_id (line 1251) matches across all service components, or can mismatched chain IDs cause indexers to process data from multiple chains simultaneously? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: GrpcManagerInfo::deserialize] [Known Latest Version Rollback] Can an attacker report a known_latest_version (line 1265) that is lower than previously seen values, causing indexers to roll back and reprocess transactions, potentially exploiting race conditions? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Struct: HeartbeatRequest::visit_map] [Service Info Injection] Can an attacker inject malicious ServiceInfo (line 1367) containing contradictory chain_id or version information to desynchronize multiple indexer components? (High)"
]