[
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 136] [Immutability] Does the comment 'This value should not be changed, for replay purposes' at line 136 mean default_if_missing is a critical constant? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 162-167] [Deserialization requirement] Does the comment about double BCS deserialization mean this is a fixed protocol requirement that can't be changed without breaking replay? (High)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 277-279] [Limit types] Does the comment about 'two separate block limits' mean both must be enforced, or is one optional? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 281-285] [Formula specification] Is the gas limit formula comment at lines 281-285 the authoritative specification, or could the implementation differ? (High)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 291-294] [Granular conflicts] Does the comment explaining granular resource group conflicts match the actual implementation of use_granular_resource_group_conflicts? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 299] [Not supported flag] Does 'Currently not supported' for use_module_publishing_block_conflict mean the flag is ignored? Why is it in the config? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 302] [Approximate computation] What does 'approximate' mean for block output size? Could the approximation be exploited? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 308-309] [BlockEpilogue vs StateCheckpoint] Does creating BlockEpilogue instead of StateCheckpoint affect consensus or state tree structure? (High)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Comment: line 310] [Not supported flag] Why is add_block_limit_outcome_onchain in the config if it's 'Currently not supported'? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Function: deserialize_into_config()] [Empty bytes] Does deserialize_into_config handle empty bytes at line 170 gracefully, or could it cause panic/undefined behavior? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Function: deserialize_into_config()] [Malformed BCS] Can malformed BCS data cause the first deserialization at line 170 to succeed but second at line 171 to fail, causing inconsistent state? (High)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Function: deserialize_into_config()] [Error handling] Does the format_err at line 172 provide enough information for debugging deserialization failures in production? (Low)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Function: deserialize_into_config()] [Version mismatch] Can deserializing a future config version (V8+) into this code cause silent failures or undefined behavior? (High)",
  "[File: aptos-core/types/src/on_chain_config/execution_config.rs] [Function: default_for_genesis()] [ComplexLimitV1 defaults] Are the ComplexLimitV1 defaults at lines 144-154 (20000 gas limit, multipliers of 1, window of 9) secure against known attack patterns? (High)",
  "[File: aptos-core/types/src/on\n\n### Citations\n\n**File:** types/src/on_chain_config/execution_config.rs (L1-580)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    block_executor::config::BlockExecutorConfigFromOnchain, on_chain_config::OnChainConfig,\n};\nuse anyhow::{format_err, Result};\nuse serde::{Deserialize, Serialize};\n\n/// The on-chain execution config, in order to be able to add fields, we use enum to wrap the actual struct.\n#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]\npub enum OnChainExecutionConfig {\n    V1(ExecutionConfigV1),\n    V2(ExecutionConfigV2),\n    V3(ExecutionConfigV3),\n    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve\n    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.\n    Missing,\n    // Reminder: Add V4 and future versions here, after Missing (order matters for enums).\n    V4(ExecutionConfigV4),\n    V5(ExecutionConfigV5),\n    V6(ExecutionConfigV6),\n    V7(ExecutionConfigV7),\n}\n\n/// The public interface that exposes all values with safe fallback.\nimpl OnChainExecutionConfig {\n    /// The type of the transaction shuffler being used.\n    pub fn transaction_shuffler_type(&self) -> TransactionShufflerType {\n        match &self {\n            OnChainExecutionConfig::Missing => TransactionShufflerType::NoShuffling,\n            OnChainExecutionConfig::V1(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V2(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V3(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V4(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V5(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V6(config) => config.transaction_shuffler_type.clone(),\n            OnChainExecutionConfig::V7(config) => config.transaction_shuffler_type.clone(),\n        }\n    }\n\n    /// The per-block gas limit being used.\n    pub fn block_gas_limit_type(&self) -> BlockGasLimitType {\n        match &self {\n            OnChainExecutionConfig::Missing => BlockGasLimitType::NoLimit,\n            OnChainExecutionConfig::V1(_config) => BlockGasLimitType::NoLimit,\n            OnChainExecutionConfig::V2(config) => config\n                .block_gas_limit\n                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),\n            OnChainExecutionConfig::V3(config) => config\n                .block_gas_limit\n                .map_or(BlockGasLimitType::NoLimit, BlockGasLimitType::Limit),\n            OnChainExecutionConfig::V4(config) => config.block_gas_limit_type.clone(),\n            OnChainExecutionConfig::V5(config) => config.block_gas_limit_type.clone(),\n            OnChainExecutionConfig::V6(config) => config.block_gas_limit_type.clone(),\n            OnChainExecutionConfig::V7(config) => config.block_gas_limit_type.clone(),\n        }\n    }\n\n    pub fn enable_per_block_gas_limit(&self) -> bool {\n        match &self {\n            OnChainExecutionConfig::Missing\n            | OnChainExecutionConfig::V1(_)\n            | OnChainExecutionConfig::V2(_)\n            | OnChainExecutionConfig::V3(_)\n            | OnChainExecutionConfig::V4(_) => false,\n            OnChainExecutionConfig::V5(config) => config.enable_per_block_gas_limit,\n            OnChainExecutionConfig::V6(config) => config.enable_per_block_gas_limit,\n            OnChainExecutionConfig::V7(config) => config.enable_per_block_gas_limit,\n        }\n    }\n\n    pub fn gas_price_to_burn(&self) -> Option<u64> {\n        match self {\n            OnChainExecutionConfig::Missing\n            | OnChainExecutionConfig::V1(_)\n            | OnChainExecutionConfig::V2(_)\n            | OnChainExecutionConfig::V3(_)\n            | OnChainExecutionConfig::V4(_)\n            | OnChainExecutionConfig::V5(_) => None,\n            OnChainExecutionConfig::V6(config) => Some(config.gas_price_to_burn),\n            OnChainExecutionConfig::V7(config) => Some(config.gas_price_to_burn),\n        }\n    }\n\n    pub fn persisted_auxiliary_info_version(&self) -> u8 {\n        match self {\n            OnChainExecutionConfig::Missing\n            | OnChainExecutionConfig::V1(_)\n            | OnChainExecutionConfig::V2(_)\n            | OnChainExecutionConfig::V3(_)\n            | OnChainExecutionConfig::V4(_)\n            | OnChainExecutionConfig::V5(_)\n            | OnChainExecutionConfig::V6(_) => 0,\n            OnChainExecutionConfig::V7(config) => config.persisted_auxiliary_info_version,\n        }\n    }\n\n    pub fn block_executor_onchain_config(&self) -> BlockExecutorConfigFromOnchain {\n        BlockExecutorConfigFromOnchain::new(\n            self.block_gas_limit_type(),\n            self.enable_per_block_gas_limit(),\n            self.gas_price_to_burn(),\n        )\n    }\n\n    /// The type of the transaction deduper being used.\n    pub fn transaction_deduper_type(&self) -> TransactionDeduperType {\n        match &self {\n            // Note, this behavior was enabled before OnChainExecutionConfig was registered.\n            OnChainExecutionConfig::Missing => TransactionDeduperType::TxnHashAndAuthenticatorV1,\n            OnChainExecutionConfig::V1(_config) => TransactionDeduperType::NoDedup,\n            OnChainExecutionConfig::V2(_config) => TransactionDeduperType::NoDedup,\n            OnChainExecutionConfig::V3(config) => config.transaction_deduper_type.clone(),\n            OnChainExecutionConfig::V4(config) => config.transaction_deduper_type.clone(),\n            OnChainExecutionConfig::V5(config) => config.transaction_deduper_type.clone(),\n            OnChainExecutionConfig::V6(config) => config.transaction_deduper_type.clone(),\n            OnChainExecutionConfig::V7(config) => config.transaction_deduper_type.clone(),\n        }\n    }\n\n    /// The default values to use for new networks, e.g., devnet, forge.\n    /// Features that are ready for deployment can be enabled here.\n    pub fn default_for_genesis() -> Self {\n        OnChainExecutionConfig::V7(ExecutionConfigV7 {\n            transaction_shuffler_type: TransactionShufflerType::default_for_genesis(),\n            block_gas_limit_type: BlockGasLimitType::default_for_genesis(),\n            enable_per_block_gas_limit: false,\n            transaction_deduper_type: TransactionDeduperType::TxnHashAndAuthenticatorV1,\n            gas_price_to_burn: 90,\n            persisted_auxiliary_info_version: 1,\n        })\n    }\n\n    /// The default values to use when on-chain config is not initialized.\n    /// This value should not be changed, for replay purposes.\n    pub fn default_if_missing() -> Self {\n        OnChainExecutionConfig::Missing\n    }\n}\n\nimpl BlockGasLimitType {\n    pub fn default_for_genesis() -> Self {\n        BlockGasLimitType::ComplexLimitV1 {\n            effective_block_gas_limit: 20000,\n            execution_gas_effective_multiplier: 1,\n            io_gas_effective_multiplier: 1,\n            conflict_penalty_window: 9,\n            use_granular_resource_group_conflicts: false,\n            use_module_publishing_block_conflict: true,\n            block_output_limit: Some(4 * 1024 * 1024),\n            include_user_txn_size_in_block_output: true,\n            add_block_limit_outcome_onchain: true,\n        }\n    }\n}\n\nimpl OnChainConfig for OnChainExecutionConfig {\n    const MODULE_IDENTIFIER: &'static str ="
]