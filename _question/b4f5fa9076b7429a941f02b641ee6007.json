[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: process_transactions_in_parallel()] [Race condition] At line 287, clear_pending_on() is called - can this race with concurrent index_table_info() calls at line 406 from other tasks, causing pending items to be cleared while still in use? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: Drop::drop()] [Race condition] Lines 46-50 implement Drop with a println - can this be called while async tasks spawned at lines 86-99 and 269-273 are still running, causing use-after-free or resource leaks? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: backup_the_snapshot_and_cleanup()] [Race condition] Line 583 calls std::fs::remove_dir_all() - can this race with snapshot_indexer_async_v2() writing to the same directory, causing file system corruption or incomplete snapshot deletion? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Race condition] Lines 131-143 conditionally snapshot at epoch end - can a race between checking transactions_in_previous_epoch.is_empty() at line 124 and snapshotting at lines 136-142 cause duplicate snapshots if epoch transitions occur rapidly? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_highest_known_version()] [Race condition] Lines 508-509 update info and ledger_version from context.get_latest_ledger_info_wrapped() - can these updates be non-atomic, causing ledger_version to be inconsistent with info when used at line 499? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: fetch_batches()] [Transaction ordering violation] Lines 227-235 verify transactions are sorted with no gaps using windows(2) - can an attacker manipulate fetch_raw_txns_with_retries to return transactions with version gaps that pass this check by crafting w[0].version + 1 == w[1].version to always succeed through integer overflow? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Version rollback] At line 189-190, current_version is stored as last_version + 1 - if last_version wraps around at u64::MAX, can this cause current_version to be set to 0, rolling back the indexer state and reprocessing old transactions? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_batches()] [Version gap] Lines 373-387 calculate batch ranges - can integer overflow in start_version += num_transactions_to_fetch at line 385 cause batches to wrap around and request duplicate or invalid version ranges? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: process_transactions_in_parallel()] [Version inconsistency] At line 302-304, update_next_version(end_version + 1) is called - if end_version is u64::MAX, can this overflow cause the next version to be set to 0, corrupting the indexer's progress tracking? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: fetch_batches()] [Transaction gap] The gap detection at lines 227-235 only checks consecutive transactions - can an attacker cause the first transaction in a batch to have an arbitrary version, creating a gap with the previous batch that goes undetected? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_highest_known_version()] [Version starvation] Lines 499-527 loop until current_version <= ledger_version - if current_version is somehow set higher than the actual ledger version (e.g., through corruption), can this cause an infinite loop that hangs the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Version skipping] At line 113, get_batches() is called with ledger_version - if this function returns empty batches due to current_version > ledger_version, can transactions be permanently skipped if the ledger version never catches up? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: new()] [Version initialization] Line 62 initializes current_version with request_start_version - if this parameter is larger than the actual ledger version, can it cause the indexer to skip all existing transactions and only process future ones? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: fetch_batches()] [Duplicate transactions] Lines 220-224 sort and collect transactions from parallel fetches - if fetch_raw_txns_with_retries returns duplicate versions due to retries, can the sorted collection contain duplicates that corrupt the indexed state? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: process_transactions_in_parallel()] [Version mismatch] Lines 252-256 get last_version from transactions, but line 278 uses this for logging - can a mismatch between the actual processed version and last_version cause update_next_version at line 302-304 to skip versions? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_batches()] [Batch calculation] Line 374-377 calculates num_transactions_to_fetch using std::cmp::min - can an attacker manipulate ledger_version to cause this calculation to return 0, creating empty batches that stall indexer progress? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Version atomicity] Lines 189-190 store current_version, but lines 175-187 log the version range - can a crash between logging and storing cause the logged version to not match the stored version, breaking audit trails? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: process_transactions()] [Version boundary] Lines 325-326 get start_version and end_version from raw_txns array bounds - can an empty array cause panic or undefined behavior when accessing raw_txns[0] and raw_txns.last()? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: fetch_batches()] [Version ordering] Line 223 sorts by txn.version using sorted_by_key - can transactions with identical versions cause non-deterministic ordering that leads to different nodes processing transactions in different orders? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Version persistence] After line 189-190 stores current_version atomically, but before line 302-304 calls update_next_version() on RocksDB - can a crash in between cause version mismatch between in-memory state and persisted state? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_batches()] [Batch overflow] Line 385 performs start_version += num_transactions_to_fetch - can repeated additions cause start_version to overflow past u64::MAX and wrap to 0, creating invalid batch ranges? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: next_version()] [Version exposure] Line 196 exposes current_version to external callers - can malicious code use this to determine processing progress and time attacks to exploit race conditions during version updates? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: run()] [Version regression] Lines 116-119 get last_version from the last transaction - if transactions array is empty due to no new transactions, can last_version be 0 and cause current_version at line 189-190 to regress to 1? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: parse_table_info()] [Version validation] Lines 393-417 process write sets starting from first_version at line 403 - can an attacker provide write sets with mismatched versions compared to transaction versions, causing index_table_info to corrupt the database? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs] [Function: get_highest_known_version()] [Version initialization] Lines 495-496 initialize ledger_version from get_latest_ledger_info_wrapped() - if this returns an error or None, can ledger_version remain 0 and cause the loop at line 499 to run indefinitely? (High)"
]