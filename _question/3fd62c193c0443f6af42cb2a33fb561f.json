[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_attribute()] [Recursive attribute DoS] Can Attribute_::Parameterized nest infinitely, causing stack overflow through recursive attribute parsing? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_attribute_value()] [Value type confusion] Can AttributeValue_::Value and AttributeValue_::ModuleAccess be confused to allow arbitrary expressions in attribute values where only literals should be accepted? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_attributes()] [Attribute count DoS] Can unlimited #[attr1][attr2]... sequences cause memory exhaustion without bounds checking? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind()] [Lookahead race condition] The lookahead check at line 864 determines bind type - can race conditions or token caching cause misclassification between variable binds and struct unpacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind()] [Positional unpack bypass] Does Bind_::PositionalUnpack (lines 890-902) properly validate field count and types, or can it be used to unpack structs with mismatched field counts? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind()] [Empty unpack exploit] Can Bind_::Unpack with empty fields vec (line 904) bypass struct validation for structs that should have required fields? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind_or_dotdot()] [DotDot pattern abuse] Can the .. pattern (BindOrDotDot_::DotDot) be used multiple times or in invalid positions to create ambiguous bindings? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind_field_or_dotdot()] [Field name collision] Can DotDot and explicit field bindings collide on the same field name, causing undefined behavior in pattern matching? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_bind_list()] [Single vs multi-bind confusion] Can the optional parentheses for single binds (lines 923-934) create ambiguity where (x) is treated differently than x? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_lambda_bind_list()] [Empty lambda parameters] Does parsing || (empty bind list) properly handle subsequent expression parsing, or can it cause misinterpretation of the lambda body? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_byte_string()] [Hex string validation] Does the HexString parsing for x\\",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_byte_string()] [Byte string injection] Can the text extraction at line 997 include escape sequences or special characters that cause injection vulnerabilities in later stages? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: maybe_parse_value()] [Address prefix bypass] Can @ prefix be missing or duplicated to confuse address value parsing with other expressions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: maybe_parse_value()] [NumValue ambiguity] The check for :: after NumValue (lines 1033-1036) prevents address access - can this be bypassed through token lookahead manipulation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_value()] [Expect panic] parse_value() expects maybe_parse_value to return Some (line 1060) - can this panic if called in invalid contexts, causing compiler DoS? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_sequence_item()] [Let without assignment] SequenceItem_::Declare allows let bindings without initialization (line 1084) - can this be exploited to use uninitialized variables? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_sequence()] [Use after sequence items] Use declarations are only parsed at sequence start (lines 1106-1108) - can uses be injected mid-sequence through parser confusion? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_sequence()] [Semicolon manipulation] The last_semicolon_loc tracking - can missing or extra semicolons cause incorrect expression vs statement classification? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_sequence()] [Block end confusion] When RBrace is encountered (line 1134), can premature block termination skip validation of incomplete statements? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [Control expression DoS] Control expressions ending in blocks have special parsing (lines 1172-1177) - can this be abused to create deeply nested structures causing stack overflow? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [Match lookahead bypass] Match expression requires specific lookahead (lines 1180-1182) - can token caching or race conditions bypass this check to parse malformed match expressions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [For loop condition bypass] For loop parsing checks lookahead_nth (lines 1191-1193) - can this be defeated to parse for loops in invalid contexts? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [Break with value exploit] The code notes 'break' with value is not yet supported (line 1206) - can this be bypassed through expression parsing to create undefined break semantics? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [Vector type arg ambiguity] The type args ambiguity label (line 1229) - can < in vector declarations be confused with comparison operators in complex expressions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [NumValue coloncolon check] At lines 1252-1254, NumValue followed by :: is treated as module access - can integer literals be used as module names to bypass validation? (Critical)"
]