[
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Single child leaf promotion] When only one child remains at lines 574-598, leaf nodes are promoted. Can this logic be exploited to create artificially shallow trees that bypass depth-based security checks? (Medium)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Old leaf node retrieval] At lines 581-585, old leaf nodes are retrieved from storage and marked stale. Can race conditions cause the retrieved node to differ from the one that was originally in the tree, causing hash mismatches? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Child node key generation] The gen_child_node_key calls at lines 582, 609, and 612 use version and nibble parameters. Can incorrect version usage cause nodes from different versions to collide in storage? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Hash cache exploitation] The Child::for_node call at line 612 uses hash_cache. Can cache poisoning attacks provide incorrect hashes that later cause merkle proof verification to fail, breaking state integrity? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Null node depth constraint] The ensure! at lines 625-628 allows Null nodes only at depth <= MIN_LEAF_DEPTH. Can violating this by manipulating depth parameters cause Null nodes in invalid positions, corrupting tree structure? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: batch_insert_at()] [Existing leaf handling delegation] At line 621, existing leaf nodes are handled by batch_update_subtree_with_existing_leaf. Can inconsistencies between this function and batch_update_subtree cause divergent behavior? (Medium)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: insert_at_child()] [Child index extraction] The child_index is extracted at line 647 using get_nibble(depth). Can depth values exceeding ROOT_NIBBLE_HEIGHT cause out-of-bounds access or incorrect nibble extraction? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: insert_at_child()] [Child existence branch divergence] When child is Some vs None (lines 650-667), different code paths are taken. Can attackers exploit timing differences to learn information about tree structure through side-channel attacks? (Low)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: insert_at_child()] [Slice range calculation] The kvs slice at lines 654 and 662 uses left..=right range. Can off-by-one errors in NibbleRangeIterator cause incorrect slices that skip or duplicate keys? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: insert_at_child()] [Depth increment overflow] The depth + 1 at lines 655 and 663 increments depth. Can recursive calls with maximum depth cause integer overflow leading to incorrect depth values and invalid tree structure? (Medium)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: insert_at_child()] [New subtree version usage] When creating new subtrees at line 659, the version parameter is used. Can version inconsistencies between parent and child nodes cause merkle path verification failures? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof()] [Proof conversion safety] The function converts SparseMerkleProofExt to SparseMerkleProof at line 714. Can this conversion lose critical information needed for verification, causing invalid proofs to be accepted? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Empty tree proof forgery] For empty trees, a proof with no sibling hash is returned at line 793. Can attackers exploit this to prove non-existence of keys that actually exist by manipulating version parameters? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Cyclic graph detection] The loop at line 731 deliberately limits iterations to ROOT_NIBBLE_HEIGHT to detect cycles. Can carefully crafted tree structures bypass this detection and cause infinite loops or DoS? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Root node error handling] At lines 736-741, MissingRootError is returned only when nibble_depth == 0. Can this leak information about tree depth through error messages, enabling timing attacks? (Low)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Single leaf internal node skip] At lines 744-751, internal nodes with leaf_count == 1 are skipped without adding siblings. Can this optimization be exploited to create shorter proof paths that hide actual tree structure? (Medium)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Nibble iterator exhaustion] At lines 753-755, running out of nibbles returns an error. Can malformed keys cause premature exhaustion that generates invalid proofs accepted by verifiers? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Child retrieval with siblings] The get_child_with_siblings call at lines 756-763 populates out_siblings. Can manipulation of this function cause missing or extra siblings that break proof verification? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Non-existence proof validity] When child_node_key is None at lines 764-776, a proof of non-existence is returned. Can attackers craft keys that produce false non-existence proofs for existing keys? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Leaf key comparison] At line 780, leaf_node.account_key() == key determines value existence. Can hash collisions cause two different keys to match, returning wrong values? (Critical)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Target root depth handling] The target_root_depth parameter (line 721) affects proof generation at lines 762, 772, and 788. Can manipulation cause proofs valid for one depth to be incorrectly accepted at another depth? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_with_proof_ext()] [Null node proof handling] When encountering Node::Null at line 792, an empty proof is returned. Can this be exploited to prove anything about null subtrees, bypassing access control checks? (Medium)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_range_proof()] [Rightmost key validation] The ensure! at line 807 requires the rightmost_key_to_prove to exist. Can providing a non-existent key cause proof generation to fail in a way that leaks information about tree contents? (Low)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_range_proof()] [Sibling filtering logic] The filter_map at lines 809-820 keeps only right siblings (!bit condition at line 815). Can incorrect bit iteration or off-by-one errors cause wrong siblings to be included, invalidating range proofs? (High)",
  "[File: aptos-core/storage/jellyfish-merkle/src/lib.rs] [Function: get_range_proof()] [Sibling reversal] The .rev() call at line 821 reverses siblings. Can this ordering be exploited to create range proofs that verify incorrectly when the order is non-deterministic? (Medium)"
]