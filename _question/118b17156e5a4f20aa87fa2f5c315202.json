[
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Executor coupling] The same thread pool is used by NativeVMBlockExecutor, AptosVMParallelUncoordinated, and NativeParallelUncoordinated - can mixing different executor types on the same pool cause work queue contamination where transaction parsing tasks block transaction execution tasks? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: get_concurrency_level()] [Configuration mismatch] The value returned at line 28-32 is used to configure BlockExecutorLocalConfig - can a mismatch between this value and the actual thread pool size (if pool was initialized before set_concurrency_level_once) cause BlockSTM to use incorrect parallelism assumptions? (High)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [install() recursion] When executors call NATIVE_EXECUTOR_POOL.install() for nested parallel operations (like parsing then executing), can this cause work-stealing deadlock if the pool is too small and all threads are waiting for sub-tasks? (High)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: get_concurrency_level()] [AptosVM mismatch] Both NativeConfig and AptosVM have separate concurrency settings - can they be set to different values causing one executor type to use different parallelism than another, making benchmark comparisons invalid? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [First access latency] The Lazy<> initialization at line 9-17 occurs on first access - can this cause the first benchmark run to include thread creation overhead, skewing timing measurements and making cold-start performance non-representative? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Initialization ordering] If NATIVE_EXECUTOR_POOL is accessed before main() sets concurrency_level, it locks in the default value of 1 forever - can this happen during static initialization of other modules that depend on this pool? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: Lazy::new()] [Blocking initialization] The Lazy::new() closure at line 9-17 blocks the first thread that accesses NATIVE_EXECUTOR_POOL until ThreadPoolBuilder completes - can this cause unexpected latency spikes or timeouts in time-sensitive benchmark operations? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Deferred panic] If ThreadPoolBuilder::build() fails but the panic is deferred until first access of NATIVE_EXECUTOR_POOL, can this cause benchmark failures deep in execution logic rather than at initialization, making debugging extremely difficult? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: ThreadPoolBuilder::build()] [Platform limits] Different operating systems have different thread limits (Linux: /proc/sys/kernel/threads-max, Windows: job object limits) - can benchmarks succeed on one platform but fail on another due to unchecked thread creation at line 14-15? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Container constraints] In containerized environments (Docker/Kubernetes), CPU quota limits may not match available CPU count - can setting concurrency_level based on num_cpus() cause over-subscription and severe performance degradation? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: set_concurrency_level_once()] [Test isolation] If multiple benchmark tests run in the same process, the first test to call set_concurrency_level_once() locks the value for all subsequent tests - can this cause test interference where early tests affect later test configurations? (High)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Signal handling] If a signal (SIGTERM, SIGINT) arrives during thread pool initialization, can it leave threads in partially-initialized state that later cause undefined behavior in executor operations? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: set_concurrency_level_once()] [No return value] The function returns () and silently ignores errors via .ok() (line 25) - can callers mistakenly assume their configuration was applied when it was actually ignored due to prior initialization? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_CONCURRENCY_LEVEL] [Public mutability] Although OnceCell enforces write-once, the static is pub allowing any code to attempt setting it - can malicious or buggy code repeatedly call set_concurrency_level_once() expecting dynamic reconfiguration, causing confusion? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: get_concurrency_level()] [Unsafe assumptions] Callers may assume this returns the configured value, but if called before setting it returns 1 (line 31) - can this cause benchmarks to silently run in degraded single-threaded mode without any warning? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Arc cloning overhead] Every access to NATIVE_EXECUTOR_POOL requires cloning the Arc (line 99 in native_vm.rs) - can frequent cloning in hot paths cause reference count contention and performance degradation in highly concurrent benchmarks? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Shared resource] The thread pool is globally shared with no access control - can untrusted benchmark code submit arbitrary closures to the pool for execution, potentially running malicious code in benchmark infrastructure? (High)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: set_concurrency_level_once()] [No authentication] There is no validation of who calls this function - can benchmark adversaries call it early with value 1 to sabotage competing benchmark runs by forcing single-threaded execution? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Information leakage] Thread pool statistics (active workers, queued tasks) might be observable through side channels - can attackers infer sensitive benchmark workload characteristics by monitoring pool state? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_CONCURRENCY_LEVEL] [Configuration tampering] If benchmark scripts can modify this before binary startup via environment variables or config files, can they force degraded performance to hide scaling issues? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Non-deterministic scheduling] Rayon's work-stealing scheduler is non-deterministic - can this cause transaction execution order to vary between benchmark runs, making it impossible to reproduce specific timing-dependent bugs? (Medium)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: get_concurrency_level()] [Environmental dependency] The returned value depends on when set_concurrency_level_once() was called - can this make benchmark results non-reproducible if initialization order changes across runs? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Global: NATIVE_EXECUTOR_POOL] [Thread ID reuse] When threads complete tasks, their IDs may be reused - can this cause confusion in debugging or logging where the same thread ID appears to execute unrelated transactions? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: thread_name()] [Non-unique names] Thread names like 'native_exe_0' might conflict with other thread pools in the process - can this cause monitoring/profiling tools to conflate threads from different pools? (Low)",
  "[File: aptos-core/execution/executor-benchmark/src/native/native_config.rs] [Function: set_concurrency_level_once()] [Resource bomb] Setting concurrency_level to 1,000,000 (line 22) would cause ThreadPoolBuilder to attempt creating 1M threads, each with ~2MB stack, requiring 2TB of virtual memory - can this immediately OOM kill the benchmark process? (Critical)"
]