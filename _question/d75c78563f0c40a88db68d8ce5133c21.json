[
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_seq_num_based_transactions()] [Parking Lot Flooding] At lines 616-624, transactions beyond min_seq are added to parking_lot_index. Can attacker submit massive sequence number gaps to fill parking lot and cause memory exhaustion? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_seq_num_based_transactions()] [State Transition Race] At line 610, process_ready_transaction() is called in loop. Can concurrent commits cause sequence number to advance during loop, leading to incorrect ready state determination? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: commit_transaction()] [Account Sequence Number Manipulation] At lines 679-684, new_account_seq_number is set to max(current, txn_seq + 1). Can Byzantine validator commit out-of-order transactions to cause sequence number to jump arbitrarily, rejecting legitimate user transactions? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [Replay Protector Type Confusion] The code handles both ReplayProtector::SequenceNumber and ReplayProtector::Nonce differently. Can attacker exploit type confusion by submitting transactions that are processed as wrong type? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: get_mempool_txn()] [Replay Protector Lookup] At lines 145-153, transactions are looked up by replay_protector. Can hash collisions in ReplayProtector enum cause transaction mismatches or overwrites? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: commit_transaction()] [Nonce Cleanup] At lines 691-706, Nonce-based transactions are only removed from mempool, not cleaned up like SequenceNumber transactions. Can this lead to unbounded growth of account_sequence_numbers HashMap for orderless transaction users? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_txn_ready()] [Nonce Always Ready] At lines 496-499, Nonce transactions are always considered ready. Can attacker exploit this by flooding mempool with Nonce transactions to consume priority_index and timeline_index capacity? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: commit_transaction()] [Sequence Number vs Nonce Handling] At lines 678-690, SequenceNumber commits trigger cleanup and promotion, while Nonce commits (lines 691-706) only remove the specific transaction. Can this asymmetry be exploited to cause resource exhaustion? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Panic During Removal] At lines 740-769, multiple indexes are removed sequentially. If unwrap_or_else() at line 748 panics, will earlier index removals be reverted or will mempool be left inconsistent? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Hash Index Removal Failure] At line 756, hash_index.remove() is called. If the hash doesn't exist (due to earlier corruption), will this silently fail leaving size_bytes incorrectly calculated? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Size Bytes Underflow] At line 757, size_bytes is decremented. Can integer underflow occur if get_estimated_bytes() returns incorrect value or if transaction was inserted with different size estimate? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: index_remove()] [Empty Transaction Cleanup] At lines 761-765, if txns.len() == 0, the account's data structures are removed. Can race condition cause this check to pass incorrectly while concurrent insertion is adding new transaction? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_transaction()] [Priority Index Insertion] At line 558, priority_index.insert() is called. If this fails but timeline_index.insert() at line 567 succeeds, will transaction be in inconsistent state? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_transaction()] [Timeline State Mismatch] At line 562, ready_for_mempool_broadcast checks if timeline_state == TimelineState::NotReady. Can concurrent state changes cause transaction to be inserted into timeline_index when it shouldn't be? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_transaction()] [Parking Lot Removal Race] At line 591, parking_lot_index.remove() is called after promotion. If transaction was never in parking lot, does this cause issues? Can race allow transaction to be re-parked while being promoted? (Medium)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: insert()] [System TTL Index First] At line 348, system_ttl_index.insert() is called before expiration_time_index.insert(). If system_ttl_index insert succeeds but expiration_time_index fails, will transaction be in partial indexed state? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_transaction()] [Timeline State Mutation] The code modifies txn.timeline_state but doesn't check previous state. Can transaction be promoted multiple times, causing duplicate entries in priority/timeline indexes? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: process_ready_transaction()] [Ready Flag Calculation] At line 556, ready_for_quorum_store checks if transaction is NOT in priority_index. Can this check give wrong result if priority_index.contains() has bugs or race conditions? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_txn_ready()] [Previous Transaction Check] At lines 486-493, code checks if prev_seq_num transaction is Ready. Can attacker exploit by submitting transaction with seq_num - 1 that is Ready but will be GC'd immediately, causing seq_num to incorrectly appear ready? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_txn_ready()] [Zero Sequence Number Unreachable] At lines 480-483, code hits unreachable!() for seq_num == 0. Is this actually unreachable, or can attacker trigger this panic to crash mempool? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: gc()] [Timeline State Reset] At lines 972-974, after parking transaction, timeline_state is reset to NotReady. Can this cause timeline_index to have stale entries if timeline_index.remove() at line 971 fails? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_is_full_after_eviction()] [Eviction Loop Starvation] At lines 426-447, parking_lot_index is popped until mempool is not full. Can attacker craft transactions that are never poppable from parking lot, preventing eviction and causing mempool to remain full? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_is_full_after_eviction()] [Transaction Not Found Error] At line 445, code logs error if transaction not found during eviction. Can attacker cause this by manipulating parking_lot_index to reference non-existent transactions, preventing legitimate evictions? (High)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_is_full_after_eviction()] [Eviction Only for Ready Transactions] At line 421, eviction only happens if check_txn_ready() returns true. Can attacker flood mempool with non-ready transactions that bypass eviction, causing permanent mempool saturation? (Critical)",
  "[File: aptos-core/mempool/src/core_mempool/transaction_store.rs] [Function: check_is_full_after_eviction()] [Eviction Metrics Gaming] At lines 449-453, eviction counters are tracked. Can attacker trigger expensive eviction operations to cause performance degradation in monitoring systems? (Low)"
]