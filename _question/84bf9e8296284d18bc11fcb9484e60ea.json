[
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_constant()] [Constant visibility] Can constants from other modules be accessed even when they should be private, bypassing module encapsulation? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_name() - spec vars] [Ghost memory access] Does spec variable translation through ghost memory properly isolate ghost state from execution state, or can they interact in unsafe ways? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_name() - inline functions] [Inline expansion safety] Does inline function handling prevent recursive inline expansion that could cause infinite loop or stack overflow? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_special_function_name()] [Lambda wrapper safety] Can the lambda wrapper for special vector functions capture incorrect context or have wrong variance, causing type safety violations? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - had_errors] [Error state corruption] Can the RefCell-wrapped had_errors flag be borrowed mutably in nested contexts, causing panic or leaving translator in inconsistent state? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: new_error_exp()] [Error propagation] Do error expressions properly poison type checking, or can they unify with any type, potentially hiding security-critical type errors? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: report_unification_error()] [Error message injection] Can malformed type names in error messages cause terminal escape sequence injection or other information disclosure? (Low)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: error_with_notes_and_labels()] [Error accumulation] Can excessive errors accumulate unbounded, causing memory exhaustion when malformed code generates thousands of cascading errors? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_call() - inline variance] [Variance violation] Does inline function variance checking properly prevent covariant/contravariant misuse that could allow invalid type substitutions? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - fun_is_inline field] [Inline state tracking] Can fun_is_inline state become stale during nested function translation, causing variance to be incorrectly computed for nested calls? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_fun_call_special_cases() - function pointers] [Function pointer safety] Can function pointer table entries be corrupted, causing invocation to call wrong function with incompatible signature? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpTranslator - called_spec_funs] [Spec function tracking] Can the called_spec_funs set be manipulated to hide spec function calls, causing verification to miss critical specifications? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_macro_call()] [Macro expansion safety] Does macro expansion properly prevent recursive or deeply nested macros from causing stack overflow or exponential expansion? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_macro_call() - type arguments] [Macro type confusion] Can macros that shouldn't accept type arguments be given type arguments through parsing ambiguities, causing type confusion? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: expand_macro()] [Macro hygiene] Does macro expansion maintain proper hygiene, or can expanded macro code capture variables from the call site that should be inaccessible? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_fun_call() - old handling] [Temporal logic bypass] Can nested old() expressions bypass the InsideOld check through indirect function calls, allowing invalid temporal references? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: OldExpStatus] [Old status tracking] Can old_status state machine be corrupted through exception paths or early returns, leaving status in InsideOld when it should be OutsideOld? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: lookup_local() - old parameter] [Old variable access] Does old parameter tracking properly prevent accessing mutable variables in old context, which could violate snapshot semantics? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Trait: AbilityContext - struct_signature()] [Ability inference] Can ability inference for struct instantiation produce weaker abilities than required, allowing structs without 'key' to be treated as resources? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: add_type_param_constraints() - spec mode] [Spec mode bypass] Does spec mode skip ability constraints that are security-critical, allowing specs to assume abilities that aren't actually present? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_type() - vector constraints] [Vector ability propagation] Are ability constraints properly propagated to vector element types, or can vectors of non-storable types be created? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Cast] [Cast safety] Does cast operation properly restrict conversions to numeric types only, or can casts be used to reinterpret bit patterns of arbitrary types? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Cast constraint] [Cast domain] Can cast operations accept source types that aren't actually numbers, such as addresses or bools, causing invalid conversions? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Annotate] [Type annotation override] Can type annotations force incorrect types on expressions, bypassing normal type inference and creating type confusion? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Return] [Return type mismatch] Can return expressions in lambdas vs functions get confused, causing wrong result_type to be validated and allowing type mismatches? (High)"
]