[
  "[File: aptos-core/storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs] [Error handling] [Anyhow error downcasting] The HashReader::get() returns anyhow::Error - can error details leak sensitive information about tree structure or DB internals? (Low)",
  "[File: aptos-core/storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs] [\n\n### Citations\n\n**File:** storage/aptosdb/src/ledger_db/transaction_accumulator_db.rs (L1-201)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::schema::{\n    db_metadata::{DbMetadataKey, DbMetadataSchema, DbMetadataValue},\n    transaction_accumulator::TransactionAccumulatorSchema,\n    transaction_accumulator_root_hash::TransactionAccumulatorRootHashSchema,\n};\nuse anyhow::anyhow;\nuse aptos_accumulator::{HashReader, MerkleAccumulator};\nuse aptos_crypto::{\n    hash::{CryptoHash, TransactionAccumulatorHasher},\n    HashValue,\n};\nuse aptos_schemadb::{batch::SchemaBatch, DB};\nuse aptos_storage_interface::Result;\nuse aptos_types::{\n    proof::{\n        definition::LeafCount, position::Position, AccumulatorConsistencyProof,\n        TransactionAccumulatorProof, TransactionAccumulatorRangeProof,\n    },\n    transaction::{TransactionInfo, Version},\n};\nuse std::{borrow::Borrow, path::Path, sync::Arc};\n\npub(crate) type Accumulator =\n    MerkleAccumulator<TransactionAccumulatorDb, TransactionAccumulatorHasher>;\n\n#[derive(Debug)]\npub(crate) struct TransactionAccumulatorDb {\n    db: Arc<DB>,\n}\n\nimpl TransactionAccumulatorDb {\n    pub(super) fn new(db: Arc<DB>) -> Self {\n        Self { db }\n    }\n\n    pub(super) fn create_checkpoint(&self, path: impl AsRef<Path>) -> Result<()> {\n        self.db.create_checkpoint(path)\n    }\n\n    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {\n        self.db.put::<DbMetadataSchema>(\n            &DbMetadataKey::TransactionAccumulatorPrunerProgress,\n            &DbMetadataValue::Version(version),\n        )\n    }\n\n    pub(super) fn db(&self) -> &DB {\n        &self.db\n    }\n\n    pub(crate) fn write_schemas(&self, batch: SchemaBatch) -> Result<()> {\n        self.db.write_schemas(batch)\n    }\n}\n\nimpl TransactionAccumulatorDb {\n    /// Returns frozen subtree root hashes of the accumulator, from left to right.\n    pub fn get_frozen_subtree_hashes(&self, num_transactions: LeafCount) -> Result<Vec<HashValue>> {\n        Accumulator::get_frozen_subtree_hashes(self, num_transactions).map_err(Into::into)\n    }\n\n    /// Returns proof for transaction at `version` towards root of ledger at `ledger_version`.\n    pub fn get_transaction_proof(\n        &self,\n        version: Version,\n        ledger_version: Version,\n    ) -> Result<TransactionAccumulatorProof> {\n        Accumulator::get_proof(self, ledger_version + 1 /* num_leaves */, version)\n            .map_err(Into::into)\n    }\n\n    /// Returns proof for `num_txns` consecutive transactions starting from `start_version` towards\n    /// root of ledger at `ledger_version`.\n    pub fn get_transaction_range_proof(\n        &self,\n        start_version: Option<Version>,\n        num_txns: u64,\n        ledger_version: Version,\n    ) -> Result<TransactionAccumulatorRangeProof> {\n        Accumulator::get_range_proof(\n            self,\n            ledger_version + 1, /* num_leaves */\n            start_version,\n            num_txns,\n        )\n        .map_err(Into::into)\n    }\n\n    /// Returns proof that shows the ledger at `ledger_version` is consistent with the ledger at\n    /// `client_known_version`.\n    pub fn get_consistency_proof(\n        &self,\n        client_known_version: Option<Version>,\n        ledger_version: Version,\n    ) -> Result<AccumulatorConsistencyProof> {\n        let client_known_num_leaves = client_known_version\n            .map(|v| v.saturating_add(1))\n            .unwrap_or(0);\n        let ledger_num_leaves = ledger_version.saturating_add(1);\n        Accumulator::get_consistency_proof(self, ledger_num_leaves, client_known_num_leaves)\n            .map_err(Into::into)\n    }\n\n    /// Saves a batch of txn_info hashes starting from `first_version` in accumulator.\n    pub fn put_transaction_accumulator(\n        &self,\n        first_version: Version,\n        txn_infos: &[impl Borrow<TransactionInfo>],\n        transaction_accumulator_batch: &mut SchemaBatch,\n    ) -> Result<HashValue> {\n        let txn_hashes: Vec<HashValue> = txn_infos.iter().map(|t| t.borrow().hash()).collect();\n\n        let (root_hash, writes) = Accumulator::append(\n            self,\n            first_version, /* num_existing_leaves */\n            &txn_hashes,\n        )?;\n        writes.iter().try_for_each(|(pos, hash)| {\n            transaction_accumulator_batch.put::<TransactionAccumulatorSchema>(pos, hash)\n        })?;\n\n        Ok(root_hash)\n    }\n\n    /// Returns the root hash at given `version`.\n    pub fn get_root_hash(&self, version: Version) -> Result<HashValue> {\n        if let Some(hash) = self\n            .db\n            .get::<TransactionAccumulatorRootHashSchema>(&version)?\n        {\n            return Ok(hash);\n        }\n        Accumulator::get_root_hash(self, version + 1).map_err(Into::into)\n    }\n\n    /// Deletes the transaction accumulator between a range of version in [begin, end).\n    ///\n    /// To avoid always pruning a full left subtree, we uses the following algorithm.\n    /// For each leaf with an odd leaf index.\n    /// 1. From the bottom upwards, find the first ancestor that's a left child of its parent.\n    /// (the position of which can be got by popping"
]