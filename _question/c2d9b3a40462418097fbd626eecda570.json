[
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [OnChainConfig trait] [Identifier collision] At lines 289-292, Features implements OnChainConfig with MODULE_IDENTIFIER = 'features' and TYPE_IDENTIFIER = 'Features'. Can another malicious module register the same identifiers, causing feature flag state to be overwritten by attacker-controlled data? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [ChangeSet validation] At lines 498-504, the ChangeSet uses Op::New() to initialize Features at CORE_CODE_ADDRESS. Is there validation preventing multiple genesis initializations? Can an attacker call this multiple times to reset feature flags mid-operation, causing state inconsistency? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Bitset padding] If the features vector has trailing zero bytes, does this affect feature flag interpretation? Can an attacker pad the vector with zeros or ones to manipulate high-index features that haven't been officially defined yet, pre-enabling future flags? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Canonical representation] Two Features instances with different vector lengths but same enabled flags (e.g., [0xFF] vs [0xFF, 0x00, 0x00]) are semantically equivalent. Can this non-canonical representation cause hash mismatches in Merkle tree storage, leading to state commitment failures? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Derive macros] [Ordering exploits] The Features struct derives PartialOrd and Ord at line 270. How is Vec<u8> ordering defined? Can an attacker exploit lexicographic ordering to force their malicious Features config to be selected in consensus ordering, overriding legitimate feature flags? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable() & disable()] [TOCTOU race] If one thread calls is_enabled() to check RESOURCE_GROUPS while another thread concurrently calls disable(RESOURCE_GROUPS), can the TOCTOU (Time-of-Check-Time-of-Use) race condition cause validators to execute transactions with inconsistent feature states, leading to state divergence and consensus failure? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Concurrent resize] If two threads simultaneously call enable() for features requiring different vector sizes (e.g., flag 40 and flag 100), can the resize_for_flag() while loop at lines 307-309 cause one resize to overwrite another, resulting in lost feature flag states? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: into_flag_vec()] [Concurrent modification] The into_flag_vec() method at lines 323-332 consumes self and iterates over the features vector. If the Features struct is cloned and modified concurrently during iteration, can this cause non-deterministic feature flag enumeration across validators? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_enabled()] [Unsafe concurrent read] At line 338, is_enabled() reads `self.features[byte_index]` without synchronization. If another thread is concurrently modifying this byte via enable() or disable(), can the read observe a partially-written byte value (torn read), returning incorrect feature states? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default()] [Initialization race] At lines 276-286, default() creates a new Features instance and enables multiple flags. If validators call this concurrently during startup, can race conditions in enable() cause different validators to initialize with different default feature sets, immediately forking the chain at genesis? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: get_max_binary_format_version()] [Non-atomic checks] At lines 478-490, the function checks multiple feature flags sequentially (V9, V8, V7, V6). If feature flags are being modified concurrently, can this function observe an inconsistent snapshot (e.g., V9 enabled but V8 disabled) that doesn't correspond to any actual state, causing bytecode version confusion? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [No synchronization primitives] The Features struct has no Mutex, RwLock, or atomic operations. If multiple threads on a validator node read and write Features concurrently (e.g., during reconfiguration), can this cause data races leading to UB (undefined behavior) in Rust and memory corruption? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_aggregator_v2_delayed_fields_enabled()] [Compound check race] At lines 378-379, this function checks two flags with AND logic. If one flag is disabled between the two checks, can validators observe inconsistent compound states, enabling parallel execution without proper VM change set splitting and causing state corruption? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable()] [Lost update problem] If thread A reads byte_index, thread B modifies that byte, then thread A writes its modified value, thread B's changes are lost. Can this lost update problem during concurrent feature flag modifications cause critical security features to remain disabled despite governance attempts to enable them? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: disable()] [ABA problem] If a feature is enabled (A), then disabled (B), then re-enabled (A) across multiple threads rapidly, can observers see inconsistent state transitions that violate feature dependency requirements, such as disabling MODULE_EVENT while EMIT_FEE_STATEMENT believes it's still enabled? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: into_flag_vec()] [Unwrap panic] At line 330, `.unwrap()` is called on `FeatureFlag::from_repr(feature_idx)`. If the features vector contains bits set for undefined feature indices (> 105), this will panic. Can an attacker craft a Features instance with high bits set to cause all validators to panic during feature enumeration, halting the network? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [Expect panic] At line 504, `.expect()` is called on change_set.add_resource_op(). What failure conditions could trigger this expect? Can an attacker trigger this panic during genesis initialization to prevent network bootstrap? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [Unwrap on serialization] At line 494, `bcs::to_bytes(&Features::default_for_tests()).unwrap()` could fail if the Features struct exceeds BCS size limits. Can this cause genesis initialization to panic, preventing network startup and creating a permanent DoS condition? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable() & disable()] [Index panic] Although resize_for_flag() extends the vector, if there's a race condition or logic error, could `self.features[byte_index]` at lines 315 and 320 still panic with index out of bounds, causing validator crashes during feature flag updates? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: is_enabled()] [No panic guard] At line 338, the function accesses `self.features[byte_index]` after checking `byte_index < self.features.len()`. Is this bounds check sufficient? If byte_index equals usize::MAX due to integer overflow, could this cause a panic even after the bounds check? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: into_flag_vec()] [Arithmetic panic] At line 327, `(0..8).map(move |bit_idx| byte & (1 << bit_idx) != 0)` performs left shift. If bit_idx somehow exceeds 7 due to a bug, this could cause arithmetic overflow panic in debug mode. Can this be exploited to crash validators? (Low)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: resize_for_flag()] [Allocation failure] The while loop at lines 307-309 pushes bytes without checking allocation success. On systems with memory limits, can an attacker trigger OOM by requesting extremely high feature indices, causing the allocator to panic and crash the validator? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default()] [Enable panic cascade] At lines 282-284, default() calls enable() for each default feature. If any enable() call panics (due to bugs in resize_for_flag), does this prevent Features initialization, causing all validators to crash on startup and permanent network unavailability? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: get_max_binary_format_version()] [Unreachable version] At line 488, if all VM_BINARY_FORMAT flags are disabled, the function returns VERSION_5. Is VERSION_5 still supported? Can forcing all validators to use VERSION_5 through governance disable critical security patches in newer versions, enabling exploitation of known VM vulnerabilities? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag enum] [FromRepr None case] The from_repr() call at line 330 returns Option<FeatureFlag>. While unwrap() is used, what happens if an invalid repr value is provided? Can attackers craft Features with invalid enum values to cause panics during normal operation? (High)"
]