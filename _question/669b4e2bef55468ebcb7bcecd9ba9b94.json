[
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Vector creation] [Element type confusion] Can vector literals with mixed element types bypass type checking when elem_ty is a free variable, allowing heterogeneous vectors that violate type safety? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - IfElse] [Branch type confusion] Does if-else expression properly freeze references in branches when joining types, or can one branch return &mut T while another returns &T, causing the joined type to incorrectly permit mutations? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_lvalue()] [Pattern exhaustiveness] Can non-exhaustive pattern matches be accepted in let bindings or match arms, allowing runtime failures when no pattern matches the discriminator? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_lvalue_unpack()] [Field access bypass] Does struct unpacking properly validate that all accessed fields exist and have correct types, or can malformed patterns access uninitialized memory or wrong field offsets? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: check_duplicate_assign()] [Double-free analog] Can duplicate pattern variables cause the same value to be moved or dropped multiple times, violating Move's linear type system and potentially causing double-free style bugs? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_match()] [Match arm type confusion] When joining types across match arms, can the frozen reference logic be bypassed to allow mutable access through ostensibly immutable match results? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_lambda()] [Capture escaping] Does lambda capture validation properly prevent capturing references that outlive the lambda's lifetime, potentially causing use-after-free when the lambda is invoked? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_lambda() - spec_lambda_map] [Map corruption] Can concurrent translation of multiple lambdas corrupt the spec_lambda_map, causing type information from one lambda to leak into another? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: LambdaCaptureKind] [Capture kind bypass] Can the Copy vs Move capture distinction be violated, allowing non-copyable values to be captured by copy or vice versa, breaking Move's ownership semantics? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: check_lambda_types()] [Reference-to-reference] Does the check at line 2393-2403 properly prevent all indirect ways of creating reference-to-reference through lambda type parameters or result types? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_call()] [Overload confusion] Can ambiguous overload resolution be exploited to call the wrong function variant, potentially invoking a less restrictive or malicious function instead of the intended one? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_call() - candidate matching] [Arity bypass] Does parameter count checking handle variadic functions or default arguments correctly, or can mismatched arity slip through when type inference is involved? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: prioritize_overloads()] [Priority manipulation] Can the equality overload prioritization be manipulated to prefer reference equality over value equality, causing unexpected behavior in comparisons? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_receiver_call()] [Receiver type confusion] Can receiver-style function calls be resolved to functions that expect different receiver types, bypassing access control or calling functions on inappropriate objects? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_pack()] [Field initialization] Can struct packing succeed with uninitialized or missing fields when using positional constructor syntax, creating invalid struct values? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_pack() - field bindings] [Evaluation order] Does the binding transformation for out-of-order fields preserve side effects correctly, or can reordering cause observable differences in behavior or security violations? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: check_missing_or_undeclared_fields()] [Empty struct bypass] Can the dummy_field handling for empty structs be exploited to access or modify the hidden boolean field, potentially corrupting struct metadata? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_constructor_name()] [Variant confusion] Can enum variant resolution be confused with struct names, allowing construction of wrong types or accessing fields that don't exist in the actual variant? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_fun_call_special_cases()] [Builtin bypass] Can the special case handling for builtins like 'update_field' be bypassed or confused, allowing invalid field updates or operations that should be restricted? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_update_field()] [Field mutation safety] Does update_field properly validate immutability constraints, or can it be used to modify fields that should be read-only based on reference types? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_index()] [Index bounds] Can vector or resource indexing operations bypass bounds checking in the type system, allowing out-of-bounds access to be validated at compile time? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: try_resource_or_vector_index()] [Resource access control] Does resource indexing with borrow_global properly validate Key ability, or can non-resource types be accessed as if they were global resources? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Borrow] [Reference validity] Can the borrow operation create references to temporary values or expressions that don't have stable addresses, causing undefined behavior? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Dereference] [Null reference] While Move doesn't have null, can malformed reference types or type confusion create situations where dereferencing accesses invalid memory? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: try_freeze()] [Freeze bypass] Can the automatic freeze insertion be bypassed or incorrectly applied, allowing mutable references to be used where immutable ones are expected without proper conversion? (High)"
]