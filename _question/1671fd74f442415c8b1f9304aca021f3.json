[
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Integer overflow] In line 57, the conversion `txn.info.version.0 as i64` casts u64 to i64 without checking if the value exceeds i64::MAX (9,223,372,036,854,775,807). Can an attacker exploit a transaction with version >= 2^63 to cause integer overflow, resulting in negative version numbers that corrupt the database indexing and potentially enable double-spending through version collision? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Integer truncation] In line 62, `txn.epoch.0 as i64` converts epoch number from u64 to i64. Can a malicious validator or consensus bug produce an epoch number >= 2^63 that wraps to a negative value, causing epoch regression in the database that breaks epoch-based queries and validator set transitions? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Integer truncation] In line 63, `txn.round.0 as i64` converts round number from u64 to i64. Can an attacker exploit extremely high round numbers (>= 2^63) to cause round number wrap-around, resulting in incorrect round ordering in the database that breaks consensus history analysis and fork detection? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Data loss] The version field conversion at line 57 silently truncates the upper bit of u64 values. Can this truncation cause two different blockchain versions (differing only in the 64th bit) to map to the same i64 database key, creating a primary key collision that prevents indexing of valid blocks? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Consensus integrity] If epoch or round numbers overflow from positive to negative in lines 62-63, can this enable an attacker to forge historical consensus data by inserting block metadata with manipulated negative epochs/rounds that appear to precede genesis? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Struct: BlockMetadataTransaction] [Type mismatch] The block_height parameter is passed as i64 but blockchain heights are naturally unsigned. Can negative block_height values in line 60 bypass database constraints or create inconsistencies between the transactions table and block_metadata_transactions table? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Arithmetic overflow] In timestamp parsing at line 69, if parse_timestamp receives a u64 timestamp near u64::MAX from txn.timestamp.0, can the microsecond-to-second conversion cause arithmetic overflow that panics the indexer or produces incorrect timestamp values? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Boundary condition] Can an attacker submit a BlockMetadataTransaction with version = 2^63 - 1 (i64::MAX) that successfully indexes, then submit version = 2^63 which wraps to i64::MIN, creating a massive backward jump in version ordering that corrupts transaction history? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Panic/DoS] Line 65 uses `.unwrap()` on `serde_json::to_value(&txn.failed_proposer_indices)`. Can an attacker craft a BlockMetadataTransaction with a maliciously large or deeply nested failed_proposer_indices Vec<u32> that causes JSON serialization to fail, panicking the indexer and causing denial of service? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Panic/DoS] Line 66-67 uses `.unwrap()` on `serde_json::to_value(&txn.previous_block_votes_bitvec)`. Can an attacker manipulate the vote bitvector (Vec<u8>) to include values or structures that cause JSON serialization to panic, crashing the indexer and preventing block metadata indexing? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Memory exhaustion] If failed_proposer_indices in line 65 contains billions of u32 values, can the JSON serialization consume excessive memory causing OOM crashes that halt indexer operations and prevent historical data queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Memory exhaustion] If previous_block_votes_bitvec in line 66 is an extremely large Vec<u8> (e.g., 100MB+ of vote data), can the JSON conversion allocate unbounded memory causing indexer crashes and service unavailability? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Serialization failure] Can special byte sequences in previous_block_votes_bitvec (e.g., invalid UTF-8, control characters) cause serde_json::to_value to fail with an error that the unwrap() converts to a panic, crashing the indexer? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Resource exhaustion] If an attacker causes repeated JSON serialization panics by submitting malformed block metadata every block, can this prevent the indexer from ever catching up to chain tip, effectively DOS-ing all historical data queries? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Address manipulation] Line 64 calls `standardize_address(&txn.proposer.inner().to_hex_literal())`. The standardize_address function pads addresses to 66 characters. Can an attacker submit a proposer address shorter than expected that gets incorrectly padded, creating a different address that bypasses proposer validation and attribution? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Input validation] The standardize_address function at line 64 assumes input starts with '0x' and performs `&handle[2..]`. Can a proposer address without '0x' prefix cause a panic or incorrect string slicing that corrupts the proposer field in the database? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [String length violation] The proposer field is VARCHAR(66) in the database schema. If standardize_address produces a string != 66 characters due to a bug, can this cause database insertion failures that halt indexer progress? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Address collision] If standardize_address has a bug where different input addresses produce the same 66-character output (e.g., through incorrect padding), can this cause attribution errors where blocks are incorrectly associated with the wrong proposer? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Malformed input] Can an attacker provide a proposer address with special characters or escape sequences that survive to_hex_literal() conversion and cause SQL injection when inserting into the proposer VARCHAR field? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Struct: BlockMetadataTransaction] [Data integrity] If the proposer string at line 30 contains null bytes or invalid UTF-8 sequences after standardize_address processing, can this cause database constraint violations or data corruption in PostgreSQL? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Panic/DoS] Line 69 calls `parse_timestamp(txn.timestamp.0, txn_version)` which can panic if the timestamp is invalid. Can an attacker submit a BlockMetadataTransaction with timestamp > MAX_TIMESTAMP_SECS causing parse_timestamp to panic and crash the indexer? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Time manipulation] If parse_timestamp at line 69 receives a timestamp far in the future (e.g., year 10000), can this create database entries with invalid timestamps that break time-based queries and analytics? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Timestamp overflow] The parse_timestamp function divides by 1000000 to convert microseconds to seconds. Can a timestamp value near u64::MAX cause arithmetic overflow during this conversion that produces incorrect chrono::NaiveDateTime values? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Nanosecond conversion] In parse_timestamp, the nanosecond calculation `(ts % 1000000 * 1000).try_into().unwrap()` can panic. Can an attacker craft a timestamp where this conversion fails, causing indexer crashes? (High)",
  "[File: aptos-core/crates/indexer/src/models/block_metadata_transactions.rs] [Function: from_transaction()] [Timestamp regression] Can negative or zero timestamps in txn.timestamp.0 pass through to parse_timestamp causing it to panic with 'Could not parse timestamp' and halt indexer operations? (Medium)"
]