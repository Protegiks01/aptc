[
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Memory allocation DoS] The function allocates a new vector at line 133 with size (j-i) - can attackers exploit this by requesting maximum-size substrings repeatedly to exhaust validator memory and cause OOM crashes? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Usize truncation] The casts 'as usize' at lines 119-120 truncate u64 values - can attackers on 32-bit systems provide i or j > usize::MAX to cause truncation and incorrect substring extraction? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Type safety] Does the VectorRef guarantee that the underlying vector hasn't been moved or invalidated, or can attackers trigger use-after-free by deallocating the vector before this function accesses it? (Critical)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Iterator exhaustion] The iter().cloned() chain at line 133 - can malicious input cause this iterator to consume excessive CPU time on pathological UTF-8 sequences, degrading validator performance? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Determinism with edge cases] When i==j (empty substring), does the function behave deterministically across all validators, or can edge cases in empty vector creation cause consensus divergence? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [Gas front-running] Since gas is charged after the substring operation completes, can attackers submit transactions that fail mid-operation but consume validator CPU without paying full gas costs? (Low)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_sub_string()] [TODO comment security] The TODO comment at line 123 about abort codes - can the absence of proper abort code handling be exploited to cause incorrect error propagation in Move contracts? (Low)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Algorithm complexity attack] The TODO comment at line 177-178 questions the search algorithm - if Rust's str::find() uses naive search with O(n*m) complexity instead of KMP, can attackers craft pathological pattern/text pairs to cause validator CPU exhaustion? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Gas miscalculation] The gas calculation at line 179-181 only charges for 'pos' bytes searched, but if the search scans the entire string before failing, can attackers exploit this undercharging to perform expensive searches while paying minimal gas? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [ReDoS-style attack] Can attackers submit patterns and strings that cause exponential backtracking in the underlying search algorithm, similar to regex DoS attacks, causing validator performance degradation? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Unsafe UTF-8 assumption] Both from_utf8_unchecked() calls at lines 169 and 172 assume valid UTF-8 - can attackers bypass validation and cause undefined behavior by calling this function on non-validated strings? (Critical)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Integer overflow in gas] Can the multiplication 'gas_params.per_byte_pattern * NumBytes::new(r_str.len() as u64)' overflow if the pattern is extremely large, causing incorrect gas calculation? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Type confusion] The function returns s_str.len() when pattern not found - can this cause confusion in Move contracts expecting different sentinel values, leading to incorrect logic execution? (Low)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Cast overflow] The cast 'pos as u64' at line 182 - on systems where usize > u64 bits, can extremely large position values get truncated, causing incorrect results? (Low)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Empty pattern behavior] How does str::find() behave with empty patterns - can attackers exploit edge cases where empty pattern always matches at position 0 to bypass intended validation logic? (Low)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Determinism in search] Are there platform-specific differences in how Rust's str::find() implements pattern matching that could cause different validators to return different positions? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Memory exhaustion] Can attackers submit extremely long strings and patterns that cause str::find() to allocate excessive temporary memory during the search operation, crashing validators? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [VectorRef invalidation] Can the VectorRef references for both r_arg and s_arg be invalidated between the pop_arg calls and the actual search, causing use-after-free vulnerabilities? (Critical)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Function: native_index_of()] [Argument ordering attack] Arguments are popped in order r_arg then s_arg (lines 167-171) - can stack manipulation in the Move VM cause these to be swapped, leading to incorrect search results? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: CheckUtf8GasParameters] [Gas parameter manipulation] Can governance proposals set gas_params.base or gas_params.per_byte to zero, allowing free UTF-8 validation and enabling spam attacks on validators? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: CheckUtf8GasParameters] [Integer overflow in gas] Can extremely large per_byte values cause integer overflow when multiplied by string length, leading to wraparound and undercharging? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: IsCharBoundaryGasParameters] [Flat fee vulnerability] The function only charges base gas - can attackers exploit this flat pricing to check char boundaries on arbitrarily large strings without proportional cost? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: SubStringGasParameters] [Gas pricing mismatch] Does the per_byte gas accurately reflect the actual CPU cost of substring extraction, or is it underpriced allowing attackers to extract substrings cheaply? (Medium)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: IndexOfGasParameters] [Three-parameter complexity] With base + per_byte_pattern + per_byte_searched, can attackers exploit the complex gas calculation to find scenarios where actual cost exceeds charged gas? (High)",
  "[File: third_party/move/move-stdlib/src/natives/string.rs] [Struct: GasParameters] [Deserialization attack] Can attackers manipulate the GasParameters struct during deserialization from chain configuration to inject malicious gas values? (Medium)"
]