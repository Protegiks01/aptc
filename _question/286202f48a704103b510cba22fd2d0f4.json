[
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_total_staked_amount()] [Integer overflow] Can an attacker cause integer overflow by manipulating active, inactive, pending_active, and pending_inactive values such that their sum exceeds u64::MAX, resulting in wrapping behavior that corrupts total stake calculations and enables fund theft? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_total_staked_amount()] [Integer overflow] Does the addition `self.active + self.inactive + self.pending_active + self.pending_inactive` use checked arithmetic, or can overflow during reward distribution cause the total staked amount to wrap to a small value, allowing withdrawal of more funds than deposited? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_total_staked_amount()] [Arithmetic manipulation] Can a malicious validator or delegator set individual stake fields (active, pending_active, etc.) to values near u64::MAX to trigger overflow in the summation, causing the function to return incorrect totals that break stake accounting? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_total_staked_amount()] [State corruption] If multiple stake operations occur concurrently (adding stake, unlocking stake, distributing rewards), can race conditions cause the sum calculation to read inconsistent intermediate states, returning an incorrect total that violates stake invariants? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_governance_voting_power()] [Integer overflow] Can the calculation `self.active + self.pending_active + self.pending_inactive` overflow when processing large reward distributions, causing voting power to wrap to a small value and enabling governance takeover with minimal actual stake? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_governance_voting_power()] [Voting manipulation] Does the voting power calculation exclude inactive stake correctly, or can an attacker manipulate the pending_inactive field to artificially inflate voting power while maintaining the ability to withdraw funds, breaking the economic security model? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_governance_voting_power()] [Governance takeover] Can a validator set pending_active and pending_inactive to maximum values (u64::MAX - epsilon) such that their sum overflows, resulting in near-zero voting power being reported while they maintain actual control over the stake? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Function: get_governance_voting_power()] [Arithmetic attack] If active stake is u64::MAX and pending_active is non-zero, will the addition overflow and wrap, causing the validator's voting power to be incorrectly calculated as a small value despite controlling maximum stake? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: active] Can the active stake field be directly manipulated through unsafe deserialization or memory corruption to artificially inflate a validator's stake without actual funds deposited, enabling consensus takeover or reward theft? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: inactive] Can the inactive field be set to u64::MAX through malicious state updates, causing subsequent additions in get_total_staked_amount() to overflow and corrupt the total stake calculation? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: pending_active] Can an attacker exploit pending_active transitions by repeatedly adding and canceling stake operations to cause integer overflow in the field itself, corrupting the stake pool state? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: pending_inactive] Does pending_inactive properly track unlocking requests, or can concurrent unlock operations cause this field to exceed the sum of active + pending_active, violating stake conservation and enabling double-withdrawal? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: locked_until_secs] Can the locked_until_secs timestamp be manipulated to a value in the distant past or set to u64::MAX, either enabling immediate unauthorized withdrawals or permanently locking funds that require a hardfork to recover? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: locked_until_secs] Does the timestamp validation prevent time-based attacks where an attacker sets locked_until_secs to 0 to bypass lock periods, or to u64::MAX to permanently freeze validator stake and cause liveness issues? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: operator_address] Can the operator_address be changed to an attacker-controlled address without proper authorization checks in the Move module, allowing unauthorized rotation of consensus keys and network addresses to hijack the validator? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: delegated_voter] Can an attacker exploit the delegated_voter field by setting it to their own address in a governance proposal that bypasses voting checks, effectively stealing voting power from legitimate stakers? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: operator_address] If operator_address is set to address zero (0x0) through malicious deserialization, can this cause undefined behavior in consensus key operations or network messaging that crashes validator nodes? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: delegated_voter] Can delegated_voter be set to the same address as operator_address or pool owner, creating conflicts in the governance system where a single entity controls both staking and voting operations? (Medium)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State invariant] Can the sum `active + inactive + pending_active + pending_inactive` decrease without corresponding withdrawals, indicating fund loss through state corruption or arithmetic underflow in Move module operations? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State invariant] Is the invariant `pending_inactive <= active + pending_active` enforced, or can unlock operations set pending_inactive to exceed available stake, enabling withdrawal of more funds than deposited? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State invariant] Can active and pending_active both be non-zero after epoch transition, violating the expected state machine where pending_active should move to active atomically, causing double-counting of stake? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State invariant] If locked_until_secs is in the past but inactive and pending_inactive are both non-zero, does this indicate a failed unlock operation that has left the pool in an inconsistent state with stuck funds? (High)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State transition] During reward distribution, can the increase to active stake overflow if accumulated rewards are large, causing the active field to wrap and resulting in apparent loss of stake that enables theft? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [State transition] When transitioning from pending_active to active during epoch change, can a race condition cause the same stake to be counted in both fields simultaneously, doubling the validator's effective stake and voting power? (Critical)",
  "[File: aptos-core/types/src/stake_pool.rs] [Struct: StakePool] [Field: initialize_validator_events] Can an attacker forge or replay initialize_validator_events by manipulating the EventHandle counter, allowing them to register multiple validator instances for the same stake pool and cause consensus confusion? (High)"
]