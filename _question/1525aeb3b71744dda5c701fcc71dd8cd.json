[
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Argument Order] Can the VecDeque at line 34 have arguments in wrong order due to stack manipulation, causing safely_pop_arg! at line 47 to extract the wrong value? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [VecDeque Manipulation] Can an attacker manipulate the VecDeque at line 65 between function entry and argument extraction at line 78 to inject malicious arguments? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Argument Extraction Order] Do lines 111-112 pop arguments in the correct order from the VecDeque, or can reversed order cause master and permission addresses to be swapped? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Empty VecDeque] Can the VecDeque at line 131 be empty despite the assertion at line 134, causing safely_pop_arg! at line 136 to panic or access invalid memory? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Context Mutation] Can the SafeNativeContext at line 32 be mutated by concurrent transactions in a way that affects gas charging at line 49 or feature flag checks at line 38? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Gas Schedule Corruption] Can the gas schedule be corrupted between lines 80 and actual charging, causing PERMISSION_ADDRESS_BASE to be read as an invalid value that causes arithmetic overflow? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Context Isolation] Does the SafeNativeContext at line 96 properly isolate between transactions in parallel execution, or can context pollution cause gas to be charged to wrong transaction? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Feature Flag Staleness] Can the feature flag check at lines 138-141 return stale data from context cache, allowing the function to proceed with outdated feature flag state? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Non-Determinism] Can the is_permissioned() call at line 50 return different results on different validators due to race conditions, causing state root divergence and consensus failure? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Determinism] Is permission_address() at line 85 guaranteed to be deterministic across all validators, or can hardware differences or timing cause different addresses to be returned? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Consensus Divergence] If Value::permissioned_signer() at lines 115-118 uses non-deterministic operations (random IDs, timestamps), can validators create different signers causing state divergence? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [State Root Mismatch] Can differences in borrow_signer() implementation at line 150 across validator versions cause different addresses to be returned, leading to consensus failures? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Replay Attack] Can transactions creating permissioned signers at lines 95-119 be replayed across different epochs or chains to create unauthorized signers in different contexts? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Reordering Attack] If permission address queries at lines 62-86 can be reordered relative to signer creation, can attackers query addresses before signers are properly initialized? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Flag Toggle] Can rapid toggling of PERMISSIONED_SIGNER feature flag at lines 38-45 between transactions in the same block cause some transactions to execute with feature enabled and others disabled, breaking atomicity? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Feature Race] Between feature flag check at lines 69-76 and actual operation at line 81-85, can the feature flag be disabled causing inconsistent execution state? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Flag Synchronization] Do all validators see the same feature flag state at lines 102-109 during block execution, or can network delays cause some validators to execute with old flag values? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Compound Condition] Can the complex AND condition at lines 138-146 involving feature flag and is_permissioned create race windows where the flag changes between the two checks? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Abort Code Overflow] Can EPERMISSION_SIGNER_DISABLED (value 9) at line 22 overflow when combined with other error codes in composite error handling, causing wrong error interpretation? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Magic Number] Can abort_code 3 at line 82 be manipulated through integer overflow in error handling logic to become a different error code? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: make_all()] [Initialization Order] Can the native function registration at lines 157-178 occur before required dependencies are initialized, causing functions to be called before they're ready? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: make_all()] [Builder Safety] Does the SafeNativeBuilder at line 158 properly validate native function signatures, or can malformed functions be registered that cause crashes when called? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Signature Bypass] Can permissioned signers created at lines 95-119 be used to sign transactions without requiring the master account's private key, enabling unauthorized transaction signing? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Authentication] Does borrowing an address at line 150 maintain authentication properties, or can borrowed addresses be used without proper signature validation? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Storage Corruption] Can permission addresses returned at line 85 point to corrupted storage\n\n### Citations\n\n**File:** aptos-move/framework/src/natives/permissioned_signer.rs (L1-178)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\nuse aptos_gas_schedule::gas_params::natives::{\n    aptos_framework::{\n        IS_PERMISSIONED_SIGNER_BASE, PERMISSION_ADDRESS_BASE, SIGNER_FROM_PERMISSIONED_HANDLE_BASE,\n    },\n    move_stdlib::SIGNER_BORROW_ADDRESS_BASE,\n};\nuse aptos_native_interface::{\n    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeError,\n    SafeNativeResult,\n};\nuse move_core_types::account_address::AccountAddress;\nuse move_vm_runtime::native_functions::NativeFunction;\nuse move_vm_types::{\n    loaded_data::runtime_types::Type,\n    values::{SignerRef, Value},\n};\nuse smallvec::{smallvec, SmallVec};\nuse std::collections::VecDeque;\n\nconst EPERMISSION_SIGNER_DISABLED: u64 = 9;\n\n/***************************************************************************************************\n * native fun is_permissioned_signer_impl\n *\n *   Returns true if the signer passed in is a permissioned signer\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_is_permissioned_signer_impl(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    mut arguments: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(arguments.len() == 1);\n\n    if !context\n        .get_feature_flags()\n        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)\n    {\n        return SafeNativeResult::Err(SafeNativeError::Abort {\n            abort_code: EPERMISSION_SIGNER_DISABLED,\n        });\n    }\n\n    let signer = safely_pop_arg!(arguments, SignerRef);\n\n    context.charge(IS_PERMISSIONED_SIGNER_BASE)?;\n    let result = signer.is_permissioned()?;\n\n    Ok(smallvec![Value::bool(result)])\n}\n\n/***************************************************************************************************\n * native fun permission_address\n *\n *   Returns the permission storage address if the signer passed in is a permissioned signer\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_permission_address(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    mut args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(args.len() == 1);\n\n    if !context\n        .get_feature_flags()\n        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)\n    {\n        return SafeNativeResult::Err(SafeNativeError::Abort {\n            abort_code: EPERMISSION_SIGNER_DISABLED,\n        });\n    }\n\n    let signer = safely_pop_arg!(args, SignerRef);\n\n    context.charge(PERMISSION_ADDRESS_BASE)?;\n    if !signer.is_permissioned()? {\n        return Err(SafeNativeError::Abort { abort_code: 3 });\n    }\n\n    Ok(smallvec![signer.permission_address()?])\n}\n\n/***************************************************************************************************\n * native fun signer_from_permissioned_handle_impl\n *\n *   Returns the permission signer from a master signer.\n *   gas cost: base_cost\n *\n **************************************************************************************************/\nfn native_signer_from_permissioned(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    mut arguments: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(arguments.len() == 2);\n\n    if !context\n        .get_feature_flags()\n        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)\n    {\n        return SafeNativeResult::Err(SafeNativeError::Abort {\n            abort_code: EPERMISSION_SIGNER_DISABLED,\n        });\n    }\n\n    let permission_addr = safely_pop_arg!(arguments, AccountAddress);\n    let master_addr = safely_pop_arg!(arguments, AccountAddress);\n    context.charge(SIGNER_FROM_PERMISSIONED_HANDLE_BASE)?;\n\n    Ok(smallvec![Value::permissioned_signer(\n        master_addr,\n        permission_addr\n    )])\n}\n\n/***************************************************************************************************\n * native fun borrow_address\n *\n *   gas cost: base_cost\n *\n **************************************************************************************************/\n#[inline]\nfn native_borrow_address(\n    context: &mut SafeNativeContext,\n    _ty_args: &[Type],\n    mut arguments: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(_ty_args.is_empty());\n    debug_assert!(arguments.len() == 1);\n\n    let signer_reference = safely_pop_arg!(arguments, SignerRef);\n\n    if !context\n        .get_feature_flags()\n        .is_enabled(aptos_types::on_chain_config::FeatureFlag::PERMISSIONED_SIGNER)\n        && signer_reference.is_permissioned()?\n    {\n        return SafeNativeResult::Err(SafeNativeError::Abort {\n            abort_code: EPERMISSION_SIGNER_DISABLED,\n        });\n    }\n\n    context.charge(SIGNER_BORROW_ADDRESS_BASE)?;\n\n    Ok(smallvec![signer_reference.borrow_signer()?])\n}\n\n/***************************************************************************************************\n * module\n *\n **************************************************************************************************/\npub fn make_all(\n    builder: &SafeNativeBuilder,\n) -> impl Iterator<Item = (String, NativeFunction)> + '_ {\n    let natives = [\n        ("
]