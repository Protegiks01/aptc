[
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Verification Gap] Are there borrow patterns that pass analysis but violate safety at runtime? (Critical)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Analysis Complexity] Can crafted bytecode cause exponential time complexity in borrow analysis? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Memory Usage] Can deeply nested borrows cause unbounded memory usage during analysis? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Fixpoint Iteration] Can fixpoint iteration fail to converge for certain function patterns? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Graph Size] Is there a bound on borrow graph size to prevent memory exhaustion? (Medium)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Parallel Analysis] If functions are analyzed in parallel, can race conditions corrupt shared state? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Parallel Execution] Does borrow analysis account for Block-STM parallel transaction execution? (Critical)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [Overall] [Transaction Isolation] Can concurrent transactions violate borrow safety through shared global state? (Critical)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Direct] [Direct Edge Semantics] Can Direct edges be used to hide complex borrow relationships? (Medium)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Field] [Field Projection] Can field borrows violate struct invariants? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Index] [Vector Bounds] Can index edges be created for out-of-bounds vector access? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Index] [Table Keys] For table index edges, is key existence validated? (High)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Hyper] [Hyper Edge Complexity] Can hyper edges with many flattened edges cause confusion in writeback logic? (Medium)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [BorrowEdge::Invoke] [Invoke Conservatism] Is the conservative Invoke edge handling too permissive? (Medium)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [SetDomain] [Set Operations] Can SetDomain operations (insert, remove, contains) have incorrect semantics? (Medium)",
  "[File: third_party/move/move-model/bytecode/src/borrow_analysis.rs] [MapDomain] [Map Operations] Can MapDomain operations corrupt the internal state? (Medium)",
  "[File: third_party/move/move-model/bytecode/\n\n### Citations\n\n**File:** third_party/move/move-model/bytecode/src/borrow_analysis.rs (L1-869)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! Data flow analysis computing borrow information for preparation of memory_instrumentation.\n\nuse crate::{\n    dataflow_analysis::{DataflowAnalysis, TransferFunctions},\n    dataflow_domains::{AbstractDomain, JoinResult, MapDomain, SetDomain},\n    function_target::{FunctionData, FunctionTarget},\n    function_target_pipeline::{FunctionTargetProcessor, FunctionTargetsHolder, FunctionVariant},\n    livevar_analysis::LiveVarAnnotation,\n    stackless_bytecode::{AssignKind, BorrowEdge, BorrowNode, Bytecode, IndexEdgeKind, Operation},\n    stackless_control_flow_graph::StacklessControlFlowGraph,\n};\nuse abstract_domain_derive::AbstractDomain;\nuse itertools::Itertools;\nuse move_binary_format::file_format::CodeOffset;\nuse move_model::{\n    ast::TempIndex,\n    model::{FunctionEnv, GlobalEnv, QualifiedInstId},\n    pragmas::{INTRINSIC_FUN_MAP_BORROW_MUT, INTRINSIC_FUN_MAP_BORROW_MUT_WITH_DEFAULT},\n    ty::Type,\n    well_known::VECTOR_BORROW_MUT,\n};\nuse std::{borrow::BorrowMut, collections::BTreeMap, fmt};\n\n#[derive(AbstractDomain, Debug, Clone, Eq, Ord, PartialEq, PartialOrd, Default)]\npub struct BorrowInfo {\n    /// Contains the nodes which are alive. This excludes nodes which are alive because\n    /// other nodes which are alive borrow from them.\n    live_nodes: SetDomain<BorrowNode>,\n\n    /// Forward borrow information.\n    borrowed_by: MapDomain<BorrowNode, SetDomain<(BorrowNode, BorrowEdge)>>,\n\n    /// Backward borrow information. This field is not used during analysis, but computed once\n    /// analysis is done.\n    #[no_join]\n    borrows_from: MapDomain<BorrowNode, SetDomain<(BorrowNode, BorrowEdge)>>,\n}\n\n/// Represents a write-back from a source node to a destination node with the associated edge\n#[derive(Debug, Clone, Eq, Ord, PartialEq, PartialOrd)]\npub struct WriteBackAction {\n    /// the `src` of a write-back action must be a reference\n    pub src: TempIndex,\n    pub dst: BorrowNode,\n    pub edge: BorrowEdge,\n}\n\nimpl BorrowInfo {\n    /// Gets the children of this node.\n    fn get_children(&self, node: &BorrowNode) -> Vec<&BorrowNode> {\n        self.borrowed_by\n            .get(node)\n            .map(|s| s.iter().map(|(n, _)| n).collect_vec())\n            .unwrap_or_default()\n    }\n\n    /// Gets the children of this node with edges\n    fn get_children_with_edge(&self, node: &BorrowNode) -> Vec<(&BorrowNode, &BorrowEdge)> {\n        self.borrowed_by\n            .get(node)\n            .map(|s| s.iter().map(|(n, e)| (n, e)).collect_vec())\n            .unwrap_or_default()\n    }\n\n    /// Gets the parents (together with the edges) of this node.\n    fn get_incoming(&self, node: &BorrowNode) -> Vec<(&BorrowNode, &BorrowEdge)> {\n        self.borrows_from\n            .get(node)\n            .map(|s| s.iter().map(|(n, e)| (n, e)).collect_vec())\n            .unwrap_or_default()\n    }\n\n    /// Checks whether a node is in use. A node is used if it is in the live_nodes set\n    /// or if it is borrowed by a node which is used.\n    pub fn is_in_use(&self, node: &BorrowNode) -> bool {\n        if self.live_nodes.contains(node) {\n            true\n        } else {\n            self.get_children(node)\n                .iter()\n                .any(|child| self.is_in_use(child))\n        }\n    }\n\n    /// Checks whether `node` is being borrowed by at least one live node\n    pub fn has_borrow(&self, node: &BorrowNode) -> bool {\n        self.get_children(node)\n            .iter()\n            .any(|child| self.is_in_use(child))\n    }\n\n    /// Returns nodes which are dying from this to the next state. This includes those which\n    /// are directly dying plus those from which they borrow. Returns nodes in child-first order.\n    pub fn dying_nodes(&self, next: &BorrowInfo) -> Vec<(BorrowNode, Vec<Vec<WriteBackAction>>)> {\n        let mut result = vec![];\n        for dying in self.live_nodes.difference(&next.live_nodes) {\n            if next.is_in_use(dying) {\n                continue;\n            }\n\n            // Collect ancestors trees until reaching an ancestor that is still in use.\n            let dying_trees = self.collect_dying_ancestor_trees(dying, next);\n            result.push((dying.clone(), dying_trees));\n        }\n        result\n    }\n\n    /// Start from this node and follow-up the borrow chain until reaching a live/in-use ancestor.\n    /// Collect possible paths (from this node to a live ancestor) and return them in the DFS order.\n    fn collect_dying_ancestor_trees(\n        &self,\n        node: &BorrowNode,\n        next: &BorrowInfo,\n    ) -> Vec<Vec<WriteBackAction>> {\n        let mut trees = vec![];\n        self.collect_dying_ancestor_trees_recursive(node, next, vec![], &mut trees);\n        trees\n    }\n\n    fn collect_dying_ancestor_trees_recursive(\n        &self,\n        node: &BorrowNode,\n        next: &BorrowInfo,\n        order: Vec<WriteBackAction>,\n        trees: &mut Vec<Vec<WriteBackAction>>,\n    ) {\n        match node {\n            BorrowNode::LocalRoot(..) | BorrowNode::GlobalRoot(..) => {\n                trees.push(order);\n            },\n            BorrowNode::Reference(index) => {\n                if next.is_in_use(node) {\n                    // stop at a live reference\n                    trees.push(order);\n                } else {\n                    let incoming = self.get_incoming(node);\n                    if incoming.is_empty() {\n                        // when the borrow reference node has no incoming edges, it means that this\n                        // reference is a function argument.\n                        trees.push(order);\n                    } else {\n                        // when there are incoming edges, this borrow occurs within the body\n                        // of this function and this node need to be further traced upwards.\n                        for (parent, edge) in incoming {\n                            let mut appended = order.clone();\n                            appended.push(WriteBackAction {\n                                src: *index,\n                                dst: parent.clone(),\n                                edge: edge.clone(),\n                            });\n                            self.collect_dying_ancestor_trees_recursive(\n                                parent, next, appended, trees,\n                            );\n                        }\n                    }\n                }\n            },\n            BorrowNode::ReturnPlaceholder(..) => {\n                unreachable!("
]