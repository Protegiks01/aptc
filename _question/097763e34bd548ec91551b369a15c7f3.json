[
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: get_entry_function_payload_from_transaction_payload()] [Incomplete multisig extraction] At lines 275-294, when extracting EntryFunctionPayload from MultisigPayload, the nested pattern matching at lines 282-288 only handles EntryFunctionPayload but ignores other payload types - can this allow malicious multisig transactions with non-entry-function payloads to bypass filters? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: get_entry_function_payload_from_transaction_payload()] [Wildcard pattern bypass] At line 290, the function uses wildcard pattern _ => None for non-matching payloads, which silently accepts ScriptPayload and ModuleBundle - can attackers use these alternative payload types to evade entry function filters completely? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: EntryFunctionFilter::validate_state()] [Weak validation] At lines 183-187, validation only checks that at least one field is set but doesn't validate the format of address/module/function strings - can malformed strings cause panics during matching? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: EntryFunctionFilter::matches()] [Logic error in filter] At lines 191-211, line 196 checks if address.is_some() OR function.is_some(), but shouldn't it be AND since both are needed to properly identify an entry function? This appears to be a bug that could allow filter bypass. (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: EntryFunctionFilter::matches()] [Missing module handling] At lines 197-207, when module_id.module is None, the function returns false, but does this correctly handle all protobuf encoding cases where the module might be legitimately missing vs malformed? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: EntryFunctionFilter::matches()] [Function name matching precedence] At lines 192-194, function name is matched BEFORE checking if module exists - can this cause incorrect matches where the function name matches but the module/address don't exist? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: EntryFunctionFilter::get_standardized_address()] [Address clone overhead] At lines 146-152, the standardized address clones the original address string - in high-throughput scenarios, can this memory allocation overhead be exploited to cause performance degradation? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: validate_state()] [Weak validation] At lines 65-73, validation only checks that at least one of data_substring_filter OR struct_type is set, but doesn't validate the substring length or content - can an attacker provide an extremely long substring (e.g., 1GB) to cause memory exhaustion? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: matches()] [Substring search DoS] At lines 89-96, the data_substring_finder uses memchr::memmem::Finder which compiles the search pattern once via OnceCell, but can an attacker craft pathological patterns (e.g., many repeated characters) that cause worst-case O(n*m) search performance on every event, DoSing the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: matches()] [Race condition in Finder initialization] At lines 90-92, the data_substring_finder uses OnceCell::get_or_init() - in concurrent scenarios, can multiple threads race to initialize the Finder, and does into_owned() properly handle this without data races? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: matches()] [Missing struct type validation] At lines 77-86, when struct_type_filter is provided but the event type is not a Struct (e.g., Content is Generic), the function returns false at line 85, but does this correctly handle all enum variants in Content or could new variants bypass this check? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: matches()] [Event data encoding assumption] At line 93, the code assumes item.data is valid UTF-8 by calling as_bytes(), but event data could be binary - can malformed UTF-8 in event data cause panics or incorrect substring matching? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: matches()] [Finder::into_owned() memory leak] At line 92, into_owned() creates an owned copy of the Finder - in long-running indexer processes with many different filters, can this cause memory accumulation if filters are frequently created and discarded? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Function: From<EventFilter>] [Protobuf data loss] At lines 44-52 and 54-60, the From implementations don't preserve the data_substring_finder OnceCell state - can this cause filters to lose their compiled patterns when converting to/from protobuf, requiring recompilation and causing performance degradation? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Function: validate_state()] [Weak validation] At lines 76-81, validation only checks that at least one field is set but doesn't validate address format or length - can an attacker provide an address with invalid hex characters to cause panics in standardize_address()? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Function: matches()] [Double standardization overhead] At line 86, standardize_address() is called on struct_tag.address for every match attempt, but get_standardized_address() also calls standardize_address() - is this double standardization necessary and can it be exploited for performance degradation? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Function: get_standardized_address()] [OnceCell race condition] At lines 39-45, OnceCell::get_or_init() is used without synchronization - in a concurrent filter evaluation scenario, can multiple threads race causing inconsistent standardization results? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Function: matches()] [Case sensitivity bug] At lines 84-89, the matches() implementation compares standardized addresses, but module and name are compared directly via Option<String>::matches() - are module and name comparisons case-sensitive when they should be case-insensitive, allowing filter bypass? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Special address confusion] At lines 14-28, addresses where the first 63 characters are '0' and last char <= 'f' are treated as special addresses (0x1 format), but what if an attacker provides '0x00...00g' - does this fall through to long format correctly or cause unexpected behavior? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Buffer overflow potential] At line 33, ZEROS is indexed with [..64 - trimmed.len()] - if trimmed.len() > 64, this will cause integer underflow and potential panic or buffer overflow - can an attacker provide an oversized address string to crash the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Special address boundary case] At lines 20-21, the code checks if last_char <= 'f', but what about uppercase 'F'? Can an attacker use uppercase hex digits to bypass the special address detection and cause address collision attacks? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Empty address handling] What happens if an empty string is passed to standardize_address()? At line 12, trimmed could be empty, and line 15 chars().last() would return None - can this cause panics or incorrect behavior? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Non-hex character handling] At lines 16-21, the code checks is_ascii_hexdigit() but doesn't explicitly handle non-hex characters in the body - can malformed addresses with special characters like '/', '%', or Unicode bypass detection? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Leading zero inconsistency] At lines 16-18, all([...].chars().all(|c| c == '0')) checks for leading zeros, but does this correctly handle addresses like '0x000g001' where there are zeros but also other characters interspersed? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Address aliasing vulnerability] Can an attacker craft two different address strings that standardize to the same value, allowing them to impersonate system addresses (0x1, 0x2, etc.) by finding collisions in the standardization logic? (Critical)"
]