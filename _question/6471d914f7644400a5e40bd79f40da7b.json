[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: parse_named_address()] [Input validation bypass] Can an attacker craft a malicious named address string with multiple '=' delimiters that bypasses the split().len() != 2 check, potentially injecting arbitrary addresses into the compilation namespace? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: parse_named_address()] [Address collision] Does the function validate uniqueness of address names before insertion, or can an attacker overwrite critical system addresses (like 0x1) by providing duplicate name=address pairs causing fund theft? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: parse_named_address()] [Parser confusion] Can malformed address strings with special characters (newlines, nulls, unicode) in the name portion exploit the parse() call to cause parser state corruption affecting subsequent compilation? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: parse_named_address()] [Numerical overflow] Does NumericalAddress::parse_str() properly validate address bit lengths, or can an attacker provide oversized hexadecimal values that overflow into adjacent memory causing state corruption? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: parse_named_address()] [Empty string bypass] What happens if before_after[0] or before_after[1] is empty after splitting - does this allow registration of unnamed addresses or addresses with empty names that could bypass access controls? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Trait: TName] [Type confusion] Can an attacker exploit the generic Key and Loc types in TName to create type confusion vulnerabilities where mismatched location/key pairs corrupt the symbol table? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: TName::drop_loc()] [Memory safety] Does drop_loc() properly handle the lifetime of the dropped location, or can this create use-after-free vulnerabilities when the location is accessed after being separated from its key? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: TName::add_loc()] [Location spoofing] Can an attacker provide an arbitrary Loc value that doesn't correspond to actual source code, allowing them to bypass source location-based security checks or obfuscate malicious code origins? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Type: Name/Symbol] [Symbol pool exhaustion] Since Name uses Symbol from move_symbol_pool, can an attacker exhaust the symbol pool by creating millions of unique identifiers causing denial of service during compilation? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: shortest_cycle()] [Infinite loop] Can a malicious dependency graph with carefully crafted cycles cause the fold operation to never terminate, hanging the compiler and preventing valid transaction compilation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: shortest_cycle()] [Panic on unwrap] The function calls shortest_path.unwrap() without checking if a cycle exists - can an attacker provide an acyclic graph causing a panic that crashes the compiler and halts the blockchain? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: shortest_cycle()] [Stack overflow] For deeply nested dependency cycles, can the recursive petgraph_astar call exceed stack limits causing validator nodes to crash during module deployment? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: shortest_cycle()] [Path manipulation] Can an attacker construct a dependency graph where the shortest path calculation produces incorrect results, allowing circular dependencies that should be rejected to pass validation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: shortest_cycle()] [Memory exhaustion] Can an extremely large dependency graph with millions of nodes cause path.insert(0, start) to allocate unbounded memory leading to OOM crashes? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Struct: NamedAddressMaps] [Index out of bounds] Does NamedAddressMaps::get() validate that NamedAddressMapIndex is within bounds, or can an attacker provide an out-of-bounds index causing a panic or memory corruption? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: NamedAddressMaps::insert()] [Integer overflow] Can inserting an unbounded number of address maps cause self.0.len() to overflow usize, creating an invalid NamedAddressMapIndex that points to wrong memory? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: NamedAddressMaps::get()] [Concurrent access race] Is NamedAddressMaps thread-safe, or can concurrent get() calls during parallel compilation read inconsistent data causing non-deterministic bytecode generation? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Struct: NamedAddressMapIndex] [Index reuse vulnerability] Can NamedAddressMapIndex values be reused across different NamedAddressMaps instances, causing cross-contamination where one module's addresses are used in another? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: NamedAddressMaps::new()] [Uninitialized state] Does new() properly initialize the internal Vec, or can accessing elements before insert() cause undefined behavior? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Struct: PackagePaths] [Path traversal] Can the paths Vec contain directory traversal sequences (../, ./) that allow an attacker to include code from outside the intended package boundaries? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Struct: PackagePaths] [Address map injection] Can an attacker provide a malicious named_address_map in PackagePaths that overwrites core system addresses during compilation, allowing unauthorized access to privileged functions? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: string_vec_to_symbol_vec()] [Symbol injection] Can malicious strings in the input vector inject special symbols that bypass later validation checks in the compilation pipeline? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: string_map_to_symbol_map()] [Key collision] Does the conversion properly handle hash collisions when converting String keys to Symbol keys, or can this cause silent overwrites of address mappings? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Struct: IndexedPackagePath] [Index validation missing] Can an IndexedPackagePath be constructed with an invalid named_address_map index that points to non-existent or wrong address mappings? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs] [Function: CompilationEnv::new()] [Attribute validation bypass] If known_attributes is empty or improperly initialized, can this allow unknown/malicious attributes to pass through unchecked enabling privilege escalation? (Critical)"
]