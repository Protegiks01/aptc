[
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Pureness bypass] Can an attacker craft Move modules where the RewritingScope::CompilationTarget filter excludes malicious spec functions from pureness checking, allowing impure specifications to bypass validation and break formal verification guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Race condition] If multiple threads call run_spec_checker() concurrently during parallel compilation, can race conditions in the RewriteTargets structure lead to some spec functions being checked multiple times while others are skipped entirely? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Filter bypass] Can the filter predicate at line 27-32 be bypassed by crafting RewriteTarget variants that match but shouldn't be checked, or vice versa, allowing impure specifications to pass through? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [State corruption] If get_env_state() returns inconsistent RewriteState values during iteration (lines 36-46), can this lead to spec functions being checked with wrong expressions or skipped validation entirely? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Type confusion] Can an attacker cause type confusion between RewriteTarget::MoveFun and RewriteTarget::SpecFun by manipulating qualified IDs, leading to Move function definitions being checked as spec functions or vice versa? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Incomplete validation] Does the match statement at lines 36-46 properly handle all possible combinations of RewriteTarget and RewriteState, or can certain combinations bypass pureness checking? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Inline spec bypass] For MoveFun targets, the code calls visit_inline_specs() at line 38-41. Can an attacker craft inline specs that don't get visited due to AST structure manipulation, bypassing pureness checks? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Resource exhaustion] Can an attacker create deeply nested or recursive spec function calls that cause the pureness checker to consume excessive memory or stack space, leading to validator node crashes during compilation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: run_spec_checker()] [Wildcard bypass] The wildcard pattern '_' at line 45 silently ignores certain target/state combinations. Can this lead to security-critical spec blocks being unchecked? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [Error suppression] The error_reported flag at line 51 is passed to FunctionPurenessChecker but only controls reporting, not checking. Can an attacker chain multiple impure operations where only the first is reported, hiding subsequent violations? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [Mode confusion] The FunctionPurenessCheckerMode::Specification is hardcoded at line 53. Can this mode be bypassed or manipulated for certain expression types to allow impure constructs? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [Call chain manipulation] Can an attacker craft expressions where the call_chain parameter passed to report_error becomes corrupted or truncated, hiding the true source of impurity? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [Closure escape] The closure at lines 54-55 captures error_reported mutably. Can lifetime issues or closure escaping lead to the error_reported flag persisting across multiple unrelated checks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [AST poisoning] If the Exp parameter contains malformed or specially crafted AST nodes, can this cause check_exp() to panic, hang, or skip validation of subtrees? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_exp()] [Transitive bypass] Does check_exp() properly handle transitive pureness through generic function instantiations and lambda captures, or can impurity leak through type parameters? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_spec()] [Spec block bypass] Can an attacker create Spec blocks with certain SpecBlockTarget types that don't get properly checked by check_spec(), allowing impure specifications in struct invariants or module specs? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_spec()] [Error isolation] Similar to check_exp(), the error_reported flag at line 60 is local. Can multiple impure conditions in a single Spec block result in only partial error reporting? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_spec()] [Global state access] The spec_checker.rs comment at line 8 mentions checking that struct invariants don't depend on global state. Does check_spec() actually enforce this, or can borrow_global be used in struct invariants? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: check_spec()] [Checker reuse] Each invocation of check_spec() creates a new FunctionPurenessChecker at line 61-64. Can pureness results from previous checks be exploited to poison subsequent checks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [Early exit exploit] Lines 77-79 return early if error_reported is true, suppressing subsequent errors. Can an attacker craft code where the first error is benign but later errors represent critical security violations? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [Empty call chain] Lines 83-91 handle empty call_chain differently. Can an attacker manipulate call chains to be empty when they shouldn't be, resulting in less informative error messages that hide attack vectors? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [Call chain corruption] The loop at lines 96-107 accesses call_chain[i-1] and call_chain[1]. Is there a bounds checking issue or off-by-one error that could cause panics or incorrect error reporting? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [Index confusion] Line 98 accesses call_chain[1].0 instead of call_chain[i].0 in a loop iterating with index i. Is this a bug that could hide the true impure function in call chains longer than 2? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [NodeId manipulation] Can an attacker craft malicious Move code where NodeId values are reused or corrupted, causing get_node_loc() to return incorrect source locations and hide the true origin of impurity? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/spec_checker.rs] [Function: report_error()] [Function name spoofing] The print_fun closure at line 82 uses get_function().get_name_str(). Can function name collision or Unicode exploits make error messages misleading about which function is impure? (Low)"
]