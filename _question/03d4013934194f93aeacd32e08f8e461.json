[
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: try_from_bytes()] [Deserialization Attack] Can an attacker craft malicious BCS-encoded bytes that cause unbounded memory allocation during deserialization, leading to validator node OOM crashes and loss of liveness? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: try_from_bytes()] [Type Confusion] Can malformed bytes bypass BCS type checks to deserialize as BurnEvent with invalid internal state, potentially causing undefined behavior when processed by indexers or validators? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: try_from_bytes()] [Integer Overflow] Can attacker-controlled bytes contain u64 values near MAX that cause integer overflow when the index field is used in arithmetic operations downstream in collection supply tracking? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: try_from_bytes()] [DoS via Panic] Does the BCS deserialization properly handle all error cases without panicking, or can crafted inputs cause unwrap() panics that crash validator nodes during event processing? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: try_from_bytes()] [Resource Exhaustion] Can an attacker repeatedly submit transactions that emit malformed BurnEvents requiring expensive deserialization attempts, exhausting validator CPU resources and degrading consensus performance? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: new()] [Missing Validation] Does the constructor validate that the index parameter corresponds to a legitimate token that was previously minted, or can attackers create BurnEvents for non-existent tokens causing supply accounting corruption? (Critical)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: new()] [Duplicate Burn] Can the same index be used to create multiple BurnEvents, allowing attackers to artificially deflate collection supply counters and potentially cause integer underflow in supply tracking? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: new()] [Invalid Token Address] Does the constructor verify that the token AccountAddress is valid and not a system-reserved address, or can malicious actors emit events claiming to burn special system tokens? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: new()] [Zero Index] Can attackers create BurnEvents with index=0 to exploit off-by-one errors in collection management code that uses 0 as a sentinel value? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Function: new()] [MAX_U64 Index] Can using index=18446744073709551615 (MAX_U64) cause overflow in subsequent arithmetic when calculating collection statistics or token positions? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [MoveStructType Implementation] [Type Confusion] Can an attacker emit events with MODULE_NAME='collection' and STRUCT_NAME='BurnEvent' but from a different address than TOKEN_OBJECTS_ADDRESS, bypassing access controls in the Move contract? (Critical)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Static BURN_EVENT_TYPE] [Type Mismatch] If the BURN_EVENT_TYPE TypeTag doesn't match the actual Move struct definition in collection.move, can this cause silent event emission failures or indexer misinterpretation leading to supply tracking errors? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Static BURN_EVENT_TYPE] [Address Spoofing] Can malicious contracts create structs with identical module and struct names but different addresses, causing indexers to mistakenly process fake burn events as legitimate? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [MoveEventV1Type Marker] [Migration Vulnerability] During the migration from V1 to V2 events (referenced in collection.move), can mismatches between legacy BurnEvent and new Burn event types cause double-counting or missed burns in supply tracking? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Field: index] [Arithmetic Overflow] When the index field is used in collection.move's decrement_supply() to update current_supply (lines 488, 509), can attacker-controlled large index values cause unexpected behavior in supply calculations? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Field: index] [Underflow Attack] If collection supply tracking uses 'current_supply -= index' instead of 'current_supply -= 1', can attackers with MAX_U64 index values cause supply counters to underflow and wrap around? (Critical)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Field: index] [Off-by-One] If indexing logic assumes 1-based indexing but the event allows 0-based, can this cause array access violations or incorrect token lookups in collection management? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Emission] [Unauthorized Burn] Does the Rust type system prevent unauthorized code from constructing BurnEvent instances, or can any module emit fake burn events that manipulate collection supply without actually destroying tokens? (Critical)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Emission] [Cross-Contract Exploit] Can malicious smart contracts import the BurnEvent struct and emit their own burn events that get processed by indexers, artificially deflating legitimate collection supplies? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Friend-Only Pattern] [Access Bypass] Since collection::decrement_supply() is marked 'friend fun' and only callable by token.move, can attackers find alternative paths to emit BurnEvents without going through proper burn authorization? (Critical)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Processing] [Replay Attack] Can the same BurnEvent be replayed multiple times by re-submitting historical transaction data, causing supply counters to be decremented repeatedly for a single actual burn? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Processing] [Ordering Violation] If BurnEvents are processed out-of-order by indexers, can this cause temporary supply inconsistencies that could be exploited for arbitrage or oracle manipulation? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Processing] [Missing Sequence] If a validator fails to emit a BurnEvent during token destruction, can this cause permanent divergence between actual token existence and tracked supply counters? (High)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Event Processing] [Duplicate Detection] Without deduplication logic, can Byzantine validators emit duplicate BurnEvents for the same token burn, causing double-counting in supply tracking? (Medium)",
  "[File: aptos-core/types/src/account_config/events/burn_event.rs] [Struct Layout] [Memory Corruption] Can misaligned memory access when deserializing the index and token fields cause memory corruption on certain architectures, potentially enabling RCE? (Low)"
]