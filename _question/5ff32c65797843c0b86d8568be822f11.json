[
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_optimistic_fetch_request()] [Fetch replacement race] Lines 257-260 insert optimistic fetch, and line 261 checks if previous existed - can rapid consecutive requests from same peer cause the first fetch's response_sender to be dropped without notification? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_optimistic_fetch_request()] [Silent overwrite] When is_some() at line 261, only a trace log is emitted (lines 262-271) - can an attacker deliberately trigger overwrites to suppress optimistic fetch responses without triggering alerts? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_optimistic_fetch_request()] [Per-peer limit bypass] The DashMap at line 258 is keyed by PeerNetworkId - can an attacker use multiple peer IDs from the same network to bypass single-fetch-per-peer limits and exhaust server resources? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_optimistic_fetch_request()] [Metrics manipulation] OPTIMISTIC_FETCH_ADD counter at lines 275-279 is incremented even when overwriting - can this inflate metrics to hide attack patterns or trigger false performance alerts? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_optimistic_fetch_request()] [Time service manipulation] OptimisticFetchRequest stores time_service at line 253 - if time_service is MockTimeService in production, can an attacker exploit time manipulation to bypass timeout checks? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Stream ID collision] Lines 292-294 create SubscriptionRequest with stream_id from request - can an attacker deliberately reuse stream IDs across different subscription types to cause stream confusion? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Entry lock contention] Line 302 locks the DashMap entry - can an attacker create long-running subscription operations to hold locks, blocking other peers' subscription requests and causing DoS? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Stream replacement without cleanup] Lines 312-318 replace entire subscription stream when IDs don't match - are resources from old stream (pending requests, response senders) properly cleaned up, or can this leak memory? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Failed request notification bypass] When add_subscription_request fails at lines 324-335, error handling calls handle_subscription_request_failure - but can network failures during error notification leave client in broken state? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Vacant entry race] Line 338 handles vacant entry - between checking vacancy and inserting at line 344, can another thread insert, causing the second insert to silently overwrite? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request()] [Metrics double-counting] New stream metrics updated at lines 321, 347 - if entry transitions from Occupied to Vacant due to race, can metrics be double-counted, corrupting monitoring data? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request_failure()] [Error message leakage] Line 377 converts internal Error to StorageServiceError with to_string() - can detailed error messages expose internal state or storage structure to malicious peers? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request_failure()] [Response sender consumption] take_response_sender() at line 378 consumes the SubscriptionRequest - if send_response fails, is the error unrecoverable, leaving client without notification? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: handle_subscription_request_failure()] [Sampling rate bypass] Sample rate at line 363 means not all failures are logged - can an attacker exploit this to perform repeated attacks that go unnoticed in logs? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: send_response()] [Response logging before send] Line 238 logs response before sending at line 239 - if send fails, are logs misleading about actual responses sent, complicating forensics? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: send_response()] [Send failure handling] ResponseSender.send() at line 239 - if this fails (network disconnection), is the failure properly handled or silently ignored, potentially hiding peer issues? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: log_storage_response()] [Summary spam prevention] Lines 619-633 sample summary response logging - can an attacker flood GetStorageServerSummary requests to probe when sampling occurs, timing attacks on logging infrastructure? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: log_storage_response()] [Error logging verbosity] Error responses at lines 636-639 use Debug format - can this expose sensitive internal state or stack traces to log aggregation systems? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: log_storage_response()] [Response formatting DoS] Line 627 formats data_response using Display trait - can extremely large responses cause excessive CPU usage during string formatting? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: new()] [Shared state initialization] Lines 60-78 initialize Handler with Arc-wrapped shared state - are all shared structures (DashMap, ArcSwap, Cache) properly initialized with bounded sizes to prevent unbounded growth? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: new()] [Clone safety] Handler implements Clone trait (line 48) - when cloned, are all Arc references properly shared, or can cloning create isolated instances that miss updates? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: update_created_stream_metrics()] [Metric counter overflow] Lines 581-587 increment counter without bounds checking - can long-running nodes experience counter overflow (u64::MAX), wrapping to 0 and corrupting metrics? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: update_failed_subscription_metrics()] [Network ID validation] Line 593 uses peer_network_id.network_id() - can invalid or malicious network IDs cause metric system panics or undefined label behavior? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: update_new_subscription_metrics()] [Metric injection] Line 603 directly uses network_id in metrics - can an attacker with custom NetworkId values inject arbitrary metric labels, polluting monitoring systems? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Cross-Function] [DashMap deadlock] Optimistic fetches (line 51), subscriptions (line 55) use DashMap - can concurrent operations on same peer from different handler threads cause deadlocks or lock ordering issues? (High)"
]