[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: empty_bytecode()] [Bytecode bypass] Can an attacker craft a CompiledModule with zero-length bytecode array that bypasses the EMPTY_CODE_UNIT check through race conditions during module loading, allowing execution of uninitialized memory as bytecode? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: empty_bytecode()] [DoS via verification] If empty bytecode passes verification on some validators but fails on others due to inconsistent verify_module() implementation, could this cause validator set divergence and network partition? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: empty_bytecode_v5()] [Version bypass] Does the version check (module.version = 5) properly validate against negative versions, MAX versions, or overflowed version numbers that could bypass empty bytecode validation? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: empty_bytecode_v5()] [Version manipulation] Can an attacker set module.version to a boundary value (e.g., 5.5, 4.9999, INT_MAX) that causes inconsistent version checking across validators, leading to divergent bytecode acceptance? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: verify_module()] [Integer overflow] In the enumerate() loop over function_defs(), can an attacker craft a module with TableIndex values that overflow when cast to FunctionDefinitionIndex, causing verification to skip malicious functions? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: verify_module()] [Native function bypass] Does the filter !def.is_native() properly validate all native function markers, or can an attacker mark malicious bytecode as 'native' to bypass control flow verification entirely? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: verify_module()] [Panic exploitation] If function_definition.code is None for a non-native function, the expect() call panics - can an attacker craft modules that cause validator crashes through this panic during module loading? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_br_true()] [Conditional branch bypass] Can an attacker craft bytecode where BrTrue offset points beyond code boundaries, bypassing INVALID_FALL_THROUGH detection and causing out-of-bounds execution? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_br_true()] [Stack manipulation] If BrTrue(1) executes with a corrupted stack state where LdFalse was skipped, could this bypass the fallthrough check and execute undefined bytecode at the function boundary? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_br_false()] [Boolean type confusion] Can an attacker exploit type confusion between LdTrue/LdFalse and other stack values to make BrFalse behave as an unconditional branch, bypassing fallthrough validation? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_br_false()] [Offset manipulation] Does BrFalse(1) properly validate that offset '1' is within bounds, or can negative/overflow offsets bypass verification and jump to arbitrary code locations? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_non_branch()] [Last instruction validation] If dummy_procedure_module() incorrectly appends bytecode, can the 'Pop' instruction appear as non-last, bypassing INVALID_FALL_THROUGH while still allowing fallthrough in practice? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: invalid_fallthrough_non_branch()] [Bytecode reordering] Can an attacker exploit race conditions during module deserialization to reorder bytecode such that Pop appears before the actual last instruction, bypassing verification? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_branch()] [Self-loop DoS] Does Branch(0) create an infinite loop that passes verification but causes validator timeout/DoS when executed, violating liveness guarantees? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_branch()] [Gas metering bypass] If Branch(0) creates an infinite loop, does the gas meter properly charge for each iteration, or can this be exploited for infinite computation without gas costs? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_ret()] [Early return exploitation] Can an attacker craft bytecode with Ret that skips critical epilogue checks (balance updates, event emissions, storage commits), leading to state inconsistencies? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_ret()] [Return value manipulation] Does a single Ret instruction properly validate that the return stack matches function signature, or can mismatched returns bypass type safety? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_abort()] [Abort code manipulation] Can an attacker craft LdU64(7) with overflow/underflow values that cause inconsistent abort code interpretation across validators, breaking determinism? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: valid_fallthrough_abort()] [State rollback bypass] Does Abort properly roll back all state changes including storage writes, or can partial commits leak through on abort, corrupting blockchain state? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_max_depth()] [Depth calculation bypass] Can an attacker craft nested BrFalse loops where depth calculation overflows or underflows, bypassing max_loop_depth limit and causing validator DoS through deep recursion? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_max_depth()] [Config manipulation] If VerifierConfig.max_loop_depth is set to None or Some(0), does this disable depth checking entirely, allowing unbounded loop nesting that causes stack overflow? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_max_depth()] [Off-by-one error] The test uses max_loop_depth: Some(2) for 2 nested loops - is this an off-by-one where 3 loops should fail but passes, allowing one extra nesting level for DoS attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_exceed_max_depth()] [Boundary validation] Does the depth check use > or >= comparison? Can exactly max_loop_depth loops pass when they should fail, or vice versa, causing inconsistent verification? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_exceed_max_depth()] [Loop collapse exploitation] Can an attacker craft overlapping loop structures that appear as depth 2 to verifier but execute as depth 3+, bypassing LOOP_MAX_DEPTH_REACHED check? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/control_flow_tests.rs] [Function: nested_loops_exceed_max_depth()] [Integer overflow in depth] If loop depth is stored as u8/u16 and exceeds MAX, does it wrap to 0 and bypass depth checking, allowing infinite nesting? (Critical)"
]