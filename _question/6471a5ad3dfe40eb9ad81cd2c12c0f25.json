[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_::Shl/Shr] [Shift overflow] Can BinOp_::Shl and BinOp_::Shr be exploited with shift amounts exceeding the bit width of operands, causing undefined behavior or returning incorrect results that compromise cryptographic operations? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_] [is_pure() bypass] Can attackers exploit the is_pure() classification (lines 1001-1020) to mark impure operations as pure, causing the compiler to incorrectly optimize or reorder operations, breaking deterministic execution guarantees? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_] [is_spec_only() abuse] Can the is_spec_only() method (lines 1022-1025) be bypassed to allow specification-only operators (Range/Implies/Iff) in executable code, causing runtime errors or enabling exploitation of unimplemented spec operators? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_::BitOr/BitAnd/Xor] [Bitwise confusion] Are bitwise operations properly typed to prevent mixing with boolean operations, or can attackers create expressions that exploit operator precedence to cause logic errors in access control checks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_::And/Or] [Short-circuit bypass] Can the And/Or operators be manipulated to bypass short-circuit evaluation, causing side effects in operands that should never execute and violating transaction atomicity? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: BinOp_::Implies/Iff] [Specification injection] Can specification-only operators Implies and Iff be injected into runtime code through macro expansion or inline functions, causing compiler crashes or incorrect bytecode generation? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: UnaryOp_::Negate] [Minimum value overflow] Does UnaryOp_::Negate properly handle negation of minimum signed integer values (e.g., -i128::MIN), which cannot be represented, and is is_pure() correctly returning false for Negate (line 946) to prevent overflow assumptions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: UnaryOp_::Not] [Boolean/bitwise confusion] Can UnaryOp_::Not be applied to both boolean and integer types, and are there type confusion vulnerabilities where bitwise NOT on integers is misinterpreted as logical NOT on booleans? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: UnaryOp_] [is_pure() misclassification] Is the is_pure() implementation (lines 942-948) correct in classifying Not as pure but Negate as non-pure, and could this lead to incorrect constant folding that introduces overflow vulnerabilities? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: NameAccessChain_] [Deep nesting DoS] Can NameAccessChain_ variants (One/Two/Three/Four) be nested or chained to create excessively deep name resolution paths that cause stack overflow or exponential time complexity during module resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: NameAccessChain_::Two] [Module confusion] Can NameAccessChain_::Two with LeadingNameAccess be exploited to confuse module resolution between named addresses and numerical addresses, potentially accessing wrong modules and bypassing access controls? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: NameAccessChain_::Three/Four] [Path traversal] Do NameAccessChain_::Three and NameAccessChain_::Four properly validate that multi-level name access doesn't enable path traversal attacks to access private module members or system modules? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: LeadingNameAccess_] [Anonymous address injection] Can LeadingNameAccess_::AnonymousAddress be exploited to inject arbitrary addresses that bypass named address verification, enabling address spoofing in module imports? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: LeadingNameAccess_::Name] [Name shadowing] Can LeadingNameAccess_::Name be used to shadow system modules or framework addresses, redirecting imports to malicious modules and enabling supply chain attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: ModuleIdent_] [Address-module confusion] Does ModuleIdent_ properly enforce uniqueness of (address, module) pairs, or can attackers create colliding module identifiers that reference different modules, causing type confusion? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility] [Internal exposure] Can the Visibility::Internal variant be bypassed through macro expansion, inline functions, or friend declarations, allowing unauthorized access to private module functions? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility::Script] [Script restriction bypass] Can Visibility::Script functions be called from non-script contexts (e.g., other modules), bypassing intended restrictions and enabling unauthorized transaction submission? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility::Friend] [Friend list manipulation] Can the Visibility::Friend mechanism be exploited by adding malicious modules to the friend list post-deployment, breaking encapsulation and accessing private state? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility::Package] [Package boundary violation] Does Visibility::Package properly enforce package boundaries, or can modules from different packages masquerade as being in the same package to gain unauthorized access? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility::Public] [Public exposure of critical functions] Are there guard checks to prevent accidentally marking critical system functions as Visibility::Public, which could expose administrative operations to all users? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Visibility] [Loc field timing] Can the Loc field in visibility variants be manipulated to create visibility declarations that appear in wrong source locations, confusing security audits and static analysis tools? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: Function] [Entry modifier bypass] Can the entry: Option<Loc> field be manipulated to mark non-entry functions as entry points or vice versa, enabling unauthorized transaction entry or blocking legitimate transactions? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: Function] [Inline function exploitation] Can the inline: bool flag be abused to force inlining of functions with side effects, bypassing gas metering or causing unexpected behavior through aggressive inlining? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: Function] [Native function abuse] Does FunctionBody_::Native properly restrict which modules can declare native functions, or can user modules declare native functions that execute arbitrary native code and bypass VM sandboxing? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: FunctionSignature] [Type parameter explosion] Can FunctionSignature with excessive type_parameters cause memory exhaustion or exponential compilation time during generic instantiation? (High)"
]