[
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Non-atomic updates] The three components (state, state_summary, transaction_accumulator) can't be updated atomically as a single unit - can partial updates where only some components are updated (due to crashes or errors) create LedgerSummary instances that violate invariants but can't be detected by assert_versions_match? (Critical)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Rollback inconsistency] If a transaction batch fails and needs rollback, state and state_summary might revert but transaction_accumulator might not (if it was already persisted) - can this asymmetric rollback capability cause version mismatches that break the ability to construct valid LedgerSummary after rollback? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Commit ordering] The order of committing state, state_summary, and transaction_accumulator matters for consistency - if commits happen in wrong order (e.g., accumulator before state due to async operations), can observers see intermediate states where versions are temporarily inconsistent, causing query inconsistencies? (Medium)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [State root mismatch] state_summary contains global_state_summary SparseMerkleTree whose root must match the state at transaction_accumulator's version - if root calculation is incorrect or cached, can mismatched roots allow validators to accept invalid state transitions that pass transaction accumulator checks but fail state verification? (Critical)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Accumulator root verification] InMemoryTransactionAccumulator has its own root_hash computed from frozen_subtree_roots - if this root can diverge from what's stored in state_summary or committed to consensus, can this allow transaction accumulator forgery where fake transactions appear valid according to accumulator proofs but don't match state roots? (Critical)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Proof generation version] When generating merkle proofs from LedgerSummary, the version used (from version() or next_version()) must exactly match the proof data - can off-by-one errors in version selection cause proofs to be generated at wrong versions, allowing invalid proofs to verify or valid proofs to fail? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Shard version skew] LedgerState uses 16 shards (NUM_STATE_SHARDS) with per-shard metadata, but transaction_accumulator is single-threaded - if shards can be updated in parallel at slightly different versions, can next_version() return a value that doesn't reflect the actual state of all shards, causing state/accumulator inconsistency? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Parallel execution race] If Block-STM parallel execution modifies state shards concurrently while LedgerSummary is being constructed, can race conditions cause the snapshot to capture inconsistent shard versions where some shards are at version N and others at N+1? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Hot state LRU consistency] Each shard has independent hot_state_metadata with LRU tracking - if LRU evictions happen during LedgerSummary construction, can the state and state_summary capture different views of which keys are hot, causing later lookups to fail or return stale data? (Medium)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Usage calculation overflow] LedgerState tracks StateStorageUsage with items and bytes counts - if usage calculations overflow (e.g., bytes > i64::MAX in usage_delta_per_shard), can this corrupt the usage tracking and allow state to grow unbounded, bypassing storage limits and causing disk exhaustion? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Usage underflow attack] If update_usage() calculates negative deltas incorrectly and underflows items or bytes counts to 0 (or wraps to huge values), can this allow free storage usage that bypasses gas costs, enabling state bloat attacks or allowing attackers to store unlimited data for free? (High)",
  "[File: aptos-core/storage/storage-interface/src/ledger_summary.rs] [Struct: LedgerSummary] [Usage inconsistency between validators] If usage calculation depends on the order of state updates or cached values, can different validators calculate different usage values for the same state, causing divergence in state transitions that depend on usage limits or gas calculations? (Critical)"
]