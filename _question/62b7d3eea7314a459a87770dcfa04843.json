[
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [Control Flow] [Skip While Logic] Lines 147-154 use skip_while to remove leading signers - can a function with signers in the middle or end bypass validation? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [Logic] [Ability Check] Lines 199-201 check 'has Copy and not Key' - but what about structs with Drop, Store abilities? Can they bypass these checks? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [DoS] [Quadratic Complexity] If a module has thousands of functions, does the filtering at lines 130-163 have quadratic complexity that could cause timeouts? (Low)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [DoS] [Recursive Type Explosion] Deeply nested or recursive types in get_type_tag() could cause exponential time complexity - is there a depth limit? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [DoS] [BTreeMap Performance] As the output BTreeMap grows large with many ABIs, does insertion performance degrade? (Low)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [Critical] [Bytecode Injection] When load_compiled_bytes() reads .mv files or in_memory_bytes, is there any validation that the bytes are actually valid Move bytecode? Can arbitrary bytes be injected? (Critical)",
  "[File: aptos-core/third_party/move/move-prover/move-abigen/src/abigen.rs] [Critical] [Type System Bypass] If\n\n### Citations\n\n**File:** third_party/move/move-prover/move-abigen/src/abigen.rs (L1-351)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse anyhow::{anyhow, bail};\nuse heck::ToSnakeCase;\n#[allow(unused_imports)]\nuse log::{debug, info, warn};\nuse move_binary_format::CompiledModule;\nuse move_bytecode_verifier::script_signature;\nuse move_command_line_common::files::MOVE_COMPILED_EXTENSION;\nuse move_core_types::{\n    abi::{ArgumentABI, ScriptABI, ScriptFunctionABI, TransactionScriptABI, TypeArgumentABI},\n    ability::Ability,\n    identifier::IdentStr,\n    language_storage::{StructTag, TypeTag},\n};\nuse move_model::{\n    ast::Address,\n    model::{FunctionEnv, GlobalEnv, ModuleEnv},\n    ty,\n    ty::ReferenceKind,\n};\nuse serde::{Deserialize, Serialize};\nuse std::{collections::BTreeMap, io::Read, path::PathBuf};\n\n/// Options passed into the ABI generator.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default, deny_unknown_fields)]\npub struct AbigenOptions {\n    /// Where to find the .mv files of scripts.\n    pub compiled_script_directory: String,\n    /// Where to get the script bytes if held in memory\n    pub in_memory_bytes: Option<BTreeMap<String, Vec<u8>>>,\n    /// In which directory to store output.\n    pub output_directory: String,\n}\n\nimpl Default for AbigenOptions {\n    fn default() -> Self {\n        Self {\n            compiled_script_directory:"
]