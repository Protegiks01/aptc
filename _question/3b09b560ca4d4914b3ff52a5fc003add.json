[
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Version manipulation] Can an attacker provide a manifest with version equal to target_version + 1 to bypass the version check at line 115, allowing restoration of a future state that hasn't been committed yet, potentially causing state inconsistency across validators? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Integer overflow] Can version or target_version overflow during the comparison at line 115, causing the skip logic to fail and allowing restoration of an invalid state version? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [State rollback attack] If self.version is set to 0 or a very old version, can an attacker exploit the version check to restore ancient state, effectively performing a deep chain reorganization that violates consensus finality? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Bypass via equal version] When self.version equals self.target_version exactly, does the check at line 115 allow restoration to proceed, and could this edge case be exploited to restore state at a specific version boundary that has timing vulnerabilities? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Manifest injection] Can an attacker replace the manifest file at self.manifest_handle after initialization but before loading at line 125, injecting a malicious StateSnapshotBackup with crafted chunk handles pointing to attacker-controlled data? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [JSON deserialization DoS] Can an attacker craft a deeply nested or extremely large JSON manifest that causes load_json_file at line 125 to consume excessive memory or CPU, causing validator nodes to crash or become unresponsive? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Manifest validation bypass] Does the StateSnapshotBackup deserialization at line 125 validate all required fields, or can an attacker provide a manifest with missing/invalid chunks array causing undefined behavior during iteration at line 169? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Path traversal via manifest] Can manifest.proof contain path traversal sequences (e.g., '../../') that cause load_bcs_file at line 127 to read arbitrary files from the validator's filesystem, potentially leaking private keys or consensus state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Proof bypass] Can an attacker craft a TransactionInfoWithProof where the verify() call at line 128 passes despite the proof being invalid, allowing injection of arbitrary state without proper Merkle verification? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Signature verification bypass] Does txn_info_with_proof.verify() at line 128 properly verify the ledger info signatures, or can an attacker provide a LedgerInfoWithSignatures (li) with forged signatures that still pass verification? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Version mismatch attack] Can manifest.version differ from the version in txn_info_with_proof, and does line 128 catch this mismatch, or could an attacker restore state for version X using a proof for version Y? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [State checkpoint enforcement bypass] Does ensure_state_checkpoint_hash() at line 131 always enforce that the transaction created a state checkpoint, or can it be bypassed for non-checkpoint transactions, allowing restoration from invalid state points? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Hash collision attack] If manifest.root_hash uses a weak hash function or has a collision vulnerability, can an attacker provide two different state trees with the same root_hash, passing the check at line 133 while injecting malicious state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Root hash substitution] Can an attacker modify manifest.root_hash after it's loaded but before the comparison at line 133, substituting a different root hash that matches their malicious state chunks? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Error message information leak] Does the error message at lines 134-136 leak sensitive information about the expected state_root_hash that could help an attacker craft a preimage attack on the Merkle root? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Race condition in verification] Between loading the proof at line 127 and verifying the root hash at line 133, can another thread modify manifest.root_hash, causing TOCTOU (Time-Of-Check-Time-Of-Use) vulnerabilities? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Optional verification bypass] When self.epoch_history is None, the verification at lines 138-140 is skipped entirely - can an attacker exploit restore scenarios where epoch_history is not provided to inject state from the wrong epoch? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Epoch boundary attack] Can an attacker craft a LedgerInfoWithSignatures for an epoch boundary that technically passes epoch_history.verify_ledger_info() but is from a different validator set, allowing state injection during epoch transitions? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Validator set mismatch] Does verify_ledger_info() at line 139 ensure the validator set in the ledger info matches the expected epoch, or can signatures from validators of a different epoch be used to authorize malicious state restoration? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Double initialization] Can get_state_restore_receiver() be called multiple times with different parameters, and does wrapping it in Arc<Mutex<Option<_>>> at line 142 properly prevent concurrent initialization that could corrupt the receiver state? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Receiver parameter injection] Can an attacker manipulate self.version, manifest.root_hash, or self.restore_mode before they're passed to get_state_restore_receiver() at lines 143-145, causing the receiver to be initialized with incorrect parameters? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Restore mode exploitation] Can self.restore_mode be set to an unexpected value that causes get_state_restore_receiver() to create a receiver with insufficient validation, allowing malicious chunks to be accepted? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Mutex poisoning attack] If the Mutex at line 142 becomes poisoned due to a panic in another thread, can subsequent lock() calls fail, causing the restore to silently succeed without actually adding any state chunks? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Resume point manipulation] Can an attacker corrupt the previous_key_hash returned at line 166 to skip critical chunks or restart from an incorrect position, causing incomplete or inconsistent state restoration? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: run_impl()] [Chunk boundary exploitation] Does the skip_while at line 171 correctly handle chunks where chunk.last_key equals resume_point exactly, or could this boundary condition cause chunks to be skipped or processed twice? (High)"
]