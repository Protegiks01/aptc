[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: match_doc_comments()] [Join Separator] Documentation comments are joined with '\\n' separator at line 415. Can this '\\n' insertion alter the semantic meaning of documentation in ways that mislead contract auditors or formal verification tools? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: check_and_get_doc_comments()] [Memory Consumption] The check_and_get_doc_comments() method at lines 425-440 iterates all remaining doc_comments. Can an attacker add thousands of unmatched doc comments to cause excessive diagnostic generation and memory exhaustion? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: check_and_get_doc_comments()] [mem::take Race] At line 439, std::mem::take(&mut self.matched_doc_comments) moves matched comments. Can multiple calls to check_and_get_doc_comments() cause matched comments to be lost or returned multiple times? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: advance()] [State Consistency] In advance() method (lines 442-450), is the state update atomic? If trim_whitespace_and_comments() or find_token() fails partway, can prev_end be updated while cur_start/cur_end/token remain stale, corrupting lexer state? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: advance()] [Error Propagation] When advance() returns an error, are all position fields (prev_end, cur_start, cur_end) left in a consistent state, or can partial updates leave the lexer in an unrecoverable state requiring full reset? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: advance_with_loc()] [Location Calculation] In advance_with_loc() (lines 452-457), the start_loc is captured before advance(), and end_loc after. Can this create locations that span discontinuous source regions if advance() skips comments/whitespace? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: advance()] [Text Length Calculation] At line 445, the calculation self.text.len() - text.len() assumes text is a suffix of self.text. Can malicious trim_whitespace_and_comments() implementations violate this assumption causing cur_start to point outside valid text bounds? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: replace_token()] [Length Validation] The replace_token() method (lines 462-465) sets cur_end = cur_start + len without validating len. Can an attacker cause the parser to call replace_token with len > actual token length, making cur_end point past valid text and causing subsequent slicing panics? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: replace_token()] [Token Consistency] When replace_token() changes token and cur_end but not cur_start, can this create inconsistencies where content() returns text that doesn't match the token type, causing parser to misinterpret subsequent tokens? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: replace_token()] [State Validation] Does replace_token() validate that the new token is actually a valid prefix of the current token's text, or can arbitrary token replacements corrupt the parsing state machine? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Empty Input] At lines 474-478, when text is empty, find_token() returns (Tok::EOF, 0). Can parser logic properly handle EOF at any point in the source, or can premature EOF in the middle of a module declaration allow partial module compilation that bypasses safety checks? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Character Iteration] The text.chars().next() at line 474 handles multi-byte UTF-8. Can malicious UTF-8 sequences cause chars() to return unexpected characters that bypass token classification at line 480-684? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Hex Fallback] In hex number parsing (lines 482-492), if text starts with '0x' but get_hex_number() returns hex_len=0, the code falls back to treating it as single '0' token. Can an attacker use '0x' followed by invalid characters to inject ambiguous numeric literals that parsers interpret differently? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Hex Prefix Length] The text.len() > 2 check at line 482 ensures '0x' has following characters. But what if text.len() == 2 exactly (just '0x')? Does this fall through to decimal parsing or get caught properly? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_hex_number()] [Hex Character Validation] In get_hex_number() at lines 726-731, the character range check includes underscore. Can excessive underscores like '0x1_2_3_4_5_6_7_8_9' cause the parser to accept malformed hex literals that should be rejected? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_hex_number()] [Mixed Case Hex] Does get_hex_number() properly handle mixed case like '0xAbCdEf', or can case sensitivity issues cause the same numeric literal to be tokenized differently on different platforms? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_decimal_number()] [Leading Zeros] The get_decimal_number() function (lines 717-723) allows any sequence of 0-9 digits. Can leading zeros like '00000123' be used to create ambiguous numeric literals that different parser implementations interpret as octal vs decimal? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_decimal_number()] [Underscore Handling] Underscores are allowed in decimal numbers for readability. Can patterns like '1__2__3' with multiple consecutive underscores be used to bypass downstream numeric validation that doesn't expect them? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_decimal_number()] [Maximum Length] Does get_decimal_number() enforce maximum length limits, or can attacker provide arbitrarily long numeric strings like '99999999...' (10000 digits) to cause excessive memory consumption in subsequent parsing phases? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_number_maybe_with_suffix()] [Type Suffix Parsing] In get_number_maybe_with_suffix() (lines 735-757), suffixes are checked with starts_with(). Can an attacker use suffix like 'u8x' where 'u8' matches but 'x' is separate token, causing the number and 'x' to be tokenized ambiguously? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_number_maybe_with_suffix()] [Suffix Precedence] The suffix checks at lines 737-752 use if-else chain checking 2-char then 3-char then 4-char suffixes. Can this ordering be exploited where 'u256' is checked before 'u25' causing unexpected tokenization if 'u25' was valid? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_number_maybe_with_suffix()] [Signed Integer Suffixes] The function accepts signed type suffixes (i8, i16, i32, i64, i128, i256). Are these signed types actually valid in Move language, or can accepting them allow unsupported types that cause issues in later compilation phases? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_number_maybe_with_suffix()] [u256 Support] The code accepts 'u256' suffix (line 747-750). Is u256 actually implemented in Move VM, or can this allow contracts using u256 to compile but fail at runtime causing stuck transactions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_number_maybe_with_suffix()] [Overflow in Addition] When returning (Tok::NumTypedValue, num_text_len + 2/3/4), can num_text_len be close to usize::MAX causing integer overflow in the addition, returning wrong token length? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Byte String Validation] In byte string parsing starting at line 495, the code checks for x\\"
]