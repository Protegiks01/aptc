[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Scope depth increment] The function pushes to unused without incrementing current_depth() consistently with add_and_shadow_all() - can this cause depth mismatches during set_to_outer_scope()? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [Early return bypass] If outer_scope.0 is None, the function returns empty AliasSet - can this cause unused aliases to be lost when popping scopes with no outer scope? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [mem::replace atomicity] The mem::replace() at line 259 swaps self with outer_scope - can concurrent access cause partial state during this swap, leading to inconsistent alias resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [Depth assertion] The assert at line 261 checks depth relationship - can an attacker craft malicious scope operations to violate this assertion and panic the compiler during critical deployments? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [Unused vector pop] The pop() at line 262 can return None if unused is empty - but the code uses unwrap(), can this panic if unused vector is corrupted? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [Scope leakage] After swapping to outer_scope, inner_scope.unused is transferred to outer_scope.unused - can this cause unused tracking data from inner scopes to leak into outer scopes? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: set_to_outer_scope()] [Double pop vulnerability] Can calling set_to_outer_scope() twice with the same OldAliasMap cause the unused vector to be popped twice, corrupting scope tracking? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: current_depth()] [usize overflow] The function returns self.unused.len() directly - can extremely deep nesting cause usize to overflow, wrapping to 0 and causing depth calculations to fail? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: current_depth()] [Vec length manipulation] If an attacker can manipulate unused vector length through memory corruption, can this cause current_depth() to return incorrect values and break shadowing? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasSet::new()] [UniqueSet initialization] The function creates empty UniqueSets - can default initialization of UniqueSet be exploited if the underlying implementation has unsafe initialization logic? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasSet::is_empty()] [Short-circuit optimization] The is_empty() check uses && operator - can the order of evaluation be exploited to hide non-empty members if modules is non-empty? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasMapBuilder::new()] [Builder pattern safety] The builder starts with empty UniqueMaps - can concurrent modification of the builder before aliases are added cause race conditions? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasMapBuilder::is_empty()] [Empty builder attacks] If an attacker can force AliasMapBuilder to always be empty, can this bypass add_and_shadow_all()'s early return and prevent proper scope tracking? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasMap::new()] [Empty unused vector] The unused vector starts empty - can this cause current_depth() to return 0 even after scopes are created, breaking depth tracking? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: AliasMap::is_empty()] [Unused tracking ignored] The is_empty() check ignores unused vector - can an AliasMap report as empty while still containing stale unused tracking data? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: OldAliasMap::is_empty()] [Option unwrapping] The is_empty() method matches on Option - can None values be exploited to report empty when aliases actually exist in the outer scope? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Struct: OldAliasMap] [Wrapper transparency] OldAliasMap(Option<AliasMap>) is a thin wrapper - can pattern matching bugs in calling code bypass the Option and access freed AliasMap memory? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Cross-function: add_module_alias + module_alias_get] [State consistency] Can an attacker add a module alias with add_module_alias() then immediately call module_alias_get() before the alias is fully initialized, reading partial state? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Cross-function: add_and_shadow_all + set_to_outer_scope] [Scope depth divergence] Can mismatched calls to add_and_shadow_all() and set_to_outer_scope() cause validators to have different unused vector lengths, leading to non-deterministic compilation? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Cross-function: shadow_for_type_parameters + member_alias_get] [Type param shadowing bypass] Can type parameters added via shadow_for_type_parameters() be confused with member aliases when member_alias_get() is called, causing incorrect name resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Cross-function: Implicit vs explicit aliases] [Tracking inconsistency] Can mixing add_implicit_module_alias() and add_module_alias() cause unused tracking to become inconsistent, where some aliases are tracked and others are not? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Cross-function: Multiple builder operations] [Builder state corruption] Can calling add_module_alias() and add_member_alias() with the same name on AliasMapBuilder cause internal UniqueMap state corruption? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Determinism: Clone operations] [Non-deterministic iteration] The clone() operations at lines 204, 245 clone entire HashMaps - can hash randomization cause different iteration orders across validators, leading to non-deterministic bytecode? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Determinism: Unused tracking] [Validator divergence] If different validators track unused aliases differently due to timing or ordering, can this cause compilation to succeed on some validators and fail on others? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Determinism: Location preservation] [Location-dependent compilation] The functions preserve original name locations - can different validators with different source file formatting produce different location metadata, causing bytecode divergence? (High)"
]