[
  "[File: aptos-core/crates/transaction-generator-lib/src/lib.rs] [Edge case] Can generate_transactions() be called with num_to_create = 0, causing empty transaction batches or logic errors? (Low)",
  "[File: aptos-core/crates/transaction-generator-lib/src/lib.rs] [Edge case] Can transaction generation with non_conflicting=true fail if addresses_pool.len() < 2, causing division by zero? (Medium)",
  "[File: aptos-core/crates/transaction-generator-lib/src/lib.rs] [Edge case] Can empty transaction_mix_per_phase Vec cause the generator to produce no transactions, leading to liveness issues? (Medium)",
  "[File: aptos-core/crates/transaction-generator-lib/src/lib.rs] [Edge case] Can weight = 0 in transaction mix cause transactions of that type to never be generated? (Low)",
  "[File: aptos-core/crates/transaction-generator-lib/src/lib.rs]\n\n### Citations\n\n**File:** crates/transaction-generator-lib/src/lib.rs (L1-567)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n#![forbid(unsafe_code)]\n\nuse anyhow::Result;\nuse aptos_infallible::{RwLock, RwLockWriteGuard};\nuse aptos_logger::{sample, sample::SampleRate};\nuse aptos_sdk::{\n    move_types::account_address::AccountAddress,\n    transaction_builder::{aptos_stdlib, TransactionFactory},\n    types::{transaction::SignedTransaction, LocalAccount},\n};\nuse async_trait::async_trait;\nuse clap::{Parser, ValueEnum};\nuse log::{info, warn};\nuse publishing::{\n    entry_point_trait::{EntryPointTrait, PreBuiltPackages},\n    publish_util::PackageHandler,\n};\nuse rand::{rngs::StdRng, seq::SliceRandom, Rng};\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc,\n    },\n    time::Duration,\n};\nuse workflow_delegator::WorkflowKind;\n\npub mod account_generator;\npub mod accounts_pool_wrapper;\nmod batch_transfer;\nmod bounded_batch_wrapper;\npub mod call_custom_modules;\npub mod entry_points;\nmod p2p_transaction_generator;\npub mod publish_modules;\npub mod publishing;\nmod transaction_mix_generator;\npub mod workflow_delegator;\nuse self::{\n    account_generator::AccountGeneratorCreator,\n    call_custom_modules::CustomModulesDelegationGeneratorCreator,\n    p2p_transaction_generator::P2PTransactionGeneratorCreator,\n    publish_modules::PublishPackageCreator,\n    transaction_mix_generator::PhasedTxnMixGeneratorCreator,\n};\nuse crate::{\n    accounts_pool_wrapper::AccountsPoolWrapperCreator,\n    batch_transfer::BatchTransferTransactionGeneratorCreator,\n    entry_points::EntryPointTransactionGenerator, p2p_transaction_generator::SamplingMode,\n    workflow_delegator::WorkflowTxnGeneratorCreator,\n};\npub use publishing::{\n    entry_point_trait,\n    prebuild_packages::{create_prebuilt_packages_bundle, PrebuiltPackageConfig},\n};\n\npub const SEND_AMOUNT: u64 = 1;\n\n#[derive(Debug, Clone)]\npub enum TransactionType {\n    CoinTransfer {\n        invalid_transaction_ratio: usize,\n        sender_use_account_pool: bool,\n        non_conflicting: bool,\n        use_fa_transfer: bool,\n        use_txn_payload_v2_format: bool,\n        use_orderless_transactions: bool,\n    },\n    AccountGeneration {\n        add_created_accounts_to_pool: bool,\n        max_account_working_set: usize,\n        creation_balance: u64,\n    },\n    PublishPackage {\n        use_account_pool: bool,\n        pre_built: &'static dyn PreBuiltPackages,\n        package_name: String,\n    },\n    CallCustomModules {\n        entry_point: Box<dyn EntryPointTrait>,\n        num_modules: usize,\n        use_account_pool: bool,\n    },\n    CallCustomModulesMix {\n        entry_points: Vec<(Box<dyn EntryPointTrait>, usize)>,\n        num_modules: usize,\n        use_account_pool: bool,\n    },\n    BatchTransfer {\n        batch_size: usize,\n    },\n    Workflow {\n        workflow_kind: Box<dyn WorkflowKind>,\n        num_modules: usize,\n        progress_type: WorkflowProgress,\n    },\n}\n\n#[derive(Debug, Copy, Clone, ValueEnum, Default, Deserialize, Parser, Serialize)]\npub enum AccountType {\n    #[default]\n    Local,\n    Keyless,\n}\n\n#[derive(Debug, Copy, Clone)]\npub enum WorkflowProgress {\n    MoveByPhases,\n    WhenDone { delay_between_stages_s: u64 },\n}\n\nimpl WorkflowProgress {\n    pub fn when_done_default() -> Self {\n        Self::WhenDone {\n            delay_between_stages_s: 10,\n        }\n    }\n}\n\nimpl Default for TransactionType {\n    fn default() -> Self {\n        TransactionType::CoinTransfer {\n            invalid_transaction_ratio: 0,\n            sender_use_account_pool: false,\n            non_conflicting: false,\n            use_fa_transfer: true,\n            use_txn_payload_v2_format: false,\n            use_orderless_transactions: false,\n        }\n    }\n}\n\npub trait TransactionGenerator: Sync + Send {\n    fn generate_transactions(\n        &mut self,\n        account: &LocalAccount,\n        num_to_create: usize,\n    ) -> Vec<SignedTransaction>;\n}\n\n#[async_trait]\npub trait TransactionGeneratorCreator: Sync + Send {\n    fn create_transaction_generator(&self) -> Box<dyn TransactionGenerator>;\n}\n\npub struct CounterState {\n    pub submit_failures: Vec<AtomicUsize>,\n    pub wait_failures: Vec<AtomicUsize>,\n    pub successes: AtomicUsize,\n    // (success, submit_fail, wait_fail)\n    pub by_client: HashMap<String, (AtomicUsize, AtomicUsize, AtomicUsize)>,\n}\n\n#[async_trait]\npub trait ReliableTransactionSubmitter: Sync + Send {\n    async fn get_account_balance(&self, account_address: AccountAddress) -> Result<u64>;\n\n    async fn query_sequence_number(&self, account_address: AccountAddress) -> Result<u64>;\n\n    async fn execute_transactions(&self, txns: &[SignedTransaction]) -> Result<()> {\n        self.execute_transactions_with_counter(txns, &CounterState {\n            submit_failures: vec![AtomicUsize::new(0)],\n            wait_failures: vec![AtomicUsize::new(0)],\n            successes: AtomicUsize::new(0),\n            by_client: HashMap::new(),\n        })\n        .await\n    }\n\n    async fn execute_transactions_with_counter(\n        &self,\n        txns: &[SignedTransaction],\n        state: &CounterState,\n    ) -> Result<()>;\n\n    fn create_counter_state(&self) -> CounterState;\n}\n\nfn failed_requests_to_trimmed_vec(failed_requests: &[AtomicUsize]) -> Vec<usize> {\n    let mut result = failed_requests\n        .iter()\n        .map(|c| c.load(Ordering::Relaxed))\n        .collect::<Vec<_>>();\n    while result.len() > 1 && *result.last().unwrap() == 0 {\n        result.pop();\n    }\n    result\n}\n\nimpl CounterState {\n    pub fn show_simple(&self) -> String {\n        format!("
]