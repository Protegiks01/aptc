[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Combined Attack: Flag Manipulation + Filter Bypass] Can an attacker manipulate compilation environment flags during compilation AND craft attributes that are misrecognized, combining these vulnerabilities to include malicious verification code in production bytecode that creates backdoors in Move contracts? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Combined Attack: TOCTOU + Caching] If compilation results are cached AND verification flags can change between compilation and deployment, can an attacker exploit time-of-check-time-of-use to deploy bytecode that includes filtered code to the blockchain? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Combined Attack: Attribute Confusion + Reference Leaking] Can an attacker craft Move code where verify_only code is filtered but references to it remain, then exploit these dangling references to cause memory corruption or type confusion in the Move VM at runtime? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Code Quality: Ignoring is_source_def] At line 31, the is_source_def parameter is explicitly ignored with underscore prefix - is this intentional or a bug? Should source definitions be filtered differently than library definitions to prevent supply chain attacks via malicious libraries? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Code Quality: No Logging] The filtering logic at lines 50-57 has no diagnostic logging or telemetry - if filtering behaves unexpectedly, can this be detected, or will silent failures go unnoticed until deployed code breaks? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Code Quality: No Tests Referenced] There are no inline test annotations or test references in the file - is the filtering logic adequately tested for all edge cases, attribute combinations, and failure modes? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Governance: Attribute Changes] If Aptos governance adds new verification-related attributes in the future, does this filter automatically handle them via the known_attributes resolution at line 67, or could new attributes bypass filtering? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Governance: Compiler Upgrades] During on-chain compiler upgrades, if the filtering logic changes between versions, can this cause validators running different compiler versions to produce incompatible bytecode, splitting the network? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Governance: Flag Defaults] The verification flag defaults are defined elsewhere - if governance changes default flag values or introduces new compilation modes, can this inadvertently change filtering behavior and include/exclude unexpected code? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Line 54: any() predicate] The any() check only looks for VerifyOnly variant - if VerificationAttribute enum is extended with other variants in the future, will they be handled correctly or could they bypass the is_verify_only check? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Line 56: Boolean logic] The expression 'is_verify_only && !env.flags().is_verification()' removes verify_only code when NOT in verification mode - is the double negative logic correct? Could a logic error allow verify_only code in production or exclude it from verification builds? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Line 52: flat_map + collect] The combination of flat_map (lazy) followed by collect (eager) - does this have the intended semantics, or could lazy evaluation cause attributes to be processed out of order or multiple times? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/verification/ast_filter.rs] [Line 44: Context creation] Context::new is called with mutable reference to compilation_env - what prevents this reference from being aliased elsewhere, violating Rust's borrowing rules and potentially causing undefined behavior? (Low)"
]