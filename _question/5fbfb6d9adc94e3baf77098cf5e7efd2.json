[
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: get_Nth_root_of_unity()] [Timing Attack] The loop at line 106 runs a variable number of times based on log_N, could timing differences leak information about domain sizes being used in cryptographic protocols if an attacker can measure execution time? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: is_order()] [Timing Attack] The loop at line 214 runs K-1 times doing field multiplications, for domains of different sizes used in different transaction types, could timing analysis distinguish transaction types or proof complexities? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: BatchEvaluationDomain::new()] [Timing Attack] The initialization loops run N iterations at line 128 and log_N iterations at line 137, could timing measurements reveal domain sizes used in secret protocols? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: smallest_power_of_2_greater_than_or_eq()] [Boundary] For n = 1, the function returns (1, 0), creating a domain with a single point, is this mathematically valid for FFT operations or should the minimum domain size be 2? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: smallest_power_of_2_greater_than_or_eq()] [Boundary] For n = 2^63 on 64-bit systems, N would become 2^63 and log_N = 63, but is this representable in usize (which is u64 on 64-bit), or does the next power (2^64) overflow? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: get_subdomain()] [Boundary] When k equals self.omegas.len() (i.e., k = N), the assertion at line 164 passes (k <= N), but is a subdomain of size N valid, or should this be k < N to ensure proper subdomains? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/blstrs/evaluation_domain.rs] [Function: BatchEvaluationDomain::new()] [Off-by-One] The N_inverses loop at line 137 uses\n\n### Citations\n\n**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L1-231)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n//! Evaluation domains and batched evaluation domains for radix-2 FFTs over the BLS12-381 scalar field.\n\nuse crate::CryptoMaterialError;\nuse blstrs::Scalar;\nuse ff::{Field, PrimeField};\nuse more_asserts::{assert_gt, assert_le};\nuse serde::{Deserialize, Serialize};\n\n/// This struct abstracts the notion of an FFT evaluation domain over the scalar field of our curve.\n/// This consists of $N = 2^k$ and an $N$th root of unity. (The $\\log_2{N}$ field is just handy in our FFT\n/// implementation.)\n#[allow(non_snake_case)]\n#[derive(Clone, PartialEq, Eq, Debug, Deserialize, Serialize)]\npub struct EvaluationDomain {\n    /// The actual number $n$ of evaluations we want, which might not be a power of two.\n    pub(crate) n: usize,\n    /// The smallest power of two $N \\ge n$.\n    pub(crate) N: usize,\n    /// $\\log_2{N}$\n    pub(crate) log_N: usize,\n    /// An $N$th primitive root of unity $\\omega$ that generates a multiplicative subgroup $\\{\\omega^0, \\omega^1, \\ldots, \\omega^{N-1}\\}$.\n    pub(crate) omega: Scalar,\n    /// The inverse $\\omega^{-1}$.\n    pub(crate) omega_inverse: Scalar,\n    // geninv: Scalar,\n    /// The inverse of $N$ when viewed as a scalar in the multiplicative group of the scalar field.\n    pub(crate) N_inverse: Scalar,\n}\n\n/// A `BatchEvaluationDomain` struct encodes multiple `EvaluationDomain` structs in a more efficient way.\n/// This is very useful when doing FFTs of different sizes (e.g., 1, 2, 4, 8, 16, ... in an accumulator-style\n/// polynomial multiplication; see `accumulator_poly` function) and we want to avoid recomputing the\n/// same roots of unity multiple times, as well as other scalars.\n#[allow(non_snake_case)]\n#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]\npub struct BatchEvaluationDomain {\n    /// $\\log_2{N}$\n    pub(crate) log_N: usize,\n    /// A vector of all $N$th roots of unity $\\{\\omega^0, \\omega^1, \\omega^2, \\ldots, \\omega^{N-1}\\}$\n    omegas: Vec<Scalar>,\n    /// A vector of $i^{-1}$, for all $i \\in \\{1, 2, 4, 8, \\ldots, N/2, N\\}$\n    N_inverses: Vec<Scalar>,\n}\n\n/// Returns the highest $N = 2^k$ such that $N \\ge n$.\n#[allow(non_snake_case)]\npub fn smallest_power_of_2_greater_than_or_eq(n: usize) -> (usize, usize) {\n    let mut N = 1;\n    let mut log_N: usize = 0;\n\n    while N < n {\n        N <<= 1;\n        log_N += 1;\n    }\n\n    (N, log_N)\n    // TODO: Replace with:\n    // let N = n.next_power_of_two();\n    // let log_N = N.trailing_zeros() as usize;\n    // (N, log_N)\n}\n\nimpl EvaluationDomain {\n    /// `n` is the max number of evaluations at the roots of unity we want to get, but might not be\n    /// a power of two. So we find the smallest $N$ which a power of two such that $N >= n$.\n    ///\n    /// For FFT-based multiplication, we set $n - 1$ to be the degree of the polynomials we are\n    /// multiplying.\n    #[allow(non_snake_case)]\n    pub fn new(n: usize) -> Result<EvaluationDomain, CryptoMaterialError> {\n        // Compute the size of our evaluation domain\n        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);\n\n        // The pairing-friendly curve may not be able to support\n        // large enough (radix2) evaluation domains.\n        if log_N >= Scalar::S as usize {\n            return Err(CryptoMaterialError::WrongLengthError);\n        }\n\n        // Compute $\\omega$, the $N$th primitive root of unity\n        let omega = Self::get_Nth_root_of_unity(log_N);\n\n        Ok(EvaluationDomain {\n            n,\n            N,\n            log_N,\n            omega,\n            omega_inverse: omega.invert().unwrap(),\n            // geninv: Scalar::multiplicative_generator().invert().unwrap(),\n            N_inverse: Scalar::from(N as u64).invert().unwrap(),\n        })\n    }\n\n    /// Efficiently returns the $N$th primitive root of unity that's been precomputed in this evaluation domain.\n    pub fn get_primitive_root_of_unity(&self) -> &Scalar {\n        &self.omega\n    }\n\n    /// Returns a primitive $N$th root of unity in the scalar field, given $\\log_2{N}$ as an argument.\n    #[allow(non_snake_case)]\n    fn get_Nth_root_of_unity(log_N: usize) -> Scalar {\n        let mut omega = Scalar::ROOT_OF_UNITY;\n        for _ in log_N..Scalar::S as usize {\n            omega = omega.square();\n        }\n        omega\n    }\n}\n\nimpl BatchEvaluationDomain {\n    /// Returns a batch evaluation domain for FFTs of size $1, 2, 4, 8, 16, \\ldots n$, where $n$ is the\n    /// number of coefficients in the polynomial $f(X) \\cdot g(X)$.\n    ///\n    /// This then allows more efficient fetching of subdomains for any of those sizes than via\n    /// `get_evaluation_dom_for_multiplication`.\n    #[allow(non_snake_case)]\n    pub fn new(n: usize) -> Self {\n        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);\n        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);\n\n        let mut omegas = Vec::with_capacity(N);\n        omegas.push(Scalar::ONE);\n\n        let mut acc = omega;\n        for _ in 1..N {\n            omegas.push(acc);\n            acc *= omega; // $\\omega^i$\n        }\n\n        debug_assert_eq!(omegas.len(), N);\n\n        let mut N_inverses = Vec::with_capacity(log_N);\n        let mut i = 1u64;\n        for _ in 0..=log_N {\n            N_inverses.push(Scalar::from(i).invert().unwrap());\n\n            i *= 2;\n        }\n\n        debug_assert_eq!(\n            N_inverses.last().unwrap().invert().unwrap(),\n            Scalar::from(N as u64)\n        );\n\n        BatchEvaluationDomain {\n            log_N,\n            omegas,\n            N_inverses,\n        }\n    }\n\n    /// Returns the size `N` of the batch evaluation domain.\n    #[allow(non_snake_case)]\n    pub fn N(&self) -> usize {\n        self.omegas.len()\n    }\n\n    /// Returns the equivalent of `EvaluationDomain::new(k)`, but much faster since everything is precomputed.\n    #[allow(non_snake_case)]\n    pub fn get_subdomain(&self, k: usize) -> EvaluationDomain {\n        assert_le!(k, self.omegas.len());\n        assert_ne!(k, 0);\n\n        let (K, log_K) = smallest_power_of_2_greater_than_or_eq(k);\n        assert_gt!(K, 0);\n\n        let K_inverse = self.N_inverses[log_K];\n        debug_assert_eq!(K_inverse.invert().unwrap(), Scalar::from(K as u64));\n\n        let mut idx = 1;\n        for _ in log_K..self.log_N {\n            // i.e., omega = omega.square();\n            idx *= 2;\n        }\n        // TODO: idx == 2^(self.log_N - log_K)\n\n        let N = self.omegas.len();\n        let omega = self.omegas[idx % N]; // TODO: %N seems unnecessary\n        debug_assert!(Self::is_order(&omega, K));\n\n        let omega_inverse = self.omegas[(N - idx) % N]; // TODO: %N seems unnecessary\n        debug_assert_eq!(omega_inverse.invert().unwrap(), omega);\n\n        EvaluationDomain {\n            n: k,\n            N: K,\n            log_N: log_K,\n            omega,\n            omega_inverse,\n            N_inverse: K_inverse,\n        }\n    }\n\n    /// Efficiently returns the $i$th $N$th root of unity $\\omega^i$, for $i\\in[0, N)$.\n    pub fn get_root_of_unity(&self, i: usize) -> Scalar {\n        self.omegas[i]\n    }\n\n    /// Efficiently returns all the $N$th roots of unity.\n    pub fn get_all_roots_of_unity(&self) -> &Vec<Scalar> {\n        self.omegas.as_ref()\n    }\n\n    /// Asserts the order of $\\omega$ is $K$.\n    #[allow(non_snake_case)]\n    fn is_order(omega: &Scalar, K: usize) -> bool {\n        assert_gt!(K, 0);\n        let mut acc = *omega;\n\n        // First, check that \\omega^1, \\omega^2, \\omega^{K-1} are NOT the identity.\n        for _ in 1..=K - 1 {\n            // println!("
]