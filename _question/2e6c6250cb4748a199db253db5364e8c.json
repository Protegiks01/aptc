[
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: process_new_observation()] [Equivocation] Can a Byzantine validator sign multiple different ProviderJWKs for the same issuer and version, sending different proposals to different peers? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: process_peer_request()] [Selective Response] Can a Byzantine validator selectively respond to observation requests from only certain peers to split consensus? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: process_quorum_certified_update()] [Byzantine Quorum] If > 1/3 but < 2/3 validators are Byzantine, can they prevent quorum formation while honest validators waste resources? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: process_new_observation()] [Observation Spam] Can Byzantine validators continuously trigger new observations with slightly different jwks to spam the network and prevent convergence? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: process_peer_request()] [State Probing] Can Byzantine validators probe other validators' consensus states to time attacks based on who has reached InProgress vs Finished? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: run()] [Observer Manipulation] Can an attacker compromise OIDC provider endpoints to serve malicious JWKs to some validators but not others, causing consensus splits? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: run()] [Observer Timing] Can attackers control timing of JWK updates at provider endpoints to manipulate which validators observe changes first, influencing consensus outcomes? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: run()] [Observer DoS] Can observers be forced into infinite retry loops by provider endpoints returning transient errors, consuming validator resources? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/jwk_manager/mod.rs] [Function: tear_down()] [Observer Shutdown] Can observer shutdown take excessively long if endpoints are unresponsive, blocking epoch transitions? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src\n\n### Citations\n\n**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L1-383)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    jwk_observer::JWKObserver,\n    mode::per_issuer::PerIssuerMode,\n    network::IncomingRpcRequest,\n    types::{\n        ConsensusState, JWKConsensusMsg, ObservedUpdate, ObservedUpdateResponse,\n        QuorumCertProcessGuard,\n    },\n    update_certifier::TUpdateCertifier,\n    TConsensusManager,\n};\nuse anyhow::{anyhow, bail, Context, Result};\nuse aptos_channels::{aptos_channel, message_queues::QueueStyle};\nuse aptos_crypto::{bls12381::PrivateKey, SigningKey};\nuse aptos_logger::{debug, error, info, warn};\nuse aptos_types::{\n    account_address::AccountAddress,\n    epoch_state::EpochState,\n    jwks::{\n        jwk::JWKMoveStruct, AllProvidersJWKs, Issuer, OIDCProvider, ObservedJWKs,\n        ObservedJWKsUpdated, ProviderJWKs, QuorumCertifiedUpdate, SupportedOIDCProviders,\n    },\n    validator_txn::{Topic, ValidatorTransaction},\n};\nuse aptos_validator_transaction_pool::VTxnPoolState;\nuse futures_channel::oneshot;\nuse futures_util::{future::join_all, FutureExt, StreamExt};\nuse std::{\n    collections::{HashMap, HashSet},\n    sync::Arc,\n    time::Duration,\n};\n\n/// `JWKManager` executes per-issuer JWK consensus sessions\n/// and updates validator txn pool with quorum-certified JWK updates.\npub struct IssuerLevelConsensusManager {\n    /// Some useful metadata.\n    my_addr: AccountAddress,\n    epoch_state: Arc<EpochState>,\n\n    /// Used to sign JWK observations before sharing them with peers.\n    consensus_key: Arc<PrivateKey>,\n\n    /// The sub-process that collects JWK updates from peers and aggregate them into a quorum-certified JWK update.\n    update_certifier: Arc<dyn TUpdateCertifier<PerIssuerMode>>,\n\n    /// When a quorum-certified JWK update is available, use this to put it into the validator transaction pool.\n    vtxn_pool: VTxnPoolState,\n\n    /// The JWK consensus states of all the issuers.\n    states_by_issuer: HashMap<Issuer, PerProviderState>,\n\n    /// Whether a CLOSE command has been received.\n    stopped: bool,\n\n    qc_update_tx: aptos_channel::Sender<Issuer, QuorumCertifiedUpdate>,\n    qc_update_rx: aptos_channel::Receiver<Issuer, QuorumCertifiedUpdate>,\n    jwk_observers: Vec<JWKObserver>,\n}\n\nimpl IssuerLevelConsensusManager {\n    pub fn new(\n        consensus_key: Arc<PrivateKey>,\n        my_addr: AccountAddress,\n        epoch_state: Arc<EpochState>,\n        update_certifier: Arc<dyn TUpdateCertifier<PerIssuerMode>>,\n        vtxn_pool: VTxnPoolState,\n    ) -> Self {\n        let (qc_update_tx, qc_update_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);\n        Self {\n            consensus_key,\n            my_addr,\n            epoch_state,\n            update_certifier,\n            vtxn_pool,\n            states_by_issuer: HashMap::default(),\n            stopped: false,\n            qc_update_tx,\n            qc_update_rx,\n            jwk_observers: vec![],\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl TConsensusManager for IssuerLevelConsensusManager {\n    async fn run(\n        self: Box<Self>,\n        oidc_providers: Option<SupportedOIDCProviders>,\n        observed_jwks: Option<ObservedJWKs>,\n        mut jwk_updated_rx: aptos_channel::Receiver<(), ObservedJWKsUpdated>,\n        mut rpc_req_rx: aptos_channel::Receiver<\n            AccountAddress,\n            (AccountAddress, IncomingRpcRequest),\n        >,\n        close_rx: oneshot::Receiver<oneshot::Sender<()>>,\n    ) {\n        let mut this = self;\n        this.reset_with_on_chain_state(observed_jwks.unwrap_or_default().into_providers_jwks())\n            .unwrap();\n\n        let (local_observation_tx, mut local_observation_rx) =\n            aptos_channel::new(QueueStyle::KLAST, 100, None);\n\n        this.jwk_observers = oidc_providers\n            .unwrap_or_default()\n            .into_provider_vec()\n            .into_iter()\n            .filter_map(|provider| {\n                let OIDCProvider { name, config_url } = provider;\n                let maybe_issuer = String::from_utf8(name);\n                let maybe_config_url = String::from_utf8(config_url);\n                match (maybe_issuer, maybe_config_url) {\n                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(\n                        this.epoch_state.epoch,\n                        this.my_addr,\n                        issuer,\n                        config_url,\n                        Duration::from_secs(10),\n                        local_observation_tx.clone(),\n                    )),\n                    (maybe_issuer, maybe_config_url) => {\n                        warn!("
]