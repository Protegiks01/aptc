[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Cryptographic: Domain separation bypass] The sign() function (lines 222-226) signs generic CryptoHash types - without proper domain separation in the hash function, can signatures be replayed across different message contexts in Aptos consensus? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Cryptographic: Signature malleability] The to_bytes() implementation (lines 299-303) converts signatures to bytes - if the underlying signature scheme has malleability issues, can attackers create alternative valid byte representations causing transaction hash changes? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Cryptographic: Verification oracle] The verify_arbitrary_msg() function (lines 289-297) verifies raw bytes - can this be exploited as a signature verification oracle to perform chosen-message attacks against validator keys? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Rust: proc_macro TokenStream injection] Lines 85, 137, 164, 178, 196, 240 return TokenStream - can malicious derive macro attributes inject arbitrary Rust code into generated trait implementations, enabling backdoors in cryptographic operations? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Rust: quote! macro injection] The quote! macro is used throughout (lines 22, 23, 28, 46-60, etc.) - can attacker-controlled enum variant names or field names inject malicious code through quote! expansion? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Rust: syn parsing vulnerabilities] Lines 10-13, 15-19 use syn crate for parsing - are there known vulnerabilities in syn that could be exploited to inject malicious structures during macro expansion? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Rust: Ident hygiene] Variant identifiers are used directly in generated code (lines 38, 51, 76, 141, 207, 252, 264) - can unhygienic identifier expansion cause name collisions or access to unintended variables in generated code? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Consensus: Deterministic serialization] The to_bytes() implementations generated by lines 88-90 and 299-303 must be deterministic - can non-deterministic serialization cause different validators to compute different transaction hashes, breaking consensus? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Consensus: Signature verification consistency] The verify() implementation on lines 279-287 must be consistent across all validators - can platform-specific differences in generated code cause verification disagreements, leading to chain splits? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Consensus: Version compatibility] If enum variants are added or reordered, does the TryFrom chain (lines 46-60) maintain backward compatibility, or will old transactions fail to deserialize on updated validators, causing consensus failures? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [State: Key material persistence] The ValidCryptoMaterial trait (lines 92-98) is used for key storage - can serialization inconsistencies cause keys to deserialize differently after state synchronization, locking validators out of the network? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Error: Empty enum handling] Lines 35-37 panic on empty enums - can this be exploited during protocol upgrades where enum variants are temporarily removed, causing all validators to crash simultaneously? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Error: Fieldless variant handling] Lines 39-44 and 51-56 expect variants to have fields - can fieldless enum variants cause panics or generate broken code that compiles but fails at runtime during signature operations? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Error: Attribute absence] Lines 108-112 return errors when attributes are missing - can missing attributes on cryptographic enums cause compilation failures during validator software updates, preventing emergency patches? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Error: Type parsing failures] Line 138 uses unwrap() on type parsing - can invalid type paths in attributes cause build failures, and could this be exploited to prevent validators from compiling critical security fixes? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Error: Pattern match exhaustiveness] The verify() function (lines 280-286) requires exact variant matching - if new variants are added to one enum but not others, can this cause runtime panics during normal operations, halting consensus? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Memory: Key material leakage] The to_vec() calls on line 79 clone cryptographic key material - are sensitive values properly zeroed after use, or can memory dumps from crashed validators leak private keys? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Memory: Reference lifetime safety] Lines 27-28 handle reference types - can incorrect lifetime annotations in generated code cause use-after-free vulnerabilities when accessing cryptographic key material? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Side-channel: Timing attacks] The verify() implementation (lines 279-287) branches on variant matching - can timing differences between different enum variants leak information about which cryptographic algorithm is being used, aiding targeted attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Side-channel: Error message timing] Lines 282-286 and 292-296 construct detailed error messages - can the time taken to format these errors leak information about signature validity, enabling timing-based oracle attacks? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Supply chain: Macro expansion attack] This file is in third_party/move/move-examples path - is this code audited as carefully as core Aptos code, or could upstream Move framework vulnerabilities propagate to Aptos validators? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Supply chain: Dependency vulnerabilities] The file uses syn (line 7) and quote (line 6) crates - are these dependencies pinned to audited versions, or could malicious updates to these crates compromise cryptographic code generation? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Build: Compile-time code injection] The procedural macro generates code at compile time - can attackers who compromise the build environment inject malicious code that only appears in the final binary, bypassing source code audits? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Attack scenario: Validator key rotation bypass] If the From<&PrivateKey> implementation (lines 147-154) has variant mismatches with the actual key types used, can attackers prevent key rotation during security incidents, forcing continued use of compromised keys? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Attack scenario: Transaction replay across algorithms] The sign() function (lines 222-226) doesn't encode algorithm information in signatures - can attackers take a signature from one algorithm variant and replay it against a different algorithm's verification, enabling cross-scheme attacks? (Critical)"
]