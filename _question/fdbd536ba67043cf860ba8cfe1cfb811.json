[
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Race condition] Can multiple concurrent requests race between checking current_day at line 54-55 and storing the new day at line 57-60, causing some requests to bypass rate limiting during day rollover? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Race condition] Does the check-then-act pattern between lines 54 and 61 allow attackers to send thousands of concurrent requests during day transition, all passing the check before the cache is cleared? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Race condition] Between acquiring the lock at line 75 and incrementing at line 87, can concurrent requests from the same IP bypass rate limits by racing through get_or_insert_mut before counter updates? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Atomicity violation] Can the non-atomic sequence of load (line 55), store (line 57-60), and clear (line 61) create a window where some IPs get cleared while others don't during concurrent day transitions? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [TOCTOU] Is there a time-of-check-time-of-use vulnerability between clear_if_new_day() at line 73 and acquiring the lock at line 75, allowing requests to use stale day data? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: complete()] [Race condition] Can the decrement operation at line 99 race with concurrent check() calls at line 87, causing request counts to become negative or incorrect? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Ordering issue] Does using Relaxed memory ordering at lines 55 and 59 allow reordering that could cause current_day updates to be visible before cache clears, breaking rate limit guarantees? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Integer overflow] Can the increment operation at line 87 overflow if requests_today is already at u32::MAX, wrapping to 0 and bypassing rate limits entirely? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: complete()] [Integer underflow] Can the decrement at line 99 underflow if called multiple times for the same request or when requests_today is 0, wrapping to u32::MAX and blocking legitimate requests? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: new()] [Integer overflow] Can days_since_tap_epoch at line 49 overflow when current_time_secs approaches u64::MAX, causing incorrect day calculations and rate limit bypasses? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Integer overflow] Can the comparison at line 54-55 behave incorrectly if days_since_tap_epoch overflows, preventing cache clears and permanently blocking all IPs? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: MemoryRatelimitCheckerConfig] [Configuration overflow] Can max_requests_per_day be set to u32::MAX causing the comparison at line 78 to never trigger, allowing unlimited requests? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Time manipulation] If system time jumps backward, can days_since_tap_epoch at line 54 return a smaller value than current_day, preventing cache clears indefinitely and blocking all IPs? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Day boundary race] During the exact second of day transition, can attackers exploit the narrow window where days_since_tap_epoch changes to send unlimited requests before cache clear completes? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: new()] [Initialization timing] Can incorrect initialization timing cause current_day at line 49 to be set incorrectly if get_current_time_secs() is called during a leap second or system clock adjustment? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Multiple transitions] If clear_if_new_day is called with days_since_tap_epoch jumping multiple days forward, does it correctly handle the transition or can rate limits be bypassed? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: clear_if_new_day()] [Clock skew] Can NTP clock adjustments cause days_since_tap_epoch to jump forward/backward erratically, leading to premature cache clears or permanent blocks? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Cache eviction bypass] Can attackers rotate through max_entries_in_map + 1 different IPs to evict earlier IPs from the LRU cache, allowing those evicted IPs to immediately request again and bypass daily limits? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: new()] [Memory exhaustion] Can the default max_entries_in_map of 1,000,000 at line 25 consume excessive memory (potentially 12+ MB for the cache alone), leading to OOM conditions? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [LRU manipulation] Can sophisticated attackers coordinate requests from max_entries_in_map different IPs to force eviction of target IPs, allowing controlled rate limit resets? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [State loss] When an IP is evicted from the LRU cache at line 77 due to capacity, is its request count permanently lost, allowing that IP to bypass rate limits by triggering eviction? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: new()] [Configuration vulnerability] Can max_entries_in_map be set to a very small value (e.g., NonZeroUsize::new(1)), making the rate limiter ineffective as every request evicts previous entries? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Off-by-one error] Does the >= comparison at line 78 allow exactly max_requests_per_day requests when it should allow max_requests_per_day - 1, effectively giving attackers one extra request per day? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Dry run bypass] Can attackers make unlimited dry_run=true requests at line 86 to probe the system without incrementing counters, then use gathered information to optimize attacks? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs] [Function: check()] [Initial insertion bypass] Does get_or_insert_mut at line 77 insert with value 1, meaning the first check passes even if the IP should be rate limited from a previous day? (Medium)"
]