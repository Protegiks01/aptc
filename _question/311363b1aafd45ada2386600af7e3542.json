[
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: run_simplifier()] [Target module filtering] Only target modules (line 82) are simplified - can non-target dependencies have unsimplified ASTs that cause linking errors or inconsistent semantics when called from simplified code? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: SimplifierRewriter::new()] [ConstantFolder safety] The ConstantFolder is created with false for the second parameter (line 558) - what does this parameter control, and can incorrect initialization lead to wrong constant folding? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: SimplifierRewriter::rewrite_function_body()] [State initialization order] The function calls find_possibly_modified_vars before clearing visiting_binding and values (lines 596-602) - can stale state from previous function compilations leak into the current function's analysis? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: SimplifierRewriter::rewrite_function_body()] [Parameter value removal] The code removes parameter symbols from the values map (lines 607-610) - but does this correctly handle all parameter types (references, generics), or can parameter constants be incorrectly propagated? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Struct: SimplifierRewriter] [Mutable state tracking] The in_mut_borrow and in_mut_borrow_stack fields (lines 534-537) track mutable borrow context - if these become desynchronized, can variables in mutable borrows be incorrectly constant-propagated? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_to_recorded_value()] [Uninitialized value handling] When a SimpleValue::Uninitialized is found (lines 621-627), the function returns None - does the caller correctly handle None to avoid eliminating the uninitialized variable binding? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_to_recorded_value()] [Value node ID reuse] The function creates a new ExpData::Value with the original node ID (line 620) - can reusing node IDs cause type checker or later compilation phases to become confused about expression origins? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: exp_to_simple_value()] [Constant value extraction] This function only recognizes ExpData::Value as a simple value (lines 643-645) - can other constant expressions (like literal tuples, constant function calls) be missed, reducing optimization opportunities or causing inconsistencies? (Low)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: expand_tuple()] [Non-empty tuple bug] If a non-empty Value::Tuple is encountered (lines 659-667), the code emits a Severity::Bug diagnostic but returns the original expression - can this cause wrong bytecode generation by leaving illegal tuple constants in the AST? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: expand_tuple()] [Empty tuple expansion] Empty tuples are expanded to Call(Tuple) operations (line 657) - is this expansion semantically equivalent, or can it change behavior in contexts that check for Value vs Call nodes? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: expand_tuple()] [Vector value handling] The comment says Value::Vector is left alone (line 653) - why are vectors and tuples treated differently, and can this inconsistency cause issues? (Low)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: try_collapse_cast()] [Type equality check] The function checks if arg0_type == result_type (line 679) to collapse casts - does this handle type equivalence correctly for complex types (references, generics, type parameters)? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: try_collapse_cast()] [Cast semantics preservation] When a cast is collapsed by returning arg0 directly (line 680), are there cases where the cast has side effects (runtime checks, numeric conversions) that should be preserved? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Borrow tracking state machine] The complex BorrowEffect state machine (lines 701-722) tracks whether expressions are borrowable - can incorrect state transitions allow mutable borrows of temporary values to be optimized away, breaking Move's reference safety? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [TransparentToBorrow handling] Select operations are marked as TransparentToBorrow (line 715) - does this correctly propagate borrow context through field selections, or can nested selects confuse the tracker? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Mutable borrow scope entry] When entering IsMutableBorrow scope (lines 731-735), in_mut_borrow is set to true - if the code then encounters a NotBorrowable subexpression, is the stack properly managed? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Borrow stack imbalance] The in_mut_borrow_stack is pushed and popped at different match arms (lines 733, 738, 759, 767) - can complex nested expressions cause stack imbalance and incorrect borrow tracking? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Protected expression wrapping] When a non-borrowable expression becomes borrowable after rewriting (lines 765-805), it's wrapped in a Sequence to create a temporary - is this wrapping applied in all necessary cases, or can some transformations bypass it? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [LocalVar wrapping logic] LocalVar nodes are wrapped in Sequence when transformed inside mutable borrows (lines 788-793) - but what if the LocalVar was already directly borrowable in the original code? Does this change semantics? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Temporary wrapping] Temporary nodes are also wrapped (lines 788-793) - can this cause issues where parameters referenced via Temporary become inaccessible to mutable borrows? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Select wrapping in borrow] Call(Operation::Select) nodes are wrapped in Sequence when in mutable borrow context (lines 790-793) - does this preserve the semantics of field selection through references? (High)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_exp()] [Node ID cloning] A new node ID is cloned for wrapped expressions (line 791) - can incorrect node ID management cause type information or source location to be lost? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_local_var()] [Mutable borrow assertion] The assertion on line 851 checks that in_mut_borrow is false when replacing a variable - but what if this assertion is compiled out in release builds, allowing unsafe substitution? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_local_var()] [Constant value substitution] When a LocalVar is replaced with its recorded constant value (lines 838-854), is the node ID preserved correctly to maintain type and location information? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs] [Function: rewrite_local_var()] [Scope visibility check] The function checks self.values.get(&sym) to find recorded values - does this correctly handle variable shadowing where inner and outer scopes have the same symbol? (High)"
]