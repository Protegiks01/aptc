[
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Validation bypass] For LOCAL_PROTOCOL, UDP variants, and UNIX sockets at line 90, original_addr is returned unchanged. Can attacker abuse this to keep proxy's address instead of revealing true source, enabling address spoofing attacks? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Type confusion] UDP_IPV4/UDP_IPV6 at line 90 are treated as LOCAL_PROTOCOL. Can attacker send UDP traffic through TCP proxy to confuse transport layer security checks or consensus message validation? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [UNIX socket attack] TCP_UNIX and UDP_UNIX at line 90 fall through to original_addr. Can attacker exploit this to bypass network address validation if downstream code expects only IP addresses? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Unreachable code] Comment at line 89 says 'TODO: Support UDP in the future'. If UDP support is added, can existing TCP-only validation logic be bypassed by UDP packets? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Version bypass] At line 69, version_and_command byte is checked. Only PPV2_LOCAL (0x20) and PPV2_PROXY (0x21) are accepted. Can attacker send 0x22-0x2F to exploit unvalidated version bits? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Command injection] PPV2_LOCAL (0x20) is accepted but treated same as PPV2_PROXY. Can attacker use LOCAL command to bypass logging, monitoring, or rate limiting that only tracks PROXY commands? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Protocol downgrade] File rejects PPV1 (comment line 10). Can attacker force fallback to non-proxy mode by sending invalid version, causing validator to accept direct connections bypassing proxy authentication? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Bit manipulation] Version/command byte uses high 4 bits for version, low 4 bits for command (comment line 68). Can attacker manipulate bits to create valid-looking but semantically incorrect commands? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Race condition] Function is async with multiple await points (lines 58, 86). Can attacker exploit race between header read and address_bytes read to inject malicious data mid-stream? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Cancellation safety] If async task is cancelled between line 58 and 86, is partial header state cleaned up properly, or can next connection reuse corrupted state causing address confusion? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Stream corruption] read_exact() at lines 58 and 86 assumes stream is in correct state. Can prior failed reads leave stream in corrupted state causing next read_header() to parse garbage as valid addresses? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Timeout handling] No timeouts on read_exact() calls. Can attacker send partial header and stall, holding validator connections open indefinitely and exhausting connection pool? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Concurrency] If multiple tasks call read_header() on same stream concurrently, can header bytes be interleaved causing both tasks to receive corrupted addresses and misroute consensus messages? (Critical)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Error leak] Error messages at lines 63, 74, 99, 114, 127 might leak internal state. Can attacker use error responses to probe validator network configuration or protocol versions? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Panic paths] try_into().unwrap() at lines 82, 104, 105, 118, 119 can panic. Can attacker craft inputs causing unwrap() panic, crashing validator node and causing network partition? (Critical)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Resource leak] If stream.read_exact() returns Err after successful header[0..16] read at line 58, is the stream left in undefined state? Can this cause resource exhaustion with repeated failed handshakes? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Error propagation] All errors return io::Error with InvalidInput kind. Can downstream code distinguish between malicious input vs network errors, potentially treating attacks as transient failures and retrying? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Incomplete validation] No validation that address_size + 16 doesn't exceed reasonable limits. Can attacker send address_size close to u16::MAX causing integer overflow when computing total header size? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Conversion failure] NetworkAddress::from(socket_addr) at lines 107, 122 might fail silently for invalid addresses. Can this return corrupted NetworkAddress causing routing failures in consensus layer? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Clone safety] original_addr.clone() at line 93 for unsupported protocols. If NetworkAddress has shared mutable state, can this cause aliasing bugs when multiple connections share same address object? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Address validation] No validation that extracted SocketAddr is valid (non-zero port, routable IP). Can attacker inject invalid addresses that break downstream peer connection logic? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Type confusion] NetworkAddress conversion from SocketAddr. Can attacker craft addresses that are valid SocketAddr but invalid NetworkAddress, causing type confusion in network layer? (Low)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Spec deviation] Comment line 16 says 'Address space that's larger than expected is rejected'. But validation at lines 97, 111 allows larger sizes. Is this exploitable to include malicious TLV data? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [TLV injection] Comment line 13 says 'Does not interpret TLVs'. Can attacker append malicious Type-Length-Value extensions after address data to exploit downstream consumers expecting clean NetworkAddress? (High)",
  "[File: aptos-core/network/netcore/src/transport/proxy_protocol.rs] [Function: read_header()] [Spec ambiguity] ProxyProtocol spec allows optional TLVs. Since code reads exact address_size bytes but doesn't validate TLV structure, can attacker inject arbitrary data disguised as TLVs? (Medium)"
]