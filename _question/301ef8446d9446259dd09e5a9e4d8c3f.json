[
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_name_len()] [Leading Digit Check] At lines 405-409, if first character is digit or EOF, length is 0, but is EOF check using unwrap_or('0') safe - can this mask actual EOF and cause incorrect name length calculation? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_name_len()] [Name Length Limit] At lines 410-412, names can be arbitrary length (text.len()) - can attacker provide extremely long identifiers causing memory exhaustion or buffer overflow in downstream processing? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [DotNameValue Validation] At lines 262-268, DotNameValue combines two names with '.', but is there validation that both parts are valid identifiers and not empty, preventing tokens like '.name' or 'name.' or '..'? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_name_token()] [Underscore Token] At line 458, single underscore '_' is Tok::Underscore, but can this be used in contexts where identifiers are expected, bypassing variable name validation? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_name_len()] [Dollar Sign Names] At line 411, '$' is allowed in names - can this enable creation of special system identifiers that conflict with compiler-generated names or reserved symbols? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_decimal_number()] [Type Suffix Priority] At lines 421-435, type suffixes are checked in order u8, u16, u32, u64, u128, u256 - can overlapping prefixes like 'u1' matching 'u128' or 'u16' cause ambiguity? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_decimal_number()] [Default u64] At line 434, numbers without suffix default to U64Value - can this cause implicit type coercion issues where attacker provides large numbers that fit in u128 but overflow when interpreted as u64? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_decimal_number()] [Suffix Case Sensitivity] Type suffixes are lowercase 'u8', 'u16', etc. - can attacker use uppercase 'U8' or mixed case 'u6' to bypass numeric type validation? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_decimal_number()] [Invalid Suffix] If attacker provides suffix like 'u7' or 'u65' that doesn't match any type, does the number get parsed as U64Value without suffix, potentially causing type confusion? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: get_decimal_number()] [Multiple Suffixes] Can attacker provide 'u8u16' or 'u64u128' to create ambiguous type annotations that cause parser confusion? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: start_loc()] [Location Accuracy] At line 166-168, start_loc() returns cur_start as usize, but are there cases where cur_start doesn't accurately reflect token start due to state corruption? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: previous_end_loc()] [Stale Previous] At line 170-172, previous_end_loc() returns prev_end which is only updated in advance() - can this return incorrect location if replace_token() is used? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Location Truncation] At line 390, start_offset is cast to u32 for location - can this truncate high bits on systems with large files, causing error locations to wrap around? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Field: file_hash] [Hash Collision] At line 133, file_hash identifies source files - if two files have same hash, can this cause token locations to be misattributed across files? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: new()] [Initial State] At lines 142-152, lexer initializes with token=EOF and all positions=0 - can this initial state cause issues if peek() or content() are called before first advance()? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Malformed Bytecode] If lexer accepts invalid token sequences that parser doesn't properly validate, can this lead to generation of malformed Move bytecode that crashes the VM or bypasses safety checks? (Critical)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Resource Safety Bypass] If tokens for resource operations (MoveTo, MoveFrom, BorrowGlobal) at lines 58-86 are misclassified due to lexer bugs, can this allow compilation of code that violates Move's resource safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Gas Metering Evasion] If numeric literals are incorrectly tokenized, can attacker create constants that bypass gas metering calculations, allowing execution of unbounded loops or operations? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Type Confusion Attack] If type suffix tokens (ToU8, ToU16, etc.) at lines 69-74 are confused with numeric types (U8Value, U16Value, etc.) at lines 13-18, can this cause type casting operations to be miscompiled? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Enum: Tok] [Freeze Token] At line 64, Freeze token exists - if this is misclassified or injected through lexer bug, can attacker create freeze operations on mutable references that shouldn't be allowed? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: is_spec_directive()] [Directive Detection] At lines 123-128, only Ensures, Requires, SucceedsIf, and AbortsIf are considered spec directives - can attacker use other spec tokens like Invariant or Old to inject spec code that bypasses verification? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Field: spec_mode] [Spec Mode Injection] At line 132, spec_mode flag changes tokenization behavior - if attacker can inject spec code in regular Move context or vice versa, can this cause verification to accept invalid programs? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Enum: Tok] [Global vs BorrowGlobal] At lines 58 and 66, BorrowGlobal is for Move code but Global is for spec language - can confusion between these cause spec-only operations to appear in executable code? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Enum: Tok] [SpecReturn vs Return] At lines 95-97, SpecReturn and Return are different - if these are confused in lexer, can spec return statements leak into Move code or vice versa? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Spec Mode Token Bypass] At lines 307-309, when spec_mode is true, special lookahead is skipped and only name token is returned - can this allow spec code to use Move-specific syntax that should be rejected? (Medium)"
]