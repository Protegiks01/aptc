[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Aptos: Event emission] [Event emission filtering] Can filtering functions that emit events break event tracking, block explorers, or fraud detection systems, enabling hidden malicious activity? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Aptos: Native functions] [Native function binding] If Move functions marked as native are filtered, can this break the binding to Rust native implementations, causing runtime crashes or allowing function replacement attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Attributes: Conditional compilation] [Conditional compilation bypass] Can attackers use attributes intended for conditional compilation (e.g., test-only code) to hide malicious production code that survives filtering? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Attributes: Deprecation markers] [Deprecation attribute abuse] Can deprecation attributes be exploited to filter critical security functions, causing callers to use insecure fallback implementations? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Attributes: Feature flags] [Feature flag filtering] If filtering is controlled by feature flags, can attackers manipulate feature flags to selectively enable/disable security checks in different deployment environments? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Attributes: Custom attributes] [Custom attribute injection] Can attackers define custom attributes that look like system attributes, tricking the filter into removing legitimate code while keeping malicious code? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Concurrency: Mutable state] [FilterContext mutation safety] Does FilterContext trait allow mutable state (&mut self), and can concurrent compilation of multiple modules cause race conditions in the filtering context state? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Concurrency: Thread safety] [Multi-threaded compilation filtering] If compilation is parallelized across threads, is the filtering process thread-safe, or can race conditions cause non-deterministic filtering results breaking consensus? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [State: Filter ordering] [State-dependent filtering] If FilterContext maintains state and filtering decisions depend on previously filtered elements, can attackers exploit this by controlling the order of module/definition processing? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Verification: Spec completeness] [Missing spec after filtering] If critical invariants are specified in spec blocks that get filtered, can this cause the Move Prover to miss security bugs, generating false proofs of correctness? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Verification: Schema filtering] [Schema spec filtering] Can filtering spec schemas (reusable verification patterns) break verification of multiple functions that depend on the schema, creating verification gaps? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Verification: Global invariants] [Module invariant filtering] If module-level invariants (spec module { invariant ... }) are filtered, can this disable critical safety properties for the entire module, enabling attacks? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Verification: Axiom filtering] [Axiom spec filtering] Can filtering spec axioms cause the prover to make incorrect assumptions about function behavior, generating unsound proofs that hide vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Dependencies: Transitive dependencies] [Transitive filtering impact] If module A depends on module B and module B's dependencies are filtered, can this break module A's compilation or create undefined behavior at runtime? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Dependencies: Circular dependencies] [Circular dependency with filtering] Can filtering modules involved in circular dependencies cause inconsistent dependency graphs, breaking module initialization order or creating deadlocks? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Dependencies: Version conflicts] [Dependency version filtering] If different versions of the same module exist and filtering applies to some versions but not others, can this cause version conflicts or allow downgrade attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Package: PackageDefinition filtering] [Package-level filtering bypass] Can attackers place malicious modules in packages with filtering attributes that are ignored at the package level, bypassing module-level filtering? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Package: named_address_map consistency] [Address map inconsistency after filtering] If filtering removes address definitions but named_address_map still references them, can this cause address resolution to map to wrong addresses, enabling address spoofing? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Address: Address aliasing] [Filtered address aliasing] If multiple named addresses map to the same address value and one alias is filtered, can this break code that uses different aliases, causing unexpected behavior? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Lines: 141-156] [Source/lib filtering divergence] The filter_program() function processes lib_definitions with is_source_def=false and source_definitions with is_source_def=true - can attackers exploit this difference to compile malicious code as library that would be filtered as source? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Lines: 158-173] [Source definition precedence] If the same module exists in both source_definitions and lib_definitions with different filtering results, which version takes precedence, and can attackers exploit precedence rules to inject malicious code? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Source/lib: API surface consistency] [Public API inconsistency] If source and library versions of the same module have different members due to filtering, can this break the public API contract and enable type confusion or ABI compatibility attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Edge case: Empty attributes] [Empty attribute handling] How are empty attribute lists handled by should_remove_by_attributes(), and can empty attributes cause default behavior that incorrectly filters or keeps code? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Edge case: Duplicate definitions] [Duplicate member filtering] If a module has duplicate function or struct names (compiler error normally), can filtering one duplicate cause the other to survive, bypassing duplicate detection? (Medium)"
]