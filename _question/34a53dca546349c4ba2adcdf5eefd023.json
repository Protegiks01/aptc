[
  "[File: third_party/move/move-model/src/ast.rs] [Function: ConditionKind::allows_old()] [Specification bypass] Can an attacker craft malicious specification conditions that incorrectly allow `old(..)` expressions in contexts where they should be forbidden (e.g., in LetPre, Requires), potentially enabling state manipulation through temporal logic violations? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ConditionKind::allowed_on_fun_decl()] [Access control bypass] Does the visibility parameter validation properly prevent private functions from having specification conditions they shouldn't have, or can attackers exploit this to add unauthorized invariants to internal functions causing verification failures? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ConditionKind::allowed_on_fun_impl()] [Specification injection] Can malicious code inject specification conditions like GlobalInvariant or Axiom into function implementations where they're not allowed, potentially bypassing verification or causing runtime invariant violations? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ConditionKind::allowed_on_module()] [Module-level attack] Are there missing validation checks that could allow attackers to place function-level conditions at module scope, creating inconsistent specification states across the codebase? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Struct: Condition] [Expression injection] In the `Condition` struct with `exp` and `additional_exps` fields, can an attacker inject malicious expressions into `additional_exps` that bypass validation applied only to the primary `exp`, enabling specification-level exploits? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: Spec::filter_kind()] [Condition filtering bypass] Can attackers craft conditions with disguised kinds that bypass `filter_kind()` checks, allowing unauthorized condition types to pass through verification and potentially violating safety invariants? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: Spec::used_funs_with_uses()] [Function tracking bypass] Does `used_funs_with_uses()` correctly identify all function usages including indirect references through closures and lambdas, or can attackers hide malicious function calls that bypass dependency analysis? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: Spec::called_funs_with_callsites()] [Call graph manipulation] Can the distinction between `used_funs_with_uses()` and `called_funs_with_callsites()` be exploited to hide function values that are loaded but not directly called, enabling covert execution paths? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Struct: Spec with update_map] [Update statement injection] In the `update_map` field storing ghost variable updates, can attackers inject malicious update statements at arbitrary `NodeId`s to corrupt specification state during verification? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Struct: PropertyBag] [Property injection] Can malicious actors inject arbitrary properties into the `PropertyBag` (BTreeMap<Symbol, PropertyValue>) to influence compilation, verification, or runtime behavior in unintended ways? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: AccessSpecifier::used_vars()] [Variable tracking bypass] Does `used_vars()` correctly extract all variable dependencies from `AddressSpecifier::Call` and `Parameter` variants, or can attackers hide variable dependencies to bypass access control checks? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: AccessSpecifierKind::subsumes()] [Access control logic error] Can the `subsumes()` logic be exploited where Reads subsumes Writes incorrectly, allowing write operations to masquerade as read-only access and bypass resource modification checks? (Critical)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ResourceSpecifier::matches()] [Type instantiation bypass] In `matches()` with function instantiation parameter, can attackers provide malicious type instantiations that cause incorrect resource matching, enabling unauthorized resource access? (Critical)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ResourceSpecifier::matches() with empty inst] [Type parameter wildcard exploit] When `spec_struct_id.inst.is_empty()` allows any type instance, can attackers exploit this wildcard matching to access resources with incompatible type parameters, violating type safety? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ResourceSpecifier::matches_modulo_type_instantiation()] [Instantiation downgrade attack] Does downgrading to uninstantiated patterns in `matches_modulo_type_instantiation()` create security holes where type-specific access controls are bypassed? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Invalid] [Invalid expression propagation] Can `ExpData::Invalid` nodes persist through compilation stages without proper error handling, potentially causing undefined behavior or security bypasses in verification or execution? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Temporary] [Parameter index manipulation] For `Temporary(NodeId, TempIndex)` representing function parameters, can attackers manipulate the TempIndex to access out-of-bounds parameters or internal temporaries, violating memory safety? (Critical)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Call with Operation] [Operation substitution attack] Can attackers substitute malicious `Operation` variants within `Call` expressions to bypass operation-specific validation and execute unauthorized operations? (Critical)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Lambda with capture_kind] [Closure capture bypass] Can the `LambdaCaptureKind` (Default/Copy/Move) be manipulated to violate Move's ownership semantics, enabling double-moves or use-after-move vulnerabilities? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Quant with ranges and triggers] [Quantifier injection] Can attackers inject malicious trigger patterns in quantified expressions that cause solver divergence, infinite loops, or incorrect verification results? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Block with pattern binding] [Variable shadowing exploit] In `Block(NodeId, Pattern, Option<Exp>, Exp)`, can attackers exploit variable shadowing through malicious patterns to access or modify variables that should be out of scope? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::LoopCont with nest level] [Loop escape vulnerability] Can manipulated nest levels in `LoopCont(NodeId, usize, bool)` cause break/continue to target wrong loop nesting levels, enabling control flow bypasses or infinite loops? (High)",
  "[File: third_party/move/move-model/src/ast.rs] [Enum: ExpData::Match with arms] [Pattern matching bypass] Can attackers craft `Match` expressions with overlapping or incomplete patterns that bypass exhaustiveness checking, leading to unreachable code or undefined behavior? (Medium)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ExpData::node_id()] [Node ID collision] Can duplicate or manipulated NodeIds in expressions cause type information or location data to be incorrectly associated, leading to type confusion attacks? (Critical)",
  "[File: third_party/move/move-model/src/ast.rs] [Function: ExpData::call_args()] [Panic exploitation] Does the panic in `call_args()` when called on non-Call expressions create denial-of-service vectors or crash conditions exploitable during verification? (Medium)"
]