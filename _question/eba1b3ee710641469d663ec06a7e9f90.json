[
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - CallGeneric] [Type Parameter Substitution Attack] The ty_params processing with default_location tuple - can type parameter substitution produce misleading types that hide dangerous generic function instantiations? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - CallGeneric] [Return Type Confusion] If function_handle.return_ signature is processed incorrectly, can this hide that functions return more values (like capabilities) than displayed? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - CallClosure] [Closure Type Validation] The check if closure_sign.len() != 1 gives generic error - can malformed closures with invalid signatures bypass validation and execute with wrong types? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - PackClosure/PackClosureGeneric] [Closure Capture Abuse] The mask parameter in PackClosure - can incorrect mask values hide which variables are captured by the closure, allowing capture of sensitive capabilities? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_bytecode()] [Code Size DoS] The print_code_size option prints instruction count - can malicious bytecode with near-maximum instruction count cause resource exhaustion when disassembling? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_bytecode()] [Instruction Index Overflow] When enumerating with .enumerate() and inserting block labels, can instr_index overflow if code.code.len() approaches usize::MAX? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_bytecode()] [CFG Block Injection] The VMControlFlowGraph::new(&code.code) generates basic blocks - can malformed bytecode with invalid jumps cause incorrect block boundaries that hide unreachable malicious code? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_bytecode()] [Block Number Overflow] The calculation *block_id as usize + block_number for insertion - can this overflow and insert block labels at wrong positions, corrupting control flow display? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_bytecode()] [Coverage Map Desync] If function_code_coverage_map doesn't match actual executed code, can this cause incorrect coverage coloring that hides untested malicious code paths? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_type_formals()] [Phantom Type Confusion] The is_phantom flag display - can phantom type parameters be used to hide that certain types are never actually instantiated, allowing unused but dangerous type capabilities? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_type_formals()] [Ability Constraint Bypass] If ty_param.constraints shows fewer abilities than actually enforced at runtime, can this hide that structs have dangerous abilities like drop or copy for resources? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_type_formals()] [Type Parameter Count Mismatch] The zip of source_map_ty_params and type_parameters - can mismatch in lengths cause some type parameters to not be displayed, hiding generic type abuse? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_fun_type_formals()] [Function Type Ability Hiding] Similar to struct formals, can ability set mismatches hide that function type parameters have dangerous abilities? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_locals()] [Local Variable Count Mismatch] The enumerate on function_source_map.locals - if locals count doesn't match signature length, can this cause wrong types to be assigned to local variables? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_locals()] [Type Resolution Failure] If type_for_local() fails for some locals, are those locals silently omitted from output, hiding critical security-relevant variables like signer capabilities? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Arity Mismatch Silent Failure] The debug_assert! for parameter length mismatch only runs in debug builds - can production bytecode with arity mismatches cause undefined behavior or hide parameter count attacks? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Entry Function Bypass] The is_entry flag display - can malicious bytecode mark private functions as entry or vice versa to bypass entry point validation during security audits? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Visibility Confusion] If function.0.visibility is manipulated, can private functions appear public or friend functions appear private, hiding unauthorized function calls? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Native Function Spoofing] The is_native() check - can bytecode forge native modifier to make Rust-implemented functions appear as Move functions or vice versa? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Return Type Hiding] If function_handle.return_ signature is malformed, can this hide that functions return sensitive values like capabilities that should be tracked? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_function_def()] [Parameter Name Injection] The zip of signature tokens and function_source_map.parameters - can parameter name manipulation inject misleading names that hide the actual parameter purpose? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_def()] [Ability Set Spoofing] If struct_handle.abilities is manipulated, can structs appear to lack key/store/copy/drop abilities when they actually have them, or vice versa? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_def()] [Native Struct Confusion] For StructFieldInformation::Native, can malicious bytecode mark Rust-implemented structs as Move structs to hide their native implementation? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_def()] [Field Declaration Mismatch] For Declared fields, can the field list from struct_source_map mismatch with actual fields, hiding extra fields or wrong field types? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_struct_def()] [Variant Declaration Injection] For DeclaredVariants, can malicious bytecode inject extra variants or hide existing ones through manipulation of the variants iterator? (High)"
]