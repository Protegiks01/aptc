[
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Attribute Preservation] Are attr_id and aa (abort action) attributes correctly preserved across transformations, or can attribute loss cause the prover to lose source location information needed for accurate error reporting and verification? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: process()] [Pipeline Ordering] Does process() have dependencies on other pipeline passes that must run before/after it, and can incorrect ordering cause the transformation to see partially-transformed bytecode that violates its assumptions? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: process()] [Data Ownership] Does returning builder.data at line 35 properly transfer ownership, or can use-after-free occur if the builder holds references to data that are accessed after ownership is transferred? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: process()] [SCC Handling] Is the _scc_opt parameter (strongly connected components) intentionally ignored at line 31, and could mutual recursion between functions cause the transformation to produce inconsistent results across recursive function groups? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Determinism] Is the bytecode transformation deterministic across different platforms and compiler versions, or can non-deterministic behavior cause different validators to produce different verification results leading to consensus failures? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Panic Safety] If transform_bytecode panics during iteration at line 54, does the builder remain in a valid state, or can partially-transformed code cause verification to continue with corrupted bytecode structures? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_type()] [Type Recursion] Can deeply nested reference types cause stack overflow in transform_type through recursive Box unwrapping, allowing DoS attacks on the verification service through maliciously crafted Move code? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Struct: EliminateImmRefs] [Lifetime Safety] Does the 'a lifetime parameter correctly bound the FunctionDataBuilder reference, or can lifetime extension bugs cause dangling references when the builder outlives the data it references? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Reference Semantics] When transforming immutable references to values, does the pass verify that the original reference was the only reference to that memory location, or can it violate Move's aliasing rules by creating multiple mutable copies? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: is_imm_ref()] [Type Caching] Does get_local_type perform a lookup on every call, and if so, can repeated is_imm_ref checks on the same TempIndex have different results if types are being concurrently modified, causing TOCTOU vulnerabilities? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Assign Kind Correctness] Does the AssignKind::Move vs AssignKind::Copy distinction at lines 94 and 99 correctly model Move's copy/move semantics, or can incorrect assignment kinds cause the prover to miss use-after-move or double-free bugs? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Type Iteration Order] Does the into_iter() transformation of local_types at line 57 preserve the original order and indices, or can reordering cause TempIndex values to reference wrong types after transformation? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Abort Action Handling] Is the aa (abort action) parameter correctly propagated or cleared in transformed instructions, or can incorrect abort action preservation cause the prover to mismodel exceptional control flow? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: process()] [Function Environment] Does process() correctly use func_env to access function metadata, or can stale or incorrect FunctionEnv data cause the transformation to use outdated type information leading to unsound transformations? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [GetField Type Safety] When BorrowField becomes GetField, does the transformation verify that the struct type still exists after reference elimination, or can it create GetField operations on reference-typed structs that no longer exist? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Module/Struct ID Validation] Are mid and sid parameters (module ID, struct ID) validated when transforming BorrowField/BorrowGlobal operations, or can invalid IDs cause the prover to access wrong modules/structs leading to verification of incorrect code? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Type Actuals Preservation] Are type_actuals correctly preserved in the BorrowFieldâ†’GetField transformations, or can generic type parameter mismatches cause the prover to verify code with wrong concrete types? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Result Type Flattening] Does the flatten() call on result_type at line 65 correctly handle nested tuples, or can it produce incorrect return type signatures that allow functions to violate their declared contracts? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [ReadRef Source Validation] Does the ReadRef transformation verify that srcs[0] actually points to valid readable memory, or can it read from uninitialized or freed temporaries causing undefined behavior in verification? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [FreezeRef Semantics] When FreezeRef becomes ReadRef at line 96, does this correctly model the lifetime extension from mutable to immutable borrow, or can it create scenarios where mutable and immutable references coexist in violation of Move's rules? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Drop Guard Bypass] Does skipping Drop for immutable refs at line 131 allow resources to be leaked without running their destructors, enabling attackers to bypass cleanup logic and maintain invalid state? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: new()] [Builder Initialization] Does the FunctionDataBuilder::new() call properly initialize all necessary state, or can uninitialized fields cause the subsequent transformation to produce incorrect bytecode? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Bytecode Ordering] Does the transformation maintain the relative ordering of bytecode instructions, or can reordering cause control flow changes that alter program semantics and verification results? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Multiple Destinations] Do the transformations correctly handle cases where dests has more than one element, or does indexing dests[0] ignore other destinations causing lost assignments and incorrect verification? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Multiple Sources] Similarly, do transformations that only check srcs[0] properly handle operations with multiple source operands, or can additional sources be ignored leading to incorrect dataflow analysis? (High)"
]