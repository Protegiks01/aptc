[
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: process()] [Verification bypass] Can a malicious contract bypass data invariant instrumentation by marking functions as native or intrinsic, allowing unverified code with violated invariants to execute and potentially steal funds? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: process()] [Logic error] Does the early return for native/intrinsic functions properly validate that these functions truly should skip instrumentation, or can an attacker craft bytecode that falsely claims to be native to avoid invariant checks? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: process()] [State corruption] If ProverOptions are misconfigured or manipulated, can the instrumentation be disabled entirely, allowing contracts with broken invariants to be verified and deployed to mainnet? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument()] [Memory safety] Does std::mem::take on builder.data.code properly clear the original code, or can race conditions during concurrent instrumentation lead to duplicate bytecode execution and state inconsistency? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument()] [Resource exhaustion] Can an attacker provide bytecode with extremely long instruction sequences that cause the instrumentation loop to run indefinitely or consume excessive memory during verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument()] [Logic bypass] If the old_code vector is empty after mem::take, does the function handle this edge case correctly, or does it proceed with invalid state that could skip invariant checks? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Critical bypass] Can malicious bytecode containing UnpackRef or UnpackRefDeep operations completely skip invariant checks since these instructions are silently removed without any verification? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Invariant bypass] Does the removal of UnpackRef/UnpackRefDeep without replacement checks create a verification gap where unpacked struct references bypass data invariant validation entirely? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Type confusion] When processing Pack operations, can type arguments be manipulated to cause the wrong struct invariants to be checked, allowing invariant violations to pass verification? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Conditional bypass] Does the for_verification flag properly prevent invariant injection in non-verification contexts, or can attackers toggle this flag to deploy unverified code to production? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Pack operation bypass] Can an attacker craft Pack instructions with malicious module IDs or struct IDs that reference structs without invariants, bypassing all data invariant checks? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Variant bypass] For PackVariant operations, can variant indices be manipulated to point to variants without invariants or with weaker invariants than expected? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Shallow vs deep confusion] Can attackers exploit the difference between PackRef (shallow) and PackRefDeep (deep) to bypass deep invariant checks on nested structures containing stolen funds? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Destination manipulation] Can the dests[0] array access cause out-of-bounds errors or return wrong temporaries when Pack operations have manipulated destination counts? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode()] [Source manipulation] For PackRef operations using srcs[0], can empty or malformed source arrays bypass invariant checks or cause panics that halt verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode() - WellFormed rewriter] [Logic injection] Can the ExpData rewriter that augments WellFormed calls be exploited to inject malicious logic into assumption expressions, weakening verification guarantees? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode() - WellFormed rewriter] [Conjunction bypass] Does the And operation correctly combine WellFormed with invariants, or can boolean logic errors allow invariant violations when WellFormed is true but invariants are false? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode() - WellFormed rewriter] [Expression replacement] Can the RewriteResult::Rewritten path replace critical WellFormed checks with weaker conditions, creating verification gaps? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode() - WellFormed rewriter] [Recursive bypass] If WellFormed calls are nested within complex expressions, can the rewriter miss some calls and fail to inject invariants at all levels? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: instrument_bytecode() - WellFormed rewriter] [Type argument bypass] When translate_invariant is called with args[0], can manipulated type arguments cause wrong invariants to be retrieved and checked? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: emit_data_invariant_for_temp()] [Empty invariant bypass] If translate_invariant returns an empty vector, does the function silently succeed without emitting any checks, allowing invariant violations to pass? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: emit_data_invariant_for_temp()] [Location spoofing] Can malicious bytecode manipulate location information to cause misleading error messages that hide the true source of invariant violations? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: emit_data_invariant_for_temp()] [PropKind confusion] Can attackers exploit differences between Assert and Assume to turn critical assertions into weak assumptions that don't enforce invariants? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: emit_data_invariant_for_temp()] [Debug comment injection] Can malicious debug comments be injected to confuse verification output or hide security issues in audit logs? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/data_invariant_instrumentation.rs] [Function: emit_data_invariant_for_temp()] [VC info manipulation] Can the verification condition message INVARIANT_FAILS_MESSAGE be bypassed or modified to hide invariant violations in verification reports? (Medium)"
]