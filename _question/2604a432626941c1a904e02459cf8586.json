[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Input validation] Can an attacker request starting_version = None to trigger Status::invalid_argument error and potentially cause service availability issues through repeated invalid requests? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Integer overflow] Does the saturating_add operation on line 82 properly prevent integer overflow when transactions_count is set to u64::MAX - 1, potentially causing ending_version to wrap or reach u64::MAX incorrectly? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Input validation] Can a malicious client set starting_version = u64::MAX and transactions_count = Some(1) to create an ending_version that causes unexpected behavior in the coordinator loop condition on line 128? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Resource exhaustion] Can an attacker set transactions_count = None to create ending_version = u64::MAX, forcing the service to attempt streaming the entire blockchain history and causing memory exhaustion or service degradation? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Integer underflow] If starting_version is 0 and the coordinator attempts to decrement or perform arithmetic, could this cause underflow issues in version tracking logic? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Race condition] Between lines 97-99 where abort_handle is cloned and checked at line 132, can a race condition occur if abort_handle is set to true between spawning and the first check, causing inconsistent abort behavior? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Concurrency] The tokio::spawn on line 99 creates an async task - can multiple concurrent requests spawn unbounded tasks leading to resource exhaustion and service degradation? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Race condition] Is there a race condition between checking abort_handle.load(Ordering::SeqCst) on line 132 and the coordinator.process_next_batch() call on line 131 where abort could be triggered mid-processing? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Memory ordering] Does the SeqCst memory ordering on line 132 provide sufficient guarantees, or could relaxed ordering cause visibility issues across CPU cores leading to missed abort signals? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Async safety] Can the spawned task on line 99 outlive the service lifetime, potentially accessing dropped resources after FullnodeDataService is dropped? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Resource exhaustion] The TRANSACTION_CHANNEL_SIZE is hardcoded to 35 on line 53 - can slow clients cause the channel to fill up, blocking the spawned task and causing memory buildup in the coordinator? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Deadlock] If tx.send() blocks due to full channel on lines 113 or 166, and the receiver is also blocked, could this create a deadlock preventing progress? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Error handling] When tx.send() fails on line 113 (init message), the code panics with 'Unable to initialize stream' - can this panic be triggered by early client disconnection to crash the service thread? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Stream integrity] If tx.send() fails silently on line 166 (batch_end_status), the loop breaks without notifying the client - can this cause the client to receive incomplete batches without proper error signaling? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Resource leak] When the client disconnects and send() returns Err at line 186, does the spawned task properly clean up all resources, or could there be memory/resource leaks? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [State integrity] On line 191, coordinator.current_version is updated to max_version + 1 - if max_version is u64::MAX, will this overflow and reset current_version to 0, causing infinite loops? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Gap detection] The loop condition on line 128 checks current_version < end_version, but if get_max_batch_version returns an error on line 146, the loop breaks without updating current_version - can this create transaction gaps? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Data consistency] Between lines 158-160, the batch_end_status uses coordinator.current_version as start but max_version as end - if process_next_batch() doesn't return consecutive versions, can this mislead clients about batch boundaries? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Version integrity] If IndexerStreamCoordinator.get_max_batch_version() on line 144 returns a version less than coordinator.current_version, will line 191 cause current_version to move backwards, creating state inconsistency? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Loop termination] If coordinator.process_next_batch() continuously returns empty results but current_version never increments, will the loop on line 128 become infinite? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Panic safety] The panic on line 124 when unable to send init_status can crash the spawned task - can an attacker trigger this by disconnecting immediately after connection to cause repeated task crashes? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Error propagation] When get_max_batch_version returns Err on line 146, only an error log is printed before breaking - should this error be propagated to the client through the stream? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Graceful shutdown] When results.is_empty() on line 136 causes break, is this properly logged as client disconnection, or could legitimate errors be misinterpreted as disconnections? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Unwrap safety] The .unwrap() calls in the moving average and logging logic could panic if calculations fail - are these paths properly tested for edge cases? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs] [Function: get_transactions_from_node()] [Chain ID validation] The ledger_chain_id is retrieved on line 89 without validation - can an attacker connect to a node with a different chain_id and receive transactions from the wrong chain? (Critical)"
]