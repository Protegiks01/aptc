[
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: get_explanation()] [Missing Error Code] If a Move module aborts with a new error code that hasn't been registered in the error map yet (e.g., after a module upgrade), will get_explanation() return None, and can this cause validators to reject transactions with legitimate new error codes, breaking contract upgrades? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorDescription] [String Injection] Can an attacker inject malicious strings into code_name or code_description fields at lines 17-19 (e.g., control characters, ANSI escape codes, script tags) that execute when error messages are displayed in validator logs or web interfaces, potentially leading to log injection or XSS attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorDescription] [Unbounded String Length] Do code_name and code_description fields at lines 17-19 have any length limits, or can an attacker register error descriptions with gigabyte-sized strings, causing memory exhaustion when the error map is loaded or errors are looked up? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorDescription] [Unicode Normalization] Are code_name strings properly normalized (NFC/NFKC), or can an attacker register error codes with different Unicode normalizations of the same logical string (e.g., 'café' vs 'café'), causing lookup mismatches and masking real errors? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_module_error()] [Module Name Validation] Does add_module_error() validate the module_name parameter at line 48, or can an attacker provide empty strings, null bytes, path separators (../../), or Unicode directional overrides that corrupt the module_error_maps structure? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_module_error()] [Format String Attack] If error descriptions from ErrorDescription are later used in format strings or logging without proper escaping, can an attacker inject format specifiers (%s, %x, {}) that leak memory or cause crashes when errors are reported? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Integer Key Collision] Are category_id and abort_code values (u64 at lines 25, 48) validated to ensure they're not special values like u64::MAX, u64::MIN, or reserved ranges, or can attackers register errors at boundary values that collide with system-reserved error codes? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_error_category()] [Category ID Exhaustion] If category_id is a u64, can an attacker register 2^64 error categories until the space is exhausted, preventing legitimate system modules from registering critical error codes and breaking error reporting? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_module_error()] [Abort Code Exhaustion] For a given module_name, can an attacker register 2^64 different abort_codes until the BTreeMap is full, causing memory exhaustion or preventing legitimate error codes from being registered? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [BTreeMap Size Overflow] If error_categories or module_error_maps grow to contain billions of entries, can the total memory size exceed isize::MAX causing allocation failures, or does BTreeMap properly handle large sizes without overflow? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Missing Synchronization] Does ErrorMapping have any synchronization primitives (Mutex, RwLock), or if shared between threads, can concurrent access to the BTreeMaps at lines 25-27 cause data races, corruption, or undefined behavior despite Rust's borrowing rules? (Critical)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_error_category()] [TOCTOU Race] Between the check for duplicate at line 36 and the insert, if another thread modifies the error_categories map, can this create a race window where duplicates are added despite the check, breaking the uniqueness guarantee? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_module_error()] [TOCTOU Race] Between the or_default() at line 51-54 and the duplicate check at line 55, if another thread inserts the same abort_code, can this race cause duplicate error descriptions to be added, breaking deterministic error reporting across validators? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: get_explanation()] [Read-Write Race] If one thread calls get_explanation() while another calls add_module_error(), can the read at lines 77-79 observe a partially-updated BTreeMap structure, causing incorrect error lookups or panics? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: from_file()] [Concurrent Load Race] If multiple threads call from_file() concurrently for the same path, can they cause file descriptor exhaustion, race to load inconsistent error maps, or cause undefined behavior if the file is being written by to_file() simultaneously? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Interior Mutability] Does ErrorMapping use any interior mutability patterns (Cell, RefCell) that could bypass Rust's borrowing rules, allowing mutable access through shared references and causing data races? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Non-Deterministic Ordering] Does BTreeMap guarantee deterministic iteration order across all validator nodes at lines 25-27, or can differences in insertion order cause validators to report errors in different order, breaking consensus on error logs? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_error_category()] [Non-Deterministic Errors] Does the bail!() error message at lines 37-40 include non-deterministic data (timestamps, addresses, thread IDs) that could cause validators to produce different error messages for the same duplicate category violation? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: add_module_error()] [Non-Deterministic Errors] Does the bail!() error message at lines 56-59 include non-deterministic data that could cause validators to disagree on whether an error addition succeeded, leading to state divergence? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: from_file()] [Non-Deterministic Loading] If different validators load error maps from files with different timestamps or metadata, does this affect the ErrorMapping contents or behavior, potentially causing validators to interpret the same error code differently? (Critical)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Cross-Validator Consistency] If validators load error maps at different times during an epoch (e.g., one after a module upgrade), can they have inconsistent error descriptions for the same abort code, causing confusion when diagnosing consensus failures? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: get_explanation()] [Deterministic Lookup] If the same module_name and output_code are looked up on different validators, is the returned ErrorDescription guaranteed to be byte-for-byte identical, or can differences in String encoding or metadata cause divergence? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [Memory Exhaustion] Can an attacker cause unbounded memory growth by repeatedly calling add_error_category() and add_module_error() with unique IDs, eventually exhausting validator memory and causing OOM crashes? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Struct: ErrorMapping] [BTreeMap Memory Layout] Does BTreeMap have optimal memory layout for error maps with millions of entries, or can pathological key distributions cause excessive memory fragmentation and allocator overhead? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/errmap.rs] [Function: from_file()] [File Size Bomb] Can an attacker provide a BCS-encoded file that is small on disk but decompresses/deserializes to a massive ErrorMapping structure consuming gigabytes of RAM, causing validator OOM crashes? (High)"
]