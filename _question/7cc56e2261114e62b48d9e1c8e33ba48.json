[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledModule] [Annotation injection attack] Can attackers inject malicious annotations into AnnotatedCompiledModule that bypass compilation checks but execute maliciously at runtime? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [BTreeMap invariant violation] Can the used_lambda_funs BTreeMap be manipulated to violate BTreeMap ordering invariants, causing undefined behavior during iteration? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Spec info consistency] Can spec_info BTreeMap contain SpecInfo entries that reference non-existent functions or invalid bytecode offsets? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Enum: CompiledUnitEnum] [Enum discriminant manipulation] Can unsafe code or memory corruption attacks modify the enum discriminant to create invalid CompiledUnitEnum states? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Error detail injection] Can format!(\\",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Diagnostic overflow] Can verify_units() accumulate unlimited diagnostics through diags.extend(), causing memory exhaustion when verifying large module batches? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Location spoofing in errors] Can attackers craft VMErrors with\n\n### Citations\n\n**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs (L1-262)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    diag,\n    diagnostics::Diagnostics,\n    expansion::ast::{ModuleIdent, ModuleIdent_, SpecId},\n    parser::ast::{ModuleName, Var},\n    shared::{Name, NumericalAddress},\n};\nuse move_binary_format::file_format as F;\nuse move_bytecode_source_map::source_map::SourceMap;\nuse move_core_types::{\n    account_address::AccountAddress, identifier::Identifier as MoveCoreIdentifier,\n    language_storage::ModuleId,\n};\nuse move_ir_types::location::*;\nuse move_symbol_pool::Symbol;\nuse std::collections::BTreeMap;\n\n//**************************************************************************************************\n// Compiled Unit\n//**************************************************************************************************\n\n#[derive(Debug, Clone)]\npub struct SpecInfo {\n    pub offset: F::CodeOffset,\n    // Re-mapped function pointer names\n    pub used_lambda_funs: BTreeMap<Symbol, (Symbol, Vec<Var>)>,\n}\n\n#[derive(Debug, Clone)]\npub struct FunctionInfo {\n    pub spec_info: BTreeMap<SpecId, SpecInfo>,\n}\n\n#[derive(Debug, Clone)]\npub struct NamedCompiledModule {\n    // package name metadata from compiler arguments\n    pub package_name: Option<Symbol>,\n    pub address: NumericalAddress,\n    pub name: Symbol,\n    pub module: F::CompiledModule,\n    pub source_map: SourceMap,\n}\n\n#[derive(Debug, Clone)]\npub struct NamedCompiledScript {\n    // package name metadata from compiler arguments\n    pub package_name: Option<Symbol>,\n    pub name: Symbol,\n    pub script: F::CompiledScript,\n    pub source_map: SourceMap,\n}\n\n#[derive(Debug, Clone)]\npub struct AnnotatedCompiledModule {\n    pub loc: Loc,\n    pub module_name_loc: Loc,\n    pub address_name: Option<Name>,\n    pub named_module: NamedCompiledModule,\n}\n\n#[derive(Debug, Clone)]\npub struct AnnotatedCompiledScript {\n    pub loc: Loc,\n    pub named_script: NamedCompiledScript,\n    pub function_info: FunctionInfo,\n}\n\npub trait TargetModule {}\npub trait TargetScript {}\nimpl TargetScript for AnnotatedCompiledScript {}\nimpl TargetScript for NamedCompiledScript {}\nimpl TargetModule for AnnotatedCompiledModule {}\nimpl TargetModule for NamedCompiledModule {}\n\n#[derive(Debug, Clone)]\npub enum CompiledUnitEnum<TModule: TargetModule, TScript: TargetScript> {\n    Module(TModule),\n    Script(TScript),\n}\n\npub type CompiledUnit = CompiledUnitEnum<NamedCompiledModule, NamedCompiledScript>;\npub type AnnotatedCompiledUnit = CompiledUnitEnum<AnnotatedCompiledModule, AnnotatedCompiledScript>;\n\nimpl AnnotatedCompiledModule {\n    pub fn module_ident(&self) -> ModuleIdent {\n        use crate::expansion::ast::Address;\n        let address =\n            Address::Numerical(self.address_name, sp(self.loc, self.named_module.address));\n        sp(\n            self.loc,\n            ModuleIdent_::new(\n                address,\n                ModuleName(sp(self.module_name_loc, self.named_module.name)),\n            ),\n        )\n    }\n\n    pub fn module_id(&self) -> (Option<Name>, ModuleId) {\n        let id = ModuleId::new(\n            AccountAddress::new(self.named_module.address.into_bytes()),\n            MoveCoreIdentifier::new(self.named_module.name.to_string()).unwrap(),\n        );\n        (self.address_name, id)\n    }\n}\n\nimpl AnnotatedCompiledUnit {\n    pub fn verify(&self) -> Diagnostics {\n        match self {\n            Self::Module(AnnotatedCompiledModule {\n                loc,\n                named_module:\n                    NamedCompiledModule {\n                        module, source_map, ..\n                    },\n                ..\n            }) => verify_module(source_map, *loc, module),\n            Self::Script(AnnotatedCompiledScript {\n                loc,\n                named_script:\n                    NamedCompiledScript {\n                        script, source_map, ..\n                    },\n                ..\n            }) => verify_script(source_map, *loc, script),\n        }\n    }\n\n    pub fn into_compiled_unit(self) -> CompiledUnit {\n        match self {\n            Self::Module(AnnotatedCompiledModule {\n                named_module: module,\n                ..\n            }) => CompiledUnitEnum::Module(module),\n            Self::Script(AnnotatedCompiledScript {\n                named_script: script,\n                ..\n            }) => CompiledUnitEnum::Script(script),\n        }\n    }\n\n    pub fn package_name(&self) -> Option<Symbol> {\n        match self {\n            Self::Module(AnnotatedCompiledModule { named_module, .. }) => named_module.package_name,\n            Self::Script(AnnotatedCompiledScript { named_script, .. }) => named_script.package_name,\n        }\n    }\n\n    pub fn loc(&self) -> &Loc {\n        match self {\n            Self::Module(AnnotatedCompiledModule { loc, .. })\n            | Self::Script(AnnotatedCompiledScript { loc, .. }) => loc,\n        }\n    }\n}\n\nimpl CompiledUnit {\n    pub fn name(&self) -> Symbol {\n        match self {\n            Self::Module(NamedCompiledModule { name, .. })\n            | Self::Script(NamedCompiledScript { name, .. }) => *name,\n        }\n    }\n\n    pub fn package_name(&self) -> Option<Symbol> {\n        match self {\n            Self::Module(NamedCompiledModule { package_name, .. })\n            | Self::Script(NamedCompiledScript { package_name, .. }) => *package_name,\n        }\n    }\n\n    pub fn source_map(&self) -> &SourceMap {\n        match self {\n            Self::Module(NamedCompiledModule { source_map, .. })\n            | Self::Script(NamedCompiledScript { source_map, .. }) => source_map,\n        }\n    }\n\n    pub fn serialize(&self, bytecode_version: Option<u32>) -> Vec<u8> {\n        let mut serialized = Vec::<u8>::new();\n        match self {\n            Self::Module(NamedCompiledModule { module, .. }) => module\n                .serialize_for_version(bytecode_version, &mut serialized)\n                .unwrap(),\n            Self::Script(NamedCompiledScript { script, .. }) => script\n                .serialize_for_version(bytecode_version, &mut serialized)\n                .unwrap(),\n        };\n        serialized\n    }\n\n    #[allow(dead_code)]\n    pub fn serialize_debug(self) -> Vec<u8> {\n        match self {\n            Self::Module(NamedCompiledModule { module, .. }) => format!("
]