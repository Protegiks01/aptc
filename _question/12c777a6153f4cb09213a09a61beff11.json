[
  "[File: aptos-core/storage/backup/backup-service/src/lib.rs] [Function: start_backup_service()] [Authentication bypass] Does the backup service implement any authentication or authorization mechanism before exposing database state, or can any network-accessible attacker query sensitive validator state including transaction history, account balances, and cryptographic proofs without credentials? (Critical)",
  "[File: aptos-core/storage/backup/backup-service/src/lib.rs] [Function: start_backup_service()] [Access control] Is there IP whitelisting, TLS client certificate validation, or any network-level access control to restrict who can call backup endpoints, or can external attackers freely download the entire blockchain state including private validator metadata? (Critical)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Rate limiting] Does the backup service implement rate limiting or request throttling on any endpoints, or can an attacker exhaust server resources by making unlimited concurrent requests to expensive endpoints like state_snapshot? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Resource exhaustion] Can an attacker request state snapshots at extremely high versions (near u64::MAX) to force the database to perform expensive Merkle tree traversals, causing validator node slowdown or memory exhaustion? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Integer overflow] When processing the limit parameter in state_snapshot_chunk(version, start_idx, limit), can an attacker supply limit=usize::MAX to cause integer overflow in buffer allocation or iterator bounds checking? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Memory exhaustion] Can an attacker request transactions(0, usize::MAX) to force the server to load billions of transactions into memory, causing OOM crashes and validator unavailability? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/bytes_sender.rs] [Function: BytesSender::send_size_prefixed_bcs_bytes()] [Channel flooding] With MAX_BATCHES set to 100, can an attacker trigger slow client reads to fill the mpsc channel, causing the blocking_send() to block indefinitely and freeze the backup service thread? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/bytes_sender.rs] [Function: BytesSender::send_bytes()] [Buffer growth] Is there a maximum buffer size limit before flushing, or can malicious BCS-serialized records cause unbounded buffer growth in BytesMut, leading to memory exhaustion attacks? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [Version inconsistency] When serving state_range_proof(version, end_key), if the database is concurrently being updated with new transactions, can the proof reference a state root from version N while returning values from version N+1, breaking Merkle proof verification? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [TOCTOU race] Between calling get_state_item_iter(version) and iterating through results, if the database prunes old versions, can the iterator return inconsistent data or panic due to missing state, causing validator crashes? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Proof integrity] Does get_transaction_range_proof validate that first_version <= last_version before generating proofs, or can an attacker request inverted ranges to trigger assertion failures or return invalid proofs? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [Epoch boundary] When requesting epoch_ending_ledger_infos(start_epoch, end_epoch), if end_epoch < start_epoch or end_epoch is far in the future, can this cause infinite loops or panics in the iterator logic? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/lib.rs] [Function: start_backup_service()] [Runtime safety] Does spawning the warp server with runtime.handle().spawn() properly handle runtime shutdown, or can calling drop(runtime) while requests are in-flight cause use-after-free or data races? (High)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/utils.rs] [Function: reply_with_bytes_sender()] [Task abandonment] After spawning the blocking task with tokio::task::spawn_blocking(), if the client disconnects early, does the spawned task continue consuming database resources indefinitely without cancellation? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/bytes_sender.rs] [Function: BytesSender::finish()] [Double finish] If finish() is called multiple times on the same BytesSender (e.g., via Drop and explicit call), can this cause double-flush leading to duplicate data in the stream or panic? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/bytes_sender.rs] [Function: BytesSender::abort()] [Error propagation] When abort() is called with an error, if blocking_send() fails because the receiver is dropped, does the original error get swallowed, making debugging impossible? (Low)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [HashValue validation] Does the endpoint validate that the end_key HashValue represents a valid state key before calling get_account_state_range_proof(), or can malformed hash values cause database query errors or crashes? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Index bounds] When processing state_snapshot_chunk(version, start_idx, limit), is there validation that start_idx + limit doesn't overflow usize, preventing out-of-bounds iterator access? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Version validation] Does the transactions endpoint validate that start_version exists in the database before creating the iterator, or can requesting future versions cause panics or return empty results without proper error codes? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [Epoch overflow] Can an attacker supply u64::MAX for end_epoch to cause integer overflow when calculating (end_epoch - start_epoch), potentially leading to incorrect iteration bounds? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/utils.rs] [Function: unwrap_or_500()] [Information leakage] When logging errors with warn!(\\",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/utils.rs] [Function: handle_rejection()] [Enumeration attack] Does the 400 Bad Request response reveal different error details for malformed parameters vs. missing parameters, allowing attackers to enumerate valid endpoint structures and parameter types? (Low)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: db_state endpoint] [State disclosure] Does the db_state endpoint return sensitive information like internal database version numbers, epoch configurations, or validator set details that could aid attackers in planning consensus attacks? (Medium)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/bytes_sender.rs] [Function: abort()] [Error serialization] When abort() sends an error through the stream, is the error properly sanitized to avoid leaking sensitive database internals, or could boxed errors expose implementation details? (Low)",
  "[File: aptos-core/storage/backup/backup-service/src/handlers/mod.rs] [Function: state_root_proof endpoint] [Proof forgery] Does the state_root_proof endpoint validate the returned proof before sending it, or can database corruption cause it to return invalid Merkle proofs that would allow attackers to fake state commitments? (Critical)"
]