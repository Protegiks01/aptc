[
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::start_active_subscription_stream()] [Duplicate Stream Prevention] Lines 1011-1016 error if active_subscription_stream already exists. But can race conditions in concurrent create_data_client_requests() calls bypass this check, creating multiple active subscriptions that corrupt version tracking? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::update_request_version_and_epoch()] [Epoch Increment Logic] Lines 1094-1101 increment next_request_epoch when request_end_version equals target version and ends_epoch. Can an off-by-one error in this comparison cause epoch transitions to be missed or duplicated? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::update_request_tracking()] [Type Confusion] Lines 1117-1161 match on stream request type. Can an attacker exploit request type mismatches between initial stream creation and subsequent updates to bypass validation checks and corrupt request tracking? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_data_client_requests()] [Target Version Bypass] Lines 1230-1232 return empty vec if next_request_version > target version. Can this check be bypassed by manipulating next_request_version through concurrent update_request_version_and_epoch() calls? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_data_client_requests()] [Dynamic Prefetching Override] Lines 742-748 override max_in_flight_requests for dynamic prefetching. Can this configuration change mid-stream cause in-flight request count mismatches, leading to either request starvation or resource exhaustion? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::transform_client_response_into_notification()] [Flag Reset Vulnerability] Lines 1337-1344 reset end_of_epoch_requested and optimistic_fetch_requested flags. Can a malicious duplicate response exploit this to reset flags prematurely, allowing new requests before the legitimate response is processed? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::transform_client_response_into_notification()] [Request Type Validation] Lines 1350-1459 validate request/response type combinations. Can an attacker send mismatched response types that pass the initial type check but fail deeper validation, causing the stream to enter an inconsistent state? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_notification_for_optimistic_fetch_data()] [First Version Calculation] Lines 643-645 calculate first_version = known_version + 1. Can known_version be manipulated through concurrent updates to cause duplicate or missing version ranges in notifications? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_notification_for_new_data()] [Version Range Validation] Lines 606-614 calculate last_version = first_version + num_versions - 1. Can num_versions = 0 bypass empty response validation in extract_new_versions_and_target() and cause integer underflow? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_notification_for_continuous_data()] [Empty Response Detection] Lines 552-566 check for num_received_versions == 0. But can an attacker send responses with num_versions = 1 containing invalid/corrupted transaction data that passes this check but fails verification later? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::is_remaining_data_available()] [Advertised Data Manipulation] Lines 1292-1311 check if advertised_data contains next_request_version. Can a Byzantine peer selectively advertise version ranges to control which peers sync from them, enabling eclipse attacks? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_optimistic_fetch_request()] [Known Version Consistency] Lines 688-713 create optimistic fetch using get_known_version_and_epoch(). Can this function return inconsistent values if called during concurrent stream/request version updates? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::new()] [Highest Epoch Validation] Lines 1488-1495 extract highest_epoch_ending_ledger_info from advertised_data. Can a malicious peer advertise a forged epoch ending ledger info with inflated epoch number to cause other nodes to skip legitimate epoch transitions? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::new()] [Start Epoch Validation] Lines 1497-1502 verify that end_epoch >= request.start_epoch. Can this check be bypassed by a TOCTOU attack where advertised_data changes between the check and actual request creation? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::update_request_tracking()] [Epoch Overflow] Lines 1528-1531 calculate next_request_epoch = end_epoch + 1 with checked_add. Can end_epoch = u64::MAX cause overflow, permanently blocking future epoch ending requests? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::transform_client_response_into_notification()] [Empty Ledger Info List] Lines 1607-1613 check for empty ledger_infos list. But what if the list contains a single invalid/corrupted ledger info that passes the isEmpty() check but has invalid signatures or wrong epoch numbers? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::transform_client_response_into_notification()] [Last Epoch Extraction] Lines 1615-1620 extract last epoch using .last().map(). Can this return an incorrect epoch if ledger_infos are not sorted by epoch, causing stream completion to trigger prematurely or late? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::transform_client_response_into_notification()] [Epoch Bounds Clamping] Lines 1623-1624 use bound_by_range() on last_received_epoch. Can an attacker exploit this by sending epoch numbers far outside the requested range to manipulate stream progression? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::transform_client_response_into_notification()] [Stream Completion Check] Lines 1632-1634 mark stream complete when last_received_epoch >= end_epoch. Can an attacker send end_epoch in the response before all intermediate epochs are received, causing gaps in epoch ending ledger infos? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: EpochEndingStreamEngine::is_remaining_data_available()] [Epoch Range Validation] Lines 1572-1578 check if epoch_ending_ledger_infos contains the required range. Can advertised_data be manipulated to falsely claim availability, causing request failures that block state sync? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: TransactionStreamEngine::new()] [Initial Version Validation] Lines 1669-1690 initialize stream with start_version from request. Can start_version be set to u64::MAX or other extreme values to cause immediate overflow in subsequent version calculations? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: TransactionStreamEngine::update_stream_version()] [Version Calculation Chain] Lines 1725-1728 calculate last_received_version using checked_add and checked_sub. Can carefully crafted num_received_versions values exploit this calculation chain to cause integer overflow/underflow? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: TransactionStreamEngine::update_stream_version()] [Empty Response Check] Lines 1717-1722 check for num_received_versions == 0. Can an attacker send num_received_versions = 1 with invalid transaction data to bypass this check and corrupt the transaction stream? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: TransactionStreamEngine::update_stream_version()] [Stream Completion Logic] Lines 1741-1743 check if last_received_version >= stream_end_version. Can version bounds manipulation cause premature completion before all requested transactions are received? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: TransactionStreamEngine::update_request_version()] [Request Version Overflow] Lines 1749-1752 calculate next_request_version = request_end_version + 1. Can request_end_version = u64::MAX cause overflow here, and is the error properly handled? (High)"
]