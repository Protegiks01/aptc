[
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Type Confusion] Can an attacker craft a WriteResource with a malicious type string that passes V2TokenResource::is_resource_supported() but causes type confusion during V2TokenResource::from_resource(), potentially corrupting indexer state or causing panics? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Null Pointer Dereference] At line 103, resource.data.as_ref().unwrap() is called without checking if data exists - can a malicious transaction include a WriteResource with null data field, causing the indexer to panic and halt processing? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Missing Validation] Lines 109-137 check if metadata exists in token_v2_metadata mapping but return Ok(None) at line 136 if ObjectCore is missing - can an attacker submit transactions that deliberately omit ObjectCore to cause silent collection creation failures and indexer inconsistencies? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Supply Manipulation] Lines 113-126 show that unlimited_supply can be overwritten by fixed_supply even if both exist - can an attacker exploit this priority logic to cause supply inconsistencies by crafting transactions with both supply types, allowing max_supply bypass? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Integer Overflow] Lines 114-118 and 121-125 clone BigDecimal values for current_supply, max_supply, and total_minted without validation - can extremely large supply values cause BigDecimal operations to overflow or consume excessive memory during indexing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Data Truncation] Lines 141 and 143 call get_name_trunc() and get_uri_trunc() - if truncation occurs, can attackers create multiple collections with identical truncated names but different full names, causing collection_id collisions or indexer confusion? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Missing Mutability Validation] Lines 129-133 only set mutable_description and mutable_uri if aptos_collection exists, otherwise they remain None - can this cause indexer inconsistencies where collections appear immutable when they're actually mutable? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Placeholder Values] Lines 96 and 98 use placeholder values (0) for write_set_change_index and transaction_version in MoveResource::from_write_resource() - can these placeholders cause issues if the underlying function doesn't actually ignore them as claimed? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Creator Address Validation] Line 140 calls inner.get_creator_address() without validation - can malicious on-chain data provide invalid creator addresses (e.g., non-standardized format) that bypass address checks? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Resource Address Trust] Line 139 uses resource.address as collection_id directly - can attackers manipulate resource addresses to create collection_id collisions or impersonate existing collections? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Concurrent Modification] The function reads from token_v2_metadata mapping at line 109 without locking - can concurrent transactions modifying the same collection cause race conditions where supply data is read inconsistently? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Supply Logic Bug] Lines 110-126 show fixed_supply overwrites unlimited_supply, but both are checked - can a malicious smart contract transition from unlimited to fixed supply mid-transaction, violating collection immutability guarantees? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Type String Injection] Lines 85-90 construct type_str by concatenating address, module, and name fields - can special characters or malicious formatting in these fields cause type confusion or bypass V2TokenResource validation? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Pattern Matching Failure] Line 101 uses pattern matching on V2TokenResource::Collection(inner) but only handles the Collection variant - if V2TokenResource::from_resource() returns a different variant despite passing is_resource_supported(), can this cause logic errors? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v2_from_write_resource()] [Metadata Injection] token_v2_metadata parameter is passed from external context - can attackers pollute this mapping with fake metadata for addresses they don't own, causing incorrect supply or mutability data to be indexed? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Null Pointer Dereference] Line 193 calls table_item.data.as_ref().unwrap() without checking - can malicious table items with null data field cause indexer panic and processing halt? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Creator Address Fallback Chain] Lines 208-232 implement complex fallback logic for creator resolution with 3 different methods - can attackers exploit the fallback order to inject fake creator addresses by manipulating table_handle_to_owner mapping? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Silent Failure] Lines 221-227 log an error and return Ok(None) if all creator lookup methods fail - can attackers deliberately trigger this condition to prevent legitimate collections from being indexed, causing loss of collection visibility? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Address Standardization Bypass] Lines 206 and 233 call standardize_address() on table_handle and creator_address - can inconsistent standardization between these calls cause collection_id mismatches and indexer inconsistencies? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Collection ID Generation] Lines 234-236 generate collection_id using CollectionDataIdType - can attackers craft creator_address and collection names that produce collision-prone IDs, allowing collection impersonation? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Database Dependency] The function requires database connection at line 191 - can database unavailability or connection failures during creator lookup cause transaction processing to hang or fail non-deterministically across indexers? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Supply Value Cloning] Line 249 clones collection_data.supply and lines 250 and 265 clone collection_data.maximum - can malicious on-chain data provide extreme BigDecimal values causing memory exhaustion during clone operations? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Type Confusion V1/V2] The function explicitly sets token_standard to TokenStandard::V1.to_string() at lines 255 and 270, but processes data that might have V2 characteristics - can hybrid tokens exploit this to bypass validation logic? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Mutability Config Trust] Lines 252-253 and 267-268 directly trust collection_data.mutability_config values - can malicious table items provide mutability_config that violates on-chain invariants, allowing supposedly immutable collections to be modified? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_collections.rs] [Function: get_v1_from_write_table_item()] [Table Handle Validation] Line 204 converts table_item.handle to string without validation - can non-standard or malicious handle formats bypass standardize_address() checks and cause lookup failures? (Low)"
]