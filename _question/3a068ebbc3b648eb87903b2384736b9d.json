[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Batch consistency] MAX_BYTES_PER_BATCH at line 23 and MAX_BYTES_PER_BATCH at line 130 both refer to 20MB, but are transactions split atomically or can a single large transaction exceed this limit? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Tokio scope safety] At line 61, tokio_scoped::scope is used, but if parent task is cancelled, can child tasks continue running with dangling references to &self? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Blocking in async] At line 69, `blocking_recv()` is used in what appears to be an async context - can this cause thread starvation or deadlocks in the tokio runtime? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Async consistency] At line 204, `response_sender.send().await` is async, but what happens if the sender is dropped while send is in progress - can this cause partial sends or data corruption? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Task spawn safety] At line 124, tasks are spawned in scope with mutable access to handler_rx - can this violate Rust's borrowing rules if multiple tasks try to recv simultaneously? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Sleep timing] At line 176, tokio::time::sleep(100ms) is hardcoded - can attackers exploit predictable timing to synchronize attacks or cause thundering herd when many streams wake simultaneously? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: new()] [Lifetime bounds] LiveDataService has lifetime parameter 'a at line 25, but does in_memory_cache at line 27 properly respect this lifetime in all async operations? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Reference safety] At line 54, &'a self is passed to run(), but async closures at lines 62 and 124 capture this reference - can the service be dropped while tasks are still running? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Async lifetime] At line 148, start_streaming takes &'a self and is called in a spawned task - if the task outlives the scope, can use-after-free occur? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Arc/Clone safety] At line 42, connection_manager.clone() is called after already being moved into in_memory_cache - are Arc reference counts properly managed to prevent leaks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Filter DoS] At lines 93-96, BooleanTransactionFilter::new_from_proto() is called with max_transaction_filter_size_bytes limit, but can an attacker send a complex filter that passes size check but causes exponential evaluation time? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Filter bypass] At line 110, when no filter is provided, None is used - but does downstream code properly handle None versus empty filter, or can this bypass intended filtering? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Filter evaluation] Filter is passed to in_memory_cache.get_data() at line 187, but is filter evaluation done before or after transaction deserialization - can malicious filters cause deserialization of invalid transactions? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Filter injection] At line 92, transaction_filter comes from the proto request - can malicious proto encoding inject filter logic that wasn't intended by the client? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Filter validation timing] At lines 99-107, filter validation error handling sends error and continues - but is the spawned task at line 62 properly cancelled to prevent resource leaks? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Metrics manipulation] At lines 70-72, COUNTER is incremented for each request - can attackers flood requests to overflow counter metrics or hide malicious activity in noise? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Metrics timing] At lines 191-193, TIMER measures send_batch duration - can attackers use timing information to infer cache state or network conditions? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Counter accuracy] At lines 86-88, 216-217, different error counters are used - can incorrect counter labels mask attack patterns or monitoring failures? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Monitoring bypass] At line 158-160, stream start counter is incremented but there's no corresponding decrement - can this cause incorrect active stream counts? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Boundary condition] At line 166, ending_version defaults to u64::MAX when None - can this cause infinite loops if blockchain version never reaches u64::MAX? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Edge case] At line 168, loop breaks when `next_version >= ending_version`, but what if starting_version == ending_version initially - is zero-length range handled correctly? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Boundary condition] At line 80, validation allows `starting_version <= known_latest_version + 10000`, but what if known_latest_version is 0 at startup - can this allow querying non-existent negative versions? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Empty batch handling] At lines 180-189, what if get_data() returns Some with empty transactions vector - does the code handle this or infinite loop incrementing next_version? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Version gap handling] If last_processed_version at line 189 jumps forward by more than 1 due to filtering, does next_version = last_processed_version + 1 at line 202 cause skipped versions? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Connection tracking] At line 162-163, insert_active_stream() is called with ending_version that might be u64::MAX - can this cause connection_manager to incorrectly track stream lifetime? (Low)"
]