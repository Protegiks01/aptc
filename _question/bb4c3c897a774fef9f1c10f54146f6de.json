[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: start()] [Empty Transactions Vector] When transactions.len() == 0 (line 172), the loop logs and sleeps - but can repeated empty responses indicate a stuck DataManager that will never recover, causing the indexer to fall permanently behind? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: start()] [MAX_SIZE_PER_FILE Enforcement] The constant MAX_SIZE_PER_FILE (50MB) is passed to get_transactions_from_cache at line 160 and FileStoreOperatorV2 at line 128 - are these limits consistently enforced, or can transactions larger than 50MB cause buffer overflows or memory exhaustion? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Transaction Vector Empty] At lines 191-192, transactions.first() and transactions.last() are called with unwrap() - if an empty transactions vector is passed (which shouldn't happen but isn't checked), can this cause a panic during upload? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [File Entry Compression Attack] FileEntry::from_transactions is called at line 197 with Lz4CompressedProto format - can specially crafted transaction data cause the compression to fail, produce corrupted output, or consume excessive memory during compression? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Path Traversal Attack] The path is obtained from reader.get_path_for_version at line 199 - if version numbers can be manipulated, can an attacker cause path traversal to write files outside the intended directory structure? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [File Save Failure Handling] The save_raw_file call at lines 207-209 returns a Result that gets propagated with ? - but are transient storage failures handled gracefully, or will they cause the entire upload process to fail and require manual intervention? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Timestamp Manipulation] The timing logic (lines 214-225) uses last_batch_metadata_update_time and Instant::now() - can system clock manipulation or time skew cause the update_batch_metadata flag to be set incorrectly, leading to too frequent or too infrequent metadata updates? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Sleep Overflow Attack] At lines 221-224, if end_batch is true, the code sleeps until last_batch_metadata_update_time + max_update_frequency - can negative duration values or time arithmetic overflow cause panics or incorrect sleep durations? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Batch Metadata Serialization] The batch_metadata is serialized at line 239 with serde_json::to_vec - can extremely large or deeply nested batch metadata structures cause serialization to fail, consume excessive memory, or produce invalid JSON? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Metadata Path Collision] The batch_metadata_path is obtained at line 231 using get_path_for_batch_metadata - can version number manipulation or folder boundary logic cause two different batches to write to the same metadata path, overwriting each other? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Metadata Update Race Condition] Batch metadata is updated at lines 236-242 and file store metadata at lines 250-256 - can concurrent do_upload calls race to update these metadata files, causing one update to overwrite the other and creating inconsistent state? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Early Return Skips Metadata] If update_batch_metadata is false (line 227), the function returns early without updating any metadata - can this cause the file store to contain transaction files without corresponding metadata entries, breaking recovery and reading logic? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Version Increment Overflow] At line 254, last_version + 1 is calculated - can the maximum u64 version cause overflow, or does Rust's overflow checking prevent this? If prevented, what happens when version reaches u64::MAX? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: do_upload()] [Update Frequency Bypass] The update frequency check compares Instant::now() - self.last_metadata_update_time >= max_update_frequency (line 250) - can an attacker who controls the file store backend return an artificially large max_update_frequency to prevent metadata updates and cause data loss? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: update_file_store_metadata()] [Metric Inconsistency] FILE_STORE_VERSION.set() is called at line 263 before the actual metadata is saved - if the save_raw_file call at lines 271-273 fails, the metric will be incorrect and monitoring will show the wrong version, hiding failures? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: update_file_store_metadata()] [Metadata Overwrite Attack] The function unconditionally overwrites METADATA_FILE_NAME with new version (lines 271-273) - can concurrent update calls cause race conditions where the version bounces between different values, creating inconsistent metadata? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: update_file_store_metadata()] [Chain ID Mismatch] The metadata includes self.chain_id (line 265), but there's no validation that this matches the actual blockchain - can initialization with wrong chain_id cause permanent metadata corruption that's hard to detect and recover from? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: update_file_store_metadata()] [NUM_TXNS_PER_FOLDER Hardcoded] The constant NUM_TXNS_PER_FOLDER is hardcoded in metadata (line 266), and the constructor checks it matches (lines 68-75) - but what if the constant is changed after data exists, causing all existing data to become unreadable? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Function: update_file_store_metadata()] [Version Regression] The function accepts any version parameter (line 262) without validation - can an attacker or bug cause version to decrease (e.g., passing version 1000 after version 2000 was saved), causing readers to miss transactions or re-index old data? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Constants] [Folder Size Attack] NUM_TXNS_PER_FOLDER is set to 100,000 transactions (line 26) - can an attacker spam tiny transactions to fill folders quickly, or large transactions to make each folder exceed storage limits, causing file system issues? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Constants] [File Size Bypass] MAX_SIZE_PER_FILE is 50MB (line 27) - but if individual transactions approach or exceed this size, can they bypass the size check and cause memory exhaustion or storage issues? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Constants] [Recovery Limit Attack] MAX_NUM_FOLDERS_TO_CHECK_FOR_RECOVERY is only 5 folders (line 28) - if batch metadata is corrupted or missing for 6+ consecutive folders, will recovery panic unnecessarily (line 107-109) even though the data is valid? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Constants] [Update Frequency Exploitation] MIN_UPDATE_FREQUENCY is 10 seconds (line 29) - can this delay cause significant data loss if the process crashes during this window, before metadata is updated to reflect uploaded files? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Concurrency] [Mutable Self Race] The start() function takes &mut self (line 120) but then spawns tasks that capture self - is there proper synchronization, or can concurrent access to last_batch_metadata_update_time (lines 214-248) and last_metadata_update_time (line 250) cause data races? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs] [Concurrency] [Channel Close Detection] If the upload task (lines 138-145) exits or panics, does the main loop (lines 147-177) detect the channel closure and stop gracefully, or does it continue sending to a closed channel causing backpressure? (High)"
]