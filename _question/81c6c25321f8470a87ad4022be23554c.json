[
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [DoS via filter complexity] Can an attacker craft deeply nested BooleanTransactionFilter structures (e.g., 1000 levels of nested AND/OR/NOT operators) that bypass the max_filter_size check since it only validates encoded_len() but not recursion depth, causing CPU exhaustion during filter evaluation and indexer service degradation? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Integer overflow in size check] In the max_filter_size validation at line 99-106, can an attacker exploit integer overflow if proto_filter.encoded_len() returns a value near usize::MAX, causing the size check to pass incorrectly and allowing arbitrarily large filters to crash the indexer? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Recursive deserialization DoS] When deserializing nested LogicalAnd/LogicalOr/LogicalNot filters at lines 116-124, does the recursive call to new_from_proto() without max_filter_size parameter (passing None) allow bypass of size limits in nested filters, enabling unbounded memory allocation? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: matches()] [Recursive stack overflow] Can an attacker create a BooleanTransactionFilter with extremely deep nesting (e.g., 10000 nested NOT operators) that causes stack overflow during the recursive matches() call at lines 250-257, crashing the indexer process? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: and()/or()] [Unvalidated filter combination] When combining filters using and() at line 157-160 or or() at line 187-190, the resulting filter is not validated - can an attacker chain valid individual filters into an invalid combined filter that bypasses validate_state() checks and causes panics during evaluation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalAnd::matches()] [Short-circuit evaluation bypass] At line 296, LogicalAnd uses iter().all() which short-circuits on first false - can an attacker craft filters where expensive checks are placed later, causing inconsistent performance that leaks information about transaction content through timing side-channels? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalOr::matches()] [Short-circuit evaluation bypass] At line 336, LogicalOr uses iter().any() which short-circuits on first true - can timing analysis reveal partial transaction data by observing which filter in the OR chain matched first, leaking sensitive information? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalNot::matches()] [Double negation bypass] Can an attacker create a LogicalNot wrapping another LogicalNot to create double negation at line 365-366, and does this behave identically to no filter, potentially bypassing intended restrictions? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalAnd::validate_state()] [Empty filter array] At lines 288-293, does validate_state() properly reject LogicalAnd with an empty 'and' vector, or can an attacker create an always-true filter by providing an empty array (since all([]) returns true)? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalOr::validate_state()] [Empty filter array] At lines 328-333, does validate_state() properly reject LogicalOr with an empty 'or' vector, or can an attacker create an always-false filter by providing an empty array (since any([]) returns false), breaking expected filter semantics? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom<LogicalAndFilters>] [Malformed protobuf handling] At lines 268-276, when converting from protobuf LogicalAndFilters, can malformed/corrupted protobuf data cause panics or undefined behavior if proto_filter.filters contains invalid oneof variants? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom<LogicalOrFilters>] [Malformed protobuf handling] At lines 308-316, when converting from protobuf LogicalOrFilters, can an attacker provide protobuf with missing required fields causing unwrap() panics during the recursive conversion? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom<APIFilter>] [Missing oneof validation] At lines 380-400, the try_into converts aptos_protos::indexer::v1::ApiFilter but uses ok_or() to handle missing oneof - can an attacker exploit this by sending protobuf messages with empty/unset oneof fields to trigger error paths that reveal internal state? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: From<BooleanTransactionFilter>] [Protobuf explosion] When converting to protobuf at lines 49-91, can recursive conversion of deeply nested filters cause exponential memory allocation in the protobuf encoding, leading to OOM conditions? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: APIFilter::matches()] [Transaction type bypass] At lines 463-483, when matching EventFilter, the code explicitly returns false for StateCheckpoint, Validator, and BlockEpilogue at lines 472-476, but does it properly handle future/unknown transaction types that might be added, potentially allowing filter bypass? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: APIFilter::matches()] [Missing transaction data] At lines 468-480, when txn.txn_data is None, the EventFilter logic returns false, but does this create an inconsistency where transactions missing data are treated differently than transactions with empty event arrays, potentially causing filter bypass? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: APIFilter::matches()] [Pattern matching exhaustiveness] At lines 469-476, the match on TxnData doesn't use a wildcard pattern - can future additions of new transaction types cause compilation errors or undefined behavior if not updated here? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs] [Function: validate_state()] [Empty filter acceptance] At lines 51-55, the validation only checks if BOTH success and txn_type are None, but does it properly validate that the provided txn_type enum value is valid and not out of range? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs] [Function: matches()] [Missing transaction info] At lines 60-64, when item.info is None, the success filter check uses matches_opt() which returns true if the filter is None, but should transactions without info be rejected entirely for security, preventing filter bypass on malformed transactions? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs] [Function: matches()] [Expect on invalid type] At lines 67-71, the code uses expect() when converting transaction type, which will panic on invalid enum values - can an attacker craft a Transaction protobuf with an invalid r#type field value to crash the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs] [Function: From<TransactionRootFilter>] [Lossy enum conversion] At lines 40-46, when converting to protobuf, the transaction_type uses map(Into::into) - does this properly handle all enum variants or can it silently drop invalid/future types? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: validate_state()] [Weak validation] At lines 74-79, the validation only checks that at least one of sender OR payload is set, but doesn't validate the actual sender address format - can an attacker provide an invalid address string that causes panic during standardize_address()? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: matches()] [Missing user request] At lines 84-92, when u.request is None, the function returns false, but does this correctly handle all transaction variants or could a malformed User transaction without a request bypass filters? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: matches()] [Race condition in standardization] At lines 39-45 and 94-97, get_standardized_sender() uses OnceCell which is initialized on first access - in a concurrent environment, can multiple threads race to initialize this, potentially causing inconsistent address comparisons? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Function: matches()] [Payload matching bypass] At lines 100-112, the payload filter only checks entry_function_payload when it exists, but returns true (matches) when payload_filter exists but the transaction has no entry function payload - is this the correct semantic or should it return false to prevent bypass? (Medium)"
]