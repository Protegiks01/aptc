[
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start()] [Channel starvation] The select_next_some() calls at lines 126, 129, 132 will panic if channels are closed. Can a malicious actor close these channels remotely, causing validator crash and network liveness issues? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: new()] [Private key storage] At line 80, key_storage is initialized from SafetyRulesConfig. Is the PersistentSafetyStorage properly secured? Can an attacker with filesystem access read the consensus private keys and use them to sign malicious JWK consensus messages? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Key extraction vulnerability] At lines 217-219, the consensus private key is extracted using consensus_sk_by_pk(). If this operation fails, an error is returned but the validator continues running. Can an attacker delete or corrupt the key storage file, causing legitimate validators to fail key extraction and be unable to participate in consensus? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Key reuse across epochs] The private key extracted at line 217-219 is wrapped in Arc<> at line 230. Can the same private key be reused across multiple epochs without rotation? Does this violate forward secrecy if an old epoch's key is compromised? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Key verification bypass] At line 215-216, the public key is retrieved from the validator set but there's no verification that the stored private key actually corresponds to this public key. Can a validator use a different private key than the one registered in the validator set to participate in consensus? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Struct: EpochManager] [Key storage lifetime] The key_storage at line 48 persists for the entire lifetime of EpochManager. If the process crashes during epoch transition, can partial writes to PersistentSafetyStorage corrupt the key material, preventing validator restart? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Error message information leak] At line 218, the error message includes the actual error from consensus_sk_by_pk(). Can this error message leak sensitive information about the key storage internals that could help an attacker compromise the system? (Low)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Validator set tampering] At lines 155-159, the ValidatorSet is extracted from the payload without cryptographic verification. Can a Byzantine node provide a fake reconfig notification with a manipulated ValidatorSet, causing honest validators to accept unauthorized validators into JWK consensus? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [My index calculation] At lines 161-165, my_index is computed but never validated. Can a validator that's not actually in the validator set (my_index is None) still process RPC messages and events, allowing expelled validators to continue participating in consensus? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Validator impersonation] At line 206, get_ordered_account_addresses() returns the validator list for ReliableBroadcast. If the EpochState was constructed with a tampered ValidatorSet, can Byzantine nodes include themselves multiple times in the list to gain extra voting power? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Non-validator participation] At line 197, the condition checks my_index.is_some() to decide whether to start the JWK manager. But between lines 197-254, there's no additional check that my_addr is actually in the validator set. Can a non-validator node exploit this to start a consensus manager and inject messages? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Address collision] At line 163, address_to_validator_index() is used without checking for hash collisions. Can a Byzantine actor generate an AccountAddress that collides with a legitimate validator's address, allowing them to impersonate the validator in JWK consensus? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Epoch state immutability] At line 159, EpochState is wrapped in Arc without interior mutability. However, multiple components receive clones at lines 160, 232, 242. If any component modifies the underlying data through unsafe code, will all validators have inconsistent epoch states? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Feature flag bypass] At lines 177-195, multiple configuration paths exist with different feature flag checks. Can a Byzantine actor manipulate the OnChainConfigPayload to trigger the fallback path at line 188-194, bypassing the jwk_consensus_enabled() check at line 180 and enabling JWK consensus when it should be disabled? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Configuration race condition] At lines 172-175, multiple configs are fetched from the same payload without atomicity guarantees. Can a race condition during payload construction cause validators to see different combinations of configs, leading to network split where some validators start JWK consensus and others don't? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [OIDC provider manipulation] At lines 181-185, OIDC providers are extracted and converted without validation. Can a malicious governance proposal insert fake OIDC providers with malicious endpoints, causing validators to fetch and consensus on fraudulent JWKs? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [VTxn dependency] At line 180 and 191, both paths require is_vtxn_enabled(). If VTxn is disabled mid-epoch due to a bug or attack, will existing JWK consensus managers continue running, potentially creating validator transactions that cannot be included in blocks? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Default config vulnerability] At line 175, unwrap_or_default() is used for OnChainConsensusConfig. If the config is missing, default values are used. Can an attacker delete the consensus config from on-chain storage, forcing all validators to use potentially unsafe default settings? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Feature flag inconsistency] At line 228, JWK_CONSENSUS_PER_KEY_MODE is checked, but this is a separate flag from the flags checked at lines 180 and 190. Can these flags be in inconsistent states, causing some validators to use KeyLevelConsensusManager while others use IssuerLevelConsensusManager, breaking consensus? (Critical)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Observed JWKs tampering] At line 174, ObservedJWKs is fetched with ok(), silently ignoring errors. If a Byzantine actor corrupts the on-chain JWK state, will validators start with None and potentially reach consensus on JWKs that conflict with the actual on-chain state? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [TODO comment security] At line 189, there's a TODO comment indicating this is temporary code. Is this fallback path production-ready? Can the lack of proper validation in this path be exploited before the framework change is published? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Type confusion] At lines 227-246, either KeyLevelConsensusManager or IssuerLevelConsensusManager is created based on a feature flag, but both are cast to Box<dyn TConsensusManager>. Can differences in their behavior or security assumptions cause vulnerabilities when the wrong type is active? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Spawn without monitoring] At line 247, the consensus manager is spawned with tokio::spawn without any error handling or monitoring. If the spawned task panics, will the epoch manager detect this and restart it, or will the validator silently stop participating in JWK consensus? (High)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [Channel capacity mismatch] At line 220, jwk_event_rx is created with capacity 1 (KLAST), while at line 222, jwk_rpc_msg_rx uses capacity 100 (FIFO). Can this capacity mismatch cause backpressure issues where RPC messages queue up while events are dropped, leading to consensus divergence? (Medium)",
  "[File: aptos-core/crates/aptos-jwk-consensus/src/epoch_manager.rs] [Function: start_new_epoch()] [UpdateCertifier construction] At line 238, UpdateCertifier::new(rb) is created only for IssuerLevelConsensusManager. Is ReliableBroadcast being used by both the UpdateCertifier and the KeyLevelConsensusManager? Can this cause message broadcast conflicts or duplicate messages? (Medium)"
]