[
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: handle_to_loaded_function()] [Lazy verification bypass] The 'lazily_verified' module loading - can unverified modules be loaded and used in type checking? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: handle_to_loaded_function()] [Module storage manipulation] Can module_storage be manipulated to return malicious modules that pass shallow verification but contain exploits? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: handle_to_loaded_function()] [Function name collision] Can two modules have functions with same name causing get_function to return wrong function? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_native_call()] [Type stack underflow] When pop_ty() is called in the loop at line 520, can insufficient stack depth cause underflow leading to panic? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_native_call()] [Type stack overflow] When push_ty() is called for return types, can excessive return values cause stack overflow? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: set_new_frame()] [Type stack consistency] When types are popped from type_stack during parameter checking, if a check fails midway, are the already-popped types lost? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: replay_impl()] [Call stack underflow] When call_stack.pop() returns None, execution terminates - can this be exploited to exit prematurely leaving unvalidated code? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: replay_impl()] [Type check return] The type_check_return call at line 166 - can return type mismatches be exploited to return incompatible values to callers? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: set_new_frame()] [Call stack depth limit] The error at line 652 claims overflow 'cannot happen during replay' - but can recursive functions exceed the limit? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Pack instruction] Are Pack/PackGeneric instructions properly validated for struct type parameters, or can attacker pack structs with wrong field types? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [PackVariant enum safety] Do PackVariant/PackVariantGeneric instructions validate that the variant tag matches the enum definition? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Unpack type validation] Can Unpack/UnpackGeneric instructions be exploited to unpack structs with incompatible field types onto the stack? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [UnpackVariant tag mismatch] Can UnpackVariant instructions unpack the wrong variant, accessing memory with incorrect type interpretation? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [TestVariant exploits] Can TestVariant instructions be used to leak information about memory layout by testing invalid variant tags? (Low)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [ReadRef/WriteRef safety] Are ReadRef and WriteRef instructions type-checked to ensure borrowed references have correct mutability and type? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [FreezeRef mutability] Can FreezeRef be exploited to freeze references that shouldn't be frozen, bypassing mutability checks later? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [MutBorrowLoc/ImmBorrowLoc] Are local borrows validated to prevent simultaneous mutable and immutable borrows of the same local? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [MutBorrowField field bounds] Can MutBorrowField/MutBorrowFieldGeneric access out-of-bounds struct fields? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [MutBorrowVariantField variant safety] Can MutBorrowVariantField access fields of the wrong variant causing type confusion? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [ImmBorrowField const violation] Can ImmBorrowField be used to get mutable access to supposedly immutable data through type confusion? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Global operations] Are MutBorrowGlobal/ImmBorrowGlobal/MoveFrom/MoveTo properly validated for resource type correctness? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Exists check bypass] Can the Exists/ExistsGeneric instructions be manipulated to check for resources of wrong types? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Arithmetic overflow] Do Add/Sub/Mul/Div/Mod instructions properly check for integer overflow and division by zero in type checking? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Bitwise operation types] Are BitOr/BitAnd/Xor/Shl/Shr validated to only work on integer types, not other types? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_type_checks_async.rs] [Function: execute_instructions()] [Comparison type safety] Do Eq/Neq/Lt/Gt/Le/Ge instructions validate operands are comparable types? (High)"
]