[
  "[File: aptos-core\n\n### Citations\n\n**File:** crates/aptos-dkg/src/pcs/univariate_kzg.rs (L1-68)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::sigma_protocol::{\n    homomorphism,\n    homomorphism::{fixed_base_msms, fixed_base_msms::Trait, TrivialShape as CodomainShape},\n};\nuse ark_ec::{pairing::Pairing, VariableBaseMSM};\nuse ark_serialize::{CanonicalDeserialize, CanonicalSerialize};\nuse std::fmt::Debug;\n\n/// Homomorphism for univariate KZG commitments using a Lagrange basis.\n///\n/// # Description\n/// - Maps values (domain), combined with randomness, to a G1 group element (codomain).\n/// - Input domain:\n///   - `E::ScalarField`: blinding factor, thought of as f(omega^0)\n///   - `Vec<E::ScalarField>`: the remaining values, which will correspond to f(omega^i) for i > 0\n/// - Uses `lagr_g1` because the input represents **evaluations**, not coefficients.\n///\n/// For the sake of modularity, we might refactor this in the future to have this homomorphism feed into a homomorphism whose input are only values (by concatenating the inputs into one Vec).\n#[derive(CanonicalSerialize)]\npub struct Homomorphism<'a, E: Pairing> {\n    pub lagr_g1: &'a [E::G1Affine],\n}\n\nimpl<'a, E: Pairing> homomorphism::Trait for Homomorphism<'a, E> {\n    type Codomain = CodomainShape<E::G1>;\n    /// Input domain: (blinding factor, remaining values)\n    type Domain = (E::ScalarField, Vec<E::ScalarField>);\n\n    fn apply(&self, input: &Self::Domain) -> Self::Codomain {\n        self.apply_msm(self.msm_terms(input))\n    }\n}\n\nimpl<'a, E: Pairing> fixed_base_msms::Trait for Homomorphism<'a, E> {\n    type Base = E::G1Affine;\n    type CodomainShape<T>\n        = CodomainShape<T>\n    where\n        T: CanonicalSerialize + CanonicalDeserialize + Clone + Debug + Eq;\n    type MsmInput = fixed_base_msms::MsmInput<Self::Base, Self::Scalar>;\n    type MsmOutput = E::G1;\n    type Scalar = E::ScalarField;\n\n    fn msm_terms(&self, input: &Self::Domain) -> Self::CodomainShape<Self::MsmInput> {\n        debug_assert!(\n            self.lagr_g1.len() > input.1.len(),"
]