[
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Missing checksum validation] The standardize_address() function doesn't validate address checksums (if Aptos uses them) - can attackers provide addresses with invalid checksums that pass filtering but fail later validation, causing inconsistencies? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: is_valid()] [Error propagation bypass] At lines 30-39, is_valid() calls validate_state() and adds trace information on error, but can an attacker craft filters where validate_state() returns Ok() prematurely without recursively checking all nested filters, bypassing validation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: is_valid()] [Serialization panic] At line 34, serde_json::to_string(self).unwrap() is called - can an attacker craft a filter that fails JSON serialization (e.g., with circular references or invalid UTF-8) causing unwrap() to panic and crash the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: matches()] [Missing pre-validation] The matches() method at line 46 can be called directly without calling is_valid() first - can an attacker exploit invalid filters that weren't validated to cause panics or undefined behavior during matching? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: matches_vec()] [Empty array semantics] At lines 49-51, matches_vec() returns true if ANY item matches using iter().any() - but does this correctly handle empty arrays (returns false), and is this the intended semantic or should empty arrays match by default? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: matches_opt()] [None handling inconsistency] At lines 54-59, matches_opt() returns false when the Option is None, but should None be treated as 'no constraint' (always match) rather than 'no match' to maintain consistency with other filter semantics? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: Option<F>::matches()] [Semantic confusion] At lines 92-97, Option<Filterable>::matches() returns true when filter is None (meaning no restriction), but this conflicts with matches_opt() behavior at line 57 which returns false for None - can this inconsistency cause logic bugs? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: Option<String>::matches()] [Case sensitivity] At lines 108-121, Option<String> implements Filterable with direct equality comparison (filter == item) - is this case-sensitive comparison correct for all string filter use cases, or should it be case-insensitive? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: Option<i32>::matches()] [Integer type assumption] At lines 123-136, the Filterable implementation for Option<i32> assumes transaction types/enums fit in i32, but could future Aptos upgrades introduce types requiring i64 causing silent truncation bugs? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/traits.rs] [Function: Option<bool>::matches()] [Boolean logic bypass] At lines 138-151, Option<bool> matching uses direct equality, but could Three-valued logic (true/false/unknown) be more appropriate for transaction filtering to avoid accidentally accepting transactions with missing boolean fields? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/errors.rs] [Function: FilterError::new()] [Unbounded error chain] At lines 45-50, FilterError stores an arbitrary error chain in SerializableError, but is there a limit on the depth or size of error chains - can attackers craft deeply nested errors to cause memory exhaustion? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/errors.rs] [Function: FilterError::add_trace()] [Unbounded trace accumulation] At lines 52-57, add_trace() pushes to filter_path without any limit - can an attacker craft filters with thousands of nested levels to accumulate an unbounded trace vector, causing memory exhaustion? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/errors.rs] [Function: Display for FilterError] [Information disclosure] At lines 66-80, the Display implementation shows detailed error traces including serialized filter content - can this leak sensitive information about filter structure or internal state to attackers? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/errors.rs] [Function: From<anyhow::Error>] [Error type confusion] At lines 60-64, any anyhow::Error is converted to FilterError, but does this properly preserve error context or could error type confusion cause incorrect error handling? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/errors.rs] [Function: SerializableError::serialize()] [Serialization error handling] At lines 89-96, errors are serialized as strings using to_string(), but what if the error contains non-UTF-8 data or extremely long messages - can this cause serialization failures or performance issues? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Struct: BooleanTransactionFilter] [Clone semantics] The BooleanTransactionFilter derives Clone at line 16, but does cloning properly handle the nested Box<BooleanTransactionFilter> in LogicalNot without causing stack overflow on deeply nested structures? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Struct: EventFilter] [OnceCell thread safety] EventFilter's data_substring_finder uses OnceCell at line 41 which is not Send/Sync by default - in a multi-threaded indexer, can filters be shared across threads safely or does this cause data races? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Struct: UserTransactionFilter] [OnceCell memory ordering] At line 35, standardized_sender uses OnceCell without explicit memory ordering guarantees - can weak memory ordering on ARM/RISC-V architectures cause threads to see unstandardized addresses after initialization? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Struct: MoveStructTagFilter] [OnceCell initialization race] At line 34, standardized_address uses OnceCell - if two threads initialize this simultaneously with different standardization results due to a race condition, which value is kept and can this cause filter bypasses? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs] [Derive: Builder] [Invalid default state] EventFilter derives Builder with default at line 31 - does the default constructor create a valid filter state (e.g., with both data_substring_filter and struct_type as None), or does it violate the constraint that at least one must be set? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs] [Derive: Builder] [Missing build validation] TransactionRootFilterBuilder at line 21 doesn't call validate_state() in build() - can an attacker use the builder to create invalid filters that bypass validation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Derive: Builder] [Setter validation] UserTransactionFilterBuilder at line 26 uses setter(into, strip_option) - can type coercion via into() allow attackers to provide unexpected types that bypass intended validation? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs] [Derive: Builder] [Skip setter bypass] At line 35, standardized_sender has setter(skip) - but can an attacker manually construct the struct to provide a pre-initialized OnceCell with a malicious value, bypassing standardization? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs] [Derive: Builder] [Builder state corruption] MoveStructTagFilterBuilder at line 24 allows setting address, module, name independently - can partial builds create filters in invalid states if build() is called prematurely? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Derive: Serialize, Deserialize] [Untagged enum confusion] BooleanTransactionFilter uses #[serde(untagged)] at line 17 - can ambiguous JSON cause deserialization to choose the wrong variant, creating filter confusion attacks where And is interpreted as Or? (High)"
]