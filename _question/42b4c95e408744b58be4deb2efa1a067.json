[
  "[File: consensus/src/consensus_observer/publisher/consensus_publisher.rs] [Function: process_network_message()] [ACK Protocol] Can SubscribeAck/UnsubscribeAck be lost or reordered, causing peers to have incorrect understanding of their subscription state? (Medium)",
  "[File: consensus/src/consensus_\n\n### Citations\n\n**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L1-654)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::consensus_observer::{\n    common::{\n        logging::{LogEntry, LogEvent, LogSchema},\n        metrics,\n    },\n    network::{\n        network_handler::ConsensusPublisherNetworkMessage,\n        observer_client::ConsensusObserverClient,\n        observer_message::{\n            ConsensusObserverDirectSend, ConsensusObserverMessage, ConsensusObserverRequest,\n            ConsensusObserverResponse,\n        },\n    },\n};\nuse aptos_channels::aptos_channel::Receiver;\nuse aptos_config::{config::ConsensusObserverConfig, network_id::PeerNetworkId};\nuse aptos_infallible::RwLock;\nuse aptos_logger::{error, info, warn};\nuse aptos_network::application::interface::NetworkClient;\nuse futures::StreamExt;\nuse futures_channel::mpsc;\nuse std::{collections::HashSet, sync::Arc, time::Duration};\nuse tokio::time::interval;\nuse tokio_stream::wrappers::IntervalStream;\n\n/// The consensus publisher sends consensus updates to downstream observers\n#[derive(Clone)]\npub struct ConsensusPublisher {\n    // The consensus observer client to send network messages\n    consensus_observer_client:\n        Arc<ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>>,\n\n    // The configuration for the consensus observer\n    consensus_observer_config: ConsensusObserverConfig,\n\n    // The set of active subscribers that have subscribed to consensus updates\n    active_subscribers: Arc<RwLock<HashSet<PeerNetworkId>>>,\n\n    // The sender for outbound network messages\n    outbound_message_sender: mpsc::Sender<(PeerNetworkId, ConsensusObserverDirectSend)>,\n}\n\nimpl ConsensusPublisher {\n    pub fn new(\n        consensus_observer_config: ConsensusObserverConfig,\n        consensus_observer_client: Arc<\n            ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>,\n        >,\n    ) -> (\n        Self,\n        mpsc::Receiver<(PeerNetworkId, ConsensusObserverDirectSend)>,\n    ) {\n        // Create the outbound message sender and receiver\n        let max_network_channel_size = consensus_observer_config.max_network_channel_size as usize;\n        let (outbound_message_sender, outbound_message_receiver) =\n            mpsc::channel(max_network_channel_size);\n\n        // Create the consensus publisher\n        let consensus_publisher = Self {\n            consensus_observer_client,\n            consensus_observer_config,\n            active_subscribers: Arc::new(RwLock::new(HashSet::new())),\n            outbound_message_sender,\n        };\n\n        // Return the publisher and the outbound message receiver\n        (consensus_publisher, outbound_message_receiver)\n    }\n\n    #[cfg(test)]\n    /// Creates a new consensus publisher with the given active subscribers\n    pub fn new_with_active_subscribers(\n        consensus_observer_config: ConsensusObserverConfig,\n        consensus_observer_client: Arc<\n            ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>,\n        >,\n        active_subscribers: HashSet<PeerNetworkId>,\n    ) -> Self {\n        // Create the consensus publisher\n        let (consensus_publisher, _) =\n            ConsensusPublisher::new(consensus_observer_config, consensus_observer_client);\n\n        // Update the active subscribers\n        *consensus_publisher.active_subscribers.write() = active_subscribers;\n\n        // Return the publisher\n        consensus_publisher\n    }\n\n    /// Adds the given subscriber to the set of active subscribers\n    fn add_active_subscriber(&self, peer_network_id: PeerNetworkId) {\n        self.active_subscribers.write().insert(peer_network_id);\n    }\n\n    /// Garbage collect inactive subscriptions by removing peers that are no longer connected\n    fn garbage_collect_subscriptions(&self) {\n        // Get the set of active subscribers\n        let active_subscribers = self.get_active_subscribers();\n\n        // Get the connected peers and metadata\n        let peers_and_metadata = self.consensus_observer_client.get_peers_and_metadata();\n        let connected_peers_and_metadata =\n            match peers_and_metadata.get_connected_peers_and_metadata() {\n                Ok(connected_peers_and_metadata) => connected_peers_and_metadata,\n                Err(error) => {\n                    // We failed to get the connected peers and metadata\n                    warn!(LogSchema::new(LogEntry::ConsensusPublisher)\n                        .event(LogEvent::UnexpectedError)\n                        .message(&format!("
]