[
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Duplicate index entries] If the same (stale_since_version, version, state_key_hash) tuple exists multiple times in the index (database corruption), will batch.delete at line 63 be called multiple times for the same key, and can this cause issues? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: new()] [Progress regression] If progress from line 30-34 > metadata_progress, the catch-up at line 42 will prune nothing but still update progress - can this mask issues where shards are ahead of metadata indicating synchronization problems? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Batch operation ordering] The batch accumulates deletes at lines 63-64, then put at lines 66-69 - does RocksDB guarantee these execute in order, or can reordering cause metadata to update before deletions complete? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Transaction rollback] If write_schemas at line 71 is not fully atomic (depends on RocksDB write options), can partial rollback occur where only some schema deletions are reverted, leaving inconsistent state? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Index deserialization attack] At line 59, the index is deserialized from database - if an attacker previously wrote malformed index data, can deserialization fail in ways that corrupt the iterator or cause panics? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: new()] [Recursive catch-up] If metadata_progress is updated concurrently while new() executes, and multiple pruners are initialized, can recursive catch-up calls cause stack overflow or infinite loops? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Break condition correctness] The break at line 61 assumes entries are strictly ordered by stale_since_version - if this assumption is violated by database corruption, will the pruner miss entries that should be deleted? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [State key hash space exhaustion] If state_key_hash space is fully utilized, can hash routing to shards become unbalanced causing some shards to accumulate excessive stale data while others remain small? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Struct: StateKvShardPruner] [Lifetime assumptions] The pruner holds Arc<DB> which could outlive the parent StateKvDb - can this cause use-after-free if the parent is dropped while pruner still holds references? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Metadata write failure isolation] If the metadata put at lines 66-69 fails but subsequent write_schemas succeeds (unlikely but possible with partial disk failure), can this cause permanent loss of progress tracking? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs] [Function: prune()] [Version timestamp assumptions] If Version values represent timestamps and system clock skew occurs, can this cause stale\n\n### Citations\n\n**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_shard_pruner.rs (L1-77)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    pruner::pruner_utils::get_or_initialize_subpruner_progress,\n    schema::{\n        db_metadata::{DbMetadataKey, DbMetadataSchema, DbMetadataValue},\n        stale_state_value_index_by_key_hash::StaleStateValueIndexByKeyHashSchema,\n        state_value_by_key_hash::StateValueByKeyHashSchema,\n    },\n};\nuse aptos_logger::info;\nuse aptos_schemadb::{batch::SchemaBatch, DB};\nuse aptos_storage_interface::Result;\nuse aptos_types::transaction::Version;\nuse std::sync::Arc;\n\n// This pruner is only used when enable_sharding flag is true\npub(in crate::pruner) struct StateKvShardPruner {\n    shard_id: usize,\n    db_shard: Arc<DB>,\n}\n\nimpl StateKvShardPruner {\n    pub(in crate::pruner) fn new(\n        shard_id: usize,\n        db_shard: Arc<DB>,\n        metadata_progress: Version,\n    ) -> Result<Self> {\n        let progress = get_or_initialize_subpruner_progress(\n            &db_shard,\n            &DbMetadataKey::StateKvShardPrunerProgress(shard_id),\n            metadata_progress,\n        )?;\n        let myself = Self { shard_id, db_shard };\n\n        info!(\n            progress = progress,\n            metadata_progress = metadata_progress,"
]