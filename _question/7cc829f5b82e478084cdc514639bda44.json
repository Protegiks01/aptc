[
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Named address collision] In the named_address_mapping construction at lines 160-169, can an attacker craft a malicious dependency package with conflicting named address mappings that shadow system addresses (e.g., @aptos_framework, @aptos_std), allowing code injection into privileged modules and enabling unlimited APT minting? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Address resolution attack] When merging named_address_map from targets and deps via chain() at lines 160-162, can duplicate address names from malicious dependencies override root package addresses, causing the compiler to resolve system module calls to attacker-controlled code? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Address shadowing] Does the flat_map operation at lines 163-168 properly detect when multiple packages define the same named address with different values, or can an attacker exploit the ordering to shadow legitimate addresses and redirect module imports? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Resolution table manipulation] At line 59 where pkg.resolution_table is accessed, can a malicious dependency provide an empty or manipulated resolution_table that causes system addresses to become unresolved, breaking framework module imports and causing denial of service? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Address format injection] In the format! macro at line 166 where addresses are formatted as '{}={}', can an attacker inject special characters or escape sequences in address names that corrupt the named_address_mapping string, causing parser confusion or arbitrary address assignment? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Address cloning vulnerability] When named_address_map.clone() is called at line 92 and 99, does this deep clone prevent shared mutable state, or can modifications to cloned maps propagate back to affect other packages' address resolution? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Dependency substitution] In the filter_map at lines 43-62, when checking nm == root_name at line 44, can an attacker register a malicious package with the same name as the root package to inject into the dependency list and execute arbitrary Move code? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Root package confusion] At line 38 where root_package is cloned from resolution_graph, can a malicious ResolvedGraph provide a fake root_package pointing to attacker-controlled code that gets compiled with elevated privileges? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Package table iteration] Does the iteration over package_table at line 42 guarantee deterministic ordering, or can non-deterministic iteration cause different validators to build different dependency lists, resulting in state divergence and chain splits? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Dependency verification bypass] When collecting deps_source_info at lines 39-63, are the Package objects validated against signatures or checksums, or can a man-in-the-middle attacker substitute malicious package bytecode during resolution? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Circular dependency exploitation] If the package_table contains circular dependencies, can the iteration at lines 42-63 cause infinite loops, stack overflow, or allow an attacker to include the same malicious code multiple times with different addresses? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Bytecode substitution] At lines 51-55 where source falls back to bytecode when dep_source_paths.is_empty(), can an attacker provide malicious bytecode that bypasses source-level security checks (like attribute validation), executing arbitrary opcodes? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Source availability flag bypass] Does the source_available boolean at lines 50 and 60 affect security validation, or can an attacker set it to false to force bytecode loading that skips type checking and allows invalid Move operations? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Bytecode verification gap] When get_bytecodes() is called at line 53, are the bytecode files verified for Move VM compatibility and safety, or can pre-compiled malicious bytecode with invalid type descriptors cause VM crashes or memory corruption? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Mixed source/bytecode attack] Can an attacker provide a package with some modules as source and others as bytecode, causing inconsistent compilation where bytecode modules bypass security checks applied only to source modules? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Empty path edge case] At line 52 where is_empty() is checked, can both get_sources() and get_bytecodes() return empty vectors, causing the package to be silently skipped while its resolution_table is still used, leading to unresolved imports? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Path traversal] When source paths are collected via get_sources() at line 48, can an attacker include paths with '../' sequences to read arbitrary files outside the package directory and leak sensitive validator keys or configuration? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Source file injection] At lines 150-153 where paths are converted to strings and collected into options.sources, are the file paths validated against a whitelist, or can an attacker inject system files (/etc/passwd) that get parsed as Move code? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Dependency path poisoning] When collecting dependencies at lines 156-159, can malicious paths containing symlinks redirect the compiler to attacker-controlled directories, allowing code injection into the dependency resolution? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Filter bypass - path manipulation] In the target_filter logic at lines 76-109, can an attacker craft file paths that contain the filter string in a parent directory name rather than the file itself, causing system modules to be incorrectly classified as targets and bypass dependency checks? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Absolute path injection] Are the paths in PackagePaths validated to be relative, or can absolute paths pointing to system directories be injected, allowing compilation of arbitrary Move code from any location on the validator's filesystem? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Attribute check bypass] At lines 111-115 where skip_attribute_checks is read from build_options, can an attacker manipulate the BuildConfig to disable attribute validation, allowing malicious packages to use restricted attributes like #[test_only] in production code? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Known attributes manipulation] When known_attributes is cloned at lines 116-120 and 131, can an attacker provide a modified known_attributes set that whitelists malicious custom attributes, enabling code execution through attribute macro expansion? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Language version downgrade] At lines 125-129 where language_version is assigned from build_options, can an attacker force compilation with an older language version that has known vulnerabilities or lacks security features? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Experiment flag abuse] When experiments are cloned at lines 134-140, can an attacker enable experimental compiler features that bypass production safety checks, allowing unstable or untested code transformations that introduce vulnerabilities? (High)"
]