[
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_epoch_ending_ledger_infos()] [Epoch subtraction] At lines 838-843, computing highest_local_epoch_end requires subtracting 1 from epoch if ledger info doesn't end epoch, but can malicious epoch values at boundary conditions cause incorrect epoch identification? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_next_data_notification()] [Stream timeout exploitation] At lines 584-598, if max_num_stream_timeouts is reached (line 593), the stream resets, but can an attacker repeatedly trigger timeouts to prevent bootstrap progress while keeping the node in perpetual sync attempt state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_active_stream_notifications()] [Notification loop exhaustion] At lines 602-661, the loop processes up to max_consecutive_stream_notifications, but can an attacker send exactly that many valid-but-useless notifications to prevent progress on critical data? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: reset_active_stream()] [Stream reset race] At lines 1540-1557, if reset_active_stream() is called concurrently from multiple contexts (e.g., timeout and error handling), can the speculative_stream_state be set to None while still being accessed elsewhere? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: handle_end_of_stream_or_invalid_payload()] [Premature end of stream] At lines 1467-1488, if DataPayload::EndOfStream is received before all expected data is synced, does the stream reset without proper verification that sync is complete, potentially leaving the node in inconsistent state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: drive_progress()] [Active stream race condition] At lines 415-442, checking active_data_stream.is_some() and then processing notifications is not atomic - can the stream be reset between the check and processing, causing null pointer or logic errors? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: initialize_active_data_stream()] [Chunk executor reset timing] At line 459, reset_chunk_executor() is called to flush invalid in-memory state, but can this reset occur while storage_synchronizer is still committing data from a previous stream, causing data corruption? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [Fallback mode abuse] At lines 769-797, if output_fallback_handler.in_fallback_mode() returns true, the node switches to transaction outputs, but can an attacker force repeated execution failures to permanently trap the node in less-secure output-only mode? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: handle_storage_synchronizer_error()] [Fallback transition vulnerability] At lines 1517-1537, when ExecuteOrApplyFromGenesis mode encounters errors, it falls back to outputs at line 1528, but is this fallback decision persisted, allowing an attacker to permanently downgrade node security through transient errors? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [Fallback metric manipulation] At lines 771-775, the DRIVER_FALLBACK_MODE metric is set to 1 when in fallback, but can an attacker monitoring this metric identify which nodes are in degraded mode and target them for attacks? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: handle_storage_synchronizer_error()] [Error recovery bypass] At line 1523, reset_active_stream() is called with notification feedback, but if this reset fails, does the error propagate or is it silently swallowed, allowing corrupted state to persist? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_transaction_info_to_sync()] [Single transaction info verification] At lines 1288-1294, the code checks that transaction_infos.len() == 1, but does it verify that this single transaction info corresponds to the correct version before using it for state root verification? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_transaction_info_to_sync()] [Proof verification timing] At lines 1295-1313, if transaction_outputs_with_proof.verify() succeeds but the ledger_info_to_sync has been updated concurrently, can mismatched proofs be accepted? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_epoch_ending_payload()] [Empty payload bypass] At lines 1082-1091, the code checks for empty epoch_ending_ledger_infos and returns error, but what if the payload contains a single invalid ledger info that fails verification later - is the stream properly reset before state corruption? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_epoch_ending_payload()] [Batch verification atomicity] At lines 1095-1107, epoch ending ledger infos are verified in a loop, but if verification fails midway, are the already-verified ledger infos rolled back, or do they remain in verified_epoch_states causing inconsistency? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_payload_start_version()] [Version mismatch handling] At lines 1340-1370, if payload_start_version doesn't match expected_start_version, the stream resets, but can an attacker cause repeated version mismatches to prevent sync while keeping node in resource-consuming retry loop? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: bootstrapping_complete()] [Premature completion] At lines 374-379, bootstrapped is set to true, but is there proper verification that all required data (epoch states, waypoint, state values) is actually synced before marking complete? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: notify_listeners_if_bootstrapped()] [Listener notification race] At lines 397-412, if bootstrap_notifier_channel.send() succeeds but reset_active_stream() or finish_chunk_executor() fails afterward, is the listener falsely notified of successful bootstrap? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: is_bootstrapped()] [Bootstrap flag check] At line 369, the function simply returns self.bootstrapped, but can this flag be set through other code paths without proper validation, bypassing bootstrap requirements? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: subscribe_to_bootstrap_notifications()] [Multiple subscriber check] At lines 382-394, only one bootstrap subscriber is allowed (line 386), but can an attacker repeatedly subscribe and unsubscribe to cause race conditions or resource leaks in notification handling? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_snapshot_data()] [Genesis fast sync completion] At lines 527-532, if fast sync to genesis completes but highest_synced_version doesn't match GENESIS_TRANSACTION_VERSION (0), an UnexpectedError occurs, but what caused this mismatch and is it exploitable? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_snapshot_data()] [Version threshold bypass] At lines 564-572, if num_versions_behind is less than num_versions_to_skip_snapshot_sync, bootstrapping completes, but can an attacker manipulate network state to keep the node just under this threshold while actually being far behind? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: initialize_active_data_stream()] [Already synced bypass] At lines 484-489, if highest_synced_version >= highest_known_ledger_version, bootstrapping completes, but what if storage is corrupted at this version - does completion occur without state validity checks? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [Save state values failure handling] At lines 1036-1050, if storage_synchronizer.save_state_values() fails, the stream resets with InvalidPayloadData feedback, but is the partially saved state rolled back or does it persist, causing corruption? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: drive_progress()] [Pending data check] At line 428, if storage_synchronizer.pending_storage_data() returns true, the bootstrapper waits, but can this wait become infinite if pending data is stuck, causing perpetual bootstrap failure? (High)"
]