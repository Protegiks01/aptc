[
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Division by zero] Can an attacker create a malicious DelegationPool resource with scaling_factor set to zero, causing a division by zero panic at line 90 when calculating `shares / &pool_balance.scaling_factor`, potentially crashing the indexer and causing loss of liveness? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Precision loss] Does the BigDecimal division at line 90 properly handle precision loss when scaling_factor is extremely large, or could rounding errors cause delegators to lose track of small share amounts leading to permanent fund freezing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Integer overflow] Can malicious transaction data contain share values that overflow when parsed as BigDecimal at lines 78-89, potentially causing incorrect balance tracking or indexer crash? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Division by zero] Can an attacker manipulate inactive pool metadata to have scaling_factor of zero, causing a panic at line 151 during `shares / &pool_balance.scaling_factor`, halting the indexer and preventing balance updates? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Arithmetic inconsistency] If scaling_factor differs between active and inactive pools for the same staking pool, could this cause share value inconsistencies that lead to incorrect reward distribution calculations? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Negative shares] Does the BigDecimal parsing at lines 78-89 validate that shares are non-negative, or could malicious transaction data inject negative share values that corrupt balance accounting? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Negative shares] Does the BigDecimal parsing at lines 139-150 prevent negative share values, or could an attacker use negative shares to drain pool balances by exploiting arithmetic underflow? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Precision manipulation] Can an attacker exploit floating-point-like precision in BigDecimal arithmetic to create share values that round differently across different indexer instances, causing consensus failures in indexed data? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Panic DoS] The unwrap_or_else with panic! at lines 72-76 will crash the indexer if data field is None - can an attacker craft WriteTableItem with None data to cause permanent indexer failure requiring manual intervention? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Panic DoS] The unwrap_or_else with panic! at lines 133-137 assumes data is always present - can malicious transactions omit this field to trigger panic and halt all delegator balance indexing? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Silent error suppression] Multiple .unwrap() calls at lines 332, 338, 345, 361, 372, 381, 392 silently convert Result::Err into panic - can this hide critical parsing errors and cause indexer crashes on edge case transactions? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [Error swallowing] Lines 210-223 silently return Ok(None) on database lookup failure with only a log message - could this cause delegator balances to become permanently stale if database queries consistently fail? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Retry exhaustion] If all QUERY_RETRIES attempts fail at lines 303-310, the function returns a generic error - can adversarial database conditions cause permanent loss of delegator balance tracking? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Context loss] The context! macro at lines 82-89 adds error context but the underlying parse error might be swallowed - can malformed share values bypass validation and corrupt database state? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Context loss] Multiple context! calls at lines 143-150 may hide root cause of parsing failures - could this prevent detection of systematic data corruption attacks? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Missing validation] Lines 78-89 parse data.value as string then BigDecimal without validating format - can an attacker inject non-numeric strings that parse as unexpected values, corrupting balance records? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Type confusion] The code expects data.value to be a string at line 80, but what if the API returns a number type? Could type mismatch cause silent failures or incorrect parsing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Address validation bypass] Line 71 uses standardize_address but doesn't validate the result - can malformed addresses pass through and create invalid database records that break queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Address validation bypass] Line 132 standardizes delegator_address without checking validity - could attackers create delegator_balances entries with corrupt addresses that break API queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_delete_table_item()] [No data validation] Lines 167-188 set shares to zero without verifying the delete operation is legitimate - can an attacker forge DeleteTableItem events to artificially zero out delegator balances? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [No data validation] Lines 191-239 assume all DeleteTableItem operations are valid - could malicious validators include fake delete events to manipulate delegator balance tracking? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Table handle collision] Line 67 uses table_handle as HashMap key without uniqueness check - can multiple pools with same table_handle collide, causing balance updates to be applied to wrong pools? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Table handle collision] Line 114 relies on table_handle uniqueness in HashMap - if two inactive pools share a handle, could balance updates be misdirected leading to fund tracking errors? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [pool_type hardcoded] Line 94 hardcodes pool_type as 'active_shares' string - is this value validated against database schema constraints, or could typos cause query failures? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [pool_type hardcoded] Line 155 hardcodes pool_type as 'inactive_shares' - are these string constants validated, or could schema changes break the indexer silently? (Low)"
]