[
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: is_valid_resource_group_member()] [Error message bug] Line 437 returns ViewFunction attribute error for ResourceGroupMember validation failure - another error type confusion issue? (Low)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: get_metadata()] [Cross-validator inconsistency] If validators have different cache states due to different transaction ordering, can metadata lookups return different results causing consensus failures? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: verify_module_metadata_for_module_publishing()] [Feature flag desync] Multiple feature flag checks at lines 445, 449, 496, 507 - can epoch boundary transitions cause validators to see different feature flag states? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: check_module_complexity()] [Bytecode vs source mismatch] Complexity is checked on compiled module, but does source-level metadata validation occur separately - can discrepancies cause security bypasses? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: get_randomness_annotation_for_entry_function()] [Transaction vs module metadata] Randomness annotation is read from module metadata, but can transaction execution context override or bypass these limits? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Struct: RuntimeModuleMetadataV1] [Serialization determinism] BTreeMap serialization should be deterministic, but can BCS encoding variations cause different validators to produce different serializations? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: check_metadata_format()] [Compilation metadata interaction] Lines 270-277 validate CompilationMetadata separately - can malicious compilation metadata affect runtime metadata processing? (Medium)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: get_compilation_metadata()] [Metadata isolation] Lines 311-317 extract compilation metadata - is this metadata properly isolated from runtime execution to prevent compiler-based attacks? (Medium)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Constant: METADATA_CACHE_SIZE] [Global cache size] All caches share 1024 entry limit - can attackers exploit cache thrashing between V0 and V1 caches to cause performance degradation? (Medium)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: safe_get_table()] [Table consistency] Function assumes table contents don't change during access - can parallel execution cause tables to be modified during validation? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Enum: ResourceGroupScope] [Scope upgrade attack] Can modules be deployed with relaxed scope (Global) then have members added with stricter scope (Module), violating scope containment? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: check_sigtok_complexity()] [Move type system bypass] Complexity checking walks signature tokens but does Move VM's actual type instantiation cost match these estimates? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: is_valid_resource_group()] [Move resource semantics] Resource group validation checks abilities but does it ensure compliance with Move's linear type semantics? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: is_valid_resource_group_member()] [Key ability semantics] Only Key ability is checked - does this properly enforce that members are storable in global storage? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: is_valid_view_function()] [View function semantics] Validation only checks return type exists - does it prevent state mutation, which is the key view function requirement? (Critical)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: verify_module_metadata_for_module_publishing()] [Module linking] Validation is per-module but doesn't check cross-module references - can malicious modules reference attributes from other modules incorrectly? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Struct: RuntimeModuleMetadataV1] [Error map usage] Error map links abort codes to descriptions - can attackers craft modules with wrong error codes to mislead debugging and hide exploit traces? (Low)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: extract_abort_info()] [Error code lookup] The function checks both masked and full codes - but which takes precedence in case of conflict, and can this be exploited? (Low)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: check_module_complexity()] [Gas-complexity mismatch] Complexity budget prevents DoS during validation, but does it correlate with actual execution gas costs? (High)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: get_metadata()] [Cache miss cost] Cache misses trigger BCS deserialization - can attackers craft workloads that maximize cache misses to cause gas cost spikes? (Medium)",
  "[File: aptos-core/types/src/vm/module_metadata.rs] [Function: get_randomness_annotation_for_entry_function()] [Metadata lookup overhead] Function performs multiple map lookups - does this gas cost get properly accounted in transaction execution? (\n\n### Citations\n\n**File:** types/src/vm/module_metadata.rs (L1-799)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    on_chain_config::{FeatureFlag, Features},\n    transaction::{AbortInfo, EntryFunction},\n    vm::code::CompiledCodeMetadata,\n};\nuse lru::LruCache;\nuse move_binary_format::{\n    access::ModuleAccess,\n    file_format::{\n        FunctionDefinition, FunctionHandle, IdentifierIndex, SignatureToken, StructDefinition,\n        StructFieldInformation, StructHandle, TableIndex,\n    },\n    CompiledModule,\n};\nuse move_core_types::{\n    ability::{Ability, AbilitySet},\n    errmap::ErrorDescription,\n    identifier::{IdentStr, Identifier},\n    language_storage::{ModuleId, StructTag},\n    metadata::Metadata,\n};\nuse move_model::{\n    metadata::{CompilationMetadata, COMPILATION_METADATA_KEY},\n    model::StructEnv,\n};\nuse serde::{Deserialize, Serialize};\nuse std::{cell::RefCell, collections::BTreeMap, env, num::NonZeroUsize, str::FromStr, sync::Arc};\nuse thiserror::Error;\n\npub mod prelude {\n    pub use crate::vm::module_metadata::{\n        get_compilation_metadata, get_metadata_from_compiled_code, RuntimeModuleMetadataV1,\n    };\n}\n\n/// The minimal file format version from which the V1 metadata is supported\npub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;\n\n// For measuring complexity of a CompiledModule w.r.t. to metadata evaluation.\n// This is for the size of types.\n/// Cost of one node in a type.\nconst NODE_COST: usize = 10;\n/// Cost of one character in the name of struct referred from a type node.\nconst IDENT_CHAR_COST: usize = 1;\n/// Overall budget for module complexity, calibrated via tests\nconst COMPLEXITY_BUDGET: usize = 200000000;\n\n/// The keys used to identify the metadata in the metadata section of the module bytecode.\n/// This is more or less arbitrary, besides we should use some unique key to identify\n/// Aptos specific metadata (`aptos::` here).\npub static APTOS_METADATA_KEY: &[u8] ="
]