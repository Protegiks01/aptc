[
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Collection name manipulation] Since collection_name is used in hash calculation but also stored separately (lines 125-126), can attackers exploit truncation differences between the two to create collections with identical hashes but different displayed names? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Struct: CollectionData] [Text field DoS] Can the unbounded description Text field (line 33) be exploited to insert gigabytes of data, causing database bloat and query timeouts that make collection metadata inaccessible? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Mutability bypass] Can mutability_config flags (lines 138-140) be flipped after initial collection creation to bypass immutability promises, allowing creators to rug-pull by changing metadata post-mint? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Historical mutability tracking] When maximum_mutable, uri_mutable, or description_mutable change between transactions, does the historical collection_datas table properly track these changes, or can attackers hide evidence of mutability abuse? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Mutability state desync] If mutability flags differ between CollectionData (line 138-140) and CurrentCollectionData (lines 152-154) due to race conditions, can this cause inconsistent mutability enforcement across indexer queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Version ordering attack] Can out-of-order transaction processing cause collection_datas entries with higher transaction_version to be inserted before lower versions, corrupting the historical timeline of collection evolution? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Current state rollback] If CurrentCollectionData is updated with an older transaction_version due to processing delays, can this cause permanent rollback of collection state to outdated supply/metadata values? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Struct: CurrentCollectionData] [Last version tracking] Does last_transaction_version at line 58 properly enforce monotonic increases, or can attackers submit multiple updates with the same version to create ambiguous current state? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Timestamp manipulation] Can txn_timestamp at lines 88, 142, 157 be manipulated to show backdated or future-dated collection creation, breaking temporal ordering in NFT marketplaces and analytics? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: get_by_table_handle()] [SQL injection] Can special characters in table_handle parameter at line 192 be exploited for SQL injection despite Diesel's parameterization, especially if table_handle contains apostrophes or SQL keywords? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: get_by_table_handle()] [Query performance] Can an attacker deliberately query with non-indexed table_handle values to cause full table scans, creating database performance degradation that slows all indexer operations? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: get_collection_creator()] [Database connection exhaustion] If get_collection_creator() retries consume database connections without proper timeout, can concurrent calls exhaust the connection pool and cause total indexer failure? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: get_by_table_handle()] [First() ambiguity] Does first::<Self>(conn) at line 193 properly handle cases where multiple rows match due to data corruption, or can this return arbitrary creator addresses? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Table handle collision] Can two different collections share the same table_handle value at line 103, causing creator_address lookups to return wrong owners and enabling collection ownership hijacking? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Table handle validation] Is table_handle format validated before use at line 103, or can malformed handles (empty string, special chars) bypass security checks and corrupt table_handle_to_owner mappings? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Table metadata poisoning] Can attackers manipulate table_handle_to_owner map to return malicious owner_address at line 106, allowing them to claim ownership of collections they don't control? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Missing table handle] When table_handle_to_owner.get() returns None at line 104 for legitimate collections, does forced database lookup at line 109 introduce unnecessary latency that can be exploited for targeted DoS? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [BCS deserialization attack] Can malicious BCS-encoded CollectionData in table_item_data.value at line 96 exploit deserialization vulnerabilities to inject arbitrary data into supply, maximum, or mutability fields? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Type confusion] If TokenWriteSet::from_table_item_type() at line 94 misidentifies data type, can non-CollectionData be parsed as CollectionData, corrupting indexer state with invalid collection metadata? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Deserialization DoS] Can extremely nested or malformed BCS data in value_type cause TokenWriteSet::from_table_item_type() to consume excessive CPU/memory, creating indexer processing bottlenecks? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Memory exhaustion] Can attackers create collections with extremely long names (before truncation) or descriptions that consume excessive memory during CollectionDataIdType creation at line 122-123? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: from_write_table_item()] [Clone overhead] Do the multiple clone() operations at lines 106, 123, 125, 126, 130-149 create performance bottlenecks when processing high-volume NFT transactions that could cause indexer lag? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Function: get_collection_creator()] [Sleep accumulation] Can the std::thread::sleep() at line 178 accumulate to significant delays when many collections are missing from table_handle_to_owner, causing indexer to fall behind blockchain state? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Struct: CollectionData] [Primary key violation] Can concurrent insertions of the same (collection_data_id_hash, transaction_version) pair cause primary key constraint violations that corrupt the indexer database state? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/collection_datas.rs] [Struct: CurrentCollectionData] [Unique constraint bypass] Can race conditions allow multiple CurrentCollectionData entries with same collection_data_id_hash to exist temporarily, causing ambiguous current collection state? (High)"
]