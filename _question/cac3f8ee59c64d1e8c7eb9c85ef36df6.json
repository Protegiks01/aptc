[
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: BytesSender] [Buffer Overflow] Lines 45-53 in bytes_sender.rs extend buffer without max size check - can an attacker trigger scenarios where buffer grows beyond TARGET_BATCH_SIZE without flushing, causing heap exhaustion and OOM crashes? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: send_size_prefixed_bcs_bytes] [Integer Truncation] Lines 55-67 in bytes_sender.rs cast record_bytes.len() to u32 - can an attacker provide records larger than 4GB to cause size truncation, where the prefix says size=100MB but actual data is 5GB, breaking deserialization and corrupting restored state? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Iterator Drop Safety] Lines 53-55 chain try_for_each on iterator - if the iterator panics mid-iteration, can cleanup handlers fail to execute, leaving database locks held and corrupting subsequent backup operations? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Stream Backpressure] Lines 106-109 iterate without backpressure control - can a slow consumer cause unbounded buffering in BytesSender, exhausting memory as the producer keeps generating transaction data faster than network transmission? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: flush_buffer] [Partial Flush] Lines 69-74 in bytes_sender.rs split buffer and freeze - if the MPSC channel is full, can blocking_send deadlock while holding the partial buffer, causing later sends to fail and corrupting the output stream? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bytes_sender] [Task Panic Handling] Lines 59-63 in utils.rs spawn task and ignore join_handle - if the spawned task panics, can the error be silently swallowed while the client waits indefinitely for data, creating ghost connections that leak resources? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bcs_bytes] [Serialization DOS] Lines 36-45 in utils.rs serialize arbitrary records with bcs::to_bytes - can an attacker trigger serialization of deeply nested structures causing stack overflow in BCS encoder, crashing the service? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: send_size_prefixed_bcs_bytes] [BCS Bomb] Lines 59 in bytes_sender.rs serialize record without size limits - can an attacker craft state records that expand exponentially during BCS serialization (zip bomb equivalent), consuming all available memory? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: db_state endpoint] [Deserialization Attack] Lines 32 serialize DbState with BCS - if DbState contains untrusted data from ledger metadata, can malicious validators insert crafted DbState that causes downstream BCS deserialization to panic or execute arbitrary code? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Type Confusion] Lines 54 serialize StateKey/StateValue pairs - can type confusion between Move resource types cause BCS to serialize a Coin<AptosCoin> as Coin<FakeCoin>, enabling backup consumers to mint unlimited tokens during restoration? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Metrics Poisoning] Lines 140-146 record latency in LATENCY_HISTOGRAM - can an attacker send requests that hang indefinitely to skew metrics with elapsed times of days/weeks, poisoning monitoring systems and hiding real performance degradation? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bcs_bytes] [Counter Overflow] Lines 41-43 in utils.rs increment THROUGHPUT_COUNTER - can an attacker send massive requests to overflow the counter (if it's not properly atomic), causing counter wraps that break monitoring, alerting, and rate limiting based on metrics? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Endpoint Enumeration] Lines 126-135 define all route paths - can an attacker enumerate these endpoints to build a complete map of available backup operations, identifying the most valuable targets for exfiltration or the most vulnerable to DoS? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: custom log handler] [Log Injection] Lines 140-146 log info.path() without sanitization - can an attacker inject newlines or ANSI escape codes into paths to corrupt logs, hide attack traces, or trigger log processing vulnerabilities? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [HTTP Method Confusion] Lines 138 explicitly filters to GET only - can an attacker bypass this filter using HTTP verb tampering (GETâ†’POST via X-HTTP-Method-Override header) to trigger unintended behavior if backend handlers process other methods? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bytes_sender] [Response Splitting] Lines 65 in utils.rs create Response without header validation - can an attacker inject malicious data into the response stream that includes CRLF sequences, enabling HTTP response splitting attacks against backup clients? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: all endpoints] [Connection Hijacking] All endpoints return boxed Reply without TLS enforcement - can a man-in-the-middle attacker intercept backup responses to steal state data, then modify and replay them to backup clients, causing restoration of attacker-controlled state? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Route Confusion] Lines 126-135 OR together all routes - can overlapping path patterns cause warp router to match ambiguous requests to wrong handlers, like /state_snapshot/123 matching both state_snapshot and state_snapshot_chunk? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: BytesSender] [Memory Leak] Lines 32 in bytes_sender.rs create channel with MAX_BATCHES=100 - if sender panics before calling finish() or abort(), can buffered messages leak permanently, accumulating until the process runs out of memory? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Iterator Lifetime] Lines 52-55 pass iterator to closure - can the iterator hold references to database state that outlive transaction snapshots, causing use-after-free if the database reclaims the memory? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bytes_sender] [Arc Leak] Lines 58 in utils.rs clone BackupHandler (which is Arc-based) - can unclosed streams prevent BackupHandler from being dropped, leaking database connections and eventually exhausting connection pool? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Unbounded Allocation] Lines 106-109 iterate over num_transactions without pagination - can requesting millions of transactions cause allocation of gigabytes of contiguous memory for WriteSet/Events, triggering OOM even with memory limits due to fragmentation? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot + transaction_range_proof] [Backup Integrity] Combining snapshots from lines 50-57 with proofs from lines 115-123 - can an attacker mix-and-match snapshots and proofs from different versions to create backups that pass proof verification but represent impossible blockchain states, causing divergence on restoration? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk] [Chunked Backup Attack] Lines 73-79 allow arbitrary chunk requests - can an attacker request overlapping chunks (chunk1: idx 0-1000, chunk2: idx 500-1500) to detect if state changes occurred between requests, timing their attack to occur during validator rotations when state is most vulnerable? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos] [Epoch Replay Attack] Lines 93-100 return historical epoch endings - can an attacker collect epoch ending ledger infos from ancient epochs, then replay them during a new epoch transition to confuse backup restoration logic and cause validators to accept outdated validator sets? (High)"
]