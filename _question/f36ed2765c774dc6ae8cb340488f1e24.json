[
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Input Validation] Does the new() constructor validate that the keys, values, and types vectors have matching lengths, or can an attacker create a MutateTokenPropertyMapEvent with mismatched vector lengths causing indexing errors and potential crashes when processing events? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Resource Exhaustion] Can an attacker call new() with unbounded vector sizes (keys, values, types) to cause memory exhaustion attacks during event creation, potentially causing validator nodes to OOM crash and disrupting consensus? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [State Consistency] Does new() validate that old_id and new_id are different TokenIds, or can an attacker create events where old_id equals new_id, violating the mutation semantics and causing state corruption in token indexers? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Token ID Manipulation] Can an attacker craft a MutateTokenPropertyMapEvent where old_id references a token they don't own but new_id references a token they do own, potentially stealing token properties or bypassing ownership checks? (Critical)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Duplicate Keys] Does new() check for duplicate keys in the keys vector, or can an attacker provide duplicate property keys causing undefined behavior when the property map is applied, potentially overwriting security-critical properties? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Empty Vectors] Can new() be called with empty keys/values/types vectors, creating a no-op mutation event that could be used to inflate event counts, cause gas manipulation, or bypass validation logic expecting non-empty property changes? (Low)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [String Validation] Does new() validate that keys and types contain valid UTF-8 strings without null bytes or control characters that could cause injection attacks in downstream event processors or APIs? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Type String Parsing] Are the type strings in the types vector validated to be legitimate Move type identifiers, or can an attacker inject malicious type strings causing type confusion when deserializing property values? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Value Size Limits] Does new() enforce maximum size limits on individual values in the Vec<Vec<u8>> values field to prevent attackers from creating single enormous property values causing memory exhaustion? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new()] [Token Existence] Does new() validate that both old_id and new_id reference existing tokens in the blockchain state, or can attackers create events for non-existent tokens causing indexing inconsistencies? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [BCS Deserialization] Can an attacker craft malicious BCS-encoded bytes that exploit vulnerabilities in bcs::from_bytes() to cause integer overflows, buffer overflows, or arbitrary memory corruption when deserializing MutateTokenPropertyMapEvent? (Critical)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Vector Length Attack] Can an attacker provide BCS bytes claiming extremely large vector lengths for keys/values/types that cause allocation of gigabytes of memory before actual data is read, leading to OOM kills of validator nodes? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Nested Vector Depth] Can an attacker exploit the Vec<Vec<u8>> structure in the values field to create deeply nested or circular BCS structures causing stack overflow during recursive deserialization? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Length Mismatch Exploitation] Can an attacker provide BCS bytes where the decoded keys, values, and types vectors have mismatched lengths, and does try_from_bytes() validate this before constructing the struct? (High)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [TokenId Deserialization] Can malicious BCS encoding of the old_id or new_id TokenId fields cause deserialization errors that are improperly handled, leading to partial state updates or undefined behavior? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Invalid UTF-8] Does try_from_bytes() validate that deserialized String values in keys and types are valid UTF-8, or can attackers inject invalid UTF-8 causing panics in downstream string processing? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Trailing Bytes] Does BCS deserialization check for trailing bytes after the MutateTokenPropertyMapEvent structure, or can attackers append additional data that gets silently ignored, potentially bypassing signature validation? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Error Handling] Does try_from_bytes() properly propagate all deserialization errors without exposing sensitive memory contents in error messages that could leak validator state information? (Low)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Deterministic Deserialization] Is BCS deserialization deterministic across all validator nodes regardless of architecture, or could differences in deserialization lead to consensus divergence when processing events? (Critical)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: try_from_bytes()] [Integer Overflow] Can the BCS deserialization of vector lengths cause integer overflows in memory allocation calculations, potentially leading to heap corruption or exploitable memory safety violations? (Critical)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: old_id()] [Reference Exposure] Does returning a reference to old_id allow callers to hold references across mutations, potentially causing use-after-free vulnerabilities if the event struct is moved or modified? (Low)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: new_id()] [TokenId Mutation] Could concurrent access to new_id() while the event is being processed lead to race conditions where the TokenId is read in an inconsistent state? (Low)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: keys()] [Vector Aliasing] Does returning a reference to the keys vector allow attackers to exploit interior mutability patterns to modify keys after validation but before processing? (Medium)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: values()] [Raw Bytes Exposure] Does exposing the raw Vec<Vec<u8>> values allow attackers to observe sensitive data that should be type-checked first, potentially leaking private token metadata? (Low)",
  "[File: aptos-core/types/src/account_config/events/mutate_token_property_map_event.rs] [Function: types()] [Type String Leakage] Can accessing types() reveal implementation details about the Move VM's type system that could be exploited in other attacks against type safety? (Low)"
]