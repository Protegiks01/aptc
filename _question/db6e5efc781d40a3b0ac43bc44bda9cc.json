[
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Invariant Loss] Can the transpose operation silently drop invariants from entrypoint_assumptions if multiple inv_rel.insts entries have conflicting data, causing critical safety invariants to be missing from verification? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Data Corruption] Does the extend() operation in transpose() properly handle duplicate invariant instantiations, or could malformed PerFunctionRelevance data cause invariants to be duplicated, leading to incorrect verification results? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Type Confusion] Can the transpose operation mix up type instantiations between different invariants sharing the same GlobalId, causing invariant checks to be applied with wrong type parameters and accepting invalid code? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Memory Safety] If inv_rel.insts.values() returns references to large BTreeSets and they are cloned multiple times during transpose, could this cause excessive memory allocation leading to OOM crashes during verification of large contracts? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Code Offset Collision] Can malicious bytecode manipulation cause multiple per_bytecode_assertions entries to map to the same code_offset, causing invariants for different bytecode instructions to overwrite each other? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: InstrumentationPack::transpose()] [Ghost Parameter Overflow] Is the ghost_type_param_count properly validated during transpose, or could a malicious module with excessive type parameters cause integer overflow when setting this field? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: GlobalInvariantInstrumentationProcessor::process()] [Verification Bypass] Can an attacker mark a function as native or intrinsic to bypass invariant instrumentation entirely, allowing unverified code with safety violations to execute on-chain? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: GlobalInvariantInstrumentationProcessor::process()] [Variant Confusion] Does the check for data.variant.is_verified() properly distinguish between all verification flavors, or could a function with FunctionVariant::Verification(VerificationFlavor::Instantiated) bypass instrumentation despite needing invariant checks? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: GlobalInvariantInstrumentationProcessor::process()] [Analysis Race Condition] If global_invariant_analysis::get_info() returns stale or incomplete analysis data due to concurrent processing, could invariants be missing from instrumented bytecode? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: GlobalInvariantInstrumentationProcessor::process()] [Null Analysis Result] What happens if global_invariant_analysis::get_info() returns a PerFunctionRelevance with empty invariant maps - does the instrumenter handle this gracefully or could it skip necessary invariant checks? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: GlobalInvariantInstrumentationProcessor::process()] [Debug Assert Bypass] The debug_assert! on line 126-129 only checks in debug builds - could release builds accept non-Regular verification variants, causing instrumentation to be applied incorrectly? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Code Reordering Attack] Can the bytecode reordering during instrumentation change the semantics of the original code, such as moving assertions before state-modifying operations that should execute first? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Invariant Ordering] Are entrypoint assumptions emitted before all other bytecode instructions, or could race conditions cause assumptions to be placed after operations that depend on them, accepting invalid states? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Update Invariant State Snapshot Missing] For update invariants that use old() expressions, if emit_state_saves_for_update_invs() is not called at the right point, could the old state be missing, causing incorrect invariant evaluation? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [OpaqueCallBegin Matching Failure] In the reverse loop (lines 186-196) searching for OpaqueCallBegin, if no matching begin is found for an OpaqueCallEnd, does the code fail silently or emit incorrect assertions without proper state snapshots? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Integer Underflow] The wrapping_sub(1) on line 186 and reverse iteration could underflow when code_offset is 0 - does this cause the loop to iterate over invalid memory or skip the matching logic entirely? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Nested Opaque Call Confusion] If OpaqueCallBegin/End pairs are nested, does the reverse search correctly match the innermost pair, or could it match an outer pair, causing state snapshots to be placed at the wrong location? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Return Statement Bypass] Are all return bytecode variants (Ret, Branch with return, Abort) properly detected on line 228, or could some exit paths skip exitpoint assertion emission? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Assertion Before Return] When assertions are placed before Ret bytecode (line 229), if the assertion fails, does the function return occur anyway due to incorrect bytecode ordering? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Double Instrumentation] For OpaqueCallEnd, the code skips pre-instrumentation if xlated_for_opaque_end.contains_key (line 222) - could logic errors cause state saves to be emitted twice, or not at all? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Ghost Type Param Override] When overriding ghost_type_param_count on line 242, is the old value properly discarded, or could stale ghost parameters from previous instrumentation passes persist? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Code Offset Skew] After inserting multiple assert/assume bytecodes, do code offsets stored in xlated_inlined remain valid, or do they become stale and point to wrong instructions? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::instrument()] [Memory Usage DoS] If a function has thousands of bytecode instructions each requiring multiple invariant assertions, could the instrumented code grow exponentially, causing memory exhaustion during verification? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::translate_invariants()] [Invalid GlobalId] If invs_with_insts contains a GlobalId that doesn't exist in the global environment, does SpecTranslator::translate_invariants_by_id fail gracefully or panic, causing prover crashes? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/global_invariant_instrumentation.rs] [Function: Instrumenter::translate_invariants()] [Type Instantiation Mismatch] Can mismatched type instantiations in inv_insts cause SpecTranslator to generate incorrect invariant expressions that accept invalid states? (Critical)"
]