[
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: new()] [Integer overflow] Can an attacker cause integer overflow or wraparound by passing usize::MAX or extremely large capacity values to new(), potentially bypassing concurrency limits and causing resource exhaustion in validators? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: new()] [Zero capacity DoS] What happens if capacity=0 is passed to new()? Will all spawn() calls block forever, causing complete validator liveness failure and network halt? (Critical)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: new()] [Memory exhaustion] Can an attacker create multiple BoundedExecutor instances with extremely large capacity values, exhausting validator memory through semaphore allocation before tasks are even spawned? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Struct: BoundedExecutor] [Clone semantics] Since BoundedExecutor implements Clone via #[derive(Clone)], do all cloned instances share the same Arc<Semaphore>, and can this lead to unexpected capacity sharing across supposedly independent executors? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: new()] [Handle validity] Is there validation that the provided tokio Handle is valid and not from a shutdown runtime? Could invalid handles cause panics during critical consensus operations? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: acquire_permit()] [Unwrap panic] The function uses .unwrap() on acquire_owned().await - can semaphore.acquire_owned() ever return an Err causing panic and validator crash? What if the semaphore is closed or in an invalid state? (Critical)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: acquire_permit()] [Semaphore poisoning] If one task panics while holding a permit, does the semaphore get poisoned or corrupted, preventing future permit acquisitions and causing validator deadlock? (Critical)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: acquire_permit()] [Cancellation safety] If the acquire_permit().await is cancelled (e.g., timeout or task abort), is there a permit leak where the semaphore counter is decremented but the permit is never returned? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_acquire_permit()] [Error handling] Using .ok() silently discards the error from try_acquire_owned() - could this hide critical semaphore corruption errors that should halt the validator? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: acquire_permit()] [Fairness] Does acquire_owned() guarantee FIFO ordering, or can malicious tasks starve legitimate consensus/execution tasks by repeatedly acquiring permits? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn()] [Async cancellation] If spawn() is cancelled after acquiring a permit but before executor.spawn() is called, does the permit leak, permanently reducing available capacity and eventually causing DoS? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn()] [Panic propagation] If the tokio executor.spawn() panics, is the acquired permit properly released, or does it leak causing gradual capacity degradation? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn()] [Resource exhaustion] Can an attacker flood spawn() calls with never-completing futures that hold permits indefinitely, exhausting executor capacity and blocking critical validator operations? (Critical)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn()] [JoinHandle abandonment] If the returned JoinHandle is dropped without awaiting, does the spawned task continue holding the permit until completion, or is there early permit release? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn()] [Ordering guarantees] Are there ordering guarantees between spawn() calls? Could reordering of spawned consensus tasks lead to safety violations like out-of-order block processing? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_spawn()] [Race condition] Is there a TOCTOU race between try_acquire_permit() and executor.spawn() where the runtime could be shutdown, causing spawn to fail after permit acquisition? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_spawn()] [Error path leak] If executor.spawn() succeeds but returns a JoinHandle for a task that immediately panics, is the permit properly released via future_with_permit? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_spawn()] [Capacity starvation] Can Byzantine validators deliberately use try_spawn() in tight loops to monopolize executor capacity, preventing honest validators from spawning critical consensus tasks? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_spawn()] [Return value handling] If try_spawn returns Err(future), is the caller responsible for retrying? Could improper caller handling lead to silently dropped critical tasks? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn_blocking()] [Thread exhaustion] Can spawn_blocking() exhaust tokio's blocking thread pool separately from the semaphore capacity, causing validator deadlock when blocking threads are unavailable? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn_blocking()] [Panic in closure] If func() panics inside spawn_blocking(), is the permit properly released by function_with_permit, or could unwinding bypass the drop() call? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn_blocking()] [Async context mixing] If spawn_blocking() is used for async operations or calls .await internally, could this cause deadlocks with the bounded executor's async tasks? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: try_spawn_blocking()] [Synchronous blocking] Does spawn_blocking() account for CPU-bound vs I/O-bound tasks differently? Could CPU-intensive cryptographic operations block progress of async tasks? (Medium)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: spawn_blocking()] [Permit timing] Is the permit held during the entire execution of the blocking function, or could long-running blocking operations starve async tasks from permits? (High)",
  "[File: aptos-core/crates/bounded-executor/src/executor.rs] [Function: future_with_permit()] [Drop order] The permit is dropped inside future.map() - does this guarantee the permit is released before the future's output is consumed, or could there be a use-after-free if output contains references? (Medium)"
]