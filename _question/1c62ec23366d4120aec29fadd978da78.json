[
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Deserialization attack] Can an attacker provide a maliciously crafted bytecode file that exploits CompiledModule::deserialize() to cause memory corruption, arbitrary code execution, or crash the decompiler when processing line 121, potentially affecting validator nodes running decompilation tools? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Deserialization attack] Can an attacker craft a CompiledScript with malformed internal structures that bypass deserialization checks at line 116-117, allowing invalid bytecode to be processed and potentially causing downstream security issues in the Move VM? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: get_source_map()] [Deserialization attack] Can an attacker provide a malicious source map file that exploits bcs::from_bytes::<SourceMap>() at line 145 to cause buffer overflows, integer overflows, or arbitrary memory access during deserialization? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: get_source_map()] [Unsafe deserialization] Does the unwrap_or_else at line 146 properly handle all deserialization failures, or can a partially deserialized malicious SourceMap leak sensitive memory contents or cause use-after-free vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Type confusion] Can an attacker provide bytecode that deserializes successfully as CompiledModule but contains type confusion vulnerabilities that manifest during subsequent processing stages, bypassing Move's type safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Path traversal] Can an attacker exploit the file path handling at lines 110-112 where file_name() and unwrap_or_default() are used to perform directory traversal attacks by providing inputs like '../../../etc/passwd' in the bytecode metadata? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Arbitrary file write] Can an attacker control the output_dir and ending options to write decompiled output to arbitrary system locations at lines 131-135, potentially overwriting critical system files or injecting malicious code into sensitive directories? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Symlink attack] Does the fs::write operation at line 134 follow symbolic links, allowing an attacker to create a symlink at the output location to redirect writes to privileged files or directories? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: get_source_map()] [Path traversal] Can an attacker manipulate the input_file parameter to exploit the path construction at lines 141-143 to read arbitrary files outside the intended source_map_dir through path traversal sequences? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: get_source_map()] [Information disclosure] Does the fs::read at line 144 properly validate permissions and prevent reading sensitive system files when an attacker provides crafted file paths through the source map directory? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [TOCTOU race] Is there a time-of-check-time-of-use race condition between checking the output file path at line 131 and writing at line 134, where an attacker could swap the target file with a symlink to a privileged location? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: validate_module()] [Verification bypass] Can an attacker craft bytecode that passes move_bytecode_verifier::verify_module() at line 221 but contains malicious logic that exploits vulnerabilities in subsequent processing stages, effectively bypassing security checks? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: load_module()] [Validation timing] Is validate_module() called at line 186 before any processing that could be exploited, or can an attacker trigger operations on unvalidated bytecode between deserialization and validation? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: validate_module()] [Error handling] Does the error formatting at line 222 leak sensitive information about bytecode verification internals that could help attackers craft bypasses for the Move bytecode verifier? (Low)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: decompile_package()] [Batch validation] Are all modules in the batch properly validated at lines 160-162, or can an attacker sneak invalid bytecode into a package by exploiting ordering or dependency resolution issues? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: load_module()] [Dependency loading] Does the with_dep_closure=true parameter at line 189 securely load all dependencies, or can an attacker provide a module with malicious dependencies that bypass validation or introduce vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Infinite loop] Can an attacker craft bytecode that causes the transformation loop at lines 252-264 to never reach a fixed point, resulting in an infinite loop that exhausts CPU and memory resources, causing denial of service? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Resource exhaustion] Can an attacker provide bytecode with deeply nested control flow structures that cause exponential growth in AST size during the iterative transformations at lines 254-263, leading to memory exhaustion? (High)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Quadratic complexity] Does the repeated cloning at lines 246, 253 create quadratic or exponential time complexity for pathological bytecode inputs, allowing an attacker to cause severe performance degradation with relatively small inputs? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [Memory exhaustion] Can an attacker provide extremely large bytecode files that consume excessive memory during deserialization at lines 113-122, potentially causing out-of-memory conditions on validator nodes? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: decompile_package()] [Batch DoS] Can an attacker provide a package with thousands of modules to exploit the unbounded iteration at lines 160-166, causing resource exhaustion through processing of excessive module counts? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Stack overflow] Can deeply nested bytecode structures cause stack overflow during recursive AST transformation calls, particularly in astifier functions invoked at lines 255, 258, and 266? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: run()] [File size DoS] Is there any limit on the size of input files read by fs::read at line 113, or can an attacker provide multi-gigabyte bytecode files to exhaust disk I/O and memory? (Low)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Semantic divergence] Can an attacker craft bytecode where the AST transformations at lines 254-266 produce decompiled source code that has different semantics from the original bytecode, misleading auditors about the actual on-chain behavior? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-decompiler/src/lib.rs] [Function: lift_to_ast()] [Conditional transformation bug] Can the transform_conditionals function at line 258 incorrectly reconstruct if/match statements from bytecode, producing logically different control flow that hides malicious behavior during audits? (High)"
]