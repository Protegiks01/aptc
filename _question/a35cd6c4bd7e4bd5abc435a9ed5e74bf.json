[
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Race condition] In the run_after() function, the mutex is locked at line 35 and released implicitly at line 58 - can concurrent calls to run_after() and update_auto_advance_limit() create a race condition where tasks are executed in non-deterministic order, causing test flakiness that masks consensus timing bugs? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Mutex poisoning] If the task.run() call at line 57 panics within the futures::executor::block_on(), does this poison the Mutex and cause all subsequent time service operations to fail, potentially masking critical consensus test failures? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: sleep()] [Race condition] The sleep() function clones the Arc at line 68, locks it at line 69, and modifies inner.now - can concurrent calls to sleep() from multiple threads cause time to advance non-atomically, violating the TimeService contract that time should increase by at least the sleep duration? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: get_current_timestamp()] [TOCTOU] The get_current_timestamp() function returns a snapshot of 'now' at line 64 - can a race condition occur where a caller reads the timestamp, another thread advances time via sleep(), and the caller's timeout calculation becomes stale, leading to incorrect consensus timeout behavior in tests? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Deadlock risk] The update_auto_advance_limit() function holds the mutex lock from line 112 through line 127 while executing tasks via block_on() - if any executed task tries to call back into the time service (e.g., scheduling another task), would this cause a deadlock since the mutex is already held? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Struct: SimulatedTimeServiceInner] [Memory ordering] The SimulatedTimeServiceInner fields are protected by a standard Mutex but not atomic - could weak memory ordering on multi-core systems cause one thread to see stale values of 'now' or 'time_limit' even after another thread has updated them, breaking time monotonicity guarantees? (Low)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Time inconsistency] In run_after() at lines 38-52, when deadline <= time_limit, inner.now is set to deadline - but if multiple tasks have different deadlines and execute in sequence, can this cause time to jump backwards if tasks are not executed in strictly ascending deadline order? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Integer overflow] At line 37, the deadline is calculated as 'now + timeout' - can providing a timeout of Duration::from_secs(u64::MAX) cause an integer overflow in Duration addition, resulting in a deadline that wraps around to a very small value and causes immediate task execution when it should be deferred? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Max clamping bypass] Lines 53-55 clamp inner.now to inner.max if exceeded - but this happens AFTER setting inner.now = deadline, meaning tasks scheduled beyond max will still update 'now' to the clamped value - can this allow an attacker to artificially advance time to the maximum by scheduling tasks with very large timeouts? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: sleep()] [Unclamped time advance] The sleep() function at line 70 directly adds 't' to inner.now without checking if the addition would overflow - can calling sleep(Duration::from_secs(u64::MAX)) cause a panic or wrap-around, breaking time monotonicity in consensus tests? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: sleep()] [Max enforcement inconsistency] Lines 71-73 clamp inner.now to inner.max AFTER the addition - can this lead to time appearing to advance beyond max temporarily in a multithreaded scenario where another thread reads the timestamp between lines 70 and 72? (Low)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Time limit overflow] At line 113, the time_limit is incremented via 'inner.time_limit += time' - can repeatedly calling this with large Duration values cause time_limit to overflow past u64::MAX and wrap to a small value, causing all pending tasks to suddenly become executable? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Task ordering violation] Lines 117-124 iterate through pending tasks and remove those with deadline <= time_limit, but the tasks are stored in an unsorted Vec - does this mean tasks could be executed out of deadline order, violating the expected time service semantics and masking consensus timing bugs? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: new()] [Max value edge case] The new() constructor initializes max to Duration::from_secs(u64::MAX) at line 91 - can this cause issues when combined with the clamping logic in run_after() and sleep(), particularly if arithmetic operations on this maximum value cause overflow? (Low)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: auto_advance_until()] [Zero time_limit] The auto_advance_until() constructor accepts any Duration value for time_limit - what happens if time_limit is set to Duration::from_secs(0), would all tasks immediately execute regardless of their timeout, breaking test assumptions about timeout ordering? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Task execution failure] At line 57, task.run() is executed via futures::executor::block_on() - if the task's future panics or returns an error, is there any error handling, or will the panic propagate and potentially poison the mutex or crash the test without proper diagnostics? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Ignored AbortHandle] Lines 59-60 create an AbortHandle but never connect it to any actual abort mechanism - can tests that rely on aborting scheduled tasks fail because the abort does nothing, causing tasks to execute when they shouldn't and creating timing-related test failures? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Blocking executor deadlock] The futures::executor::block_on() at line 57 creates a nested executor context - if the ScheduledTask itself tries to await on another future that depends on the same time service, could this cause a deadlock or panic due to the nested block_on() call? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Task panic recovery] At line 127, task.run() is executed via block_on() - if a task panics, does the loop at lines 125-128 abort, leaving remaining tasks in the 'drain' vector unexecuted and potentially masking test failures? (High)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Vec removal inefficiency] The loop at lines 117-124 uses pending.remove(i) which is O(n) and shifts all subsequent elements - could this O(nÂ²) behavior cause performance issues in tests with many pending tasks, and more critically, could the shifting cause tasks to be skipped if indices become misaligned? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: run_after()] [Pending tasks memory leak] Tasks with deadlines > time_limit are added to the pending vector at line 45 but never removed unless update_auto_advance_limit() is called - in tests that create many SimulatedTimeService instances without advancing time, could this lead to unbounded memory growth as pending tasks accumulate? (Low)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: update_auto_advance_limit()] [Task execution order non-determinism] The drain vector at line 116 collects tasks in the order they appear in pending, not sorted by deadline - if multiple tasks have different deadlines but all are <= time_limit, they execute in pending vector order rather than deadline order, potentially causing non-deterministic test behavior? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: clone()] [Shared mutable state] The clone() implementation at lines 132-137 clones the Arc<Mutex<...>>, creating a new SimulatedTimeService that shares the same inner state - can this lead to unintended coupling between what tests expect to be independent time services, causing test pollution and non-deterministic failures? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Struct: SimulatedTimeService] [Clone semantics confusion] Since SimulatedTimeService clones by sharing the inner Arc, multiple clones will all see the same 'now' and pending tasks - could test code that expects isolated time services exhibit bugs when clones inadvertently share state, particularly in parallel test execution? (Medium)",
  "[File: aptos-core/consensus/src/util/mock_time_service.rs] [Function: clone()] [Pending tasks shared] When a SimulatedTimeService is cloned, the pending tasks vector is shared across all clones - if one clone calls update_auto_advance_limit() and drains pending tasks, do all other clones see those tasks disappear, potentially causing unexpected behavior in tests using multiple time service instances? (Medium)"
]