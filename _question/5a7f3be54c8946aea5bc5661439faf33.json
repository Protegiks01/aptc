[
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: All check_* functions] [PartialVMResult error aggregation] Can multiple validation errors be combined in ways that hide critical errors behind less severe ones? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [BinaryIndexedView aliasing] Can multiple references to resolver through self cause aliasing violations if resolver internally uses RefCell or UnsafeCell? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Field handle at bounds] Does resolver.field_handle_at() perform bounds checking, or can out-of-bounds FieldHandleIndex cause undefined behavior? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [Variant field handle at bounds] Does resolver.variant_field_handle_at() validate VariantFieldHandleIndex bounds before dereferencing? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Struct def at bounds] Can struct_def_index exceed the module's struct_defs table size, causing out-of-bounds access in resolver? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_op()] [Struct variant handle at bounds] Does resolver.struct_variant_handle_at() validate StructVariantHandleIndex before table access? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_function_op()] [Function handle at bounds] Can func_handle_index point outside valid function handle table, causing undefined behavior in resolver? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_closure_mask()] [Signature at bounds] Does resolver.signature_at() validate signature indices, or can invalid parameters cause crashes? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Generic substitution attack] Can an attacker craft generic type parameters that cause exponential type expansion, leading to resource exhaustion during type checking? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_function_op()] [Recursive generic types] Can generic function type parameters reference themselves recursively, causing infinite loops during type resolution? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_op()] [Generic variant type substitution] Can generic variants be instantiated with type arguments that violate capability constraints (copy, drop, store, key)? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Generic instantiation caching] If the resolver caches generic instantiations, can cache poisoning attacks cause incorrect type resolution for subsequent operations? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: verify_module() vs verify_script()] [Module-script verification inconsistency] Can bytecode that passes verify_script() fail verify_module() or vice versa, allowing cross-context exploitation? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: verify_module_impl()] [Module self_id manipulation] Can module.self_id() be manipulated to point to a different module, causing error messages to mislead about vulnerability location? (Low)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: verify_script_impl()] [Script code manipulation] Can script.code be modified after verification but before execution in a TOCTOU attack? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Global resource type confusion] Can MutBorrowGlobal/ImmBorrowGlobal be used with struct types that don't have 'key' capability, bypassing resource access control? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [MoveTo duplicate key] Can MoveTo be called multiple times for the same address and type within a transaction, creating duplicate resources? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [MoveFrom dangling reference] After MoveFrom, can references to the moved resource persist and be dereferenced, causing use-after-free? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Exists phantom check] Can Exists check be bypassed by quickly creating and destroying resources in between check and use? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [VecPack signed integer confusion] Although checked against u16::MAX, can negative values be passed as num through type confusion, causing underflow? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [VecUnpack mismatch] If VecUnpack num doesn't match actual vector length, can this cause stack corruption or incorrect type assumptions? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [VecPack type parameter bypass] Can VecPack be used with type parameters that violate Move's type system constraints (e.g., packing references)? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_closure_mask()] [Closure escape analysis] Does check_closure_mask() ensure captured variables don't outlive their scope, or can closures create dangling references? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [PackClosure mutable capture] Can PackClosure capture mutable references that violate Rust's borrow checker equivalent rules in Move? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [PackClosureGeneric type erasure] Can generic closures erase type information in ways that allow type confusion when the closure is called? (High)"
]