[
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: max_capacity()] [Immutability assumption] Does consensus assume max_capacity never changes after genesis, and can a governance upgrade violate this assumption by changing max_capacity mid-epoch, causing validators to use different modulo divisors and calculate different indices for the same event retrieval? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Atomicity violation] Are updates to next_idx and table writes atomic in the Move implementation, or can a validator crash between incrementing next_idx and writing the new event, leaving next_idx pointing to an empty table slot that causes consensus recovery failures? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [OnChainConfig trait] [Version mismatch] When consensus reads CommitHistoryResource at a specific ledger version, can concurrent block commits create a situation where the resource metadata (next_idx, length) is from a newer version than the actual table contents, causing index calculation to point to non-existent entries? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Recovery poisoning] Can Byzantine validators craft malicious NewBlockEvents with invalid hash/epoch/round values and insert them into CommitHistory, causing honest validators during recovery to accept fraudulent consensus history and fork the chain? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: next_idx()] [Index prediction] Can an attacker predict which table indices will be overwritten next based on next_idx, and selectively corrupt those specific entries just before they're needed for consensus recovery, maximizing disruption while minimizing on-chain evidence? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Event ordering] Does the circular buffer guarantee that events are retrieved in chronological order during consensus recovery, or can the wraparound behavior cause events to be read out of order (e.g., events 1900-2000, then 0-100) breaking temporal dependencies in consensus? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: length()] [Bounded history attack] If table.length never decreases (even as old events are overwritten), can it grow indefinitely until u64 overflow, causing consensus to attempt reading billions of events during recovery and triggering storage exhaustion DoS? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Epoch boundary] When epoch changes occur, does CommitHistory correctly handle events from multiple epochs in the circular buffer, or can consensus recovery be confused by mixing events from epoch N and N+1 leading to validator set mismatch errors? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: table_handle()] [Cross-epoch contamination] Can events from old epochs remain in the circular buffer after epoch change, and if consensus recovers using these stale events, will it use outdated validator sets for signature verification causing Byzantine behavior to go undetected? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Missing events] If next_idx advances but the corresponding table entry write fails (due to storage error or resource limit), will consensus encounter missing events during recovery and fail to reconstruct the correct commit history? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: max_capacity()] [Insufficient capacity] Is max_capacity=2000 sufficient for all recovery scenarios, or can a prolonged network partition where validators are down for >2000 blocks cause them to attempt recovery but find their required events have been overwritten, forcing a manual intervention? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Selective event deletion] Can Byzantine validators with governance privileges selectively delete specific historical events from the table while keeping next_idx/length unchanged, causing consensus recovery to fail when accessing those indices with 'Table item doesn't exist' errors? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [OnChainConfig trait] [State key collision] Can the state key for CommitHistoryResource collide with other on-chain configs, causing get_state_value_by_version to return wrong data that deserializes successfully but contains malicious values leading to consensus corruption? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Replay attack] Can old commit events be replayed by copying them from historical table slots to current slots, causing consensus to accept duplicate blocks with same hash/epoch/round that violate AptosBFT safety guarantees? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: next_idx()] [Race condition] If multiple validators simultaneously read next_idx during consensus recovery, can they get different values due to concurrent block commits, causing validators to fetch different sets of commit events and diverge in their recovery state? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [OnChainConfig trait] [Unauthorized reads] Does the OnChainConfig trait implementation restrict who can read CommitHistoryResource, or can any unprivileged account query this resource and use next_idx/max_capacity information to predict future table indices and pre-emptively corrupt them? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Governance bypass] Can non-governance transactions modify CommitHistoryResource fields directly through write set transactions or other privileged operations, bypassing normal access controls and injecting malicious commit history? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Direct table access] Can attackers directly access the underlying table through table_handle() and modify entries without going through the Move module's emit_new_block_event(), bypassing validation and inserting fraudulent commit events? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: max_capacity()] [Capacity reduction attack] Can a malicious governance proposal reduce max_capacity to 1, causing the circular buffer to overwrite events immediately and making consensus recovery impossible for any validator that's offline for >1 block? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [OnChainConfig trait] [Module identifier spoofing] Are MODULE_IDENTIFIER and TYPE_IDENTIFIER validated against the actual resource address, or can a malicious module claim to be 'block::CommitHistory' and inject fake resources that consensus reads as authoritative? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: CommitHistoryResource] [Initialization race] During genesis or initialize_commit_history(), can an attacker front-run the initialization transaction and create a CommitHistoryResource with malicious parameters (max_capacity=1, malicious table_handle) that gets used instead of the legitimate one? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Handle manipulation] Can the TableHandle be constructed with a handle value that points to storage outside the valid CommitHistory table range, causing consensus to read arbitrary on-chain state and interpret it as NewBlockEvents with crafted malicious content? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Method: table_handle()] [Reference safety] Does table_handle() return a reference to the internal TableHandle, and can this reference be used to bypass ownership rules and mutate the handle after CommitHistoryResource is created? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Handle uniqueness] Are TableHandles globally unique, or can two different CommitHistory instances (e.g., from different forks or test chains) share the same handle, causing consensus to read events from the wrong chain instance? (High)",
  "[File: aptos-core/types/src/on_chain_config/commit_history.rs] [Struct: TableWithLength] [Storage corruption] If the underlying storage layer corrupts table entries (bit flips, partial writes), will the BCS deserialization detect corruption and fail safely, or can it succeed with malformed NewBlockEvents that break consensus invariants? (High)"
]