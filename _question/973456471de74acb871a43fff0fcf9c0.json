[
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Input validation bypass] Can an attacker craft a protobuf BooleanTransactionFilter with malformed oneof fields that passes size validation but crashes during new_from_proto() parsing, causing indexer service denial of service? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Size limit bypass] Does max_filter_size_bytes properly account for nested recursive filters (And/Or/Not containing And/Or/Not), or can an attacker craft a deeply nested filter that exceeds memory limits despite passing encoded_len() check? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Protobuf bomb] Can an attacker exploit protobuf compression or nested structure to create a small encoded message that expands to massive size during deserialization, bypassing the max_filter_size_bytes check? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Integer overflow] Can max_filter_size_bytes parameter overflow when compared with proto_filter.encoded_len(), allowing arbitrarily large filters to pass validation? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Type confusion] Can an attacker send a BooleanTransactionFilter with an unset oneof field that passes through this validation but causes panic in new_from_proto() when it expects a valid filter variant? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Information disclosure] Does the error message format string on line 14 leak sensitive internal state or memory addresses when displaying the error from new_from_proto(), potentially aiding attackers in exploitation? (Low)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Error handling bypass] Can an attacker craft inputs that cause new_from_proto() to return Ok with an invalid filter state that passes validation but causes crashes during actual filtering operations? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Panic propagation] If BooleanTransactionFilter::new_from_proto() panics instead of returning an error, does this wrapper catch it or does it crash the entire gRPC service handling the request? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Race condition] Can concurrent calls to parse_transaction_filter() with different max_filter_size_bytes values cause inconsistent filter validation across multiple indexer streams? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Size calculation mismatch] Does proto_filter.encoded_len() accurately represent the actual memory consumption during parsing, or can recursive TryFrom conversions allocate significantly more memory than the encoded size suggests? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Default configuration vulnerability] Is max_filter_size_bytes set to a safe default value (10,000 bytes), or can this be misconfigured to allow excessively large filters that enable DoS attacks on indexer nodes? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Recursive depth attack] Since BooleanTransactionFilter supports nested LogicalAnd/Or/Not structures, can an attacker create filters with excessive recursion depth that cause stack overflow during new_from_proto() conversion despite passing size checks? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Filter complexity DoS] Can an attacker craft a filter with thousands of simple APIFilters combined with OR operations that passes size validation but takes exponential time to evaluate against transactions, causing indexer performance degradation? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Regex DoS] If EventFilter contains data_substring_filter with a malicious regex-like pattern, can it cause catastrophic backtracking during transaction matching despite passing parse_transaction_filter() validation? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Address normalization bypass] Can an attacker use non-standard address formats in UserTransactionFilter or MoveStructTagFilter that pass parsing but match incorrectly during standardize_address() conversion, bypassing intended filter logic? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Missing validation in service layer] Do HistoricalDataService and LiveDataService properly validate that parse_transaction_filter() returns Ok before using the filter, or can error paths leave uninitialized filter state? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Stream hijacking] Can an attacker send a malicious filter that passes validation but matches no transactions, causing legitimate streams to starve while attacker streams consume resources checking against empty result sets? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Authentication bypass] Is parse_transaction_filter() called before or after authentication checks in the gRPC services, allowing unauthenticated attackers to send malicious filters for reconnaissance? (Low)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Memory leak] Does BooleanTransactionFilter::new_from_proto() properly deallocate memory for OnceCell cached values and Finder instances on error paths, or can repeated malicious filter submissions cause memory leaks? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Clone overhead] When filters are cloned for concurrent stream processing, can the OnceCell and Finder caching lead to excessive memory duplication or cache poisoning across threads? (Low)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Protobuf version mismatch] Can version mismatches between the protobuf definition and the Rust types cause parse_transaction_filter() to accept filters with deprecated or unsupported fields that crash during matching? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [TryFrom panic] Do all TryFrom implementations for LogicalAnd, LogicalOr, LogicalNot, and APIFilter properly handle malformed protobuf data, or can they panic causing service crashes? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Enum variant exhaustion] If new filter types are added to the protobuf BooleanTransactionFilter oneof, will parse_transaction_filter() handle them gracefully or will unhandled variants cause silent filter bypasses? (Medium)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [LogicalNot double negation] Can an attacker create filters with nested NOT operations that cause logical inversions to cancel out incorrectly, allowing blocked transactions to pass through filters? (High)",
  "[File: ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs] [Function: parse_transaction_filter()] [Empty filter sets] Can LogicalAnd or LogicalOr filters with empty vec![  ] pass validation, and if so, do they match all transactions or none, potentially causing unintended data exposure? (High)"
]