[
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_neq()] [Duplicate logic] Are NEQ_BASE and EQ_BASE different values, and if not, can attackers optimize which comparison to use based on gas costs? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_eq()] [Early termination bypass] If equality checks short-circuit on first difference, can attackers pay full gas but consume minimal CPU for strategically crafted values? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_borrow_global()] [Success flag bypass] The _is_success parameter is unused - can failed borrow_global operations that should refund gas or cost less still charge full price? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_borrow_global()] [Type parameter bypass] The _ty parameter is unused - can borrowing massive resources cost the same as tiny ones since size isn't factored into gas? (High)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_borrow_global()] [Mut/generic mismatch] Can an attacker manipulate is_mut or is_generic flags to pay minimal IMM_BORROW_GLOBAL_BASE instead of proper MUT_BORROW_GLOBAL_GENERIC_BASE? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_exists()] [Exists bypass] The _exists parameter is unused - can checking existence of non-existent resources that require expensive database queries cost the same as cached exists? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_move_from()] [Resource size bypass] The _val parameter is unused - can moving massive resources from global storage cost the same as tiny ones, enabling cheap extraction of expensive data? (High)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_move_to()] [Success state exploitation] When _is_success is false due to resource already existing, is gas still charged for failed operations, or can attackers spam failed move_to calls cheaply? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_pack()] [Element count overflow] Can args.len() as u64 overflow when creating massive vectors, allowing packing of billions of elements for minimal VEC_PACK_PER_ELEM cost? (Critical)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_unpack()] [Expected vs actual mismatch] Can expect_num_elements be much smaller than actual _elems.len(), allowing attackers to pay gas for fewer elements than actually unpacked? (High)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_unpack()] [Element size bypass] Does VEC_UNPACK_PER_EXPECTED_ELEM account for individual element sizes, or can unpacking vectors of massive elements cost the same as tiny ones? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_len()] [Fixed cost exploit] VEC_LEN_BASE is fixed regardless of vector size - can querying lengths of extremely large vectors stored in memory be exploited for cheap profiling? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_borrow()] [Index bounds bypass] Are bounds checking costs included in VEC_IMM_BORROW_BASE/VEC_MUT_BORROW_BASE, or can out-of-bounds accesses trigger expensive error handling for minimal gas? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_push_back()] [Value size bypass] The _val parameter is unused - can pushing massive elements onto vectors cost the same as tiny ones, enabling cheap vector bloat? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_pop_back()] [None value exploit] When _val is None (pop from empty vector), is gas still charged for a failed operation that triggers error handling? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_vec_swap()] [Vector size bypass] VEC_SWAP_BASE is fixed - can swapping elements in massive vectors that require copying large amounts of memory cost the same as tiny vectors? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_drop_frame()] [Free cleanup exploit] This function returns Ok(()) - can dropping frames with thousands of locals containing massive values be done for free, encouraging wasteful stack usage? (Medium)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_drop_frame()] [Iterator bypass] The _locals iterator is unused - can attackers trigger frame drops with expensive destructor logic that isn't metered? (Low)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_create_ty()] [Feature version bypass] Can an attacker force feature_version() < 14 to skip type creation charging entirely, enabling unlimited type instantiation for free? (High)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_create_ty()] [Num nodes overflow] Can num_nodes overflow in SUBST_TY_PER_NODE * num_nodes calculation, allowing creation of types with billions of nodes for minimal gas? (Critical)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_create_ty()] [Recursive type bypass] Does num_nodes correctly count nodes in recursive or mutually recursive type definitions, or can unbounded type complexity be created cheaply? (High)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_storage_fee()] [Amount manipulation] Can the amount parameter be negative or overflow, allowing attackers to receive storage fee refunds instead of paying? (Critical)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_storage_fee()] [Gas unit price manipulation] Can gas_unit_price be set to zero or extremely small values, making storage fees negligible and enabling state bloat? (Critical)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_storage_fee()] [Determinism violation] Is storage fee calculation deterministic across all validators, or can floating-point or rounding differences cause consensus failures? (Critical)",
  "[File: aptos-core/aptos-move/aptos-gas-meter/src/meter.rs] [Function: charge_io_gas_for_transaction()] [Txn size overflow] Can txn_size overflow in io_gas_per_transaction calculation, wrapping to a small value and allowing massive transactions for minimal gas? (High)"
]