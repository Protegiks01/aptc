[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [INTERNAL_TYPE_ERROR bypass] Can non-struct TypeTag be returned from ty_to_ty_tag through malformed types, and is the error check sufficient? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [FAILED_TO_DESERIALIZE_RESOURCE handling] Does the error properly clean up partial state when deserialization fails, or can it leave corrupted entries? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: insert_resource()] [UNKNOWN_INVARIANT_VIOLATION_ERROR recovery] When this error occurs, can the cache continue operating or is it permanently corrupted? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: into_effects()] [INTERNAL_TYPE_ERROR on serialize] Can serialization fail with INTERNAL_TYPE_ERROR, and does this properly abort the transaction? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: get_resource_mut()] [Error message information leak] Do error messages with format! expose sensitive information about cache state or resource types? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Struct: TransactionDataCache] [BTreeMap key collision] Can crafted AccountAddress values cause BTreeMap key collisions through hash or comparison manipulation? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: insert_resource()] [Entry API race] Does the Entry::Vacant and Entry::Occupied match properly handle concurrent modifications to the BTreeMap? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: into_effects()] [Iterator invalidation] Can account_map be modified during into_iter() iteration, causing iterator invalidation and undefined behavior? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: contains_resource()] [TOCTOU in BTreeMap] Does the is_some_and check create a TOCTOU window where the entry can be removed before subsequent operations? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: get_resource_mut()] [BTreeMap mutation safety] Can get_mut on BTreeMap invalidate other references or iterators, causing use-after-free? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [Layout version mismatch] Can layouts from different Move compiler versions cause deserialization failures or data corruption? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Struct: DataCacheEntry] [Layout update inconsistency] If a resource's layout changes during execution, can cached old layouts cause misinterpretation of updated data? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [Metadata module mismatch] Can load_module_for_metadata return metadata from a different module version than the actual resource? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: into_effects()] [Layout TriompheArc sharing] Can multiple DataCacheEntry objects sharing the same TriompheArc<MoveTypeLayout> cause issues when one modifies shared state? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [LayoutConverter state corruption] Can LayoutConverter maintain incorrect state across multiple type_to_type_layout_with_delayed_fields calls? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: load_resource_mut()] [Invalid address access] Can invalid or malformed AccountAddress values bypass validation and access unintended memory locations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: create_data_cache_entry()] [Address canonicalization] Does AccountAddress use canonical form, or can different representations of the same address create duplicate cache entries? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/data_cache.rs] [Function: insert_resource()] [Reserved address bypass] Can resources be inserted at reserved system addresses (0x0, 0x1) without proper authorization checks? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L1-375)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    module_traversal::TraversalContext,\n    native_functions::DependencyGasMeterWrapper,\n    storage::{\n        loader::traits::{ModuleMetadataLoader, StructDefinitionLoader},\n        module_storage::FunctionValueExtensionAdapter,\n        ty_layout_converter::LayoutConverter,\n    },\n    Loader, ModuleStorage,\n};\nuse bytes::Bytes;\nuse move_binary_format::errors::*;\nuse move_core_types::{\n    account_address::AccountAddress,\n    effects::{AccountChanges, ChangeSet, Changes},\n    gas_algebra::NumBytes,\n    language_storage::{StructTag, TypeTag},\n    value::MoveTypeLayout,\n    vm_status::StatusCode,\n};\nuse move_vm_types::{\n    gas::DependencyGasMeter,\n    loaded_data::runtime_types::Type,\n    resolver::ResourceResolver,\n    value_serde::{FunctionValueExtension, ValueSerDeContext},\n    values::{GlobalValue, Value},\n};\nuse std::collections::btree_map::{BTreeMap, Entry};\nuse triomphe::Arc as TriompheArc;\n\n/// A hack to be able to use [MoveVmDataCache] in native context where there is no access to\n/// static gas meter.\npub trait NativeContextMoveVmDataCache {\n    /// Used by native context only! Returns true if resource exists in global storage, and false\n    /// otherwise. Also, returns the number of bytes loaded (if any, otherwise [None]).\n    fn native_check_resource_exists(\n        &mut self,\n        gas_meter: &mut dyn DependencyGasMeter,\n        traversal_context: &mut TraversalContext,\n        addr: &AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(bool, Option<NumBytes>)>;\n}\n\n/// Provides access to global storage for Move VM.\npub trait MoveVmDataCache: NativeContextMoveVmDataCache {\n    /// Loads resource from global storage. Returns the immutable reference to it, along with the\n    /// number of bytes loaded (if any, otherwise [None]).\n    ///\n    /// Note: default implementation loads the resource for mutation, casting the mutable reference\n    /// to immutable.\n    fn load_resource(\n        &mut self,\n        gas_meter: &mut impl DependencyGasMeter,\n        traversal_context: &mut TraversalContext,\n        addr: &AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(&GlobalValue, Option<NumBytes>)> {\n        let (gv, bytes_loaded) = self.load_resource_mut(gas_meter, traversal_context, addr, ty)?;\n        Ok((gv, bytes_loaded))\n    }\n\n    /// Loads resource from global storage. Returns the mutable reference to it, along with the\n    /// number of bytes loaded (if any, otherwise [None]).\n    fn load_resource_mut(\n        &mut self,\n        gas_meter: &mut impl DependencyGasMeter,\n        traversal_context: &mut TraversalContext,\n        addr: &AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(&mut GlobalValue, Option<NumBytes>)>;\n}\n\n/// Adapter for data cache that also stores references to code and data global storages. In case\n/// resource is not yet in data cache, global storage is used to add it there.\npub struct MoveVmDataCacheAdapter<'a, LoaderImpl> {\n    data_cache: &'a mut TransactionDataCache,\n    resource_resolver: &'a dyn ResourceResolver,\n    loader: &'a LoaderImpl,\n}\n\nimpl<'a, LoaderImpl> NativeContextMoveVmDataCache for MoveVmDataCacheAdapter<'a, LoaderImpl>\nwhere\n    LoaderImpl: Loader,\n{\n    fn native_check_resource_exists(\n        &mut self,\n        gas_meter: &mut dyn DependencyGasMeter,\n        traversal_context: &mut TraversalContext,\n        addr: &AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(bool, Option<NumBytes>)> {\n        let mut gas_meter = DependencyGasMeterWrapper::new(gas_meter);\n        let (gv, bytes_loaded) = self.load_resource(&mut gas_meter, traversal_context, addr, ty)?;\n        let exists = gv.exists();\n        Ok((exists, bytes_loaded))\n    }\n}\n\nimpl<'a, LoaderImpl> MoveVmDataCacheAdapter<'a, LoaderImpl>\nwhere\n    LoaderImpl: Loader,\n{\n    pub fn new(\n        data_cache: &'a mut TransactionDataCache,\n        resource_resolver: &'a dyn ResourceResolver,\n        loader: &'a LoaderImpl,\n    ) -> Self {\n        Self {\n            data_cache,\n            resource_resolver,\n            loader,\n        }\n    }\n}\n\nimpl<'a, LoaderImpl> MoveVmDataCache for MoveVmDataCacheAdapter<'a, LoaderImpl>\nwhere\n    LoaderImpl: Loader,\n{\n    fn load_resource_mut(\n        &mut self,\n        gas_meter: &mut impl DependencyGasMeter,\n        traversal_context: &mut TraversalContext,\n        addr: &AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(&mut GlobalValue, Option<NumBytes>)> {\n        let bytes_loaded = if !self.data_cache.contains_resource(addr, ty) {\n            let (entry, bytes_loaded) = TransactionDataCache::create_data_cache_entry(\n                self.loader,\n                &LayoutConverter::new(self.loader),\n                gas_meter,\n                traversal_context,\n                self.loader.unmetered_module_storage(),\n                self.resource_resolver,\n                addr,\n                ty,\n            )?;\n            self.data_cache.insert_resource(*addr, ty.clone(), entry)?;\n            Some(bytes_loaded)\n        } else {\n            None\n        };\n\n        let gv = self.data_cache.get_resource_mut(addr, ty)?;\n        Ok((gv, bytes_loaded))\n    }\n}\n\n/// An entry in the data cache, containing resource's [GlobalValue] as well as additional cached\n/// information such as tag, layout, and a flag whether there are any delayed fields inside the\n/// resource.\nstruct DataCacheEntry {\n    struct_tag: StructTag,\n    layout: TriompheArc<MoveTypeLayout>,\n    contains_delayed_fields: bool,\n    value: GlobalValue,\n}\n\n/// Transaction data cache. Keep updates within a transaction so they can all be published at\n/// once when the transaction succeeds.\n///\n/// It also provides an implementation for the opcodes that refer to storage and gives the\n/// proper guarantees of reference lifetime.\n///\n/// Dirty objects are serialized and returned in make_write_set.\n///\n/// It is a responsibility of the client to publish changes once the transaction is executed.\n///\n/// The Move VM takes a `DataStore` in input and this is the default and correct implementation\n/// for a data store related to a transaction. Clients should create an instance of this type\n/// and pass it to the Move VM.\npub struct TransactionDataCache {\n    account_map: BTreeMap<AccountAddress, BTreeMap<Type, DataCacheEntry>>,\n}\n\nimpl TransactionDataCache {\n    /// Create a `TransactionDataCache` with a `RemoteCache` that provides access to data\n    /// not updated in the transaction.\n    pub fn empty() -> Self {\n        TransactionDataCache {\n            account_map: BTreeMap::new(),\n        }\n    }\n\n    /// Make a write set from the updated (dirty, deleted) global resources along with\n    /// published modules.\n    ///\n    /// Gives all proper guarantees on lifetime of global data as well.\n    pub fn into_effects(self, module_storage: &dyn ModuleStorage) -> PartialVMResult<ChangeSet> {\n        let resource_converter = |value: Value,\n                                  layout: TriompheArc<MoveTypeLayout>,\n                                  _: bool|\n         -> PartialVMResult<Bytes> {\n            let function_value_extension = FunctionValueExtensionAdapter { module_storage };\n            let max_value_nest_depth = function_value_extension.max_value_nest_depth();\n            ValueSerDeContext::new(max_value_nest_depth)\n                .with_func_args_deserialization(&function_value_extension)\n                .serialize(&value, &layout)?\n                .map(Into::into)\n                .ok_or_else(|| {\n                    PartialVMError::new(StatusCode::INTERNAL_TYPE_ERROR)\n                        .with_message(format!("
]