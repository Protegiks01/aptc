[
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_task_until_cancelled()] [Future Memory Leak] At lines 144-146, task_fut and watchdog_fut are pinned and fused - if neither future completes (e.g., hung Boogie process and no stop signal), can these futures leak memory indefinitely? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Runtime Panic] At line 69, tokio runtime build unwrap() will panic on failure - can resource exhaustion (too many threads, memory limits) cause this unwrap to panic during verification, crashing the validator node without graceful error handling? (High)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run()] [File Handle Leak] Command.output() at line 196 captures stdout/stderr - if the Boogie process produces gigabytes of output, can this exhaust memory or file handles, causing system instability? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: is_success()] [Logic Inversion] At line 209, Err(_) is treated as success - can an attacker cause IO errors (file permission issues, disk full) to be interpreted as successful verification, allowing unverified Move code to be deployed on-chain? (Critical)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: is_success()] [Short-Circuit Error] At lines 207-208, the function returns false for compilation errors but true for timeouts - can an attacker craft Move code that causes Boogie to timeout, having it incorrectly counted as successful verification and allowing vulnerable code deployment? (Critical)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Early Return Bug] At line 109, the function returns when num_working_instances == 1 without checking success - can the last remaining worker fail, yet its failure result is returned as if it succeeded, bypassing verification? (Critical)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Off-By-One] At line 117, num_working_instances is incremented with saturating_add(1) when it should be decremented - can this cause the loop to never terminate when all workers have finished, hanging verification indefinitely? (High)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Missing Error Check] At line 128, the Err pattern is caught but ignored with an empty block - can legitimate errors be silently swallowed, causing verification to hang or return incorrect results? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Edge Case] At lines 177-179, if num_instances is 1, the function returns a single-element vector with options.random_seed - but if random_seed is not properly initialized, can this cause deterministic verification that always produces the same result regardless of input? (Low)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: make_timeout()] [Hard-Coded Value] At line 214, the timeout task ID is hard-coded to 0 - can this collide with a legitimate task_id=0 from init(), causing ambiguity about whether a result is from timeout or actual verification? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Broadcast Failure] At lines 113 and 121, master_tx.send() result is ignored with let _ = - if the broadcast fails (all receivers dropped), can workers continue running indefinitely, wasting resources and potentially causing inconsistent results? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: is_success()] [Regex Logic Error] At line 207, the function returns true if contains_compilation_error OR (NOT contains_timeout) - can a result with both compilation errors AND timeouts be incorrectly marked as success, allowing buggy verification logic? (High)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Deadlock Potential] If all num_instances workers fail and send results before the master thread reaches recv_timeout() at line 105, can the master thread deadlock waiting for a result that was already sent and lost? (High)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Constant: MAX_PERMITS] [Overflow Risk] At line 32, MAX_PERMITS = usize::MAX >> 4 - on 32-bit systems, can this value (268,435,455) cause overflow when multiplied by permit sizes in Semaphore's internal accounting, corrupting its state? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Underflow] At line 94, num_working_instances is initialized to num_instances - if num_instances is 0, can subsequent operations on num_working_instances cause underflow and undefined behavior? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Cast Truncation] At line 183, rng.gen::<u8>() is cast to usize - can this truncation on 64-bit systems reduce randomness to only 256 possible seed values, making verification results predictable and exploitable? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: get_boogie_command()] [Format Overflow] At line 223, format! is used with seed value - if seed is usize::MAX (18446744073709551615 on 64-bit), can the resulting string exceed buffer limits in command parsing, causing truncation or crashes? (Low)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Duration Overflow] At line 99, Duration::from_secs(u64::MAX) creates a duration of ~584 billion years - can this overflow internal timer implementations, causing immediate wakeup instead of the intended infinite wait? (Low)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Collection Overflow] At line 182, (0..num_instances).map() collects into a Vec - if num_instances is usize::MAX, can this allocation fail with OOM or cause integer overflow in Vec's capacity calculation? (High)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: run_tasks()] [Broadcast Size] At line 80, broadcast::channel(num_instances) - if num_instances causes overflow in the channel's internal buffer size calculation, can this panic or allocate insufficient space, causing message loss? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Weak RNG] At line 180, rand::thread_rng() is used for seed generation - is this cryptographically secure for blockchain verification, or can an attacker predict future seeds to manipulate verification outcomes? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Seed Collision] At lines 182-184, multiple random seeds are generated - with only u8 range (256 values), can seed collisions cause multiple workers to produce identical results, defeating the purpose of parallel randomized verification? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Deterministic Mode Bypass] At lines 177-179, single-instance mode uses options.random_seed - if an attacker can control options.random_seed, can they force specific SMT solver behavior to hide bugs in Move contracts? (Medium)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: init()] [Birthday Paradox] With u8 random generation at line 183 and multiple concurrent verifications, can the birthday paradox cause frequent seed collisions across different verification runs, reducing the effectiveness of randomized testing? (Low)",
  "[File: aptos-core/third_party/move/move-prover/boogie-backend/src/prover_task_runner.rs] [Function: contains_compilation_error()] [ReDoS] At line 230, the regex pattern '(?m)^.*\\\\((?P<line>\\\\d+),(?P<col>\\\\d+)\\\\).*(Error:|error:).*$' contains multiple .* wildcards - can an attacker craft Boogie output with pathological strings that cause exponential backtracking, hanging the verification process? (High)"
]