[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_request_metadata()] [Authentication bypass] Can an attacker craft requests with missing or malformed metadata headers (GRPC_AUTH_TOKEN_HEADER, REQUEST_HEADER_APTOS_IDENTIFIER) to bypass authentication, as the function uses unwrap_or('unspecified') for missing values instead of rejecting the request? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_request_metadata()] [Header injection] Can an attacker inject malicious values in metadata headers that contain special characters or escape sequences, which are then used in to_str().unwrap_or('unspecified') without validation, potentially causing log injection or metric poisoning? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_request_metadata()] [Metadata forgery] Does the function properly validate the authenticity of request_token from GRPC_AUTH_TOKEN_HEADER, or can an attacker replay valid tokens from intercepted requests to impersonate legitimate processors? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_transactions()] [Authorization weakness] The function accepts requests without starting_version (line 169-173), defaulting to latest_version - 1; can this be exploited to bypass rate limiting or access controls designed for specific version ranges? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_request_metadata()] [JSON deserialization] The function uses serde_json::from_str on user-controlled metadata (line 885-886); can an attacker craft malicious JSON that causes deserialization vulnerabilities or panics? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_transactions()] [Request validation] When starting_version is None, the code uses in_memory_cache.latest_version().saturating_sub(1); can an underflow scenario (latest_version = 0) cause incorrect version calculations leading to cache bypass? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_request_metadata()] [UUID collision] The function generates request_connection_id using Uuid::new_v4() (line 883); while unlikely, could UUID collisions in high-load scenarios cause request confusion or metric corruption? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [Chain ID validation] The chain ID from Redis is retrieved with .unwrap() (line 438), assuming it must be present; can a race condition where chain ID is deleted from Redis after the check cause a panic and service crash? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [Chain ID mismatch] When metadata_chain_id != chain_id (line 460), the function returns an error but doesn't prevent subsequent requests; can an attacker exploit timing windows during chain ID updates to serve data from wrong chains? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [Metadata waiting] The code waits indefinitely for file store metadata with only logging (lines 422-432); can an attacker who controls file store metadata prevent all new connections by never providing metadata? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [TOCTOU race] Between checking chain_id from Redis (line 437) and using it in get_data_with_tasks (line 479), can the chain ID in Redis be modified, causing cross-chain data contamination? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [File store metadata delay] The FILE_STORE_METADATA_WAIT_MS is only 2000ms; can this be too short during legitimate file store restarts, causing all requests to fail unnecessarily? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetch()] [Cache poisoning] When batch_get_encoded_proto_data returns Ok(CacheBatchGetStatus::Ok(transactions)), are the deserialized transactions validated for consistency with starting_version before use, or can poisoned cache data cause version skipping? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: deserialize_cached_transactions()] [Deserialization bomb] The spawn_blocking task deserializes Vec<Vec<u8>> without size limits (lines 704-715); can an attacker who poisons Redis cache with gigabytes of compressed data cause memory exhaustion when decompressed? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetch()] [Cache timing attack] The function returns TransactionsDataStatus::AheadOfCache when data is NotReady; can an attacker infer internal cache state or transaction timing by repeatedly querying versions and measuring response times? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetcher_task()] [Redis connection failure] When redis connection fails, the error is logged and channel receives unavailable status (lines 396-415), but the task exits; can repeated connection failures cause resource leaks from spawned tasks? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetch()] [Cache bypass] When CacheBatchGetStatus::EvictedFromCache is returned (line 775), the code falls back to file store; can an attacker who controls cache eviction policy force expensive file store reads for all requests? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: deserialize_cached_transactions()] [Task panic handling] The spawn_blocking task can panic during deserialization (lines 707-711); does the await on line 714 properly propagate panics, or can silent failures cause missing transactions in responses? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: get_data_with_tasks()] [Cache operator clone] CacheOperator is cloned for each task (line 290); can this cause race conditions if the underlying ConnectionManager is not properly synchronized? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: data_fetch()] [Error propagation] When batch_get_result returns Err (line 781), the error is propagated; but are all Redis errors treated as transient, or can permanent errors cause infinite retry loops? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: ensure_sequential_transactions()] [Gap injection] When prev_end + 1 != start_version (line 643), the function panics; can an attacker who controls file store batches inject version gaps to trigger panics and crash the service? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: ensure_sequential_transactions()] [Overflow in gap detection] The calculation prev_end - start_version + 1 (line 646) can overflow if start_version > prev_end; can this cause incorrect gap metrics or panic? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: ensure_sequential_transactions()] [Batch ordering attack] Batches are sorted by first version (line 605); if two batches have the same first version but different data, which one takes precedence, and can this cause non-deterministic transaction ordering? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: ensure_sequential_transactions()] [Drain underflow] The batch.drain(0..(prev_end - start_version + 1) as usize) (line 638) can underflow if the batch length is less than calculated; can this panic and crash the service? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs] [Function: ensure_sequential_transactions()] [Empty batch handling] If a batch is empty (len = 0), calling first().unwrap() (line 613) will panic; are empty batches properly filtered before this function? (High)"
]