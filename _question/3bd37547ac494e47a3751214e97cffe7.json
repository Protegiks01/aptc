[
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Integer Overflow] Can a malicious peer send a known_version at u64::MAX-1 and target_version at u64::MAX, causing the checked_sub operation to succeed but subsequent checked_add operations to fail, leading to inconsistent error handling and potential state sync corruption? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Integer Underflow] If target_version equals known_version exactly (bypassing the <= check through race conditions), can the checked_sub at line 78 return zero, causing num_versions_to_fetch to be 0 and creating empty or invalid storage requests that break state sync? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Arithmetic Edge Case] When known_version is u64::MAX, can the checked_add(1) operation at line 91 fail with an overflow error, preventing legitimate state sync progress and causing permanent sync stall for affected peers? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Integer Boundary] Can an attacker craft a request where target_version - known_version equals exactly max_chunk_size, causing the min() operation to potentially select an off-by-one value that leads to incorrect end_version calculation? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Overflow Propagation] If num_versions_to_fetch is bounded by max_chunk_size but known_version is near u64::MAX, can the checked_add at line 94 overflow even with a valid chunk size, causing inconsistent error messages between different overflow points? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Validation Bypass] Can a Byzantine peer exploit the version comparison at line 69 by sending target_version == known_version + 1 repeatedly to cause excessive storage reads and validator resource exhaustion without triggering rate limits? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Epoch Boundary Violation] At line 533, when epoch_ending_ledger_info.version() <= highest_known_version, can a malicious peer intentionally send requests that span epoch boundaries incorrectly to trigger repeated invalid fetch detection and cause resource exhaustion? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Cross-Epoch Attack] Can an attacker send highest_known_epoch < highest_synced_epoch (line 503) but craft highest_known_version to point within the next epoch, bypassing epoch boundary validation and causing nodes to serve data from the wrong epoch? (Critical)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Version Consistency] If target_ledger_info is updated between the version check at line 69 and the proof_version assignment at line 104, can this TOCTOU vulnerability cause proof versions to mismatch transaction versions, breaking Merkle proof verification? (Critical)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Epoch Manipulation] Can a peer send optimistic fetch requests with highest_known_epoch one less than the current epoch, causing the system to repeatedly fetch epoch_ending_ledger_info from storage (line 506), amplifying storage I/O and degrading validator performance? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: is_expired()] [Time Overflow] Can the duration_since().as_millis() conversion at line 198 overflow when calculating elapsed time if fetch_start_time is far in the past, causing expired requests to appear valid and never be cleaned up? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: is_expired()] [Timeout Bypass] Can a malicious peer manipulate their time_service mock during testing or exploit time service inconsistencies to make optimistic fetches appear non-expired indefinitely, exhausting server memory with accumulated fetch requests? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_expired_invalid_and_ready_fetches()] [Race Condition] Between checking is_expired() at line 416 and using the fetch data at line 417-423, can the request become expired, causing stale version/epoch data to be used in subsequent ready/invalid classification? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: removed_expired_optimistic_fetches()] [Expiration Race] If a fetch expires and is removed at line 575 while handle_ready_optimistic_fetches() is processing it concurrently, can this cause the response_sender to be dropped without notification, leaving the peer hanging indefinitely? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: is_expired()] [u128 Conversion] Can casting timeout_ms from u64 to u128 at line 200 cause comparison issues if timeout_ms is u64::MAX, potentially making all requests appear expired or never expired depending on comparison semantics? (Low)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: handle_ready_optimistic_fetches()] [TOCTOU Race] Between the remove_if predicate evaluation at line 276 and the actual removal, can another thread modify highest_known_version via a new request, causing the wrong fetch to be removed or the same fetch to be processed twice? (Critical)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: handle_ready_optimistic_fetches()] [Double Processing] Can concurrent calls to handle_ready_optimistic_fetches() for the same peer cause remove_if to succeed in both threads, leading to double-processing of the same optimistic fetch and duplicate responses sent to the peer? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Concurrent Modification] While spawn_blocking tasks at line 500 iterate over peers_and_highest_synced_data, can new optimistic fetches be added to the map, causing iterator invalidation or missed processing of new entries? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: handle_ready_optimistic_fetches()] [Channel Race] After take_response_sender() at line 315, if the response channel is closed or the peer disconnects, can the subsequent notify_peer_of_new_data call panic or hang, preventing cleanup of other ready fetches? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Mutex Contention] Can malicious peers flood optimistic fetch requests to cause excessive lock contention on peers_with_invalid_optimistic_fetches and peers_with_ready_optimistic_fetches mutexes (lines 473-474), degrading validator performance? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: handle_active_optimistic_fetches()] [Concurrent Map Access] Between update_optimistic_fetch_metrics() reading the map at line 222 and get_peers_with_ready_optimistic_fetches() modifying it, can race conditions cause metric counts to be permanently incorrect, hiding resource exhaustion attacks? (Low)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: identify_ready_and_invalid_optimistic_fetches()] [Task Completion Race] If join_all() at line 555 completes but new optimistic fetches are added concurrently, can those new fetches be missed in the current processing cycle, causing unbounded accumulation of pending fetches? (Medium)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: handle_ready_optimistic_fetches()] [Spawn Blocking Race] Can spawning blocking tasks at line 292 without backpressure control allow malicious peers to exhaust the blocking thread pool by triggering many optimistic fetches simultaneously, causing validator thread starvation? (High)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: get_storage_request_for_missing_data()] [Unreachable Panic] Can an attacker exploit improper request type validation to reach the unreachable!() at line 137, causing validator panic and loss of liveness through carefully crafted malformed requests? (Critical)",
  "[File: state-sync/storage-service/server/src/optimistic_fetch.rs] [Function: highest_known_version()] [Pattern Exhaustiveness] If new DataRequest variants are added but unreachable!() at line 151 is not updated, can this cause production validators to panic when processing legitimate new request types, breaking state sync? (High)"
]