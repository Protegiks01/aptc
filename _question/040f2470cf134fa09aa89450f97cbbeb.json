[
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: ParsedAddress::into_account_address()] [Address Resolution Attack] Can an attacker provide a malicious named address that matches reserved system addresses (like 0x1, 0x2) through the mapping function, allowing unauthorized access to system modules and causing privilege escalation? (Critical)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: ParsedAddress::into_account_address()] [Unbound Address Exploit] Does the error handling at line 34 properly prevent transaction execution when a named address cannot be resolved, or can an attacker craft transactions with intentionally unbound addresses that bypass validation and cause state corruption? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: ParsedAddress::into_account_address()] [Mapping Function Injection] Can an attacker manipulate the closure mapping function to return arbitrary AccountAddress values for named addresses, potentially redirecting funds to attacker-controlled accounts during transaction execution? (Critical)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: ParsedAddress::into_account_address()] [Case Sensitivity Bypass] Are named addresses case-sensitive in the mapping function, or can an attacker use case variations (e.g., 'Admin' vs 'admin') to bypass access controls and execute privileged operations? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: ParsedAddress::into_account_address()] [Unicode Homograph Attack] Can an attacker use Unicode characters that look identical to ASCII characters in named addresses (e.g., Cyrillic 'Ð°' vs Latin 'a') to create confusable addresses that redirect transactions to malicious accounts? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Integer Overflow Attack] Does the parse_address_number call at line 71 properly validate that the parsed BigUint fits within AccountAddress::LENGTH bytes, or can an attacker provide extremely large numbers that cause integer overflow and wrap around to small addresses like 0x0? (Critical)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Format Confusion Attack] Can an attacker mix hex and decimal formats in a single address string (e.g., '0x' prefix with decimal digits) to bypass validation checks and create addresses that are interpreted differently by different system components, causing state inconsistencies? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Leading Zero Exploitation] Does the parsing at line 71-75 treat addresses with different numbers of leading zeros as distinct (e.g., '0x01' vs '0x0001'), or can an attacker exploit this to create duplicate account registrations or bypass rate limits? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Negative Number Bypass] Can an attacker provide negative address values (e.g., '-0x1') that get parsed through the determine_num_text_and_base function, potentially causing underflow or wrapping to large address values that collide with existing accounts? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Error Message Information Disclosure] Does the error message at line 80-84 leak sensitive information about the maximum address size that could help an attacker craft addresses just below the limit to cause boundary condition bugs? (Low)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Whitespace Injection] Are leading/trailing whitespace characters properly stripped before parsing, or can an attacker inject spaces to bypass string equality checks while still producing valid addresses? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Special Character Injection] Can an attacker inject control characters (null bytes, newlines, etc.) into address strings that get interpreted differently by different components, causing parsing inconsistencies across the transaction pipeline? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: NumericalAddress::parse_str()] [Exponential Notation Exploit] Does the BigUint parsing reject exponential notation (e.g., '1e10'), or can an attacker use scientific notation to specify addresses in unexpected ways that bypass length validation? (Low)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::Display for NumericalAddress] [Format Field Exploitation] At lines 96-105, can an attacker control the NumberFormat field to cause the same address bytes to display differently in logs and UIs, creating a mismatch between what users see and actual on-chain addresses for phishing attacks? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::Display for NumericalAddress] [BigUint Conversion Overflow] Does the BigUint::from_bytes_be conversion at line 100 handle maximum-size addresses correctly, or can certain byte patterns cause arithmetic overflow in the display logic leading to incorrect address rendering? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::Display for NumericalAddress] [Decimal Display DoS] For addresses with maximum byte values, does the decimal conversion at line 100-101 require excessive computation time, allowing an attacker to cause denial-of-service by repeatedly requesting decimal formatting of large addresses? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::Display for NumericalAddress] [Format Confusion in Logs] Can an attacker register addresses that display identically in one format but differently in another, causing transaction logs and audit trails to be ambiguous or misleading about which account performed an action? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::UpperHex for NumericalAddress] [Leading Zero Stripping Attack] At lines 117-120, does the skip_while logic that removes leading zeros correctly handle all-zero addresses (0x0), or can this cause display inconsistencies where 0x0 appears as '0' in some contexts and '0x0' in others? (Low)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::UpperHex for NumericalAddress] [Hex Encoding Length Confusion] Does the hex::encode_upper call at line 116 produce consistent output length for addresses, or can variable-length hex strings cause parsing errors when the displayed address is copied and re-used in transactions? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::UpperHex for NumericalAddress] [Alternate Format Bypass] Can an attacker exploit the f.alternate() check at line 121 to cause addresses to render without the '0x' prefix in certain contexts, leading to decimal interpretation of hex values and massive address mismatches? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: fmt::UpperHex for NumericalAddress] [Character Iterator Vulnerability] Does the chars().skip_while() operation at lines 118-120 correctly handle UTF-8 encoding, or can malformed bytes in the hex string cause panics or incorrect address truncation? (Low)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: PartialEq for NumericalAddress] [Format Field Ignored in Equality] At lines 149-160, does ignoring the format field in equality comparison allow an attacker to create 'duplicate' addresses that are considered equal by the system but display differently, enabling phishing attacks where users send funds to what appears to be a different address? (High)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: Ord for NumericalAddress] [Ordering Inconsistency] At lines 135-146, does the Ord implementation that only compares bytes create ordering inconsistencies with Display output, allowing an attacker to manipulate sorted address lists to hide malicious accounts? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: Eq for NumericalAddress] [Reflexivity Violation] Does the Eq implementation correctly maintain reflexivity, symmetry, and transitivity across all possible byte patterns, or can certain bit patterns cause equality to behave inconsistently in hash maps and sets? (Medium)",
  "[File: aptos-core/third_party/move/move-command-line-common/src/address.rs] [Function: Hash for NumericalAddress] [Hash Collision with Format Variations] At lines 164-171, since only bytes are hashed (format is ignored), can an attacker create multiple NumericalAddress instances with different formats but identical hashes, causing HashMap collisions and performance degradation in address lookup operations? (Medium)"
]