[
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: consensus_sk_by_pk()] [Key substitution attack] Can a malicious validator replace the stored consensus private key with their own key that happens to match the expected public key through hash collision, allowing them to sign blocks on behalf of the legitimate validator and break consensus safety? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: consensus_sk_by_pk()] [Key validation bypass] In the fallback logic between explicit_sk and default_sk (lines 119-125), can an attacker exploit the error handling to retrieve an incorrect private key when both lookups fail, causing silent key mismatches that break signature verification? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: consensus_sk_by_pk()] [Public key verification race] Between retrieving the private key and verifying key.public_key() != pk (line 126), can a concurrent modification replace the key in storage, causing a TOCTOU vulnerability where wrong keys are used for signing consensus messages? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: consensus_sk_by_pk()] [Key enumeration attack] Does the explicit key lookup using format!('{}_{}'', CONSENSUS_KEY, pk_hex) (line 113) allow an attacker to enumerate all stored validator keys by brute-forcing public key prefixes, revealing the validator set composition? (Medium)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: default_consensus_sk()] [Key leak via error messages] Does the error propagation from internal_store.get() (lines 102-104) leak sensitive information about key storage structure or encryption status that could aid in cryptographic attacks? (Medium)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize_keys_and_accounts()] [Re-initialization vulnerability] The code returns Ok() early on KeyAlreadyExists error (lines 75-77), but does this allow an attacker to trigger re-initialization with different author/keys, potentially corrupting the validator's identity? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize_keys_and_accounts()] [Partial initialization state] If internal_store.set(CONSENSUS_KEY, consensus_private_key) succeeds but internal_store.set(OWNER_ACCOUNT, author) fails (line 80), does this leave the storage in an inconsistent state where keys exist but author doesn't, breaking validator authentication? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize_keys_and_accounts()] [Key overwrite protection bypass] Can an attacker repeatedly call initialize() to overwrite OWNER_ACCOUNT even after CONSENSUS_KEY exists, allowing validator impersonation by changing the author while keeping the same key? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize()] [Weak initial safety data] The initial SafetyData is created with SafetyData::new(1, 0, 0, 0, None, 0) (line 46), can an attacker exploit these zero values to vote on historical rounds or violate 3-chain commit rules during initial consensus? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize()] [Initialization order vulnerability] Between creating cached_safety_data (line 49) and calling set_safety_data() (line 55), if concurrent access reads the cache, can it see uninitialized safety data that violates consensus invariants? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Double-signing enabler] Can a malicious validator call set_safety_data() with decremented last_voted_round values to reset their voting history, allowing them to vote multiple times in the same round and double-sign conflicting blocks? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Epoch rollback attack] Does set_safety_data() validate that data.epoch is monotonically increasing, or can an attacker set a lower epoch value to revert to old validator sets and break epoch transition safety guarantees? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Cache-storage inconsistency] If internal_store.set() succeeds but the process crashes before updating cached_safety_data (line 163), does the cache hold stale data on restart, causing validators to violate safety rules they thought they had updated? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Partial update atomicity] Between setting counters (lines 153-159) and persisting to internal_store (line 161), can a crash leave metrics updated but storage unchanged, causing observability to show false safety state? (Medium)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Error handling cache invalidation] When internal_store.set() fails (line 166), the code sets cached_safety_data = None (line 167), but does this allow subsequent safety_data() calls to return outdated values from storage, violating safety rules? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Preferred_round manipulation] Can an attacker set data.preferred_round to values inconsistent with last_voted_round, breaking the 2-chain or 3-chain consensus rules and enabling equivocation? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [highest_timeout_round bypass] Does set_safety_data() validate that highest_timeout_round relationships with last_voted_round are consistent, or can malicious validators manipulate timeout rounds to avoid slashing penalties? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [one_chain_round violation] Can setting one_chain_round to arbitrary values break the relationship between 1-chain and 2-chain heights required for AptosBFT commit rules, allowing premature finalization of unsafe blocks? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: safety_data()] [Cache bypass race condition] Between checking enable_cached_safety_data (line 136) and reading cached_safety_data (line 141), can concurrent set_safety_data() invalidate the cache, causing stale data to be returned? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: safety_data()] [Cache initialization race] When cached_safety_data is None and multiple threads call safety_data() (lines 143-147), can they all read from storage and create different cached copies, leading to inconsistent safety state? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: safety_data()] [Clone-based cache pollution] The code returns cached_safety_data.clone() (line 142), but if the SafetyData struct contains mutable references or interior mutability, can cloned instances modify shared state and corrupt safety guarantees? (High)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: safety_data()] [Storage backend tampering] If the underlying internal_store is compromised (e.g., via file system access), can an attacker modify stored SafetyData to reset voting history while the validator is offline, enabling double-signing on restart? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_waypoint()] [Waypoint rollback attack] Does set_waypoint() enforce monotonicity of waypoint.version(), or can an attacker downgrade to an old waypoint with lower version numbers to revert state verification and enable historical transaction replay? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_waypoint()] [State verification bypass] Can malicious validators set arbitrary waypoints with mismatched version and hash values, bypassing state synchronization checks and allowing them to propose blocks with forked state? (Critical)",
  "[File: aptos-core/consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_waypoint()] [Metric-storage desync] The counter is updated before storage (line 180), can a storage failure leave waypoint_version metric incorrect, causing monitoring systems to report false safety state while actual waypoint is stale? (Medium)"
]