[
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::update_request_tracking()] [Integer Overflow] Can a malicious peer send a StateValuesWithProof response with end_index = u64::MAX, causing checked_add(1) at line 210-211 to overflow and crash the state sync process, leading to loss of liveness? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::create_data_client_requests()] [Integer Underflow] At line 252-253, can number_of_states = 0 cause checked_sub(1) to underflow when calculating end_state_index, resulting in Error::IntegerOverflow that permanently blocks state synchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::transform_client_response_into_notification()] [State Inconsistency] Between lines 339-341, after updating next_stream_index with checked_add(1), can a malicious response cause this to desynchronize from next_request_index, leading to missing state chunks and incomplete state reconstruction? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::transform_client_response_into_notification()] [Empty Response Bypass] At lines 323-328, the code checks for empty raw_values, but can an attacker send a response with raw_values containing only padding/garbage data that passes the isEmpty() check but contains no valid state values, corrupting the state merkle tree? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::create_data_client_requests()] [Race Condition] Lines 237-239 check if state_num_requested is true and number_of_states is None, then return empty vec. Can concurrent calls to this function create a race where state_num_requested is set but the response hasn't arrived, causing indefinite request blocking? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::transform_client_response_into_notification()] [Bounds Validation Bypass] At line 336, bound_by_range() clamps last_received_index, but can an attacker exploit this by sending last_index far beyond request.end_index, causing the stream to incorrectly mark itself as complete at line 348-349 before all data is received? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::transform_client_response_into_notification()] [State Completion Manipulation] Lines 344-350 check if last_received_index >= last_stream_index to mark stream complete. Can a malicious peer send last_index = get_number_of_states() - 1 prematurely to stop state sync before all chunks are validated and committed? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::get_number_of_states()] [Uninitialized State] At lines 220-224, can this function be called before number_of_states is initialized, returning UnexpectedErrorEncountered, but is this error properly propagated to prevent using stale/invalid state counts in subsequent requests? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::transform_client_response_into_notification()] [Version Validation] Lines 373-382 validate number_of_states against next_request_index. Can an attacker manipulate advertised number_of_states to be exactly equal to next_request_index to bypass the validation at line 374, then later increase it to cause out-of-bounds state access? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: StateStreamEngine::new()] [Initial State Validation] Lines 191-200 initialize both next_stream_index and next_request_index to request.start_index. Can request.start_index be manipulated to be near u64::MAX, causing all subsequent checked_add operations to fail and permanently blocking state sync initialization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::new()] [Version Validation Bypass] Lines 459-467 validate that target_version >= next_version, but can a malicious client provide target_version = next_version, then exploit race conditions to request data beyond the target, causing inconsistent ledger state across nodes? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::calculate_next_version_and_epoch()] [Integer Overflow] At lines 493-496, can known_version = u64::MAX cause checked_add(1) to return IntegerOverflow, but is this error properly handled to prevent initializing a stream with invalid starting versions? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::select_target_ledger_info()] [Target Ledger Spoofing] Lines 524-530 select highest_synced_ledger_info from advertised_data. Can a Byzantine peer advertise a forked ledger info with higher version to redirect state sync to an invalid chain, causing consensus divergence? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_notification_for_continuous_data()] [Version Calculation Overflow] Lines 569-572 calculate last_received_version with checked_add and checked_sub. Can num_received_versions be manipulated to cause integer overflow in the calculation, resulting in incorrect last_received_version and stream version desynchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::update_stream_version_and_epoch()] [Epoch Transition Attack] Lines 1052-1058 increment next_stream_epoch when last_received_version matches target version and ends_epoch is true. Can an attacker craft a malicious ledger info with ends_epoch=true at arbitrary versions to cause premature epoch transitions and validator set confusion? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::update_stream_version_and_epoch()] [Target Clearing Vulnerability] Lines 1080-1082 set current_target_ledger_info to None when reaching target version. Can this create a race condition where new requests are made before a new target is selected, causing gaps in the transaction stream? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_data_client_requests()] [Blocking State Attack] Lines 1174-1176 return empty vec if end_of_epoch_requested or optimistic_fetch_requested is true. Can a malicious peer indefinitely delay responses to these requests, permanently blocking all subsequent data requests and causing loss of liveness? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_data_client_requests()] [Epoch Change Detection Bypass] Lines 1194-1210 request epoch ending ledger info when target epoch > current epoch. Can an attacker manipulate advertised_data to skip epoch boundaries, causing the stream to miss epoch-ending ledger infos and desynchronize validator sets? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_subscription_stream_requests()] [Max Index Overflow] Lines 768-772 check if subscription_stream_index > max_subscription_stream_index. Can the increment at line 810 cause next_subscription_stream_index to overflow, bypassing the max check and creating infinite subscription requests? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_subscription_stream_requests()] [Subscription Takeover] Lines 724-733 retrieve active_subscription_stream with .take(). Can concurrent calls to this function cause both to take() the stream, resulting in None being returned to one caller while the other continues, creating duplicate subscription streams with the same ID? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::create_notification_for_subscription_data()] [Stream Termination Bypass] Lines 665-672 terminate subscription when index >= max index. Can an attacker send subscription responses out-of-order with decreasing indices to prevent termination detection, causing resource exhaustion from never-ending subscriptions? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::handle_epoch_ending_response()] [Single Ledger Info Assumption] Lines 829-850 expect exactly one ledger info in the response. Can this assumption be exploited by sending zero or multiple ledger infos to cause the error path at line 844-849, but are these errors properly handled to prevent stream corruption? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::get_known_version_and_epoch()] [Underflow Vulnerability] Lines 862-868 calculate known_version = next_request_version - 1 with checked_sub. Can next_request_version = 0 cause underflow, and does the error handling properly prevent this from being used in optimistic fetch requests? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::handle_optimistic_fetch_error()] [Request Flag Desync] Lines 878-886 check if optimistic_fetch_requested is true, then reset it at line 886. Can a malicious response arrive after timeout, causing the flag to be reset twice and desynchronizing request tracking state? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/stream_engine.rs] [Function: ContinuousTransactionStreamEngine::handle_subscription_error()] [Stream Reset Attack] Lines 944-954 reset active_subscription_stream to None on error. Can an attacker repeatedly trigger subscription errors to force continuous stream resets, degrading performance and preventing stable state synchronization? (High)"
]