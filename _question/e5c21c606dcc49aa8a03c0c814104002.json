[
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [Path traversal] At line 153-169 generating filenames like 'epoch_ending_{}-{}.meta', can an attacker control first_epoch or last_epoch values to inject path traversal sequences (e.g., '../../../etc/passwd') that, despite ShellSafeName validation, could overwrite arbitrary files when parsed? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [Filename collision] At line 158 using state_snapshot_ver_{version}.meta, can an attacker create multiple StateSnapshotBackupMeta with identical version numbers but different epochs, causing filename collisions that overwrite legitimate backup metadata during save_metadata_line() operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Filename collision] At line 88-91 creating 'epoch_ending_compacted_{first}-{last}.meta', can overlapping compaction operations with same epoch ranges create duplicate filenames, causing race conditions where concurrent writes overwrite each other's compacted metadata? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [ShellSafeName bypass] At line 167 using .try_into().unwrap(), can extremely large epoch or version numbers (e.g., u64::MAX) create filenames exceeding the 127-character limit in ShellSafeName validation, causing unwrap() panic that crashes backup operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_statesnapshot_backup_range()] [Filename format] At line 103-106 creating 'state_snapshot_compacted_epoch_{}_{}}.meta', can backup_metas[0].epoch == backup_metas[last].epoch create identical filenames for different snapshot contents, allowing malicious overwrites during concurrent compaction? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_transaction_backup_range()] [Filename predictability] At line 139-142 using sequential version numbers in filename, can an attacker predict upcoming compacted backup filenames and pre-create malicious files with those names, causing legitimate compaction to fail or overwrite with attacker-controlled content? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Sorting assumption] At line 73-86, the code assumes backup_metas[0] is first and processes .skip(1), but if the input vector is not sorted by epoch, can discontinuous epochs pass validation causing compacted metadata to have incorrect epoch ordering? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_transaction_backup_range()] [Sorting assumption] Comment at line 122 states 'assume the vector is sorted based on version', but without enforcement, can unsorted backup_metas cause the continuity check at line 129-135 to validate wrong pairs, allowing gaps or overlaps in compacted transaction ranges? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Clone overhead] At line 73 and 86, backup metadata is cloned, but can extremely large FileHandle strings or manifest data cause memory exhaustion during compaction of thousands of backups, leading to OOM crashes that interrupt backup operations? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_statesnapshot_backup_range()] [No continuity check] Unlike epoch ending and transaction compaction, state snapshot compaction at line 96-113 has no continuity validation - can this allow compacting non-continuous snapshot epochs (e.g., [1, 5, 100]) creating metadata that claims continuous snapshots but has massive gaps? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Partial failure] If to_text_line() at line 77 or 86 fails for some but not all backups in the vector, can partial results be returned with incomplete res vector, causing the compacted file to reference only subset of epochs leading to data loss during restore? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_transaction_backup_range()] [Duplicate entry] Can the loop at line 129-137 add duplicate TextLine entries if backup_metas contains duplicate TransactionBackupMeta elements, causing the compacted file to reference same transaction range multiple times and confusing restore logic? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: CompactionTimestampsMeta] [Equality bypass] At line 222-226, eq() only compares file_compacted_at, ignoring compaction_timestamps HashMap - can an attacker create two CompactionTimestampsMeta with same file_compacted_at but different timestamp mappings that compare as equal, causing deduplication logic to drop critical timestamp data? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: CompactionTimestampsMeta] [Ordering inconsistency] At line 228-237, Ord implementation only uses file_compacted_at, but can this cause incorrect sorting when multiple compaction operations occur at same timestamp, potentially losing or reordering compaction records in sorted collections? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: EpochEndingBackupMeta] [Ordering] At line 176 deriving Ord, can the default derived ordering (first_epoch, last_epoch, first_version, last_version) cause incorrect sorting when backups have overlapping ranges, leading to wrong backup selection during restore operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: CompactionTimestampsMeta] [Hash inconsistency] While Eq is implemented, Hash is not derived - if CompactionTimestampsMeta is used in HashMap or HashSet, can Rust's default hash include compaction_timestamps while eq() ignores it, violating HashMap invariants and causing lookup failures? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_random_identity()] [Weak randomness] At line 147-151 using HashValue::random() to generate identity, is the RNG source cryptographically secure? Can predictable RNG allow attackers to forge identity metadata, causing backup systems to accept malicious metadata as coming from legitimate backup operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: IdentityMeta] [No authentication] At line 199-202, IdentityMeta only contains an id HashValue with no signature or authentication mechanism - can an attacker copy a legitimate identity.meta file's ID and forge metadata claiming to be from trusted backup source? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [Identity filename] At line 162 returning hardcoded 'identity.meta', can multiple backup operations create filename collisions where concurrent or sequential backup identity files overwrite each other, causing loss of backup provenance tracking? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: IdentityMeta] [ID collision] Can HashValue::random() collisions (birthday paradox) occur when generating many identity metadata files, causing different backup operations to have identical IDs and breaking backup uniqueness tracking? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_epoch_ending_backup()] [Epoch-version desync] Can an attacker create EpochEndingBackupMeta where the epoch range [first_epoch, last_epoch] doesn't match the transaction version range [first_version, last_version], causing restore to apply epoch endings at wrong version heights and corrupting validator set transitions? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Manifest inconsistency] At line 77 and 86, manifest FileHandles from different backups are preserved separately in compacted file, but can manifests reference overlapping or conflicting epoch ending ledger infos that, when restored, create forked validator set histories? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_state_snapshot_backup()] [Snapshot-epoch mismatch] Can StateSnapshotBackupMeta at line 42-47 be created with epoch and version from different blockchain forks, causing restore to load state snapshot that doesn't match the epoch ending backup's validator set, breaking consensus? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_transaction_backup_range()] [Transaction gaps] If the continuity check at line 129-135 is bypassed (e.g., through race conditions or integer overflow), can compacted metadata with gaps cause restore to skip transaction versions, creating state that diverges from canonical blockchain history? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_statesnapshot_backup_range()] [Epoch ordering] At line 108-111, can the state snapshot compaction produce TextLine vector in wrong order if backup_metas is sorted by version instead of epoch, causing restore to apply snapshots out of order and corrupt state? (High)"
]