[
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Epoch transition deadlock] During epoch change, if new BufferManager is created before old one is fully stopped, can they share the same commit_msg_rx causing message stealing and preventing either from making progress? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Parameter injection] Can an attacker manipulate the author parameter to impersonate another validator, causing BufferManager to sign commit votes with wrong validator identity and break voting power calculations? (Critical)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Configuration confusion] If order_vote_enabled is set incorrectly (opposite of intended value), can it disable critical ordering checks in BufferManager allowing blocks to be committed out-of-order and violating linearizability? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Back pressure bypass] Can a malicious validator set back_pressure_enabled=false to disable flow control, causing unbounded block accumulation in BufferManager and memory exhaustion on victim validators? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Round manipulation] If highest_committed_round is set to u64::MAX, can it cause integer overflow in round number comparisons within BufferManager, allowing old blocks to be accepted as new ones? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Executor binding] Can the bounded_executor parameter be configured with zero capacity or manipulated to execute all tasks synchronously, causing BufferManager to block on async operations and halt consensus? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Consensus observer injection] Can a malicious consensus_publisher (Option<Arc<ConsensusPublisher>>) be injected to leak sensitive consensus data or manipulate published blocks seen by downstream observers? (Medium)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Cache overflow] If max_pending_rounds_in_commit_vote_cache is set to a very large value, can it allow unbounded memory consumption in BufferManager's pending_commit_votes cache, causing validator OOM? (Medium)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Phase desynchronization] Can ExecutionSchedulePhase and ExecutionWaitPhase become desynchronized if ExecutionSchedulePhase processes blocks but ExecutionWaitPhase is reset, causing execution futures to complete without corresponding wait requests? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Pipeline bypass] Since PipelinePhase instances are created independently, can an attacker bypass one phase (e.g., ExecutionWaitPhase) by directly injecting SigningRequests into signing_phase_request_tx without proper execution? (Critical)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Phase isolation breach] Can malicious code access the response_tx channels (execution_schedule_phase_response_tx, execution_wait_phase_response_tx, signing_phase_response_tx) and inject fake responses, bypassing actual phase processing? (Critical)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Response spoofing] If ExecutionResponse or SigningResponse messages can be crafted without actually executing or signing, can an attacker make BufferManager believe blocks are ready when they're not, causing invalid commits? (Critical)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Phase restart race] During reset, if phases are restarted in wrong order (e.g., SigningPhase before ExecutionWaitPhase), can messages flow backwards through the pipeline causing causality violations? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Unbounded channel growth] Since create_channel() creates unbounded channels, can a Byzantine validator flood execution_schedule_phase_request_tx with ExecutionRequests faster than they're processed, causing unbounded memory growth and OOM? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Task counter overflow] Can the ongoing_tasks (Arc<AtomicU64>) counter overflow if more than 2^64 CountedRequests are created, causing it to wrap around and allow premature pipeline reset while tasks are still active? (Medium)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Response channel saturation] If signing_phase_response_rx is not consumed quickly enough by BufferManager, can the corresponding sender in SigningPhase block indefinitely causing the phase to stop processing new requests? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Bounded executor saturation] If bounded_executor reaches capacity, can it cause BufferManager's async tasks to queue indefinitely, blocking critical operations like epoch transitions? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Channel handle leak] Are all channel senders and receivers properly dropped when BufferManager or phases are destroyed, or can leaked channels cause memory leaks in long-running validators? (Low)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Observer data leak] Can a malicious consensus_publisher leak uncommitted blocks or execution results to observers before they're finalized, allowing front-running or insider trading attacks? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Observer config manipulation] If consensus_observer_config is manipulated to enable publishing when it should be disabled, can it cause performance degradation or information leakage affecting consensus liveness? (Medium)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Publisher poisoning] Can a malicious ConsensusPublisher implementation panic or block when called by BufferManager, causing the main consensus loop to hang? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Execution-Signing gap] Is there proper validation that blocks sent to SigningPhase have actually been executed, or can an attacker create SigningRequests for blocks that never went through ExecutionWaitPhase? (Critical)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Signing-Persisting gap] Can SigningPhase generate signatures that are never persisted if PersistingPhase crashes, causing commit votes to be broadcast without local state updates and creating divergence? (High)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Phase timing attack] Can an attacker deliberately slow down one phase (e.g., by sending complex blocks to ExecutionSchedulePhase) while speeding through others to create timing windows for attacks? (Medium)",
  "[File: consensus/src/pipeline/decoupled_execution_utils.rs] [Function: prepare_phases_and_buffer_manager()] [Duplicate phase usage] Since the function returns owned PipelinePhase instances, can they be started multiple times creating duplicate processors that interfere with each other? (High)"
]