[
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_variant_handle()] [Struct def validation dependency] At lines 296-300, check_struct_variant_handle() depends on struct_def_at() which may fail - can an attacker provide variant handles referencing invalid struct indices that cause errors but leave system in inconsistent state? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_variant_index()] [Variant count type casting] At lines 302-317, variant_index is compared to variant_count after casting to usize - can an attacker exploit the cast from VariantIndex (likely u16) to usize on different architectures? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_variant_index()] [Non-variant struct attack] If struct_def.field_information.variant_count() returns 0 for non-variant structs, can an attacker provide variant_index=0 that incorrectly passes validation at line 307? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_instantiation()] [Type parameter mismatch] At lines 319-325, check_struct_instantiation() only validates that def and type_parameters are in bounds, but does it verify that the number of type parameters matches the struct definition's requirements? (Critical)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_instantiation()] [Handle validation gap] At lines 327-336, check_function_instantiation() validates handle and type_parameters separately - can there be TOCTOU issues where handle is modified between checks? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_field_instantiation()] [Optional field handles] At line 342, check_bounds_impl_opt is used for field_handles - can an attacker exploit the absence of field_handles table to bypass field instantiation validation entirely? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_variant_field_instantiation()] [Variant instantiation consistency] At lines 346-352, does check_variant_field_instantiation() ensure that type parameters are compatible with all variants referenced by the handle, or just validate indices? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_variant_instantiation()] [Handle validity timing] At lines 354-360, struct_variant_handles table is checked optionally - if table exists but handle is invalid, can partial validation leave system vulnerable? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_constant()] [Type-value mismatch] At lines 369-371, check_constant() only validates constant.type_ through check_type(), but does it verify that the constant's actual data bytes match the declared type? (Critical)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_constants()] [Constant pool size] At lines 139-144, iteration over constant_pool() has no size limits - can an attacker provide modules with millions of constants causing memory exhaustion or validation timeouts? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_def()] [Type parameter count calculation] At lines 380-384, type_param_count is calculated from struct_handle.type_parameters.len() which may fail if handle is invalid - can this cause use of incorrect type parameter count for field validation? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_def()] [Declared fields validation] At lines 386-391, fields are validated in declared structs, but can an attacker craft fields with circular type references that pass individual check_field_def() but cause infinite loops during type resolution? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_def()] [DeclaredVariants empty check] At lines 399-406, empty variants return ZERO_VARIANTS_ERROR, but is this checked before iterating over variants (line 393), potentially causing iteration over empty collection? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_def()] [Variant name validation] At line 394, variant.name is checked against identifiers table - can attacker provide duplicate variant names that pass bounds check but cause name resolution conflicts? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_struct_def()] [Native struct handling] At line 408, Native structs skip field validation - can an attacker declare native structs with field_information that would fail validation if checked? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_field_def()] [Type parameter bounds] At lines 413-422, check_type_parameters_in_ty() is called with type_param_count - can an attacker exploit differences between struct-level and field-level type parameters to cause type confusion? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_field_def()] [Signature validation order] Lines 418-420 check field.name before field.signature - can early return on name validation allow malformed signatures to persist in the module? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_def()] [Context switching vulnerability] At lines 429-431, context is mutated to ModuleFunction - is this mutation thread-safe given the interior mutability pattern used elsewhere, or can race conditions occur? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_def()] [Acquires validation] At lines 433-435, acquires_global_resources are checked against struct_defs, but does this validate that acquired resources are actually used in the function or can phantom acquires be declared? (Low)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_def()] [Double bounds check] Lines 442-448 manually check function_def.function bounds after it should have been checked by check_bounds_impl() - does this indicate a potential gap in earlier validation? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_def()] [Parameters signature validation] At lines 450-457, parameters signature index is checked again - can an attacker exploit timing between initial signature table validation and per-function validation? (High)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_function_def()] [Native function handling] At lines 437-440, native functions (no code) return early - can attacker declare native functions with invalid signatures or type parameters that skip code validation? (Medium)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_code()] [Locals count overflow] At lines 477-478, locals_count uses saturating_add - if saturation occurs, does the comparison at line 480 correctly detect overflow or can attacker bypass TOO_MANY_LOCALS check? (Critical)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_code()] [LocalIndex::MAX validation] At line 480, locals_count is compared to LocalIndex::MAX which is likely u8::MAX (255) - can an attacker provide more locals through crafted parameters+locals combination that overflows u8? (Critical)",
  "[File: aptos-core/third_party/move/move-binary-format/src/check_bounds.rs] [Function: check_code()] [Locals signature validation timing] At line 474, code_unit.locals is validated before get_locals() at line 476 - can TOCTOU vulnerabilities occur if locals signature is modified between checks? (Low)"
]