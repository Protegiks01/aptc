[
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Shard ordering guarantee] Does the TODO comment at line 89 about 'smt per shard' indicate a future breaking change that could invalidate current assumptions? (Medium)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Deletion handling] Can deletion operations (value_opt = None) at line 97 be processed incorrectly, leaving deleted keys in the Merkle tree? (High)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Creation vs Modification] Does the code distinguish between Creation and Modification in as_state_value_opt(), or can attackers modify existing values while claiming creation? (High)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: StateSummary::update()] [Value hash consistency] Can different StateValue objects with identical serialization produce different hashes, breaking deduplication assumptions? (Medium)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: LedgerStateSummary::update()] [Checkpoint manipulation] Can an attacker force checkpoint creation by manipulating for_last_checkpoint_batched() to cause excessive checkpointing and storage bloat? (Medium)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: LedgerStateSummary::update()] [Checkpoint suppression] Can an attacker prevent checkpoints by ensuring for_last_checkpoint_batched() always returns None, breaking pruning and causing unbounded state growth? (High)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: LedgerStateSummary::last_checkpoint()] [Checkpoint staleness] Can last_checkpoint() at line 163 return extremely old checkpoints if updates are maliciously structured, breaking state sync assumptions? (High)",
  "[File: aptos-core/storage/storage-interface/src/state_store/state_summary.rs] [Function: ProvableStateSummary::get_proof()] [Statistical attack] Can attackers submit 10000 mal\n\n### Citations\n\n**File:** storage/storage-interface/src/state_store/state_summary.rs (L1-247)\n```rust\n// Copyright (c) Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    metrics::TIMER,\n    state_store::{\n        state::LedgerState,\n        state_update_refs::{BatchedStateUpdateRefs, StateUpdateRefs},\n    },\n    DbReader,\n};\nuse anyhow::Result;\nuse aptos_crypto::{\n    hash::{CryptoHash, CORRUPTION_SENTINEL},\n    HashValue,\n};\nuse aptos_metrics_core::TimerHelper;\nuse aptos_scratchpad::{ProofRead, SparseMerkleTree};\nuse aptos_types::{proof::SparseMerkleProofExt, transaction::Version};\nuse derive_more::Deref;\nuse itertools::Itertools;\nuse rayon::prelude::*;\n\n/// The data structure through which the entire state at a given\n/// version can be summarized to a concise digest (the root hash).\n#[derive(Clone, Debug)]\npub struct StateSummary {\n    /// The next version. If this is 0, the state is the"
]