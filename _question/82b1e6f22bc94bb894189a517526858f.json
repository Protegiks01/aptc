[
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: All deserialize() implementations] [Timing Attack] Do deserialization error paths take different amounts of time, allowing attackers to use timing side-channels to infer valid vs invalid field values and probe fullnode internal state? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsOutput::deserialize()] [Transaction Ordering] Does the transactions vector preserve insertion order during deserialization, or can reordering attacks cause transactions to be applied in wrong sequence violating consensus ordering? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: stream_status::StatusType::deserialize() - line 454] [Type Widening] When converting i64 to i32 via try_from, can the error case be exploited to cause the deserializer to fall back to other visitor methods (visit_u64, visit_str) allowing type confusion? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: All GeneratedField enums] [Enum Exhaustiveness] Are all match statements on GeneratedField enums exhaustive, or can future enum variants added without updating match arms cause deserialization to silently fail or default to wrong behavior? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: Multiple visit_str implementations] [String Validation] Do the visit_str implementations validate string lengths and character sets, or can extremely long field names or unicode exploits cause buffer overflows or parsing errors? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: All serialize_field calls] [Field Name Injection] Can attackers exploit the camelCase vs snake_case field name mapping (e.g., 'startingVersion' vs 'starting_version') to inject duplicate fields with different naming conventions bypassing deduplication checks? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize()] [Ledger Version Confusion] Can Byzantine fullnodes send requests with starting_version pointing to forked chain versions, and does the protocol validate that requested versions match the canonical chain causing potential chain split acceptance? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: StreamStatus::deserialize()] [Epoch Boundary Attack] When start_version and end_version span across epoch boundaries, does deserialization validate that this is handled correctly, or can this cause epoch reconfiguration data to be skipped leading to validator set inconsistencies? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsFromNodeResponse::deserialize()] [Fork Choice Attack] Can malicious fullnodes send TransactionsFromNodeResponse data from alternative forks with valid chain_id, causing honest fullnodes to cache and potentially serve forked transaction data to other peers? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsOutput::deserialize()] [Transaction Authenticity] Does the transactions vector deserialization validate transaction signatures and state roots, or can unsigned/invalid transactions be deserialized and cached causing state verification failures downstream? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize()] [Amplification Attack] Can attackers send small GetTransactionsFromNodeRequest messages requesting massive transaction ranges (transactions_count=u64::MAX), amplifying small requests into huge responses causing bandwidth exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: StreamStatus::deserialize()] [Stream Flooding] Can attackers rapidly send StreamStatus messages with type=INIT to force fullnodes to repeatedly reinitialize streams, consuming CPU and memory resources in stream setup logic? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsOutput::deserialize()] [Deep Nesting] If transaction objects contain nested structures, can attackers send deeply nested transaction data exceeding recursion limits causing stack overflow during deserialization? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: All deserialize() implementations] [Slowloris Attack] Can attackers send partial JSON/binary data that keeps deserializers in waiting state consuming connection resources, eventually exhausting fullnode connection pools? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize()] [Version Monotonicity] Is there validation ensuring starting_version values in sequential requests are monotonically increasing, or can attackers interleave old and new version requests causing out-of-order transaction processing? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: StreamStatus::deserialize()] [Status Transition Validation] Can attackers send StreamStatus with illegal state transitions (e.g., BATCH_END followed by BATCH_END without INIT), causing state machine corruption in transaction streaming protocol? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsFromNodeResponse::deserialize()] [Response Correlation] Is there validation correlating Response messages to prior Request messages, or can attackers send unsolicited responses that get cached and served to wrong requesters causing data corruption? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsOutput::deserialize()] [Transaction Completeness] Does deserialization validate that all transactions in the requested range are present in the output, or can partial responses cause gaps in the fullnode's transaction database? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: All deserialize() implementations] [Concurrent Deserialization] If multiple threads deserialize messages concurrently, can race conditions in the map.next_key() loops cause fields to be deserialized into wrong message instances leading to state corruption? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize() - lines 88-89] [Variable Shadowing] Can the use of mutable variables starting_version__ and transactions_count__ lead to race conditions if deserialization is interrupted and resumed, causing partial field initialization? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsFromNodeResponse::deserialize() - lines 582-583] [Response Race] Can concurrent deserialization of chain_id and response fields cause inconsistent TransactionsFromNodeResponse objects where chain_id doesn't match the actual chain of the response data? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize()] [Access Control Bypass] Does deserialization validate that the requester is authorized to access the requested transaction range, or can any peer request and receive transactions from private/permissioned ranges? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: PingFullnodeRequest::deserialize()] [Unauthenticated Ping] Can unauthenticated peers send PingFullnodeRequest to enumerate fullnodes and gather network topology information for targeted attacks? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: TransactionsFromNodeResponse::deserialize()] [Response Authentication] Is there cryptographic verification of TransactionsFromNodeResponse messages, or can man-in-the-middle attackers inject fake responses causing fullnodes to accept invalid transaction data? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.serde.rs] [Function: GetTransactionsFromNodeRequest::deserialize()] [Genesis Block Edge Case] When starting_version=0 (genesis), are there special handling requirements that deserialization doesn't validate, causing errors when processing genesis transactions differently from regular transactions? (Medium)"
]