[
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Initialization vulnerability] Can a malicious on-chain configuration provide an empty HashMap for proposers combined with an invalid default_proposer (e.g., zero address or non-validator address), causing all rounds to be assigned to an unauthorized proposer and breaking consensus validator authority invariants? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Validator set manipulation] Can an attacker craft a proposers HashMap that maps all rounds to a single Byzantine validator (or < 1/3 colluding validators), centralizing block production and enabling censorship attacks or transaction ordering manipulation? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Determinism failure] Does the HashMap.get() operation guarantee deterministic behavior across all validators when the same round is queried, or could hash collision handling or internal HashMap implementation differences cause validators to select different proposers for the same round, leading to consensus failure? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Default proposer abuse] When proposers.get(&round) returns None for unmapped rounds, all such rounds default to default_proposer - can this be exploited by intentionally leaving rounds unmapped to give one validator disproportionate proposal power, violating fairness and potentially enabling validator collusion? (Medium)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Concurrent access] Is the proposers HashMap accessed from multiple threads without synchronization primitives (Mutex/RwLock), and could concurrent reads during epoch transitions or reconfigurations cause race conditions leading to non-deterministic proposer selection? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Round overflow] Round is a u64 type - can an attacker force round numbers to overflow by manipulating timeout certificates or malicious proposals, causing rounds to wrap around to previously-mapped proposers and potentially triggering equivocation or safety violations? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [HashMap size DoS] Can a malicious on-chain governance proposal create a proposers HashMap with billions of entries (e.g., mapping every possible u64 round to validators), causing memory exhaustion on validator nodes and crashing the consensus layer? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Author validation bypass] Does this implementation validate that the returned Author (proposer) is actually in the current validator set, or can it return addresses of non-validators, removed validators, or zero addresses, allowing unauthorized block proposals? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Epoch boundary bugs] During epoch transitions when the validator set changes, is the RoundProposer instance properly updated or recreated, or could stale mappings persist across epochs, assigning rounds to validators who are no longer in the active set? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Liveness attack] If the default_proposer is offline or Byzantine, and most rounds are unmapped (falling back to default), can this cause persistent liveness failures as the network repeatedly selects a non-responsive proposer? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Clone semantics] The proposers HashMap is cloned when passed to new() (based on usage in epoch_manager.rs) - does this deep clone operation preserve exact ordering and determinism across all validators, or could subtle differences in HashMap internal state cause non-deterministic behavior? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Byzantine round skipping] Can Byzantine validators deliberately skip certain rounds to influence which proposer gets selected, exploiting the sparse HashMap to manipulate consensus flow and favor colluding validators? (Medium)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Serialization attacks] If RoundProposer state is serialized/deserialized (e.g., for checkpointing), could an attacker inject malicious data to corrupt the proposers mapping or default_proposer during deserialization, bypassing validator verification? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Type confusion] Author is a type alias for AccountAddress - could type confusion between validator addresses, user addresses, and system addresses allow non-validator addresses to be returned as valid proposers? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Default proposer selection] The default_proposer is hardcoded to proposers.first() in epoch_manager.rs - can the validator ordering be manipulated during validator set construction to ensure a Byzantine validator becomes the default proposer? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Memory safety] Are there any unsafe blocks or raw pointer manipulations in the HashMap implementation that could lead to memory corruption, use-after-free, or other memory safety violations affecting consensus integrity? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Hash collision] If two different Round values hash to the same HashMap bucket and one is mapped while the other isn't, could bucket collision handling cause the wrong proposer to be selected for the unmapped round? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Return value verification] Is the returned Author verified to be non-zero and valid before use, or could a zero/null address be returned (e.g., if default_proposer is uninitialized), causing crashes or undefined behavior in downstream consensus code? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Immutability assumption] Once created, RoundProposer has no mutator methods - but could shared mutable references to the underlying HashMap (via unsafe code or interior mutability patterns) allow runtime modification, breaking determinism guarantees? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Duplicate mapping validation] Does the constructor validate that each Round maps to exactly one Author, or could duplicate/conflicting entries in the input HashMap cause ambiguous proposer selection? (Medium)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Cache timing attacks] Could the HashMap.get() operation's timing differences (cache hit vs. miss, or hash collision resolution time) leak information about which rounds are mapped, enabling side-channel attacks to predict future proposers? (Low)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [Arc/Mutex wrapping] When wrapped in Arc for multi-threaded access (as seen in epoch_manager.rs), are there missing Mutex guards that could allow data races when multiple threads query get_valid_proposer() during the same round? (High)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: get_valid_proposer()] [Round range validation] Are there any checks that round is within valid bounds (e.g., not MAX_U64, not zero), or could extreme round values cause integer wraparound issues in the HashMap hashing function? (Medium)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Function: new()] [Proposer validity check] Does the constructor verify that all Authors in the proposers HashMap and the default_proposer are valid public keys with corresponding private keys held by actual validators, preventing insertion of uncontrolled addresses? (Critical)",
  "[File: consensus/src/liveness/round_proposer_election.rs] [Struct: RoundProposer] [State consistency] If multiple RoundProposer instances are created across different validator nodes from the same on-chain configuration, is there guaranteed bitwise-identical state, or could differences in HashMap internal structure cause divergent behavior? (Critical)"
]