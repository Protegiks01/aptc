[
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [Premature vote deletion] At lines 162-170, votes are removed if their round <= highest_ordered_round. Can a malicious node manipulate highest_ordered_round to be artificially high, causing premature deletion of valid pending votes and preventing quorum formation? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [Round number manipulation] At lines 164-169, the round number is extracted from either LedgerInfoWithSignatures or SignatureAggregator. Can an attacker craft votes with manipulated round numbers in the LedgerInfo to bypass garbage collection and persist invalid votes indefinitely? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [State inconsistency after GC] At line 163, the retain() operation mutates the HashMap. If insert_order_vote() is called concurrently during garbage collection, can this cause race conditions leading to partial vote sets or corrupted state? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [Loss of valid votes] If garbage_collect() is called with an incorrect highest_ordered_round value due to a bug or attack, can this permanently delete votes that are still needed for consensus, causing liveness failures? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [Denial of quorum] Can a Byzantine validator coordinate vote timing such that votes arrive just before garbage_collect() runs with an aggressive highest_ordered_round, preventing quorum formation by deleting votes before they can be aggregated? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Unknown author bypass] At lines 96-101, if a validator is unknown, UnknownAuthor is returned but the vote may have already been partially processed. Can this leave the SignatureAggregator in an inconsistent state, affecting subsequent vote processing? (Medium)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Panic on expect()] At lines 75-76 and 104, expect() is used which will panic if the condition fails. Can an attacker trigger these panics by providing a None verified_quorum_cert or manipulating validator set state, crashing the validator node? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Error silencing] At lines 106-111, zero voting power votes are logged with warn! but processing continues. Can Byzantine validators exploit this by overwhelming logs with zero-power votes while hiding genuine attack patterns in the noise? (Low)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [TooLittleVotingPower handling] At lines 139-141 and 145-146, TooLittleVotingPower errors are treated as normal cases. Can an attacker trigger this error path maliciously to prevent proper error detection and logging of actual consensus failures? (Medium)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Generic error handling] At lines 148-154, verification errors are logged with error! but processing continues. Can critical security violations (like invalid signatures) be disguised as generic errors, allowing Byzantine behavior to go undetected? (Medium)",
  "[File: consensus/src/pending_order_votes.rs] [Struct: PendingOrderVotes] [Missing synchronization] The struct at lines 40-46 contains a HashMap but no explicit Mutex or RwLock. If accessed concurrently from multiple threads, can this cause data races, corrupted state, or undefined behavior in the vote aggregation logic? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Non-atomic state updates] At lines 132-137, the status is updated and then a result is returned. Can concurrent calls interleave between the status update and result return, causing some threads to see stale state and form inconsistent views of quorum status? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [HashMap entry race] At lines 72-82, entry().or_insert_with() is used. Can two threads simultaneously inserting votes for the same ledger info create a race where one thread's QuorumCert overwrites another's, leading to consensus inconsistencies? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Signature aggregator race] At lines 92-156, the sig_aggregator is accessed mutably. If multiple threads process votes for the same ledger info concurrently, can they corrupt the aggregator's internal state by racing on add_signature() calls? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [GC/insert race] At line 163, retain() mutates the HashMap while insert_order_vote() may be adding entries. Without proper locking, can this race condition cause votes to be lost, duplicated, or the HashMap to enter a corrupted state? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Validator set desync] At lines 65 and 94-95, the same ValidatorVerifier instance is used. If the validator set changes between these calls (epoch transition), can this cause voting power to be calculated inconsistently, leading to invalid quorum certificates? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Stale verifier exploitation] If the ValidatorVerifier passed at line 65 is from a previous epoch but votes are for a future epoch's ledger info, can this allow validators who are no longer in the set to contribute to quorum formation? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Pessimistic verify set manipulation] At lines 334-339 in tests, pessimistic_verify_set() is checked. Can an attacker manipulate which signatures go into the pessimistic verify set to bypass full cryptographic verification while still reaching the voting power threshold? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Quorum voting power race] At lines 116-117, quorum_voting_power() is called on the ValidatorVerifier. Can the quorum threshold change between this check and the actual aggregation at line 124, allowing QCs to form with less than the true required voting power? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: has_enough_order_votes()] [Verifier bypass] At lines 173-180, this function checks quorum status without re-validating against a ValidatorVerifier. Can an attacker exploit this by modifying the validator set after a QC is formed, making previously invalid QCs appear valid? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [LedgerInfo tampering] At line 79, the LedgerInfo is cloned from the OrderVote. Can an attacker modify the LedgerInfo between vote creation and vote processing to make votes for different ledger infos appear to be for the same digest? (Critical)",
  "[File: consensus/src/pending_order_votes.rs] [Function: garbage_collect()] [Round overflow] At lines 165 and 168, round numbers are compared. Can an attacker submit votes with round numbers near u64::MAX causing integer overflow in round comparisons, preventing garbage collection or causing premature deletion? (Medium)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Round mismatch exploitation] If votes arrive for ledger infos with inconsistent round numbers (e.g., votes claim round 100 but LedgerInfo contains round 50), can this confusion be exploited to bypass round-based safety checks in the broader consensus protocol? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: has_enough_order_votes()] [Stale quorum check] At lines 174-175, the function checks if EnoughVotes status exists but doesn't validate that the votes are still valid for the current epoch/validator set. Can stale QCs from previous epochs be mistakenly accepted? (High)",
  "[File: consensus/src/pending_order_votes.rs] [Function: insert_order_vote()] [Epoch boundary attack] If votes span an epoch boundary where the validator set changes, can Byzantine validators exploit the transition to get votes from the old set counted toward quorum in the new set, breaking consensus safety? (Critical)"
]