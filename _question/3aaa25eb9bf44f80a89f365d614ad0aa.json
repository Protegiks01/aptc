[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: new()] [Integer overflow] If an attacker supplies extremely large values for n or max_in_progress parameters during backup restoration, can this cause integer overflow when calculating buffer sizes, leading to memory exhaustion or corrupted backup data? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: new()] [Resource exhaustion] Can a malicious backup file trigger the creation of TryBufferedX with n=usize::MAX, causing the backup restoration process to allocate unbounded memory and crash validator nodes during state recovery? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: new()] [State corruption] If max_in_progress is set to 0 or is less than n, can this create an invalid state where futures are never processed, causing backup restoration to hang indefinitely and prevent validators from syncing? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: new()] [Initialization race] Can concurrent calls to new() with the same stream cause the Fuse wrapper to be incorrectly initialized, leading to duplicate processing of backup chunks and state inconsistency? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Race condition] In the while loop at line 59, can concurrent polling from multiple tasks cause in_progress_queue.len() to be checked and modified non-atomically, leading to more than max futures being spawned and resource exhaustion? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Error propagation bypass] At line 60, when this.stream.as_mut().poll_next(cx)? propagates errors immediately, can a malicious backup file trigger partial processing where some futures complete but errors aren't fully unwound, causing state corruption during restoration? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Order violation] When pushing futures to in_progress_queue at line 62, can a race condition in the underlying FuturesOrderedX cause futures to be executed out of order, leading to transactions being restored in incorrect sequence and breaking state consistency? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Infinite loop] If this.stream.as_mut().poll_next(cx) always returns Poll::Ready(Some(fut)), can the while loop at line 59 run indefinitely without yielding, causing validator nodes to hang during backup restoration? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Buffer overflow] Can the condition in_progress_queue.len() < *this.max be exploited by timing attacks to exceed the maximum buffer size between check and push operations, exhausting memory during backup processing? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Premature termination] At line 75, when checking this.stream.is_done(), can a race condition cause the stream to report done prematurely while futures are still in flight, leading to incomplete backup restoration and missing state data? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Polling starvation] If in_progress_queue.poll_next_unpin(cx) at line 69 always returns Poll::Pending, can this prevent new futures from being spawned from the stream, causing backup restoration to stall indefinitely? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Double-poll vulnerability] Can poll_next be called concurrently on the same Pin<&mut Self>, violating Rust's pinning guarantees and causing undefined behavior in the Fuse<IntoStream<St>> wrapper? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Partial failure state] When error propagation occurs via the ? operator at line 60, are in-flight futures in in_progress_queue properly cancelled, or can they continue executing and corrupting restored state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Error masking] Can errors from in_progress_queue.poll_next_unpin() be silently dropped at line 69 when pattern matching only handles Poll::Pending and Poll::Ready(Some(_)), causing backup corruption to go undetected? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Panic propagation] If TryFutureExt::into_future() panics during the push operation at line 62, can this leave in_progress_queue in an inconsistent state with partially committed futures? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Error recovery] After an error is propagated from stream polling at line 60, can the TryBufferedX be reused or is it permanently poisoned, and could this prevent retry logic from recovering corrupted backups? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Struct: TryBufferedX] [Fuse wrapper vulnerability] Can the Fuse wrapper around IntoStream at line 40 incorrectly report the stream as done before all items are consumed, causing incomplete backup restoration? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [State transition] When transitioning from Poll::Ready(None) to stream.is_done() check at line 75, can intermediate Poll::Pending returns be exploited to poll already-completed futures multiple times? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Terminal state bypass] After this.stream.is_done() returns true at line 75, can in_progress_queue still contain pending futures that will never be polled, causing data loss during restoration? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Wake mechanism] If Poll::Pending is returned at line 78, is the waker properly registered to wake the task when in_progress_queue has capacity, or can this cause permanent suspension of backup processing? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Struct: TryBufferedX] [FuturesOrderedX interaction] Can the in_progress_queue's ordering guarantees be violated if futures complete out of order in the underlying FuturesUnorderedX, causing transactions to be restored in wrong sequence? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Concurrent modification] When project() is called at line 55 to get mutable references, can these be used to modify in_progress_queue and stream concurrently from different tasks, violating borrow checker assumptions? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Function: poll_next()] [Async cancellation] If the future returned by poll_next is dropped before completion, can this leave in_progress_queue with orphaned futures that consume resources indefinitely? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Struct: TryBufferedX] [Pin safety] Does the #[pin_project] macro properly handle the pinned stream field at line 28, or can moves of TryBufferedX after pinning cause dangling references in async contexts? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/try_buffered_x.rs] [Struct: TryBufferedX] [Memory leak] Can futures pushed to in_progress_queue at line 62 leak memory if they're never polled due to early termination, causing validator memory exhaustion over time? (High)"
]