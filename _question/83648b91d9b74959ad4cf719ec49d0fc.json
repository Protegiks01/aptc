[
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: get_new_subscription_id()] [Integer Overflow] Can the U64IdGenerator wrap around after 2^64 subscriptions, causing subscription ID collisions that overwrite existing subscriptions and allow attackers to hijack event streams intended for other components? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Duplicate Subscription ID] The error handling checks for duplicate subscription IDs, but is this check atomic? Can concurrent subscribe_to_events() calls generate the same ID and both succeed, causing one subscription to silently overwrite another and leading to missed critical events? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Race Condition] Since subscription_id_generator.next() and HashMap insertion are not atomic, can two concurrent threads get the same ID between lines 124-133, causing subscription corruption and event notification delivery to wrong subscribers? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_reconfigurations()] [Duplicate Subscription] Similar to event subscriptions, can concurrent reconfiguration subscription calls at lines 179-188 cause ID collisions leading to overwritten subscriptions and missed epoch transitions? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [State Inconsistency] If subscription insertion succeeds but event_key_subscriptions update fails partway through (lines 142-149), can this leave the system in an inconsistent state where subscription exists but isn't registered for any events, causing memory leaks and orphaned subscriptions? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Validation Bypass] The function rejects empty event_keys AND event_v2_tags (line 116-118), but can an attacker pass empty vectors that pass validation and create subscriptions that never receive events, wasting channel resources? (Low)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Resource Exhaustion] There's no limit on the number of subscriptions per event key. Can an attacker create millions of subscriptions for the same event key, causing notify_event_subscribers() to iterate over massive HashSets and trigger DoS through CPU exhaustion? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Memory Exhaustion] Since event_buffer in EventSubscription has no size limit, can a malicious component subscribe to high-frequency events but never consume notifications, causing unbounded memory growth in event_buffer before notify_subscriber_of_events() is called? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Channel Buffer Behavior] With KLAST queue style and size 100 (line 40-41), if a subscriber processes slowly, old notifications are silently dropped. Can this cause critical consensus events to be missed, leading to validator desynchronization and potential safety violations? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: subscribe_to_events()] [Orphaned Subscriptions] There's no unsubscribe mechanism. If a component crashes or stops, can zombie subscriptions accumulate indefinitely, consuming memory and CPU cycles for notifications that are never consumed? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Missing Subscription Error] At lines 230-238, if a subscription_id exists in event_key_subscriptions but not in subscription_id_to_event_subscription, an error is returned. Can an attacker exploit timing windows to create this inconsistency and halt all event processing? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Partial Notification Failure] If notify_subscriber_of_events() fails for one subscription (lines 254-257), the entire function returns an error. Can a single malicious or buggy subscriber cause all other subscribers to miss events, creating a single point of failure? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Event Cloning Cost] Events are cloned for each subscriber (line 234). For popular events with thousands of subscribers, can this cause excessive memory allocation and CPU usage, leading to performance degradation during high-transaction periods? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Reconfig Detection Bypass] The function checks is_new_epoch_event() on line 243-245, but what if a maliciously crafted event passes this check without being a valid epoch change? Can this trigger false reconfiguration notifications and disrupt validator operations? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Version Ordering] There's no validation that version numbers are monotonically increasing. Can out-of-order event notifications cause subscribers to process events in wrong order, leading to state inconsistencies and consensus failures? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_event_subscribers()] [Event Type Confusion] The function handles both ContractEvent::V1 and V2 (lines 218-224). Can an attacker craft events that match both v1 keys and v2 tags, causing double notifications and potential double-processing of the same logical event? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_events()] [Empty Events Optimization] The function returns early if events are empty (line 313-315). Can an attacker exploit this by sending empty event batches at critical versions to prevent reconfiguration detection and keep subscribers in stale states? (Medium)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_events()] [Reconfig Without Events] If reconfig_event_processed is true but notify_reconfiguration_subscribers() fails (line 323), event subscribers already got notified. Can this cause partial state updates where some components see new configs but others don't? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Empty Subscribers Optimization] The function returns early if reconfig_subscriptions is empty (line 266-268). Can the absence of subscribers allow epochs to transition without any component being aware, potentially causing validators to miss critical configuration updates? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Config Read Failure] If read_on_chain_configs() fails (line 270), no subscribers get notified. Can database read errors during epoch transitions cause validators to operate with stale configs, leading to consensus failures and potential chain splits? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Partial Notification] The loop at lines 271-273 notifies subscribers sequentially. If one fails, do others still get notified, or does the entire operation abort? Can a single failing subscriber prevent all reconfiguration notifications and halt the network? (Critical)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_reconfiguration_subscribers()] [Config Cloning] The new_configs are cloned for each subscriber (line 272). For large config payloads with many subscribers, can this cause memory spikes during epoch transitions, potentially causing validator OOM crashes? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_initial_configs()] [Version Validation] The function accepts any version without validation (line 329-331). Can an attacker call this with an arbitrary version to force config reads at malicious versions, potentially exposing incorrect or manipulated configs? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: notify_initial_configs()] [Access Control] Who can call notify_initial_configs()? If state sync component is compromised, can it spam reconfiguration notifications with arbitrary versions, causing validators to constantly reconfigure and lose liveness? (High)",
  "[File: aptos-core/state-sync/inter-component/event-notifications/src/lib.rs] [Function: read_on_chain_configs()] [State View Creation] The state_view_at_version call at lines 286-296 can fail. If this happens during a critical epoch transition, can it cause the entire reconfiguration to fail and validators to remain in old epoch indefinitely? (Critical)"
]