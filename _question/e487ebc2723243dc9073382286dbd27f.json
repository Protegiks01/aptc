[
  "[File: network/discovery/src/lib.rs] [Network Partition: REST discovery] [Split-Brain] If different validators use different REST endpoints that return inconsistent ValidatorSet data, can this cause a network split where subsets of validators have different peer lists? (Critical)",
  "[File: network/discovery/src/lib.rs] [Byzantine: Validator injection] [Peer Flooding] Can Byzantine validators craft discovery updates with thousands of fake peers to flood the connectivity manager, causing memory exhaustion or connection storms? (High)",
  "[File: network/discovery/src/lib.rs] [Byzantine: Source conflict] [Discovery Source Confusion] If a node runs multiple discovery mechanisms (ValidatorSet + File + REST) simultaneously, can conflicting peer information cause the connectivity manager to thrash between different peer sets? (High)",
  "[File: network/discovery/src/lib.rs] [Byzantine: Update manipulation] [Selective Discovery] Can a Byzantine validator selectively prevent certain peers from being discovered by manipulating the discovery stream, enabling eclipse attacks against specific honest validators? (Critical)",
  "[File: network/discovery/src/lib.rs] [Resource: Memory] [PeerSet Size] Is there a limit on the size of PeerSet returned by discovery streams? Can an attacker inject millions of peers to cause memory exhaustion? (High)",
  "[File: network/discovery/src/lib.rs] [Resource: CPU] [Update Frequency] Can rapid discovery updates (e.g., from file-based discovery with tiny interval) cause excessive CPU usage in the run() loop's update processing? (Medium)",
  "[File: network/discovery/src/lib.rs] [Resource: Metrics] [Counter Overflow] The DISCOVERY_COUNTS metric is incremented on failures. Can persistent failures cause integer overflow in the counter, potentially wrapping to zero and hiding the problem? (Low)",
  "[File: network/discovery/src/lib.rs] [Type Safety: DiscoverySource] [Enum Mismatch] Can the discovery_source field become desynchronized from source_stream variant, causing metrics/logs to report the wrong discovery source? (Low)",
  "[File: network/discovery/src/lib.rs] [Type Safety: Pin usage] [Unsafe Pin] Is the Pin usage in run() sound? Could self-referential structures in source_stream cause memory unsafety if the Pin invariants are violated? (High)",
  "[File: network/discovery/src/lib.rs] [Type Safety: Generic bounds] [OnChainConfigProvider trust] Does the generic bound 'P: OnChainConfigProvider' have any safety implications? Can an untrusted implementation of OnChainConfigProvider inject malicious config data? (Medium)",
  "[File: network/discovery/src/lib.rs] [Error Handling: run()] [Silent Failure] When update.is_err() in run(), only a warning is logged. Can repeated errors cause silent degradation where discovery stops working but the node appears healthy? (High)",
  "[File: network/discovery/src/lib.rs] [Error Handling: try_send] [Full Channel] When update_channel.try_send() fails due to full channel, the update is dropped. Can this cause the validator to miss critical peer updates during epoch transitions? (High)",
  "[File: network/discovery/src/lib.rs] [Error Handling: stream termination] [No Restart Logic] When the discovery stream terminates (returns None), there's no automatic restart. Can this be exploited to permanently disable discovery by causing stream termination? (Critical)",
  "[File: network/discovery/src/lib.rs] [State Consistency: multiple streams] [Discovery Confusion] If multiple DiscoveryChangeListener instances are started for the same network_context, can they send conflicting updates that confuse the connectivity manager? (High)",
  "[File: network/discovery/src/lib.rs] [State Consistency: discovery_source] [Immutability] The discovery_source field is set at construction and never changes. Is this enforced at the type level, or could interior mutability allow it to be changed? (Low)",
  "[File: network/discovery/src/lib.rs] [State Consistency: update ordering] [Update Race] If ValidatorSet discovery sends an update while File discovery sends a conflicting update, which one wins? Can this cause peer list flapping? (Medium)",
  "[File: network/discovery/src/lib.rs] [Crypto: expected_pubkey] [Key Substitution] In validator_set(), the expected_pubkey is used for validation. Can an attacker perform a key substitution attack by exploiting timing windows between key validation and peer connection? (Critical)",
  "[File: network/discovery/src/lib.rs] [Crypto: PeerSet keys] [Key Format Validation] Does the PeerSet returned by discovery streams properly validate public key formats (x25519), or can malformed keys cause crashes in downstream crypto operations? (High)",
  "[File: network/discovery/src/lib.rs] [Crypto: Network address] [Noise Protocol Bypass] When peer addresses include noise-ik keys, are these validated before being passed to the connectivity manager, or can an attacker inject invalid noise keys that bypass authentication? (Critical)",
  "[File: network/discovery/src/lib.rs] [Logging: trace macro] [Log Injection] The trace!() macro logs update contents. Can an attacker craft malicious PeerSet data with control characters or escape sequences that inject false log entries? (Low)",
  "[File: network/discovery/src/lib.rs] [Logging: sensitive data] [Information Disclosure] Do the log messages in run() leak sensitive information like private keys, validator identities, or network topology that could aid attackers? (Medium)",
  "[File: network/discovery/src/lib.rs] [Integration: ConnectivityRequest] [Request Validation] Does the connectivity manager validate ConnectivityRequest::UpdateDiscoveredPeers messages, or can malicious discovery updates directly modify the peer connection state? (Critical)",
  "[File: network/discovery/src/lib.rs] [Integration: DiscoverySource priority] [Source Precedence] If multiple DiscoverySource types send conflicting peer updates, does the connectivity manager have precedence rules, or could this cause non-deterministic peer selection? (High)",
  "[File: network/discovery/src/lib.rs] [Integration: channel semantics] [Message Loss] The update_channel uses try_send() which fails if full. Can message loss during high-frequency updates cause the connectivity manager to have an incomplete view of the network? (High)"
]