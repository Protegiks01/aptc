[
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_sig_tok()] [Struct Handle Index Bounds] For Struct and StructInstantiation cases, can struct_handle_at(struct_handle_idx) be called with out-of-bounds index to cause panic or return wrong struct type? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_sig_tok()] [Type Instantiation Confusion] In StructInstantiation, the list(instantiation)? recursively processes type arguments - can circular type references cause infinite recursion? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_sig_tok()] [Ability Display Injection] The abilities.display_postfix() for function types - can malicious ability set strings inject formatting that corrupts the type display? (Low)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - LdConst] [Constant Data Exposure] The format! directly exposes constant.type_ and constant.data in debug format - can this leak sensitive data like private keys or secrets embedded in bytecode? (Medium)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - LdConst] [Constant Index Bounds] Can constant_at(*idx) be called with out-of-bounds index to access invalid memory or return wrong constant data? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - CopyLoc/MoveLoc/StLoc] [Local Index Overflow] The usize::from(*local_idx) conversion in name_for_parameter_or_local() - can local_idx values cause integer overflow and access wrong local variables? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - CopyLoc/MoveLoc/StLoc] [Type Mismatch] Can inconsistency between the displayed type from type_for_parameter_or_local() and actual runtime type hide type confusion attacks in Move bytecode? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowLoc/ImmBorrowLoc] [Borrow Safety Bypass] If the displayed borrow type doesn't match the actual borrow, can this hide violations of Move's borrow checking that could lead to use-after-free or double-borrow? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowField/ImmBorrowField] [Field Index Validation] Can field_idx be out of bounds and bypass validation, causing name_for_field() to return wrong field names that hide unauthorized field access? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowFieldGeneric/ImmBorrowFieldGeneric] [Generic Field Type Confusion] Can field_instantiation_at() return wrong type arguments that make mutable borrows appear as immutable, hiding write access to critical fields? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowVariantField] [Variant Field Access] For enum variants, can malformed bytecode access fields from wrong variant arms, and would this be visible in disassembly or hidden? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowVariantFieldGeneric] [Variant Type Parameter Abuse] Can variant_field_instantiation_at() return incorrect type parameters that hide attempts to access variant fields with wrong types? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - Pack/Unpack] [Struct Instantiation Type Mismatch] If struct_type_info() returns wrong type arguments for Pack/PackGeneric, can this hide creation of structs with invalid type parameters that bypass capability checks? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - PackGeneric/UnpackGeneric] [Type Parameter Injection] Can struct_instantiation_at() be manipulated to return forged type parameters that make dangerous generic instantiations appear safe? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - PackVariant/UnpackVariant] [Enum Variant Type Confusion] Can variant_struct_type_info() misidentify which variant is being packed/unpacked, hiding attacks that pack one variant but unpack as another? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - PackVariantGeneric/UnpackVariantGeneric] [Variant Generic Abuse] Can struct_variant_instantiation_at() return wrong type parameters for generic enum variants, hiding type safety violations? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - TestVariant] [Variant Test Bypass] If TestVariant instruction's displayed type doesn't match actual test, can malicious code appear to check correct variant but actually test different one? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - TestVariantGeneric] [Generic Variant Test Confusion] Can incorrect type parameters in TestVariantGeneric disassembly hide that code is testing wrong generic variant instantiation? (High)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - Exists/ExistsGeneric] [Resource Existence Check Bypass] Can struct_type_info() misidentify the resource type being checked, hiding existence checks for wrong resources that could lead to double-initialization attacks? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowGlobal/ImmBorrowGlobal] [Global Resource Confusion] If the displayed struct type doesn't match actual borrowed resource, can this hide unauthorized access to global resources like coin stores or governance capabilities? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MutBorrowGlobalGeneric/ImmBorrowGlobalGeneric] [Generic Resource Type Abuse] Can incorrect generic type parameters hide attempts to borrow global resources with wrong type arguments, bypassing capability restrictions? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MoveFrom/MoveFromGeneric] [Resource Theft] Can type mismatches in MoveFrom disassembly hide theft of resources from global storage, such as moving coins from arbitrary accounts? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - MoveTo/MoveToGeneric] [Resource Injection] Can incorrect type display in MoveTo hide injection of malicious resources into global storage under wrong account addresses? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - Call/CallGeneric] [Function Target Confusion] Can get_function_string() return wrong module::function name due to module alias manipulation, hiding calls to malicious functions as calls to trusted ones? (Critical)",
  "[File: third_party/move/tools/move-disassembler/src/disassembler.rs] [Function: disassemble_instruction() - Call] [Parameter Type Mismatch] If disassemble_sig_tok() produces wrong parameter types, can this hide that functions are being called with incompatible arguments that could cause runtime errors or exploits? (High)"
]