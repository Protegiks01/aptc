[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_friend()] [Friend declaration bypass] Can filtering friend declarations break the friend visibility model, either preventing legitimate friends from accessing internal functions or allowing non-friends to bypass access controls? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_friend()] [Circular friend filtering] If module A declares module B as friend and module B declares module A as friend, and one friend declaration is filtered, does this create an asymmetric trust relationship exploitable for unauthorized access? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_friend()] [Friend-only function exposure] If a friend declaration is filtered but the module still has public(friend) functions, are these functions now inaccessible or do they become fully public, creating unintended exposure? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_constant()] [Constant reference dangling] If a constant is filtered but code references it, does this cause compilation errors or can attackers exploit undefined constant values to cause integer overflow, division by zero, or logic errors? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_constant()] [Security constant filtering] Can filtering critical security constants (e.g., MAX_SUPPLY, MIN_STAKE, SLASHING_RATE) allow attackers to compile code with missing bounds checks, enabling economic attacks or fund theft? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_map_constant()] [Constant expression evaluation] If a constant with complex expressions is filtered, can the compiler still evaluate expressions that reference it, potentially causing evaluation errors or incorrect constant propagation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_program()] [Source vs library filtering inconsistency] Does filter_program() apply different filtering logic to source_definitions vs lib_definitions, and can attackers exploit this by placing malicious code in libraries to bypass stricter source filtering rules? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_program()] [Named address map inconsistency] If address definitions are filtered but named_address_maps still contain references to them, can this cause address resolution failures or allow attackers to create address spoofing attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_program()] [Package definition filtering] Can filtering entire PackageDefinition entries cause dependency resolution failures, breaking the build for legitimate packages or allowing malicious packages to masquerade as filtered ones? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_program()] [Empty program after filtering] If all definitions are filtered and filter_program() returns an empty Program, does this cause downstream compilation stages to panic, crash, or enter undefined states? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_definition()] [Definition type confusion] Does filter_definition() properly preserve the Definition enum variant (Module/Address/Script) after filtering, or can type confusion cause modules to be treated as scripts, bypassing module-specific security checks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_definition()] [Recursive filtering] If filter_definition() is called recursively (e.g., Address containing Modules), are there stack overflow risks or infinite recursion vulnerabilities exploitable by crafting deeply nested definitions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_definition()] [None propagation] When filter_definition() returns None, does the caller properly handle this case, or can None values propagate causing panics in code expecting Some values? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_address()] [Empty address after module filtering] If all modules within an address definition are filtered, does filter_address() return Some(empty_address) or None, and can empty addresses cause address resolution errors or spoofing attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_address()] [Module filtering order] Does filter_address() filter modules in a deterministic order, or can non-deterministic filtering cause compilation inconsistencies across different nodes, breaking consensus? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_address()] [Attribute vs module filtering precedence] If an address has filtering attributes but contains modules without filtering attributes, which takes precedence, and can attackers exploit this to bypass filtering? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_script()] [Script function filtering edge case] The comment states 'if the only function in the script is filtered, we consider the whole script is filtered' - but does this handle scripts with zero functions initially, and can empty scripts cause runtime errors or verification bypass? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_script()] [Uses filtering after function filter] Does filter_script() filter use declarations before or after filtering the main function, and can this ordering allow dangling use declarations that reference filtered items to survive? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_script()] [Constant filtering in scripts] Can filtering constants in scripts but not the function that uses them cause undefined behavior, integer overflow, or type checking failures when the script is executed? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_script()] [Spec filtering for scripts] Are spec blocks in scripts properly filtered and validated, or can attackers inject malicious verification conditions that create false security proofs for script transactions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_module()] [Filtered member tracking correctness] Does the filtered_members BTreeSet correctly track all filtered functions and structs by their Symbol, or can name collisions, unicode normalization issues, or symbol table bugs cause incorrect tracking? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_module()] [Spec block orphan removal] The code filters spec blocks whose targets are in filtered_members, but what if a spec block has a wildcard target or module-level target - can these orphaned specs survive and cause verification errors? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_module()] [Two-pass filtering requirement] Why does filter_module() require two passes (filter members, then filter their spec blocks), and can attackers exploit the gap between passes by crafting spec blocks that reference filtered members? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_module()] [is_spec_module filtering] Does filtering apply differently to spec modules vs regular modules, and can attackers place malicious code in spec modules to bypass filtering intended for regular modules? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/filter.rs] [Function: filter_module()] [Empty module after complete filtering] If all members of a module are filtered, does filter_module() return Some(empty_module) or None, and can empty modules break module resolution, dependency tracking, or friend relationships? (Medium)"
]