[
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [TOCTOU race] Between the empty check at line 69-72 and accessing backup_metas[0] at line 73, can another thread modify backup_metas causing out-of-bounds access or using stale first_epoch value in filename generation? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_transaction_backup_range()] [Concurrent modification] Can concurrent calls to compact_transaction_backup_range() with overlapping version ranges create conflicting compacted metadata files that both claim authority over same transaction range, confusing restore coordinator? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: to_text_line()] [Non-atomic serialization] At line 171-172, if Metadata fields are being modified by another thread during serde_json::to_string() call, can inconsistent intermediate state be serialized creating metadata that references mixed backup versions? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [Race in filename generation] Can concurrent calls to name() for same Metadata generate identical filenames that, when passed to save_metadata_line(), cause race conditions where last writer wins but earlier writer's data is lost? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Enum: Metadata] [No integrity check] Throughout the file, metadata structures lack cryptographic signatures or checksums - can an attacker modify serialized metadata files in backup storage without detection, causing restore to use corrupted epoch/transaction ranges? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: EpochEndingBackupMeta] [Manifest tampering] At line 182, manifest FileHandle is just a string with no integrity verification - can attackers replace manifest files with malicious versions containing fake epoch ending ledger infos that change validator set composition? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: TransactionBackupMeta] [No transaction hash] TransactionBackupMeta at line 192-197 doesn't include transaction hash or Merkle root - can attackers provide manifests referencing different transaction data than originally backed up, causing non-deterministic state during restore? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: StateSnapshotBackupMeta] [No state root] StateSnapshotBackupMeta at line 185-190 lacks state root hash from Jellyfish Merkle tree - can modified snapshot manifests cause restore to load incorrect state that doesn't match the blockchain's cryptographic state commitment? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: to_text_line()] [No signing] Metadata serialized at line 171-172 has no signature from backup operator - can malicious metadata files be injected into backup storage, overwriting legitimate metadata and redirecting restore operations to attacker-controlled manifest files? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Memory exhaustion] At line 76-86, can an attacker provide backup_metas vector with millions of entries, causing the res vector to grow unbounded and exhaust memory during TextLine collection, crashing backup compaction operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_statesnapshot_backup_range()] [Collection exhaustion] At line 108-111 collecting into Vec<TextLine>, can extremely large backup_metas with gigabytes of manifest data cause collect() to allocate excessive memory, leading to OOM kill of backup service? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: CompactionTimestampsMeta] [HashMap size] At line 207, can an attacker create CompactionTimestampsMeta with HashMap containing millions of FileHandle entries, each with large path strings, causing serialization at to_text_line() to exhaust memory or create unbounded JSON? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [String allocation] Can repeated calls to name() with extremely large epoch/version numbers cause format!() macro to allocate many large strings, gradually exhausting memory during high-volume backup operations? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Enum: Metadata] [Variant mismatch] When deserializing Metadata enum at line 15-23, can an attacker provide JSON that matches multiple variant patterns (e.g., contains both 'first_epoch' and 'first_version' fields), causing serde to deserialize to wrong variant and trigger type confusion in match arms? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: name()] [Exhaustive match] At line 153-169, if new Metadata variants are added but name() isn't updated to handle them exhaustively, can missing match arms cause panic when serializing new metadata types during backward compatibility scenarios? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Enum: Metadata] [Variant ordering] Can the order of enum variants at line 17-22 affect serde deserialization, where earlier variants are tried first, allowing attacker to craft JSON that matches wrong variant by providing superset of fields? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_epoch_ending_backup()] [Zero epoch] Can an attacker create EpochEndingBackupMeta with first_epoch=0 and last_epoch=0, representing genesis epoch, but with incorrect first_version/last_version that doesn't match genesis state, corrupting initial validator set during full blockchain restore? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_transaction_backup()] [Zero version] Can TransactionBackupMeta be created with first_version=0 (genesis transaction) but manifest pointing to non-genesis data, causing restore to overwrite genesis configuration with arbitrary attacker-controlled state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Epoch boundary] When compacting across epoch boundaries where validator set changes occur, can the compaction at line 66-94 mix metadata from different validator configurations, causing restore to apply blocks with wrong validator signatures? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: new_state_snapshot_backup()] [Version precision] Can StateSnapshotBackupMeta be created with version that doesn't correspond to actual epoch-ending version, causing snapshot restore to use state from mid-epoch when validator set is transitioning, breaking consensus rules? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: EpochEndingBackupMeta] [Manifest URI injection] At line 182, manifest FileHandle could contain malicious URI schemes (e.g., 'file:///', 'smb://') that, when opened during restore, cause backup system to access unintended network resources or local files outside backup directory? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: TransactionBackupMeta] [Dangling reference] Can manifest FileHandle at line 196 reference non-existent or deleted files, causing restore operations to fail partway through transaction replay, leaving blockchain in inconsistent partially-restored state? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Struct: StateSnapshotBackupMeta] [Manifest redirect] Can manifest FileHandle be modified to point to different snapshot data after metadata is created, causing version and epoch fields to mismatch actual snapshot contents loaded during restore? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Manifest duplication] When multiple backup metas at line 78-86 reference same manifest FileHandle, does compacted metadata preserve all references, causing restore to redundantly load same epoch ending data multiple times? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/metadata/mod.rs] [Function: compact_epoch_ending_backup_range()] [Error propagation] At line 77 and 86, if to_text_line() returns Err, the ? operator propagates error abandoning partial results - can this cause incomplete compacted files to be saved, or can the error leave backup storage in inconsistent state with partially written data? (Medium)"
]