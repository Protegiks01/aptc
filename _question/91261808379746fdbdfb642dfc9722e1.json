[
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: new()] [State inconsistency] In the constructor, the next_version is read from the database and initialized as AtomicU64, but can a race condition occur if another thread updates the database version between the read and AtomicU64 initialization, causing version desynchronization across indexer instances? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: update_next_version()] [Integer overflow] Can an attacker cause integer overflow when calculating end_version - 1, especially if end_version is 0 or the minimum u64 value, potentially corrupting the version tracking metadata in IndexerMetadataSchema? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: update_next_version()] [Atomicity violation] The function writes to the database first and then updates the AtomicU64, but can a crash or panic between these two operations cause persistent state divergence where the DB version differs from the in-memory version, breaking indexer consistency? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_with_annotator()] [Version desync] The function calculates end_version from first_version + write_sets.len(), but if write_sets.len() causes integer overflow when added to first_version, can this lead to incorrect version tracking or skipped table info indexing? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: next_version()] [Inconsistent reads] This function reads directly from the database rather than using the AtomicU64 next_version field, can this cause stale reads or inconsistencies when concurrent threads are updating versions via update_next_version()? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_table_info()] [Version calculation] When computing last_version as first_version + write_sets.len(), can an attacker craft inputs where this addition overflows u64::MAX, causing state_view_at_version() to be called with a wrapped-around version number, leading to incorrect state reads? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: get_table_info_with_retry()] [Infinite loop DoS] The retry loop continues indefinitely until table info is found, can an attacker create conditions where a table handle never gets indexed (e.g., malformed data, corrupt DB), causing threads to spin forever and exhausting system resources? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: get_table_info_with_retry()] [Resource exhaustion] With TABLE_INFO_RETRY_TIME_MILLIS set to only 10ms, can multiple concurrent calls to this function for missing table handles cause thread pool exhaustion and validator performance degradation affecting consensus participation? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: get_table_info_with_retry()] [Log spam attack] Although sample! is used for subsequent failures, the first failure is always logged, can an attacker trigger thousands of concurrent lookups for non-existent tables to flood logs and cause disk space exhaustion? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: get_table_info_with_retry()] [Deadlock potential] If get_table_info() internally acquires locks that conflict with table info writing operations in index_with_annotator(), can the infinite retry loop cause deadlocks preventing forward progress? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Struct: IndexerAsyncV2] [Race condition] The pending_on DashMap is shared across threads without explicit synchronization beyond DashMap's internal locks, can concurrent modifications during save_table_info() and collect_table_info_from_table_item() cause lost updates or inconsistent pending state? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: save_table_info()] [TOCTOU vulnerability] The function checks if table info exists with get_table_info(), then removes from pending_on, but can another thread insert the same handle between these operations, causing duplicate processing or lost pending items? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: is_indexer_async_v2_pending_on_empty()] [Race condition] The function iterates over pending_on.iter() while other threads may be modifying it, can this cause inconsistent reads or panic if entries are removed during iteration? (Low)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: clear_pending_on()] [Data loss] Calling clear_pending_on() removes all pending items without processing them, can this be invoked at the wrong time (e.g., during active indexing) causing permanent loss of table metadata requiring node resync? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_table_item()] [Concurrent insertion] When bytes.clone() is inserted into pending_on DashSet, can concurrent threads inserting identical bytes for the same handle cause memory bloat or affect deduplication logic? (Low)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_resource_group()] [BCS bomb] When deserializing ResourceGroup with bcs::from_bytes(), can an attacker craft malicious BCS data with deeply nested structures causing stack overflow or excessive memory allocation leading to node crashes? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_resource_group()] [Unbounded iteration] After deserializing ResourceGroup as BTreeMap, the code iterates over all entries, can an attacker create a resource group with millions of entries causing CPU exhaustion during indexing? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_resource_group()] [Malformed data] If bcs::from_bytes() fails to deserialize due to corrupted data, the error is propagated with '?', but does this cause indexing to halt permanently or can the system recover and continue processing other transactions? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_with_annotator()] [Silent failure] When finish_table_info_parsing() fails, an error is logged and bail! is called, but can this cause partial writes where some table info is committed to the batch but the transaction fails, leading to inconsistent DB state? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: collect_table_info_from_write_op()] [Error suppression] The function returns Result but errors from nested calls like collect_table_info_from_struct() are propagated with '?', can malformed write ops cause the entire batch to fail, preventing valid table info from being indexed? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: finish_table_info_parsing()] [Partial batch] The try_for_each may fail partway through result.iter(), can this leave SchemaBatch in an inconsistent state with some table handles written but not others before write_schemas() is called? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: create_checkpoint()] [Unchecked unwrap] The fs::remove_dir_all(path).unwrap_or(()) silently ignores errors, can filesystem permission issues or corrupted directories cause checkpoint creation to fail silently, leading to incomplete backups? (Low)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: index_with_annotator()] [Write atomicity] SchemaBatch is populated and written with write_schemas(), but if the write fails after partial commits (due to disk space, corruption), can the database be left in an inconsistent state with some table info present and others missing? (High)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: finish_table_info_parsing()] [Duplicate writes] If the same TableHandle appears multiple times in the result HashMap, can batch.put() be called multiple times with different TableInfo values, and which value ultimately persists in the database? (Medium)",
  "[File: aptos-core/storage/indexer/src/db_v2.rs] [Function: get_table_info()] [Stale reads] Reading from self.db.get() without transaction isolation, can another thread be writing the same table handle causing read-write race conditions and stale or torn reads? (Medium)"
]