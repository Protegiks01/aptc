[
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::add_share()] [Weight manipulation] Can a Byzantine validator exploit the share insertion logic to submit multiple shares with different author identities, bypassing the HashMap::insert() deduplication check and artificially inflating total_weight beyond the actual validator stake? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::add_share()] [Integer overflow] Can an attacker cause integer overflow in total_weight calculation by repeatedly adding shares with u64::MAX weight values, wrapping the total_weight counter and bypassing threshold checks to trigger premature aggregation? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::add_share()] [Weight inconsistency] Does the add_share() method verify that the provided weight parameter matches the validator's actual stake in the current epoch, or can a malicious node provide inflated weight values to manipulate threshold calculations? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::add_share()] [Duplicate shares] If a validator submits shares with the same author field but different share data, does the HashMap::insert() overwrite check prevent double-counting the weight, or can timing attacks exploit the is_none() condition to add weight multiple times? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::add_share()] [State corruption] Can concurrent calls to add_share() from multiple threads cause race conditions in updating shares HashMap and total_weight, leading to inconsistent state where total_weight doesn't match the sum of validator weights? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Threshold bypass] Can an attacker exploit the threshold comparison logic to trigger aggregation with total_weight slightly below the required threshold due to race conditions between weight accumulation and threshold checking? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Cryptographic failure] If SecretShare::aggregate() fails with an error in the tokio::spawn_blocking task, the error is only logged via warn! but the system continues - can this lead to missing randomness generation and consensus stalls? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Channel failure] The unbounded_send() call result is explicitly ignored with let _ = - can a full or closed decision_tx channel cause silent loss of aggregated keys, preventing randomness from propagating to consensus and causing liveness failures? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Self share absence] The expect() on get_self_share() assumes self share is always present after threshold is reached - can Byzantine validators exploit timing to trigger aggregation before self share is added, causing panic and validator crash? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Resource exhaustion] Can malicious validators trigger excessive tokio::spawn_blocking tasks by repeatedly meeting threshold with invalid shares that fail aggregation, exhausting the blocking thread pool and degrading validator performance? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [Timing attack] Does the blocking aggregation computation expose timing information about the secret shares being aggregated, potentially leaking information about validator private keys through side-channel analysis? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::try_aggregate()] [State transition] After try_aggregate() returns Either::Right with self_share, the aggregator is moved and can't be used again - can this cause issues if additional shares arrive after threshold is met but before aggregation completes? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::retain()] [Weight desync] The retain() method recalculates total_weight from scratch after filtering shares - can concurrent modifications during this recalculation cause the weight to be calculated incorrectly using stale weight data? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::retain()] [Metadata mismatch] If some shares have matching metadata and others don't, retain() filters them out but can this create a scenario where threshold was previously met but drops below after retain(), causing aggregation failure? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::retain()] [Weight lookup failure] The expect() on weights.get(author) assumes all share authors exist in the weights map - can Byzantine validators add shares with invalid authors that cause panic when retain() is called? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareAggregator::retain()] [Metadata forgery] Does retain() verify that the metadata parameter matches actual block metadata from consensus, or can attackers provide forged metadata to selectively filter out honest validator shares? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share()] [Metadata mismatch attack] In PendingDecision state, can a Byzantine validator send shares with mismatching metadata to cause the ensure! check to fail, preventing honest shares from being added and blocking randomness generation? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share()] [Silent failure] When in Decided state, add_share() returns Ok(()) without adding the share - can this hide Byzantine behavior where validators send conflicting shares after decision, preventing detection of equivocation? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share()] [State race] Can concurrent calls to add_share() on the same SecretShareItem cause one thread to see PendingMetadata while another sees PendingDecision, leading to inconsistent share handling? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share()] [Weight parameter trust] The share_weight parameter is passed by caller rather than looked up internally - can callers provide incorrect weights to bypass threshold checks or manipulate aggregation? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::try_aggregate()] [Memory safety] The std::mem::replace() pattern temporarily replaces self with Author::ONE dummy value - can this cause undefined behavior if another thread accesses the item during replacement? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::try_aggregate()] [Invalid state] If try_aggregate() is called on PendingMetadata or Decided states, it's a no-op - can this hide failures where aggregation should happen but doesn't due to incorrect state management? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::try_aggregate()] [Premature aggregation] Can an attacker exploit the state transition to PendingDecision before enough valid shares are collected, causing aggregation attempts with insufficient honest validator participation? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::try_aggregate()] [Double aggregation] After transitioning to Decided state, can subsequent try_aggregate() calls on stale references trigger duplicate aggregation computations, wasting resources or causing inconsistent randomness? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share_with_metadata()] [State violation] The function bails with error if called in PendingDecision state - can this prevent legitimate self share updates after block metadata is received, blocking randomness for that round? (High)"
]