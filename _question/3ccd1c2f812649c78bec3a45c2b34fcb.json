[
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: Display] [Format Override] The Display trait at lines 267-271 calls to_standard_string() - can format!() macro overrides or debug formatting bypass AIP-40 compliance and leak addresses in non-standard formats? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: LowerHex/UpperHex] [Case Sensitivity] The hex formatting implementations at lines 279-305 provide both lowercase and uppercase - can case-sensitivity issues in downstream parsers cause address validation failures or lookup mismatches? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: TryFrom<&[u8]>] [Slice Conversion] The TryFrom<&[u8]> implementation at lines 313-320 delegates to from_bytes() - can lifetime or ownership issues cause use-after-free if the slice is modified during conversion? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: TryFrom<Vec<u8>>] [Memory Safety] The TryFrom<Vec<u8>> at lines 322-329 consumes the vector - if the conversion fails, is the vector properly dropped or can memory leaks occur in error paths? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: From<&AccountAddress> for String] [Encoding Choice] The From<&AccountAddress> for String at lines 355-359 uses hex::encode() directly without AIP-40 compliance - can this create canonical vs non-canonical string mismatches? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: TryFrom<String>] [Error Propagation] The TryFrom<String> at lines 361-367 calls from_str() - are parse errors properly propagated or can silent failures cause addresses to default to zero corrupting account state? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Const: ZERO, ONE, etc.] [Constant Integrity] The special address constants defined at lines 22-38 are public - can malicious code modify these through unsafe operations or FFI boundaries causing system-wide address corruption? (Critical)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Const: LENGTH] [Size Assumption] The LENGTH constant is hardcoded to 32 bytes at line 24 - if future Move versions change address size, can this cause buffer overflows or truncation in serialization code? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Const: MAX_ADDRESS] [Boundary Value] The MAX_ADDRESS constant (0xFF repeated) at line 26 - is this value properly handled in comparisons, or can arithmetic operations on this value cause overflow? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Function: get_hex_address_one()/two()/etc.] [Const Fn Safety] The const fn helpers at lines 44-78 construct special addresses - can const evaluation bugs cause these constants to have incorrect values at compile time? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Enum: AccountAddressParseError] [Error Exhaustiveness] The error enum at lines 442-466 defines specific error cases - are all possible parsing failures covered, or can unexpected errors cause panics instead of returning Err? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Error: InvalidHexChars] [Error Message Injection] The InvalidHexChars variant at line 448 includes formatted error string - can attackers inject format string specifiers causing crashes or information disclosure in error logs? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Error: LongFormRequiredUnlessSpecial] [Error Logic] The error at lines 459-462 is returned when non-special addresses use short form - is this check consistent across all parsing functions or can some paths bypass it? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Error: InvalidPaddingZeroes] [Special Address Check] The InvalidPaddingZeroes error at lines 464-465 validates special address format - can the padding check be bypassed with unicode zero-width characters or other non-ASCII zeros? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Struct: AccountAddress] [Memory Alignment] The AccountAddress struct at line 18 wraps a [u8; 32] array - can unaligned memory access in unsafe code or FFI cause undefined behavior when accessing address bytes? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Struct: AccountAddress] [Copy Semantics] AccountAddress derives Copy (line 12) - if address validation state is cached elsewhere, can stale copies bypass validation after the original is updated? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Struct: AccountAddress] [Hash Collision] AccountAddress derives Hash (line 12) - are hash collisions possible for adversarially chosen addresses causing HashMap/HashSet lookup failures? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Struct: AccountAddress] [Ordering Semantics] The struct derives Ord and PartialOrd (line 12) - can the lexicographic byte ordering be exploited to manipulate validator selection or priority queue ordering in consensus? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Derive: proptest_derive::Arbitrary] [Fuzzing Bypass] The Arbitrary derivation at line 13 is conditional on test/fuzzing features - can production builds have different behavior than fuzzed builds hiding bugs? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Derive: arbitrary::Arbitrary] [Test Coverage] The arbitrary crate derivation at lines 14-16 generates random addresses for testing - does fuzzing adequately cover special address edge cases and AIP-40 violations? (Low)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Function: to_big_uint()] [Integer Overflow] The to_big_uint() function at lines 147-149 converts address to BigUint using big-endian bytes - can overflow in BigUint operations on adversarial addresses cause panics in arithmetic operations? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Function: to_big_uint()] [Endianness Consistency] Does to_big_uint() use consistent big-endian ordering across all platforms, or can endianness differences cause address comparison failures in multi-platform validator deployments? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: Deref] [Implicit Coercion] The Deref implementation at lines 259-265 allows implicit coercion to [u8; 32] - can this enable accidental modification of address bytes through mutable references? (Medium)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Trait: AsRef] [Lifetime Safety] The AsRef<[u8]> at lines 253-257 returns a slice reference - can lifetime issues cause the slice to outlive the AccountAddress leading to use-after-free? (High)",
  "[File: aptos-core/third_party/move/move-core/types/src/account_address.rs] [Function: from_str()] [Empty String Handling] The from_str() function checks for empty strings at lines 393-395 - but does it properly handle strings with only whitespace, newlines, or control characters that may pass non-empty checks? (Medium)"
]