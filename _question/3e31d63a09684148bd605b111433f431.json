[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Borrow checking] The 'borrow_global' and 'borrow_global_mut' builtins (lines 73-74) access global storage - can attackers exploit gaps in borrow checking to hold multiple mutable borrows simultaneously, violating Rust's aliasing rules and causing race conditions? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Exists race conditions] The 'exists' builtin at line 75 checks resource existence - can attackers exploit TOCTOU (time-of-check-time-of-use) races between exists check and resource access to bypass existence validation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Freeze timing] The 'freeze' builtin at line 76 converts mutable to immutable references - if freeze timing is not atomic with respect to other operations, can attackers exploit race windows where references appear immutable but are still being mutated? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Move_from cleanup] The 'move_from' builtin at line 77 removes resources from storage - if cleanup after move_from is incomplete, can this leave dangling references or ghost resources that violate Move's linear type system? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Move_to duplication] The 'move_to' builtin at line 78 publishes resources - can attackers call move_to multiple times for the same resource type to create duplicate resources, violating the invariant that resources are unique per address? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Old value staleness] The 'old' builtin at line 79 references pre-state values in specs - can attackers exploit stale old values that don't reflect actual pre-state to bypass verification checks or create false postconditions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array Organization] [Array traversal performance] All arrays are unsorted and use linear lookup by downstream code - can attackers exploit the O(n) lookup time to cause performance degradation by using many different keywords, slowing compilation and potentially timing out validator block production? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array Completeness] [Missing future keywords] If Aptos adds new Move keywords in future versions but this legacy file isn't updated, can version-specific contracts exploit keyword gaps to use future keywords as identifiers, breaking forward compatibility? (Medium)"
]