[
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: connect()] [Authentication bypass] The connect() method at lines 17-24 establishes gRPC connections without any authentication mechanism - can an attacker connect to any fullnode endpoint and consume unlimited transaction data, potentially enabling surveillance of all network transactions and user activity? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Struct: FullnodeDataClient] [Authorization missing] The entire FullnodeDataClient implementation (lines 12-152) lacks any authorization checks - can malicious actors establish multiple concurrent connections to exhaust server resources and cause denial of service to legitimate indexers? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: ping()] [Access control] The ping() method at lines 92-118 is accessible without authentication - can attackers use this to enumerate fullnodes, map network topology, and identify targets for more sophisticated attacks? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: get_transactions_from_node()] [Privilege escalation] The get_transactions_from_node() method at lines 120-151 streams transaction data without verifying caller identity - can this be exploited to access sensitive transaction data that should be restricted to authorized indexers only? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: with_interceptor()] [Interceptor bypass] The with_interceptor() method at lines 41-58 allows adding authentication interceptors, but there's no enforcement that interceptors are required - can attackers bypass authentication by connecting directly without interceptors? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: max_decoding_message_size()] [DoS via oversized messages] The max_decoding_message_size() at lines 79-81 has a default of 4MB but can be set to any value - can an attacker configure unlimited message size and send massive protobuf messages to exhaust server memory and crash fullnodes? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: max_encoding_message_size()] [Memory exhaustion] The max_encoding_message_size() at lines 87-89 defaults to usize::MAX - can malicious fullnodes encode enormous response messages (up to system memory limits) to crash client applications and disrupt indexer operations? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Server: max_decoding_message_size()] [Server-side DoS] The server-side max_decoding_message_size() at lines 234-236 can be set arbitrarily - if not configured, can attackers send multi-gigabyte requests to consume all server memory and cause total service unavailability? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Server: max_encoding_message_size()] [Response flooding] The server-side max_encoding_message_size() at lines 242-244 defaults to None - can this lead to fullnodes attempting to encode unlimited transaction batches into single messages, causing OOM crashes and loss of liveness? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: get_transactions_from_node()] [Unbounded streaming] The get_transactions_from_node() streaming method at lines 120-151 has no rate limiting - can attackers request infinite transaction streams and hold connections open indefinitely to exhaust server connection pools and prevent legitimate indexers from syncing? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: send_compressed()] [Compression bomb] The send_compressed() method at lines 65-67 enables compression without size validation - can attackers send highly compressible data that expands exponentially on decompression (e.g., 1MB -> 10GB) to cause OOM and crash receiving nodes? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: accept_compressed()] [Decompression DoS] The accept_compressed() method at lines 71-73 accepts compressed data without bomb detection - can malicious fullnodes send nested compressed payloads that require exponential CPU time to decompress, freezing indexer operations? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Server: accept_compressed()] [Server compression bomb] The server-side accept_compressed() at lines 220-222 enables decompression without protections - can attackers craft malicious compressed requests that expand to gigabytes, consuming all server memory and halting fullnode operations? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Server: send_compressed()] [Malicious compression] The server-side send_compressed() at lines 226-228 could be exploited if compromised - can a Byzantine fullnode send compression bombs to all connected indexers simultaneously to take down the entire indexer infrastructure? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: send_compressed()] [CPU exhaustion] Compression/decompression operations in send_compressed() and accept_compressed() (lines 65-73, 220-228) consume significant CPU - can attackers send streams of data requiring maximum compression effort to exhaust all CPU cores and degrade fullnode consensus participation? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: get_transactions_from_node()] [State machine violation] The server_streaming implementation at lines 120-151 doesn't enforce proper stream state transitions (INIT -> DATA -> BATCH_END) - can attackers send out-of-order status messages to confuse indexers and cause state inconsistencies? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: server_streaming()] [Missing sequence validation] The server_streaming call at line 150 doesn't validate transaction version ordering - can malicious fullnodes send transactions in arbitrary order or with gaps to corrupt indexer databases and cause incorrect state reconstruction? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Type: GetTransactionsFromNodeStream] [Stream interruption] The GetTransactionsFromNodeStream type at line 170-177 can be terminated at any point - can attackers deliberately drop streams mid-batch to leave indexers in inconsistent states where they've processed partial batches and cannot recover? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: get_transactions_from_node()] [Infinite loop] If starting_version and transactions_count are not properly validated, can attackers request version ranges that trigger infinite loops in stream processing (e.g., starting_version=u64::MAX, transactions_count=None)? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: server_streaming()] [Duplicate streaming] The server_streaming method at line 357 doesn't prevent multiple concurrent streams for the same version range - can attackers open thousands of overlapping streams to amplify data transfer and exhaust bandwidth/memory? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Request: GetTransactionsFromNodeRequest] [Integer overflow] The GetTransactionsFromNodeRequest contains starting_version (u64) and transactions_count (u64) - can attackers set starting_version + transactions_count to overflow u64::MAX, causing incorrect end_version calculations and returning wrong transaction ranges? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Request: GetTransactionsFromNodeRequest] [Version underflow] If starting_version is 0 and attackers request negative offsets through manipulated protobuf fields, can this cause underflow when calculating batch boundaries, potentially exposing genesis transactions multiple times? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Response: StreamStatus] [Version range manipulation] The StreamStatus (lines referenced in service) contains start_version and end_version - can malicious fullnodes send conflicting version ranges (e.g., end_version < start_version) to confuse indexers and corrupt their version tracking? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Function: get_transactions_from_node()] [Version spoofing] The streaming implementation doesn't cryptographically verify version numbers - can attackers claim arbitrary version numbers for transactions to trick indexers into accepting forked or invalid chain histories? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.internal.fullnode.v1.tonic.rs] [Request: GetTransactionsFromNodeRequest] [Denial of service via large ranges] If transactions_count is set to u64::MAX, can this request transactions from starting_version to u64::MAX, forcing fullnodes to attempt reading billions of transactions and causing memory exhaustion? (Critical)"
]