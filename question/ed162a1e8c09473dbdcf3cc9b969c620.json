[
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_properly_contains_ty_parameter()] [Nested reference handling] For multiply-nested references (&&&T), does the recursive call (line 260) properly track all levels, or can deep nesting bypass detection? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: check_cyclic_instantiations()] [GlobalEnv mutation] If GlobalEnv is modified by other compiler passes during the iteration (line 13), can this cause race conditions or inconsistent checking results? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: CyclicInstantiationChecker] [Lifetime safety] The checker holds a ModuleEnv<'a> reference (line 24) - if the referenced module is modified or freed during checking, can this cause use-after-free or incorrect analysis? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Mutable chain sharing] The callers_chain is passed as &mut (line 140) - can concurrent or reentrant analysis corrupt this shared mutable state across different checking contexts? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Type equivalence bypass] When comparing callee.to_qualified_id() with ancestor_caller.to_qualified_id() (line 102), can attackers exploit type equivalence rules to make Vec<T> and Vector<T> appear different, hiding cycles? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_contains_ty_parameter()] [Phantom type parameters] Does the checker properly handle phantom type parameters that don't appear in struct fields, or can attackers use phantom parameters to hide cyclic growth? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_properly_contains_ty_parameter()] [Type alias expansion] If Move supports type aliases, are they fully expanded before checking, or can attackers hide type parameters behind aliases to bypass detection? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Instantiate method vulnerabilities] The call to callee_uninst.instantiate(insts) (line 94) performs type substitution - can incorrect substitution rules cause type parameters to be dropped or duplicated, affecting cycle detection? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Type::instantiate_vec bugs] The Type::instantiate_vec call (line 146) substitutes a vector of types - can bugs in this bulk substitution cause some type parameters to be incorrectly substituted? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: gen_generic_insts_for_fun()] [Type parameter generation order] Are type parameters generated in the same order as they appear in function signatures (line 52), or can order mismatches cause incorrect instantiation tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit()] [Post-order traversal gap] Only Pre position is checked (line 77) - can attackers exploit Post or MidPre positions to hide cyclic calls that are only visible after child expression evaluation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Incomplete traversal] The visit_positions_all_visits_return_true method (line 147) may not visit all expression types - can attackers hide calls in unvisited expression categories? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: check()] [Function ordering dependency] Functions are checked in iteration order (line 34) - can the checking order affect detection accuracy if later functions provide context needed for earlier ones? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_callees()] [Unbounded recursion] Can attackers create extremely deep (but not cyclic) call chains that cause stack overflow in the checker before any cycle is detected? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_contains_ty_parameter()] [Deeply nested types] Can maliciously crafted types with extreme nesting depth cause stack overflow in the recursive type checking functions (lines 234-249)? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: report_error()] [Error message DoS] Can attackers create extremely long caller chains that cause report_error() to generate massive error messages, exhausting memory or causing compilation to hang? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Non-recursive cycles] The checker skips non-recursive functions (line 95), but can attackers create mutual recursion (A calls B, B calls A) where each function individually appears non-recursive? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Indirect instantiation growth] Can attackers create functions where type parameters grow through multiple intermediate calls (f<T> calls g<Vec<T>> calls h<Vec<Vec<T>>>), with no single call showing proper containment? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: ty_properly_contains_ty_parameter()] [Equivalent type bypass] Can attackers use type-equivalent representations (e.g., Vec<T> vs custom MyVec<T>) that are semantically identical but structurally different to bypass 'proper containment' detection? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: check_cyclic_instantiations()] [Pipeline ordering] If this checker runs before other type resolution passes, can incomplete type information cause it to miss cyclic instantiations that would be visible later? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: check_cyclic_instantiations()] [Incremental compilation] In incremental compilation scenarios, are all affected modules rechecked when dependencies change, or can stale checking results allow previously-safe code to become unsafe? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: report_error()] [Error handling bypass] After reporting errors (line 207-214), does compilation halt, or can attackers suppress or ignore errors to deploy code with known cyclic instantiation issues? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: gen_generic_insts_for_fun()] [Higher-kinded types] If Move supports higher-kinded types or type constructors, does the simple Type::TypeParameter generation (line 52) properly represent all generic capabilities? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: visit_call()] [Constrained type parameters] Can attackers use constrained type parameters (e.g., T: Copy + Drop) to create cycles that bypass detection because constraints are not tracked in the instantiation chain? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/cyclic_instantiation_checker.rs] [Function: gen_init_callers_chain()] [Module qualification] Does qualified_inst (line 59) properly handle module qualification, or can attackers exploit ambiguous qualification to confuse cycle detection across module boundaries? (Medium)"
]