[
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Deserialization attack] Can a malicious validator craft BCS-encoded state data with mismatched field types (e.g., negative values disguised as u64) that bypass serde deserialization checks, leading to state corruption when FixedSupplyResource is instantiated? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Integer overflow] Can an attacker manipulate on-chain state to set current_supply, max_supply, or total_minted to u64::MAX, causing arithmetic overflow in downstream Rust code that performs calculations with these values without checked arithmetic? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [Invariant violation] Does the new() constructor validate that current_supply <= max_supply and total_minted >= current_supply, or can an attacker create invalid FixedSupplyResource instances with impossible state that violates supply tracking invariants? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [State inconsistency] Can an attacker call new() with total_minted < current_supply, creating a logically impossible state where more tokens exist than have ever been minted, potentially enabling unlimited token creation exploits? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [BCS deserialization] Can malformed BCS bytes cause bcs::from_bytes() to panic or return incorrect field values when deserializing FixedSupplyResource from state storage, leading to node crashes or state inconsistencies across validators? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Fields: burn_events, mint_events] [Event handle manipulation] Can an attacker forge or manipulate the EventHandle keys/counters in burn_events or mint_events fields to emit fake mint/burn events, misleading indexers and creating artificial supply tracking that diverges from actual on-chain state? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: burn_events()] [Event replay] Does burn_events() return a reference that could be cloned and reused to replay historical burn events with modified sequence numbers, potentially confusing event indexers or causing double-counting of burns? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: mint_events()] [Event injection] Can mint_events() be exploited to inject events into the wrong collection's event stream if EventHandle validation is insufficient, allowing cross-collection event pollution and supply tracking confusion? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Event handle exhaustion] Can an attacker cause event handle counter overflow by triggering u64::MAX mint or burn operations, wrapping the sequence number and potentially causing event stream corruption or indexer failures? (Low)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Field: current_supply] [Supply manipulation] Can an attacker directly modify current_supply through unsafe state mutations, bypassing the Move module's increment_supply/decrement_supply logic and creating unlimited tokens without updating total_minted? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Field: max_supply] [Max supply bypass] Can max_supply be changed after collection creation through Rust-side state manipulation, allowing attackers to mint beyond the original fixed supply cap and violating the collection's supply guarantees? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Field: total_minted] [Accounting bypass] Can total_minted be decremented (violating monotonic increase invariant) through state corruption, enabling infinite minting by resetting the mint counter while keeping current_supply high? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: current_supply()] [Race condition] Can concurrent reads of current_supply() during parallel transaction execution return stale values due to missing synchronization, causing validators to disagree on supply limits and accept different transaction sets? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: max_supply()] [TOCTOU vulnerability] Can a time-of-check-time-of-use race exist where max_supply() is read, then modified before a mint operation completes, bypassing supply cap enforcement and allowing over-minting? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: MoveResource] [Serialization non-determinism] Does FixedSupplyResource serialization produce deterministic BCS output across all validators, or can field ordering/padding differences cause merkle root mismatches and consensus failures? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: Serialize] [Serialization size attack] Can an attacker create FixedSupplyResource instances with maliciously large EventHandle internal structures that cause serialization to produce multi-megabyte state values, exhausting storage or causing gas calculation errors? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: Deserialize] [Deserialization DoS] Can specially crafted BCS bytes with deeply nested or recursive structures cause serde deserialization to consume excessive CPU/memory when parsing FixedSupplyResource, enabling validator DoS attacks? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: MoveStructType] [Module name mismatch] Can MODULE_NAME being hardcoded as 'collection' create vulnerabilities if the actual Move module is renamed or moved, causing type confusion where FixedSupplyResource deserializes data from the wrong module? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: MoveStructType] [Struct name collision] Can STRUCT_NAME 'FixedSupply' collide with other structs in different modules, allowing an attacker to substitute a malicious struct that deserializes into FixedSupplyResource with attacker-controlled field values? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: MoveStructType] [Type tag manipulation] Can an attacker forge StructTag references that map to FixedSupply but load data from a completely different resource type, causing type confusion and memory safety violations when fields are accessed? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Move/Rust state divergence] Can inconsistencies between the Move FixedSupply definition and the Rust FixedSupplyResource struct (if Move module is upgraded but Rust code isn't) cause deserialization failures or incorrect field mappings leading to supply tracking errors? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [Direct instantiation bypass] Can Rust code directly instantiate FixedSupplyResource using new() without going through Move's create_fixed_collection(), bypassing on-chain validation and creating invalid supply tracking resources? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: current_supply()] [Getter side effects] Can calling current_supply() or other getter methods trigger unintended side effects (like event emissions or state mutations) if the EventHandle references are improperly implemented, violating read-only assumptions? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: burn_events()] [Reference lifetime] Can the returned &EventHandle reference outlive the FixedSupplyResource borrow, causing use-after-free if the resource is dropped while event operations are in progress? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: mint_events()] [Mutable aliasing] Although mint_events() returns &EventHandle, can unsafe code elsewhere obtain &mut EventHandle simultaneously, violating Rust's aliasing rules and causing undefined behavior during concurrent event emissions? (High)"
]