[
  "[File: aptos-core/crates/aptos-infallible/src/rwlock.rs] [Function: RwLock::read] [Guard drop order] If multiple RwLockReadGuards are held simultaneously and dropped in different orders across validator nodes, can this create non-deterministic behavior in consensus that breaks safety guarantees? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/rwlock.rs] [Function: RwLock::write] [Write priority] Does the underlying std::sync::RwLock implement write-preferring or read-preferring lock policy, and can this preference be exploited to either starve readers or writers in consensus-critical paths? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/rwlock.rs] [Function: RwLock::inner] [Poison bypass] By accessing RwLock::inner (lines 40-42) and using try_read/try_write, can attackers or buggy code bypass poison detection and continue operating on corrupted state, causing consensus divergence? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Zero panic] In the NonZeroUsize! macro's expect on zero (lines 7-13), can validator configuration code pass zero values for critical parameters like validator_set_size or epoch_duration, causing panics that halt node startup and prevent network operation? (Critical)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Initialization timing] Can the NonZeroUsize! macro's panic during validator initialization occur after partial state setup, leaving the node in inconsistent state that requires manual recovery or could cause consensus issues? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Runtime computation] When NonZeroUsize! is applied to runtime-computed values (not constants) in consensus operations like vote counting, can dynamic zero values from Byzantine attacks cause panics mid-consensus and loss of liveness? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Message customization] Does the custom message parameter (lines 11-13) in NonZeroUsize! provide enough context for debugging zero-value panics in production, or can ambiguous messages hide the actual source of configuration errors? (Low)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Integer bounds] When NonZeroUsize! is used with usize::MAX (line 22 test), can this create issues on 32-bit vs 64-bit architectures where usize differs, causing inconsistent behavior in validator capacity calculations? (Low)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Const evaluation] Can NonZeroUsize! be used in const contexts for protocol constants, and if compile-time evaluation fails with zero, does this prevent compilation rather than causing runtime panics? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Type safety] Does NonZeroUsize! enforce type safety to prevent accidental conversion from potentially-zero usize to NonZeroUsize in critical consensus code like quorum threshold calculations? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/nonzero.rs] [Macro: NonZeroUsize!] [Overflow interaction] Can NonZeroUsize! combined with checked! macro arithmetic create scenarios where overflow results in zero, causing both arithmetic error AND zero panic in validator reward calculations? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [System time manipulation] In duration_since_epoch's expect on pre-UNIX_EPOCH time (lines 10-14), can attackers with system-level access manipulate validator node system clocks backwards to cause panics in consensus timeout calculations, creating DoS? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Clock skew] Can validator nodes with system clocks set before 1970 (lines 10-14) participate in consensus with corrupted timestamps, or does the panic prevent such nodes from starting, potentially reducing validator set below safety threshold? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch_at] [Time validation] In duration_since_epoch_at's expect (lines 17-21), can malicious code pass attacker-controlled SystemTime values that are pre-epoch to cause intentional panics in transaction validation or block timestamp checks? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Monotonicity] Does duration_since_epoch guarantee monotonically increasing values, or can system clock adjustments cause non-monotonic timestamps in consensus that break round ordering and safety assumptions? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Overflow handling] Can Duration overflow occur on systems running past year 2262 (u64 nanoseconds limit), and would this cause panics in long-running validators or silent wraparound in timestamp comparisons? (Low)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Concurrent time access] In parallel transaction execution, can concurrent calls to duration_since_epoch return inconsistent values due to system clock changes mid-execution, causing non-deterministic transaction ordering? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Attribute: forbid(unsafe_code)] [Safety guarantee] Does the #![forbid(unsafe_code)] directive (line 5) provide absolute guarantee that no unsafe time manipulation is possible, or can safe code still interact with unsafe system time APIs indirectly? (Low)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Precision loss] Can Duration's nanosecond precision be lost when converted to seconds in consensus timeout calculations, causing rounding errors that lead to premature or delayed timeout events? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch_at] [Reference time attack] Can attackers provide manipulated SystemTime references to duration_since_epoch_at in API endpoints to cause incorrect timestamp validation that accepts expired transactions or blocks? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/time.rs] [Function: duration_since_epoch] [Timezone independence] Is duration_since_epoch properly timezone-independent for consensus operations across global validators, or can timezone/DST changes cause timestamp inconsistencies? (Low)",
  "[File: aptos-core/crates/aptos-infallible/src/lib.rs] [Module integration] [Panic coordination] Can panics from different modules (NonZeroUsize!, Mutex::lock, duration_since_epoch) interact to create cascade failures where one panic triggers others, amplifying impact from single-point failure to total node crash? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/lib.rs] [Module integration] [Dependency ordering] If consensus code uses Mutex to protect arithmetic operations using checked! macro on time values from duration_since_epoch, can improper lock ordering or panic ordering create deadlocks or inconsistent state? (High)",
  "[File: aptos-core/crates/aptos-infallible/src/lib.rs] [Export visibility] [Public API] Are all re-exports (lines 11-14) properly scoped to prevent external crates from misusing infallible primitives in ways that violate Aptos consensus assumptions? (Medium)",
  "[File: aptos-core/crates/aptos-infallible/src/lib.rs] [Module: math] [Consensus arithmetic] When checked! macro is used in consensus round calculations protected by Mutex or RwLock, can race conditions cause arithmetic operations to execute on stale data, producing incorrect results despite overflow checks passing? (High)"
]