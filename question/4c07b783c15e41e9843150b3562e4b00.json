[
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_ty_impl()] [Function tag depth bypass] Can the special depth handling for function reference/mutable reference tags (adding 2 instead of 1) be exploited to bypass depth limits through carefully crafted function types? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_ty_impl()] [Type argument mismatch] Can struct tags with mismatched type argument counts compared to struct type parameter declarations bypass verification and cause type confusion? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeParamMap::match_ty()] [Type deduction bypass] Can attackers craft type patterns that incorrectly match against expected types, enabling unauthorized transaction argument construction that bypasses type validation? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeParamMap::match_ty()] [Inconsistent type param binding] Can concurrent modifications to the type parameter map during matching lead to inconsistent type bindings that violate type safety invariants? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeParamMap::verify_and_extract_type_args()] [Partial type args] Can the filter_map operation skip some type parameter indices, creating incomplete type argument lists that cause type instantiation errors or security vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Struct: AbilityInfo] [Ability cache poisoning] Can the ignored AbilityInfo fields in equality/hash comparisons be exploited to create types that are considered equal but have different ability sets, breaking caching assumptions? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Struct: AbilityInfo] [Phantom mask manipulation] Can attackers manipulate the phantom_ty_args_mask to incorrectly mark type arguments as phantom, enabling ability violations through incorrect polymorphic ability calculations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Enum: Type] [Reference cycle creation] Can attackers create cyclic type references through StructInstantiation type arguments that cause infinite loops during type traversal or ability checking? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Enum: Type] [TyParam in runtime] Can the TyParam variant appear in runtime types despite being intended only for compile-time, and if so, can this be exploited to bypass type instantiation? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Iterator: TypePreorderTraversalIter] [Stack overflow] Can deeply nested types cause stack overflow in the SmallVec-based iterator by exceeding the inline capacity and causing heap allocations in tight loops? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Macro: paranoid_failure] [Sub-status confusion] Can the EPARANOID_FAILURE sub-status be exploited to bypass error handling logic that relies on specific status codes? (Low)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessSpecifier::enables()] [Empty inclusion bypass] Can an attacker exploit the logic where empty inclusions with non-empty exclusions are considered enabling, to bypass access control checks and gain unauthorized resource access? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessSpecifier::enables()] [Exclusion bypass] Can attackers craft access instances that satisfy inclusion clauses but should be blocked by exclusions, exploiting logical errors in the exclusion checking? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessSpecifier::specialize()] [Eval not specialized] Can unspecialized AddressSpecifier::Eval terms remain after specialization, causing access checks to incorrectly deny legitimate accesses or allow unauthorized ones? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessSpecifierClause::includes()] [Write subsumes read bypass] Can the logic where Writes enables both read and write access be exploited to escalate read-only access to write access in unintended contexts? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessSpecifierClause::excludes()] [Reads exclusion confusion] Can the asymmetric interpretation where !reads excludes both read and write but !writes only excludes write be exploited to bypass access controls? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: ResourceSpecifier::matches()] [Type instantiation bypass] Can attackers use ResourceInstantiation with carefully crafted type arguments to bypass Resource-level restrictions that should apply to all instantiations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: ResourceSpecifier::matches()] [Module ID manipulation] Can malicious modules forge ModuleId to match DeclaredInModule restrictions incorrectly, gaining unauthorized access to resources they shouldn't control? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AddressSpecifier::matches()] [Eval false negative] Can AddressSpecifier::Eval always returning false in matches() be exploited to deny legitimate accesses or create inconsistent access control state? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AddressSpecifier::specialize()] [Function evaluation error] Can errors during eval_address_specifier_function be caught and handled incorrectly, leading to partially specialized access specifiers that violate security invariants? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AddressSpecifierFunction::parse()] [Function string injection] Can attackers inject malicious function strings that match legitimate patterns but point to different implementations, bypassing access control checks? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AddressSpecifierFunction::eval()] [SignerRef extraction attack] Can the multi-step signer address extraction (borrow_signer -> value_as Reference -> read_ref -> value_as AccountAddress) be exploited to extract addresses from invalid signer references? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AddressSpecifierFunction::eval()] [ObjectAddress unimplemented] Can the unimplemented ObjectAddress function be exploited if object-based access control is added in the future without proper implementation? (Low)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Function: AccessInstance::new()] [Invalid instance construction] Can AccessInstance be constructed with inconsistent resource, instance, and address combinations that bypass access control validation? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs] [Enum: AccessSpecifier] [Constraint normalization bypass] Can unnormalized or partially simplified Constraint specifiers bypass optimization assumptions and cause incorrect access control decisions? (High)"
]