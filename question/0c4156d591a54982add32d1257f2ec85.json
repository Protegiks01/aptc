[
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_struct_definition()] [Index bounds validation] Does idx_to_struct_name_ref properly validate the StructNameIndex bounds before access, or can an out-of-bounds index cause panics that crash validators? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_load_type()] [Recursive type depth] When creating types via ty_builder.create_ty, is there a recursion depth limit to prevent stack overflow from deeply nested generic types like Vec<Vec<Vec<...>>>? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_instantiated_function()] [Type argument count validation] Does the function validate that len(ty_args) matches the function's generic parameter count before instantiation, preventing arity mismatch crashes? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: build_instantiated_function()] [Ability constraint checking] When instantiating generic functions, are ability constraints (copy, drop, store, key) properly validated for all type arguments to prevent resource safety violations? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_script()] [Script size validation] Is there a maximum size limit for serialized_script to prevent memory exhaustion from maliciously large scripts? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_deserialize_and_cache_script()] [Bytecode format validation] Does deserialization properly validate the script bytecode format, or can malformed bytecode with invalid opcodes or operands pass deserialization and crash during execution? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_module_storage()] [Storage interface soundness] The function returns a trait object - can type confusion or vtable corruption allow callers to access storage methods they shouldn't, bypassing access controls? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: runtime_environment()] [Environment consistency] The runtime environment is accessed through module_storage - can inconsistent environment configurations across different storage instances cause non-deterministic behavior? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_get_existing_deserialized_module()] [Deserialized vs verified state] The function retrieves deserialized (but not necessarily verified) modules for metadata - can this create a side channel where unverified module data leaks through metadata access? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_get_existing_eagerly_verified_module()] [Verification state guarantee] Does 'eagerly verified' guarantee full transitive verification of all dependencies, or can partially verified module graphs exist where some modules bypass verification? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Struct: EagerLoader] [Lifetime management] The loader has lifetime 'a bound to module_storage - can lifetime extension bugs allow the loader to outlive its storage, causing use-after-free or dangling pointer issues? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: is_lazy_loading_enabled()] [Debug assertion bypass] The debug_assert on line 155 checks that lazy loading is disabled - can this assertion be stripped in release builds, allowing eager loader to be used when lazy loading is enabled, causing inconsistent behavior? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_instantiated_function()] [LegacyLoaderConfig validation] The config parameter controls gas charging behavior - can malicious transactions provide manipulated config objects to bypass gas charges? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_script()] [Config flag consistency] Config is checked twice (lines 333 and 346) for different charging modes - can inconsistent config state between checks cause partial gas charging where some dependencies are free? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: runtime_environment().vm_config()] [VM config immutability] Are VM config settings immutable after initialization, or can they be modified mid-execution to change loader behavior and bypass security checks? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: build_locally_verified_script()] [Local verification soundness] Does local verification check all security-critical properties, or can locally-verified scripts violate global invariants when combined with other modules, enabling resource duplication? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: build_verified_script()] [Cross-module verification] When building verified scripts with immediate_dependencies, are interface boundaries properly checked to prevent type confusion attacks across module boundaries? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: build_instantiated_script()] [Script instantiation safety] When instantiating scripts with type arguments, can an attacker provide type arguments that violate script preconditions, bypassing entry function checks and executing privileged operations? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_instantiated_function()] [Entry function privilege escalation] Can an attacker craft type arguments that allow calling private or internal functions as entry points, bypassing access control checks? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: unmetered_load_type()] [Phantom type exploitation] When loading types with phantom type parameters, can an attacker exploit phantom types that should have no runtime representation to cause type confusion or bypass ability checks? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_struct_definition()] [Traversal context pollution] The traversal_context parameter is mutable and passed through multiple loader calls - can an attacker pollute or corrupt this context to affect subsequent module loads in the same transaction? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: charge_native_result_load_module()] [Arena allocator exhaustion] The traversal_context.referenced_module_ids arena is used for allocations - can unbounded allocations during deep dependency traversals exhaust arena memory and crash validators? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_script()] [Script reference arena] The traversal_context.referenced_scripts arena (line 335) - can an attacker execute transactions that reference thousands of scripts to exhaust arena memory? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: load_instantiated_function()] [Module ID deduplication] Does the arena allocator properly deduplicate module IDs, or can repeated references to the same module consume excessive memory? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/loader/eager.rs] [Function: deserialize_into_script()] [Bytecode version mismatch] When deserializing scripts, are bytecode version numbers properly validated to prevent execution of scripts compiled for incompatible VM versions that could have different security properties? (High)"
]