[
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_call_generic()] [CORE_CODE_ADDRESS Check] Line 211 checks *module_id.address() == CORE_CODE_ADDRESS. Can an attacker exploit address collision vulnerabilities or CREATE2-style attacks to generate addresses matching CORE_CODE_ADDRESS? (Critical)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_call_generic()] [Event Module Leak] Lines 213-215 enable memory leak for event module in feature version >= 4. Is this intentional, and can it be exploited for DoS by repeatedly calling event module functions to exhaust memory? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Field: should_leak_memory_for_native] [State Persistence] Line 46 initializes should_leak_memory_for_native to false, but line 211 sets it per call. Can this flag persist incorrectly across multiple function calls, causing wrong memory tracking for subsequent operations? (High)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_native_function_before_execution()] [Selective Memory Release] Line 228 conditionally releases argument memory based on should_leak_memory_for_native. Can interleaved calls to table/event and other natives cause memory tracking corruption? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: use_heap_memory()] [Quota Zeroing on Error] Line 59 sets memory_quota to 0 before returning error. Can this premature zeroing cause subsequent memory release operations to incorrectly accumulate quota from zero, enabling quota overflow? (High)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_load_resource()] [Partial Transaction State] If abstract_heap_size calculation fails at line 280, the transaction aborts but memory may have been charged by the base meter. Can this state inconsistency be exploited across multiple failed transaction attempts? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_native_function()] [Return Value Error Handling] If abstract_heap_size fails at line 257, memory has not been charged but the base meter may have charged gas. Can repeated failures cause gas depletion without corresponding memory accounting? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_pack()] [Try-Fold Error Recovery] The try_fold at lines 335-342 short-circuits on error. If it fails partway through, are partial stack size calculations lost, allowing memory tracking to desynchronize? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_drop_frame()] [Frame Drop Failure] Lines 527-537 try_fold to calculate heap sizes of locals. If this fails, the frame drop aborts but stack may be partially unwound. Can this leave memory in an inconsistent state? (High)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Macro: delegate_mut] [Side Effect Ordering] Lines 88-96 define delegation that calls base meter methods. Can ordering issues between memory tracking and base meter charges cause race conditions or inconsistent state? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_pop()] [Base Meter Call Order] Line 298 calls self.base.charge_pop after releasing heap memory. If base.charge_pop fails, has memory been incorrectly released without the pop completing? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_ld_const_after_deserialization()] [Deserialization Memory] Line 306-313 charges memory after deserialization. Can specially crafted constants have large deserialized sizes that exhaust memory before quota checks activate? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_copy_loc()] [Cached Value Bypass] Line 324 calls charge_copy_loc_cached which is implemented in CacheValueSizes trait. Can cached size values become stale or manipulated to report incorrect sizes? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_read_ref_cached()] [Cache Manipulation] Lines 548-556 use cached stack and heap sizes. Can attackers poison the cache with incorrect sizes to bypass memory limits on subsequent operations? (High)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_vec_pack()] [Vector Size Manipulation] Lines 458-469 charge memory based on abstract_packed_size of arguments. Can attackers create vectors with many small elements that report deceptive packed sizes? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_vec_unpack()] [Expect vs Actual Mismatch] Line 477 takes expect_num_elements parameter. If actual element count differs, can this cause memory tracking errors where released memory doesn't match allocated memory? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_vec_pop_back()] [Optional Value Handling] Line 510 only releases memory if val is Some. Can repeated pop operations on empty vectors cause asymmetric memory tracking where pushes charge but pops don't release? (Low)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_vec_push_back()] [Unbounded Growth] Line 497-505 charges per-element without checking total vector size. Can attackers create extremely large vectors through incremental pushes that bypass aggregate memory checks? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_call_generic()] [Type Argument Size] Line 206 receives ty_args iterator. Can extremely large or deeply nested type arguments consume unbounded memory before quota checks activate? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_pack()] [Generic Pack Attack] Line 329 takes is_generic parameter but doesn't use it for memory tracking. Can generic type instantiations with large type arguments bypass memory checks? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_pack_closure()] [Closure Capture Size] Lines 370-387 charge memory for closure packing. Can attackers capture large values in closures to exhaust memory, especially if closure sizes are not properly tracked? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_borrow_global()] [Borrowed Reference Leak] Delegated at line 153-159, no memory tracking for borrowed references. Can long-lived references to large resources cause unbounded memory consumption? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_move_from()] [Move From Memory Leak] Delegated at lines 169-174. When resources are moved from storage, is heap memory properly tracked for the in-memory representation? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_move_to()] [Move To Memory] Delegated at lines 176-182. When moving resources to storage, is memory released immediately or does it linger until transaction commit? (Low)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_read_ref()] [Reference Copy Memory] Lines 391-398 charge memory for reading references. Can repeated reads of the same reference cause multiplicative memory consumption through repeated heap allocations? (Medium)"
]