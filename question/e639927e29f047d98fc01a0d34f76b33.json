[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Parser bypass] Does the KEYWORDS array contain all keywords that get_name_token() in lexer.rs recognizes, or can an attacker exploit missing entries (like 'inline' at lexer.rs:798 or 'has' missing from lexer matching) to bypass keyword validation in documentation or tooling? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Inconsistency attack] The KEYWORDS array includes 'has' at line 17, but get_name_token() in lexer.rs:781-812 does NOT recognize 'has' as a keyword token - can attackers use 'has' as an identifier to create malicious smart contracts that bypass security checks expecting it to be reserved? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Inconsistency attack] The KEYWORDS array includes 'friend' at line 15, and lexer.rs recognizes it at line 793, but can timing differences between when this keyword was added to each location create compiler version inconsistencies allowing malicious code deployment? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Missing keyword] The lexer.rs recognizes 'inline' as Tok::Inline at line 798, but this keyword is NOT present in the KEYWORDS array - can this discrepancy allow documentation generators or static analysis tools to misclassify 'inline' as a user identifier, hiding malicious code? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Specification bypass] The CONTEXTUAL_KEYWORDS array defines spec language keywords like 'aborts_if', 'ensures', 'requires' - if these are not properly reserved in all compiler phases, can attackers define functions or variables with these names to shadow or bypass formal verification checks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Access control bypass] The 'Self' keyword is in CONTEXTUAL_KEYWORDS at line 60 - can attackers exploit case-sensitivity issues (Self vs self) to bypass type checking or access control in Move modules, potentially accessing private resources? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Verification bypass] Keywords like 'axiom', 'assume', 'decreases' control formal verification behavior - are these properly enforced to prevent attackers from injecting false assumptions that bypass invariant checking, allowing resource theft or double-spending? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: PRIMITIVE_TYPES] [Type confusion] The PRIMITIVE_TYPES array defines 'u8', 'u16', 'u32', 'u64', 'u128', 'u256' - but lexer.rs:735-756 recognizes typed number suffixes independently - can discrepancies allow attackers to craft type-confused values that bypass gas metering or cause integer overflow in critical operations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: PRIMITIVE_TYPES] [Missing type validation] The PRIMITIVE_TYPES array includes 'bool' and 'vector' but these are not checked in get_number_maybe_with_suffix() - can attackers craft malformed type annotations that bypass validation, causing VM crashes or determinism violations across validators? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: PRIMITIVE_TYPES] [Integer type bounds] PRIMITIVE_TYPES includes 'u256' which is Aptos-specific - if tooling relies on this array but doesn't validate maximum integer sizes, can attackers cause integer overflow in gas calculations or state storage, potentially stealing funds or halting the network? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Builtin shadowing] The BUILTINS array defines 'borrow_global', 'borrow_global_mut', 'move_to', 'move_from' - can attackers define user functions with these names in specific scopes to shadow builtins and bypass resource safety checks, enabling double-spending or unauthorized resource access? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Access control bypass] 'exists', 'borrow_global', 'borrow_global_mut' are resource access primitives - if these are not strictly reserved in all contexts, can malicious modules redefine them to bypass acquires declarations and access resources without proper authorization? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Verification bypass] The 'old' builtin at line 79 is used in specification contexts - can attackers exploit incomplete reservation of this keyword to inject fake 'old' values in postconditions, bypassing state transition invariants and enabling unauthorized state modifications? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [State integrity] 'freeze' builtin converts mutable references to immutable - if not properly reserved, can attackers create confusion between the builtin and user-defined 'freeze' functions to bypass borrow checking, potentially causing race conditions or state corruption? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [All Arrays] [Encoding attack] All keyword arrays use ASCII strings - are Unicode normalization attacks possible where attackers use lookalike Unicode characters (e.g., Cyrillic 'a') to bypass keyword checks and inject malicious code that appears legitimate in documentation? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [All Arrays] [Case sensitivity] None of the arrays specify case-sensitivity rules - can attackers exploit case variations (e.g., 'Abort', 'ABORT', 'aBort') to bypass keyword reservation and use reserved words as identifiers in ways that confuse static analysis or create namespace collisions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [All Arrays] [Immutability guarantee] These arrays are 'pub const' but in Rust, const array contents are mutable if obtained as mutable references - can compiler plugins or procedural macros modify these keyword definitions at compile time to inject malicious keywords or remove security-critical ones? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Determinism violation] The KEYWORDS array order is not alphabetically sorted - if different compiler versions or platforms iterate this array differently during compilation, can this cause non-deterministic bytecode generation across validators, leading to consensus failures? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Missing reservations] Contextual keywords like 'package', 'phantom', 'mut' may not be reserved in all parsing contexts - can attackers use these as struct field names or module names to cause parser confusion, potentially bypassing access control checks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Spec language injection] The spec keywords 'aborts_with', 'succeeds_if', 'modifies' define verification conditions - if these are not properly isolated from executable code, can attackers inject specification statements into runtime code to manipulate execution flow or bypass security checks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: PRIMITIVE_TYPES] [Missing signed types] The array includes unsigned types (u8-u256) but lexer.rs:737-750 recognizes signed types (i8, i16, i32, i64, i128, i256) - can this inconsistency cause tooling to mishandle signed integers, leading to type confusion in arithmetic operations that could cause integer overflow or underflow? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: BUILTINS] [Incomplete list] The BUILTINS array has only 8 entries but Move may have additional builtins in newer versions - can missing entries cause documentation generators or IDE plugins to misclassify actual builtins as user functions, hiding dangerous operations from security reviews? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [All Arrays] [Version skew] This file is in 'legacy-move-compiler' path - if newer compiler versions have different keyword sets but tooling uses this legacy file, can version skew allow code that's valid in one compiler to fail unexpectedly in another, potentially bricking deployed contracts? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: KEYWORDS] [Missing 'entry'] Modern Move has 'entry' keyword for entry functions - if this is missing from the array but recognized by newer compilers, can attackers exploit the discrepancy to deploy contracts with ambiguous entry point definitions that behave differently than expected? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/keywords.rs] [Array: CONTEXTUAL_KEYWORDS] [Pragma abuse] The 'pragma' keyword at line 58 controls compiler behavior - if not properly validated, can attackers inject malicious pragmas that disable safety checks, alter gas metering, or enable unsafe compiler optimizations that break consensus? (Critical)"
]