[
  "[File: types/src/account_config/resources/fixed_supply.rs] [Field: current_supply] [Underflow on burn] If decrement_supply in Move uses unchecked subtraction and current_supply is 0, can burning cause underflow to u64::MAX, appearing as infinite supply and breaking all supply cap enforcement? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Field: total_minted] [Overflow on mint] Can total_minted overflow to 0 after u64::MAX mints, causing the collection to appear freshly created with 0 mints, potentially bypassing max_supply checks that compare against total_minted? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Fields: current_supply, max_supply] [Comparison exploit] Can an attacker set max_supply to 0 and current_supply to u64::MAX through state corruption, causing supply checks (current_supply <= max_supply) to always fail and permanently DOS the collection? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Upgrade to ConcurrentSupply] When upgrade_to_concurrent() migrates FixedSupply to ConcurrentSupply, can race conditions cause FixedSupplyResource deserialization to fail partway through migration, leaving collections in an indeterminate state? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Migration data loss] During migration from FixedSupply to ConcurrentSupply, can current_supply, max_supply, or total_minted values be lost or incorrectly transferred, enabling supply cap bypass or token loss? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: total_minted()] [Monotonicity violation] Can total_minted() ever return a value less than a previous call (violating monotonic increase), indicating state corruption or rollback that could enable replay attacks or double-minting? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: current_supply()] [Negative supply] Although current_supply is u64, can integer underflow in Move cause it to wrap to near-maximum values, making current_supply() report billions of tokens in collections that actually have negative effective supply? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: PartialEq] [Equality bypass] Can two FixedSupplyResource instances with different supply values be considered equal if EventHandle comparison is flawed, causing supply tracking to accept invalid state transitions as no-ops? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Trait: Debug] [Information leakage] Does the Debug implementation expose sensitive internal EventHandle counters or GUID information that could be exploited to predict future event sequence numbers or forge events? (Low)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Cache poisoning] Can stale FixedSupplyResource values be cached in the Rust layer without proper invalidation, causing validators to operate on outdated supply information and accept conflicting transactions? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [Storage bypass] Can new() be used to create FixedSupplyResource instances that bypass AptosDB storage layer validation, allowing in-memory supply manipulation without corresponding state commitment? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Parallel execution] Can Block-STM parallel execution cause multiple transactions to read the same current_supply value and all pass max_supply checks simultaneously, resulting in over-minting when transactions are committed? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: current_supply()] [Non-atomic read] Is current_supply() read atomic with respect to concurrent mints/burns, or can partial updates be observed causing current_supply to temporarily violate invariants (e.g., exceeding max_supply)? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Field reordering attack] Can BCS deserialization be exploited by reordering fields in the byte stream to swap current_supply with max_supply, causing the collection to accept mints far beyond the intended cap? (Critical)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Extra field injection] Can BCS-encoded data with extra trailing fields be deserialized into FixedSupplyResource without error, potentially hiding malicious data that's later accessed through unsafe casting or type confusion? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Missing field exploit] Can BCS deserialization succeed with fewer fields than FixedSupplyResource expects, causing fields to be zero-initialized and creating collections with max_supply=0 that can't mint any tokens? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: mint_events()] [Indexer poisoning] Can the EventHandle returned by mint_events() be manipulated to reference a different event stream, causing indexers to process events from the wrong collection and misreport supply statistics? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: burn_events()] [Event sequence manipulation] Can burn_events() EventHandle counter be set to u64::MAX-1, causing the next burn to wrap to 0 and potentially overwrite or corrupt historical burn events in the indexer? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Const: MODULE_NAME] [Hardcoded module path] Is MODULE_NAME='collection' hardcoded safely, or can the Move module be renamed/moved to a different address (e.g., during protocol upgrade) causing FixedSupplyResource deserialization to fail and break all fixed-supply collections? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Const: STRUCT_NAME] [Struct rename risk] If the Move struct name changes from 'FixedSupply' to 'FixedSupplyV2', will FixedSupplyResource fail to deserialize, or will it silently deserialize the wrong struct type causing critical state misinterpretation? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [No validation] Does new() perform ANY validation of invariants (current_supply <= max_supply, max_supply > 0, total_minted >= current_supply), or can completely invalid resource states be created by calling new() with arbitrary parameters? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Function: new()] [EventHandle validation] Does new() validate that burn_events and mint_events are distinct EventHandles with different GUIDs, or can passing the same EventHandle twice cause mint/burn events to collide and corrupt both streams? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Send/Sync safety] Is FixedSupplyResource safe to send across threads (if EventHandle contains raw pointers or non-Send types), or can concurrent access from multiple validator threads cause data races? (High)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Drop safety] Does FixedSupplyResource implement Drop, and if so, can dropping it trigger unsafe cleanup that could panic or leave event handles in inconsistent state if drop occurs during transaction execution? (Medium)",
  "[File: types/src/account_config/resources/fixed_supply.rs] [Struct: FixedSupplyResource] [Byzantine validator attack] Can a Byzantine validator (<1/3 threshold) propose blocks with maliciously crafted FixedSupplyResource state that passes BCS deserialization but contains impossible supply values, causing honest validators to diverge when validating mint transactions? (Critical)"
]