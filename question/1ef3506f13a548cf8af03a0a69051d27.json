[
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Block size validation bypass] Is block_size (line 188) validated to be within safe bounds, or can an attacker set it to 0 or negative values causing division-by-zero errors or integer underflow in RocksDB calculations? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Bloom filter bits overflow] Can bloom_filter_bits parameter (line 201) be set to extreme values (e.g., f64::INFINITY or NaN) causing undefined behavior in bloom filter allocation or corrupting memory? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Bloom level manipulation] Can bloom_before_level (line 202) be set to negative values or values exceeding max LSM tree depth, causing the hybrid ribbon filter to apply incorrectly and degrade query performance? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Cache coherency violation] When multiple column families share block_cache (line 198), can cache invalidation for one CF fail to propagate to others, causing stale reads that violate transaction serializability? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Index cache staleness] Does cache_index_and_filter_blocks (line 192) properly invalidate cached indexes after compaction, or can validators query stale indexes that point to deleted data, causing state lookup failures? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_kv_db_column_families()] [Pruning bypass] Can an attacker prevent pruning by corrupting STALE_STATE_VALUE_INDEX_CF_NAME entries, causing historical state to accumulate indefinitely and exhausting disk space on validator nodes? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_merkle_db_column_families()] [Stale node resurrection] Can an attacker exploit STALE_NODE_INDEX_CF_NAME and STALE_NODE_INDEX_CROSS_EPOCH_CF_NAME to resurrect deleted Merkle nodes, enabling replay of old state transitions and double-spending attacks? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_kv_db_new_key_column_families()] [Incomplete migration] The comment on line 147 mentions 'we still need this cf before deleting all the write callsites' - can an attacker exploit this transitional state to cause writes to old schema that are invisible to new schema readers, creating state divergence? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_kv_db_new_key_column_families()] [Schema version confusion] Can validators running different code versions interpret STATE_VALUE_INDEX_CF_NAME differently, causing some to write key-based indexes while others write hash-based indexes, breaking state queries? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_merkle_db_column_families()] [Merkle node injection] Can an attacker write directly to JELLYFISH_MERKLE_NODE_CF_NAME with crafted node hashes that form valid Merkle paths but commit to fraudulent state, allowing them to forge state proofs? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: state_merkle_db_column_families()] [Cross-epoch node reuse] Does STALE_NODE_INDEX_CROSS_EPOCH_CF_NAME properly prevent reuse of Merkle nodes across epochs, or can an attacker create Merkle paths that span epochs with incompatible state transitions? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: event_db_column_families()] [Event accumulator bypass] Can an attacker modify EVENT_ACCUMULATOR_CF_NAME without updating corresponding events in EVENT_CF_NAME, causing event Merkle roots to diverge from actual emitted events and breaking smart contract invariants? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: event_db_column_families()] [Event key collision] Can an attacker craft event keys that collide in EVENT_BY_KEY_CF_NAME, causing events from different contracts to be grouped together and returned incorrectly to event queries? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: ledger_metadata_db_column_families()] [Block-version desynchronization] Can an attacker cause BLOCK_BY_VERSION_CF_NAME and VERSION_DATA_CF_NAME to desynchronize, where a version maps to different blocks in different indexes, causing consensus split-brain conditions? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: ledger_metadata_db_column_families()] [Epoch boundary manipulation] Can an attacker manipulate EPOCH_BY_VERSION_CF_NAME to cause validators to disagree on epoch boundaries, applying wrong validator sets and breaking Byzantine fault tolerance? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_cfds()] [Post-processor bypass] Can an attacker provide a no-op cf_opts_post_processor that skips critical security configurations like prefix extractors, causing state key lookups to fail and halting transaction processing? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: with_state_key_extractor_processor()] [Conditional extractor attack] Can an attacker exploit the conditional application of prefix extractors (lines 226-229) to cause some state CFs to have extractors while others don't, leading to lookup inconsistencies and state corruption? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_hot_state_kv_shard_cfds()] [Hot shard overflow] Can an attacker force all state accesses into HOT_STATE_VALUE_BY_KEY_HASH_CF_NAME, overwhelming the hot tier and causing hot shard database to grow unbounded, exhausting disk space? (High)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_ledger_cfds()] [Write set inconsistency] Can an attacker exploit WRITE_SET_CF_NAME in the ledger database to create inconsistencies with write sets in the dedicated write_set database, causing state application to use wrong write set data? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_transaction_cfds()] [Transaction ordering attack] Can an attacker manipulate ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME to reorder transactions for API responses while TRANSACTION_CF_NAME maintains correct order, causing user interfaces to show incorrect transaction sequences? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_persisted_auxiliary_info_cfds()] [Auxiliary info poisoning] Can an attacker corrupt PERSISTED_AUXILIARY_INFO_CF_NAME to provide false auxiliary data that affects consensus decisions, such as incorrect peer information or network statistics? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_transaction_accumulator_cfds()] [Accumulator root forgery] Can an attacker create inconsistencies between TRANSACTION_ACCUMULATOR_CF_NAME leaves and TRANSACTION_ACCUMULATOR_HASH_CF_NAME internal nodes, causing validators to compute different transaction accumulator roots? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table_options()] [Partition filter fragmentation] Does set_partition_filters (line 191) create vulnerability where an attacker can cause filter fragmentation by crafting keys that force creation of many filter partitions, degrading bloom filter effectiveness? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/db_options.rs] [Function: gen_table\n\n### Citations\n\n**File:** storage/aptosdb/src/db_options.rs (L1-348)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::schema::*;\nuse aptos_config::config::{IndexType, RocksdbConfig};\nuse aptos_schemadb::{\n    BlockBasedIndexType, BlockBasedOptions, Cache, ColumnFamilyDescriptor, ColumnFamilyName,\n    DBCompressionType, Options, SliceTransform, DEFAULT_COLUMN_FAMILY_NAME,\n};\nuse aptos_types::transaction::Version;\n\nconst VERSION_SIZE: usize = std::mem::size_of::<Version>();\n\npub(super) fn ledger_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        BLOCK_BY_VERSION_CF_NAME,\n        BLOCK_INFO_CF_NAME,\n        EPOCH_BY_VERSION_CF_NAME,\n        EVENT_ACCUMULATOR_CF_NAME,\n        EVENT_BY_KEY_CF_NAME,\n        EVENT_BY_VERSION_CF_NAME,\n        EVENT_CF_NAME,\n        LEDGER_INFO_CF_NAME,\n        PERSISTED_AUXILIARY_INFO_CF_NAME,\n        STALE_STATE_VALUE_INDEX_CF_NAME,\n        STATE_VALUE_CF_NAME,\n        TRANSACTION_CF_NAME,\n        TRANSACTION_ACCUMULATOR_CF_NAME,\n        TRANSACTION_ACCUMULATOR_HASH_CF_NAME,\n        TRANSACTION_AUXILIARY_DATA_CF_NAME,\n        ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME,\n        TRANSACTION_SUMMARIES_BY_ACCOUNT_CF_NAME,\n        TRANSACTION_BY_HASH_CF_NAME,\n        TRANSACTION_INFO_CF_NAME,\n        VERSION_DATA_CF_NAME,\n        WRITE_SET_CF_NAME,\n        DB_METADATA_CF_NAME,\n    ]\n}\n\npub(super) fn event_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        EVENT_ACCUMULATOR_CF_NAME,\n        EVENT_BY_KEY_CF_NAME,\n        EVENT_BY_VERSION_CF_NAME,\n        EVENT_CF_NAME,\n    ]\n}\n\npub(super) fn persisted_auxiliary_info_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        PERSISTED_AUXILIARY_INFO_CF_NAME,\n    ]\n}\n\npub(super) fn transaction_accumulator_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        TRANSACTION_ACCUMULATOR_CF_NAME,\n        TRANSACTION_ACCUMULATOR_HASH_CF_NAME,\n    ]\n}\n\npub(super) fn transaction_auxiliary_data_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        TRANSACTION_AUXILIARY_DATA_CF_NAME,\n    ]\n}\n\npub(super) fn transaction_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        TRANSACTION_CF_NAME,\n        ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME,\n        TRANSACTION_SUMMARIES_BY_ACCOUNT_CF_NAME,\n        TRANSACTION_BY_HASH_CF_NAME,\n    ]\n}\n\npub(super) fn transaction_info_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        TRANSACTION_INFO_CF_NAME,\n    ]\n}\n\npub(super) fn write_set_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        WRITE_SET_CF_NAME,\n    ]\n}\n\npub(super) fn ledger_metadata_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        BLOCK_BY_VERSION_CF_NAME,\n        BLOCK_INFO_CF_NAME,\n        DB_METADATA_CF_NAME,\n        EPOCH_BY_VERSION_CF_NAME,\n        LEDGER_INFO_CF_NAME,\n        VERSION_DATA_CF_NAME,\n    ]\n}\n\npub(super) fn state_merkle_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        JELLYFISH_MERKLE_NODE_CF_NAME,\n        STALE_NODE_INDEX_CF_NAME,\n        STALE_NODE_INDEX_CROSS_EPOCH_CF_NAME,\n    ]\n}\n\npub(super) fn skip_reporting_cf(cf_name: &str) -> bool {\n    cf_name == DEFAULT_COLUMN_FAMILY_NAME || cf_name == DB_METADATA_CF_NAME\n}\n\npub(super) fn state_kv_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        STALE_STATE_VALUE_INDEX_CF_NAME,\n        STATE_VALUE_CF_NAME,\n        STATE_VALUE_INDEX_CF_NAME,\n    ]\n}\n\npub(super) fn state_kv_db_new_key_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        DB_METADATA_CF_NAME,\n        STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME,\n        STATE_VALUE_BY_KEY_HASH_CF_NAME,\n        STATE_VALUE_INDEX_CF_NAME, // we still need this cf before deleting all the write callsites\n    ]\n}\n\npub(super) fn hot_state_kv_db_column_families() -> Vec<ColumnFamilyName> {\n    vec![\n        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,\n        HOT_STATE_VALUE_BY_KEY_HASH_CF_NAME,\n    ]\n}\n\nfn gen_cfds<F>(\n    rocksdb_config: &RocksdbConfig,\n    block_cache: Option<&Cache>,\n    cfs: Vec<ColumnFamilyName>,\n    cf_opts_post_processor: F,\n) -> Vec<ColumnFamilyDescriptor>\nwhere\n    F: Fn(ColumnFamilyName, &mut Options),\n{\n    let mut cfds = Vec::with_capacity(cfs.len());\n    for cf_name in cfs {\n        let table_options = gen_table_options(rocksdb_config, block_cache, cf_name);\n\n        let mut cf_opts = Options::default();\n        cf_opts.set_compression_type(DBCompressionType::Lz4);\n        cf_opts.set_block_based_table_factory(&table_options);\n        cf_opts.add_compact_on_deletion_collector_factory(0, 0, 0.4);\n        cf_opts_post_processor(cf_name, &mut cf_opts);\n        cfds.push(ColumnFamilyDescriptor::new((*cf_name).to_string(), cf_opts));\n    }\n    cfds\n}\n\nfn gen_table_options(\n    rocksdb_config: &RocksdbConfig,\n    block_cache: Option<&Cache>,\n    cf_name: ColumnFamilyName,\n) -> BlockBasedOptions {\n    let mut table_options = BlockBasedOptions::default();\n\n    table_options.set_block_size(rocksdb_config.block_size as usize);\n\n    table_options.set_index_type(convert_index_type(rocksdb_config.index_type));\n    table_options.set_partition_filters(rocksdb_config.partition_filters);\n    table_options.set_cache_index_and_filter_blocks(rocksdb_config.cache_index_and_filter_blocks);\n    table_options.set_pin_l0_filter_and_index_blocks_in_cache(\n        rocksdb_config.pin_l0_filter_and_index_blocks_in_cache,\n    );\n\n    if let Some(cache) = block_cache {\n        table_options.set_block_cache(cache);\n    }\n\n    if let Some(bits) = rocksdb_config.bloom_filter_bits {\n        match rocksdb_config.bloom_before_level {\n            Some(level) => table_options.set_hybrid_ribbon_filter(bits, level),\n            None => table_options.set_bloom_filter(bits, /* block_based = */ false),\n        }\n    }\n\n    if cf_name == STATE_VALUE_BY_KEY_HASH_CF_NAME || cf_name == HOT_STATE_VALUE_BY_KEY_HASH_CF_NAME\n    {\n        // We do not generally perform point queries on these tables.\n        table_options.set_whole_key_filtering(false);\n    }\n\n    table_options\n}\n\nfn convert_index_type(index_type: IndexType) -> BlockBasedIndexType {\n    match index_type {\n        IndexType::BinarySearch => BlockBasedIndexType::BinarySearch,\n        IndexType::HashSearch => BlockBasedIndexType::HashSearch,\n        IndexType::TwoLevelIndexSearch => BlockBasedIndexType::TwoLevelIndexSearch,\n    }\n}\n\nfn with_state_key_extractor_processor(cf_name: ColumnFamilyName, cf_opts: &mut Options) {\n    if cf_name == STATE_VALUE_CF_NAME\n        || cf_name == STATE_VALUE_BY_KEY_HASH_CF_NAME\n        || cf_name == HOT_STATE_VALUE_BY_KEY_HASH_CF_NAME\n    {\n        let prefix_extractor =\n            SliceTransform::create("
]