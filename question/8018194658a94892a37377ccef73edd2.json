[
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Deserialization error propagation] If PublicKey::try_from() returns an error, can error handling logic accidentally use the partial key material before the error is checked? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Cloneable private keys risk] Under the 'cloneable-private-keys' feature, does allowing PrivateKey cloning increase the attack surface for key material leakage? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Fuzzing mode security] Does enabling the 'fuzzing' feature disable security checks that could be exploited if accidentally enabled in production? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Test-only functions] Can test-only functions like sign_arbitrary_message() be called in production, bypassing proper message serialization? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_sigs] [Empty message set attack] In verify_aggregate(), what happens if msgs or pks arrays are empty? Can this cause verification to succeed trivially, enabling forgery? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Aggregate with self] Can PublicKey::aggregate() be called with the same public key multiple times, and does this enable amplification attacks on signature verification? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_sigs] [Signature subtraction] Can an attacker compute the difference between two signatures to forge a signature on a message difference, bypassing normal signing? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_keys] [Negative scalar attack] Can negative scalar values in cryptographic operations enable signature forgery through scalar negation attacks? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [Module: bls12381_pop] [Self-PoP attack] Can a validator create a valid PoP for someone else's public key and use it to participate in multisig with that key? (Critical)",
  "[File: aptos-core/crates/aptos-crypto/src/bls12381/mod.rs] [blst library] [Library version mismatch] If different validators use different versions of the blst library with incompatible behaviors, can this cause signature verification mismatches? (High)",
  "[File: aptos-core/\n\n### Citations\n\n**File:** crates/aptos-crypto/src/bls12381/mod.rs (L1-430)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module provides APIs for Boneh-Lynn-Shacham (BLS) aggregate signatures, including\n//! normal (non-aggregated) signatures and multisignatures, on top of Barreto-Lynn-Scott BLS12-381\n//! elliptic curves. This module wraps the [blst](https://github.com/supranational/blst) library.\n//!\n//! Our multisignature and aggregate signature implementations are described in [^BLS04], [^Bold03],\n//! except we use the proof-of-possession (PoP) scheme from [^RY07] to prevent rogue-key attacks\n//! [^MOR01] where malicious signers adversarially pick their public keys in order to forge a\n//! multisignature or forge an aggregate signature.\n//!\n//! Our normal (non-aggregated) signatures implementation requires CAREFUL use by developers to\n//! prevent small-subgroup attacks. Specifically, developers must always wrap `bls12381::PublicKey`\n//! objects as `Validatable::<bls12381::PublicKey>` and access the public key via\n//! `Validatable::<bls12381::PublicKey>::valid()`. We give an example below.\n//!\n//! We implement the `Minimal-pubkey-size` variant from the BLS IETF draft standard [^bls-ietf-draft],\n//! which puts the signatures in the group $\\mathbb{G}_2$ and the public keys in $\\mathbb{G}_1$. The\n//! reasoning behind this choice is to minimize public key size, since public keys are posted on the\n//! blockchain.\n//!\n//! # Overview of normal Boneh-Lynn-Shacham (BLS) signatures\n//!\n//! In a _normal signature scheme_, we have a single _signer_ who generates its own key-pair:\n//! a _private-key_ and a corresponding _public key_. The signer can produce a _signature_ on a\n//! _message_ `m` using its private-key. Any _verifier_ who has the public key can check that\n//! the signature on `m` was produced by the signer.\n//!\n//! # Overview of Boneh-Lynn-Shacham (BLS) multisignatures\n//!\n//! In a _multisignature scheme_, we have `n` signers. Each signer `i` has their own key-pair `(sk_i, pk_i)`.\n//! Any subset of `k` signers can collaborate to produce a succinct _multisignature_ on the *same*\n//! message `m`.\n//!\n//! Typically, the `k` signers first agree on the message `m` via some protocol (e.g., `m` is the\n//! latest block header in a blockchain protocol). Then, each signer produces a _signature share_ `s_i`\n//! on `m` using their own private key `sk_i`. After this, each signer `i` sends their signature\n//! share `s_i` to an _aggregator_: a dedicated, untrusted party who is responsible for aggregating\n//! the signature shares into the final multisignature. For example, one of the signers themselves\n//! could be the aggregator.\n//!\n//! Lastly, the aggregator can proceed in two ways:\n//!\n//! 1. Pessimistically verify each signature share, discarding the invalid ones, and then aggregate\n//!    the final multisignature.\n//!\n//! 2. Optimistically aggregate all signature shares, but verify the final multisignature at the end\n//!    to ensure no bad signature shares were included. If the multisignature does not verify,\n//!    revert to the pessimistic mode (or consider other approaches [^LM07]).\n//!\n//! Either way, the end result (assuming some of the signature shares were valid) will be a valid\n//! multisignature on `m` which can be verified against an _aggregate public key_ of the involved\n//! signers.\n//!\n//! Specifically, any verifier who knows the public keys of the signers whose shares were aggregated\n//! into the multisignature, can first compute an _aggregate public key_ as a function of these\n//! public keys and then verify the multisignature under this aggregate public key.\n//!\n//! Extremely important for security is that the verifier first ensure these public keys came with\n//! valid proofs-of-possession (PoPs). Otherwise, multisignatures can be forged via _rogue-key attacks_\n//! [^MOR01].\n//!\n//! # Overview of Boneh-Lynn-Shacham (BLS) aggregate signatures\n//!\n//! In an _aggregate signature scheme_ any subset of `k` out of `n` signers can collaborate to produce\n//! a succinct _aggregate signature_ over (potentially) different message. Specifically, such an\n//! aggregate signature is a succinct representation of `k` normal signatures, where the `i`th signature\n//! from the `i`th signer is on some message `m_i`. Importantly, `m_i` might differ from the other `k-1` messages\n//! signed by the other signers.\n//!\n//! Note that an aggregate signature where all the signed messages `m_i` are the same is just a\n//! multisignature.\n//!\n//! Just like in a multisignature scheme, in an aggregate signature scheme there is an _aggregator_\n//! who receives _signature shares_ `s_i` from each signer `i` on their *own* message `m_i` and\n//! aggregates the valid signature shares into an aggregate signature. (In contrast, recall that,\n//! in a multisignature scheme, every signer `i` signed the same message `m`.)\n//!\n//! Aggregation proceeds the same as in a multisignature scheme (see notes in previous section).\n//!\n//! # A note on subgroup checks\n//!\n//! This library was written so that users who know nothing about _small subgroup attacks_  [^LL97], [^BCM+15e]\n//! need not worry about them, **as long as library users either**:\n//!\n//!  1. For normal (non-aggregated) signature verification, wrap `PublicKey` objects using\n//!     `Validatable<PublicKey>`\n//!\n//!  2. For multisignature, aggregate signature and signature share verification, library users\n//!     always verify a public key's proof-of-possession (PoP)** before aggregating it with other PKs\n//!     and before verifying signature shares with it.\n//!\n//! Nonetheless, we still provide `subgroup_check` methods for the `PublicKey` and `Signature` structs,\n//! in case manual verification of subgroup membership is ever needed.\n//!\n//! # A note on domain separation tags (DSTs)\n//!\n//! Internal to this wrapper's implementation (and to the underlying blst library) is the careful\n//! use of domain separation tags (DSTs) as per the BLS IETF draft standard [^bls-ietf-draft].\n//!\n//! Specifically, **when signing a message** `m`, instead of signing as `H(m)^sk`, where `sk` is the\n//! secret key, the library actually signs as `H(sig_dst | m)^sk`, where `sig_dst` is a DST for\n//! message signing.\n//!\n//! In contrast, **when computing a proof-of-possesion (PoP)**, instead of signing the public key as\n//! `H(pk)^sk`, the  library actually signs as `H(sig_pop | pk)^sk`, where `sig_pop` is a DST for\n//! signatures used during PoP creation.\n//!\n//! This way, we can clearly separate the message spaces of these two use cases of the secret key `sk`.\n//!\n//! # How to use this module to create and verify normal (non-aggregated) signatures on a single message\n//!\n//! A typical use of the normal (non-aggregated) signature library would look as follows.\n//!\n//! For signers:\n//!\n//! ```\n//! use std::iter::zip;\n//! use aptos_crypto::test_utils::{KeyPair, TestAptosCrypto};\n//! use aptos_crypto::{bls12381, Signature, SigningKey, Uniform};\n//! use aptos_crypto::bls12381::bls12381_keys::{PrivateKey, PublicKey};\n//! use aptos_crypto::bls12381::ProofOfPossession;\n//! use aptos_crypto_derive::{CryptoHasher, BCSCryptoHash};\n//! use rand_core::OsRng;\n//! use serde::{Serialize, Deserialize};\n//!\n//! let mut rng = OsRng;\n//!\n//! // A signer locally generated their own BLS key-pair via:\n//! let kp = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);\n//!\n//! // Any arbitrary struct can be signed as long as it is properly"
]