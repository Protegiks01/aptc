[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand()] [PRNG seeding] When using extract_then_expand() to seed a PRNG by combining master seed with PRNG output, can a weak PRNG state completely undermine the high-entropy master seed? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Partial entropy leakage] If one entropy source in ikm leaks (e.g., predictable timestamp), does this leak propagate to compromise all derived keys, or does the salt provide sufficient mixing? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract()] [Entropy estimation] Does the implementation validate that combined entropy in ikm meets minimum security requirements (e.g., 128 bits effective entropy), or only check length without considering entropy quality? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [Noise chaining key] Does extract_then_expand_no_ikm() properly support Noise protocol chaining key derivation where ikm is empty and only salt contains the previous chaining key? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [Handshake state leakage] Can calling extract_then_expand_no_ikm() during Noise handshake leak handshake state through timing variations or error conditions, enabling active attacks on the key exchange? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [Key derivation for encryption and MAC] When deriving both encryption and MAC keys from the same chaining key via extract_then_expand_no_ikm(), does the info parameter provide sufficient domain separation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [Rekey operation] Does extract_then_expand_no_ikm() support secure rekeying in Noise protocol where new keys are derived from current keys without additional entropy? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_then_expand_no_ikm()] [PSK mode] When using pre-shared keys (PSK) in Noise protocol with extract_then_expand_no_ikm(), can the PSK be properly mixed into the chaining key without being used as ikm? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Struct: Hkdf<D>] [Type parameter substitution] Can malicious code substitute the generic hash function D at runtime through unsafe code or type punning, replacing SHA256 with a weak hash function to compromise key derivation? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Type: PhantomData<D>] [Zero-sized type exploitation] Does PhantomData<D> being zero-sized create vulnerabilities where multiple Hkdf instances with different D types share memory or state? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Trait bounds: D] [Trait implementation bypass] Can an attacker create a custom type implementing all required traits (Update, BlockInput, etc.) that passes compile-time checks but has runtime cryptographic weaknesses? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Type: D::OutputSize] [Associated type manipulation] Can associated types like D::OutputSize and D::BlockSize be manipulated through trait coherence rules to create type confusion in HMAC operations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Generic: ArrayLength<u8>] [Type-level integer overflow] Can type-level arithmetic in generic_array::ArrayLength cause integer overflow in type computations, leading to incorrect buffer sizes at runtime? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Import: hkdf::Hkdf] [Dependency vulnerability] Does the underlying hkdf crate (used in extract_no_ikm_check and expand) have known vulnerabilities, outdated cryptographic implementations, or supply chain risks? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Import: digest::*] [Trait compatibility] Can version mismatches or breaking changes in the digest crate traits (Update, BlockInput, FixedOutput) cause cryptographic failures or security regressions? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Import: generic_array] [Type system dependency] Can vulnerabilities in generic_array type-level programming create buffer overflows or type confusion in array operations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: extract_no_ikm_check()] [Wrapper vulnerability] Does wrapping hkdf::Hkdf::extract() introduce additional attack surface through incorrect parameter passing or result handling? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs] [Function: expand()] [Error mapping vulnerability] Does mapping hkdf errors to HkdfError variants lose important security-relevant error information that could indicate attacks in progress?\n\n### Citations\n\n**File:** third_party/move/move-examples/diem-framework/crates/crypto/src/hkdf.rs (L1-199)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! An implementation of HKDF, the HMAC-based Extract-and-Expand Key Derivation Function for the\n//! Diem project based on [RFC 5869](https://tools.ietf.org/html/rfc5869).\n//!\n//! The key derivation function (KDF) is intended to support a wide range of applications and\n//! requirements, and is conservative in its use of cryptographic hash functions. In particular,\n//! this implementation is compatible with hash functions that output 256 bits or more, such as\n//! SHA256, SHA3-256 and SHA512.\n//!\n//! HKDF follows the"
]