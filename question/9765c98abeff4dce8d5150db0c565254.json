[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script()] [Resolver type confusion] At line 44, BinaryIndexedView::Script is created - if the script reference is later modified or the BinaryIndexedView is reused for a different script, can stale resolver data cause verification to pass on outdated/incorrect bytecode? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [Resolver inconsistency] At line 106, BinaryIndexedView::Module is created per-function - if the module is modified between function verifications during concurrent verification, can race conditions cause some functions to be verified against stale module data? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Version mismatch] At line 162, resolver.version() is checked but the resolver was created from script/module - can the resolver's cached version differ from the actual script.version or module.version, causing wrong validation path? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [Race condition] At lines 60-71, entry functions are iterated and verified sequentially - if the module's function_defs are modified concurrently by another thread during verification, can this cause verification of phantom functions or skipping of malicious entry functions? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature_by_name()] [TOCTOU] The function is found at line 82 and verified at line 90-94 - can the function definition be modified between lookup and verification (time-of-check-time-of-use), allowing a malicious function to pass verification with valid name but execute with modified signature? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Signature aliasing] At line 155, multiple SignatureIndex values could point to the same signature table entry - can an attacker craft bytecode where parameters_idx and return_idx are the same, causing return types to be validated as parameters and bypassing return type checks? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Empty signature exploitation] The empty_vec is created but only used as fallback for None return_idx - can an attacker craft a valid return_idx that points to an empty signature, bypassing return type validation while claiming the function has returns? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Iterator side effects] At lines 164-166 and 169-171, skip_while consumes iterator elements - if the closure has side effects or the iterator is reused, can this cause validation inconsistencies where some types are checked multiple times or skipped? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [Filter manipulation] At line 64, filter(|(_idx, fdef)| fdef.is_entry) selects entry functions - if is_entry is a computed property rather than a stored field, can its value change between filter evaluation and actual verification? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Generic type injection] Does is_valid_for_constant() properly reject SignatureToken::TypeParameter, or can an attacker pass generic type parameters as script arguments that are instantiated with Signer or Reference types at runtime, bypassing signature validation? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Nested reference bypass] At line 165, the pattern matches S::Reference(inner) where inner is S::Signer - but can an attacker craft S::Reference(S::Reference(S::Signer)) or deeper nesting that bypasses the single-level pattern match? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Struct instantiation] If parameters contain SignatureToken::StructInstantiation with type arguments including Signer, does is_valid_for_constant() properly reject this, or can Signer be smuggled inside struct generic parameters? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [Quadratic complexity] If a module has N entry functions each with M parameters, verification is O(N*M) - can an attacker deploy a module with thousands of entry functions with large signatures to cause excessive verification time, delaying block validation? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Vector allocation] At line 154, an empty_vec is allocated on stack - if signature tables contain extremely large vectors (thousands of parameters), can this cause stack overflow during signature validation? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature()] [Handle index validation] At line 107, fdef.function is used as index for function_handle_at() - can an attacker craft bytecode where fdef.function points to an invalid or out-of-bounds function handle, causing panic or memory corruption? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature_by_name()] [Name resolution bypass] At line 83, module.identifier_at(module.function_handle_at(fdef.function).name) performs two indirect lookups - can these indices be manipulated to resolve to wrong names, causing verification of unintended functions? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [VERSION_5 boundary] At line 130, deprecated_logic uses resolver.version() < VERSION_5 - what happens for VERSION_4 scripts? Are there any version-specific validation gaps between VERSION_1 and VERSION_5 that can be exploited? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [VERSION_1 special case] At line 162, VERSION_1 has special handling for S::Reference(S::Signer) - can an attacker use this to inject signer references that later versions prohibit, then upgrade the version to bypass validation? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Status code exploitation] At line 176, INVALID_MAIN_FUNCTION_SIGNATURE is returned - can an attacker craft bytecode that triggers this error in a way that's caught and ignored by upstream validation, allowing invalid signatures to proceed? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module_function_signature_by_name()] [Error code confusion] At line 86, VERIFICATION_ERROR status is used for function-not-found - can this generic error code be confused with other verification failures, causing different security responses? (Low)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: legacy_script_signature_checks()] [Pattern match exhaustiveness] At line 165, the match uses matches! macro with S::Reference(inner) if matches!(&**inner, S::Signer) - are all SignatureToken variants properly handled, or can new variants bypass this check? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_module()] [Entry flag bypass] At line 64, only functions with fdef.is_entry==true are verified - can an attacker mark malicious functions as is_entry=false but still make them callable through direct VM invocation, bypassing signature validation entirely? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_main_signature_impl()] [is_entry parameter] The is_entry parameter controls deprecated_logic at line 130 - can this boolean be manipulated during verification pipeline to cause inconsistent validation between verification and execution phases? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script() vs verify_module()] [Validation asymmetry] Scripts with version >= VERSION_5 skip all validation (line 41) while modules with version < VERSION_5 skip validation (line 56) - can an attacker exploit this inverse logic to bypass validation by choosing specific version-type combinations? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/script_signature.rs] [Function: verify_script()] [Script parameter handling] Scripts pass None for return_ (line 46) but modules pass Some(return_) (line 114) - if downstream code expects consistent behavior, can this None value cause panics or incorrect validation? (Medium)"
]