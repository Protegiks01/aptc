[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_id()] [Address bytes truncation] Does AccountAddress::new(self.named_module.address.into_bytes()) properly handle address sizes, or can truncation or padding issues cause address collisions enabling module replacement? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_id()] [Numerical address conversion] Can NumericalAddress.into_bytes() produce non-canonical address representations that hash differently but represent the same address, breaking address-based security? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Address-name binding vulnerability] Is the binding between address (NumericalAddress) and address_name (Option<Name>) enforced, or can attackers create modules with mismatched address identifiers? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify()] [Partial verification state] If verify() fails partway through verification, can the AnnotatedCompiledUnit be left in an inconsistent state where some components are verified and others aren't? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Transactional verification failure] Does verify_units() provide all-or-nothing verification semantics, or can partial verification allow some units to be considered verified while others failed? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledModule] [Module-ident desynchronization] Can the module_ident() result become desynchronized from the actual named_module contents after mutation, causing identity confusion? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: into_compiled_unit()] [Irreversible conversion] Since into_compiled_unit() consumes self, can this enable one-way attacks where AnnotatedCompiledUnit security metadata is permanently lost? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Concurrent serialization race] If serialize() is called concurrently with modifications to the module field, can race conditions cause serialization of partially-modified bytecode? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Concurrent verification TOCTOU] Can Time-of-Check Time-of-Use vulnerabilities occur if units are modified between verify_units() checking them and the bytecode being deployed? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Concurrent spec info modification] Can concurrent access to spec_info BTreeMap cause data races if spec information is updated during verification? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize_source_map()] [Concurrent source map serialization] Can concurrent calls to serialize_source_map() for the same SourceMap cause race conditions in BCS serialization? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_id()] [Module dependency spoofing] Can an attacker create a ModuleId that matches a legitimate module's ID but contains malicious code, enabling dependency confusion attacks where imports resolve to attacker modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Cross-module verification dependencies] Does verify_units() properly verify that module dependencies are themselves verified, or can unverified dependencies be used by verified modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_ident()] [Circular dependency via identity] Can circular dependencies be created by having modules with ModuleIdents that reference each other, causing infinite loops during module loading? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Package boundary violation] Can modules from different package_name values interact in ways that violate package isolation security policies? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Move bytecode format version mismatch] Can serialize() produce bytecode that's valid in one Move VM version but exploits bugs in another version, causing consensus failures in heterogeneous validator sets? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Move spec verification bypass] Can malicious spec_info configurations disable Move formal verification checks, allowing deployment of code that violates Move safety invariants? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_module()] [Move resource safety bypass] Does verify_module() properly enforce Move's resource safety rules, or can attackers deploy modules with resource duplication or deletion vulnerabilities? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_script()] [Move script capability escalation] Can malicious scripts bypass Move's capability checks to gain unauthorized access to resources or functions? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: NamedCompiledModule] [Symbol collision attack] Can two modules have identical name Symbols but different bytecode content, causing non-deterministic module resolution across validators? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: name()] [Name shadowing vulnerability] Can an attacker deploy a module/script with a name that shadows a trusted system module, hijacking calls intended for the legitimate module? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Lambda symbol collision] Can used_lambda_funs contain multiple entries with colliding Symbol keys, causing lambda function calls to resolve to wrong implementations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: package_name()] [Package name resolution ambiguity] Can multiple modules claim the same package_name but belong to different addresses, violating package uniqueness assumptions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: into_compiled_unit()] [Pipeline stage bypass] Can into_compiled_unit() be called prematurely to extract CompiledUnit before all compilation stages complete, deploying partially-compiled code? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify()] [Multi-stage verification bypass] If verification occurs in multiple stages, can attackers pass early stages but manipulate units before later stages? (High)"
]