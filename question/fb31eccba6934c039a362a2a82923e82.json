[
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: is_enabled(), Line 195] [Integer overflow] Can an attacker cause integer overflow when comparing timestamp_micros with activation_time_on().timestamp_micros() as u64, potentially enabling features prematurely by providing a maliciously large timestamp that wraps around? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: is_enabled(), Line 195] [Timestamp manipulation] If a validator provides a timestamp_micros value that exceeds i64::MAX (9223372036854775807), does the cast to u64 in the comparison create a wraparound condition that could activate features before their intended time? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: activation_time_on(), Lines 72-141] [Timezone conversion bug] Could timezone conversion errors between Los_Angeles and UTC introduce off-by-one hour bugs during daylight saving time transitions, causing features to activate at incorrect times and breaking consensus? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: new(), Lines 152-164] [Chain ID spoofing] If NamedChain::from_chain_id() returns Err for an unknown chain ID, the system defaults to TimedFeaturesImpl::EnableAll - can an attacker exploit this by providing a malicious chain_id to bypass all timed feature restrictions? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: is_enabled(), Line 195] [Type casting vulnerability] The comparison casts timestamp_micros() result from i64 to u64 - can negative timestamp values from malformed DateTime objects cause incorrect feature enabling due to two's complement representation? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: activation_time_on(), Lines 76-141] [Cross-chain feature leak] If a node starts with TESTNET chain_id but later switches to MAINNET (via reconfiguration), could features intended only for testnet become enabled on mainnet due to stale TimedFeatures instances? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: new(), Line 158] [Unknown chain EnableAll bypass] The fallback to EnableAll for unknown chains could allow attackers to launch a private chain fork with all experimental features enabled, potentially finding and exploiting bugs before they're discovered on mainnet - is this secure? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: activation_time_on(), Lines 139-140] [Default activation time] For DEVNET and PREMAINNET, features activate at BEGINNING_OF_TIME - could this cause security features to be disabled on staging environments that should mirror mainnet's security posture? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Struct: TimedFeaturesImpl, Lines 32-39] [Enum variant confusion] Can validators construct malicious TimedFeaturesImpl::EnableAll instances that bypass timestamp checks entirely, even when running on mainnet with strict activation schedules? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: get_override(), Lines 49-65] [Override bypass] The get_override() method returns None for most flags in Testing mode (line 62), which means they fall through to timestamp-based activation - can an attacker inject a Testing override profile in production to manipulate feature states? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: with_override_profile(), Lines 173-178] [Profile injection] The with_override_profile() method allows arbitrary override profiles to be set - if this builder is exposed to external input, can malicious actors force Replay or Testing overrides in production environments? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: is_enabled(), Lines 184-188] [Override priority] Overrides take priority over timestamp checks (lines 184-188) - if an attacker can control the override_ field through deserialization or API exposure, can they permanently enable/disable critical security features? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: get_override(), Lines 54-58] [Replay override hardcoding] The Replay override hardcodes _LimitTypeTagSize and _ModuleComplexityCheck to true - if these features have known vulnerabilities that were fixed in newer versions, could replaying old transactions exploit outdated feature states? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: build(), Lines 201-208] [Non-deterministic iteration] The TimedFeatureFlag::iter() iteration order must be deterministic across all validators - if enum variants are reordered during compilation, could different validators produce different enabled arrays causing consensus failure? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: build(), Line 202] [Array initialization] The enabled array is initialized with [false; TimedFeatureFlag::COUNT] - if COUNT is calculated incorrectly or enum variants are added without updating tests, could this cause out-of-bounds access when indexing by flag as usize? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: is_enabled() in TimedFeatures, Lines 215-217] [Bounds checking] When accessing self.0[flag as usize], is there runtime bounds checking to prevent panics if a new flag is added but COUNT is stale, or could this crash validators? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Struct: TimedFeatures, Line 212] [Serialization determinism] The TimedFeatures struct derives Serialize - if different validators serialize this with different serde versions or settings, could non-deterministic serialization cause state root mismatches? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: build(), Lines 201-208] [Race condition] If build() is called concurrently by multiple threads with slightly different timestamp_micros values (due to clock skew), could this produce different TimedFeatures instances causing validator disagreement? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Lines 13-14] [Always-enabled features] _LimitTypeTagSize is marked as 'always enabled' but has activation_time_on() logic - if a validator incorrectly implements this feature check, could unbound type tags cause DoS through excessive memory consumption? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Lines 15-16] [Irreversible features] _ModuleComplexityCheck is marked 'cannot be disabled' - if this feature has a critical bug discovered post-activation, is there any emergency mechanism to disable it without a hard fork? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Lines 20-22] [Memory tracking bug fix] FixMemoryUsageTracking fixes a bug where table natives don't track memory - during the transition period before activation, can attackers exploit the unfixed bug to allocate unlimited memory and crash validators? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Lines 27-28] [Double-counting fix] FixTableNativesMemoryDoubleCounting fixes double counting - before activation, could the double-counting bug cause gas calculations to be incorrect, allowing attackers to execute more operations than they paid for? (High)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Line 18] [Gas bypass] ChargeBytesForPrints introduces gas charges for print operations - before activation (lines 111-118), can attackers spam print operations without paying gas to fill logs and degrade validator performance? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Enum: TimedFeatureFlag, Lines 23-25] [Capture option vulnerability] DisabledCaptureOption controls whether option types can be captured - if this feature flag is manipulated, could it enable type system bypasses that violate Move's resource safety guarantees? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/timed_features.rs] [Function: activation_time_on(), Lines 78-79] [BEGINNING_OF_TIME bypass] _LimitTypeTagSize activates at BEGINNING_OF_TIME on both testnet and mainnet - if BEGINNING_OF_TIME (line 68) is DateTime::UNIX_EPOCH, could timestamp comparisons with 0 cause underflow issues? (Medium)"
]