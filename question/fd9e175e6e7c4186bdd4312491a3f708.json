[
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: check_mutable_borrow_field()] [Immutable source mutation] Does the check properly detect all cases of mutable borrowing from immutable references, including those through complex field selection chains? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_quant()] [Domain type confusion] Can quantified variables range over invalid domain types that aren't vectors, ranges, or type domains, causing runtime errors in specification checking? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_quant() - QuantKind] [Choice semantics] Do choice quantifiers (choose/chooseMin) properly validate that the range is non-empty, or can they produce undefined results when no values satisfy the condition? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_spec_block()] [Context leakage] Can locals from the enclosing function context leak into spec blocks inappropriately, allowing specs to reference variables that shouldn't be visible? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_spec_block() - lambda_info] [Type specialization] Does spec block lambda type specialization properly handle defaults, or can incomplete types in lambda specs cause verification to accept invalid programs? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: post_process_body()] [Placeholder resolution] Can placeholder expressions remain unresolved due to errors, and if so, do they cause crashes or undefined behavior in later compilation stages? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpPlaceholder - FieldSelectInfo] [Unresolved fields] If struct type inference fails, can field selection placeholders resolve to wrong fields in different structs with the same field name? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Struct: ExpPlaceholder - ReceiverCallInfo] [Receiver resolution race] Can concurrent post-processing of receiver calls cause placeholder_map corruption, leading to wrong function being called or type confusion? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: post_process_receiver_call()] [Borrow injection] Does automatic borrow injection for receiver calls properly validate the resulting reference type matches expectations, preventing invalid reference conversions? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_seq()] [Block scope] Can sequence expressions violate lexical scoping rules, allowing variables defined in later sequence items to be referenced in earlier ones? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_seq_recursively()] [Type defaults] When sequence items have unconstrained types, does the default unit type assignment interact correctly with type inference, or can it cause unexpected type errors? (Low)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Loop/While] [Loop label confusion] Can loop labels be shadowed or duplicated, causing break/continue to target the wrong loop and violate control flow integrity? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: find_loop_nest()] [Label lookup] Does label resolution properly handle nested loops with same labels, or can it compute wrong nesting depth, causing break/continue to escape too many or too few loops? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Assign] [Assignment safety] Can assignment to patterns containing wildcards silently drop values that should require explicit drop, violating Move's explicit resource handling? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - Mutate] [Mutation reference type] Does mutate operation properly validate that the target is a mutable reference, or can immutable references be coerced to mutable in edge cases? (Critical)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: freeze_tuple_exp()] [Tuple element freeze] Can tuple freezing miss elements that need conversion, allowing mutable references to leak through tuple destructuring? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_exp() - FieldMutate] [Field mutation bypass] Can field mutation operations bypass access control checks that would prevent direct mutable borrow of the field? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: define_type_param()] [Type parameter collision] Can duplicate type parameter names cause earlier definitions to be silently overwritten, leading to wrong type being used in generic instantiation? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: analyze_and_add_type_params()] [Phantom type bypass] Are phantom type parameters properly enforced to not appear in function bodies or field types, or can they be misused to bypass variance checks? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: make_instantiation()] [Instantiation mismatch] When type arguments are provided, does arity checking happen before type translation, or can partial instantiation slip through causing crashes? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: make_instantiation_or_report()] [Error recovery] If instantiation fails, does error recovery leave partial state that corrupts subsequent type inference, causing cascading errors or security issues? (Medium)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_access_specifiers()] [Access control bypass] Can wildcard access specifiers (*) be combined with specific names to bypass intended access restrictions in spec functions? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_access_specifier() - module resolution] [Module confusion] Can malformed module access patterns cause resolution to wrong modules, allowing specs to reference resources from unintended modules? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_address_specifier()] [Address parameter injection] Can attacker-controlled address specifiers in specs access arbitrary addresses, potentially reading or writing to addresses that should be inaccessible? (High)",
  "[File: third_party/move/move-model/src/builder/exp_builder.rs] [Function: translate_access_specifier() - acquires] [Legacy acquires bypass] Does the LegacyAcquires handling properly validate constraints, or can it be abused to acquire resources that shouldn't be accessible? (Medium)"
]