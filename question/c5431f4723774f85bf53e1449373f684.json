[
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_ability_constraint()] [Key ability transformation] For structs with Key ability, the function transforms Key to Store for type argument checking. Can an attacker exploit this transformation to pass types without Store as arguments, violating the invariant that Key structs can only contain Store types? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_ability_constraint()] [Tuple ability intersection] Abilities of tuple elements are intersected. Can an attacker create a tuple with one element missing an ability, reducing the tuple's abilities, but then extract elements individually to regain the ability? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_ability_constraint()] [Vector ability checking] Vectors have fixed abilities (VECTOR). Can an attacker create vector<T> where T lacks drop, making the vector non-droppable, leading to resource leaks or preventing stack frame cleanup? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_ability_constraint()] [Reference ability override] References always return REFERENCES abilities regardless of inner type. Can an attacker use &T where T lacks required abilities, bypassing ability checks by wrapping in references? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_ability_constraint()] [Constraint deferral] For Var types, the constraint is deferred by adding it to the substitution. Can an attacker chain variable bindings such that ability constraints are deferred indefinitely until they're bound to Error type, which skips validation? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_receiver_function_constraint()] [Automatic borrowing bypass] The function auto-wraps arguments in references if receiver_needs_borrow() returns true. Can an attacker craft a receiver function signature that triggers automatic borrowing when not intended, allowing mutable access to immutable data? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_receiver_function_constraint()] [Type parameter constraint skipping] The function adds constraints for receiver function type parameters. Can an attacker define a receiver function with weak constraints, then call it on a type that doesn't satisfy the intended constraints? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Substitution::eval_receiver_function_constraint()] [Inline variance switching] When a receiver function is inline, variance switches to ShallowImplInlineVariance. Can an attacker exploit this to allow type conversions in inline functions that would be rejected in regular functions? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: ReceiverFunctionInstance::receiver_needs_borrow()] [Borrow kind mismatch] The function determines if borrowing is needed based on the first argument. Can an attacker craft a type that needs mutable borrow but gets immutable borrow, or vice versa, violating borrow semantics? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Type::get_struct()] [Struct resolution failure] The function returns None if type is not a struct. Can an attacker cause operations expecting structs to silently fail with None, leading to uninitialized data or type confusion? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Type::from_type_tag()] [Struct tag resolution panic] The function panics if struct tag cannot be resolved with 'Invariant violation' message. Can an attacker provide malformed TypeTag that causes validator nodes to panic during transaction validation, causing DoS? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Type::from_signature_token()] [Signature token injection] Can an attacker craft a SignatureToken that resolves to an unexpected type through the struct_resolver function, bypassing type validation in module loading? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Type::get_vars()] [Variable extraction incompleteness] The function recursively extracts type variables. Can an attacker hide variables in ResourceDomain with None instantiation, causing incomplete variable tracking and unbound variables in final types? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: Type::is_incomplete()] [Incomplete type detection bypass] The function checks for Var(_) types. Can an attacker create types with unresolved constraints that aren't represented as Var, passing completeness checks but failing at execution? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: PrimitiveType::possible_int_types()] [Integer bounds checking] The function filters types where value fits within min/max bounds. Can an attacker provide a value at the boundary (e.g., u64::MAX) that passes validation but overflows when used in arithmetic operations expecting smaller types? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: PrimitiveType::get_max_value()] [U256/I256 bounds] The function uses U256::MAX and I256::MAX from move_core_types. Are these values correctly validated to match on-chain Move VM limits, or could there be discrepancies causing type confusion? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: PrimitiveType::get_min_value()] [Signed integer minimum] For signed integers, the function returns i8::MIN, i64::MIN, etc. Can an attacker exploit two's complement edge cases where MIN value has no corresponding positive value, causing overflow in abs() operations? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: PrimitiveType::is_spec()] [Spec type leakage] The function identifies spec-only types (Num, Range, EventStore). Can an attacker use these types in implementation code by bypassing the is_spec() check, leading to undefined behavior in the VM? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: AbilityInference::infer_abilities()] [Phantom type ability bypass] The function returns (is_phantom, abilities) but phantom types report their declared abilities. Can an attacker declare phantom type with copy+drop but instantiate with non-copyable type, violating ability constraints? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: AbilityInference::infer_abilities()] [Vector ability intersection] Vector abilities are intersected with element abilities. Can an attacker create vector<T> where T is Error type (EMPTY abilities), resulting in a vector with no abilities that can't be dropped or copied? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: AbilityInference::infer_abilities()] [Tuple ability intersection] Tuple abilities are computed by intersecting all element abilities. Can an attacker create a tuple with one element lacking copy, making the entire tuple non-copyable, then destructure and use individual elements as if copyable? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: AbilityInference::infer_struct_abilities()] [Key ability special case] The function adds Key ability if struct declares Key and all type args have Store. Can an attacker satisfy this check with phantom type args that don't truly have Store, violating Key's requirement? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Function: AbilityInference::infer_struct_abilities()] [Phantom parameter exclusion] Phantom parameters don't participate in ability derivation (AbilitySet::ALL). Can an attacker use this to instantiate a struct with phantom parameter of type that violates ability requirements, bypassing checks? (High)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Struct: Type] [Derived PartialEq/Eq] The Type enum derives PartialEq and Eq. Does this correctly handle Error types in comparisons, or can two different Error instances compare equal, leading to incorrect type unification? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/ty.rs] [Struct: Type] [Derived Hash] The Type enum derives Hash for use in BTreeMap/BTreeSet. Can hash collisions between Struct types with different instantiations but same ModuleId/StructId cause type confusion in substitution maps? (High)"
]