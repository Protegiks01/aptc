[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: parse_newtype_fields()] [Panic-based DoS] Can an attacker trigger a panic by providing a derive macro on an empty struct, causing the expect() call on line 19 to crash the compilation process and potentially DoS build systems in continuous integration pipelines? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: parse_newtype_fields()] [Type confusion] Does the function properly validate that the extracted field type on line 16 is actually a cryptographic type before returning it, or can malicious developers derive crypto traits on arbitrary types like strings or integers, bypassing cryptographic security checks? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: parse_newtype_fields()] [Reference handling] On lines 27-28, when handling TypeReference, does the function ensure that lifetime parameters are properly validated, or can malicious lifetime annotations lead to use-after-free vulnerabilities in generated crypto code? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: parse_newtype_fields()] [Struct validation] Lines 10-13 silently return an empty vector for non-struct types - can this lead to a scenario where enums mistakenly pass through and generate broken crypto implementations that fail at runtime with cryptographic operations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: parse_newtype_fields()] [Field access vulnerability] On line 21, when determining field names, can tuple structs with numeric indices (quote!(0)) be exploited to access incorrect memory offsets in generated code, potentially leaking private key material? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Deserialization bypass] In the TryFrom chain on lines 46-60, does the or_else() error swallowing allow an attacker to provide malformed bytes that successfully deserialize to the wrong cryptographic variant, enabling signature forgery or key substitution attacks? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Empty enum panic] Line 35-37 panics if the enum is empty - can an attacker exploit this by creating empty crypto enum types through macro manipulation to crash validator nodes during key deserialization? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Type confusion attack] Lines 39-44 extract the first variant's type without validation - can this be exploited to associate incorrect cryptographic algorithms with key types, such as treating an Ed25519 key as a Secp256k1 key, bypassing signature verification? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Error information leak] The or_else closure on line 58 discards the original error (_err) - could this hide critical validation failures that should prevent key acceptance, such as weak key detection or malformed point validation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Variant ordering dependency] The try_chain on lines 46-60 attempts deserialization in variant declaration order - can an attacker exploit this ordering by crafting ambiguous byte sequences that deserialize to an unintended but valid variant, causing cryptographic type confusion? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_tryfrom()] [Missing field validation] Lines 51-56 expect field iteration to succeed without checking if variants actually have fields - can fieldless enum variants crash the macro or generate broken deserialization code? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: match_enum_to_bytes()] [Non-exhaustive matching] The generated match arms on lines 74-82 don't include a wildcard pattern - can new enum variants added later fail to serialize, causing transaction validation failures or consensus disagreements when validators run different code versions? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: match_enum_to_bytes()] [Serialization inconsistency] Line 79 calls to_bytes().to_vec() on each variant - are all variant types guaranteed to produce deterministic serialization, or could non-deterministic byte output cause validators to produce different transaction hashes, breaking consensus? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: match_enum_to_bytes()] [Clone vulnerability] The to_vec() call on line 79 performs cloning - could this leave sensitive key material in memory longer than necessary, increasing the attack surface for memory scraping attacks on validator nodes? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_valid_crypto_material()] [Bidirectional consistency] Lines 86-90 combine TryFrom and to_bytes implementations - is there validation that deserialization followed by serialization produces identical bytes, or can round-trip inconsistencies cause signature verification failures? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_valid_crypto_material()] [Trait implementation safety] The ValidCryptoMaterial trait implementation on lines 92-98 has no validation - can developers derive this trait on non-cryptographic types, bypassing security checks elsewhere in the codebase? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: get_type_from_attrs()] [Attribute injection] The attribute parsing on lines 104-106 searches for any attribute with attr_name - can attackers inject malicious attributes with crafted type names to manipulate which cryptographic implementation gets used? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: get_type_from_attrs()] [Missing attribute validation] Lines 114-123 parse the attribute value as a LitStr without validating it's a valid type path - can arbitrary strings be injected to reference non-existent or malicious types, causing compilation errors or linking to wrong implementations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: get_type_from_attrs()] [Error message information leak] Lines 108-112 and 119-127 return detailed error messages including attribute names - could error messages during macro expansion leak sensitive information about the cryptographic implementation structure to attackers? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: get_type_from_attrs()] [Type path parsing] Line 138 and similar locations parse LitStr directly into syn::Type using unwrap() - can malformed type strings cause panics during compilation, creating a denial-of-service vector against the build system? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_publickey()] [Key derivation bypass] The From implementation on lines 147-154 converts private keys to public keys through pattern matching - can an attacker exploit missing match arms to cause a panic when converting from a new private key variant, denying service during key generation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_publickey()] [Type association vulnerability] Lines 157-160 implement PublicKey trait associating a specific PrivateKeyMaterial type - can type confusion between different private/public key pairs enable cross-scheme attacks where keys from one algorithm are used with another? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_publickey()] [Match arm completeness] Lines 139-145 generate match arms for From<&PrivateKey> - if private key enum has more variants than public key enum, can unmatched variants cause panics, enabling DoS during validator key rotation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_publickey()] [Into conversion safety] Line 144 uses .into() for key conversion - are all conversions infallible and constant-time, or could timing side-channels leak information about private key values during public key derivation? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_privatekey()] [Minimal validation] The PrivateKey trait implementation on lines 170-174 only associates a PublicKeyMaterial type without any validation - can this enable creation of invalid private key types that pass compile-time checks but fail cryptographic operations? (High)"
]