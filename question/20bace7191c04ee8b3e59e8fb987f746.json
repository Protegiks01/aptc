[
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Deserialization Attack] Can an attacker craft malicious BCS-encoded bytes with excessive length fields that cause memory exhaustion or DoS when try_from_bytes() deserializes the data, potentially crashing indexer nodes or API servers? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Type Confusion] Does try_from_bytes() properly validate that the deserialized TokenId structure matches the expected schema, or can an attacker provide bytes that deserialize to a structurally different TokenId causing type confusion and potential memory corruption? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Integer Overflow] Can an attacker craft BCS bytes where the amount field u64 value causes integer overflow when processed by downstream systems that perform arithmetic operations on burned amounts? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Malicious String Attack] Since TokenId contains nested TokenDataId with String fields (collection, name), can an attacker inject extremely long strings or special characters that bypass validation and cause buffer overflows or injection attacks in indexer database queries? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Resource Exhaustion] Does the BCS deserialization have bounded limits on nested structure depth for TokenId->TokenDataId, or can an attacker create deeply nested structures causing stack overflow during deserialization? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Panic on Invalid Data] When bcs::from_bytes fails, does the error propagation via map_err(Into::into) properly handle all error cases, or can specific malformed inputs cause unwrap panics in the calling code path? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Zero-Length Exploit] Can an attacker pass zero-length bytes to try_from_bytes() causing the BCS deserializer to return unexpected default values that bypass downstream validation checks? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Determinism Violation] Does BCS deserialization guarantee deterministic output across different Rust compiler versions and architectures, or could non-deterministic deserialization lead to consensus failures when validators process burn events differently? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.amount] [Integer Overflow] Can the u64 amount field be set to u64::MAX in the event, and when indexers aggregate total burned amounts across multiple events, does this cause integer overflow leading to incorrect burn statistics or supply tracking? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.amount] [Zero Amount Bypass] Although the Move contract enforces amount > 0, can the Rust event structure be instantiated with amount=0 through direct construction, allowing fake burn events that bypass Move-side validation when processed by indexers? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: amount()] [Missing Validation] Does the amount() getter perform any validation or sanitization, or does it return potentially malicious values that could be used in unsafe arithmetic operations in calling code? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: new()] [Constructor Validation] Does the new() constructor validate that amount > 0 and amount <= some maximum reasonable value, or can it create invalid BurnToken instances that violate Move-side invariants? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.account] [Address Spoofing] Can an attacker craft a BurnToken event with a fake account address that differs from the actual transaction sender, causing indexers to incorrectly attribute burns to wrong accounts? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: account()] [Special Address Exploit] Does the account() getter validate that the returned AccountAddress is not a system reserved address (0x0, 0x1, etc.), or can events claim burns from system accounts causing accounting inconsistencies? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.account] [Account Existence Check] When a BurnToken event is emitted, is there validation that the account address actually exists on-chain and owns the tokens being burned, or can events be emitted for non-existent accounts? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: new()] [Address Format Validation] Does the constructor validate that the AccountAddress follows the correct format and byte length, or can malformed addresses be embedded in events causing parser failures? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.id] [TokenId Integrity] Since TokenId contains nested TokenDataId structure, can an attacker create a BurnToken event where the TokenId.token_data_id has inconsistent or contradictory fields that don't match any actual token, causing indexer confusion? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: id()] [Reference Safety] Does returning &TokenId create opportunities for use-after-free or dangling reference bugs if the BurnToken struct is dropped while the reference is still held? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.id] [Property Version Manipulation] Can the property_version field in TokenId be set to u64::MAX or other extreme values that cause overflow when used as array indices or version counters in downstream processing? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.id] [Creator Address Mismatch] In the nested TokenDataId, can the creator address differ from the actual token creator, allowing attackers to forge burn events for tokens they don't own? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.id] [Collection Name Injection] Can the collection String in TokenDataId contain malicious characters (NULL bytes, SQL injection strings, shell metacharacters) that exploit vulnerabilities in indexer database queries? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.id] [Token Name Exploit] Similarly, can the name String in TokenDataId be crafted with extremely long strings (>1MB) or special Unicode characters causing buffer overflows or encoding issues? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Trait: MoveStructType] [Module Name Mismatch] The MODULE_NAME is hardcoded as 'token' - can this create confusion or type mismatch issues if the actual Move module is renamed or if events from different versions are processed together? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Trait: MoveStructType] [Struct Name Confusion] The STRUCT_NAME is 'Burn' (not 'BurnToken'), creating a discrepancy with the Rust struct name - can this naming inconsistency be exploited to confuse event routing or type checking logic? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Static: BURN_TOKEN_TYPE] [Type Tag Manipulation] The BURN_TOKEN_TYPE lazy static uses TOKEN_ADDRESS - if this constant is modified or points to an attacker-controlled address, can malicious events be accepted as legitimate? (Critical)"
]