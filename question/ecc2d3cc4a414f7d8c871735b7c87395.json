[
  "[File: third_party/move/move-core/types/src/language_storage.rs] [FunctionTag abilities] [Ability inheritance] When functions are used as type arguments in generics, are ability constraints properly inherited, or can attackers create wrapper functions that circumvent ability restrictions on inner function types? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [FunctionParamOrReturnTag] [Reference lifetime confusion] The enum distinguishes Reference, MutableReference, and Value - can attackers exploit the lack of lifetime tracking to create dangling references by passing references to temporary values? (Critical)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [FunctionParamOrReturnTag::inner_tag()] [Type extraction safety] The function returns inner TypeTag without validation - can callers misuse this to treat references as values or vice versa, bypassing Move's ownership rules? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag::Function variant] [First-class function abuse] Function types were added in bytecode v8 - can attackers exploit chains with mixed validator versions to submit function types that some validators reject, causing consensus failures? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [FunctionTag serialization] [Recursive function nesting] Can attackers create function types containing function arguments containing function arguments recursively, exceeding MAX_TYPE_TAG_NESTING and causing deserialization panics? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [FunctionParamOrReturnTag variants] [Variant exhaustion] Only three variants exist - if Move adds new parameter passing modes (e.g., move semantics, copy-on-write), will old validators reject new function types causing protocol upgrade failures? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::new()] [Unchecked construction] The new() function accepts any AccountAddress and Identifier without validation - can attackers create ModuleIds with system addresses to impersonate core modules and bypass access control checks? (Critical)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::is_option()] [Address hardcoding] The function checks against OPTION_MODULE_ID's address - if validators disagree on what address contains the Option module, could this cause option unwrapping to fail on some validators leading to state divergence? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [pseudo_script_module_id()] [Script address collision] Script module ID uses AccountAddress::MAX_ADDRESS - can this address ever collide with legitimate user addresses, allowing attackers to overwrite script storage or deploy fake script modules? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [SCRIPT_MODULE_ID TODO comment] [Placeholder address risk] The comment mentions replacing MAX_ADDRESS with a specific hash-derived address - is the current implementation vulnerable to attacks that rely on the predictable MAX_ADDRESS value? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::Display::fmt()] [to_hex() in events] The Display trait is used in TransactionExecutionFailedEvent which is emitted on-chain - can attackers manipulate module IDs to inject malicious hex strings into on-chain events that exploit log parsing vulnerabilities? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::short_str_lossless()] [Lossless guarantee] Does short_str_lossless() truly guarantee no information loss for all possible AccountAddress values, or can some addresses have multiple valid short representations causing module resolution ambiguity? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId equivalence trait] [Hash collision] The hashbrown::Equivalent implementation allows comparing ModuleId to (&AccountAddress, &IdentStr) tuples - are hash collisions possible between ModuleId and tuple representations that could corrupt module lookup tables? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::as_refs()] [Lifetime safety] The function returns references to internal fields - can callers extend these lifetimes beyond the ModuleId's lifetime using unsafe code to create use-after-free vulnerabilities? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId From trait] [Destructuring safety] Converting ModuleId to (AccountAddress, Identifier) tuple moves out the fields - can this break code that expects ModuleId to remain valid after conversion? (Low)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [ModuleId::FromStr] [Parser injection] FromStr calls parse_module_id(s) - can attackers inject malicious strings that parse successfully but create invalid ModuleIds that crash validators when used for module resolution? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag::preorder_traversal_iter()] [Stack exhaustion] The iterator uses a Vec stack for traversal - can deeply nested types cause stack vector to grow unbounded, exhausting memory and crashing validators during type inspection? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTagPreorderTraversalIter::next()] [Infinite iteration] For circular type references (if they exist), does the iterator detect cycles, or will it loop infinitely causing validators to hang during transaction verification? (Critical)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTagPreorderTraversalIter stack] [Order manipulation] The iterator pushes children in reverse order for depth-first traversal - can attackers exploit this ordering to cause validators to process types differently based on traversal order, breaking determinism? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag traversal FunctionTag] [Nested function traversal] When traversing FunctionTag, it extends stack with results then args in reverse - is this ordering consistent with other type resolution code, or could ordering differences cause type mismatches? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [preorder_traversal_iter lifetime] [Reference validity] The iterator holds &'a TypeTag references - if the original TypeTag is modified during iteration, could this create dangling references and memory corruption? (High)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTagPreorderTraversalIter stack field] [Stack capacity attack] The Vec stack is unbounded - can attackers create type structures with thousands of direct children to cause excessive memory allocation during iterator creation? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag::struct_tag()] [Type extraction] The function returns Option<&StructTag> but doesn't validate the boxed StructTag - can attackers create malformed Struct variants that pass this check but crash when dereferenced? (Medium)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag Hash/Eq traits] [Collision attack] TypeTag derives Hash and Eq - can attackers find hash collisions between semantically different TypeTags to corrupt HashMap-based type caches and cause type confusion? (Critical)",
  "[File: third_party/move/move-core/types/src/language_storage.rs] [TypeTag PartialOrd/Ord] [Ordering inconsistency] TypeTag derives Ord for sorting - is the ordering consistent with structural equality, or can two 'equal' TypeTags have different orderings causing BTreeMap corruption? (High)"
]