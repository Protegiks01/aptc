[
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Panic vulnerability] Can an attacker craft a WriteTableItem with None data field causing unwrap() on line 66 to panic and crash the indexer, resulting in service disruption and loss of blockchain state availability? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Panic vulnerability] If write_table_item.data is None, will the multiple unwrap() calls on lines 66, 67, 74, 75 crash the indexer node, preventing it from indexing new transactions and causing state query service outages? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Panic vulnerability] Can a malicious transaction create a DeleteTableItem without data field, triggering the panic on lines 92-95, causing the indexer to permanently halt and requiring manual intervention to restore service? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Error message leak] Does the panic message on line 93 expose internal state information about the DeleteTableItem structure that could help attackers craft more sophisticated attacks against the indexer? (Low)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Data availability] If a WriteTableItem is malformed but passes initial validation, can it cause cascading failures where the indexer continuously crashes and restarts, effectively creating a persistent denial of service for state queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Hash collision] The key_hash on line 72 uses SHA256 hashing - can an attacker craft two different keys with the same hash to overwrite legitimate table entries in current_table_items, causing state corruption and loss of user data? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Hash collision] Can an attacker exploit hash collisions in key_hash (line 112) to delete wrong table entries by crafting a key that hashes to an existing entry's hash, causing unauthorized data deletion? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Struct: CurrentTableItem] [Primary key collision] The composite primary key (table_handle, key_hash) on line 14 - can hash collisions in key_hash allow attackers to overwrite unrelated table items in the same table_handle, corrupting indexed state? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Key truncation] If the key string exceeds SHA256 hash space, could there be birthday attack scenarios where attackers generate collision keys to corrupt table state with only 2^128 operations? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Hash consistency] Are key_hash values deterministic across different indexer nodes? Could hash computation differences lead to state divergence where nodes have different views of deleted items? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Address manipulation] The standardize_address() call on line 65 - can an attacker provide malformed handle strings (shorter than 2 chars) that cause out-of-bounds access in the slice operation &handle[2..], crashing the indexer? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Address validation] Does standardize_address() on lines 65 and 71 validate that the handle is a valid hex string? Can non-hex characters cause parsing errors or allow address spoofing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Address standardization bypass] Can attackers use different representations of the same address (e.g., with/without leading zeros) to create multiple entries in current_table_items that point to the same on-chain table, fragmenting state? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Address length validation] If handle string is empty or only",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Standardization inconsistency] Are the standardize_address() calls on lines 105 and 111 guaranteed to produce identical results? Could race conditions or implementation differences cause mismatches in table_handle values? (Low)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Struct: TableItem] [Integer overflow] The transaction_version field is i64 - can this overflow after 2^63 transactions, causing version numbers to wrap to negative values and breaking transaction ordering? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Struct: CurrentTableItem] [Version rollback] The last_transaction_version as i64 on line 22 - if version numbers overflow, could newer transactions appear to have older versions, allowing attackers to revert state changes? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Negative version] Can transaction_version parameter be negative? Would negative versions bypass database constraints or ordering checks, allowing out-of-order state updates? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Version manipulation] If an attacker submits transaction_version that exceeds i64::MAX, will it cause integer overflow during arithmetic operations or database insertions, corrupting the indexer database? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Struct: TableItem] [Block height overflow] The transaction_block_height as i64 - can block height overflow cause incorrect historical queries where recent blocks appear older than genesis, breaking blockchain explorers? (Low)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Write set index overflow] Can write_set_change_index overflow during bulk transaction processing, causing index collisions where multiple changes map to the same index value? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [State divergence] The function returns both TableItem and CurrentTableItem - if only one gets inserted into database due to error, will this cause state inconsistency between historical and current views? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_delete_table_item()] [Deletion inconsistency] If the CurrentTableItem deletion succeeds but TableItem insertion fails, will the indexer show item as deleted in current state but missing in history, creating unexplainable state transitions? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Function: from_write_table_item()] [Atomic transaction] Are the TableItem and CurrentTableItem insertions atomic? Can partial failures leave the database in inconsistent state where current_table_items and table_items disagree? (High)",
  "[File: aptos-core/crates/indexer/src/models/move_tables.rs] [Struct: CurrentTableItem] [Stale data] The is_deleted flag on line 23 - can race conditions cause an item to be marked deleted in CurrentTableItem while still showing as existing in historical TableItem queries? (Medium)"
]