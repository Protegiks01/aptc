[
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: verify_and_update_last_vote_round()] [Double-voting attack] Can a malicious validator exploit race conditions between checking safety_data.last_voted_round and updating it to vote twice in the same round, violating the first voting rule and enabling double-spending? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: verify_and_update_preferred_round()] [Safety violation] Can an attacker craft a proposal with a QC that has one_chain_round < preferred_round but passes verification due to missing atomicity between verification and update, breaking the second voting rule? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules_2chain.rs] [Function: safe_to_vote()] [Consensus bypass] Can a malicious validator construct a block where round != next_round(qc_round) but the check passes due to integer overflow in next_round() when qc_round is u64::MAX? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules_2chain.rs] [Function: safe_to_timeout()] [Liveness attack] Can timeout certificates be manipulated so that round == next_round(tc_round) passes but qc_round < one_chain_round, allowing premature timeouts that stall consensus? (High)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: observe_qc()] [State manipulation] Does observe_qc() properly handle concurrent updates to safety_data.one_chain_round and safety_data.preferred_round, or can race conditions cause these values to diverge across validators? (High)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: verify_epoch()] [Epoch confusion] Can an attacker submit proposals from a future epoch before epoch transition completes, bypassing epoch verification and causing validators to accept invalid proposals? (Critical)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Atomicity violation] If set_safety_data() fails after internal_store.set() but before cached_safety_data update, can this create state divergence where memory cache and persistent storage are inconsistent? (High)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: verify_qc()] [Signature bypass] When skip_sig_verify is false, can a malicious QC with invalid signatures but correct structure pass verification due to insufficient validation of the aggregate signature? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules_2chain.rs] [Function: verify_tc()] [Timeout certificate forgery] Can timeout certificates with < 2f+1 valid signatures be accepted when skip_sig_verify is conditionally enabled, allowing attackers to force round changes? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: guarded_sign_proposal()] [Proposal signing bypass] Can verify_author() be bypassed if block_data.author() returns None and the validator signer is not properly validated, allowing unauthorized proposal signing? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: next_round()] [Integer overflow] Does next_round() properly handle the case when round == u64::MAX, or can checked_add overflow cause Error::IncorrectRound to be thrown incorrectly, halting valid consensus progress? (High)",
  "[File: consensus/safety-rules/src/safety_rules_2chain.rs] [Function: construct_ledger_info_2chain()] [Commit rule bypass] Can integer overflow in next_round(block0) when block0 == u64::MAX cause the 2-chain commit rule (next_round(block0) == block1) to incorrectly trigger commits? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: verify_and_update_last_vote_round()] [Round comparison] Can integer wraparound cause round <= safety_data.last_voted_round to evaluate incorrectly when rounds are near u64::MAX, allowing duplicate votes? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: observe_qc()] [Round update overflow] If one_chain or two_chain rounds overflow u64::MAX, can this cause safety_data.one_chain_round or preferred_round to wrap to 0, breaking safety guarantees? (High)",
  "[File: consensus/safety-rules/src/safety_rules_2chain.rs] [Function: safe_to_vote()] [TC round validation] Can tc_round or hqc_round overflow cause the safety check (round == next_round(tc_round) && qc_round >= hqc_round) to pass incorrectly? (Critical)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: safety_data()] [Cache poisoning] Can cached_safety_data become stale if another process modifies internal_store directly, causing validators to operate on outdated safety data and violate voting rules? (Critical)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_safety_data()] [Partial write failure] If internal_store.set() succeeds but the process crashes before cached_safety_data is updated, will subsequent reads return stale data from cache? (High)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: consensus_sk_by_pk()] [Key confusion] Can an attacker exploit the fallback from explicit_sk to default_sk to sign proposals with the wrong private key if multiple keys exist in storage? (High)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize()] [Re-initialization attack] Can calling initialize() multiple times with different author/consensus_key values overwrite existing safety data, allowing an attacker to reset voting history? (Critical)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: set_waypoint()] [Waypoint rollback] Can an attacker set a waypoint with lower version than the current waypoint, allowing validators to accept blocks from forked chains? (Critical)",
  "[File: consensus/safety-rules/src/persistent_safety_storage.rs] [Function: initialize_keys_and_accounts()] [Inconsistent initialization] If the KeyAlreadyExists warning is triggered but author doesn't match the stored value, can this cause validators to sign with incorrect keys? (High)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: guarded_initialize()] [Epoch state mismatch] Can current_epoch > epoch_state.epoch pass validation but leave validators operating on stale epoch state, causing them to accept invalid proposals? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: guarded_initialize()] [Waypoint bypass] Can waypoint verification be bypassed if EpochChangeProof contains a valid but older waypoint that doesn't represent the current chain state? (Critical)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: guarded_initialize()] [Validator set bypass] When initialize_result fails with ValidatorKeyNotFound, does setting validator_signer = None leave the validator in a partially initialized state that can be exploited? (High)",
  "[File: consensus/safety-rules/src/safety_rules.rs] [Function: guarded_initialize()] [Key reconciliation race] Can concurrent calls to initialize() cause race conditions where validator_signer is set inconsistently across different threads? (High)"
]