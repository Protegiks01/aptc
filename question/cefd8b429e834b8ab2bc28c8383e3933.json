[
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_epoch_ending_ledger_infos_request()] [Integer Overflow] Can an attacker provide a malicious EpochEndingLedgerInfosRequest with start_epoch near u64::MAX and end_epoch at u64::MAX to cause integer overflow in the checked_sub() operation at line 1071-1076, potentially bypassing validation and causing state corruption? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_epoch_ending_ledger_infos_request()] [Integer Overflow] If the checked_add(1) operation at line 1073 succeeds but results in a value used in subsequent calculations, can an attacker craft inputs that cause downstream integer overflows in epoch calculations, leading to incorrect ledger info ranges being requested? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_epoch_ending_ledger_infos_request()] [Integer Overflow] In the missing data request creation at lines 1084-1087, can an attacker provide num_received_ledger_infos near u64::MAX to cause start_epoch.checked_add() to overflow, potentially creating invalid epoch ranges that corrupt state synchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_state_values_request()] [Integer Overflow] Can an attacker provide StateValuesWithProofRequest with start_index near u64::MAX and end_index at u64::MAX to cause integer overflow at lines 1113-1119, potentially allowing unbounded state value requests that exhaust node resources? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_state_values_request()] [Integer Overflow] In the start_index calculation at lines 1127-1130, can providing num_received_state_values near u64::MAX cause checked_add() to overflow, creating invalid state value ranges that could lead to state inconsistency across validators? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transactions_request()] [Integer Overflow] Can an attacker craft TransactionsWithProofRequest with start_version and end_version values that cause overflow at lines 1157-1163, potentially bypassing transaction count limits and causing memory exhaustion? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transactions_request()] [Integer Overflow] In the missing transaction request creation at lines 1171-1174, can overflow in start_version.checked_add(num_received_transactions) result in requesting already-processed transactions, causing duplicate transaction processing and state corruption? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transaction_outputs_request()] [Integer Overflow] Can providing end_version near u64::MAX in TransactionOutputsWithProofRequest cause integer overflow at lines 1202-1208, allowing attackers to request unbounded transaction outputs and cause node resource exhaustion? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transaction_outputs_request()] [Integer Overflow] At lines 1216-1219, can overflow in start_version calculation result in wrapping to 0 or low values, causing the node to re-request and re-process old transaction outputs, wasting resources and potentially causing state desynchronization? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transactions_or_outputs_request()] [Integer Overflow] Can an attacker exploit the overflow check at lines 1246-1254 by providing values that pass checked_sub/checked_add but cause issues in downstream processing, leading to incorrect data ranges being fetched? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: create_missing_transactions_or_outputs_request()] [Integer Overflow] In the start_version calculation at lines 1274-1277, can integer overflow allow an attacker to manipulate which transactions/outputs are re-requested, potentially causing missing data in state synchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Integer Overflow] Can an attacker manipulate first_version and num_transactions values at lines 557-563 to cause overflow in the saturating_add/saturating_sub operations, resulting in incorrect highest_response_version calculation that bypasses subscription lag detection? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Integer Overflow] At lines 570-575, can overflow in first_version + num_outputs calculation bypass lag detection, allowing a subscription stream to fall dangerously behind without triggering recovery mechanisms? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Integer Underflow] Can an attacker cause underflow in highest_advertised_version.saturating_sub(highest_response_version) at line 608 by manipulating response versions, resulting in incorrect lag calculation that prevents proper stream recovery? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_client_request()] [Integer Overflow] Can the exponential backoff calculation at lines 357-359 overflow when request_failure_count is large (u32::pow(2, count)), causing u64 multiplication overflow and resulting in extremely short or wrapped timeout values that break retry logic? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: garbage_collect_notification_response_map()] [Integer Overflow] At lines 839-843, can checked_sub() fail if max_notification_id_mappings is somehow modified to be greater than map_length, causing the function to return an error and preventing garbage collection, leading to unbounded memory growth? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: process_data_responses()] [Race Condition] At lines 458-464, the pending_response.lock().client_response.take() operation could race with concurrent task completion in spawn_request_task() at line 1502, potentially causing a response to be lost or processed twice if the lock timing is exploited? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: process_data_responses()] [Race Condition] Can concurrent calls to process_data_responses() from multiple threads cause race conditions when accessing sent_data_requests queue at lines 458-541, leading to out-of-order notification delivery and state corruption? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_client_request()] [Race Condition] Between spawning the request task at line 390 and adding the join handle to spawned_tasks, can the task complete and attempt to access DataStream state before the handle is stored, causing undefined behavior? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: clear_sent_data_requests_queue()] [Race Condition] At lines 177-185, can concurrent execution of clear_sent_data_requests_queue() and process_data_responses() cause race conditions where responses are cleared while being processed, leading to lost data notifications? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: abort_spawned_tasks()] [Race Condition] When aborting spawned tasks at lines 941-945, can tasks that are mid-execution race with the abort call, potentially leaving PendingClientResponse in an inconsistent state with partial results? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: spawn_request_task()] [Race Condition] At line 1502, the pending_response.lock().client_response assignment could race with multiple concurrent abort operations, potentially causing the response to be set after the task handle is aborted, leading to zombie responses? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: insert_notification_response_mapping()] [Race Condition] Can concurrent calls to insert_notification_response_mapping() at lines 814-832 race when checking for duplicate notification IDs, allowing two responses with the same notification ID to be inserted due to TOCTOU vulnerability? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: garbage_collect_notification_response_map()] [Race Condition] Between collecting keys to remove at lines 845-854 and actually removing them at lines 857-859, can concurrent insertions or queries cause inconsistencies in the notification map state? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: resend_data_client_request()] [Race Condition] At lines 735-744, can concurrent increments of request_failure_count from multiple threads cause incorrect failure tracking, potentially allowing infinite retries or premature stream termination? (High)"
]