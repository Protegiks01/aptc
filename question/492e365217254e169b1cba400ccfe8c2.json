[
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: trim_whitespace_and_comments()] [CRLF Injection] At line 178, '\\r\\n' is trimmed as a unit, but if attacker provides '\\r' without '\\n' or vice versa, can this cause comment boundaries to be miscalculated, allowing code in comments to be executed? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: trim_whitespace_and_comments()] [Comment Nesting] At lines 181-186, '//' comments trim until newline, but if comment contains another '//' or '/*', can this cause comment parsing confusion and allow malicious code to escape comment blocks? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: trim_whitespace_and_comments()] [Infinite Loop] The loop at lines 176-188 continues until no comments/whitespace found - can specially crafted input with alternating patterns cause this loop to run indefinitely, resulting in DoS through resource exhaustion? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: trim_whitespace_and_comments()] [Newline Manipulation] At line 182, trim_start_matches() for '\\n' might not handle all newline variants (CR, LF, CRLF, NEL, etc.) - can this cause comments to extend beyond intended boundaries? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: trim_whitespace_and_comments()] [Comment EOF] If '//' appears at end of file without trailing newline, does trim_start_matches at line 182 properly handle this case, or can it cause the lexer to incorrectly include EOF in previous token? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Struct: Lexer] [State Corruption] With mutable fields cur_start, cur_end, prev_end, and token at lines 135-138, can concurrent access or reentrancy cause race conditions where these values become inconsistent, leading to incorrect tokenization? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: advance()] [Non-atomic Update] At lines 200-206, multiple lexer state fields are updated sequentially - can interruption between these updates leave lexer in inconsistent state where cur_start/cur_end don't match token? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: replace_token()] [State Bypass] At lines 209-217, replace_token() modifies token and cur_end without updating prev_end or validating that new token is consistent with text content - can this be exploited to inject arbitrary tokens? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Field: spec_mode] [Mode Toggle Attack] The spec_mode field at line 132 changes tokenization behavior - if this flag can be manipulated during parsing, can attacker toggle between modes to cause parser confusion and accept invalid Move IR? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: peek()] [Stale Token] At line 154-156, peek() returns self.token without validating it matches current position - if lexer state is corrupted, can this return stale tokens causing parser to make incorrect decisions? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Operator Ambiguity] At lines 311-319, '&mut' is tokenized as single AmpMut token only if followed by space, but what if '&mut(' or '&mut<' appears - does this cause misparse where '&' and 'mut' are separate tokens? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Lookahead Inconsistency] At lines 327-334, '==>' is checked before '==', and '<<' before '<', but if text is exactly 2 chars long (e.g., '==' at EOF), can this cause incorrect token due to starts_with() checking beyond available text? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Comparison Operator Confusion] At lines 343-359, '<=' and '>=' are distinct from '<<' and '>>', but can attacker craft input like '<<=' that causes ambiguous tokenization depending on lookahead order? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Range Operator] At lines 368-373, '..' is tokenized as PeriodPeriod for range specs, but if this appears in non-spec context, can it cause parser confusion about whether this is two Period tokens or one range operator? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [ColonEqual Spec] At lines 376-381, ':=' is spec language update operator, but if this appears in regular Move code, does parser properly reject it, or can attacker use spec syntax in non-spec context to bypass validation? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Unrecognized Character] At lines 389-396, unrecognized characters trigger ParseError::InvalidToken, but is the error location accurate (using start_offset as u32), and can integer truncation cause incorrect error reporting that masks attack location? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Character Format String] At line 394, format!() is used with character Debug trait - can special characters cause format string issues or log injection if error messages are logged without sanitization? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: advance()] [Error Propagation] At lines 199-207, advance() returns Result but doesn't validate the token found - can malformed tokens be propagated with Ok status, causing downstream parser to process invalid input? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: lookahead()] [Error Swallowing] At lines 192-197, lookahead() can return ParseError, but if caller ignores this error, can lexer continue in corrupted state accepting invalid tokens? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: replace_token()] [No Validation] At lines 209-217, replace_token() doesn't validate that the new token matches the text content at the specified length - can this be exploited to claim arbitrary tokens exist at any position? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [VecPack Overflow] At lines 284-288, vec_pack_ suffix is parsed as u64, but is there validation that the number doesn't overflow u64::MAX or cause integer overflow in downstream vector operations? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [VecUnpack Overflow] At lines 289-293, vec_unpack_ suffix parsing can overflow - if attacker provides 'vec_unpack_18446744073709551616', does parse::<u64>() fail gracefully or cause undefined behavior? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Vec Operation Zero] Can 'vec_pack_0' or 'vec_unpack_0' tokens be created, and if so, do they cause zero-size vector operations that could trigger division by zero or allocation issues in VM? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Function: find_token()] [Vec Parse Error Fallback] At lines 287-288 and 291-292, if parse::<u64>() fails, token becomes NameBeginTyValue - can this silently hide malformed vector operations that should be rejected? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-ir-to-bytecode/syntax/src/lexer.rs] [Enum: Tok] [VecPack Token Size] At line 102, VecPack(u64) stores the count in the token itself - can extremely large counts cause the Tok enum to consume excessive memory when many such tokens exist? (Low)"
]