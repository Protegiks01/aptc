[
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [State inconsistency] Can an attacker craft a transfer event where get_to_address() equals get_from_address() with non-zero values to bypass ownership tracking, allowing them to maintain phantom ownership records in both historical and current tables causing double-spending visibility in indexer queries? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Integer overflow] When calculating write_set_change_index as -1 * event_index at line 177, can an attacker trigger an integer overflow by submitting transactions with extremely large event indices (near i64::MAX), causing index collision with legitimate write set changes and corrupting historical ownership records? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Validation bypass] Does the self-transfer check at line 168 properly handle cases where transfer_event contains malformed or manipulated addresses that normalize to the same value after standardize_address(), potentially allowing attackers to create fake transfer records that appear legitimate? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [State corruption] When creating previous ownership records with amount set to BigDecimal::zero() at line 184, can race conditions between concurrent transactions cause the current ownership record to be processed before the zero-amount record, resulting in permanent inconsistency where tokens appear both owned and not owned? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Logic error] If token_v2_metadata.get() returns None for a valid token_data_id at line 124-126, does the function properly propagate the error context, or could this mask underlying data corruption where tokens exist without corresponding object metadata, leading to silent token loss? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Type confusion] Can an attacker exploit the is_fungible_v2 check at line 121 by creating tokens that report conflicting fungibility status between TokenDataV2 and object metadata, causing the indexer to skip indexing legitimate NFTs that should be tracked? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Ownership manipulation] Does the function validate that object_core.get_owner_address() at line 129 returns a valid, non-zero address, or can tokens with invalid owner addresses (0x0, 0xFFFF...FF) be indexed, creating ghost ownership records that corrupt balance queries? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Soulbound bypass] When setting is_soulbound from !object_core.allow_ungated_transfer at line 131, can an attacker toggle this flag through contract exploits during transfer to bypass soulbound restrictions, then transfer the token while the indexer records it as permanently soulbound? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Primary key collision] Can negative write_set_change_index values (from -1 * event_index) collide with legitimate negative indices from other sources, causing INSERT conflicts in token_ownerships_v2 table and silently dropping transfer records? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_nft_v2_from_token_data()] [Data integrity] When transfer events exist but metadata.transfer_event returns Some((event_index, transfer_event)), is there validation that event_index is positive to prevent negative indices being double-negated back to positive values causing incorrect ordering? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_write_resource()] [Burn detection bypass] Can an attacker craft a write_resource with a manipulated address that doesn't match tokens_burned map keys after standardize_address() is applied, allowing them to burn tokens without the indexer recording the burn event, maintaining phantom balances? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_write_resource()] [State desync] When ObjectWithMetadata::from_write_resource() returns None at line 228, does the function return Ok(None) silently, potentially missing legitimate burn events and causing the indexer to show non-existent tokens as still owned? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_write_resource()] [Double burn] If tokens_burned contains the same token_address multiple times across different transactions, can processing the write_resource multiple times create duplicate burn records with different write_set_change_index values, corrupting token supply metrics? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_write_resource()] [Amount validation] When setting amount to BigDecimal::zero() for burned tokens at line 244, is there any validation that the previous amount was non-zero, or can this be exploited to create burn records for tokens that were never owned? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [Database timing attack] When falling back to CurrentTokenOwnershipV2Query::get_nft_by_token_data_id() at line 291-294, can an attacker exploit the timing window between burn and database query to execute a transfer, causing the indexer to record the wrong owner as the burn victim? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [Error suppression] When database lookup fails at line 296-303, the function logs an error and returns Ok(None), silently dropping the burn event - can this be exploited by attackers to burn tokens without indexer awareness, maintaining phantom balances indefinitely? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [Cache poisoning] Does prior_nft_ownership HashMap at line 287-306 properly handle cases where the cached value is stale due to concurrent updates, potentially attributing burns to the wrong owner addresses? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [SQL injection] Is the token_address passed to get_nft_by_token_data_id() properly sanitized, or can specially crafted token addresses inject SQL that modifies the query results, returning incorrect ownership data? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [State inconsistency] When cloning latest_nft_ownership at line 287-306, if the is_soulbound field is None, does this propagate correctly to the burn record, or can it cause type mismatches in downstream queries expecting non-null soulbound status? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_burned_nft_v2_from_delete_resource()] [Ownership verification] Is there validation that the owner_address from latest_nft_ownership matches the actual ObjectCore owner before the delete, or can this be exploited to falsely attribute burns to arbitrary addresses? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Resource type spoofing] Can an attacker craft a write_resource with a malicious type string that passes V2FungibleAssetResource::is_resource_supported() check at line 364 but contains exploit code in the resource data, causing arbitrary code execution during from_resource() parsing? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Type confusion] When creating MoveResource at line 367-372 with placeholder values (0 for indices), can these placeholder values cause collision with legitimate resources, leading to incorrect resource parsing and corrupted balance tracking? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Balance manipulation] Is there validation that inner.balance returned from FungibleAssetStore at line 386 is non-negative and within reasonable bounds, or can attackers create fungible assets with negative or overflow balances that corrupt total supply calculations? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Metadata mismatch] When token_v2_metadata.get(&resource.address) returns None at line 381, does returning Ok(None) allow fungible assets to exist without proper metadata, enabling creation of untraceable tokens that bypass regulatory tracking? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Frozen status bypass] When setting is_soulbound from inner.frozen at line 385, can an attacker toggle the frozen state through contract vulnerabilities after the write_resource is created but before indexing, allowing transfer of frozen assets while recorded as frozen? (Critical)"
]