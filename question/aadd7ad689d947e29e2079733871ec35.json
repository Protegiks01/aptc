[
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: FrameRefState::new()] [Inconsistent State] At lines 974-985, if reference creation fails mid-initialization, is the partially constructed frame left in an invalid state? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: pop_from_shadow_stack()] [Stack Underflow] At line 1273, can safe_unwrap on empty shadow_stack cause VM crash rather than returning proper error? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: pop_many_from_shadow_stack()] [Underflow] At line 1279, can checked_sub fail on underflow but safe_unwrap masks the error, corrupting stack state? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: push_non_refs_to_shadow_stack()] [Memory Exhaustion] Does unbounded extend at line 1258 allow memory exhaustion through repeated non-ref pushes in malicious bytecode? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: copy_loc()] [TOCTOU] At lines 1317-1346, can the local value change between immutable read and mutable poisoning operations, causing race condition? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: copy_loc()] [Reference Duplication] When copying a reference at line 1344, can the new reference bypass poison state of the original, allowing use of poisoned references? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: move_loc()] [Swap Safety] At line 1357, does mem::swap guarantee atomicity? Can concurrent access corrupt the local or moved value? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: move_loc()] [Unpoisoned Move] At line 1378, moving a reference without poison check - can this be exploited to extract poisoned references from locals? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: st_loc()] [Swap Atomicity] At line 1395, can mem::swap be interrupted, leaving locals in inconsistent state with shadow stack? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: st_loc()] [Overwrite Check] At line 1417, purging overwritten reference without checking if it was poisoned - can this hide safety violations? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: write_ref()] [Mutability Check] At line 1453, safe_assert on is_mutable - can type confusion allow immutable references to reach WriteRef, causing assertion failure? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: write_ref()] [Double Poison] After destructive_write_via_mut_ref at line 1455, the reference is purged at line 1457 - can descendants remain poisoned incorrectly? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: write_ref()] [Stack Validation] At line 1443-1444, value to write is popped but never validated - can non-reference values cause type confusion? (Low)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: freeze_ref()] [Poison Transfer] At line 1477, when converting mut to immut ref, is poison state transferred or can a poisoned mutable ref become clean immutable? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: freeze_ref()] [No Destructive Write] Unlike WriteRef, freeze_ref doesn't call destructive_write_via_mut_ref - should descendant mutable refs be poisoned? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_loc()] [Root Creation] At line 1489, ensure_local_root_exists creates root lazily - can this cause inconsistency if local was already moved? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_loc()] [Aliasing] Can multiple mutable references to the same local be created if borrow_loc is called repeatedly without proper exclusivity checks? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_child_with_label()] [Parent Purge] At line 1522, parent reference is purged - can this orphan child references if get_or_create_descendant_node fails? (High)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_child_with_label()] [Mutability Assertion] At line 1516, safe_assert checks mutability - can type confusion allow immutable parent to create mutable child? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_child_with_label()] [Poison Delay] At line 1511, poison check is immediate - could delayed checking allow more efficient but less safe execution? (Low)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_global()] [Type Abstraction] At line 1532, abstracting over all addresses - can same-type resources at different addresses interfere with each other's reference safety? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_global()] [Mutable Conflict] At line 1541, checking for any references before mut borrow - is this overly strict compared to bytecode verifier? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_global()] [Immutable Conflict] At line 1545, checking for mutable refs before immut borrow - can shared immutable borrows be blocked incorrectly? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: borrow_global()] [Root Existence] At line 1536, ensuring global root exists - can this be exploited to pre-create roots for types that don't exist? (Low)",
  "[File: third_party/move/move-vm/runtime/src/runtime_ref_checks.rs] [Function: move_from()] [Poison Coverage] At lines 1566-1571, poisoning self and descendants - do siblings or ancestors that should be affected get missed? (High)"
]