[
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_state_value_chunk_with_proof()] [Proof verification bypass] The proof is generated by storage backend but not validated before wrapping in DataResponse at line 473 - can a compromised storage layer return invalid proofs that get served to peers? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_epoch_ending_ledger_infos()] [Epoch range manipulation] Lines 478-487 retrieve epoch range from start_epoch to expected_end_epoch - can an attacker request reversed ranges (start > end) or excessively large ranges to cause storage backend issues? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_epoch_ending_ledger_infos()] [Expected epoch bypass] The expected_end_epoch at line 484 suggests client expectations - if actual end differs, does error handling properly prevent serving incorrect epoch boundaries that could cause peer desynchronization? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_epoch_ending_ledger_infos()] [Epoch boundary confusion] Can an attacker request epochs that span reconfigurations to retrieve ledger infos that expose validator set changes, aiding in timing attacks on epoch transitions? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_number_of_states_at_version()] [Version oracle] Lines 489-496 allow querying state count at any version - can an attacker use this to determine exact state growth patterns, inferring transaction types or detecting high-value state changes? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_number_of_states_at_version()] [Future version probe] Can an attacker request versions beyond current synced version to detect if the server has uncommitted state or is ahead of advertised sync status? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_number_of_states_at_version()] [Pruned state detection] If historical state is pruned, does error handling distinguish between 'version too old' vs 'version doesn't exist', potentially leaking pruning policies? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_server_protocol_version()] [Version downgrade attack] The hardcoded STORAGE_SERVER_VERSION at lines 42, 500 - can an attacker exploit version mismatch between what's advertised vs what's actually supported to force protocol downgrades? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_server_protocol_version()] [Feature detection] The protocol version response is uncached and always succeeds - can an attacker rapidly poll this to detect server restarts or configuration changes in real-time? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_storage_server_summary()] [Race condition on summary read] Lines 505-507 use Arc<ArcSwap> to load summary - during summary updates, can torn reads expose inconsistent state like mismatched version/epoch pairs? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_storage_server_summary()] [Summary staleness] The cached summary is loaded via arc-swap load() - if summary updates are delayed, can an attacker exploit stale summary to request data that should no longer be serviceable? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_storage_server_summary()] [Clone amplification] The double clone at line 507 (ArcSwap load + inner clone) - can repeated requests cause excessive allocation/deallocation cycles, creating memory pressure? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_outputs_with_proof()] [Version range validation] Lines 510-526 accept proof_version, start_version, end_version without cross-validation - can an attacker request start_version > proof_version or end_version > proof_version to bypass proof validation? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_outputs_with_proof()] [Unwrap panic] Line 523 uses .unwrap() assuming transaction_output_list_with_proof exists - can storage backend return None in edge cases, causing server panic and DoS? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_outputs_with_proof()] [Version ordering attack] Can an attacker request start_version > end_version to trigger integer underflow in size calculations within storage backend, causing incorrect chunk sizes? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_outputs_with_proof()] [Proof version manipulation] proof_version at line 515 determines proof target - can an attacker use a version that creates circular proof dependencies or references non-existent state? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_with_proof()] [Events inclusion bypass] include_events flag at line 536 - can an attacker toggle this to retrieve transaction data without events, evading event-based monitoring or analysis systems? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_with_proof()] [Unwrap panic on transaction list] Line 542 unwraps transaction_list_with_proof - similar to outputs, can this panic the server if storage returns None in unexpected conditions? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_with_proof()] [Version range boundary] Can requesting transactions at exact epoch boundaries (where version equals epoch-ending version) cause proof generation issues or include transactions from wrong epoch? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_or_outputs_with_proof()] [Output reduction manipulation] max_num_output_reductions parameter at line 556 - can an attacker set this to extreme values (0 or u64::MAX) to force unnecessary computations or bypass reduction logic entirely? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_or_outputs_with_proof()] [Response type confusion] Lines 559-566 return tuple with Options - can both be None simultaneously, and does caller handle empty responses properly without panicking? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_or_outputs_with_proof()] [Reduction attack] Can an attacker observe differences in response times based on output reduction count to infer transaction complexity or output sizes, leaking transaction metadata? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transactions_or_outputs_with_proof()] [Proof consistency] When both transactions and outputs are possible, are proofs consistent between the two representations, or can an attacker exploit proof differences to claim conflicting state? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_data_with_proof()] [Type request bypass] Line 573 passes GetTransactionDataWithProofRequest through - can the transaction_data_request_type field be manipulated to access unauthorized data types? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/handler.rs] [Function: get_transaction_data_with_proof()] [Max bytes manipulation] max_response_bytes in the request - can an attacker set this to 1 byte forcing excessive chunking, or to u64::MAX causing allocation failures? (High)"
]