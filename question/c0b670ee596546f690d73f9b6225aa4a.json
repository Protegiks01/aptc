[
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Nested handle lookup] Lines 118-119 retrieve parent_table_handle from pool_balance - if parent_table_handle is corrupted or malformed, could this propagate errors through entire balance calculation? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_delete_table_item()] [Key standardization] Line 175 standardizes delete_table_item.key as delegator_address - are delete keys guaranteed to be addresses, or could malformed keys cause indexing errors? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [Parent handle mismatch] Line 235 sets parent_table_handle to table_handle instead of inactive_pool_handle - is this a bug that could cause incorrect parent relationships in database? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Handle string conversion] Line 67 converts handle to string via .to_string() - does this preserve full precision for large addresses, or could truncation cause handle collisions? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Unbounded HashMap growth] Lines 321-324 create HashMaps without size limits - can transactions with thousands of WriteSetChanges cause excessive memory allocation leading to OOM? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [String cloning] Lines 70, 179, 400-402 clone strings multiple times - could excessive cloning in large transactions cause memory pressure and performance degradation? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Thread sleep blocking] Line 308 uses blocking sleep in retry loop - could this cause thread starvation if many queries are retrying simultaneously? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Nested iteration] Lines 328-407 have nested loops iterating WriteSetChanges - could maliciously crafted transactions with repeated changes cause O(nÂ²) processing time? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Scaling factor trust] Line 90 uses scaling_factor from pool_balance metadata - if metadata is corrupted, could wrong scaling factors cause systematic balance calculation errors affecting all delegators? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Scaling factor trust] Line 151 divides by scaling_factor without validating it matches expected value - could mismatched scaling factors between active and inactive pools cause balance inconsistencies? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Metadata staleness] pool_balance.staking_pool_address retrieved from mapping at line 70 - if mapping is built from old transactions, could stale pool addresses be used? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Metadata staleness] pool_balance retrieved at line 116 from inactive_share_to_pool mapping - are mappings guaranteed to be up-to-date with current transaction state? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Pool type confusion] Function only handles 'active_shares' type - what prevents malicious transactions from using wrong table handles, causing active shares to be misclassified? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Pool type confusion] Function only handles 'inactive_shares' type - could table handle collisions cause inactive shares to be incorrectly categorized as active? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Pool classification logic] Lines 356-393 attempt active pool processing first, then fall back to inactive - if a table handle matches both mappings, which takes precedence, and could this cause misclassification? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_delete_table_item()] [Zero balance assumption] Lines 183 sets shares to zero on delete - is this correct for all delete scenarios, or could some deletes indicate transfers rather than burns? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [Zero balance assumption] Line 234 sets shares to zero - does this properly handle cases where inactive shares are transferred to active pool rather than deleted? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Struct: CurrentDelegatorBalance] [Primary key definition] Lines 34-35 define (delegator_address, pool_address, pool_type) as primary key - can a delegator have both active and inactive shares in same pool, or would this violate uniqueness constraint? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Struct: CurrentDelegatorBalance] [Composite key handling] Primary key uses three fields at line 34 - if any field contains null or invalid data, could this cause database insertion failures? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [HashMap key collision] Line 398 constructs key from (delegator_address, pool_address, pool_type) - if strings are not properly normalized, could similar keys be treated as different? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Parent handle assignment] Line 98 sets parent_table_handle to same value as table_handle for active shares - is this intentional, or should active shares have null parent handle? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Parent handle chain] Line 159 sets parent_table_handle to inactive_pool_handle - does this correctly represent the two-level mapping hierarchy, or could this break parent-child relationships? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_delete_table_item()] [Parent handle consistency] Line 184 sets parent_table_handle to table_handle - does this match the logic in write handler, or could inconsistency cause query issues? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [Parent handle error] Line 235 sets parent_table_handle to table_handle instead of inactive_pool_handle, diverging from write handler at line 159 - is this a critical bug causing broken parent relationships? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: CurrentDelegatorBalanceQuery::get_by_inactive_share_handle()] [Parent handle query] Line 419 filters by parent_table_handle - if parent handles are inconsistent between write and delete operations, could queries return wrong results? (High)"
]