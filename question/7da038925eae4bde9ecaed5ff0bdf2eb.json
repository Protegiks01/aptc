[
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: G2Bytes::new_from_vec()] [Length validation bypass] Does new_from_vec() for G2Bytes properly enforce the 64-byte length requirement, or can attackers provide shorter/longer byte vectors that corrupt memory or inject invalid curve points? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: G1Bytes::deserialize() non-human_readable] [BCS deserialization attack] Can the BCS deserialization path for G1Bytes accept malformed binary data that bypasses the newtype_struct wrapper, injecting arbitrary byte sequences as valid points? (Critical)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: G2Bytes::deserialize() non-human_readable] [BigArray bypass] Does the BigArray deserialization for G2Bytes properly validate all 64 bytes, or can attackers exploit BigArray edge cases to inject partially-valid points with corrupted data? (Critical)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: TryInto<G1Affine> for &G1Bytes] [Affine conversion bypass] Can the G1Projective to G1Affine conversion introduce normalization issues where different projective representations of the same point produce different affine outputs, breaking equality checks? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: TryInto<G2Affine> for &G2Bytes] [Affine conversion bypass] Does G2Projective to G2Affine conversion handle edge cases like points at infinity correctly, or can these special cases be exploited to create degenerate proofs? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Constants: G1_PROJECTIVE_COMPRESSED_NUM_BYTES] [Size mismatch attack] Can the 32-byte constant for G1_PROJECTIVE_COMPRESSED_NUM_BYTES be inconsistent with actual BN254 compressed point sizes, causing truncation or buffer overflow in serialization? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Constants: G2_PROJECTIVE_COMPRESSED_NUM_BYTES] [Size mismatch attack] Is the 64-byte G2_PROJECTIVE_COMPRESSED_NUM_BYTES constant validated against actual arkworks serialization output, or can size mismatches lead to memory corruption? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_pad_and_hash_string()] [Cache poisoning] Can an attacker flood PAD_AND_HASH_STRING_CACHE with malicious (string, max_bytes) key-value pairs that cause cache eviction of legitimate values, forcing expensive recomputation and enabling DoS or timing attacks? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_jwk_hash()] [JWK cache poisoning] Can JWK_HASH_CACHE be poisoned with forged JWK objects that have malicious hash values, allowing attackers to bypass JWK verification by serving cached incorrect hashes? (Critical)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Static: PAD_AND_HASH_STRING_CACHE] [Cache size DoS] Is the 1,000 entry limit in PAD_AND_HASH_STRING_CACHE sufficient, or can attackers exhaust cache capacity with unique strings causing cache thrashing and performance degradation affecting consensus? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Static: JWK_HASH_CACHE] [Cache size DoS] Can the 100 entry limit in JWK_HASH_CACHE be exhausted by submitting transactions with unique JWKs, causing cache misses and expensive hash recomputation that slows down transaction processing? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_pad_and_hash_string()] [Race condition] Are cache insertions in cached_pad_and_hash_string() atomic, or can concurrent threads race to insert different hash values for the same key, causing non-deterministic verification results? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_jwk_hash()] [Race condition] Can concurrent calls to cached_jwk_hash() with the same JWK result in cache inconsistencies where different threads see different hash values, breaking consensus determinism? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_pad_and_hash_string()] [Cache invalidation] Is there a mechanism to invalidate PAD_AND_HASH_STRING_CACHE entries when max_bytes configuration changes, or can stale cached hashes with wrong padding cause verification failures? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_jwk_hash()] [JWK equality bypass] Does JWK_HASH_CACHE use proper equality comparison for RSA_JWK keys, or can attackers create JWKs that are equal but hash to different cache keys, bypassing cache hits and causing inconsistent behavior? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Static: PAD_AND_HASH_STRING_CACHE] [Memory exhaustion] Can unbounded cache growth from PAD_AND_HASH_STRING_CACHE (even at 1,000 entries) cause memory exhaustion on validator nodes if string keys are arbitrarily large? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Static: JWK_HASH_CACHE] [Clone overhead] Does JWK_HASH_CACHE::insert() clone the entire RSA_JWK including large modulus/exponent values, causing excessive memory overhead and potential DoS from large JWK submissions? (Medium)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_pad_and_hash_string()] [Cache key collision] Can hash collisions in the (String, usize) cache key type cause different inputs to map to the same cache entry, returning incorrect hash values and enabling signature forgery? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: cached_jwk_hash()] [Hash collision in cache key] Does RSA_JWK implement Hash correctly to avoid collisions, or can attackers craft different JWKs that hash to the same cache key, causing wrong JWK hashes to be returned? (Critical)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [Field ordering attack] Can the order of fields appended to the frs vector in hash_public_inputs() be manipulated by reordering function parameters, allowing attackers to create different public input hashes for the same logical input? (Critical)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [Extra field bypass] Does hash_public_inputs() properly differentiate between None extra_field and Some(\\",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [Override_aud manipulation] Can override_aud_val logic be bypassed by providing Some(\\",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [Timestamp overflow] Does exp_timestamp_secs conversion to Fr handle u64::MAX correctly, or can large timestamps overflow field arithmetic causing incorrect expiration validation? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [Horizon overflow] Can exp_horizon_secs overflow when converted to Fr, allowing attackers to set artificially long validity periods that bypass expiration checks? (High)",
  "[File: aptos-core/types/src/keyless/bn254_circom.rs] [Function: hash_public_inputs()] [ISS field injection] Does iss parameter validation prevent injection attacks where special characters in the issuer string could manipulate the hashed value or bypass issuer checks? (High)"
]