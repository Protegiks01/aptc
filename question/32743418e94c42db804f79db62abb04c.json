[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [String Line Extraction] At line 497, text.lines().next().unwrap() extracts first line. Can multi-line byte strings be used to inject code on second line that appears to be after the string but is actually inside it? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Missing Quote Error] When get_string_len() returns None at line 500, the error message says 'Missing closing quote'. But can this error be triggered mid-compilation of valid code if file is truncated or memory corruption occurs? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Error Location Calculation] At line 501, the error location uses start_offset + line.len() + 2. Can this calculation overflow or produce invalid locations that crash error reporting? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Hex vs Byte String] The is_hex flag at line 495 determines error type at lines 503-507. Can an attacker craft input where is_hex boolean is incorrectly set, causing wrong error messages that hide actual parsing bugs? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_string_len()] [Escape Sequence Handling] In get_string_len() (lines 760-779), backslash escapes are handled at line 764-770. Can an attacker use '\\\\\\\\\\",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_string_len()] [Escape Validation] When skipping escaped character at line 766-769, does the code validate that next_chr is a valid escape character (n, t, r, \\\\, \\",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_string_len()] [UTF-8 Length Calculation] The code uses chr.len_utf8() at lines 769 and 776 to count bytes. Can malformed UTF-8 sequences cause len_utf8() to return incorrect values leading to wrong string boundaries? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_string_len()] [Position Counter Overflow] The pos variable is incremented by chr.len_utf8(). Can extremely long strings cause pos to overflow, wrapping around and returning a small value that causes out-of-bounds string extraction? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_string_len()] [Null Character Handling] Does get_string_len() allow null bytes ('\\\\0') in strings? Can embedded nulls be used to truncate string processing in downstream C-compatible code while appearing as longer strings in Move? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Identifier Length] For identifier parsing at line 513-515, get_name_len() is called which has no maximum length limit. Can attacker provide extremely long identifiers (millions of characters) that cause excessive memory usage in symbol tables? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Label Syntax] Label parsing at lines 517-529 requires '\\'' followed by identifier. Can the validation at lines 518-520 be bypassed with multi-byte UTF-8 that looks like ASCII letter but isn't? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Label Error Location] When label validation fails at lines 521-526, the error location is start_offset+1 to start_offset+2. Can this single-character location mask multi-byte UTF-8 issues in the following character? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Label Name Length] After detecting valid label start at line 527, get_name_len(&text[1..]) gets identifier length. Can empty labels like '\\'' alone cause get_name_len() to return 0, making total label length 1 which might be invalid? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_name_len()] [Name Validation] The get_name_len() function at lines 711-715 accepts a-z, A-Z, _, 0-9 without validating first character is not digit. Can this allow identifiers starting with digit that violate Move language spec? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [String Literal Ban] At lines 530-547, plain string literals \\",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [String Error Logic] The logic at 532-546 checks if closing quote exists to determine error type. Why does finding closing quote (Some) produce InvalidByteString error while not finding quote produces InvalidCharacter error? Can this inconsistency cause confusion? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Error Message Injection] The error message at line 544 includes the character c in format! macro. Can special characters in c cause format string issues or error message injection that misleads users? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [AmpMut Parsing] The '&mut ' token at lines 550-551 requires space after 'mut'. Can variations like '&mut\\t' or '&mut\\n' be used to bypass this check while still being semantically equivalent? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Operator Precedence] Operator tokenization checks longest match first (e.g., '==>' before '=>' before '=='). Can the ordering at lines 569-578 be exploited where different orderings would tokenize same text differently? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Shift Operators] The '<<' and '>>' operators (lines 594, 606) vs '<<=' and '>>=' (lines 590, 601). Can ambiguous sequences like '< <' with spaces be tokenized differently than '<<' causing semantic differences? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Triple Operators] Special operators like '==>' (line 570) and '<==>' (line 588) are only used in spec blocks. Can these operators appearing in non-spec code contexts cause parser confusion or allow spec injection? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: find_token()] [Compound Assignment] Compound assignment operators (+=, -=, *=, etc.) are recognized at lines 630-671. Can the parser correctly distinguish 'x+=1' vs 'x += 1' vs 'x + = 1', and can spacing differences be exploited? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_name_token()] [Keyword Matching] The get_name_token() function at lines 781-812 uses string matching for keywords. Can homograph attacks using Unicode lookalike characters bypass this check, allowing 'рublic' (Cyrillic р) to appear as keyword but be treated as identifier? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_name_token()] [Case Sensitivity] Keyword matching is case-sensitive (line 802 matches 'public' exactly). Can mixed case like 'Public' or 'PUBLIC' be used as identifiers that look like keywords but aren't, misleading code reviewers? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/lexer.rs] [Function: get_name_token()] [Reserved Word List] The keyword list at lines 783-809 includes spec-related keywords like 'spec', 'invariant'. Can using these as identifiers in non-spec contexts cause issues where code appears to be specs but isn't? (Medium)"
]