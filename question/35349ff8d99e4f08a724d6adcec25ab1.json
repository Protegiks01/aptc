[
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Assign bypass] Line 86 checks Assign only in Specification mode - in General mode, can an attacker use assignment expressions within pure functions to modify state, bypassing the pureness guarantee and causing unexpected side effects? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Mutate detection] Line 90 detects Mutate operations - does this catch all forms of mutation including indirect mutations through function calls that return mutable references, or can attackers bypass this by wrapping mutate in helper functions? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Return statement handling] Lines 94-100 check Return only in Specification mode but don't set is_impure=true - can this cause early returns in specifications to be reported but not actually prevent the function from being marked pure? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Block initialization] Lines 101-109 check for uninitialized let bindings in Specification mode - can attackers use uninitialized variables in General mode to cause undefined behavior or bypass type safety? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Borrow mutability] Line 110 checks for mutable borrows (&mut) - does this properly distinguish between temporary borrows and escaping borrows that could be used for mutation after function return? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Global mutation] Lines 114-121 check BorrowGlobal(Mutable) - can attackers use immutable global borrows followed by unsafe transmutation or interior mutability patterns to modify global state while appearing pure? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Function call analysis] Lines 122-142 handle MoveFunction calls - does this properly handle indirect calls through function pointers or higher-order functions that could hide impure operations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Operation coverage] The match only checks specific Operations (Borrow, BorrowGlobal, MoveFunction) - are there other operations like Freeze, Cast, or Pack that could have impurity implications but aren't checked? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Post-order traversal] Line 82 uses visit_post_order - does this visit order allow child expressions to be evaluated before parents, potentially missing impurity that manifests only in specific parent-child combinations? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Mode enforcement] Lines 86, 94, 101 check mode == Specification - can an attacker craft code that changes the checker mode mid-execution to bypass stricter Specification mode checks and allow impure operations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: new()] [Mode initialization] Line 64 sets the mode field - if multiple checker instances with different modes are used interchangeably, can mode confusion allow Specification-level impurities to pass in General mode? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Specification strictness] Specification mode has additional checks at lines 86, 94, 101 - are there impurity patterns that should be caught in both modes but are only checked in Specification mode, allowing General mode to incorrectly mark functions as pure? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_spec()] [SpecBlock handling] Lines 152-157 wrap spec in ExpData::SpecBlock - can attackers craft malformed spec blocks that bypass normal expression traversal and hide impure operations from detection? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_spec()] [Mode assumption] check_spec creates a synthetic expression without explicitly setting mode - does this use the mode from the checker instance, or can it cause mode confusion between Specification and General checks? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Struct: FunctionPurenessCheckerMode] [Mode values] Lines 27-32 define only General and Specification modes - should there be additional modes for different contexts (inline functions, public functions, private functions) to enforce context-specific purity rules? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Native purity] Lines 168-177 determine native function purity based solely on mutable reference parameters/returns - can native functions that perform I/O, logging, random number generation, or other side effects be incorrectly classified as pure? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Parameter checking] Line 171 checks if parameters have mutable references - does this handle complex types where mutable references are nested inside structs or vectors, potentially missing hidden mutability? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Return type checking] Lines 173-176 check return types for mutable references - if a native function returns an immutable reference to a mutable global, can it bypass this check while still allowing mutation through the reference? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Missing definition] Line 161 checks if function has a definition (get_def()) - if a function's definition is temporarily unavailable or corrupted, does the fallback to native checking (lines 167-177) correctly handle this edge case? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Native function iteration] Lines 169-177 iterate over parameters and return types - can extremely large parameter lists cause performance issues or timeouts during pureness checking, allowing malicious contracts to bypass verification? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Type flattening] Line 174 uses flatten() on return types - does this properly handle all type structures, or can nested or recursive types cause incorrect flattening and wrong mutability detection? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Implicit mutability] Native function checks at lines 168-177 only look at reference mutability - can native functions that implicitly mutate global state (like emitting events or updating counters) be incorrectly classified as pure? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Callback exceptions] The impure_action callback is invoked at lines 87, 91, 95, 104, 111, 116, 135 - if this callback panics or throws an exception, can it leave the checker in an inconsistent state with corrupted visiting stack or is_impure flag? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: new()] [Callback validation] Line 62 accepts any closure F that implements FnMut - can malicious callbacks be injected that intentionally corrupt checker state or selectively ignore certain impurity patterns? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Callback ordering] Multiple callbacks are invoked during traversal - does the order matter for correctness, and can attackers exploit callback timing to cause race conditions in multi-threaded verification? (Low)"
]