[
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_test_only_attribute_name()] [Input validation bypass] Can an attacker craft attribute names with Unicode homoglyphs, zero-width characters, or case variations (e.g., 'Test', 'TEST', 'test\\u200B') that bypass the exact string comparison checks, causing production code to be incorrectly marked as test-only and excluded from compilation or verification? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_test_only_attribute_name()] [Logic error] Does the function properly handle empty strings, null bytes, or excessively long attribute names that could cause downstream parser/compiler crashes when Move modules use malformed #[test_only] or #[test] attributes? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_test_only_attribute_name()] [Verification bypass] Can malicious module developers exploit the dual acceptance of both 'test' and 'test_only' to create inconsistent verification states where test code leaks into production builds, potentially bypassing formal verification invariants and introducing unverified unsafe operations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_test_attribute_name()] [Namespace pollution] Since this function only checks for 'test', can attackers register custom attributes named 'test_only', 'test_internal', or 'test_xyz' that pass validation in some contexts but not others, leading to inconsistent compilation behavior across different toolchain versions? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_verify_only_attribute_name()] [Prover bypass] Can an attacker mark critical safety checks or invariants as #[verify_only] causing them to be excluded from production bytecode while still appearing verified, effectively bypassing formal verification guarantees and introducing exploitable logic errors in deployed contracts? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: is_verify_only_attribute_name()] [Build inconsistency] Does the single string comparison for 'verify_only' mean that typos like 'verification_only', 'verify_alone', or 'verify-only' silently fail without warnings, causing developers to mistakenly include verification-only code in production that consumes gas or exposes internal state? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_MODULE] [Module spoofing] Can an attacker create a malicious module named 'vector' in a different address space that intercepts calls intended for std::vector, allowing them to inject malicious implementations of borrow_mut, push_back, or other critical vector operations that violate memory safety? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_BORROW_MUT] [Type confusion] Does the hardcoded string 'vector::borrow_mut' properly validate that calls resolve to the correct std::vector::borrow_mut function, or can namespace collisions with custom vector modules in different addresses cause type confusion attacks that bypass Move's borrow checker? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: EVENT_EMIT_EVENT] [Event injection] Can the hardcoded 'event::emit_event' string be exploited by creating a fake event module that intercepts event emissions, allowing attackers to forge events, suppress legitimate events, or emit events with manipulated data that tricks off-chain indexers? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: BORROW_NAME, BORROW_MUT_NAME] [Bytecode substitution] Since these constants define the names of borrowing operations, can a compiler bug or malicious toolchain replacement cause incorrect bytecode generation where immutable borrows are treated as mutable borrows, violating Move's reference safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_FUNCS_WITH_BYTECODE_INSTRS] [Bytecode injection] Can an attacker exploit the hardcoded list of vector functions that map to bytecode instructions to inject malicious bytecode by creating custom implementations of 'empty', 'length', 'borrow', etc. that the VM incorrectly treats as native bytecode instructions? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_FUNCS_WITH_BYTECODE_INSTRS] [Gas metering bypass] Does the VM's gas metering correctly handle all eight functions in this list ('empty', 'length', 'borrow', 'borrow_mut', 'push_back', 'pop_back', 'destroy_empty', 'swap'), or can attackers exploit missing gas charges for bytecode-level vector operations to perform DoS attacks with under-priced transactions? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_FUNCS_WITH_BYTECODE_INSTRS] [Bounds checking] Are all vector operations in this list properly bounds-checked in both Move source and bytecode, or can out-of-bounds accesses in 'borrow', 'borrow_mut', 'pop_back', or 'swap' cause memory corruption or VM crashes when the bytecode instruction path is taken? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: VECTOR_FUNCS_WITH_BYTECODE_INSTRS] [State corruption] Can the 'destroy_empty' bytecode instruction be called on non-empty vectors through type confusion or incorrect bytecode generation, causing resource leaks or dangling references that corrupt the global state tree? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: CMP_MODULE] [Integer overflow] Does the 'cmp' module properly handle comparison operations on boundary values (u8::MAX, u64::MAX, u128::MAX, u256::MAX) without integer overflow bugs that could cause incorrect sorting, broken binary searches, or violated ordering invariants in critical data structures? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: CMP_MODULE] [Type confusion] Can the hardcoded 'cmp' module name be exploited through namespace pollution where a malicious cmp module provides incorrect comparison results, breaking stdlib collections, priority queues, or sorted maps and causing state corruption? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: TYPE_NAME_MOVE, TYPE_NAME_SPEC] [Type forgery] Can the distinction between 'type_info::type_name' (runtime) and 'type_info::$type_name' (spec) be exploited to create type confusion where prover verification uses a different type representation than runtime execution, allowing unverified type casts? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: TYPE_INFO_MOVE, TYPE_INFO_SPEC] [Reflection attack] Can the 'type_info::type_of' function be abused to leak type information about private generic parameters, internal struct layouts, or system addresses, enabling attackers to craft targeted exploits based on revealed implementation details? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: TYPE_SPEC_IS_STRUCT] [Prover inconsistency] Does the 'type_info::spec_is_struct' specification function correctly identify all struct types including nested generics, phantom types, and native types, or can type misclassification cause the prover to accept incorrect code that violates struct invariants? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: TYPE_NAME_GET_MOVE, TYPE_NAME_GET_SPEC] [Address formatting] The comment notes formatting differences between type_info::type_name and type_name::get for addresses - can this inconsistency be exploited in address comparison logic to create collision attacks where two different addresses are considered equal due to formatting discrepancies? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: TYPE_NAME_GET_MOVE] [Module confusion] Since type_name::get is in 'extlib' while type_info::type_name is in 'stdlib', can attackers exploit dependency resolution bugs to substitute malicious implementations that return forged type names, breaking type-based access control or resource segregation? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: RECEIVER_PARAM_NAME] [Method dispatch bypass] Can the hardcoded 'self' parameter name be exploited in method call resolution where functions with 'self' parameters are incorrectly treated as methods, allowing non-owner accounts to call privileged methods or bypassing capability-based access control? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: RECEIVER_PARAM_NAME] [Shadowing attack] Can malicious code define multiple parameters named 'self' or use Unicode lookalikes (e.g., Cyrillic 'ะต' instead of Latin 'e') to create shadowing confusion where the wrong parameter is bound as the method receiver, breaking object identity checks? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: make_abort_code()] [Const evaluation] Is the const fn make_abort_code() guaranteed to be evaluated at compile time, or can runtime evaluation introduce non-determinism where different validators compute different abort codes for the same reason, causing consensus failure? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: make_abort_code()] [Integer overflow] Does the bit-shifting operation '(magic << 24) | (0xB << 16) | (reason as u64)' properly handle the u16 to u64 cast for all possible reason values without overflow, underflow, or sign extension bugs that could cause abort code collisions? (Medium)"
]