[
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionOutputsWithProofRequest] [Inverted version range] Can an attacker set start_version > end_version to cause the server to panic, enter error states, or return corrupted transaction outputs with invalid proofs? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionOutputsWithProofRequest] [Proof version manipulation] Can a Byzantine peer set proof_version to an arbitrary past version to force the server to regenerate historical proofs, causing excessive I/O operations and disk thrashing? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionOutputsWithProofRequest] [Resource exhaustion via range] Can requesting a massive version range (e.g., 0 to 10^15) with no chunking or pagination cause the server to load all transaction outputs into memory, causing OOM and node crashes? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Proof version in future] Can setting proof_version to a value greater than the current ledger version cause the server to block indefinitely waiting for that version to exist, causing liveness issues? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Event data amplification] Can an attacker always set include_events=true and request large version ranges to amplify response sizes by 10-100x, causing bandwidth exhaustion and network congestion? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Zero range request] Can setting start_version=end_version=X cause unexpected behavior in range iteration, potentially returning no data, wrong data, or causing off-by-one errors in proof generation? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Epoch crossing attack] Can requesting a version range that spans multiple epochs (e.g., start in epoch 5, end in epoch 8) cause the server to generate invalid proofs that don't properly account for epoch boundaries? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Output reduction manipulation] Can an attacker set max_num_output_reductions to u64::MAX to force the server to always return transaction outputs instead of full transactions, potentially hiding critical transaction data needed for verification? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Zero output reductions] Can setting max_num_output_reductions=0 cause the server to always return full transactions even when outputs would be more efficient, leading to unnecessary bandwidth consumption and DoS? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Output reduction logic bypass] Can an attacker manipulate known_version and max_num_output_reductions together to cause the server to return a mix of transactions and outputs in a single response, breaking consistency assumptions in the client? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Known version race condition] In optimistic fetch scenarios (line 126-130), can concurrent requests with different known_version values from the same peer cause the server to return overlapping or duplicate data? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Event flag inconsistency] Can setting include_events=true but then receiving only transaction outputs (not full transactions) cause the client to expect event data that never arrives, leading to synchronization failures? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsOrOutputsWithProofRequest] [Reduction count attack] Can repeatedly requesting with max_num_output_reductions=1 force the server to oscillate between returning transactions and outputs, causing unnecessary computation and state transitions? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsOrOutputsWithProofRequest] [Proof version inconsistency] Can setting proof_version to an epoch boundary while requesting version ranges that cross epochs cause the server to generate proofs with inconsistent epoch information? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsOrOutputsWithProofRequest] [Response type confusion] Can a client that expects transactions but receives outputs due to max_num_output_reductions logic fail to verify the data correctly, potentially accepting invalid state? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionOutputsWithProofRequest] [Subscription stream collision] Can multiple clients use the same subscription_stream_id from SubscriptionStreamMetadata to cause the server to overwrite or merge subscription state, leading to data corruption or missed transactions? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionOutputsWithProofRequest] [Index manipulation] Can an attacker send subscription requests with non-sequential subscription_stream_index values (e.g., jumping from index 5 to index 100) to cause the server to lose track of subscription state or skip data? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionOutputsWithProofRequest] [Subscription DoS] Can a malicious peer create thousands of subscription streams by repeatedly sending subscribe requests with different stream IDs, exhausting server memory and causing node crashes? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionOutputsWithProofRequest] [Index rewind attack] Can an attacker send a subscription_stream_index that's lower than previously received indices to cause the server to re-send old data, wasting bandwidth and potentially causing double-processing? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionsOrOutputsWithProofRequest] [Output reduction subscription] Can dynamically changing max_num_output_reductions across subscription requests cause the server to switch between sending transactions and outputs mid-stream, breaking client parsing logic? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionsOrOutputsWithProofRequest] [Event flag mutation] Can toggling include_events between true and false across subscription indices cause inconsistent response formats that crash the client or lead to missed event data? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionsOrOutputsWithProofRequest] [Subscription index overflow] Can incrementing subscription_stream_index to u64::MAX and then wrapping to 0 cause the server to treat it as a new subscription, losing subscription state and causing data gaps? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionsWithProofRequest] [Subscription metadata forgery] Can an attacker copy the subscription_stream_metadata from a legitimate subscription and use it in their own requests to hijack the subscription stream and intercept transaction data? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionsWithProofRequest] [Event data tampering] Can setting include_events=true for subscriptions cause the server to include unverified or partially verified event data that could be manipulated by Byzantine validators? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Struct: SubscriptionStreamMetadata] [Known version at stream start manipulation] Can an attacker set known_version_at_stream_start to a value that doesn't match the actual ledger state, causing the subscription to start from an incorrect position and miss critical transactions? (Critical)"
]