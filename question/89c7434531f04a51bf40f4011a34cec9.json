[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [Epoch transition invalidation] When validator epochs change and validator sets are updated, should the verified module cache be flushed to ensure new validators re-verify all modules, or can stale cached verifications from previous epochs be exploited? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Partial flush atomicity] If flush() is called to clear the cache during epoch reconfiguration, can incomplete flushes due to race conditions leave some cached entries, causing inconsistent verification state across the network? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Transaction rollback coherence] If a transaction fails and is rolled back after calling put() to cache a module hash, does the cache entry persist, potentially caching verification for a module that was never successfully deployed? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Global state pollution] Can malicious transactions pollute the global VERIFIED_MODULES_CACHE with hashes of malicious modules that fail verification but get cached before failure is detected, affecting subsequent transactions in the same block? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Singleton initialization] Is the lazy_static initialization of VERIFIED_MODULES_CACHE thread-safe and atomic, or can race conditions during first access create multiple cache instances or corrupted state? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: empty()] [Constructor security] Does empty() properly initialize the LRU cache with correct capacity, or can integer overflow in VERIFIED_CACHE_SIZE or NonZeroUsize::new() create incorrectly sized caches? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Global state visibility] Can the global cache be accessed or modified from unsafe code, test code, or external crates in ways that bypass the intended public API and corrupt cache integrity? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Memory lifetime] Is the global VERIFIED_MODULES_CACHE properly cleaned up during validator shutdown or restart, or can stale cached entries persist across validator restarts causing incorrect verification behavior? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Arbitrary hash injection] Can an attacker with access to put() inject arbitrary 32-byte hashes into the cache without corresponding verified modules, causing subsequent module loads with those hashes to skip verification incorrectly? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Hash validation] Does put() validate that the provided module_hash corresponds to a module that actually passed verification, or can callers inject hashes for modules that failed verification or never existed? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [False positive injection] Can an attacker exploit bugs in hash computation to generate hashes that incorrectly match cached entries, causing contains() to return true for modules that were never verified? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Verification status coupling] Is there strong coupling between module verification success and cache insertion, or can put() be called independently to cache hashes regardless of verification outcome? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Duplicate hash handling] When put() is called multiple times with the same module_hash, does it properly update the LRU queue without corrupting cache state, or can duplicate insertions cause internal inconsistencies? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Constant: VERIFIED_CACHE_SIZE] [Memory limit] Does the 100,000 entry cache with 32-byte keys consume excessive memory (3.2MB+ for hashes alone), and can this contribute to validator node memory exhaustion when combined with other caches? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Struct: VerifiedModuleCache] [LRU metadata overhead] Does the LRU cache implementation have hidden memory overhead beyond the 32-byte hash keys (e.g., linked list pointers, metadata) that could cause unexpected memory consumption at scale? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Memory allocation failure] If memory allocation for new LRU cache entries fails during put(), is the error handled gracefully, or can allocation failures cause cache corruption or panic that crashes the validator? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Memory leak on flush] Does flush() properly deallocate all cached entries and LRU metadata, or can repeated flush operations leak memory over time affecting long-running validator stability? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Constant: VERIFIED_CACHE_SIZE] [Size overflow] Is NonZeroUsize::new(100_000) guaranteed to not overflow on all target platforms (32-bit vs 64-bit), or can platform-specific integer limits cause cache initialization failures? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Incomplete invalidation] When flush() is called after verifier configuration changes, does it atomically clear all entries, or can partial flushes leave stale entries that were verified under old rules? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Flush timing] Is flush() called synchronously when needed (e.g., verifier config changes, epoch transitions), or can delayed flushing allow stale cached verifications to be used after they should be invalidated? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [Stale verification] Can cached module hashes become stale if the Move VM's native function implementations change, where previously verified modules might now have undefined behavior but the cache still marks them as verified? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Flush authorization] Can flush() be called by unauthorized code paths (e.g., from Move contracts, external APIs), allowing attackers to clear the cache and force expensive re-verification DoS attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Cache versioning] Is there a cache version or generation counter to track when the cache was last invalidated, preventing stale entries from old cache generations from being used after flush? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [Non-deterministic caching] Can cache hits vs misses vary across validator nodes due to different execution histories or timing, causing some validators to verify modules while others skip verification, leading to execution time divergence? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Cache state divergence] If validators start from different cache states (e.g., after restarts, different cache sizes), can this cause permanent cache divergence where validators have different cached modules, affecting performance consistency? (Medium)"
]