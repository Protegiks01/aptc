[
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: pop_pending_response_queue()] [Race Condition] Can the check at line 684 (data_request.lock().client_response.is_some()) race with concurrent updates, causing the pop_front() at line 686 to remove a different request than the one checked? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_data_notification()] [Channel Blocking] At lines 400-418, the blocking send operation (notification_sender.send().await) could deadlock if the receiver is slow or blocked, causing the entire data stream to halt - can an attacker intentionally slow down notification processing to cause denial of service? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: new()] [Channel Exhaustion] At line 142, the channel size is limited by max_data_stream_channel_sizes config - can an attacker flood the system with requests to fill this channel, causing new notifications to block and effectively halting state synchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: spawn_request_task()] [Channel Blocking] At line 1506, the stream_update_notifier.push() could fail if the channel is full - does the silent failure (let _ =) allow notifications to be lost without proper error handling, causing the streaming service to miss data ready events? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_data_notification()] [Permanent Block] If send_failure is set to true at line 413 after a send error, can the stream become permanently blocked with no recovery mechanism, requiring a full node restart to resume synchronization? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: process_data_responses()] [Head-of-Line Blocking] At lines 458-541, the FIFO processing of responses means a single slow or failed response blocks all subsequent responses - can an attacker exploit this by causing specific requests to fail repeatedly, halting the entire stream? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Stream Lag Attack] Can a malicious node provide subscription responses with artificially low version numbers at lines 557-585 to trigger false stream lag detection, causing legitimate subscriptions to be terminated unnecessarily? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Stream Lag Bypass] At lines 600-603, can an attacker provide highest_response_version >= highest_advertised_version to reset subscription_stream_lag even if the stream is actually lagging, bypassing recovery mechanisms? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: SubscriptionStreamLag::is_beyond_recovery()] [Recovery Bypass] At lines 968-993, can an attacker manipulate the lag duration check by providing responses that alternate between lagging and non-lagging states, preventing the lag duration from ever exceeding max_subscription_stream_lag_secs? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: SubscriptionStreamLag::is_beyond_recovery()] [Time Manipulation] Can time service manipulation at lines 974-975 allow an attacker to bypass the stream lag duration check, preventing legitimate stream failures from being detected? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: check_subscription_stream_lag()] [Lag State Manipulation] At lines 609-629, can an attacker repeatedly trigger lag states just below the recovery threshold to keep the stream in a degraded state indefinitely without triggering failure? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: SubscriptionStreamLag::is_beyond_recovery()] [Version Lag Update] At lines 987-990, the version_lag is only updated downward when current_stream_lag < self.version_lag - can this logic be exploited to freeze lag detection at an artificially high value? (Low)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: process_data_responses()] [Retry Limit Bypass] At line 448, the check request_failure_count >= max_request_retry could be bypassed if request_failure_count overflows or wraps, allowing infinite retries that never terminate the stream? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: resend_data_client_request()] [Failure Count Manipulation] At line 735, can concurrent increments of request_failure_count from multiple error paths cause incorrect failure tracking, potentially terminating streams prematurely or allowing excessive retries? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_data_notification_to_client()] [Failure Reset Exploit] At line 808, request_failure_count is reset to 0 after successful notification - can an attacker exploit this by ensuring occasional successes between many failures to bypass retry limits? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: send_client_request()] [Exponential Backoff Overflow] At lines 357-359, if request_failure_count grows large, the exponential calculation u32::pow(2, count) could overflow before being multiplied by response_timeout_ms - does this cause the timeout to wrap to a small value, breaking backoff? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: handle_data_client_error()] [Error Loop] At lines 712-726, errors always trigger resend_data_client_request() without distinguishing between recoverable and non-recoverable errors - can permanent errors cause infinite retry loops? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: resend_data_client_request()] [Request Queue Pollution] At lines 741-742, failed requests are pushed to the front of the queue - can repeated failures cause the same request to dominate the queue head, preventing other requests from being processed? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: insert_notification_response_mapping()] [Notification ID Collision] At lines 819-828, if the notification_id_generator produces duplicate IDs, the error case returns an error but doesn't prevent the duplicate from potentially causing state corruption - is this properly handled? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: garbage_collect_notification_response_map()] [GC Timing Attack] At lines 834-862, the garbage collection removes oldest notification IDs when map exceeds max_notification_id_mappings - can an attacker trigger excessive new mappings to cause premature GC of notifications still awaiting feedback? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: handle_notification_feedback()] [Missing Notification] At lines 251-259, if a notification_id is not found in notifications_to_responses, an error is returned - can notifications be garbage collected before feedback arrives, causing legitimate feedback to be treated as an error? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: sent_notification()] [ID Verification Bypass] At lines 223-232, the function checks both stream_end_notification_id and notifications_to_responses - can the order of checks be exploited to cause incorrect notification ownership determination? (Low)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: garbage_collect_notification_response_map()] [Incomplete GC] At lines 845-859, if num_entries_to_remove is large, the iteration could be slow - can this cause other operations to be delayed, creating a timing vulnerability? (Low)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: sanity_check_client_response_type()] [Type Confusion] At lines 1293-1380, the function only checks payload type matching - can an attacker provide correctly-typed but malicious data that passes this check but fails later validation, causing state corruption? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/data_stream.rs] [Function: sanity_check_client_response_type()] [Incomplete Validation] For TransactionsOrOutputsWithProof requests at lines 1370-1378, both transaction and output response types are accepted - can this flexibility be exploited to cause inconsistent state by alternating response types? (Medium)"
]