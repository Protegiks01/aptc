[
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Path Traversal] Can an attacker provide a malicious source_location path containing '../' sequences or absolute paths to read arbitrary files from the filesystem, potentially exposing sensitive validator configuration files or private keys? (High)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Symlink Attack] If source_location is a symlink to a sensitive file outside the intended directory, does fs::read_to_string follow the symlink and expose unauthorized file contents to the viewer? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Resource Exhaustion] Can an attacker specify a source_location pointing to an extremely large file (e.g., /dev/zero, multi-GB log files) causing fs::read_to_string to consume unbounded memory and crash the tool or validator node? (High)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Denial of Service] Does the unwrap() on fs::read_to_string at line 30 cause a panic when the file doesn't exist, is unreadable, or has permission errors, leading to tool crashes and inability to debug Move contracts? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Race Condition] Can an attacker modify the source file between the read operation and source_map.check() validation, causing time-of-check-time-of-use (TOCTOU) vulnerabilities where mismatched source code is displayed? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Assertion Failure] The assert! at line 31-34 panics if source_map.check(&file_contents) returns false - can an attacker provide a deliberately mismatched source_map to cause tool crashes and prevent bytecode analysis? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Source Map Manipulation] Can an attacker craft a source_map with incorrect file hashes that fails the check() validation, causing the assert to panic and denying service to developers trying to audit bytecode? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Hash Collision] If source_map.check() only validates file hash (not structural integrity), can an attacker find hash collisions to pass validation with malicious source code that doesn't match the actual bytecode? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Integer Overflow] At line 63, loc_end.checked_add(CONTEXT_SIZE).unwrap() will panic if the addition overflows - can large loc_end values (near usize::MAX) cause panics when displaying source context? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Type Conversion] At lines 53-54, loc.start() and loc.end() are cast 'as usize' - can these conversions from u32/u64 to usize cause truncation on 32-bit systems, leading to incorrect source spans? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Underflow Safety] At line 60, saturating_sub is used safely, but if CONTEXT_SIZE is extremely large, does context_start always equal 0, potentially revealing unintended parts of the source file? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Constant Manipulation] The CONTEXT_SIZE constant is set to 1000 at line 16 - can this be modified to usize::MAX to cause integer overflows in checked_add() or expose entire files? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Array Index] At line 55, source_code[self.file_index] accesses the vector without bounds checking - can file_index be manipulated to exceed source_code.len() causing an out-of-bounds panic? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: backing_string()] [Array Index] At line 78, source_code[self.file_index].clone() also indexes without validation - can concurrent modifications or initialization errors cause file_index to be invalid? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Vector Indexing] At line 36, file_index is set to source_code.len() - 1 - if source_code is empty, this causes integer underflow wrapping to usize::MAX, leading to out-of-bounds access in subsequent operations? (High)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [String Slicing] At line 66, source[context_start..loc_start] slices the string - if context_start > loc_start due to logic errors, does this cause a panic or incorrect substring extraction? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [UTF-8 Boundary] At lines 66-68, string slicing assumes character boundaries - if loc_start or loc_end fall in the middle of a multi-byte UTF-8 character, does this cause a panic or string corruption? (High)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Empty Span] If loc_start equals loc_end, does source[loc_start..loc_end] at line 67 create an empty highlight, potentially hiding critical code in the viewer? (Low)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Out of Bounds] If loc_end exceeds source.len(), does the min() operation at line 63 prevent out-of-bounds access, or can malformed Loc values still cause panics in the string slicing operations? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Invalid Location] At lines 49-51, source_map.get_code_location() returns a Result<Loc> - can it return locations with start > end, causing logic errors in the span calculation? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Location Overflow] Can get_code_location() return Loc values where start() or end() exceed the actual file length, causing the string slicing operations to fail despite the min() check? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Invalid Function Index] If bytecode_info.function_index points to a non-existent function in the source_map, does get_code_location() return an appropriate error or cause undefined behavior? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [Invalid Code Offset] If bytecode_info.code_offset is beyond the function's bytecode length, can get_code_location() return arbitrary or out-of-bounds locations? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: ModuleViewer::new()] [Memory Consumption] At line 35, the entire file contents are pushed into source_code vector - can repeated calls with large files cause unbounded memory growth and OOM crashes? (Medium)",
  "[File: third_party/move/tools/move-bytecode-viewer/src/source_viewer.rs] [Function: source_for_code_location()] [String Allocation] At lines 71-73, three String allocations (to_string() calls) are made per source lookup - can rapid repeated calls exhaust memory or cause performance degradation? (Low)"
]