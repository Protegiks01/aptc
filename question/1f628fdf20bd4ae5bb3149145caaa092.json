[
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share_with_metadata()] [Retain before add] The retain() call before add_share() filters shares based on new metadata - can this cause valid shares from honest validators to be discarded if they arrived before self share? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share_with_metadata()] [Weight map trust] The share_weights HashMap is provided by caller - can malicious code provide manipulated weights that don't match actual validator stakes, bypassing threshold requirements? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share_with_metadata()] [Memory replacement] The std::mem::replace() with Author::ONE dummy could cause issues if other code accesses the item concurrently - is there proper synchronization to prevent use-after-move? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::add_share_with_metadata()] [Metadata clone] The metadata is cloned from the share - can this create inconsistencies if the share's metadata is mutated after cloning but before transition to PendingDecision? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::get_all_shares_authors()] [Unreachable panic] The unreachable!() in PendingMetadata state assumes function is only called after block is added - can incorrect caller logic trigger this panic and crash the validator? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::get_all_shares_authors()] [Information disclosure] Returning None for Decided state prevents querying which validators participated - can this hide Byzantine validators who contributed to randomness generation? (Low)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareItem::get_all_shares_authors()] [Timing attack] Can malicious validators use this function to query which honest validators have submitted shares, timing their Byzantine behavior to maximize impact? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::new()] [Epoch mismatch] Can creating a SecretShareStore with incorrect epoch value allow shares from wrong epoch to be accepted, causing randomness from different epochs to be mixed? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::new()] [Config validation] Does the constructor validate that secret_share_config matches the validator set for the given epoch, or can mismatched configs allow invalid threshold calculations? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::new()] [Channel verification] Can an attacker provide a malicious decision_tx channel that drops messages or sends them to wrong destination, preventing randomness from reaching consensus? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::new()] [Author validation] Is self_author verified to be a valid validator in the current epoch, or can invalid authors be set, causing issues in self share handling? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::update_highest_known_round()] [Round manipulation] Can a Byzantine validator send fake blocks with very high round numbers to inflate highest_known_round, causing legitimate shares from current rounds to be rejected as 'future rounds'? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::update_highest_known_round()] [Integer overflow] Can round values close to u64::MAX cause overflow in calculations using highest_known_round, particularly in the FUTURE_ROUNDS_TO_ACCEPT checks? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::update_highest_known_round()] [Monotonicity violation] The max() operation ensures monotonic increase, but can concurrent updates cause stale reads where one thread sees lower value than another despite later update? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::update_highest_known_round()] [Liveness attack] Can an attacker repeatedly call this with progressively higher rounds to prevent any shares from being accepted within the FUTURE_ROUNDS_TO_ACCEPT window? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [Assert bypass] The assert! for self_author matching can be bypassed in release builds - can this allow non-self shares to be added with metadata, breaking the state machine invariants? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [Epoch validation] Can an attacker replay self shares from previous epochs that pass the epoch check due to epoch number reuse or overflow? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [Future round attack] The FUTURE_ROUNDS_TO_ACCEPT constant allows shares up to highest_known_round + FUTURE_ROUNDS_TO_ACCEPT - can Byzantine validators exploit this window to inject shares for rounds that haven't been proposed yet? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [Peer weight manipulation] The get_peer_weights() call retrieves weights from config - can the config be corrupted to return incorrect weights, allowing threshold bypass? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [State corruption] After add_share_with_metadata(), try_aggregate() is immediately called - can this cause race conditions if other threads are adding shares to the same round concurrently? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [Error handling] If add_share_with_metadata() returns an error, the function propagates it, but try_aggregate() is not called - can this leave the store in an inconsistent state? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_self_share()] [HashMap growth] The or_insert_with() creates new entries unboundedly - can this cause memory exhaustion if attacker triggers creation of many round entries? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_share()] [Weight lookup] The get_peer_weight() for share.author() could return incorrect weight if peer weights are not synchronized with actual validator set - can this allow threshold bypass? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_share()] [Epoch replay] Shares from old epochs are rejected with ensure! check, but can epoch wraparound at u64::MAX allow ancient shares to appear valid? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_store.rs] [Function: SecretShareStore::add_share()] [Future round window] The FUTURE_ROUNDS_TO_ACCEPT check allows some future rounds - can Byzantine validators pre-generate and submit shares for future rounds to bias randomness? (High)"
]