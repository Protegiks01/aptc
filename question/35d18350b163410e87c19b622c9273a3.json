[
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [ReDoS Attack] Can an attacker craft a malicious URI with nested repetitions or catastrophic backtracking patterns that causes the regex at line 40 (r'^(ipfs/)(?P<cid>[a-zA-Z0-9]+)(?P<path>/.*)?$') to consume excessive CPU resources, causing denial of service to the NFT metadata crawler? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [ReDoS Attack] Does the regex at line 43 (r'https:\\/\\/(?P<cid>[^\\.]+)\\.ipfs\\.[^\\/]+(?P<path>\\/.+)?') have polynomial time complexity when processing URIs with many dots or slashes, allowing attackers to freeze the crawler with specially crafted redirect URIs? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [ReDoS Attack] Can the path regex group '(?P<path>/.*)?' at line 40 be exploited with extremely long path strings (millions of characters) to cause memory exhaustion or timeout, disrupting NFT metadata indexing? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [ReDoS Attack] Does the negated character class '[^\\.]+ and [^\\/]+' in line 43's regex create exponential backtracking opportunities when fed URIs with alternating valid/invalid characters, enabling algorithmic complexity attacks? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [URL Injection] Can an attacker inject malicious URLs by crafting URIs with encoded characters (e.g., %0d%0a for CRLF) that bypass the Url::parse() check at line 45 but later get interpreted as HTTP header injection by the HTTP client? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [SSRF Attack] Does the Url::parse() call at line 45 validate that parsed URLs don't redirect to internal/private IP addresses (127.0.0.1, 192.168.x.x, 10.x.x.x), allowing attackers to make the crawler access internal Aptos infrastructure? (Critical)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [URL Parsing Bypass] Can attackers use URL encoding tricks (double encoding, unicode normalization, punycode domains) to bypass the ipfs_prefix matching while still reaching malicious endpoints after the URL gets normalized by downstream HTTP clients? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Protocol Smuggling] Does the URI replacement at line 28 ('ipfs://' -> 'https://ipfs.com/ipfs/') properly handle edge cases like 'ipfs:////' or 'ipfs://\\x00' that could lead to protocol smuggling or null byte injection vulnerabilities? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Path Traversal] Can the path extraction at lines 45-47 be exploited with path traversal sequences (../, ../../) that escape the intended IPFS directory structure and access arbitrary files on the gateway server? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Auth Bypass] Can an attacker craft URIs that already contain query parameters, causing the ipfs_auth_param appended at line 73 to be ignored or overridden, allowing unauthorized access to authenticated IPFS gateways? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Query Parameter Injection] Does the auth parameter construction at lines 33-37 properly escape special characters in ipfs_auth_key, or can attackers inject additional query parameters (e.g., '&admin=true') through the IPFS_AUTH_KEY constant? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: format_capture()] [Auth Token Leakage] Can the formatted URI at lines 68-74 inadvertently expose authentication tokens in server logs, error messages, or metrics if the ipfs_auth_param contains sensitive credentials? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Credential Stuffing] Does the code validate the format and length of ipfs_auth_key before using it, or can attackers supply extremely long auth keys (MB/GB size) to cause buffer overflows or memory exhaustion? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Invalid CID Handling] Does the regex pattern '[a-zA-Z0-9]+' at line 40 properly validate IPFS CIDs, or can attackers supply invalid CIDs (wrong length, invalid multihash) that cause downstream errors or fetch incorrect/malicious content? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [CID Collision Attack] Can an attacker generate malicious content with CIDs that collide with legitimate NFT metadata CIDs due to weak hash functions, causing the crawler to index incorrect/malicious metadata and corrupt the NFT database? (Critical)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: format_capture()] [CID Length Overflow] Does the code limit the maximum length of captured CIDs at line 64, or can attackers provide extremely long CID strings (GB size) that cause string concatenation memory exhaustion at lines 68-74? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [CID Character Injection] Can special characters or control characters be injected into the CID field (captured at line 64) that later get interpreted as command separators or path traversal sequences by the IPFS gateway? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: format_capture()] [Format String Injection] Does the string concatenation at lines 68-74 properly sanitize the cid, path, and ipfs_auth_param values, or can attackers inject format specifiers (%s, %x) that cause information disclosure or crashes? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: format_capture()] [Null Byte Injection] Can attackers include null bytes (\\x00) in the path or cid fields that truncate the formatted string at line 68-74, causing the final URI to be different from what the validation logic expects? (High)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Unicode Normalization Attack] Does the code handle unicode characters in URIs consistently, or can attackers use lookalike characters (homoglyphs) in domains/paths to bypass allowlists while directing the crawler to malicious endpoints? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [String Replacement Logic Bug] Can the string replace operation at line 28 ('ipfs://' -> 'https://ipfs.com/ipfs/') be bypassed with variations like 'IPFS://', 'ipfs://', or 'ipfs:%2F%2F' due to case sensitivity or encoding differences? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Error Message Information Disclosure] Does the error returned at line 55 ('Invalid IPFS URI') leak sensitive information about internal parsing logic, regex patterns, or system configuration that could help attackers craft better exploits? (Low)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Panic on Regex Compilation] Can the Regex::new() calls at lines 40 and 43 panic if the regex pattern is malformed or too complex, causing the entire crawler to crash and disrupting NFT metadata indexing? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Unwrap Safety] Does the code at lines 34, 50, 72-73 with unwrap() and unwrap_or_default() properly handle all edge cases, or can None values in unexpected states cause panics that crash the crawler? (Medium)",
  "[File: aptos-core/ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs] [Function: parse()] [Error Propagation] Does the anyhow::Result error type at line 20 properly sanitize error messages before they're logged or returned to API clients, preventing information leakage about internal URIs or credentials? (Low)"
]