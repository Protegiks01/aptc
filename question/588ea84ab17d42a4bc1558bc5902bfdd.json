[
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_io_gas_for_event()] [Event Memory] Delegated at line 585. Do large events charge memory quota? Combined with event module leak, can this exhaust memory? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_read_ref()] [Shared Reference Memory] Line 391 charges memory for reading references. For shared references, can multiple reads cause multiplicative memory charges? (Medium)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_write_ref()] [Mutable Reference Memory] Line 407 releases old value memory. For mutable references, does this correctly track reference aliasing? (Low)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_br_true()] [Branch Memory State] Delegated at line 133. Is memory quota state correctly maintained across branch targets? (Low)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_br_false()] [False Branch Memory] Delegated at line 135. Can conditional branches cause memory tracking divergence between validators? (Low)",
  "[File: aptos-core/aptos-move/aptos-memory-usage-tracker/src/lib.rs] [Function: charge_branch()] [Unconditional Branch] Delegated at line 137. Are backward branches (loops) tracked correctly for memory accumulation? (Low)",
  "[File: aptos-\n\n### Citations\n\n**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L1-599)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse aptos_gas_algebra::{\n    AbstractValueSize, Fee, FeePerGasUnit, InternalGas, NumArgs, NumBytes, NumTypeNodes,\n};\nuse aptos_gas_meter::{AptosGasMeter, CacheValueSizes};\nuse aptos_types::{\n    account_config::CORE_CODE_ADDRESS, contract_event::ContractEvent,\n    state_store::state_key::StateKey, write_set::WriteOpSize,\n};\nuse move_binary_format::{\n    errors::{PartialVMError, PartialVMResult, VMResult},\n    file_format::CodeOffset,\n};\nuse move_core_types::{\n    account_address::AccountAddress, identifier::IdentStr, language_storage::ModuleId,\n    vm_status::StatusCode,\n};\nuse move_vm_types::{\n    gas::{DependencyGasMeter, DependencyKind, GasMeter, NativeGasMeter, SimpleInstruction},\n    views::{TypeView, ValueView},\n};\n\n/// Special gas meter implementation that tracks the VM's memory usage based on the operations\n/// executed.\n///\n/// Must be composed with a base gas meter.\npub struct MemoryTrackedGasMeter<G> {\n    base: G,\n\n    memory_quota: AbstractValueSize,\n    should_leak_memory_for_native: bool,\n}\n\nimpl<G> MemoryTrackedGasMeter<G>\nwhere\n    G: AptosGasMeter + CacheValueSizes,\n{\n    pub fn new(base: G) -> Self {\n        let memory_quota = base.vm_gas_params().txn.memory_quota;\n\n        Self {\n            base,\n            memory_quota,\n            should_leak_memory_for_native: false,\n        }\n    }\n\n    #[inline]\n    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {\n        if self.feature_version() >= 3 {\n            match self.memory_quota.checked_sub(amount) {\n                Some(remaining_quota) => {\n                    self.memory_quota = remaining_quota;\n                    Ok(())\n                },\n                None => {\n                    self.memory_quota = 0.into();\n                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))\n                },\n            }\n        } else {\n            Ok(())\n        }\n    }\n\n    #[inline]\n    fn release_heap_memory(&mut self, amount: AbstractValueSize) {\n        if self.feature_version() >= 3 {\n            self.memory_quota += amount;\n        }\n    }\n}\n\n// TODO: consider switching to a library like https://docs.rs/delegate/latest/delegate/.\nmacro_rules! delegate {\n    ($(\n        fn $fn: ident $(<$($lt: lifetime),*>)? (&self $(, $arg: ident : $ty: ty)* $(,)?) -> $ret_ty: ty;\n    )*) => {\n        #[inline(always)]\n        $(fn $fn $(<$($lt)*>)? (&self, $($arg: $ty),*) -> $ret_ty {\n            self.base.$fn($($arg),*)\n        })*\n    };\n}\n\nmacro_rules! delegate_mut {\n    ($(\n        fn $fn: ident $(<$($lt: lifetime),*>)? (&mut self $(, $arg: ident : $ty: ty)* $(,)?) -> $ret_ty: ty;\n    )*) => {\n        #[inline(always)]\n        $(fn $fn $(<$($lt)*>)? (&mut self, $($arg: $ty),*) -> $ret_ty {\n            self.base.$fn($($arg),*)\n        })*\n    };\n}\n\nimpl<G> DependencyGasMeter for MemoryTrackedGasMeter<G>\nwhere\n    G: AptosGasMeter,\n{\n    delegate_mut! {\n        fn charge_dependency(&mut self, kind: DependencyKind, addr: &AccountAddress, name: &IdentStr, size: NumBytes) -> PartialVMResult<()>;\n    }\n}\n\nimpl<G> NativeGasMeter for MemoryTrackedGasMeter<G>\nwhere\n    G: AptosGasMeter + CacheValueSizes,\n{\n    delegate! {\n        fn legacy_gas_budget_in_native_context(&self) -> InternalGas;\n    }\n\n    delegate_mut! {\n        fn charge_native_execution(&mut self, amount: InternalGas) -> PartialVMResult<()>;\n    }\n\n    #[inline]\n    fn use_heap_memory_in_native_context(&mut self, amount: u64) -> PartialVMResult<()> {\n        self.use_heap_memory(amount.into())\n    }\n}\n\nimpl<G> GasMeter for MemoryTrackedGasMeter<G>\nwhere\n    G: AptosGasMeter + CacheValueSizes,\n{\n    delegate_mut! {\n        fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()>;\n\n        fn charge_br_true(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;\n\n        fn charge_br_false(&mut self, target_offset: Option<CodeOffset>) -> PartialVMResult<()>;\n\n        fn charge_branch(&mut self, target_offset: CodeOffset) -> PartialVMResult<()>;\n\n        fn charge_call(\n            &mut self,\n            module_id: &ModuleId,\n            func_name: &str,\n            args: impl ExactSizeIterator<Item = impl ValueView> + Clone,\n            num_locals: NumArgs,\n        ) -> PartialVMResult<()>;\n\n        fn charge_ld_const(&mut self, size: NumBytes) -> PartialVMResult<()>;\n\n        fn charge_move_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;\n\n        fn charge_store_loc(&mut self, val: impl ValueView) -> PartialVMResult<()>;\n\n        fn charge_borrow_global(\n            &mut self,\n            is_mut: bool,\n            is_generic: bool,\n            ty: impl TypeView,\n            is_success: bool,\n        ) -> PartialVMResult<()>;\n\n        fn charge_exists(\n            &mut self,\n            is_generic: bool,\n            ty: impl TypeView,\n            // TODO(Gas): see if we can get rid of this param\n            exists: bool,\n        ) -> PartialVMResult<()>;\n\n        fn charge_move_from(\n            &mut self,\n            is_generic: bool,\n            ty: impl TypeView,\n            val: Option<impl ValueView>,\n        ) -> PartialVMResult<()>;\n\n        fn charge_move_to(\n            &mut self,\n            is_generic: bool,\n            ty: impl TypeView,\n            val: impl ValueView,\n            is_success: bool,\n        ) -> PartialVMResult<()>;\n\n        fn charge_vec_len(&mut self) -> PartialVMResult<()>;\n\n        fn charge_vec_borrow(\n            &mut self,\n            is_mut: bool,\n        ) -> PartialVMResult<()>;\n\n        fn charge_vec_swap(&mut self) -> PartialVMResult<()>;\n\n        fn charge_create_ty(&mut self, num_nodes: NumTypeNodes) -> PartialVMResult<()>;\n    }\n\n    #[inline]\n    fn balance_internal(&self) -> InternalGas {\n        self.base.balance_internal()\n    }\n\n    #[inline]\n    fn charge_call_generic(\n        &mut self,\n        module_id: &ModuleId,\n        func_name: &str,\n        ty_args: impl ExactSizeIterator<Item = impl TypeView> + Clone,\n        args: impl ExactSizeIterator<Item = impl ValueView> + Clone,\n        num_locals: NumArgs,\n    ) -> PartialVMResult<()> {\n        // Save the info for charge_native_function_before_execution.\n        self.should_leak_memory_for_native = (*module_id.address() == CORE_CODE_ADDRESS\n            && module_id.name().as_str() =="
]