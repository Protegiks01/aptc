[
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable() & disable()] [Missing access control] The enable() and disable() methods at lines 313-321 are public functions with no access control checks. Can any code (including malicious smart contracts) call these methods to arbitrarily modify feature flags, bypassing governance and enabling/disabling critical security features? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [OnChainConfig trait] [Update authorization] The OnChainConfig trait is implemented at lines 289-292, but there's no visible access control in this file. How is on-chain feature flag modification authorized? Can an attacker bypass governance voting by directly modifying the Features resource at CORE_CODE_ADDRESS? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: disable()] [Immutable flag enforcement] At line 318, disable() can be called on any FeatureFlag. However, flags like _REJECT_UNSTABLE_BYTECODE (line 80) and _LIMIT_VM_TYPE_SIZE (line 92) are documented as 'cannot be disabled'. Is there runtime enforcement? Can governance proposals disable these immutable flags, breaking critical security invariants? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default_features()] [Governance override] At lines 162-266, default_features() returns a hardcoded list. Can governance proposals override this default list to exclude critical security features from newly bootstrapped validators, creating a persistent security vulnerability across the network? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: enable()] [Privilege escalation] If a low-privilege account gains the ability to call enable() directly (bypassing governance), can they enable ENABLE_TRUSTED_CODE to execute optimized but unverified code, gaining arbitrary code execution capabilities on validator nodes? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Struct: Features] [Direct field access] The features field is public at line 273. Can external code directly modify `features.features` vector, bypassing the enable/disable logic and creating inconsistent feature flag states that violate invariants? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: aptos_test_feature_flags_genesis()] [Genesis privilege] At lines 493-507, this function creates a ChangeSet for genesis. Who can call this function in production? Can an attacker with genesis privileges use this to initialize the chain with a compromised feature flag set (e.g., all security features disabled)? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag enum] [Future flag reservation] The highest FeatureFlag is currently 105 (ENABLE_FUNCTION_REFLECTION at line 158). Are enum values 106+ reserved? Can an attacker pre-enable undocumented future flags before they're officially defined, gaining access to unreleased features with unknown security properties? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: default_for_tests()] [Environment confusion] At lines 297-302, default_for_tests() disables ENABLE_TRUSTED_CODE. Can an attacker trick production systems into using test defaults (e.g., by manipulating environment variables), degrading security posture and enabling attacks that shouldn't work in production? (Medium)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [Function: into_flag_vec()] [Information disclosure] At line 323, into_flag_vec() consumes self and returns all enabled flags as a vector. Can unauthorized parties call this to enumerate all feature flags including sensitive security settings, gaining intelligence for targeted attacks? (Low)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: _REJECT_UNSTABLE_BYTECODE] [Bytecode injection] The _REJECT_UNSTABLE_BYTECODE flag at line 80 is marked as 'enabled on mainnet, can never be disabled' but lacks runtime enforcement in disable(). If governance maliciously disables this flag, can attackers deploy unstable or experimental bytecode containing known exploits, compromising smart contract security? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: _DISALLOW_USER_NATIVES] [Native function injection] The _DISALLOW_USER_NATIVES flag at line 95 prevents user-defined native functions. If this flag is disabled through governance attack, can malicious modules register custom native functions with arbitrary Rust code execution, achieving RCE on validator nodes? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: _SIGNATURE_CHECKER_V2] [Signature forgery] The _SIGNATURE_CHECKER_V2 flag at line 38 controls signature verification logic. If this flag is disabled, does the system fall back to an older signature checker with known vulnerabilities? Can attackers forge signatures to authorize unauthorized transactions? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: CHARGE_INVARIANT_VIOLATION] [Gas bypass] The CHARGE_INVARIANT_VIOLATION flag at line 40 controls whether invariant violations incur gas charges. If disabled, can attackers repeatedly trigger invariant violations without paying gas, executing infinite loops and causing validator DoS without economic cost? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: GAS_PAYER_ENABLED] [Fee manipulation] The GAS_PAYER_ENABLED flag at line 42 enables sponsored transactions. If enabled without proper validation elsewhere, can attackers force arbitrary accounts to pay for their malicious transactions, draining victim funds? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: STORAGE_DELETION_REFUND] [Economic attack] The STORAGE_DELETION_REFUND flag at line 48 provides refunds for storage deletion. If the refund calculation has bugs and this flag is enabled, can attackers create and delete storage slots repeatedly to extract more refunds than they paid, minting unlimited APT tokens? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: AGGREGATOR_V2_DELAYED_FIELDS] [Parallel execution race] The AGGREGATOR_V2_DELAYED_FIELDS flag at line 56 enables parallel aggregator operations. If enabled without proper synchronization in the VM, can race conditions in parallel transaction execution cause double-spending or fund duplication? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: KEYLESS_ACCOUNTS] [Authentication bypass] The KEYLESS_ACCOUNTS flag at line 66 enables keyless authentication. If this flag is toggled mid-epoch, can accounts authenticated via keyless method suddenly lose access, or can unauthenticated transactions be accepted, breaking authentication guarantees? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: JWK_CONSENSUS] [Consensus manipulation] The JWK_CONSENSUS flag at line 70 controls JWK (JSON Web Key) consensus for keyless accounts. If this flag is disabled after keyless accounts are created, can those accounts become permanently inaccessible, or can forged JWKs be used to compromise keyless account security? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: OBJECT_CODE_DEPLOYMENT] [Code injection] The OBJECT_CODE_DEPLOYMENT flag at line 73 enables deploying code to objects. If enabled without proper access control checks in the framework, can attackers deploy malicious code to arbitrary objects, hijacking object behavior and stealing assets? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: ENABLE_RESOURCE_ACCESS_CONTROL] [Access control bypass] The ENABLE_RESOURCE_ACCESS_CONTROL flag at line 100 controls resource access restrictions. If this flag is disabled, can any account access resources they shouldn't (e.g., admin-only resources), breaking the security model of the Move language? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: TRANSACTION_SIMULATION_ENHANCEMENT] [Simulation divergence] The TRANSACTION_SIMULATION_ENHANCEMENT flag at line 104 improves transaction simulation. If this flag differs between simulation and execution environments, can attackers craft transactions that behave differently in simulation vs. real execution, bypassing transaction validation? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: ENABLE_LAZY_LOADING] [Resource exhaustion] The ENABLE_LAZY_LOADING flag at line 143 enables lazy module loading. If enabled, can attackers craft transactions that trigger excessive lazy loads, consuming validator memory and causing OOM crashes? (High)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: ENABLE_TRUSTED_CODE] [Optimization bypass] The ENABLE_TRUSTED_CODE flag at line 149 allows trusted code optimizations that skip runtime checks. If enabled for untrusted modules, can attackers exploit the lack of checks to bypass type safety, resource safety, or other security invariants? (Critical)",
  "[File: aptos-core/types/src/on_chain_config/aptos_features.rs] [FeatureFlag: SESSION_CONTINUATION] [Session state corruption] The SESSION_CONTINUATION flag at line 156 enables session continuation between prologue, transaction, and epilogue. If there are bugs in session state management and this flag is enabled, can attackers manipulate session state to bypass transaction validation or fee payment? (Critical)"
]