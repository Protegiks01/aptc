[
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Cross-Function: push_back() + item_mut()] [TOCTOU] If item_mut() is called for a round, then push_back() adds a new QueueItem covering that round, can the existing &mut QueueItem reference become invalid or point to wrong data? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Cross-Function: dequeue_ready_prefix() + set_secret_shared_key()] [Race Condition] Can set_secret_shared_key() be called concurrently with dequeue_ready_prefix() such that a secret is set after is_fully_secret_shared() check but before pop_first(), causing the item to be dequeued without the secret? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Cross-Function: item_mut() + dequeue_ready_prefix()] [Use-After-Free] If item_mut() returns a mutable reference, then dequeue_ready_prefix() removes that item, does Rust's borrow checker prevent use-after-free, or can this happen through unsafe code elsewhere? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Cross-Function: push_back() + dequeue_ready_prefix()] [Ordering Invariant] If blocks are pushed and dequeued rapidly, can the BTreeMap ordering guarantee that blocks are always dequeued in increasing round order, or can concurrent operations violate this? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Struct: QueueItem] [Invariant Violation] The invariant that offsets_by_round.len() equals ordered_blocks.len() is not explicitly enforced - can bugs cause these to desync, leading to offset() returning invalid indices? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Struct: QueueItem] [Invariant Violation] pending_secret_key_rounds should only contain rounds that exist in ordered_blocks - can this be violated, causing set_secret_shared_key() to panic or behave incorrectly? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Struct: QueueItem] [Invariant Violation] Does QueueItem guarantee that ordered_blocks are actually ordered by round, or can out-of-order blocks cause first_round() and offset() to return inconsistent results? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Struct: BlockQueue] [Invariant Violation] Should BlockQueue.queue keys (first rounds) be monotonically increasing? If not, can out-of-order insertion cause dequeue_ready_prefix() to process blocks incorrectly? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Struct: BlockQueue] [Invariant Violation] Can the queue contain overlapping QueueItems where a single round appears in multiple items, causing item_mut() to return the wrong item? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Protocol: Secret Sharing] [Threshold Attack] If secret shares are required from a threshold of validators, can Byzantine validators withhold their shares until they see others' shares, allowing them to bias randomness or predict outcomes? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Protocol: Secret Sharing] [Selective Disclosure] Can a malicious validator selectively call set_secret_shared_key() for some rounds but not others based on strategic advantage, manipulating which blocks get processed and which stall? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Protocol: Secret Sharing] [Replay Attack] Is there validation that SecretSharedKey values are fresh and not replayed from previous rounds? Can old secrets be resubmitted to cause randomness reuse or prediction? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Protocol: Secret Sharing] [Forgery Attack] Does set_secret_shared_key() validate that the provided SecretSharedKey is cryptographically valid and matches the expected commitment for that round, or can arbitrary keys be submitted? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Memory Safety: Arc Usage] OrderedBlocks contains Arc<PipelinedBlock> at line 80 - can reference count manipulation cause use-after-free if Arc is cloned/dropped improperly across thread boundaries? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Memory Safety: Mutex Poisoning] At line 72, pipeline_tx().lock() can poison the mutex if a panic occurs while holding the lock - can this permanently corrupt the QueueItem preventing future secret share updates? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Memory Safety: Send/Sync] Are QueueItem and BlockQueue properly Send/Sync? Can they be safely shared across threads, or can improper thread boundaries cause data races not caught by the borrow checker? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Memory Safety: Drop Order] When QueueItem is dropped, are share_requester_handles, ordered_blocks, and HashMaps dropped in the correct order to prevent double-free or use-after-free issues? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Integer Safety: Round Overflow] Round is defined as u64 - can rounds near u64::MAX cause overflow in comparison operations, BTreeMap ordering, or range queries at line 132? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Integer Safety: Offset Overflow] The offset usize at line 54 is converted from enumeration index - can extremely large ordered_blocks (>usize::MAX on 32-bit) cause overflow or panic? (Low)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Integer Safety: Collection Size] Can ordered_blocks or pending_secret_key_rounds grow unbounded causing usize to overflow when calling .len() or iterating? (Low)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Error Handling: Unwrap/Expect] Multiple expect() calls (lines 48, 57, 116) will panic on failure - are these conditions truly impossible, or can Byzantine inputs trigger them to crash validators? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Error Handling: Assert] The assert at line 108 panics on duplicate inserts - should this return Result<> instead to allow graceful handling, or is panic acceptable for consensus violations? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Error Handling: Silent Failures] At line 73, tx.send() can fail but the error is not checked - can this cause blocks to be dequeued without their secrets being delivered, breaking downstream processing? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Error Handling: Option Unwrapping] At lines 72-73, multiple Option::take() and as_mut() calls can return None - are all None cases handled correctly, or can Some->None transitions cause logic errors? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Consensus Safety: Block Reordering] If malicious validators send QueueItems with blocks in different orders, can inconsistent offsets_by_round mappings cause different validators to apply different secrets to different blocks? (Critical)"
]