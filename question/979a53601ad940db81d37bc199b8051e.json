[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_script()] [Script constant abuse] At lines 341-346, can attackers define script-level constants that shadow or conflict with module constants, causing value confusion? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_script()] [Parameter signature mismatch] At line 351, does parameters_sig_idx match the actual formals in script.main, or can mismatches bypass transaction argument validation? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_explicit_dependency_declarations()] [Dependency mutation] At line 509, does take_dependencies() safely handle concurrent access, or can race conditions cause dependencies to be lost or duplicated? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_explicit_dependency_declarations()] [Context pollution] At line 587, does restore_dependencies properly validate dependencies_acc before restoring, or can attackers inject malicious compiled modules? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_explicit_dependency_declarations()] [Module identity spoofing] At line 516, can attackers create ModuleDependency with module_ident that doesn't match the actual compiled module's identity, causing name resolution attacks? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_explicit_dependency_declarations()] [Struct dependency mismatch] At lines 524-534, can struct dependencies declare different abilities or type formals than the actual struct definition, bypassing ability checks? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_lvalues()] [LValue ordering] At line 1064, does reversing lvalues.into_iter() correctly match the order of values on stack, or can attackers exploit ordering to assign values to wrong variables? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_lvalues() Mutate case] [Reference type validation] At line 1071, does Mutate validate the expression produces a mutable reference, or can attackers write through immutable references? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_lvalues() Mutate case] [WriteRef type mismatch] Can the value being written and the reference type be incompatible, causing WriteRef to corrupt memory with wrong-typed value? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_lvalues() Pop case] [Stack accounting] At line 1077, does Pop correctly decrement stack depth, or can attackers use Pop to manipulate stack accounting without actually removing values? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_imports()] [Import alias collision] At line 603, can attackers create imports with alias names that collide with local definitions, causing name resolution to use wrong module? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_friends()] [Friend validation] At line 597, does declare_friend validate the friend module actually exists and is compatible, or can attackers declare friendships with non-existent modules? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_move_function_body()] [Empty function body] Does verification properly handle empty code vector, or can attackers compile functions with no blocks that bypass control flow validation? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_bytecode_function_body()] [Unreachable code] Does verification detect unreachable blocks that are never jumped to, or can attackers hide malicious bytecode in unreachable blocks that gets executed through VM bugs? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: label_verification_error()] [Error message injection] At lines 199-222, can attackers craft label names with special characters that inject malicious content into error messages, potentially exploiting log parsers? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_function()] [Native function validation] At line 302, does verification skip native function bodies entirely, allowing attackers to provide malicious FunctionBody::Native that doesn't match external implementation? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_script() materialize_pools] [Pool size limits] At line 365, does materialize_pools validate that signature/identifier/constant pools don't exceed table size limits, or can overflow cause index wraparound? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module() materialize_pools] [Handle deduplication] Do module_handles and struct_handles properly deduplicate entries, or can duplicate handles cause confusion in bytecode verification? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Version compatibility] At line 473, is VERSION_DEFAULT always compatible with all VM versions, or can attackers compile modules with future versions that break older VMs? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: function_signature()] [Return type mismatch] At line 714, can function signature return types differ from actual Return statements, causing type confusion at call sites? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: function_signature()] [Type parameter constraint bypass] At lines 720-724, can attackers declare type parameters with empty ability sets that bypass required constraints like Copy or Drop? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_types()] [Empty type vector] Does compile_types correctly handle empty tys vector, or can empty type lists cause issues in generic instantiation? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: abilities()] [Ability set overflow] At line 635, can attackers provide duplicate abilities in the BTreeSet that cause ability set calculation to overflow or wrap? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: record_src_loc local] [Source map pollution] At line 36, can attackers provide local variables with malicious names that corrupt source maps, potentially hiding exploit locations in stack traces? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: record_src_loc parameter] [Parameter mapping overflow] Can functions with more parameters than expected cause parameter mapping to overflow and corrupt source map data structures? (Low)"
]