[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [Unused set manipulation] The function removes from unused[*depth].modules without validation - can an attacker pre-populate the unused set with fake entries to cause remove() to fail silently? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [depth_opt mutation timing] Setting *depth_opt = None after marking as used - can this create a window where the alias is marked as used but not yet removed from unused tracking, allowing double-use bugs? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [ModuleIdent cloning] The function clones address and module name - can this cause expensive memory allocations to be exploited for compiler DoS attacks with deeply nested alias chains? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [sp! macro safety] The sp! macro usage at lines 169-175 involves unsafe location manipulation - can malformed location data cause memory corruption? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: member_alias_get()] [Tuple destructuring race] The function destructures (sp!(mem_mod_loc, mem_mod), sp!(_, mem_name)) - can concurrent mutations cause partial reads of the tuple, leading to mismatched module-member pairs? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: member_alias_get()] [Depth tracking inconsistency] Similar to module_alias_get(), accessing unused[*depth] - can validators with different unused vector sizes cause divergent alias resolution and state fork? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: member_alias_get()] [Location data loss] The function discards the original member name location (sp!(_, mem_name)) and replaces it with n.loc - can this allow attackers to bypass source-level access control checks that depend on accurate location tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: member_alias_get()] [Module location preservation] While member location is replaced, mem_mod_loc is preserved - can this asymmetry cause confusion in error reporting that masks security-critical compilation errors? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: member_alias_get()] [Unused tracking bypass] If depth_opt is Some but unused[*depth].members.remove(n) fails (name not found), the function still sets *depth_opt = None - can this cause aliases to be incorrectly marked as used? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Shadow depth manipulation] The function calculates next_depth from current_depth() which is based on unused.len() - can an attacker manipulate the unused vector to cause integer overflow in depth calculations? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Scope cloning cost] The function clones the entire AliasMap at line 204 - can an attacker craft deeply nested scopes to cause exponential memory consumption through recursive cloning? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Empty shadowing bypass] If shadowing.is_empty() returns true, the function returns early without creating a new scope - can this cause scope depth inconsistencies in nested blocks with empty import lists? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Module removal ordering] At line 216, modules.remove() is called before modules.add() - can concurrent access during this window cause the alias to be temporarily unavailable, leading to compilation errors? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Implicit alias tracking bug] The loop at lines 212-218 only adds non-implicit aliases to current_scope.modules - can an attacker exploit this by using only implicit aliases to create untracked scopes that evade memory limits? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [UniqueMap add unwrap] Both modules.add() and members.add() use unwrap() - if shadowing contains duplicate aliases, can this cause panics that crash the compiler? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Unused vector push] The unused.push() at line 228 happens after all mutations - can a crash between mutations and push cause the unused vector to become out-of-sync with actual aliases? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Member shadowing race] The loop at lines 219-227 processes members after modules - can this ordering be exploited to shadow module aliases with member aliases of the same name? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [Depth value integrity] The next_depth is stored in Option<ScopeDepth> - can depth values exceed usize::MAX in extremely deep recursion, causing wrap-around and incorrect shadowing? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_and_shadow_all()] [OldAliasMap construction] OldAliasMap(Some(self.clone())) at line 204 clones before mutations - can this cause the saved outer_scope to have a different unused.len() than expected during set_to_outer_scope()? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Empty type params bypass] The function checks tparams_iter.len() == 0 and returns early - can an attacker pass an iterator that reports len() == 0 but still yields elements, causing shadowing to be skipped? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [ExactSizeIterator trust] The function requires ExactSizeIterator - can an attacker provide a malicious iterator implementation that reports incorrect length, causing the early return check to be bypassed? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Type param name collision] The function only removes from members, not modules - can type parameter names collide with module aliases, causing confused name resolution during compilation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Empty AliasSet push] At line 246, an empty AliasSet is pushed to unused - can this cause set_to_outer_scope() to return an empty set even when type parameters shadowed actual aliases? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Member-only shadowing] Unlike add_and_shadow_all(), this only removes members - is this asymmetry intentional, or can module aliases with same names as type params cause undefined behavior? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: shadow_for_type_parameters()] [Iterator exhaustion] The function consumes tparams_iter - can double-iteration bugs in calling code cause type parameter names to be incompletely removed from members map? (Low)"
]