[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: FunctionBody_] [Native Function Abuse] Can the Native variant of FunctionBody_ be exploited to declare arbitrary native functions without proper validation, allowing attackers to link to unsafe native implementations that bypass Move's safety guarantees? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: AccessSpecifier_] [Read/Write Confusion] Can the AccessSpecifierKind (Reads/Writes/LegacyAcquires) be manipulated to claim read-only access while performing writes, bypassing access control checks in the Move Prover or runtime validators? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: AccessSpecifier_::negated] [Negation Logic Error] Can the negated boolean in AccessSpecifier_ be exploited with double negation or incorrect negation handling to invert access permissions, granting write access where only read should be allowed? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: AddressSpecifier_] [Address Filter Bypass] Can AddressSpecifier_ variants (Any, Empty, Literal, Name, Call) be manipulated to bypass address-based access restrictions, allowing universal access to resources that should be address-restricted? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: Constant] [Constant Evaluation Bypass] Can the Constant struct with signature Type and value Exp be exploited to define constants with expressions that aren't actually constant (e.g., containing function calls), causing non-deterministic constant evaluation across validators? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: Value_] [Integer Overflow in Constants] Can Value_ variants (U8, U16, U32, U64, U128, U256, I8-I256) be exploited with values at integer boundaries to cause overflow during constant folding or arithmetic operations in the compiler? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Value_::InferredNum] [Type Inference Confusion] Can InferredNum(U256) be exploited to create ambiguous constant types that could be interpreted as different integer types in different contexts, causing type confusion in arithmetic operations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Value_::InferredNegNum] Can InferredNegNum(I256) be used to create negative number constants that get incorrectly cast to unsigned types, causing integer underflow vulnerabilities in Move code? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Value_::Address] [Address Constant Confusion] Can Value_::Address(Address) constants with NamedUnassigned addresses be exploited where the address isn't resolved until later stages, causing different validators to resolve the address differently and breaking consensus? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Value_::Bytearray] [Bytearray Size Attack] Can Bytearray(Vec<u8>) constants be exploited with extremely large byte arrays that cause memory exhaustion during compilation or create oversized bytecode that exceeds transaction size limits? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Value_::Bool] [Boolean Constant Optimization] Can Bool(bool) constants be exploited in constant folding optimizations to eliminate security checks that should always run, allowing attackers to bypass validation logic? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: Exp_] [Expression Type Confusion] Can the 40+ Exp_ variants be exploited through type confusion where an expression is evaluated with the wrong type, causing runtime type errors or memory safety violations in the Move VM? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Move] [Move Semantics Violation] Can Move(Var) be exploited to move a value multiple times or move a borrowed reference, violating Move's ownership semantics and causing use-after-move bugs that corrupt memory? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Copy] [Copy Semantics Bypass] Can Copy(Var) be used to copy non-copyable resources (without Copy ability), bypassing the ability constraint system and duplicating unique resources like tokens or NFTs? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Call] [Function Call Hijacking] Can Call(ModuleAccess, CallKind, Option<Vec<Type>>, Spanned<Vec<Exp>>) be exploited through module access manipulation to redirect function calls to attacker-controlled functions with similar signatures? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Pack] [Struct Packing Exploit] Can Pack(ModuleAccess, Option<Vec<Type>>, Fields<Exp>) be exploited to pack struct fields in incorrect order or with wrong types, causing memory layout corruption when the struct is unpacked? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Vector] [Vector Size Attack] Can Vector(Loc, Option<Vec<Type>>, Spanned<Vec<Exp>>) be exploited with extremely large vectors that cause memory exhaustion or integer overflow in size calculations during vector operations? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::IfElse] [Branch Condition Bypass] Can IfElse(Box<Exp>, Box<Exp>, Box<Exp>) be exploited where the condition expression is optimized away incorrectly, causing the wrong branch to execute and bypassing security checks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Match] [Pattern Match Bypass] Can Match(Box<Exp>, Vec<Spanned<(LValueList, Option<Exp>, Exp)>>) be exploited through incomplete pattern coverage or pattern overlap, allowing control flow to fall through to unintended code paths? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::While] [Loop Invariant Violation] Can While(Option<Label>, Box<Exp>, Box<Exp>) loops with labeled breaks be exploited to violate loop invariants specified in spec blocks, causing post-condition violations that compromise Move Prover guarantees? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Loop] [Infinite Loop Gas Bypass] Can Loop(Option<Label>, Box<Exp>) be exploited with incorrect gas metering to create infinite loops that consume all gas without being detected, causing transaction processing DoS? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Lambda] [Closure Capture Exploit] Can Lambda(TypedLValueList, Box<Exp>, LambdaCaptureKind, Option<Box<Exp>>) be exploited to capture references with incorrect lifetimes or capture non-droppable values incorrectly, violating resource safety? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Quant] [Quantifier Logic Bypass] Can Quant(QuantKind, LValueWithRangeList, Vec<Vec<Exp>>, Option<Box<Exp>>, Box<Exp>) spec-only quantifiers be manipulated to always return true/false, bypassing Move Prover verification and allowing unverified code to deploy? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Assign] [Assignment Type Confusion] Can Assign(LValueList, Box<Exp>) be exploited to assign expressions of wrong types to lvalues due to type checking errors, causing memory corruption when the wrong-typed value is read? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::FieldMutate] [Field Mutation Exploit] Can FieldMutate(Box<ExpDotted>, Box<Exp>) be used to mutate fields of immutable structs or fields accessed through immutable references, violating Rust's borrow checker assumptions? (High)"
]