[
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Discrete log] Are all operations secure under the discrete logarithm assumption, or could weak exponents or points enable discrete log attacks? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Pairing-based attacks] Are the pairing operations secure against known attacks (MOV, Frey-Rück), or could pairing weakness compromise DKG? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Small subgroup] Do all curve operations check for small-subgroup attacks, or could points in small subgroups break DKG security? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Twist attacks] Is the G2 twist properly secured against twist attacks, or could invalid curve points break pairing verification? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Hash function security] Is SHA3-512 the appropriate hash function for hash_to_scalar(), or would a different hash (SHAKE, Blake3) provide better security? (Low)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Field arithmetic] Are all scalar field operations constant-time to prevent timing attacks, or could variable-time operations leak DKG secrets? (Medium)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Crypto] [Reduction correctness] Does random_scalar_from_uniform_bytes() correctly reduce 512-bit hashes to field elements without bias or wraparound? (High)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Edge case] [Maximum array size] What is the maximum supported size for bases/scalars arrays in multi_exp, and could exceeding this cause integer overflow or memory exhaustion? (Medium)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Edge case] [Concurrent modification] If base/scalar arrays are modified concurrently during multi_exp computation, could this cause data races and incorrect results? (High)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Edge case] [NaN/Inf handling] How does the implementation handle special floating-point values if they somehow enter the computation pipeline? (Low)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Edge case] [Overflow in iteration] Can iterating over extremely large arrays cause index overflow in 32-bit architectures? (Low)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Error handling] [Panic vs Result] Should functions return Result<> for error handling instead of panic!, allowing graceful degradation during DKG failures? (Medium)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Error handling] [Error recovery] If a function panics, can the DKG protocol recover, or does this cause permanent validator failure requiring restart? (High)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Error handling] [Silent failures] Are there any code paths that could silently fail without panicking or returning errors, causing incorrect DKG results? (High)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Rust] [Unsafe code] Are there any unsafe blocks in the underlying blstrs library that could cause undefined behavior with malicious inputs? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Rust] [Lifetime bugs] Could lifetime issues in iterator handling cause use-after-free or dangling references during DKG computation? (Critical)",
  "[File: aptos-core/crates/aptos-dkg/src/utils/mod.rs] [Rust] [B\n\n### Citations\n\n**File:** crates/aptos-dkg/src/utils/mod.rs (L1-182)\n```rust\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::utils::{\n    parallel_multi_pairing::parallel_multi_pairing_slice, random::random_scalar_from_uniform_bytes,\n};\nuse ark_ec::{pairing::Pairing, AffineRepr};\nuse ark_ff::PrimeField;\nuse blstrs::{pairing, G1Affine, G1Projective, G2Affine, G2Projective, Gt};\nuse group::{Curve, Group};\nuse num_traits::Zero;\nuse rayon::ThreadPool;\nuse sha3::Digest;\nuse std::ops::Mul;\n\npub mod parallel_multi_pairing;\npub mod random;\npub mod test_utils;\n\n#[inline]\npub fn is_power_of_two(n: usize) -> bool {\n    n != 0 && (n & (n - 1) == 0)\n}\n\npub(crate) fn scalar_to_bits_le<E: Pairing>(x: &E::ScalarField) -> Vec<bool> {\n    let bigint: <E::ScalarField as ark_ff::PrimeField>::BigInt = x.into_bigint();\n    ark_ff::BitIteratorLE::new(&bigint).collect()\n}\n\n/// Hashes the specified `msg` and domain separation tag `dst` into a `Scalar` by computing a 512-bit\n/// number as SHA3-512(SHA3-512(dst) || msg) and reducing it modulo the order of the field.\n/// (Same design as in `curve25519-dalek` explained here <https://crypto.stackexchange.com/questions/88002/how-to-map-output-of-hash-algorithm-to-a-finite-field>)\n///\n/// NOTE: Domain separation from other SHA3-512 calls in our system is left up to the caller.\npub fn hash_to_scalar(msg: &[u8], dst: &[u8]) -> blstrs::Scalar {\n    // First, hash the DST as `dst_hash = H(dst)`\n    let mut hasher = sha3::Sha3_512::new();\n    hasher.update(dst);\n    let binding = hasher.finalize();\n    let dst_hash = binding.as_slice();\n\n    // Second, hash the msg as `H(dst_hash, msg)`\n    let mut hasher = sha3::Sha3_512::new();\n    hasher.update(dst_hash);\n    hasher.update(msg);\n    let binding = hasher.finalize();\n    let bytes = binding.as_slice();\n\n    assert_eq!(bytes.len(), 64);\n\n    match bytes.try_into() {\n        Ok(chunk) => random_scalar_from_uniform_bytes(chunk),\n        Err(_) => panic!("
]