[
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Infinite recursion] In the visiting stack at lines 127-132, can an attacker craft mutually recursive Move functions (A calls B, B calls A) that create an infinite loop in the DFS traversal, causing stack overflow and crashing the validator node during contract deployment or verification? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Cycle detection bypass] At line 163, the checker inserts 'true' into the pureness map before checking the function body - can an attacker exploit this optimistic assumption by creating a function that recursively calls itself and gets incorrectly marked as pure, bypassing verification and allowing impure operations in supposedly pure contexts? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Stack manipulation] The visiting stack push/pop operations at lines 127 and 131 - can race conditions or panic during traversal leave the stack in an inconsistent state, causing subsequent checks to use wrong call chains and report false positives/negatives for function pureness? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Depth limit bypass] The DFS traversal at lines 82-147 has no explicit recursion depth limit - can an attacker create a deeply nested call chain (1000+ levels) that exhausts stack space before the checker detects impurity, causing denial of service during contract verification? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Cycle breaking logic] At lines 126-133, the checker uses contains_key to break cycles - can an attacker exploit the timing between the check and insertion to cause the same function to be analyzed multiple times concurrently, leading to inconsistent pureness results in the cache? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Visiting stack overflow] The visiting Vec at line 50 has unbounded growth during recursive calls - can an attacker craft a contract with extremely long call chains that fills available memory with visiting stack entries, causing OOM crashes during pureness analysis? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Premature cache insertion] Line 163 inserts pureness=true before actual checking - if check_exp panics or the function has no definition, can this leave incorrect 'pure' entries in the cache that persist and affect subsequent checks, allowing impure functions to pass verification? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Recursive call race] At lines 127-132, if multiple threads check the same function simultaneously (before contains_key protection), can they both enter the recursive check, causing duplicate stack entries and incorrect is_impure flag restoration? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [State restoration bug] The mem::take and restoration pattern at lines 128-132 - if a panic occurs between taking old_impure and restoring it, can the is_impure flag become permanently corrupted, causing all subsequent function checks to produce incorrect results? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Flag logic error] Line 132 uses '|=' to combine is_impure with old_impure - can this logic fail to properly propagate impurity in nested call chains, allowing a deeply impure function to be marked as pure if an outer function resets the flag? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Initialization bug] Line 81 resets is_impure to false before traversal - if check_exp is called recursively without going through this reset, can stale impurity state from previous checks leak into new checks, causing false positives? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Early termination issue] Line 146 returns !self.is_impure to stop traversal early - can this cause the checker to miss impure operations deeper in the expression tree if an earlier check incorrectly set is_impure=false? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Multiple return paths] The function returns !self.is_impure at line 148 - are there code paths where is_impure could be left in an inconsistent state between line 81's reset and the final return, causing wrong results? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: new()] [Initial state] Lines 62-70 initialize is_impure to false - if the checker instance is reused across multiple check operations without proper reset, can impurity state leak between unrelated checks? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Native function state] Lines 168-177 set is_impure based on native function parameters - does this properly interact with the state restoration at line 132, or can native function impurity get lost when returning from recursive calls? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Callback side effects] Lines 87, 91, 95, 104, 111, 116, 135 invoke impure_action callback - if this callback modifies checker state or throws exceptions, can it corrupt is_impure flag or leave visiting stack in inconsistent state? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Cache poisoning] At line 130, pureness.insert is called with !is_impure after checking - if an attacker can trigger a panic or early return before this insertion, can they leave the cache empty while visiting stack still contains the function, causing infinite loops on retry? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Optimistic caching] Line 163 inserts 'true' optimistically - if the actual check at line 165 determines the function is impure but the insertion at line 130 fails to execute (panic/early return), can this leave a 'pure' entry for an impure function? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Cache inconsistency] Lines 126-134 check and insert into pureness map - in a concurrent context, can two threads racing to check the same function create inconsistent cache entries where one sees 'pure' and another sees 'impure'? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: into_map()] [Cache extraction] Line 75 consumes the checker and returns the pureness map - if this map contains incorrect entries from failed checks, can downstream code rely on these false results to make wrong security decisions about function pureness? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Missing invalidation] The pureness BTreeMap at line 48 is never cleared or invalidated - if GlobalEnv changes or functions are redefined, can stale cache entries cause the checker to use outdated pureness information? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Lookup timing] Line 134 uses unwrap() on pureness.get() - can this panic if the entry was removed between lines 130 and 134 (concurrent modification), causing crashes during verification? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_function()] [Dual insertion] Both lines 130 and 163 insert into pureness map - can race conditions cause these insertions to happen in wrong order, overwriting a correct 'impure' determination with the optimistic 'true' value? (High)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [BTreeMap ordering] The pureness map uses BTreeMap at line 48 - can an attacker exploit the ordering behavior to cause different validation results depending on the order in which functions are checked? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/pureness_checker.rs] [Function: check_exp()] [Missing patterns] The match expression at lines 85-144 handles specific ExpData variants - are there other expression types (Load, Temporary, Lambda, etc.) that could contain impure operations but are not checked in the default case at line 143? (High)"
]