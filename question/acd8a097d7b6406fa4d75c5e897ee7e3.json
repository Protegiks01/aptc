[
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Reference manipulation] Does inner.metadata.get_reference_address() at line 383 properly validate the returned address is a valid fungible asset metadata object, or can malicious references point to arbitrary objects causing type confusion? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Storage ID collision] When using token_data_id.clone() as storage_id at line 384, can multiple FungibleAssetStore resources for the same metadata create storage_id collisions in the database primary key, causing INSERT failures and dropped ownership records? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Pattern matching exhaustion] Does the pattern match at line 374-379 handle all V2FungibleAssetResource variants, or can unhandled variants like FungibleAssetMetadata bypass validation and create corrupted ownership records? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Amount precision loss] When cloning inner.balance at line 397 and 411, can BigDecimal precision loss during clone operations cause cumulative rounding errors that enable attackers to create or destroy fractional token amounts? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_ft_v2_from_write_resource()] [Owner extraction race] Can concurrent modifications to object_core between get_owner_address() call at line 387 and actual database insertion cause ownership records to attribute fungible assets to the wrong addresses? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Table type bypass] When checking tm.table_type != '0x3::token::TokenStore' at line 456, can an attacker create custom table types that mimic TokenStore structure but bypass this check, allowing unauthorized token tracking in wrong table contexts? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Amount validation bypass] Does ensure_not_negative() at line 448 properly handle BigDecimal::MIN or negative values that wrap around, allowing attackers to create tokens with invalid negative amounts that appear as massive positive balances? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Metadata injection] When table_handle_to_owner.get() returns None at line 481-488, can this warning be triggered intentionally to DoS the logger while still processing the token ownership, hiding malicious activity in log noise? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Property mutation] Are token.token_properties at line 468 and 501 validated for size and structure, or can attackers inject arbitrarily large JSON payloads causing database storage exhaustion and indexer crashes? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Owner spoofing] When standardize_address() is applied to tm.owner_address at line 459, can address normalization be exploited to make different addresses appear identical, allowing attackers to steal ownership tracking by address collision? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Table handle collision] Is table_handle standardization at line 447 collision-resistant, or can attackers craft handles that normalize to the same value as legitimate TokenStores, mixing unrelated token ownerships? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Type parsing exploit] Can TokenWriteSet::from_table_item_type() at line 437-444 be exploited with malformed value_type strings causing panic or undefined behavior in pattern matching? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Primary key conflict] When creating TokenOwnershipV2 with storage_id as table_handle at line 498, can multiple tokens in the same table create primary key violations if transaction_version and write_set_change_index are identical? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Return value confusion] When returning Ok(Some((ownership, None))) at line 491-509, does the None value for CurrentTokenOwnershipV2 get properly handled by callers, or can this cause null pointer exceptions in database insertion logic? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_write_table_item()] [Property version validation] Is token_id_struct.property_version validated for reasonable bounds at line 463 and 496, or can extremely large property versions cause BigDecimal overflow or database index exhaustion? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Soft delete bypass] When setting amount to BigDecimal::zero() at line 552 for deleted tokens, is there validation that a corresponding non-zero ownership record exists, or can attackers create fake delete records that corrupt supply tracking? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Key type confusion] Does TokenWriteSet::from_table_item_type() at line 525-532 properly validate that key_type matches expected TokenId structure, or can type mismatches cause incorrect token_data_id extraction? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Table metadata bypass] When tm.table_type check fails at line 542, returning Ok(None), can attackers delete tokens from non-TokenStore tables without triggering ownership updates, creating token accounting discrepancies? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Missing property validation] When setting token_properties_mutated_v1 to None at line 554, does this properly represent that properties are unknown for deletes, or can downstream code incorrectly interpret None as 'no properties' causing metadata loss? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Delete ordering] Can race conditions between concurrent delete_table_item operations cause out-of-order processing where a later delete is recorded before an earlier write, making tokens appear to exist after deletion? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Duplicate deletes] Is there protection against processing the same delete_table_item multiple times with different write_set_change_index values, potentially creating multiple zero-amount records that confuse balance calculations? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Owner verification] When extracting owner_address at line 545 from table metadata, is there validation that this owner actually owns the token being deleted, or can cross-owner deletes be recorded incorrectly? (High)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Token standard consistency] When setting token_standard to V1 at line 556, is there validation that the token was never previously recorded as V2, preventing standard migration exploits? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [NULL field handling] Are all Optional fields (is_soulbound_v2, is_fungible_v2, non_transferrable_by_owner) at lines 555-560 consistently None for V1 tokens, or can mixed Some/None values cause query inconsistencies? (Low)",
  "[File: aptos-core/crates/indexer/src/models/token_models/v2_token_ownerships.rs] [Function: get_v1_from_delete_table_item()] [Storage ID reuse] Can storage_id values from deleted tokens be reused for new tokens, causing primary key conflicts in current_token_ownerships_v2 table when attempting INSERT OR REPLACE operations? (High)"
]