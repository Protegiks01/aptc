[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Conjunction of exclusions] AccessSpecifier::Constraint uses AND semantics for exclusions (all exclusions must not match). Does check_access() correctly enforce that access must not be excluded by ANY specifier on the stack? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Precedence of inclusion vs exclusion] If a specifier has both inclusions and exclusions, the exclusions take precedence (access must not be excluded even if included). Does the enables() implementation at runtime_access_specifier.rs line 148-151 correctly implement this, and does check_access() rely on it? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function()] [Address evaluation order] When specialize() is called at line 45, it evaluates AddressSpecifier::Eval terms using function parameters. Can an attacker exploit evaluation order by providing parameters that cause different addresses to be computed depending on when they're evaluated? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function()] [SignerAddress extraction] If an AddressSpecifier uses AddressSpecifierFunction::SignerAddress, it extracts the address from a signer parameter. Can an attacker provide a maliciously crafted signer that causes incorrect address extraction, bypassing access controls? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function()] [ObjectAddress unimplemented] According to runtime_access_specifier.rs line 262-268, AddressSpecifierFunction::ObjectAddress is unimplemented and returns an error. Can an attacker create functions that use object::owner() in access specifiers to cause transaction failures and DoS? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function()] [Eval non-specialization] If specialize() fails to convert all AddressSpecifier::Eval variants to Literal, the specifier remains with Eval. According to runtime_access_specifier.rs line 227, Eval never matches any address. Can this cause legitimate accesses to be denied? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Address zero bypass] If an attacker creates an AccessInstance with address 0x0, and some AddressSpecifier::Literal also contains 0x0, can this be exploited to gain unauthorized access to system resources? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Resource wildcards] If a specifier uses ResourceSpecifier::Any, it matches all resources. Can an attacker exploit functions with Any resource specifiers to access restricted resources that should be protected by more specific specifiers? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Module vs Address specifiers] ResourceSpecifier has both DeclaredAtAddress and DeclaredInModule variants. If a resource is declared in module A at address X, and a specifier allows DeclaredAtAddress(X), does this grant access to resources in all modules at that address? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Type instantiation matching] ResourceSpecifier::ResourceInstantiation matches both the struct and type arguments. Can an attacker exploit generic types by using different type arguments to access the same underlying resource with different permissions? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [StructIdentifier spoofing] If an attacker can craft a malicious StructIdentifier that appears to match a legitimate resource but actually references a different resource, can this bypass access controls? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Type parameter overflow] If AccessInstance.instance contains an extremely large number of type arguments, can this cause performance issues during matching or overflow errors in the enables() check? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Call sites] According to grep results, check_access() is called from 6 locations in interpreter.rs. If any call site forgets to check the return value or ignores errors, can unauthorized resource access occur? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function(), exit_function()] [Interpreter state coupling] If the interpreter maintains its own call stack separate from the access control stack, can inconsistencies between these stacks cause access control bypasses when they desynchronize? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: check_access()] [Resource operation timing] Does the interpreter call check_access() before or after actually accessing the resource? If called after, can TOCTOU races allow unauthorized access even if the check subsequently fails? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/access_control.rs] [Function: enter_function()] [Interpreter initialization] When the interpreter starts executing a transaction, does it properly initialize a fresh AccessControlState, or can state\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/access_control.rs (L1-78)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n//! Represents the state machine managing resource access control in VM execution.\n\nuse crate::{interpreter::ACCESS_STACK_SIZE_LIMIT, LoadedFunction};\nuse move_binary_format::errors::{PartialVMError, PartialVMResult};\nuse move_core_types::vm_status::StatusCode;\nuse move_vm_types::loaded_data::runtime_access_specifier::{\n    AccessInstance, AccessSpecifier, AccessSpecifierEnv,\n};\n\n/// The state of access control. Maintains a stack of active access specifiers.\n///\n/// Every access to a resource must satisfy every specifier on the stack.\n#[derive(Clone, Debug, Default)]\npub struct AccessControlState {\n    specifier_stack: Vec<AccessSpecifier>,\n}\n\nimpl AccessControlState {\n    /// Enters a function, applying its access specifier to the state.\n    // note(inline): do not inline, they are called once per function, and increase `execute_main`\n    // quite a bit, we want to avoid those compile times\n    #[cfg_attr(feature ="
]