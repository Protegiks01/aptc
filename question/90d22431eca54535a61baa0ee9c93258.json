[
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [MutBorrowGlobal double borrow] Can an attacker craft multiple MutBorrowGlobal instructions to the same global resource within a transaction, violating Move's resource uniqueness guarantees? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [ImmBorrowGlobal concurrent access] For ImmBorrowGlobal, can concurrent transactions borrow the same global resource while one is being modified, causing read-write races? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Exists check race condition] Can an attacker sequence Exists checks followed by MoveFrom/MoveTo to exploit time-of-check-time-of-use races, moving non-existent resources or duplicating resources? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [MoveFrom resource leak] Can MoveFrom instructions be crafted to extract resources without proper cleanup, causing resource leaks that accumulate across transactions? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [MoveTo duplicate resource] Can MoveTo instructions bypass uniqueness checks to move the same resource to multiple addresses, violating Move's linear type system? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [ExistsGeneric/MoveFromGeneric type confusion] Can generic variants of global resource operations be exploited to access resources with incorrect type parameters, causing memory corruption? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [VecPack zero size] What happens if VecPack is called with num=0? Can this cause uninitialized memory or null pointer dereferences in vector operations? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [VecUnpack underflow] Can VecUnpack with num larger than actual vector size cause buffer underflow when popping elements during execution? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Bytecode sequence exploitation] Can an attacker craft sequences of validated instructions that individually pass checks but together violate invariants (e.g., borrow after move)? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_instructions()] [Unvalidated bytecode pass-through] The wildcard match arm for many bytecodes (LdU8, Add, Sub, etc.) performs no validation - can an attacker exploit this to pass malicious immediate values or indices? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Field handle resolution failure] Can resolver.field_handle_at() fail silently with invalid indices, causing check_struct_op() to operate on uninitialized or incorrect data? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Field owner mismatch] Can field_handle.owner point to a different struct than expected, allowing cross-struct field access that violates type safety? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Generic flag manipulation] Can the generic boolean parameter be inverted through bit manipulation or race conditions, causing incorrect validation logic? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_field_op()] [Offset overflow in error reporting] When check_struct_op() returns an error, can the offset parameter overflow during casting, causing error messages to point to wrong code locations and confusing auditors? (Low)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [Variant field handle resolution] Can resolver.variant_field_handle_at() return fields from incorrect variants, allowing access to uninitialized variant data? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [struct_index validation] Does field_handle.struct_index properly validate that the variant belongs to the expected struct, or can cross-struct variant access occur? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_variant_field_op()] [Variant discriminant bypass] Can an attacker access variant fields without checking the discriminant, reading data from inactive variants and causing undefined behavior? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: current_function()] [Default index abuse] When current_function is None (scripts), unwrap_or returns FunctionDefinitionIndex(0) - can this cause errors to be incorrectly attributed to function 0 instead of the script? (Low)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: current_function()] [Index 0 collision] If a module has FunctionDefinitionIndex(0), can errors from scripts collide with errors from that function, causing confusion in error reporting? (Low)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Struct def resolution failure] Can resolver.struct_def_at() return incorrect struct definitions when struct_def_index is manipulated, causing validation on wrong types? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Struct handle mismatch] Can struct_def.struct_handle point to a different struct handle than expected, allowing type confusion between different struct types? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Type parameter empty check inversion] The condition 'type_parameters.is_empty() == generic' returns error when violated - can boolean logic errors cause this to accept invalid generic/non-generic combinations? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [GENERIC_MEMBER_OPCODE_MISMATCH bypass] Can an attacker craft structs where type_parameters.is_empty() returns unexpected values (e.g., through iterator corruption), bypassing the mismatch check? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Race condition in resolver access] If BinaryIndexedView is shared across threads, can concurrent struct_def_at() and struct_handle_at() calls return inconsistent data? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/instruction_consistency.rs] [Function: check_struct_op()] [Error location precision] When returning PartialVMError with at_code_offset(), can offset as CodeOffset overflow for large functions, causing loss of error location precision? (Low)"
]