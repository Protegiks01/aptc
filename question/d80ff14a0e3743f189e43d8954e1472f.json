[
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Query injection] If the standardized address output is used in database queries without proper escaping, can malformed addresses containing SQL injection payloads (if stored before validation) compromise the indexer database? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Race condition] If multiple indexer threads call standardize_address() concurrently on the same address with different formats, can race conditions in database updates cause non-deterministic transaction indexing where some transactions are lost or duplicated? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [State inconsistency] If the indexer crashes or restarts mid-processing, can partially standardized addresses be persisted to the database, leaving the indexer in an inconsistent state where some addresses are standardized and others aren't? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Saturating subtraction] At line 16, saturating_sub(1) is used but what if trimmed.len() is 0? This returns 0, causing trimmed[..0] which is valid but empty. However, if the intent was to check all-but-last character for zeros, this logic fails for single-character addresses. Can this misclassify '0xa' as special when it should validate preceding zeros? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Unchecked subtraction] At line 33, the expression 64 - trimmed.len() assumes trimmed.len() <= 64, but there's no explicit check. If validation is missing upstream and trimmed.len() is 65, this causes integer underflow on some platforms, potentially panicking the indexer process? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Length calculation] If trimmed contains non-ASCII characters, does chars().count() differ from len() in bytes? Could this cause the ZEROS padding calculation to be incorrect, producing addresses that are too short or too long? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Capacity overflow] At line 31, String::with_capacity(66) allocates for '0x' + 64 chars. If due to a bug, more than 66 characters are pushed (e.g., if trimmed.len() calculation is wrong), can this cause hidden reallocation or memory corruption? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Constant: ZEROS] [Hardcoded constant] The ZEROS constant at line 5 is hardcoded to 64 '0' characters. If Aptos address length changes in a protocol upgrade (e.g., to 128 bits), will this constant cause incorrect padding, breaking all indexed addresses post-upgrade? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Constant: ZEROS] [Magic number] The magic number 64 is used at line 33 without a named constant. If this needs to change, will developers update all occurrences consistently, or could partial updates cause address length mismatches across the indexer? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Constant: ZEROS] [Memory efficiency] The ZEROS constant is a &str slice compiled into the binary. For high-throughput indexers processing millions of addresses, are repeated slice operations on this constant optimized by the compiler, or could it cause cache misses affecting performance? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Prefix stripping] At line 12, strip_prefix('0x') uses unwrap_or(address) if prefix not found. Can an attacker provide 'x123abc' (missing '0') that gets processed as-is, potentially creating a 'xx123abc' address after adding '0x' prefix, corrupting indexer data? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Multiple prefixes] What if an attacker provides '0x0x1234'? After strip_prefix, trimmed becomes '0x1234'. Is this then treated as a valid address and padded incorrectly, or could the nested prefix cause validation confusion in downstream systems? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Case-sensitive prefix] The strip_prefix checks for lowercase '0x'. Can an attacker provide '0X1234' (uppercase X) that bypasses prefix stripping, resulting in standardized address '0x0X1234' with double prefix corrupting indexer lookups? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Whitespace handling] Does the function trim whitespace? Can addresses like ' 0x1 ' or '0x1\\n' cause whitespace to be included in the standardized output '0x 0x1 ', breaking address matching in transaction filters? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Null terminator] If an address string contains null bytes (e.g., '0x1\\0evil'), does Rust's string handling include the null byte and everything after it in the standardized output, potentially causing buffer overreads in C-interop code? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Filter evasion] If transaction filters are configured to block specific addresses, can an attacker submit transactions with addresses in various formats (short vs long, uppercase vs lowercase) that bypass filters because standardization happens after filtering logic? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Performance bottleneck] Is standardize_address() called for every address in every transaction during indexing? For high-throughput blocks with thousands of transactions, can the string manipulation overhead cause indexer lag, resulting in delayed transaction filtering and missed fraud detection? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Error handling] The function returns String with no error indication. If standardization fails or produces invalid output, how does the indexer detect this? Can silently invalid addresses corrupt the indexed data without triggering alerts? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Caching] Does the indexer cache standardized addresses to avoid recomputation? If not, can an attacker deliberately use high-frequency addresses in various formats to force repeated standardization, causing CPU exhaustion DoS? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Concurrent access] If the transaction filter uses this function in a multi-threaded context without proper synchronization, can concurrent calls with the same address cause data races or memory corruption in the returned String objects? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Range boundary] The comment at line 14 says 'last byte is smaller than 0b10000' (16 decimal, 0x10 hex), but line 20 checks last_char <= 'f' (which is 15 decimal, 0x0f hex). Is there an off-by-one error where '0x10' should be special but isn't, or vice versa, causing address classification inconsistencies? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Hex digit interpretation] For last_char check at line 20, does 'f' correctly represent 0x0f? Should it check against '10' (two characters) for value 0x10? Can this ambiguity cause addresses in range 0x10-0x1f to be incorrectly classified as special? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Leading zeros validation] The check at line 17 validates all characters except last are '0', but what if trimmed is '000000...000g' (63 zeros + 'g')? The last_char is 'g' which is > 'f', so it's non-special. But should addresses with non-hex last character be rejected instead of standardized? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Negative numbers] Hexadecimal can represent negative numbers with sign. If an attacker provides '-0x1', does strip_prefix fail leaving '-0x1', which then gets padded to '0x00...-0x1', creating malformed addresses in the indexer? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/utils.rs] [Function: standardize_address()] [Octal/binary prefix] What if an attacker provides '0o777' (octal) or '0b1111' (binary)? These don't have '0x' prefix, so they pass through. Do they get zero-padded as-is, creating invalid address formats that break indexer queries? (Medium)"
]