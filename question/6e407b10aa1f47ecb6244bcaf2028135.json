[
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Stack overflow / DoS] Can an attacker craft a deeply nested BooleanTransactionFilter with thousands of recursive LogicalNot operations to cause stack overflow during deserialization, leading to indexer service crash and loss of availability? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Resource exhaustion] Does the max_filter_size check at line 99-106 properly account for recursive nesting depth, or can an attacker bypass it by creating filters with deeply nested And/Or/Not structures that consume excessive stack space despite passing size validation? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: matches()] [Stack overflow] In the Filterable implementation for BooleanTransactionFilter (line 250-257), can recursive calls to matches() through deeply nested LogicalNot filters cause stack overflow during transaction matching, crashing the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: validate_state()] [Stack overflow] Can deeply nested filter structures cause stack overflow during recursive validate_state() calls at line 241-247, bypassing filter validation and allowing malicious filters through? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom for LogicalNot] [Unbounded recursion] At line 352-354, the conversion from proto to LogicalNot recursively calls new_from_proto() with None for max_filter_size - can this be exploited to bypass size limits in nested filters? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom for LogicalAnd] [Unbounded recursion] At line 273, the conversion passes None for max_filter_size in recursive calls - does this allow attackers to create arbitrarily large nested filters that bypass the top-level size check? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom for LogicalOr] [Unbounded recursion] At line 313, similar to LogicalAnd, does passing None for max_filter_size in nested conversions create a vulnerability for size limit bypass? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: into_proto()] [Stack overflow] When converting nested filters to proto at line 49-90, can deeply nested structures cause stack overflow during the recursive Into::into() calls? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Size validation bypass] At line 100, the encoded_len() check only applies to the top-level proto_filter - can an attacker craft a filter where nested LogicalAnd/Or contain massive sub-filters that individually bypass the size check? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Integer overflow] Can proto_filter.encoded_len() at line 100 overflow when calculating the size of extremely large nested structures, causing the size check to pass incorrectly? (Critical)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Memory exhaustion] If max_filter_size is set to a very large value (e.g., usize::MAX), can an attacker create a filter that passes validation but consumes all available memory during deserialization? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [TOCTOU race] Between the size check at line 100 and actual deserialization at line 108-126, could there be a time-of-check-to-time-of-use issue where the filter size changes due to concurrent modification? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalAnd::matches()] [Logic error] At line 296, if the 'and' vector is empty, iter().all() returns true - does this allow attackers to create filters that match all transactions, bypassing intended filtering logic and causing unintended data exposure? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalOr::matches()] [Logic error] At line 336, if the 'or' vector is empty, iter().any() returns false - is this the intended behavior, or should empty OR filters match all transactions creating a logic inconsistency? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalAnd::validate_state()] [Empty filter validation] At line 289-292, validation passes for empty 'and' vectors - should empty LogicalAnd filters be rejected as invalid configuration? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: LogicalOr::validate_state()] [Empty filter validation] At line 329-332, validation passes for empty 'or' vectors - does this create exploitable inconsistent behavior? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_and()] [No validation] At line 220-222, new_and() accepts any Vec<BooleanTransactionFilter> without validation - can attackers create invalid filters that bypass validate_state() checks? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_or()] [No validation] At line 224-226, similar to new_and(), does accepting unvalidated vectors create security issues? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Struct: BooleanTransactionFilter] [Deserialization attack] At line 17, the #[serde(untagged)] attribute can cause ambiguous deserialization - can attackers craft JSON that deserializes to unexpected filter types, bypassing validation or causing panics? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Struct: APIFilter] [Deserialization attack] At line 372, #[serde(deny_unknown_fields)] and #[serde(tag = \\",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: new_from_proto()] [Type confusion] At line 111, ok_or() converts None to an error, but can malicious proto messages with invalid oneof variants bypass this check through proto manipulation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom<ApiFilter>] [Type confusion] At line 387, similar ok_or() pattern - can proto messages with unset oneofs cause unexpected behavior or bypass validation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom for LogicalAnd] [Memory exhaustion] At line 270-275, converting a proto LogicalAndFilters with millions of nested filters can allocate excessive memory - is there a limit on vector size to prevent memory exhaustion? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: TryFrom for LogicalOr] [Memory exhaustion] At line 310-315, similar to LogicalAnd, can massive OR filter vectors cause out-of-memory conditions crashing the indexer? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs] [Function: and()] [Memory leak] At line 157-160, repeatedly calling and() creates nested BooleanTransactionFilter structures - can this lead to unbounded memory growth if filters are continuously combined? (Medium)"
]