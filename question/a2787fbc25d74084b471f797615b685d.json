[
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Struct: IntrinsicDecl] [Type Confusion] Can an attacker manipulate the bidirectional mappings between intrinsic_to_move_fun and move_fun_to_intrinsic to become desynchronized, causing type confusion where a Move function is called when a different intrinsic implementation was expected, potentially bypassing security checks in Move bytecode execution? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Struct: IntrinsicDecl] [Type Safety Violation] Can the move_type QualifiedId<StructId> be set to point to a different struct than intended, causing intrinsic operations to be performed on incompatible types and violating Move's type safety guarantees during formal verification? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Struct: IntrinsicDecl] [Mapping Integrity] If intrinsic_to_spec_fun and spec_fun_to_intrinsic become inconsistent (one mapping exists but reverse doesn't), can this cause undefined behavior during specification verification, potentially allowing unsafe code to pass formal verification? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Struct: IntrinsicDecl] [Memory Corruption] Can concurrent modifications to the BTreeMap fields during parallel compilation cause data races leading to corrupted intrinsic mappings that result in wrong function calls at runtime? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: get_fun_triple()] [Symbol Injection] Can an attacker craft a malicious 'name' parameter with special characters or control sequences that bypass symbol pool validation, causing symbol_pool.make() to return an unexpected symbol that maps to a privileged function instead of the intended one? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: get_fun_triple()] [Information Leakage] Does the function leak sensitive information about internal module structure through the returned Address, module name, and function name triple that could be used to map the attack surface of the Move runtime? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: get_fun_triple()] [Lookup Order Attack] Can the or_else() fallback logic between move functions and spec functions be exploited by registering a malicious spec function with the same name to shadow a legitimate move function, causing wrong function resolution? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: get_fun_triple()] [Null/Empty Handling] What happens if symbol_pool.string() returns an empty string or contains null bytes - can this cause issues in downstream code that uses the returned triple for function dispatch? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: get_fun_triple()] [Module Name Spoofing] Can the module name extraction via fun_env.module_env.get_name() be manipulated if the ModuleEnv is corrupted, potentially returning a wrong module name that causes cross-module security boundary violations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: lookup_spec_fun()] [Symbol Collision] Can two different intrinsic names hash to the same Symbol in the symbol pool, causing lookup_spec_fun() to return the wrong spec function and violate formal verification guarantees? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: lookup_spec_fun()] [Case Sensitivity Attack] Is symbol comparison case-sensitive? Can an attacker register 'MAP' vs 'map' as different intrinsics to cause confusion in spec function lookup? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: lookup_spec_fun()] [Unicode/UTF-8 Attack] Can Unicode normalization issues or homoglyph attacks (e.g., Cyrillic 'Ð°' vs Latin 'a') cause lookup_spec_fun() to return wrong functions when processing intrinsic names? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Context Bypass] Can an attacker provide a non-Struct SpecBlockContext that still passes the match statement by exploiting Rust enum variants, allowing intrinsic declarations in invalid contexts like module or function spec blocks? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Early Return Exploit] The function has multiple early returns - can these be triggered maliciously to skip critical validation steps while still partially modifying builder state, leaving the system in an inconsistent state? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [PropertyValue Confusion] Can an attacker provide a PropertyValue::QualifiedSymbol when a Symbol is expected to bypass the error at line 88-92, potentially injecting a cross-module reference where it shouldn't be allowed? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Boolean Pragma Bypass] The code returns early for 'true/false pragma' at line 94-96 - can this be exploited to register intrinsics without proper validation by using boolean values? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Unknown Intrinsic Type] If the target.as_str() doesn't match INTRINSIC_TYPE_MAP, the function logs an error and returns - can an attacker use this to probe for valid intrinsic type names and enumerate the system's intrinsic capabilities? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Struct Table Race Condition] The expect('struct') at line 113 assumes the struct exists in builder.parent.struct_table - can a race condition between checking context and looking up the struct cause a panic if the struct is removed concurrently? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Intrinsics List Overflow] The builder.parent.intrinsics.push(decl) at line 129 unboundedly adds declarations - can an attacker cause memory exhaustion by registering unlimited intrinsic declarations? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: process_intrinsic_declaration()] [Deref Vulnerability] The INTRINSIC_TYPE_MAP_ASSOC_FUNCTIONS.deref() at line 103 - if the underlying data is corrupted or modified during access, can this cause memory safety issues or return malicious function mappings? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: populate_intrinsic_decl()] [Missing Type Checking - CRITICAL] Lines 190 and 232 contain TODO comments stating type checking should be done on function signatures but is currently skipped - can an attacker map intrinsics to functions with completely incompatible signatures, causing type confusion and bypassing Move's type safety during bytecode execution? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: populate_intrinsic_decl()] [Cross-Module Reference Attack] Lines 157-166 check that qualified symbols must be in the same module, but can this check be bypassed by manipulating the builder.module_name field before calling populate_intrinsic_decl()? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: populate_intrinsic_decl()] [Duplicate Mapping - Second Check Missing] Lines 195-204 check for duplicate move function mappings and error, but what if the duplicate is added to move_fun_to_intrinsic but intrinsic_to_move_fun was never populated due to an earlier error? Can this cause one-way mapping inconsistencies? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: populate_intrinsic_decl()] [Duplicate Spec Function - Similar Issue] Lines 238-246 check for duplicate spec function mappings - can the same one-way mapping inconsistency occur if spec_fun_to_intrinsic insert succeeds but intrinsic_to_spec_fun was never populated? (High)",
  "[File: aptos-core/third_party/move/move-model/src/intrinsics.rs] [Function: populate_intrinsic_decl()] [PropertyValue Injection] At lines 144-154, if props.remove(&key_sym) returns a malicious PropertyValue variant not handled, can this cause silent failures or allow bypassing validation? (Medium)"
]