[
  "[File: aptos-core/state-sync/storage-service/server/src/moderator.rs] [Concurrency] [Entry Modification Race] Can the DashMap entry obtained at line 161 be modified by another thread while the current thread is still processing, causing lost updates or inconsistent state? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/moderator.rs] [Concurrency] [get() vs entry() Race] At line 142, using get() for read-only check creates a race with subsequent entry() operations - can this allow ignored peers to slip through during the race window? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/moderator.rs] [Storage Summary] [Initialization Race] Can validate_request() be called before cached_storage_server_summary is initialized, causing load() to return a default/empty summary that incorrectly accepts or rejects all requests? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/moderator.rs]\n\n### Citations\n\n**File:** state-sync/storage-service/server/src/moderator.rs (L1-411)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{error::Error, logging::LogEntry, metrics, utils, LogSchema};\nuse aptos_config::{\n    config::{AptosDataClientConfig, StorageServiceConfig},\n    network_id::{NetworkId, PeerNetworkId},\n};\nuse aptos_logger::warn;\nuse aptos_network::application::storage::PeersAndMetadata;\nuse aptos_storage_service_types::{\n    requests::StorageServiceRequest, responses::StorageServerSummary,\n};\nuse aptos_time_service::{TimeService, TimeServiceTrait};\nuse arc_swap::ArcSwap;\nuse dashmap::DashMap;\nuse std::{\n    sync::Arc,\n    time::{Duration, Instant},\n};\n\n/// A simple struct that tracks the state of an unhealthy peer\n#[derive(Clone, Debug)]\npub struct UnhealthyPeerState {\n    ignore_start_time: Option<Instant>, // The time when we first started ignoring the peer\n    invalid_request_count: u64,         // The total number of invalid requests from the peer\n    max_invalid_requests: u64, // The max number of invalid requests before ignoring the peer\n    min_time_to_ignore_secs: u64, // The min time (secs) to ignore the peer (doubles each round)\n    time_service: TimeService, // The time service\n}\n\nimpl UnhealthyPeerState {\n    pub fn new(\n        max_invalid_requests: u64,\n        min_time_to_ignore_secs: u64,\n        time_service: TimeService,\n    ) -> Self {\n        Self {\n            ignore_start_time: None,\n            invalid_request_count: 0,\n            max_invalid_requests,\n            min_time_to_ignore_secs,\n            time_service,\n        }\n    }\n\n    /// Increments the invalid request count for the peer and marks\n    /// the peer to be ignored if it has sent too many invalid requests.\n    /// Note: we only ignore peers on the public network.\n    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {\n        // Increment the invalid request count\n        self.invalid_request_count += 1;\n\n        // If the peer is a PFN and has sent too many invalid requests, start ignoring it\n        if self.ignore_start_time.is_none()\n            && peer_network_id.network_id().is_public_network()\n            && self.invalid_request_count >= self.max_invalid_requests\n        {\n            // TODO: at some point we'll want to terminate the connection entirely\n\n            // Start ignoring the peer\n            self.ignore_start_time = Some(self.time_service.now());\n\n            // Log the fact that we're now ignoring the peer\n            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)\n                .peer_network_id(peer_network_id)\n                .message("
]