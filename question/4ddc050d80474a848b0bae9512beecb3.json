[
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Panic/DoS] Can a malicious validator pass an empty ordered_blocks vector to trigger the assertion panic at line 30, causing a node crash and potential consensus disruption? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [State Inconsistency] Can duplicate rounds in ordered_blocks cause the HashMap construction at lines 31-36 to silently overwrite entries, leading to inconsistent offsets_by_round mappings that break round lookups? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Memory Exhaustion] Can an attacker provide extremely large ordered_blocks or pending_secret_key_rounds collections to exhaust memory during HashMap/HashSet construction, causing node OOM and consensus failure? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Logic Error] If ordered_blocks contains blocks with non-sequential or duplicate rounds, does the offsets_by_round mapping correctly handle all cases, or can it cause later offset() lookups to fail or return incorrect indices? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Validation Bypass] Does QueueItem::new() validate that all rounds in pending_secret_key_rounds actually correspond to rounds in ordered_blocks, or can mismatched rounds cause undefined behavior in set_secret_shared_key()? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::first_round()] [Panic/DoS] The expect() at line 48 assumes blocks() cannot be empty, but can concurrent modifications or race conditions violate this invariant and cause a panic that crashes the validator node? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::first_round()] [Integer Overflow] Does first_round() handle rounds near u64::MAX correctly, or can integer overflow in subsequent round arithmetic cause consensus divergence when validators process blocks differently? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::first_round()] [Consensus Manipulation] Can a Byzantine validator craft blocks with manipulated round numbers (e.g., round 0 or u64::MAX) to cause first_round() to return values that break BlockQueue ordering assumptions? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::offset()] [Panic/DoS] The expect() at line 57 panics if round is not found - can a malicious validator query offset() with a round not in offsets_by_round to intentionally crash honest validators and disrupt consensus? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::offset()] [Race Condition] If offsets_by_round is modified concurrently with offset() calls (despite &self), can unsafe code or interior mutability elsewhere cause data races that return incorrect offsets leading to wrong block access? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::offset()] [State Corruption] If the offsets_by_round HashMap becomes corrupted or out-of-sync with ordered_blocks due to bugs in new(), can offset() return indices that cause out-of-bounds access in set_secret_shared_key()? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::offset()] [Type Confusion] Can usize overflow or platform-specific behavior (32-bit vs 64-bit) cause offset() to return values that appear valid but lead to incorrect array indexing in blocks_mut()? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::is_fully_secret_shared()] [Liveness Attack] Can a Byzantine validator prevent set_secret_shared_key() from being called for certain rounds, keeping pending_secret_key_rounds non-empty forever and blocking dequeue_ready_prefix() to halt block processing? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::is_fully_secret_shared()] [State Inconsistency] If pending_secret_key_rounds is initialized incorrectly in new() but secret shares are actually not needed, can is_fully_secret_shared() return false indefinitely causing blocks to never be processed? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::is_fully_secret_shared()] [Race Condition] Can concurrent calls to set_secret_shared_key() and is_fully_secret_shared() create TOCTOU (time-of-check-time-of-use) bugs where dequeue_ready_prefix() dequeues partially-ready items? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Cryptographic Bypass] Can a malicious validator call set_secret_shared_key() with an invalid or malformed SecretSharedKey that passes type checking but breaks downstream randomness generation or signature aggregation? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Double-Assignment Attack] Can set_secret_shared_key() be called multiple times for the same round to overwrite a valid secret share with a malicious one, since line 66 only checks pending_secret_key_rounds.contains() but doesn't prevent re-entry? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Panic/DoS] If offset(round) is called at line 65 with a round not in offsets_by_round, it will panic per line 57 - can an attacker trigger this by providing a round that was removed or never existed? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Race Condition] The check at line 66 and removal at line 75 are not atomic - can concurrent set_secret_shared_key() calls for the same round cause race conditions where the secret is set multiple times or pending_secret_key_rounds becomes inconsistent? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Channel Poisoning] At lines 72-73, if tx.secret_shared_key_tx.take() removes the sender, can subsequent calls to set_secret_shared_key() for the same round silently fail to send the key, causing downstream components to hang waiting for the secret? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Logic Error] The condition at line 66 checks pending_secret_key_rounds.contains(&round) - what happens if this is false? The secret key is silently ignored, which could allow attackers to call this with wrong rounds to waste resources or probe state. (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Mutex Deadlock] At line 72, pipeline_tx().lock() acquires a mutex - can recursive or nested lock acquisition cause deadlocks that freeze the validator's block processing pipeline? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Send Failure] At line 73, tx.send(Some(key)) can fail if the receiver is dropped - is this failure handled, or can silent send failures cause some validators to proceed without secret shares while others wait indefinitely? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [State Corruption] If blocks_mut()[offset] is called with an offset out of bounds due to corrupted offsets_by_round, can this cause memory safety violations or panics that crash the validator? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Timing Side-Channel] Does observe_block() at line 68 leak timing information about secret share arrival that could help an attacker infer network topology or identify which validators have which shares? (Low)"
]