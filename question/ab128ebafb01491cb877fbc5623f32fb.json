[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_module_alias()] [Alias collision] Can an attacker craft a malicious Move module with conflicting module aliases that bypass the duplicate detection in remove_module_alias_(), allowing alias shadowing to cause non-deterministic compilation across validators and leading to state divergence? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_module_alias()] [Race condition] Is there a TOCTOU (Time-Of-Check-Time-Of-Use) vulnerability between remove_module_alias_() check and modules.add() operation that could allow concurrent compilation threads to insert duplicate aliases, causing undefined behavior in alias resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_module_alias()] [Unwrap panic] The modules.add() call uses unwrap() after remove_module_alias_() - can this panic if UniqueMap internal state is corrupted, causing compiler crashes and preventing legitimate Move code deployment during critical governance upgrades? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_module_alias()] [Error handling bypass] Does the error return from remove_module_alias_() properly propagate to prevent alias insertion, or can an attacker exploit error handling to inject aliases even after remove fails, leading to namespace pollution attacks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_module_alias()] [is_implicit flag manipulation] The is_implicit flag is hardcoded to false - can an attacker exploit this by manipulating AliasMapBuilder state before calling add_module_alias() to cause implicit aliases to be treated as explicit, breaking unused alias tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_member_alias()] [Type confusion] Can a malicious Move module register a member alias that shadows a critical system function (e.g., transfer, mint) from a different module, causing type confusion during execution and bypassing access controls in the Aptos Framework? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_member_alias()] [Member-module mismatch] Does add_member_alias() validate that the member actually exists in the specified ModuleIdent, or can attackers register fake member aliases pointing to non-existent functions to cause compilation inconsistencies across validators? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_member_alias()] [Tuple destructuring] The (ident, member) tuple is stored without validation - can an attacker craft a malicious tuple with swapped positions or invalid data to cause memory corruption during alias resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_member_alias()] [Unwrap panic] Similar to add_module_alias(), the unwrap() after members.add() can panic - can this be exploited to DoS the compiler during critical protocol upgrades when governance proposals need to be compiled? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_member_alias()] [Name collision with modules] Can an attacker register a member alias with the same name as a module alias, causing namespace confusion where member_alias_get() and module_alias_get() return conflicting results leading to undefined behavior? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_module_alias()] [Unused tracking bypass] Implicit aliases are not tracked in unused set - can an attacker flood the compiler with implicit aliases that never get reported as unused, causing memory exhaustion in long-running compilation sessions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_module_alias()] [Implicit-explicit confusion] Can an attacker exploit the difference between implicit and explicit aliases by first adding an implicit alias, then shadowing it with an explicit one, causing the compiler to incorrectly track usage and miss unused imports? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_module_alias()] [is_implicit flag trust] The is_implicit flag is set to true without validation - can an attacker manipulate the builder state to flip this flag for explicit aliases, causing them to evade unused alias detection? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_module_alias()] [Determinism issue] Different validators may have different implicit alias insertion order - can this cause non-deterministic compilation results where identical Move source produces different bytecode across validators, leading to consensus failures? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_member_alias()] [Cross-module poisoning] Can an attacker use implicit member aliases to poison the namespace of other modules by injecting member names that shadow critical functions, causing subtle bugs in dependent contracts? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: add_implicit_member_alias()] [Memory leak] Implicit member aliases are never added to unused tracking - can repeated compilation of malicious Move modules cause unbounded memory growth in the AliasMap members field? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_module_alias_()] [Location leak] The function clones the location before removal - can an attacker exploit this to cause memory leaks by repeatedly adding and removing aliases in a loop during compilation? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_module_alias_()] [None vs Some inconsistency] When modules.remove() returns None, the function returns Ok(()) - is this the correct behavior, or should it return an error to catch logic bugs where removal is expected but doesn't happen? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_module_alias_()] [Unwrap on loc] The function does loc.unwrap() when modules.remove() returns Some - can this panic if get_loc() returned None due to UniqueMap internal inconsistency, causing compiler crashes? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_module_alias_()] [Double removal] Can an attacker trigger remove_module_alias_() twice for the same alias in concurrent compilation scenarios, causing the second call to incorrectly return Ok(()) and masking duplicate alias errors? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_member_alias_()] [Location inconsistency] Similar to remove_module_alias_(), this uses get_loc() and unwrap() - can inconsistent location data in UniqueMap cause panics that crash the compiler during critical deployments? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: remove_member_alias_()] [Member-module asymmetry] The function only removes member aliases without checking if the associated module still exists - can this lead to dangling member references that cause crashes during alias resolution? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [Mutable borrow race] The function takes &mut self and mutates depth_opt - can concurrent calls to module_alias_get() from different compilation threads cause data races leading to incorrect alias resolution? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [Depth index out of bounds] When accessing self.unused[*depth], can an attacker craft a depth value that exceeds unused.len(), causing an index-out-of-bounds panic and compiler crash? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/aliases.rs] [Function: module_alias_get()] [Location preservation attack] The function preserves n.loc for the module name but not for the address - can an attacker exploit location inconsistencies to bypass source-level security checks that rely on location information? (Medium)"
]