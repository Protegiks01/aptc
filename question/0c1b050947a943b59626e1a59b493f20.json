[
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [Occupied Entry Behavior] At line 175, when the entry is already Occupied, does silently continuing without updating the AcquiredAt information hide the fact that multiple paths acquire the same resource, potentially missing security-relevant information? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [Location Cloning] When other_fun_called_at.clone() is performed at line 170, can excessive cloning of large location objects cause memory exhaustion in modules with many functions, leading to DoS during compilation? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [Changed Flag Logic] The changed boolean at line 164 is only set to true when a new entry is inserted - can this cause the fixpoint algorithm to miss updates when existing entries should be modified with more specific information? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [Iterator Safety] When iterating over other_acquries.0.iter() at line 165, can concurrent modifications to other_acquries cause iterator invalidation or skip elements, leading to incomplete resource tracking? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [BTreeMap Entry API] Does using Entry::Vacant/Occupied at lines 168-175 properly handle all edge cases, or can entry API race conditions in the Rust standard library cause lost updates when the same StructId is being processed? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquiredResources::join()] [Self-Reference] If other_fun == self (the function being joined into), can this cause infinite recursion or incorrect indirect acquisitions being recorded for direct self-calls? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquireChecker::analyze()] [Pipeline Order] Can the order of operations - first building call graph, then computing fixpoint - be exploited by having functions that are added to the module after the call graph is built but before fixpoint computation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: AcquireChecker::analyze()] [Incomplete Results] If get_call_graph_and_directly_acquired_resources() returns incomplete data due to parsing errors or unsupported Move features, does compute_fixed_point() propagate these gaps, causing entire modules to have incorrect acquires information? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_call_graph_and_directly_acquired_resources()] [Function Iteration Order] When iterating over self.mod_env.get_functions() at line 211, can the iteration order affect the final results if there are hidden ordering dependencies in how call graphs are built? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_call_graph_and_directly_acquired_resources()] [Callees Overwrite] When call_graph.insert(fun_id, callees) is called at line 214, if the same fun_id is encountered multiple times (e.g., due to generics or specialization), can the later insert overwrite earlier callee information, causing missed call edges? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_call_graph_and_directly_acquired_resources()] [Map Collection] When collecting resources.into_iter().map(...).collect() at lines 215-218, can iterator adapters introduce non-determinism if the underlying resources map iteration order varies across platforms? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_call_graph_and_directly_acquired_resources()] [Empty Function Bodies] If get_callees_and_acquired_resources() is called for functions without bodies, does it return empty maps, and can these empty entries interfere with the fixpoint computation by acting as fixed points prematurely? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_call_graph_and_directly_acquired_resources()] [Resource Location Wrapping] When wrapping resources with AcquiredAt::Directly(loc) at line 217, are the locations guaranteed to point to the actual move_from/borrow_global operations, or can they point to enclosing expressions, misleading security analysis? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Non-Termination] Can the worklist algorithm at lines 238-262 fail to terminate if there are cyclic dependencies in the call graph that cause infinite re-additions to the work_list, leading to compilation hangs or resource exhaustion? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Reversed Call Graph Accuracy] When building reversed_call_graph using fold() at lines 229-237, can fold's accumulator pattern introduce bugs if the closure captures external state or if BTreeMap insertion order matters? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Self-Loop Handling] At lines 247-249, recursive calls where *callee == fun_id are explicitly skipped with continue - does this correctly handle mutual recursion (A calls B calls A), or can mutual recursion cause incorrect acquires propagation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [VecDeque Manipulation] When work_list.pop_front() is called at line 243, and later push_back() at line 258, can adversarial function ordering exploit the FIFO queue behavior to cause worst-case quadratic time complexity? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Remove-Insert Pattern] The pattern of acquire_env.remove(&fun_id) at line 245 followed by acquire_env.insert(fun_id, caller_acquires) at line 254 - can this leave the map in an inconsistent state if a panic occurs between remove and insert? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Expect Panics] The two .expect() calls at lines 245 and 250 assume the maps are always complete - can partial initialization or concurrent modification cause these expects to panic, crashing the compiler? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Any Changes Aggregation] When any_changes accumulates 'changed' results at line 252, is the logical OR operation sufficient, or can short-circuiting hide multiple changes that should be reported separately? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Caller Propagation] When iterating callers at lines 256-260, can the absence of a caller in reversed_call_graph (checked at line 256) hide functions that should have their acquires updated, causing incomplete fixpoint results? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Work List Duplicates] When push_back(*caller) is called at line 258 for each caller, can the same function be added to work_list multiple times, causing redundant re-computation and exponential blowup? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: compute_fixed_point()] [Initial Work List] The initial work_list at lines 238-242 contains all functions - does starting with all functions instead of just leaf functions in the call graph cause unnecessary iterations, and can this be exploited for DoS? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_callees_and_acquired_resources()] [Missing Function Body] When fun_env.get_def() returns None at line 278, returning empty callees and resources maps could be correct for native functions, but can this hide missing implementations for functions that should have bodies? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/src/env_pipeline/acquires_checker.rs] [Function: get_callees_and_acquired_resources()] [Spec Block State] The in_spec_block flag at lines 279 and 302 is used to exclude spec code - can malicious code embed acquires operations inside spec blocks to hide resource access from the checker? (Critical)"
]