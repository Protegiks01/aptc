[
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: EventFilter] [Case sensitivity] Is data_substring_filter case-sensitive, and can attackers bypass filters by using different casing in event data? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: EventFilter] [Empty filter matching] Does an EventFilter with both struct_type and data_substring_filter set to None match all events, potentially exposing private event data? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: APIFilter] [Oneof variant confusion] Can an APIFilter have multiple oneof variants set simultaneously due to protobuf encoding bugs, causing undefined filter behavior? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: APIFilter] [None variant bypass] Does APIFilter properly handle when the filter oneof is None, or does this bypass all filtering logic? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: BooleanTransactionFilter] [Recursive filter DoS] Can BooleanTransactionFilter logical_not contain another BooleanTransactionFilter with logical_not, creating infinite recursion that crashes the indexer? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: BooleanTransactionFilter] [Circular reference] Can attackers craft BooleanTransactionFilter with LogicalAnd containing LogicalOr containing LogicalNot in a circular pattern, causing stack overflow during evaluation? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: BooleanTransactionFilter] [Box allocation exhaustion] Can deeply nested logical_not Box allocations cause heap exhaustion before recursion depth limits are hit? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: BooleanTransactionFilter] [Oneof None bypass] Does BooleanTransactionFilter with all oneof variants set to None act as a match-all filter, bypassing security filtering? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsInStorage] [Vector size limit] Is the transactions repeated field bounded, or can an attacker store millions of transactions in a single TransactionsInStorage message, causing memory exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsInStorage] [Version continuity] Does TransactionsInStorage validate that transaction versions are sequential starting from starting_version, or can gaps/duplicates cause state inconsistency? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsInStorage] [Starting version overflow] Can starting_version be set to u64::MAX, causing integer overflow when calculating ending version or array indices? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsInStorage] [Empty transactions vector] Does TransactionsInStorage properly handle empty transactions vectors, or does this cause division by zero or null pointer errors in processing logic? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Integer overflow] Can starting_version + transactions_count overflow u64::MAX, causing wrap-around to version 0 and exposing genesis transactions? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Batch size bypass] Is batch_size properly capped at 1000 as the comment suggests, or can an attacker send batch_size > 1000 to cause memory exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Infinite stream DoS] Can transactions_count be set to u64::MAX to request effectively infinite transactions, causing indexer resource exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Version validation] Does GetTransactionsRequest validate that starting_version exists in the blockchain, or can requests for non-existent versions cause errors? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Future version access] Can an attacker request starting_version beyond the current chain tip, potentially receiving uncommitted or invalid transaction data? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Zero batch size] Does batch_size=0 cause division by zero errors or infinite loops in response pagination logic? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [Filter complexity] Can extremely complex transaction_filter with deep nesting cause exponential evaluation time, leading to CPU exhaustion DoS? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: GetTransactionsRequest] [None field semantics] When starting_version or transactions_count are None, what are the default behaviors, and can these be exploited? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: ProcessedRange] [Inverted range] Can first_version > last_version, indicating an inverted or invalid range that causes underflow in range calculations? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: ProcessedRange] [Single version range] Does first_version == last_version properly represent a range of 1 transaction, or does this cause off-by-one errors? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: ProcessedRange] [Range overflow] Can last_version - first_version overflow, causing incorrect range size calculations? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsResponse] [Chain ID mismatch] Does TransactionsResponse validate that chain_id matches the client's expected chain, or can responses from wrong chains be accepted? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.rs] [Struct: TransactionsResponse] [Response size limit] Is the transactions vector size bounded relative to the original batch_size request, or can oversized responses cause memory exhaustion? (High)"
]