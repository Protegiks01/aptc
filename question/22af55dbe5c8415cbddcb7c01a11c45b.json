[
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceError] [Error type confusion] Can a malicious peer send a crafted InternalError with embedded control characters or extremely long strings to cause log injection attacks or memory exhaustion when error messages are logged? (Medium)",
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceError] [DoS via error spam] Can an attacker repeatedly trigger TooManyInvalidRequests errors to fill logs and cause disk exhaustion on validator nodes, potentially causing node failures? (High)",
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceError] [Information leakage] Does the InternalError variant expose sensitive internal state information or stack traces that could help attackers identify vulnerabilities in the storage service implementation? (Low)",
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceMessage] [Type confusion attack] Can an attacker craft a StorageServiceMessage that switches between Request and Response variants mid-stream to cause state machine confusion in the storage service handler? (High)",
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceMessage] [Nested error exploitation] In the Response(Result<StorageServiceResponse>) variant, can deeply nested error types cause stack overflow during deserialization or error handling? (Medium)",
  "[File: state-sync/storage-service/types/src/lib.rs] [Enum: StorageServiceMessage] [Serialization size attack] Can an attacker send a StorageServiceMessage with a massive serialized size that bypasses MAX_APPLICATION_MESSAGE_SIZE checks to cause memory exhaustion? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: StorageServiceRequest] [Compression flag manipulation] Can an attacker set use_compression to false but send compressed data, or vice versa, to cause decompression errors or bypass size limits? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Function: get_label()] [Label injection] Can the label string concatenation with COMPRESSION_SUFFIX_LABEL be exploited to inject malicious metric labels that corrupt monitoring systems? (Low)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Enum: DataRequest] [Integer overflow in version ranges] Can an attacker request data with start_version = 0 and end_version = u64::MAX to cause integer overflow when calculating range sizes? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: EpochEndingLedgerInfoRequest] [Epoch range manipulation] Can start_epoch > expected_end_epoch create a degenerate range that bypasses validation and causes undefined behavior in range iteration? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: EpochEndingLedgerInfoRequest] [Massive epoch range DoS] Can an attacker request start_epoch=0 and expected_end_epoch=u64::MAX to force the server to attempt serving billions of epoch ending ledger infos, causing memory exhaustion? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionOutputsWithProofRequest] [Known version spoofing] Can a malicious peer lie about known_version and known_epoch to receive duplicate or incorrect optimistic fetch data, causing state sync inconsistencies? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionOutputsWithProofRequest] [Optimistic fetch replay] Can an attacker replay old NewTransactionOutputsWithProof requests with stale known_version to retrieve old proofs and potentially cause state rollback? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsWithProofRequest] [Event inclusion manipulation] Can toggling include_events between true/false for the same version range cause inconsistent caching or proof validation failures? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: StateValuesWithProofRequest] [Index range attack] Can start_index > end_index create an invalid range that causes integer underflow when calculating the number of state values to fetch? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: StateValuesWithProofRequest] [Massive state range DoS] Can an attacker request start_index=0 and end_index=u64::MAX at a high version to force the server to attempt loading all state values into memory? (Critical)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: StateValuesWithProofRequest] [Version mismatch exploit] Can requesting state values at a version that doesn't exist cause the server to expose internal state or error information? (Low)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: TransactionOutputsWithProofRequest] [Proof version manipulation] Can proof_version > end_version cause incorrect proof generation or validation bypass when the proof is relative to a future version? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: TransactionOutputsWithProofRequest] [Proof version underflow] Can proof_version < start_version cause the proof to reference a state before the requested data, potentially allowing invalid data injection? (Critical)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Version range boundary] Can start_version = end_version request a single transaction, and does this edge case properly validate that the transaction exists? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsWithProofRequest] [Zero-length range] Can start_version = end_version + 1 create a zero-length range that bypasses validation and returns empty data without proper error handling? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Output reduction manipulation] Can max_num_output_reductions = 0 force the server to always return transactions even when outputs would be more efficient, causing bandwidth waste? (Low)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: NewTransactionsOrOutputsWithProofRequest] [Output reduction overflow] Can max_num_output_reductions = u64::MAX cause integer overflow when counting reduction attempts? (Medium)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: TransactionsOrOutputsWithProofRequest] [Proof version inconsistency] If transactions and outputs have different proof requirements, can proof_version be set to satisfy one but not the other, causing partial validation failure? (High)",
  "[File: state-sync/storage-service/types/src/requests.rs] [Struct: SubscribeTransactionOutputsWithProofRequest] [Stream index manipulation] Can subscription_stream_index overflow or wrap around to replay old subscription data? (Medium)"
]