[
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Platform] [FreeBSD compatibility] Are FreeBSD-specific socket options or behaviors handled correctly, or could they cause issues? (Low)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Crypto] [TLS layer] Is TCP used as a transport for TLS, and if so, is the TLS handshake properly authenticated to prevent MitM attacks? (Critical)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Crypto] [Pre-shared keys] Are connections authenticated using pre-shared keys or certificates after TCP establishment? (Critical)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Crypto] [Downgrade attacks] Can attackers force connections to use unencrypted TCP instead of an encrypted transport? (Critical)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Edge case] [Zero-length addresses] How does the code handle zero-length NetworkAddress inputs, or addresses with only protocol prefixes? (Low)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Edge case] [Maximum address length] Are there limits on NetworkAddress length, or can extremely long addresses cause parsing issues or buffer overflows? (Medium)",
  "[File: aptos-core/network/netcore/src/transport/tcp.rs] [Edge case] [Special IP addresses] How are special-use IP addresses (0.0.0.0, 255.255.255.255, etc.) handled in address validation? (Low)",
  "[File: aptos-core/network/\n\n### Citations\n\n**File:** network/netcore/src/transport/tcp.rs (L1-493)\n```rust\n// Copyright © Aptos Foundation\n// Parts of the project are originally copyright © Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n//! TCP Transport\nuse crate::transport::Transport;\nuse aptos_proxy::Proxy;\nuse aptos_types::{\n    network_address::{parse_dns_tcp, parse_ip_tcp, parse_tcp, IpFilter, NetworkAddress},\n    PeerId,\n};\nuse futures::{\n    future::{self, Either, Future},\n    io::{AsyncRead, AsyncWrite},\n    ready,\n    stream::Stream,\n};\nuse std::{\n    fmt::Debug,\n    io,\n    net::SocketAddr,\n    pin::Pin,\n    task::{Context, Poll},\n};\nuse tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::{lookup_host, TcpListener, TcpStream},\n};\nuse tokio_util::compat::Compat;\nuse url::Url;\n\n#[derive(Debug, Clone, Copy, Default)]\npub struct TCPBufferCfg {\n    inbound_rx_buffer_bytes: Option<u32>,\n    inbound_tx_buffer_bytes: Option<u32>,\n    outbound_rx_buffer_bytes: Option<u32>,\n    outbound_tx_buffer_bytes: Option<u32>,\n}\n\nimpl TCPBufferCfg {\n    pub const fn new() -> Self {\n        Self {\n            inbound_rx_buffer_bytes: None,\n            inbound_tx_buffer_bytes: None,\n            outbound_rx_buffer_bytes: None,\n            outbound_tx_buffer_bytes: None,\n        }\n    }\n\n    pub fn new_configs(\n        inbound_rx: Option<u32>,\n        inbound_tx: Option<u32>,\n        outbound_rx: Option<u32>,\n        outbound_tx: Option<u32>,\n    ) -> Self {\n        Self {\n            inbound_rx_buffer_bytes: inbound_rx,\n            inbound_tx_buffer_bytes: inbound_tx,\n            outbound_rx_buffer_bytes: outbound_rx,\n            outbound_tx_buffer_bytes: outbound_tx,\n        }\n    }\n}\n\n/// Transport to build TCP connections\n#[derive(Debug, Clone, Default)]\npub struct TcpTransport {\n    /// TTL to set for opened sockets, or `None` to keep default.\n    pub ttl: Option<u32>,\n    /// `TCP_NODELAY` to set for opened sockets, or `None` to keep default.\n    pub nodelay: Option<bool>,\n\n    pub tcp_buff_cfg: TCPBufferCfg,\n}\n\nimpl TcpTransport {\n    fn apply_config(&self, stream: &TcpStream) -> ::std::io::Result<()> {\n        if let Some(ttl) = self.ttl {\n            stream.set_ttl(ttl)?;\n        }\n\n        if let Some(nodelay) = self.nodelay {\n            stream.set_nodelay(nodelay)?;\n        }\n\n        Ok(())\n    }\n\n    pub fn set_tcp_buffers(&mut self, configs: &TCPBufferCfg) {\n        self.tcp_buff_cfg = *configs;\n    }\n}\n\nimpl Transport for TcpTransport {\n    type Error = ::std::io::Error;\n    type Inbound = future::Ready<io::Result<TcpSocket>>;\n    type Listener = TcpListenerStream;\n    type Outbound = TcpOutbound;\n    type Output = TcpSocket;\n\n    fn listen_on(\n        &self,\n        addr: NetworkAddress,\n    ) -> Result<(Self::Listener, NetworkAddress), Self::Error> {\n        let ((ipaddr, port), addr_suffix) =\n            parse_ip_tcp(addr.as_slice()).ok_or_else(|| invalid_addr_error(&addr))?;\n        if !addr_suffix.is_empty() {\n            return Err(invalid_addr_error(&addr));\n        }\n\n        let addr = SocketAddr::new(ipaddr, port);\n\n        let socket = if ipaddr.is_ipv4() {\n            tokio::net::TcpSocket::new_v4()?\n        } else {\n            tokio::net::TcpSocket::new_v6()?\n        };\n\n        if let Some(rx_buf) = self.tcp_buff_cfg.inbound_rx_buffer_bytes {\n            socket.set_recv_buffer_size(rx_buf)?;\n        }\n        if let Some(tx_buf) = self.tcp_buff_cfg.inbound_tx_buffer_bytes {\n            socket.set_send_buffer_size(tx_buf)?;\n        }\n        socket.set_reuseaddr(true)?;\n        socket.bind(addr)?;\n\n        let listener = socket.listen(256)?;\n        let listen_addr = NetworkAddress::from(listener.local_addr()?);\n\n        Ok((\n            TcpListenerStream {\n                inner: listener,\n                config: self.clone(),\n            },\n            listen_addr,\n        ))\n    }\n\n    fn dial(&self, _peer_id: PeerId, addr: NetworkAddress) -> Result<Self::Outbound, Self::Error> {\n        let protos = addr.as_slice();\n\n        // ensure addr is well formed to save some work before potentially\n        // spawning a dial task that will fail anyway.\n        parse_ip_tcp(protos)\n            .map(|_| ())\n            .or_else(|| parse_dns_tcp(protos).map(|_| ()))\n            .ok_or_else(|| invalid_addr_error(&addr))?;\n\n        let proxy = Proxy::new();\n\n        let proxy_addr = {\n            use aptos_types::network_address::Protocol::*;\n\n            let addr = match protos.first() {\n                Some(Ip4(ip)) => proxy.https(&ip.to_string()),\n                Some(Ip6(ip)) => proxy.https(&ip.to_string()),\n                Some(Dns(name)) | Some(Dns4(name)) | Some(Dns6(name)) => proxy.https(name.as_ref()),\n                _ => None,\n            };\n\n            addr.and_then(|https_proxy| Url::parse(https_proxy).ok())\n                .and_then(|url| {\n                    if url.has_host() && url.scheme() =="
]