[
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Struct: ChangeSetConfigs] [Version mismatch] Can configs serialized with one feature version be deserialized with a different version, causing limit bypasses? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: legacy_resource_creation_as_modification()] [Table item exploit] The comment states table items were unaffected by the bug - can this differential create exploitable gaps in gas accounting? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: check_change_set()] [Module size accounting] Are Move modules properly included in write_set_size calculations, or can unlimited module deployments bypass limits? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: check_change_set()] [Table item size] Do table items (potentially unbounded key-value pairs) get proper size accounting in write operations? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: check_change_set()] [Validation timing] Can timing side channels in check_change_set() reveal information about which limit was violated, aiding attackers? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: new()] [Config update timing] During gas parameter updates, is there a time window where some validators use old and others use new configs? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: legacy_resource_creation_as_modification()] [Resource group bypass] Since resource groups were introduced after version 3, can they be exploited in ways the limits weren't designed to handle? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: check_change_set()] [Group operation cost] Do resource group operations (adding/removing from groups) properly account for size in both individual and group contexts? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: new()] [Feature flag manipulation] Can feature flags be manipulated to force validators into using inappropriate gas_feature_version values? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: from_gas_params()] [Governance attack] Can malicious governance proposals set gas parameters that brick the network by making all transactions invalid? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/change_set_configs.rs] [Function: from_gas_params\n\n### Citations\n\n**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L1-129)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::change_set::ChangeSetInterface;\nuse aptos_gas_schedule::AptosGasParameters;\nuse move_binary_format::errors::{Location, PartialVMError};\nuse move_core_types::vm_status::{StatusCode, VMStatus};\n\n#[derive(Clone, Debug)]\npub struct ChangeSetConfigs {\n    gas_feature_version: u64,\n    max_bytes_per_write_op: u64,\n    max_bytes_all_write_ops_per_transaction: u64,\n    max_bytes_per_event: u64,\n    max_bytes_all_events_per_transaction: u64,\n    max_write_ops_per_transaction: u64,\n}\n\nimpl ChangeSetConfigs {\n    pub fn unlimited_at_gas_feature_version(gas_feature_version: u64) -> Self {\n        Self::new_impl(\n            gas_feature_version,\n            u64::MAX,\n            u64::MAX,\n            u64::MAX,\n            u64::MAX,\n            u64::MAX,\n        )\n    }\n\n    pub fn new(feature_version: u64, gas_params: &AptosGasParameters) -> Self {\n        if feature_version >= 5 {\n            Self::from_gas_params(feature_version, gas_params)\n        } else if feature_version >= 3 {\n            Self::for_feature_version_3()\n        } else {\n            Self::unlimited_at_gas_feature_version(feature_version)\n        }\n    }\n\n    fn new_impl(\n        gas_feature_version: u64,\n        max_bytes_per_write_op: u64,\n        max_bytes_all_write_ops_per_transaction: u64,\n        max_bytes_per_event: u64,\n        max_bytes_all_events_per_transaction: u64,\n        max_write_ops_per_transaction: u64,\n    ) -> Self {\n        Self {\n            gas_feature_version,\n            max_bytes_per_write_op,\n            max_bytes_all_write_ops_per_transaction,\n            max_bytes_per_event,\n            max_bytes_all_events_per_transaction,\n            max_write_ops_per_transaction,\n        }\n    }\n\n    pub fn legacy_resource_creation_as_modification(&self) -> bool {\n        // Bug fixed at gas_feature_version 3 where (non-group) resource creation was converted to\n        // modification.\n        // Modules and table items were not affected (https://github.com/aptos-labs/aptos-core/pull/4722/commits/7c5e52297e8d1a6eac67a68a804ab1ca2a0b0f37).\n        // Resource groups and state values with metadata were not affected because they were\n        // introduced later than feature_version 3 on all networks.\n        self.gas_feature_version < 3\n    }\n\n    fn for_feature_version_3() -> Self {\n        const MB: u64 = 1 << 20;\n\n        Self::new_impl(3, MB, u64::MAX, MB, 10 * MB, u64::MAX)\n    }\n\n    fn from_gas_params(gas_feature_version: u64, gas_params: &AptosGasParameters) -> Self {\n        let params = &gas_params.vm.txn;\n        Self::new_impl(\n            gas_feature_version,\n            params.max_bytes_per_write_op.into(),\n            params.max_bytes_all_write_ops_per_transaction.into(),\n            params.max_bytes_per_event.into(),\n            params.max_bytes_all_events_per_transaction.into(),\n            params.max_write_ops_per_transaction.into(),\n        )\n    }\n\n    pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {\n        let storage_write_limit_reached = |maybe_message: Option<&str>| {\n            let mut err = PartialVMError::new(StatusCode::STORAGE_WRITE_LIMIT_REACHED);\n            if let Some(message) = maybe_message {\n                err = err.with_message(message.to_string())\n            }\n            Err(err.finish(Location::Undefined).into_vm_status())\n        };\n\n        if self.max_write_ops_per_transaction != 0\n            && change_set.num_write_ops() as u64 > self.max_write_ops_per_transaction\n        {\n            return storage_write_limit_reached(Some("
]