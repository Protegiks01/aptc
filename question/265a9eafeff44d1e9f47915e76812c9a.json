[
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Integer overflow] At line 122, when calculating `ending_version = starting_version + count`, can an attacker provide a `transactions_count` value that causes integer overflow, potentially wrapping around to a small version number and allowing unauthorized access to historical data or causing incorrect version ranges? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Integer overflow bypass] At line 80, the validation checks if `starting_version > known_latest_version + 10000`, but can an attacker exploit integer overflow by providing a starting_version near u64::MAX to bypass this check and cause undefined behavior? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Integer overflow] At line 203, `size_bytes += batch_size_bytes as u64` accumulates without overflow checking - can an attacker request many large batches to overflow size_bytes, causing incorrect metrics reporting or bypassing size limits in downstream systems? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Integer overflow] At line 202, `next_version = last_processed_version + 1` can overflow if last_processed_version is u64::MAX, causing version to wrap to 0 and potentially re-serving old data or causing infinite loops? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Integer underflow] At line 77, `starting_version.unwrap_or(known_latest_version)` sets starting_version to current latest, but what happens if transactions_count causes ending_version calculation to underflow when starting_version is 0? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Race condition] At lines 69-136, multiple concurrent requests are spawned in tokio_scoped::scope without synchronization - can concurrent modifications to in_memory_cache cause data races when reading start_version and end_version simultaneously? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Race condition] At line 76, `known_latest_version` is fetched, but between lines 76-80 it could be updated by another thread - can an attacker exploit TOCTOU (time-of-check-time-of-use) race condition to bypass the `starting_version > known_latest_version + 10000` validation? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Race condition] At lines 171-172, `connection_manager.update_stream_progress()` is called while `next_version` is being modified - can race conditions cause incorrect progress reporting or allow an attacker to manipulate stream state? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Race condition] At lines 162-163, stream insertion happens before starting the loop - can concurrent calls to `remove_active_stream()` from line 224 cause use-after-free or dangling references? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Race condition] Between lines 62-68 where `continuously_fetch_latest_data()` runs and line 76 where `known_latest_version` is read, can race conditions cause stale version reads leading to incorrect validation decisions? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Race condition] At lines 180-189, in_memory_cache.get_data() is called without holding locks across the entire operation - can the cache be evicted between getting data and sending response, causing inconsistent state? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Resource exhaustion] At line 69, `handler_rx.blocking_recv()` accepts unlimited concurrent requests without rate limiting - can an attacker spawn thousands of streams to exhaust memory and CPU resources, causing service denial? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Memory exhaustion] At line 124, each request spawns a new task in scope - can an attacker send many requests with `ending_version = None` (u64::MAX at line 166) to create long-running streams that never terminate and exhaust memory? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [CPU exhaustion] At lines 167-178, the loop sleeps for only 100ms when waiting for new data - can an attacker create many streams waiting at the head to cause excessive CPU usage from tight polling loops? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Memory leak] At lines 92-112, filter validation creates BooleanTransactionFilter objects - if validation fails after allocation but before error handling, can repeated failed requests cause memory leaks? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Resource leak] At lines 162-163, streams are inserted into active_streams, but if the task panics before reaching line 224's cleanup, are streams leaked permanently? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Resource exhaustion] The MAX_BYTES_PER_BATCH constant at line 23 is 20MB, but with unlimited concurrent streams, can attackers request many streams to exhaust network bandwidth or memory with concurrent 20MB batches? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Input validation bypass] At line 80, the check `starting_version > known_latest_version + 10000` uses a hardcoded buffer of 10000 - can an attacker exploit this by repeatedly querying at exactly known_latest_version + 10000 to bypass intended future version protection? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Filter size bypass] At line 95, `max_transaction_filter_size_bytes` validation is passed to filter creation, but is the size calculated before or after deserialization - can an attacker send compressed filters that expand beyond the limit? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Negative value bypass] At line 115, `batch_size as usize` casts without checking if batch_size could be negative or zero - can negative values cause underflows or zero cause infinite loops? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Default value abuse] At line 117, when batch_size is None, it defaults to 10000 - can an attacker avoid specifying batch_size to bypass any client-side limits and always get maximum batches? (Low)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Missing validation] At line 77, starting_version defaults to known_latest_version when None, but there's no validation that this doesn't conflict with transactions_count - can this cause incorrect ending_version calculations? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: run()] [Input validation] At lines 120-122, ending_version is calculated from transactions_count, but there's no validation that ending_version doesn't exceed u64::MAX or wrap around - can this cause undefined behavior? (High)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [State inconsistency] At lines 197-200, ProcessedRange reports first_version and last_version, but if in_memory_cache returns filtered results, can the reported range include versions that weren't actually sent, misleading clients? (Medium)",
  "[File: aptos-core/ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs] [Function: start_streaming()] [Version skipping] At line 202, next_version is set to `last_processed_version + 1`, but if get_data() returns non-contiguous versions due to filtering, can transactions be skipped without client awareness? (High)"
]