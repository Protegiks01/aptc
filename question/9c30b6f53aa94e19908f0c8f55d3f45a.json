[
  "[File: third_party/move/move-vm/test-utils/src/gas_schedule.rs] [Module-Level: PartialEq] [Comparison] Are CostTable comparisons secure against timing attacks that could leak gas schedule information? (Low)",
  "[File: third_party/move/move-\n\n### Citations\n\n**File:** third_party/move/move-vm/test-utils/src/gas_schedule.rs (L1-949)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module lays out the basic abstract costing schedule for bytecode instructions.\n//!\n//! It is important to note that the cost schedule defined in this file does not track hashing\n//! operations or other native operations; the cost of each native operation will be returned by the\n//! native function itself.\nuse move_binary_format::{\n    errors::{PartialVMError, PartialVMResult},\n    file_format::{\n        Bytecode, CodeOffset, ConstantPoolIndex, FieldHandleIndex, FieldInstantiationIndex,\n        FunctionHandleIndex, FunctionInstantiationIndex, SignatureIndex,\n        StructDefInstantiationIndex, StructDefinitionIndex, StructVariantHandleIndex,\n        StructVariantInstantiationIndex, VariantFieldHandleIndex, VariantFieldInstantiationIndex,\n    },\n    file_format_common::{instruction_key, Opcodes},\n};\nuse move_core_types::{\n    account_address::AccountAddress,\n    function::ClosureMask,\n    gas_algebra::{\n        AbstractMemorySize, GasQuantity, InternalGas, InternalGasPerAbstractMemoryUnit,\n        InternalGasUnit, NumArgs, NumBytes, NumTypeNodes, ToUnit,\n    },\n    identifier::IdentStr,\n    int256,\n    language_storage::ModuleId,\n    vm_status::StatusCode,\n};\nuse move_vm_types::{\n    gas::{DependencyGasMeter, DependencyKind, GasMeter, NativeGasMeter, SimpleInstruction},\n    views::{TypeView, ValueView},\n};\nuse once_cell::sync::Lazy;\nuse serde::{Deserialize, Serialize};\nuse std::ops::{Add, Mul};\n\npub enum GasUnit {}\n\npub type Gas = GasQuantity<GasUnit>;\n\nimpl ToUnit<InternalGasUnit> for GasUnit {\n    const MULTIPLIER: u64 = 1000;\n}\n\n/// The size in bytes for a non-string or address constant on the stack\npub const CONST_SIZE: AbstractMemorySize = AbstractMemorySize::new(16);\n\n/// The size in bytes for a reference on the stack\npub const REFERENCE_SIZE: AbstractMemorySize = AbstractMemorySize::new(8);\n\n/// The size of a struct in bytes\npub const STRUCT_SIZE: AbstractMemorySize = AbstractMemorySize::new(2);\n\n/// For exists checks on data that doesn't exists this is the multiplier that is used.\npub const MIN_EXISTS_DATA_SIZE: AbstractMemorySize = AbstractMemorySize::new(100);\n\n/// The cost tables, keyed by the serialized form of the bytecode instruction.  We use the\n/// serialized form as opposed to the instruction enum itself as the key since this will be the\n/// on-chain representation of bytecode instructions in the future.\n#[derive(Clone, Debug, Serialize, PartialEq, Eq, Deserialize)]\npub struct CostTable {\n    pub instruction_table: Vec<GasCost>,\n}\n\nimpl CostTable {\n    #[inline]\n    pub fn instruction_cost(&self, instr_index: u8) -> &GasCost {\n        debug_assert!(instr_index > 0 && instr_index <= (self.instruction_table.len() as u8));\n        &self.instruction_table[(instr_index - 1) as usize]\n    }\n}\n\n/// The  `GasCost` tracks:\n/// - instruction cost: how much time/computational power is needed to perform the instruction\n/// - memory cost: how much memory is required for the instruction, and storage overhead\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]\npub struct GasCost {\n    pub instruction_gas: u64,\n    pub memory_gas: u64,\n}\n\nimpl GasCost {\n    pub fn new(instruction_gas: u64, memory_gas: u64) -> Self {\n        Self {\n            instruction_gas,\n            memory_gas,\n        }\n    }\n\n    /// Convert a GasCost to a total gas charge in `InternalGas`.\n    #[inline]\n    pub fn total(&self) -> u64 {\n        self.instruction_gas.add(self.memory_gas)\n    }\n}\n\nstatic ZERO_COST_SCHEDULE: Lazy<CostTable> = Lazy::new(zero_cost_schedule);\n\n/// The Move VM implementation of state for gas metering.\n///\n/// Initialize with a `CostTable` and the gas provided to the transaction.\n/// Provide all the proper guarantees about gas metering in the Move VM.\n///\n/// Every client must use an instance of this type to interact with the Move VM.\npub struct GasStatus {\n    cost_table: CostTable,\n    gas_left: InternalGas,\n    charge: bool,\n}\n\nimpl GasStatus {\n    /// Initialize the gas state with metering enabled.\n    ///\n    /// Charge for every operation and fail when there is no more gas to pay for operations.\n    /// This is the instantiation that must be used when executing a user script.\n    pub fn new(cost_table: CostTable, gas_left: Gas) -> Self {\n        Self {\n            gas_left: gas_left.to_unit(),\n            cost_table,\n            charge: true,\n        }\n    }\n\n    /// Initialize the gas state with metering disabled.\n    ///\n    /// It should be used by clients in very specific cases and when executing system\n    /// code that does not have to charge the user.\n    pub fn new_unmetered() -> Self {\n        Self {\n            gas_left: InternalGas::new(0),\n            cost_table: ZERO_COST_SCHEDULE.clone(),\n            charge: false,\n        }\n    }\n\n    /// Return the `CostTable` behind this `GasStatus`.\n    pub fn cost_table(&self) -> &CostTable {\n        &self.cost_table\n    }\n\n    /// Return the gas left.\n    pub fn remaining_gas(&self) -> Gas {\n        self.gas_left.to_unit_round_down()\n    }\n\n    /// Charge a given amount of gas and fail if not enough gas units are left.\n    pub fn deduct_gas(&mut self, amount: InternalGas) -> PartialVMResult<()> {\n        if !self.charge {\n            return Ok(());\n        }\n\n        match self.gas_left.checked_sub(amount) {\n            Some(gas_left) => {\n                self.gas_left = gas_left;\n                Ok(())\n            },\n            None => {\n                self.gas_left = InternalGas::new(0);\n                Err(PartialVMError::new(StatusCode::OUT_OF_GAS))\n            },\n        }\n    }\n\n    fn charge_instr(&mut self, opcode: Opcodes) -> PartialVMResult<()> {\n        self.deduct_gas(\n            self.cost_table\n                .instruction_cost(opcode as u8)\n                .total()\n                .into(),\n        )\n    }\n\n    /// Charge an instruction over data with a given size and fail if not enough gas units are left.\n    fn charge_instr_with_size(\n        &mut self,\n        opcode: Opcodes,\n        size: AbstractMemorySize,\n    ) -> PartialVMResult<()> {\n        // Make sure that the size is always non-zero\n        let size = std::cmp::max(1.into(), size);\n        debug_assert!(size > 0.into());\n        self.deduct_gas(\n            InternalGasPerAbstractMemoryUnit::new(\n                self.cost_table.instruction_cost(opcode as u8).total(),\n            )\n            .mul(size),\n        )\n    }\n\n    pub fn set_metering(&mut self, enabled: bool) {\n        self.charge = enabled\n    }\n}\n\nimpl DependencyGasMeter for GasStatus {\n    fn charge_dependency(\n        &mut self,\n        _kind: DependencyKind,\n        _addr: &AccountAddress,\n        _name: &IdentStr,\n        _size: NumBytes,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n}\n\nimpl NativeGasMeter for GasStatus {\n    fn legacy_gas_budget_in_native_context(&self) -> InternalGas {\n        self.gas_left\n    }\n\n    fn charge_native_execution(&mut self, _amount: InternalGas) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn use_heap_memory_in_native_context(&mut self, _amount: u64) -> PartialVMResult<()> {\n        Ok(())\n    }\n}\n\nimpl GasMeter for GasStatus {\n    fn balance_internal(&self) -> InternalGas {\n        self.gas_left\n    }\n\n    /// Charge an instruction and fail if not enough gas units are left.\n    fn charge_simple_instr(&mut self, instr: SimpleInstruction) -> PartialVMResult<()> {\n        self.charge_instr(instr.to_opcode())\n    }\n\n    fn charge_br_false(&mut self, _target_offset: Option<CodeOffset>) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::BR_FALSE)\n    }\n\n    fn charge_br_true(&mut self, _target_offset: Option<CodeOffset>) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::BR_TRUE)\n    }\n\n    fn charge_branch(&mut self, _target_offset: CodeOffset) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::BRANCH)\n    }\n\n    fn charge_pop(&mut self, _popped_val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::POP)\n    }\n\n    fn charge_native_function(\n        &mut self,\n        amount: InternalGas,\n        _ret_vals: Option<impl ExactSizeIterator<Item = impl ValueView>>,\n    ) -> PartialVMResult<()> {\n        self.deduct_gas(amount)\n    }\n\n    fn charge_native_function_before_execution(\n        &mut self,\n        _ty_args: impl ExactSizeIterator<Item = impl TypeView>,\n        _args: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn charge_call(\n        &mut self,\n        _module_id: &ModuleId,\n        _func_name: &str,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n        _num_locals: NumArgs,\n    ) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::CALL, (args.len() as u64 + 1).into())\n    }\n\n    fn charge_call_generic(\n        &mut self,\n        _module_id: &ModuleId,\n        _func_name: &str,\n        ty_args: impl ExactSizeIterator<Item = impl TypeView>,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n        _num_locals: NumArgs,\n    ) -> PartialVMResult<()> {\n        self.charge_instr_with_size(\n            Opcodes::CALL_GENERIC,\n            ((ty_args.len() + args.len() + 1) as u64).into(),\n        )\n    }\n\n    fn charge_ld_const(&mut self, size: NumBytes) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::LD_CONST, u64::from(size).into())\n    }\n\n    fn charge_ld_const_after_deserialization(\n        &mut self,\n        _val: impl ValueView,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn charge_copy_loc(&mut self, val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::COPY_LOC, val.legacy_abstract_memory_size())\n    }\n\n    fn charge_move_loc(&mut self, val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::MOVE_LOC, val.legacy_abstract_memory_size())\n    }\n\n    fn charge_store_loc(&mut self, val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::ST_LOC, val.legacy_abstract_memory_size())\n    }\n\n    fn charge_pack(\n        &mut self,\n        is_generic: bool,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        let field_count = AbstractMemorySize::new(args.len() as u64);\n        self.charge_instr_with_size(\n            if is_generic {\n                Opcodes::PACK_GENERIC\n            } else {\n                Opcodes::PACK\n            },\n            args.fold(field_count, |acc, val| {\n                acc + val.legacy_abstract_memory_size()\n            }),\n        )\n    }\n\n    fn charge_unpack(\n        &mut self,\n        is_generic: bool,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        let field_count = AbstractMemorySize::new(args.len() as u64);\n        self.charge_instr_with_size(\n            if is_generic {\n                Opcodes::UNPACK_GENERIC\n            } else {\n                Opcodes::UNPACK\n            },\n            args.fold(field_count, |acc, val| {\n                acc + val.legacy_abstract_memory_size()\n            }),\n        )\n    }\n\n    fn charge_pack_closure(\n        &mut self,\n        is_generic: bool,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        let field_count = AbstractMemorySize::new(args.len() as u64);\n        self.charge_instr_with_size(\n            if is_generic {\n                Opcodes::PACK_CLOSURE_GENERIC\n            } else {\n                Opcodes::PACK_CLOSURE\n            },\n            args.fold(field_count, |acc, val| {\n                acc + val.legacy_abstract_memory_size()\n            }),\n        )\n    }\n\n    fn charge_read_ref(&mut self, ref_val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::READ_REF, ref_val.legacy_abstract_memory_size())\n    }\n\n    fn charge_write_ref(\n        &mut self,\n        new_val: impl ValueView,\n        _old_val: impl ValueView,\n    ) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::WRITE_REF, new_val.legacy_abstract_memory_size())\n    }\n\n    fn charge_eq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(\n            Opcodes::EQ,\n            lhs.legacy_abstract_memory_size() + rhs.legacy_abstract_memory_size(),\n        )\n    }\n\n    fn charge_neq(&mut self, lhs: impl ValueView, rhs: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(\n            Opcodes::NEQ,\n            lhs.legacy_abstract_memory_size() + rhs.legacy_abstract_memory_size(),\n        )\n    }\n\n    fn charge_load_resource(\n        &mut self,\n        _addr: AccountAddress,\n        _ty: impl TypeView,\n        _val: Option<impl ValueView>,\n        _bytes_loaded: NumBytes,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn charge_borrow_global(\n        &mut self,\n        is_mut: bool,\n        is_generic: bool,\n        _ty: impl TypeView,\n        is_success: bool,\n    ) -> PartialVMResult<()> {\n        use Opcodes::*;\n\n        if is_success {\n            let op = match (is_mut, is_generic) {\n                (false, false) => IMM_BORROW_GLOBAL,\n                (false, true) => IMM_BORROW_GLOBAL_GENERIC,\n                (true, false) => MUT_BORROW_GLOBAL,\n                (true, true) => MUT_BORROW_GLOBAL_GENERIC,\n            };\n\n            self.charge_instr_with_size(op, REFERENCE_SIZE)?;\n        }\n\n        Ok(())\n    }\n\n    fn charge_exists(\n        &mut self,\n        is_generic: bool,\n        _ty: impl TypeView,\n        // TODO(Gas): see if we can get rid of this param\n        exists: bool,\n    ) -> PartialVMResult<()> {\n        use Opcodes::*;\n\n        let op = if is_generic { EXISTS_GENERIC } else { EXISTS };\n        self.charge_instr_with_size(\n            op,\n            if exists {\n                REFERENCE_SIZE\n            } else {\n                MIN_EXISTS_DATA_SIZE\n            },\n        )\n    }\n\n    fn charge_move_from(\n        &mut self,\n        is_generic: bool,\n        _ty: impl TypeView,\n        val: Option<impl ValueView>,\n    ) -> PartialVMResult<()> {\n        use Opcodes::*;\n\n        if let Some(val) = val {\n            let op = if is_generic {\n                MOVE_FROM_GENERIC\n            } else {\n                MOVE_FROM\n            };\n\n            self.charge_instr_with_size(op, val.legacy_abstract_memory_size())?;\n        }\n\n        Ok(())\n    }\n\n    fn charge_move_to(\n        &mut self,\n        is_generic: bool,\n        _ty: impl TypeView,\n        val: impl ValueView,\n        is_success: bool,\n    ) -> PartialVMResult<()> {\n        use Opcodes::*;\n\n        let op = if is_generic { MOVE_TO_GENERIC } else { MOVE_TO };\n\n        if is_success {\n            self.charge_instr_with_size(op, val.legacy_abstract_memory_size())?;\n        }\n\n        Ok(())\n    }\n\n    fn charge_vec_pack<'a>(\n        &mut self,\n        args: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::VEC_PACK, (args.len() as u64).into())\n    }\n\n    fn charge_vec_len(&mut self) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::VEC_LEN)\n    }\n\n    fn charge_vec_borrow(&mut self, is_mut: bool) -> PartialVMResult<()> {\n        use Opcodes::*;\n\n        self.charge_instr(\n            if is_mut {\n                VEC_MUT_BORROW\n            } else {\n                VEC_IMM_BORROW\n            },\n        )\n    }\n\n    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {\n        self.charge_instr_with_size(Opcodes::VEC_PUSH_BACK, val.legacy_abstract_memory_size())\n    }\n\n    fn charge_vec_pop_back(&mut self, _val: Option<impl ValueView>) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::VEC_POP_BACK)\n    }\n\n    fn charge_vec_unpack(\n        &mut self,\n        expect_num_elements: NumArgs,\n        _elems: impl ExactSizeIterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        self.charge_instr_with_size(\n            Opcodes::VEC_PUSH_BACK,\n            u64::from(expect_num_elements).into(),\n        )\n    }\n\n    fn charge_vec_swap(&mut self) -> PartialVMResult<()> {\n        self.charge_instr(Opcodes::VEC_SWAP)\n    }\n\n    fn charge_drop_frame(\n        &mut self,\n        _locals: impl Iterator<Item = impl ValueView>,\n    ) -> PartialVMResult<()> {\n        Ok(())\n    }\n\n    fn charge_create_ty(&mut self, _num_nodes: NumTypeNodes) -> PartialVMResult<()> {\n        Ok(())\n    }\n}\n\npub fn new_from_instructions(mut instrs: Vec<(Bytecode, GasCost)>) -> CostTable {\n    instrs.sort_by_key(|cost| instruction_key(&cost.0));\n\n    if cfg!(debug_assertions) {\n        let mut instructions_covered = 0;\n        for (index, (instr, _)) in instrs.iter().enumerate() {\n            let key = instruction_key(instr);\n            if index == (key - 1) as usize {\n                instructions_covered += 1;\n            }\n        }\n        debug_assert!(\n            instructions_covered == Bytecode::VARIANT_COUNT,"
]