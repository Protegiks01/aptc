[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_term()] [Paren expression overload] LParen handles unit type, annotations, casts, tests, and tuples (lines 1268-1302) - can ambiguity in these cases cause incorrect AST generation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_cast_or_test_exp()] [Colon annotation bypass] allow_colon_exp flag controls : vs as/is - can this flag be manipulated to allow type annotations in contexts where they should be prohibited? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_cast_or_test_exp()] [Test expression injection] The 'is' test expression (lines 1340-1352) - can this be used to bypass type checking by testing against invalid type combinations? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_control_exp()] [Label scope escape] Labeled loops (lines 1430-1440) - can label parsing allow break/continue to escape their proper scope and jump to outer contexts? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_control_exp()] [If-else ambiguity] Dangling else problem - can nested if-else chains be parsed ambiguously, associating else with wrong if? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_control_exp()] [While spec injection] Spec blocks in while loops (line 1462) - can spec code affect runtime behavior or be exploited for side effects? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_optional_label()] [Label version bypass] Label parsing requires LanguageVersion::V2_1 (lines 1497-1502) - can version checks be bypassed to use labels in older language versions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_for_loop()] [For loop desugaring exploit] For loop transforms to complex while loop (lines 1529-1711) - can this transformation introduce vulnerabilities not present in original source? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_for_loop()] [Iterator mutation] FOR_LOOP_UPDATE_ITER_FLAG variable (line 32) - can this internal variable name collide with user variables causing undefined behavior? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_for_loop()] [Upper bound evaluation] FOR_LOOP_UPPER_BOUND_VALUE (line 33) - is upper bound evaluated once or multiple times, and can this be exploited for side effects? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_for_loop()] [Integer overflow in loop] For loop with i < upper_bound - can integer overflow in iterator or bounds cause infinite loops or DoS? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_match_exp()] [Match vs call ambiguity] Match parsing is context-dependent on match() syntax (lines 1717-1789) - can function calls to 'match' be confused with match expressions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_match_exp()] [Match fallback bypass] When match() is interpreted as function call, can remaining tokens be misparsed leading to incorrect call arguments? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_match_arms()] [Unreachable pattern bypass] Does parsing enforce that wildcard patterns come last, or can unreachable patterns be added that never match? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_match_arms()] [Guard condition abuse] Match arm guards (lines 1799-1802) - can complex guard expressions cause performance issues or bypass pattern matching semantics? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_name_exp()] [Macro call confusion] Exclaim token (!) for macros (lines 1838-1841) - can macro calls be confused with regular calls to bypass validation or inject unexpected code? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_name_exp()] [Type args whitespace exploit] Type arguments only parsed if no whitespace after name (lines 1844-1848) - can this whitespace sensitivity be exploited for parser confusion? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_name_exp()] [Pack vs call ambiguity] LBrace for struct pack vs LParen for call - can ambiguous syntax cause wrong interpretation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: at_end_of_exp()] [Expression boundary confusion] The end-of-expression tokens (lines 1900-1906) - can missing tokens cause expressions to extend beyond intended boundaries? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: at_start_of_exp()] [Expression start detection bypass] Can tokens be injected that satisfy at_start_of_exp() but aren't valid expression starts, causing parser errors or crashes? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_lambda()] [Lambda capture exploit] LambdaCaptureKind (move/copy) affects closure semantics (lines 1940-2010) - can capture kind be manipulated to access variables after they've been moved? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_lambda()] [Lambda spec abuse] Spec blocks on lambdas (lines 1955-1969) require V2_2 - can spec code in lambdas be exploited for unintended side effects? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_exp()] [Quantifier injection] Quantifier parsing (forall/exists/choose) at lines 2012 - can spec-only constructs appear in regular code through parser confusion? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: parse_exp()] [Assignment operator bypass] Op-equal operators (+=, -=, etc.) require V2_1 (lines 2034-2039) - can these be used in older versions through parser manipulation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/syntax.rs] [Function: op_equal_to_binop()] [Operator precedence exploit] Can op-equal operators have incorrect precedence compared to their binary equivalents, causing unexpected evaluation order? (Medium)"
]