[
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Immediate vs transitive dependencies] immediate_dependencies_iter() (line 386) only walks immediate deps - but comment on line 336-344 mentions transitive friends are NOT loaded - can this create verification gaps where friend modules aren't checked? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Dependency version mismatch] Dependencies are resolved by ModuleId (line 387) without version - can different versions of the same module coexist, causing type confusion when modules expect different versions? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Diamond dependency] For diamond dependency pattern (A depends on B and C, both depend on D), is D verified once or multiple times? Can repeated verification waste resources? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Self-dependency] What if a malicious module lists itself as a dependency? Would visited.insert() catch this before recursion? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Dependency ordering determinism] Dependencies are iterated in immediate_dependencies_iter() order - is this order deterministic across all validators? Can non-deterministic ordering cause verification divergence? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Implementation: ModuleStorage] [Generic type bounds] The trait bounds (lines 173-189) require specific associated types - but can an attacker implement a custom type satisfying bounds that breaks safety assumptions (e.g., malicious Extension type)? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Implementation: ModuleStorage] [Version type safety] Version is bound by Clone + Default + Ord (line 189) - but what prevents an attacker from implementing a Version type where Ord ordering is malicious (always returns Equal)? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Module type inference] Module is a generic Verified type (line 347) - can type inference bugs cause wrong Module type to be cached, leading to type confusion during execution? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Implementation: ModuleStorage] [Extension trait abuse] Extension must implement WithBytes + WithSize + WithHash (line 188) - can a malicious extension return inconsistent values (e.g., different hashes on repeated calls) to cause verification inconsistencies? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Recursion depth] Recursive dependency verification has no visible depth limit - can an attacker create a dependency chain of depth 10,000+ causing stack overflow? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Verified dependencies vector] verified_dependencies vec (line 385) grows with each dependency - for a module with 1000+ dependencies, can this single allocation exhaust available memory? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Implementation: ModuleStorage] [Arc reference counting] Heavy use of Arc::clone() throughout - can cyclic Arc references between cached modules prevent garbage collection and leak memory? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_module_bytes()] [Bytes clone] bytes().clone() (line 208) creates a full copy - for maximum size modules (potentially 1MB+), can repeated clones cause memory spikes and OOM? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: get_serialization_data()] [Captured layouts clone] captured_layouts are cloned (line 575) - if captures contain deeply nested structures, can clone recursion cause stack overflow? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_lazily_verified_module()] [Linking check skip] build_verified_module_skip_linking_checks() (line 321) explicitly skips linking - so how are dependency compatibility issues detected? Can ABI incompatibilities only surface at runtime? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Local vs linking verification] Local verification (lines 377-381) is separate from linking checks (lines 418-419) - can a module pass local verification but fail linking due to malicious dependency manipulation? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_eagerly_verified_module()] [Already verified trust] If is_verified() returns true (line 247), verification is skipped - but who sets this flag? Can a race condition cause a module to be marked verified before actual verification completes? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: visit_dependencies_and_verify()] [Build linking checks] build_verified_module_with_linking_checks() (lines 418-419) takes verified_dependencies - but are these dependencies themselves guaranteed to have passed linking checks? Or only local verification? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_lazily_verified_module()] [Lazy to eager gap] Lazy verification (lines 295-329) doesn't check dependencies - if a module is lazily verified then later used as a dependency for eager verification, is linking rechecked? (High)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_eagerly_verified_module()] [Timer only on cache miss] VM_TIMER is only started on cache miss (line 252) - can attackers use timing analysis to determine which modules are cached, leaking information about validator state? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Function: unmetered_get_lazily_verified_module()] [Verification timing] Timer is used (line 308) - but verification time varies with module complexity - can timing attacks reveal details about module bytecode to infer private logic? (Low)",
  "[File: third_party/move/move-vm/runtime/src/storage/module_storage.rs] [Implementation: ModuleStorage] [Cache timing side channel] All unmetered operations have different latencies based on cache state - can timing side channels allow attackers to map the entire cached module set? (Low)"
]