[
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: ShellSafeName] [Regex bypass] Can an attacker craft names with Unicode normalization tricks (e.g., homoglyphs, zero-width characters) that pass the PATTERN regex but execute malicious commands when passed to shell adapters, leading to remote code execution on backup nodes? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: ShellSafeName::sanitize()] [Command injection] Does the regex pattern \\\\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\\\\z properly prevent all shell metacharacters, or can attackers use edge cases like '..', './', or '--' sequences to escape backup directories and overwrite critical system files? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: ShellSafeName] [Length validation bypass] The pattern enforces {2,126} characters after the first, meaning total length 3-127 bytes. Can attackers exploit maximum length names (127 chars) to cause buffer overflows in downstream command adapters or file system operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: ShellSafeName::try_from()] [Race condition] Between sanitize() validation at line 66 and actual usage, can an attacker exploit TOCTOU (time-of-check-time-of-use) race conditions by modifying the underlying String after validation but before shell command execution? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Const: ShellSafeName::PATTERN] [Regex DoS] Can an attacker provide carefully crafted input strings that cause catastrophic backtracking in the Regex engine, leading to denial of service during backup operations and preventing disaster recovery? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: ShellSafeName::from_str()] [Memory exhaustion] Does from_str() properly validate input length BEFORE allocating String memory, or can attackers trigger OOM by sending gigabyte-sized strings that are rejected only after allocation? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Impl: Deref for ShellSafeName] [Unauthorized access] The Deref implementation at line 78-84 exposes the inner String directly - can attackers exploit this to bypass validation by obtaining mutable references and modifying the inner string after construction? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Static: Lazy<Regex>] [Initialization race] The Lazy::new() at line 56 initializes the regex pattern - can concurrent calls to sanitize() during node startup cause race conditions where the regex is used before full initialization, accepting invalid names? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: ShellSafeName] [Case sensitivity exploit] The pattern allows both uppercase and lowercase, but file systems may be case-insensitive (Windows, macOS) - can attackers create collisions between 'Backup' and 'backup' to overwrite legitimate backups? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: ShellSafeName::sanitize()] [Special name collision] Does sanitize() reject reserved file system names like 'CON', 'PRN', 'AUX', 'NUL' on Windows, or can these cause backup operations to fail or write to special devices? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: TextLine::new()] [Newline injection] The validation at line 111 checks for \\\\n and \\\\r, but does it handle all Unicode line separators (U+2028, U+2029, U+0085) that could break metadata file parsing and cause state corruption? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: TextLine] [Metadata corruption] After validation, line 113 appends '\\\\n' to every TextLine - can attackers exploit metadata files with missing or double newlines to cause parsing errors during restore, leading to permanent data loss? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: TextLine::new()] [NULL byte injection] Does the validation reject NULL bytes (\\\\0) that could truncate metadata entries in C-based file system operations, causing incomplete backup manifests and unrecoverable state? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Impl: AsRef<str> for TextLine] [Memory disclosure] The AsRef implementation at line 118 returns the string INCLUDING the appended newline - can this cause off-by-one errors in consumers that don't expect trailing newlines, leaking adjacent memory? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: TextLine] [UTF-8 validation bypass] Does TextLine::new() validate that the input is valid UTF-8, or can attackers inject invalid UTF-8 sequences that cause panics in downstream string operations during restore? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Function: TextLine::new()] [Control character injection] Beyond newlines, are other control characters (tabs, backspace, escape sequences) validated? Can these manipulate terminal output during backup/restore operations to hide malicious activity? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Struct: TextLine] [Length limit missing] Unlike ShellSafeName (127 char limit), TextLine has no explicit length limit - can attackers create gigabyte-sized metadata lines causing memory exhaustion during list_metadata_files()? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_backup()] [Name collision attack] If multiple concurrent backup operations call create_backup() with the same name, does the implementation guarantee atomicity, or can race conditions cause backup files to intermix, corrupting both backups? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_backup()] [Resource exhaustion] Can an attacker repeatedly call create_backup() with different names to create unlimited directories/buckets, exhausting storage space and preventing legitimate backups needed for disaster recovery? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_backup()] [BackupHandle manipulation] The returned BackupHandle is a String with no validation - can attackers manipulate this handle in subsequent create_for_write() calls to write files outside the backup directory via path traversal? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Type alias: BackupHandle] [Handle reuse vulnerability] Are BackupHandles unique per backup, or can an attacker reuse a handle from a previous backup to overwrite or corrupt archived historical data, breaking blockchain immutability guarantees? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_backup()] [Incomplete backup cleanup] If create_backup() partially succeeds but fails during directory creation, are partial directories cleaned up, or do they accumulate causing storage leaks and potential name collision attacks? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_for_write()] [Path traversal] The backup_handle parameter is untrusted input from create_backup() - can attackers craft handles like '../../../etc/passwd' to write arbitrary files outside the backup directory, achieving code execution? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_for_write()] [FileHandle forgery] The returned FileHandle is stored in manifests and used for restoration - can attackers forge FileHandles pointing to sensitive files (private keys, wallet files) to exfiltrate data during restore operations? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/storage/mod.rs] [Trait method: BackupStorage::create_for_write()] [AsyncWrite safety] The returned AsyncWrite is Send + Unpin - can concurrent writes to the same file handle cause interleaved data corruption, making backups unrestorable and causing permanent state loss? (Critical)"
]