[
  "[File: aptos-move/framework/move-stdlib/src/natives/result.rs] [Edge Case] [Nested results] Do result unwrap operations handle Result<Result<T>> correctly? (Low)",
  "[File: aptos-move/framework/move-stdlib/src/natives/result.rs] [Edge Case] [Empty Ok value] Does ok_result properly handle unit type or zero-sized values? (Low)",
  "[File: aptos-move/framework/move-stdlib/src/natives/bcs\n\n### Citations\n\n**File:** aptos-move/framework/move-stdlib/src/lib.rs (L1-8)\n```rust\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\npub mod natives;\n```\n\n**File:** aptos-move/framework/move-stdlib/src/natives/bcs.rs (L1-295)\n```rust\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse aptos_gas_schedule::gas_params::natives::move_stdlib::*;\nuse aptos_native_interface::{\n    safely_pop_arg, RawSafeNative, SafeNativeBuilder, SafeNativeContext, SafeNativeError,\n    SafeNativeResult,\n};\nuse move_core_types::{\n    account_address::AccountAddress,\n    gas_algebra::{NumBytes, NumTypeNodes},\n    int256,\n    language_storage::{OPTION_NONE_TAG, OPTION_SOME_TAG},\n    value::{MoveStructLayout, MoveTypeLayout},\n    vm_status::{sub_status::NFE_BCS_SERIALIZATION_FAILURE, StatusCode},\n};\nuse move_vm_runtime::native_functions::NativeFunction;\nuse move_vm_types::{\n    loaded_data::runtime_types::Type,\n    natives::function::{PartialVMError, PartialVMResult},\n    value_serde::ValueSerDeContext,\n    values::{values_impl::Reference, Struct, Value},\n};\nuse smallvec::{smallvec, SmallVec};\nuse std::collections::VecDeque;\n\npub fn create_option_u64(enum_option_enabled: bool, value: Option<u64>) -> Value {\n    if enum_option_enabled {\n        match value {\n            Some(value) => Value::struct_(Struct::pack_variant(OPTION_SOME_TAG, vec![Value::u64(\n                value,\n            )])),\n            None => Value::struct_(Struct::pack_variant(OPTION_NONE_TAG, vec![])),\n        }\n    } else {\n        Value::struct_(Struct::pack(vec![Value::vector_u64(value)]))\n    }\n}\n\n/***************************************************************************************************\n * native fun to_bytes\n *\n *   gas cost: size_of(val_type) * input_unit_cost +        | get type layout\n *             size_of(val) * input_unit_cost +             | serialize value\n *             max(size_of(output), 1) * output_unit_cost\n *\n *             If any of the first two steps fails, a partial cost + an additional failure_cost\n *             will be charged.\n *\n **************************************************************************************************/\n/// Rust implementation of Move's `native public fun to_bytes<T>(&T): vector<u8>`\nfn native_to_bytes(\n    context: &mut SafeNativeContext,\n    ty_args: &[Type],\n    mut args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(ty_args.len() == 1);\n    debug_assert!(args.len() == 1);\n\n    let ref_to_val = safely_pop_arg!(args, Reference);\n    let arg_type = &ty_args[0];\n\n    let layout = if context.get_feature_flags().is_lazy_loading_enabled() {\n        // With lazy loading, propagate the error directly. This is because errors here are likely\n        // from metering, so we should not remap them in any way. Note that makes it possible to\n        // fail on constructing a very deep / large layout and not be charged, but this is already\n        // the case for regular execution, so we keep it simple. Also, charging more gas after\n        // out-of-gas failure in layout construction does not make any sense.\n        //\n        // Example:\n        //   - Constructing layout runs into dependency limit.\n        //   - We cannot do `context.charge(BCS_TO_BYTES_FAILURE)?;` because then we can end up in\n        //     the state where out of gas and dependency limit are hit at the same time.\n        context.type_to_type_layout(arg_type)?\n    } else {\n        match context.type_to_type_layout(arg_type) {\n            Ok(layout) => layout,\n            Err(_) => {\n                context.charge(BCS_TO_BYTES_FAILURE)?;\n                return Err(SafeNativeError::Abort {\n                    abort_code: NFE_BCS_SERIALIZATION_FAILURE,\n                });\n            },\n        }\n    };\n\n    // TODO(#14175): Reading the reference performs a deep copy, and we can\n    //               implement it in a more efficient way.\n    let val = ref_to_val.read_ref()?;\n\n    let function_value_extension = context.function_value_extension();\n    let max_value_nest_depth = context.max_value_nest_depth();\n    let serialized_value = match ValueSerDeContext::new(max_value_nest_depth)\n        .with_legacy_signer()\n        .with_func_args_deserialization(&function_value_extension)\n        .serialize(&val, &layout)?\n    {\n        Some(serialized_value) => serialized_value,\n        None => {\n            context.charge(BCS_TO_BYTES_FAILURE)?;\n            return Err(SafeNativeError::Abort {\n                abort_code: NFE_BCS_SERIALIZATION_FAILURE,\n            });\n        },\n    };\n    context\n        .charge(BCS_TO_BYTES_PER_BYTE_SERIALIZED * NumBytes::new(serialized_value.len() as u64))?;\n\n    Ok(smallvec![Value::vector_u8(serialized_value)])\n}\n\n/***************************************************************************************************\n * native fun serialized_size\n *\n *   gas cost: size_of(output)\n *\n *   If the getting the type layout or serialization results in error, a special failure\n *   cost is charged.\n *\n **************************************************************************************************/\nfn native_serialized_size(\n    context: &mut SafeNativeContext,\n    ty_args: &[Type],\n    mut args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(ty_args.len() == 1);\n    debug_assert!(args.len() == 1);\n\n    context.charge(BCS_SERIALIZED_SIZE_BASE)?;\n\n    let reference = safely_pop_arg!(args, Reference);\n    let ty = &ty_args[0];\n\n    let serialized_size = match serialized_size_impl(context, reference, ty) {\n        Ok(serialized_size) => serialized_size as u64,\n        Err(_) => {\n            context.charge(BCS_SERIALIZED_SIZE_FAILURE)?;\n\n            // Re-use the same abort code as bcs::to_bytes.\n            return Err(SafeNativeError::Abort {\n                abort_code: NFE_BCS_SERIALIZATION_FAILURE,\n            });\n        },\n    };\n    context.charge(BCS_SERIALIZED_SIZE_PER_BYTE_SERIALIZED * NumBytes::new(serialized_size))?;\n\n    Ok(smallvec![Value::u64(serialized_size)])\n}\n\nfn serialized_size_impl(\n    context: &mut SafeNativeContext,\n    reference: Reference,\n    ty: &Type,\n) -> PartialVMResult<usize> {\n    // TODO(#14175): Reading the reference performs a deep copy, and we can\n    //               implement it in a more efficient way.\n    let value = reference.read_ref()?;\n    let ty_layout = context.type_to_type_layout(ty)?;\n\n    let function_value_extension = context.function_value_extension();\n    let max_value_nest_depth = context.max_value_nest_depth();\n    ValueSerDeContext::new(max_value_nest_depth)\n        .with_legacy_signer()\n        .with_func_args_deserialization(&function_value_extension)\n        .with_delayed_fields_serde()\n        .serialized_size(&value, &ty_layout)\n}\n\nfn native_constant_serialized_size(\n    context: &mut SafeNativeContext,\n    ty_args: &[Type],\n    _args: VecDeque<Value>,\n) -> SafeNativeResult<SmallVec<[Value; 1]>> {\n    debug_assert!(ty_args.len() == 1);\n\n    context.charge(BCS_CONSTANT_SERIALIZED_SIZE_BASE)?;\n\n    let ty = &ty_args[0];\n    let ty_layout = context.type_to_type_layout(ty)?;\n\n    let (visited_count, serialized_size_result) = constant_serialized_size(&ty_layout);\n    context\n        .charge(BCS_CONSTANT_SERIALIZED_SIZE_PER_TYPE_NODE * NumTypeNodes::new(visited_count))?;\n\n    let enum_option_enabled = context.get_feature_flags().is_enum_option_enabled();\n    let result = match serialized_size_result {\n        Ok(value) => create_option_u64(enum_option_enabled, value.map(|v| v as u64)),\n        Err(_) => {\n            context.charge(BCS_SERIALIZED_SIZE_FAILURE)?;\n\n            // Re-use the same abort code as bcs::to_bytes.\n            return Err(SafeNativeError::Abort {\n                abort_code: NFE_BCS_SERIALIZATION_FAILURE,\n            });\n        },\n    };\n\n    Ok(smallvec![result])\n}\n\n/// If given type has a constant serialized size (irrespective of the instance), it returns the serialized\n/// size in bytes any value would have.\n/// Otherwise it returns None.\n/// First element of the returned tuple represents number of visited nodes, used to charge gas.\nfn constant_serialized_size(ty_layout: &MoveTypeLayout) -> (u64, PartialVMResult<Option<usize>>) {\n    let mut visited_count = 1;\n    let bcs_size_result = match ty_layout {\n        MoveTypeLayout::Bool => bcs::serialized_size(&false).map(Some),\n        MoveTypeLayout::U8 => bcs::serialized_size(&0u8).map(Some),\n        MoveTypeLayout::U16 => bcs::serialized_size(&0u16).map(Some),\n        MoveTypeLayout::U32 => bcs::serialized_size(&0u32).map(Some),\n        MoveTypeLayout::U64 => bcs::serialized_size(&0u64).map(Some),\n        MoveTypeLayout::U128 => bcs::serialized_size(&0u128).map(Some),\n        MoveTypeLayout::U256 => bcs::serialized_size(&int256::U256::ZERO).map(Some),\n        MoveTypeLayout::I8 => bcs::serialized_size(&0i8).map(Some),\n        MoveTypeLayout::I16 => bcs::serialized_size(&0i16).map(Some),\n        MoveTypeLayout::I32 => bcs::serialized_size(&0i32).map(Some),\n        MoveTypeLayout::I64 => bcs::serialized_size(&0i64).map(Some),\n        MoveTypeLayout::I128 => bcs::serialized_size(&0i128).map(Some),\n        MoveTypeLayout::I256 => bcs::serialized_size(&int256::I256::ZERO).map(Some),\n        MoveTypeLayout::Address => bcs::serialized_size(&AccountAddress::ZERO).map(Some),\n        // signer's size is VM implementation detail, and can change at will.\n        MoveTypeLayout::Signer => Ok(None),\n        // vectors have no constant size\n        MoveTypeLayout::Vector(_) => Ok(None),\n        // enums and functions have no constant size\n        MoveTypeLayout::Struct(\n            MoveStructLayout::RuntimeVariants(_) | MoveStructLayout::WithVariants(_),\n        )\n        | MoveTypeLayout::Function => Ok(None),\n        MoveTypeLayout::Struct(MoveStructLayout::Runtime(fields)) => {\n            let mut total = Some(0);\n            for field in fields {\n                let (cur_visited_count, cur) = constant_serialized_size(field);\n                visited_count += cur_visited_count;\n                match cur {\n                    Err(e) => return (visited_count, Err(e)),\n                    Ok(Some(cur_value)) => total = total.map(|v| v + cur_value),\n                    Ok(None) => {\n                        total = None;\n                        break;\n                    },\n                }\n            }\n            Ok(total)\n        },\n        MoveTypeLayout::Struct(MoveStructLayout::WithFields(_))\n        | MoveTypeLayout::Struct(MoveStructLayout::WithTypes { .. }) => {\n            return (\n                visited_count,\n                Err(\n                    PartialVMError::new(StatusCode::VALUE_SERIALIZATION_ERROR).with_message("
]