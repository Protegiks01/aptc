[
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_manifest()] [Root hash mismatch] The root_hash from transaction_info is written to manifest without verifying it matches the actual state tree - can this lead to accepting corrupted state snapshots? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_manifest()] [Signature validation bypass] The LedgerInfoWithSignatures is deserialized but not validated before being written - can an attacker provide unsigned or incorrectly signed ledger info to corrupt backups? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::get_version_for_epoch_ending()] [Epoch spoofing] Can an attacker provide fake epoch ending ledger info for epoch + 1 that causes the backup to use an incorrect version number, breaking restore compatibility? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::new()] [Uninitialized version] The version field starts as None and is only set in run_impl() - can methods accessing version() be called before initialization causing unwrap panics? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::get_version_for_epoch_ending()] [Epoch boundary attack] Can an attacker request epoch ending for epoch u64::MAX causing integer overflow when computing epoch + 1, leading to incorrect version resolution? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::backup_name()] [Name collision] The backup name format 'state_epoch_{}_ver_{}' could have collisions if multiple backups run concurrently for the same epoch - can this cause file overwrites and data loss? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::get_version_for_epoch_ending()] [Missing ledger info] When no epoch ending ledger info is found, can this cause the backup to proceed with version 0 or panic, breaking the backup process? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_manifest()] [Version inconsistency] Can the manifest be written with a different version than the chunks if self.version is modified between chunk writes and manifest creation? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_chunk()] [Atomic write violation] The chunk file write and proof file write are separate operations - can a crash between them leave partial data that corrupts the backup? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_chunk()] [File handle leak] If write_all() succeeds but shutdown() fails, is the file handle properly closed or does it leak causing resource exhaustion? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_manifest()] [Manifest corruption] The manifest is written as JSON while proofs are BCS - can JSON serialization inconsistencies cause the manifest to be unreadable during restore? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_manifest()] [Metadata write race] The metadata line is saved after manifest - can a crash between these operations cause the manifest to be written but not registered in metadata? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::run_impl()] [Backup handle security] The create_backup_with_random_suffix() ensures unique names, but can an attacker predict the random suffix to overwrite or tamper with in-progress backups? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_chunk()] [Path traversal] The chunk_name() and chunk_proof_name() use ShellSafeName, but can specially crafted first_idx/last_idx values create paths that escape the backup directory? (Low)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::record_stream()] [Memory exhaustion] The CHUNK_SIZE of 100,000 records per chunk combined with concurrent_data_requests can cause massive memory usage - can an attacker trigger OOM by requesting backups with minimal max_chunk_size? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::run_impl()] [Chunk accumulation] The chunks vector accumulates all StateSnapshotChunk objects in memory - can backups of huge state trees exhaust memory before manifest is written? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: send_records_inner()] [Network starvation] The backup service client streams records continuously - can a slow or malicious backup service cause the backup process to hang indefinitely waiting for records? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::record_stream()] [Descriptor exhaustion] Each chunk stream creates new tokio tasks and channels - can the concurrency settings cause file descriptor or task handle exhaustion? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_chunk()] [Disk space exhaustion] No checks for available disk space before writing chunks - can a backup operation fill the disk causing node crashes or data corruption? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: ChunkerState::next_full_chunk()] [Boundary manipulation] The should_cut_chunk() logic determines chunk boundaries - can an attacker manipulate record sizes to force tiny chunks that create excessive chunk overhead and slow restores? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: ChunkerState::next_full_chunk()] [Key ordering attack] Can an attacker provide records with non-monotonic StateKey hashes to break chunk ordering assumptions and corrupt the manifest's first_key/last_key fields? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: ChunkerState::next_full_chunk()] [Chunk index gaps] The chunk_first_idx is set to current_idx + 1 when cutting chunks - can off-by-one errors create index gaps or overlaps between chunks? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: ChunkerState::last_chunk()] [Last chunk edge case] If the last chunk is extremely small (single record), can this violate assumptions about minimum chunk size and cause restore failures? (Low)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: ChunkerState::next_full_chunk()] [Record ordering] Can records arrive out of order from concurrent streams causing last_key to be less than first_key in a chunk, breaking Merkle proof verification? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs] [Function: StateSnapshotBackupController::write_chunk()] [Proof key mismatch] The get_account_range_proof() is called with last_key, but can this differ from the actual last key in the chunk data if parse_key() returns different hashes? (Critical)"
]