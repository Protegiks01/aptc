[
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Address manipulation] Can an attacker provide a malformed address string in write_resource.address that bypasses standardize_address() validation at line 59, leading to duplicate balance entries with different address formats and causing balance accounting inconsistencies? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Address collision] Does standardize_address() at line 59 properly handle edge cases where two distinct addresses could hash to the same standardized form, potentially allowing an attacker to manipulate another user's coin balance records? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Primary key collision] Can an attacker craft transactions with identical (transaction_version, owner_address, coin_type) tuples at line 23 to cause primary key violations, potentially preventing legitimate balance updates from being indexed? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Address length overflow] Can providing an extremely long address string (e.g., thousands of characters) to write_resource.address at line 59 cause memory exhaustion or buffer overflow in standardize_address(), leading to indexer crash or DoS? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Hash collision attack] Can an attacker craft malicious coin types that produce identical coin_type_hash values via to_hash() at line 63, allowing them to conflate different coin types and steal funds by manipulating balance records? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Hash collision] Does coin_info_type.to_hash() at line 63 use a cryptographically secure hash function, or can attackers generate hash collisions to merge distinct coin types into a single balance entry? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Hash truncation] Is coin_type_hash at line 28 sufficiently long to prevent birthday attacks, or can attackers exploit hash collisions to manipulate multiple coin type balances simultaneously? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Type hash manipulation] Can an attacker manipulate the MoveType generic_type_params[0] at line 56 to produce a coin_type_hash that collides with existing legitimate coins, enabling balance manipulation attacks? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Type truncation] Does get_coin_type_trunc() at line 64 properly handle extremely long coin type strings that exceed COIN_TYPE_HASH_LENGTH (5000 chars), or can truncation cause distinct coin types to appear identical in the database? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Truncation collision] Can an attacker create two coin types that are identical after truncation at line 64, causing the indexer to treat them as the same coin and merge their balances incorrectly? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Type storage limits] Is the coin_type field at line 29 subject to database column length limits, and can extremely long coin types (post-truncation) cause insertion failures or data corruption? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Amount overflow] Can an attacker provide a manipulated inner.coin.value at line 65 that exceeds BigDecimal's maximum precision, causing overflow and allowing them to mint unlimited coins through balance wrapping? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Negative amount] Does the code validate that inner.coin.value at line 65 is non-negative, or can an attacker insert negative balance values to manipulate total supply calculations or steal funds? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Amount precision loss] Can the clone() operation on inner.coin.value at line 65 cause precision loss in BigDecimal amounts, leading to rounding errors that accumulate and cause balance discrepancies over millions of transactions? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Amount data type] Is BigDecimal at line 30 the correct type for representing coin amounts, or can precision issues in BigDecimal arithmetic cause loss of fractional amounts during indexing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Amount validation] Are there any bounds checks on the amount field at lines 65 and 72, or can attackers insert arbitrarily large values that exceed u128::MAX or cause database storage issues? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Zero amount handling] Does the code properly handle zero or near-zero amounts at line 65, or can attackers create dust attacks with minimal amounts to bloat the coin_balances table and degrade indexer performance? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Version manipulation] Can an attacker provide a manipulated txn_version parameter at line 50 that is out of sequence or negative, causing the indexer to process transactions in the wrong order and create inconsistent balance states? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Version overflow] Is txn_version at line 50 properly validated to fit within i64 bounds, or can extremely large version numbers cause integer overflow and corrupt the indexed transaction history? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Version monotonicity] Does the indexer enforce that transaction_version at line 26 is strictly increasing, or can attackers reindex old transactions with newer versions to manipulate historical balance records? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Version collision] Can multiple write resources with the same txn_version at line 61 but different owner_addresses cause primary key violations or race conditions during concurrent indexing? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CurrentCoinBalance] [Last version tracking] Can an attacker manipulate last_transaction_version at line 42 to be less than previous values, causing the CurrentCoinBalance to show stale data and misrepresent actual balances? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Timestamp manipulation] Can an attacker provide a malicious txn_timestamp at line 51 that is far in the future or past, causing temporal inconsistencies in balance history and breaking time-based queries? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Function: from_write_resource()] [Timestamp validation] Are there any checks ensuring txn_timestamp at lines 66 and 74 is within reasonable bounds (not before genesis or after MAX_TIMESTAMP_SECS), or can invalid timestamps corrupt the indexed data? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_balances.rs] [Struct: CoinBalance] [Timestamp monotonicity] Does the code enforce that transaction_timestamp at line 31 is monotonically increasing with transaction_version, or can out-of-order timestamps cause confusion in temporal balance tracking? (Low)"
]