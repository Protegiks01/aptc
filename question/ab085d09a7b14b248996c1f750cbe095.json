[
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::io_gas_per_event()] [Version independence] Should event pricing vary by version like reads/writes, or is the uniform pricing across all versions intentional and secure? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::io_gas_per_write()] [StateKey manipulation] Can the StateKey reference be manipulated to report incorrect key sizes through custom implementations of size() or encoded(), causing undercharged writes? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::io_gas_per_write()] [WriteOpSize enum exhaustiveness] Are all WriteOpSize variants properly handled in all version implementations, or can new enum variants cause panics or incorrect gas calculation? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::io_gas_per_write()] [Version-specific logic divergence] Can the different logic in V1/V2/V3/V4 for the same operation cause validators running different versions (during upgrades) to calculate different gas costs and diverge? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::io_gas_per_write()] [Either type coercion] Does the Either wrapping for different versions properly maintain type safety and prevent gas expression manipulation? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricing] [Version rollback attack] Can an attacker force a rollback from V4 to earlier versions through governance manipulation, reverting to less secure pricing models with free quotas or lower costs? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricing] [Version-specific exploits] Can an attacker exploit timing during version transitions to submit transactions that are priced under the old version but executed under the new version (or vice versa)? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricingV1] [Legacy parameter obsolescence] Are legacy parameters (legacy_write_data_per_new_item, legacy_write_data_per_byte_in_val) still properly maintained and secured, or have they become attack surfaces due to lack of updates? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricingV2] [Storage curve attack] Can malicious governance proposals set storage curve parameters to create economic incentives for state bloat or excessive deletions? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricingV3] [GasExpression deferred evaluation] Can the deferred evaluation of GasExpression in V3/V4 cause race conditions or timing attacks where gas parameters change between expression creation and evaluation? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Struct: IoPricingV4] [Page size assumption] Is the PAGE_SIZE assumption of 4096 bytes valid across all storage backends, or can mismatched page sizes between validators cause non-deterministic gas charges? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Type: InternalGas] [Addition overflow] Can repeated additions of InternalGas values (base + per_byte + per_item) overflow the internal representation, wrapping to small values? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Type: NumBytes] [Maximum value handling] Does NumBytes properly handle u64::MAX values without causing overflow in subsequent multiplications or additions? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Type: NumArgs] [Type confusion] Can NumArgs be confused with NumBytes in calculations, causing incorrect gas charges when multiplying by per-arg vs per-byte rates? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Type: InternalGasPerByte] [Rate overflow] Can InternalGasPerByte rates be set high enough that multiplying by even moderate byte counts causes overflow? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Type: InternalGasPerArg] [Rate manipulation] Can per-arg rates be manipulated to zero through governance, enabling unlimited operations of that type? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricing::new()] [Config storage determinism] Can non-deterministic config storage reads cause different validators to construct different IoPricing variants, leading to consensus failure? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricingV2::write_op_size()] [Floating point risk] Does any calculation use floating point arithmetic that could cause non-deterministic rounding across different CPU architectures? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [Function: IoPricingV4::calculate_read_gas()] [Modulo determinism] Is the modulo operation guaranteed to be deterministic across all validator node architectures and Rust compiler versions? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [All calculate_read_gas functions] [Byte counting consistency] Can different nodes count loaded bytes differently due to compression, encoding, or caching differences, causing divergent gas charges? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/io_pricing.rs] [All io_gas_per_write functions] [StateKey encoding consistency] Does StateKey.encoded() return deterministic results across all nodes, or can serialization differences cause non-deterministic key size calculations? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-types/src/storage/\n\n### Citations\n\n**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L1-319)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse aptos_gas_algebra::GasExpression;\nuse aptos_gas_schedule::{\n    gas_params::txn::{\n        STORAGE_IO_PER_EVENT_BYTE_WRITE, STORAGE_IO_PER_STATE_BYTE_READ,\n        STORAGE_IO_PER_STATE_BYTE_WRITE, STORAGE_IO_PER_STATE_SLOT_READ,\n        STORAGE_IO_PER_STATE_SLOT_WRITE, STORAGE_IO_PER_TRANSACTION_BYTE_WRITE,\n    },\n    AptosGasParameters, VMGasParameters,\n};\nuse aptos_types::{\n    contract_event::ContractEvent,\n    on_chain_config::{ConfigStorage, StorageGasSchedule},\n    state_store::state_key::StateKey,\n    write_set::WriteOpSize,\n};\nuse either::Either;\nuse move_core_types::gas_algebra::{\n    InternalGas, InternalGasPerArg, InternalGasPerByte, InternalGasUnit, NumArgs, NumBytes,\n};\n\n#[derive(Clone, Debug)]\npub struct IoPricingV1 {\n    write_data_per_op: InternalGasPerArg,\n    write_data_per_new_item: InternalGasPerArg,\n    write_data_per_byte_in_key: InternalGasPerByte,\n    write_data_per_byte_in_val: InternalGasPerByte,\n    load_data_base: InternalGas,\n    load_data_per_byte: InternalGasPerByte,\n    load_data_failure: InternalGas,\n}\n\nimpl IoPricingV1 {\n    fn new(gas_params: &AptosGasParameters) -> Self {\n        Self {\n            write_data_per_op: gas_params.vm.txn.storage_io_per_state_slot_write,\n            write_data_per_new_item: gas_params.vm.txn.legacy_write_data_per_new_item,\n            write_data_per_byte_in_key: gas_params.vm.txn.storage_io_per_state_byte_write,\n            write_data_per_byte_in_val: gas_params.vm.txn.legacy_write_data_per_byte_in_val,\n            load_data_base: gas_params.vm.txn.storage_io_per_state_slot_read * NumArgs::new(1),\n            load_data_per_byte: gas_params.vm.txn.storage_io_per_state_byte_read,\n            load_data_failure: gas_params.vm.txn.load_data_failure,\n        }\n    }\n}\n\nimpl IoPricingV1 {\n    fn calculate_read_gas(&self, loaded: Option<NumBytes>) -> InternalGas {\n        self.load_data_base\n            + match loaded {\n                Some(num_bytes) => self.load_data_per_byte * num_bytes,\n                None => self.load_data_failure,\n            }\n    }\n\n    fn io_gas_per_write(&self, key: &StateKey, op_size: &WriteOpSize) -> InternalGas {\n        use aptos_types::write_set::WriteOpSize::*;\n\n        let mut cost = self.write_data_per_op * NumArgs::new(1);\n\n        if self.write_data_per_byte_in_key > 0.into() {\n            cost += self.write_data_per_byte_in_key * NumBytes::new(key.encoded().len() as u64);\n        }\n\n        match op_size {\n            Creation { write_len } => {\n                cost += self.write_data_per_new_item * NumArgs::new(1)\n                    + self.write_data_per_byte_in_val * NumBytes::new(*write_len);\n            },\n            Modification { write_len } => {\n                cost += self.write_data_per_byte_in_val * NumBytes::new(*write_len);\n            },\n            Deletion => (),\n        }\n\n        cost\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct IoPricingV2 {\n    pub feature_version: u64,\n    pub free_write_bytes_quota: NumBytes,\n    pub per_item_read: InternalGasPerArg,\n    pub per_item_create: InternalGasPerArg,\n    pub per_item_write: InternalGasPerArg,\n    pub per_byte_read: InternalGasPerByte,\n    pub per_byte_create: InternalGasPerByte,\n    pub per_byte_write: InternalGasPerByte,\n}\n\nimpl IoPricingV2 {\n    pub fn new_with_storage_curves(\n        feature_version: u64,\n        storage_gas_schedule: &StorageGasSchedule,\n        gas_params: &AptosGasParameters,\n    ) -> Self {\n        Self {\n            feature_version,\n            free_write_bytes_quota: Self::get_free_write_bytes_quota(feature_version, gas_params),\n            per_item_read: storage_gas_schedule.per_item_read.into(),\n            per_item_create: storage_gas_schedule.per_item_create.into(),\n            per_item_write: storage_gas_schedule.per_item_write.into(),\n            per_byte_read: storage_gas_schedule.per_byte_read.into(),\n            per_byte_create: storage_gas_schedule.per_byte_create.into(),\n            per_byte_write: storage_gas_schedule.per_byte_write.into(),\n        }\n    }\n\n    fn get_free_write_bytes_quota(\n        feature_version: u64,\n        gas_params: &AptosGasParameters,\n    ) -> NumBytes {\n        match feature_version {\n            0 => unreachable!("
]