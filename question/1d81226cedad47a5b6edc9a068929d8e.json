[
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Initialization vulnerability] Can a malicious validator provide crafted ReliableBroadcastConfig parameters (extremely low backoff_policy_base_ms or high max_delay_ms) during SecretShareManager initialization to cause resource exhaustion or timing attacks that degrade consensus performance? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [State inconsistency] Is there a race condition where the SecretShareStore is initialized with decision_tx channel before all validators are ready, potentially causing early secret shares to be lost or processed out of order? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Byzantine attack] Can an attacker manipulate the epoch_state.verifier.get_ordered_account_addresses() ordering to influence ReliableBroadcast behavior and cause secret share aggregation to favor certain validators? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Resource exhaustion] Does the unbounded channel created at line 87 for decision_tx/decision_rx allow a Byzantine validator to flood the system with fake aggregated keys, causing memory exhaustion? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Configuration bypass] Can config parameter be manipulated to set invalid threshold values (e.g., threshold > total validators) that would make secret reconstruction impossible, causing permanent liveness loss? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [Race condition] At lines 116-122, share_requester_handles and pending_secret_key_rounds are populated in a loop without atomicity - can a Byzantine validator trigger a race where handles are mismatched with rounds, causing secret shares for wrong blocks to be requested? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [Memory exhaustion] Does processing OrderedBlocks without checking maximum block count allow an attacker to send thousands of blocks in one batch, exhausting memory when spawning share_requester_handles? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [State inconsistency] Can blocks.ordered_blocks contain duplicate rounds that would cause pending_secret_key_rounds HashSet to not accurately reflect pending states, leading to blocks being processed prematurely? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [Byzantine attack] If a Byzantine validator sends blocks with non-consecutive rounds (e.g., rounds 1, 5, 100), can this cause gaps in block_queue that permanently block consensus progress? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [Denial of service] Can an attacker repeatedly send the same OrderedBlocks batch to trigger redundant process_incoming_block() calls and spawn duplicate share_requester_handles, causing resource exhaustion? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Panic vulnerability] At lines 133-138, .expect() is called on futures.secret_sharing_derive_self_fut and the inner result - can a Byzantine validator craft a block with malformed pipeline_futs that causes validator nodes to panic and halt? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Lock contention] Lines 142-148 hold secret_share_store.lock() while calling update_highest_known_round() and add_self_share() - can an attacker send rapid block sequences to cause lock contention that delays honest secret share broadcasting? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Race condition] Between releasing the lock at line 148 and broadcasting at line 154, can another thread modify the secret_share_store causing the broadcasted self_secret_share to be stale or invalid? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Byzantine broadcast] The broadcast_without_self() at line 154 doesn't verify delivery - can a Byzantine validator broadcast malformed secret shares to honest nodes while keeping valid shares for colluding validators? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Metadata manipulation] Can an attacker manipulate self_secret_share.metadata() returned at line 139 to contain mismatched round/epoch values that cause spawn_share_requester_task to request shares for wrong blocks? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Timestamp manipulation] Does the LogSchema at lines 150-153 expose sensitive timing information that Byzantine validators could use to coordinate attacks on secret share aggregation timing? (Low)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_ready_blocks()] [Unbounded send failure] At line 168, unbounded_send() result is ignored with let _ - can channel receiver being dropped or full cause ready blocks with valid secret shares to be silently lost? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_ready_blocks()] [Ordering violation] Does the iteration order through ready_blocks vec preserve the original block ordering required for consensus, or can blocks be delivered out of order causing state inconsistencies? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_ready_blocks()] [Resource leak] If outgoing_blocks.unbounded_send() fails silently, are the secret shares and DropGuards leaked, causing accumulating resource exhaustion over time? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [State inconsistency] At lines 178-181, block_queue is reset and highest_known_round is updated non-atomically - can a race condition allow blocks from the old epoch to be processed with the new epoch's round numbers? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [Byzantine attack] Can a Byzantine validator trigger ResetSignal::Stop at line 175 to permanently set self.stop=true, causing honest validators to exit the consensus loop and lose liveness? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [Data race] The block_queue reset at line 178 doesn't coordinate with concurrent process_aggregated_key() calls - can this cause secret shares to be added to a stale queue that gets discarded? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [Channel cleanup] When BlockQueue is reset, are the share_requester_handles properly dropped to abort running tasks, or do they continue requesting shares for abandoned rounds? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [Epoch rollback] Can target_round be set to a past value through ResetSignal::TargetRound, allowing replayed secret shares from old rounds to be accepted and processed? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_reset()] [Response timing] Is the ResetAck sent at line 183 before cleanup is truly complete, potentially causing the caller to proceed with operations while reset is still in progress? (Medium)"
]