[
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: commit()] [SkipRest epilogue handling] At lines 343-346, SkipRest transactions can trigger epilogue creation - if a malicious transaction intentionally triggers SkipRest after transferring all funds, can it prevent remaining honest transactions from executing while still triggering epilogue with incorrect fee accounting? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: publish_module_write_set()] [Module cache poisoning] At lines 559-571, modules are written to both global_module_cache and versioned_cache via add_module_write_to_module_cache() - can concurrent module publications cause version conflicts where different validator nodes cache different module versions, breaking consensus? (Critical)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: publish_module_write_set()] [Cache flush timing] At line 574, flush_layout_cache() is called after modules are published - can transactions read from the layout cache between module publication and flush, observing stale type layouts and causing deserialization errors or type confusion vulnerabilities? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: publish_module_write_set()] [Validation requirements bypass] At line 575, record_validation_requirements() is called with module_ids_for_v2 only if scheduler.is_v2() - can attackers force scheduler v1 mode to bypass validation recording, allowing malicious modules to be published without proper dependency validation? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: publish_module_write_set()] [Module ID collection] At lines 558-563, module IDs are collected into BTreeSet only for v2 scheduler - can discrepancies in which modules are tracked cause validation to miss dependencies, allowing modules with circular dependencies or version conflicts to be deployed? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: publish_module_write_set()] [Runtime environment access] At line 567, runtime_environment is passed to add_module_write_to_module_cache without synchronization - can concurrent modifications to runtime_environment cause module bytecode to be validated against wrong gas schedules or feature flags? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: fetch_exchanged_data()] [Type confusion] At lines 266-289, exchanged data must be in Versioned format with Some(layout) - can an attacker record data without layout information, then fetch it, causing the code_invariant_error at line 282 to be triggered during transaction execution rather than validation, breaking atomicity? (Critical)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: fetch_exchanged_data()] [Missing data attack] At lines 271-276, if input is not recorded, code_invariant_error is returned - can this be exploited in parallel execution where transaction T2 depends on T1's exchanged data, but T1 is re-executed and hasn't recorded data yet, causing T2 to fail with invariant error? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: reads_needing_delayed_field_exchange()] [Exchange bypass] At lines 597-603, reads needing exchange are returned only for Success/SkipRest status - can transactions with other statuses skip delayed field exchange while still having their delayed field reads used by dependent transactions, causing state inconsistency? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: delayed_field_keys()] [Key enumeration] At lines 580-595, delayed_field_keys() returns an iterator over delayed field change set - can malicious transactions create massive numbers of delayed field changes to DoS downstream processing or cause memory exhaustion in key collection? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: record_materialized_txn_output()] [Materialization race] At lines 670-687, delta_writes and patched data are incorporated into output using with_success_or_skip_rest - if materialization occurs after commit but before take_output, can the output be in an inconsistent partially-materialized state? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: group_reads_needing_delayed_field_exchange()] [Resource group exchange] At lines 605-616, group reads needing exchange are separate from regular reads - can attackers exploit differences in exchange timing between resource groups and regular resources to cause desynchronization in parallel execution? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: modified_resource_keys()] [Aggregator marking] At lines 486-516, resources are marked as AggregatorV1 (true/false flag) - can inconsistent marking between write_set (line 499) and delta_set (line 510) cause the same resource to appear twice with different flags, confusing validation and allowing double-application of changes? (Critical)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: modified_aggregator_v1_keys()] [Delta set bypass] At lines 518-536, aggregator keys come from both write_set and delta_set - can attackers craft transactions that update aggregators through write_set to bypass delta application logic, or vice versa, causing final aggregator values to be incorrect? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: aggregator_v1_delta_keys()] [Delta key extraction] At lines 618-633, delta keys are extracted from aggregator_v1_delta_set - if delta application fails during materialization, are these keys still returned, causing downstream logic to expect materialized values that don't exist? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: for_each_resource_key_no_aggregator_v1()] [Aggregator exclusion] At lines 442-455, resources are iterated excluding aggregator v1 - can this exclusion be inconsistent with how aggregators are identified in modified_resource_keys(), causing some aggregator updates to be double-processed or missed? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: for_each_resource_group_key_and_tags()] [Tag set manipulation] At lines 458-471, resource group tags are passed as HashSet - can malicious transactions craft tag sets with hash collisions or duplicate tags that cause the callback to be invoked multiple times for the same tag, leading to duplicate state updates? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: modified_group_key_and_tags_cloned()] [Group tag cloning] At lines 473-479, legacy_v1_resource_group_tags are cloned - if the underlying data structure is a large HashMap, can attackers create transactions that modify many group tags to cause memory exhaustion through repeated cloning during validation? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: resource_group_metadata_ops()] [Metadata manipulation] At lines 635-638, resource group metadata operations return Key-Value pairs - can malicious transactions craft metadata ops that conflict with actual group content, causing metadata to be out of sync with resource data after commit? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: record_speculative_failure()] [Failure flag race] At line 263, speculative_failure flag is set to true with Relaxed ordering - can concurrent record() calls at line 250 clear this flag while record_speculative_failure() is setting it, causing the failure to be lost and validation to incorrectly succeed? (Critical)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: read_set()] [Stale failure status] At lines 293-298, read_set returns both input and speculative_failure flag - if record_speculative_failure() is called after read_set() loads input but before loading flag, can validation use correct input with incorrect (false) failure status, missing actual speculative errors? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Struct: OutputWrapper] [SpeculativeExecutionAbortError handling] At lines 178-180, SpeculativeExecutionAbortError creates empty wrapper - can transactions in this state still have their outputs partially written to versioned_cache before error detection, polluting the cache with speculative data? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Struct: OutputWrapper] [DelayedFieldsCodeInvariantError handling] At lines 181-183, DelayedFieldsCodeInvariantError creates empty wrapper - can this error status persist across re-executions, preventing transaction from ever succeeding even after delayed fields are resolved? (Medium)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: new()] [Array bounds] At lines 224-240, vectors are initialized with num_txns capacity - if num_txns is manipulated to be larger than actual block size, can this cause excessive memory allocation leading to OOM, or if smaller, cause out-of-bounds access in later operations? (High)",
  "[File: aptos-core/aptos-move/block-executor/src/txn_last_input_output.rs] [Function: record()] [Index bounds] At lines 250, 251, 257, txn_idx is used to index into vectors - can txn_idx >= num_txns cause out-of-bounds access if parallel execution allows transactions beyond initialized range to execute? (Critical)"
]