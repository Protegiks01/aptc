[
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: new()] [Initialization vulnerability] Can an attacker manipulate the anchor_shard_id parameter during tracker creation to cause all transactions to be assigned to a malicious shard, enabling selective transaction censorship or reordering attacks? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: new()] [State corruption] If multiple threads create trackers for the same storage_location with different anchor_shard_id values concurrently, can this lead to inconsistent conflict resolution and cross-shard dependency violations? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: new()] [DoS attack] Can an attacker trigger creation of unlimited ConflictingTxnTracker instances by crafting transactions with unique storage locations, causing memory exhaustion and validator node crashes? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: new()] [Shard manipulation] Is there validation that anchor_shard_id is within valid bounds (< num_executor_shards), or can out-of-bounds shard IDs cause panics or undefined behavior during partitioning? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: new()] [Determinism violation] If anchor_shard_id is randomly chosen non-deterministically across validators, will different validators produce different partitioning results, breaking consensus safety? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_read_candidate()] [Race condition] Can concurrent calls to add_read_candidate from multiple threads cause the BTreeSet to enter an inconsistent state, leading to lost read tracking and incorrect dependency analysis? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_read_candidate()] [Duplicate tracking] If the same txn_id is added multiple times as a read candidate, does the BTreeSet properly deduplicate, or could duplicate entries cause incorrect conflict counting? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_read_candidate()] [Integer overflow] Can an attacker craft transactions with extremely large PrePartitionedTxnIdx values that overflow during BTreeSet operations, causing panics or memory corruption? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_read_candidate()] [Memory exhaustion] Can an attacker spam transactions reading the same storage location to grow pending_reads unboundedly, causing validator memory exhaustion? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_read_candidate()] [Ordering violation] If add_read_candidate is called after mark_txn_ordered for the same txn_id, does this create inconsistent state where a transaction appears both pending and finalized? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_write_candidate()] [Race condition] During parallel transaction analysis, can concurrent add_write_candidate calls from different threads cause write conflicts to be missed, allowing incorrect parallel execution? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_write_candidate()] [Write-write conflict] If multiple transactions writing to the same location are added concurrently, can the BTreeSet operations race such that some writes are lost from tracking, causing double-spending? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_write_candidate()] [Duplicate insertion] Can adding the same txn_id as both read and write candidate cause the transaction to be counted twice in conflict analysis, leading to incorrect partitioning decisions? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_write_candidate()] [DoS amplification] Can an attacker create a single transaction that writes to thousands of storage locations, forcing creation of thousands of trackers and causing quadratic complexity in conflict resolution? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: add_write_candidate()] [Memory corruption] If pending_writes BTreeSet operations are not thread-safe in the concurrent partitioning context, can this lead to memory corruption and validator crashes? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Assertion panic] The assert on line 64 will panic if a transaction was never added as a read or write candidate - can an attacker trigger this by exploiting race conditions in the partitioning flow? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Double finalization] Can mark_txn_ordered be called twice for the same txn_id, causing the transaction to appear multiple times in finalized sets and breaking dependency calculations? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Race condition] If remove operations on pending_writes and pending_reads race with concurrent add operations, can a transaction be finalized while still appearing in pending sets? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Ordering violation] Can transactions be marked as ordered out of sequence (txn N+1 before txn N), breaking the sequential execution guarantees and enabling double-spending? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Shard ID manipulation] If round_id or shard_id parameters are attacker-controlled or corrupted, can this cause transactions to be assigned to wrong shards, bypassing cross-shard dependency checks? (Critical)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [State inconsistency] If mark_txn_ordered partially succeeds (e.g., removes from pending_writes but crashes before inserting into finalized), can this leave trackers in an inconsistent state? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Integer overflow] Can extremely large round_id or shard_id values cause overflow in ShardedTxnIndexV2::new, leading to incorrect transaction ordering? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Logic error] The function assumes a transaction is either in pending_writes OR pending_reads, but what if it was never added to either due to a bug - does the assertion catch all cases? (Medium)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Finalized set pollution] Can malicious transactions be marked as finalized with fabricated round_id/shard_id values to pollute the finalized sets and corrupt dependency tracking? (High)",
  "[File: aptos-core/execution/block-partitioner/src/v2/conflicting_txn_tracker.rs] [Function: mark_txn_ordered()] [Panic-based DoS] Can an attacker reliably trigger the assertion panic on line 64 by exploiting timing windows in concurrent partitioning, causing validator crashes? (High)"
]