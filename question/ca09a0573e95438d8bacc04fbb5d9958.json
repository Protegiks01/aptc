[
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: run_impl() in EpochHistoryRestoreController] [Trusted Waypoints Clone] At line 413, trusted_waypoints is cloned from global_opt. Can an attacker modify global_opt.trusted_waypoints after cloning to create divergent verification paths? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochEndingRestoreController] [Manifest Handle Injection] At line 52, manifest_handle is directly assigned from opt. Can an attacker supply a malicious FileHandle that points to attacker-controlled storage, allowing arbitrary manifest injection? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochEndingRestoreController] [Target Version Manipulation] At line 53, target_version is set from global_opt. Can an attacker manipulate this value to include future epochs or exclude past epochs, corrupting the restore scope? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochEndingRestoreController] [Trusted Waypoints Substitution] At line 54, trusted_waypoints is cloned from global_opt. Can an attacker replace this HashMap with attacker-controlled waypoints to bypass epoch verification? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochEndingRestoreController] [Storage Backend Compromise] At line 50, storage is passed as Arc<dyn BackupStorage>. Can an attacker provide a malicious implementation of BackupStorage that returns corrupted manifests and chunks? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochEndingRestoreController] [Run Mode Manipulation] At line 51, run_mode is set from global_opt. Can an attacker switch between Restore and Verify modes to skip critical validation or persistence steps? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochHistoryRestoreController] [Manifest Order Attack] At line 330, manifest_handles is passed as Vec<FileHandle>. Can an attacker reorder this vector to cause epochs to be restored out of sequence, violating continuity checks? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: new() in EpochHistoryRestoreController] [Duplicate Manifest Attack] Can an attacker include duplicate FileHandles in manifest_handles to cause the same epochs to be restored multiple times, corrupting epoch_endings? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: preheat()] [Preheat Result Caching] At line 58-63, preheat() returns PreheatedEpochEndingRestore with cached preheat_result. Can an attacker reuse a PreheatedEpochEndingRestore with stale preheat_result to bypass fresh validation? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: preheat()] [Async Timing Attack] Since preheat_impl() is async, can an attacker exploit timing differences between manifest loading and verification to inject malicious data via TOCTOU vulnerabilities? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: preheat()] [Controller Consumption] The preheat() method consumes self and moves controller into PreheatedEpochEndingRestore. Can this prevent proper cleanup if preheat_result is Err, leading to resource leaks? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: run() in EpochEndingRestoreController] [Direct Preheat Skip] At line 65-73, run() internally calls preheat(). Can an attacker call run() multiple times to force repeated preheat operations, causing DoS through resource exhaustion? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: run() in PreheatedEpochEndingRestore] [Error Message Leakage] At line 199, errors are wrapped with anyhow!(",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: run() in PreheatedEpochEndingRestore] [Preheat Failure Silent] At line 210-212, preheat failure is mapped to error. Can an attacker cause preheat to fail silently for specific manifests while succeeding for others, creating inconsistent restore states? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Function: run() in EpochHistoryRestoreController] [Timer Information Leak] At line 353 and 407-410, timing information is logged. Can an attacker use timing side-channels to infer information about waypoint verification or epoch counts? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Integer Overflow] In preheat_impl() at line 100, chunk.first_epoch + lis.len() as u64 is computed. Can an attacker provide chunk.first_epoch near u64::MAX and a large lis.len() to cause overflow and bypass the equality check? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Integer Overflow] At line 151, next_epoch += 1 is performed. Can processing u64::MAX epochs cause overflow in next_epoch, wrapping back to 0 and corrupting epoch sequence validation? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Integer Overflow] At line 400, next_epoch += 1 in the epoch history loop. Can billions of epochs cause next_epoch overflow, making new epochs appear as old epochs and bypassing validation? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Integer Underflow] At line 307, epoch_endings[epoch as usize - 1] subtracts 1 from epoch. Can an attacker provide epoch = 0 to cause underflow, resulting in usize::MAX and out-of-bounds array access? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Integer Arithmetic] At line 280, epoch > self.epoch_endings.len() as u64 compares u64 to usize cast. Can differences in integer sizes on 32-bit vs 64-bit systems cause validation bypass? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Signature Verification] At line 147, Verifier::verify(&li) is called on next_epoch_state(). Can an attacker exploit known weaknesses in the BLS signature aggregation to forge valid signatures for malicious ledger infos? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Signature Verification] At line 239, verify(first_li) is called on previous next_epoch_state. Can replay attacks using old valid signatures from previous epochs be used to validate fraudulent new epochs? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Signature Verification] At line 310, verify(li_with_sigs) uses epoch_endings validator set. Can an attacker provide a ledger info signed by a compromised validator set from a previous epoch to bypass current validation? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Waypoint Verification] At line 123, Waypoint::new_epoch_boundary(li.ledger_info()) creates a waypoint. Can an attacker exploit hash collisions in waypoint generation to create fake ledger infos with matching waypoints? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs] [Waypoint Verification] At line 299, Waypoint::new_any() is used instead of new_epoch_boundary(). Can this weaker waypoint check be exploited to accept non-epoch-ending ledger infos in epoch history? (High)"
]