[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Interpreter: ExecutionState] [State Corruption] Can ExecutionState returned from stack_frames() be used to corrupt interpreter state? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Gas: InternalGas] [Gas Overflow] Can InternalGas values overflow when summing charges, allowing transactions to execute with negative effective gas? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Gas: NumBytes] [Size Calculation Overflow] Can NumBytes calculations overflow when computing sizes for gas charges? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Gas: DependencyKind] [Dependency Classification] Can dependency types be misclassified to charge incorrect gas amounts? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Gas: legacy_gas_budget] [Legacy Budget Exploit] Can the legacy gas budget system be exploited to bypass modern gas limits? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Gas: charge_native_result_load_module] [Module Load Gas Bypass] Can module loading be performed without adequate gas charges, enabling DoS attacks? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Closure: AbstractFunction] [Closure Capture Exploit] Can captured values in closures be manipulated to access data from other execution contexts? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Closure: LazyLoadedFunction] [Lazy Loading Race] Can lazy function loading be raced to load different implementations across validators? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Closure: captured_layouts] [Layout Cache Exploit] Can captured layout caching be exploited to reuse incorrect layouts across closures? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Closure: FunctionValueExtensionAdapter] [Extension Adapter Bypass] Can the adapter pattern be exploited to bypass serialization/deserialization checks? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Enum: FunctionResolutionError] [Error Code Manipulation] At line 284-290, can error enum values be manipulated to bypass error handling? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Enum: Reserved variant] [Reserved Exploitation] The Reserved = 0x0 variant - can this be exploited if error codes are transmitted as integers? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Enum: Error mapping] [Semantic Loss] Does mapping detailed errors to coarse categories lose security-critical information? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Attack: Type confusion] [Cross-context Type Confusion] Can types from one module be confused with identically-named types from another module? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Attack: Integer overflow] [Size Calculation Overflow] Can size calculations for gas or memory overflow, allowing unbounded resource consumption? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Attack: Timing] [Timing Side Channel] Can native function execution time leak information about private state or keys? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Attack: Resource exhaustion] [Unbounded Recursion] Can recursive type layouts or function calls cause stack overflow attacks? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Attack: State manipulation] [Cross-transaction State Leak] Can state from one transaction leak into another through improperly cleaned caches? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Struct: StructKey] [Key Collision] Can StructKey values collide, causing different structs to share layouts? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Struct: LayoutCacheEntry] [Entry Poisoning] Can cache entries be maliciously crafted to cause deserial failures across all validators? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Struct: LoadedFunctionOwner] [Owner Confusion] Can LoadedFunctionOwner::Module references be exploited to access functions from wrong modules? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/native_functions.rs] [Delegate: Ambassador pattern] [Delegation Bypass] Can the ambassador delegation pattern be exploited to bypass trait bounds or safety checks\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L1-524)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    ambassador_impl_ModuleStorage, ambassador_impl_WithRuntimeEnvironment,\n    data_cache::NativeContextMoveVmDataCache,\n    dispatch_loader,\n    interpreter::InterpreterDebugInterface,\n    loader::{LazyLoadedFunction, LazyLoadedFunctionState},\n    module_traversal::TraversalContext,\n    native_extensions::NativeContextExtensions,\n    storage::{\n        layout_cache::StructKey,\n        loader::traits::NativeModuleLoader,\n        module_storage::FunctionValueExtensionAdapter,\n        ty_layout_converter::{LayoutConverter, LayoutWithDelayedFields},\n    },\n    Function, FunctionDefinitionLoader, LayoutCache, LayoutCacheEntry, LoadedFunction,\n    LoadedFunctionOwner, Module, ModuleStorage, RuntimeEnvironment, WithRuntimeEnvironment,\n};\nuse ambassador::delegate_to_methods;\nuse bytes::Bytes;\nuse move_binary_format::{\n    errors::{ExecutionState, PartialVMError, PartialVMResult, VMResult},\n    CompiledModule,\n};\nuse move_core_types::{\n    account_address::AccountAddress,\n    gas_algebra::{InternalGas, NumBytes},\n    identifier::{IdentStr, Identifier},\n    language_storage::{ModuleId, TypeTag},\n    value::MoveTypeLayout,\n    vm_status::StatusCode,\n};\nuse move_vm_types::{\n    gas::{ambassador_impl_DependencyGasMeter, DependencyGasMeter, DependencyKind, NativeGasMeter},\n    loaded_data::runtime_types::{Type, TypeParamMap},\n    natives::function::NativeResult,\n    values::{AbstractFunction, Value},\n};\nuse std::{\n    collections::{HashMap, VecDeque},\n    rc::Rc,\n    sync::Arc,\n};\nuse triomphe::Arc as TriompheArc;\n\npub type UnboxedNativeFunction = dyn for<'a> Fn(&mut NativeContext, &'a [Type], VecDeque<Value>) -> PartialVMResult<NativeResult>\n    + Send\n    + Sync\n    + 'static;\n\npub type NativeFunction = Arc<UnboxedNativeFunction>;\n\npub type NativeFunctionTable = Vec<(AccountAddress, Identifier, Identifier, NativeFunction)>;\n\npub fn make_table(\n    addr: AccountAddress,\n    elems: &[(&str, &str, NativeFunction)],\n) -> NativeFunctionTable {\n    make_table_from_iter(addr, elems.iter().cloned())\n}\n\npub fn make_table_from_iter<S: Into<Box<str>>>(\n    addr: AccountAddress,\n    elems: impl IntoIterator<Item = (S, S, NativeFunction)>,\n) -> NativeFunctionTable {\n    elems\n        .into_iter()\n        .map(|(module_name, func_name, func)| {\n            (\n                addr,\n                Identifier::new(module_name).unwrap(),\n                Identifier::new(func_name).unwrap(),\n                func,\n            )\n        })\n        .collect()\n}\n\n#[derive(Clone)]\npub(crate) struct NativeFunctions(\n    HashMap<AccountAddress, HashMap<String, HashMap<String, NativeFunction>>>,\n);\n\nimpl NativeFunctions {\n    pub fn resolve(\n        &self,\n        addr: &AccountAddress,\n        module_name: &str,\n        func_name: &str,\n    ) -> Option<NativeFunction> {\n        self.0.get(addr)?.get(module_name)?.get(func_name).cloned()\n    }\n\n    pub fn new<I>(natives: I) -> PartialVMResult<Self>\n    where\n        I: IntoIterator<Item = (AccountAddress, Identifier, Identifier, NativeFunction)>,\n    {\n        let mut map = HashMap::new();\n        for (addr, module_name, func_name, func) in natives.into_iter() {\n            let modules = map.entry(addr).or_insert_with(HashMap::new);\n            let funcs = modules\n                .entry(module_name.into_string())\n                .or_insert_with(HashMap::new);\n\n            if funcs.insert(func_name.into_string(), func).is_some() {\n                return Err(PartialVMError::new(StatusCode::DUPLICATE_NATIVE_FUNCTION));\n            }\n        }\n        Ok(Self(map))\n    }\n}\n\npub struct NativeContext<'a, 'b, 'c> {\n    interpreter: &'a dyn InterpreterDebugInterface,\n    data_cache: &'a mut dyn NativeContextMoveVmDataCache,\n    module_storage: &'a dyn ModuleStorage,\n    extensions: &'a mut NativeContextExtensions<'b>,\n    gas_meter: &'a mut dyn NativeGasMeter,\n    traversal_context: &'a mut TraversalContext<'c>,\n}\n\nimpl<'a, 'b, 'c> NativeContext<'a, 'b, 'c> {\n    pub(crate) fn new(\n        interpreter: &'a dyn InterpreterDebugInterface,\n        data_cache: &'a mut dyn NativeContextMoveVmDataCache,\n        module_storage: &'a dyn ModuleStorage,\n        extensions: &'a mut NativeContextExtensions<'b>,\n        gas_meter: &'a mut dyn NativeGasMeter,\n        traversal_context: &'a mut TraversalContext<'c>,\n    ) -> Self {\n        Self {\n            interpreter,\n            data_cache,\n            module_storage,\n            extensions,\n            gas_meter,\n            traversal_context,\n        }\n    }\n}\n\nimpl<'b, 'c> NativeContext<'_, 'b, 'c> {\n    pub fn print_stack_trace(&self, buf: &mut String) -> PartialVMResult<()> {\n        self.interpreter\n            .debug_print_stack_trace(buf, self.module_storage.runtime_environment())\n    }\n\n    pub fn exists_at(\n        &mut self,\n        address: AccountAddress,\n        ty: &Type,\n    ) -> PartialVMResult<(bool, Option<NumBytes>)> {\n        self.data_cache.native_check_resource_exists(\n            self.gas_meter,\n            self.traversal_context,\n            &address,\n            ty,\n        )\n    }\n\n    pub fn type_to_type_tag(&self, ty: &Type) -> PartialVMResult<TypeTag> {\n        self.module_storage.runtime_environment().ty_to_ty_tag(ty)\n    }\n\n    /// Returns the runtime layout of a type that can be used to (de)serialize the value.\n    ///\n    /// NOTE: use with caution as this ignores the flag if layout contains delayed fields or not.\n    pub fn type_to_type_layout(\n        &mut self,\n        ty: &Type,\n    ) -> PartialVMResult<TriompheArc<MoveTypeLayout>> {\n        let layout = self\n            .loader_context()\n            .type_to_type_layout_with_delayed_fields(ty)?\n            .unpack()\n            .0;\n        Ok(layout)\n    }\n\n    /// Returns the runtime layout of a type that can be used to (de)serialize the value. Also,\n    /// information whether there are any delayed fields in layouts is returned.\n    pub fn type_to_type_layout_with_delayed_fields(\n        &mut self,\n        ty: &Type,\n    ) -> PartialVMResult<LayoutWithDelayedFields> {\n        self.loader_context()\n            .type_to_type_layout_with_delayed_fields(ty)\n    }\n\n    /// Returns the runtime layout of a type that can be used to (de)serialize the value. The\n    /// layout does not contain delayed fields (otherwise, invariant violation is returned).\n    pub fn type_to_type_layout_check_no_delayed_fields(\n        &mut self,\n        ty: &Type,\n    ) -> PartialVMResult<TriompheArc<MoveTypeLayout>> {\n        let layout = self\n            .loader_context()\n            .type_to_type_layout_with_delayed_fields(ty)?;\n        layout\n            .into_layout_when_has_no_delayed_fields()\n            .ok_or_else(|| {\n                PartialVMError::new_invariant_violation("
]