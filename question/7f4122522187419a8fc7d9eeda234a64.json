[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: FunctionSignature] [Return type manipulation] Can the return_type field be set to Type_::Multiple with mismatched tuple sizes, causing stack corruption when return values are destructured? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: AccessSpecifier] [Access specifier bypass] Can the access_specifiers: Option<Vec<AccessSpecifier>> field be set to Some([]) to claim 'pure' functions that actually modify global state, bypassing static analysis and enabling hidden side effects? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: AccessSpecifier_::Acquires] [Resource lock bypass] Can AccessSpecifier_::Acquires be manipulated to not declare all acquired resources, causing runtime failures or enabling race conditions in resource access? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: AccessSpecifier_::Reads/Writes] [Read-write confusion] Can AccessSpecifier_::Reads and Writes be confused or inverted, causing the compiler to miss write operations and enabling unexpected state modifications? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: AddressSpecifier_] [Wildcard abuse] Can AddressSpecifier_::Any (wildcard) be exploited in access specifiers to declare functions that access resources at arbitrary addresses, enabling unauthorized cross-account access? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: AddressSpecifier_::Call] [Function call in specifier] Can AddressSpecifier_::Call be used to execute arbitrary functions during address resolution, enabling side effects or information leakage during compilation? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: StructDefinition] [Ability bypass through visibility] Can struct visibility field be used to expose private structs with restricted abilities, enabling external code to violate ability constraints? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: StructLayout::Singleton] [Positional field confusion] Can the bool flag in StructLayout::Singleton (indicating positional fields) be manipulated to confuse named and positional field access, causing field mixup vulnerabilities? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: StructLayout::Variants] [Enum variant confusion] Do StructLayout::Variants properly enforce exhaustive pattern matching, or can missing variants cause panics or undefined behavior in match expressions? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: StructLayout::Native] [Native struct abuse] Can user modules declare StructLayout::Native to create native structs that bypass memory safety checks and access raw memory? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: StructVariant] [Variant field duplication] Can StructVariant have duplicate Field names in the fields vec, causing field access ambiguity or memory corruption? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: StructVariant] [Positional variant abuse] Can the is_positional flag in StructVariant be used inconsistently across variants of the same enum, causing pattern matching errors? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Struct: StructTypeParameter] [Phantom constraint violation] Can phantom type parameters have ability constraints that contradict their phantom nature, enabling ability violations? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_] [Nested expression DoS] Can deeply nested Exp_ variants (e.g., BinopExp inside BinopExp recursively) cause stack overflow during AST traversal, enabling DoS attacks on compiler or VM? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Call] [Call kind confusion] Can the CallKind field (Regular/Macro/Receiver) be manipulated to change function call semantics, enabling macro expansion exploits or receiver call bypasses? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::ExpCall] [Lambda call exploitation] Can Exp_::ExpCall (calling expression results as functions) be used to call non-function types, causing type confusion or enabling arbitrary code execution? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Pack] [Field order manipulation] Can Exp_::Pack with Vec<(Field, Exp)> have duplicate or missing fields, causing struct construction to access wrong memory locations? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Vector] [Vector size explosion] Can Exp_::Vector with an extremely large Spanned<Vec<Exp>> cause memory exhaustion during compilation or runtime, enabling DoS? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Match] [Match arm exhaustiveness] Do Exp_::Match arms properly cover all variant cases, or can missing patterns cause uncaught runtime panics when unexpected variants are encountered? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Lambda] [Capture kind exploitation] Can LambdaCaptureKind (Default/Copy/Move) be manipulated to cause use-after-move or double-free errors by capturing variables incorrectly? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Quant] [Quantifier complexity] Can Exp_::Quant with nested BindWithRangeList and trigger expressions cause exponential evaluation time in the spec language, enabling DoS on formal verification? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Assign] [Assignment to constants] Can Exp_::Assign be used to assign to constant expressions or immutable bindings, violating Move's immutability guarantees? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Dereference] [Null pointer dereference] Can Exp_::Dereference be applied to references that could be null or dangling, causing memory safety violations? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Borrow] [Mutable borrow aliasing] Does Exp_::Borrow with bool=true properly prevent multiple mutable borrows, or can aliasing violations occur through complex borrow chains? (Critical)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/ast.rs] [Enum: Exp_::Cast] [Unsafe cast exploitation] Can Exp_::Cast be used to cast between incompatible types (e.g., address to u64), bypassing type safety and enabling arbitrary memory access? (Critical)"
]