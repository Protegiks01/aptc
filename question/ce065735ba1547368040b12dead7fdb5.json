[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Mutate] [Reference Mutation Attack] Can Mutate(Box<Exp>, Box<Exp>) be exploited to mutate through invalid references (e.g., dangling references, references to moved values), causing memory safety violations in the Move VM? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Return] [Early Return Bypass] Can Return(Box<Exp>) be exploited to return early and bypass cleanup code or resource drops, causing resource leaks or leaving global state in inconsistent states? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Abort] [Abort Code Manipulation] Can Abort(Box<Exp>) be exploited to abort with malicious abort codes that trigger incorrect error handling or bypass abort condition checks in calling code? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Break] [Loop Break Exploit] Can Break(Option<Label>) be used to break out of multiple nested loops incorrectly or break from non-existent labels, causing control flow confusion and executing unintended code? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Continue] [Loop Continue Bypass] Can Continue(Option<Label>) be exploited to skip important loop body code including resource drops or state updates, leaving resources in inconsistent states? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Dereference] [Null Dereference] Can Dereference(Box<Exp>) be exploited to dereference null or dangling pointers if reference validity isn't properly tracked, causing memory safety violations in the VM? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::BinopExp] [Arithmetic Overflow] Can BinopExp(Box<Exp>, BinOp, Box<Exp>) be exploited with arithmetic operations that overflow or underflow integer types, causing incorrect numerical calculations in financial operations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::UnaryExp] [Unary Operation Exploit] Can UnaryExp(UnaryOp, Box<Exp>) be exploited with negation or logical NOT operations on edge case values (e.g., MIN_INT negation) to cause overflow or unexpected behavior? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Borrow] [Borrow Lifetime Violation] Can Borrow(bool, Box<Exp>) be exploited to create references with incorrect mutability (mut flag) or references that outlive their referents, violating borrow checker guarantees? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Index] [Index Out of Bounds] Can Index(Box<Exp>, Box<Exp>) be exploited with out-of-bounds indices that aren't checked at compile time, causing buffer overruns or invalid memory access at runtime? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Cast] [Type Cast Exploit] Can Cast(Box<Exp>, Type) be exploited to perform invalid type casts (e.g., casting references to integers or vice versa) that violate type safety and cause memory corruption? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Annotate] [Annotation Override] Can Annotate(Box<Exp>, Type) be exploited to override the inferred type of an expression with an incompatible type annotation, causing type checking to pass but runtime execution to fail? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Test] [Variant Test Bypass] Can Test(Box<Exp>, Vec<Type>) be exploited to test for wrong variant types or skip variant validation, allowing code to handle enum variants incorrectly and access wrong variant data? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Spec] [Spec Block Injection] Can Spec(SpecId, BTreeSet<Name>, BTreeSet<Name>) be manipulated to inject malicious specification blocks that always verify successfully, bypassing Move Prover formal verification? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::Unit] [Unit Type Confusion] Can the Unit variant with trailing flag be exploited to create ambiguous empty tuples vs explicit unit values, causing return type confusion in functions? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Exp_::ExpList] [Expression List Arity Mismatch] Can ExpList(Vec<Exp>) be exploited with wrong number of expressions compared to expected tuple types, causing arity mismatches in function calls or assignments? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: LValue_] [LValue Type Confusion] Can LValue_ variants (Var, Unpack, PositionalUnpack) be exploited to unpack structs with wrong field types or field ordering, causing memory corruption when values are written to unpacked variables? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: LValue_::Unpack] [Struct Field Confusion] Can Unpack(ModuleAccess, Option<Vec<Type>>, Fields<LValue>, Option<DotDot>) be exploited to unpack fields in wrong order or with DotDot wildcard hiding important field validations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: LValue_::PositionalUnpack] [Positional Unpack Exploit] Can PositionalUnpack(ModuleAccess, Option<Vec<Type>>, LValueOrDotDotList) be exploited to unpack positional fields with wrong types by using DotDot to skip type checking certain positions? (High)"
]