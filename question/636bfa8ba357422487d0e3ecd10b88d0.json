[
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: get_min_readable_version()] [Race condition - Memory ordering] Can concurrent reads from get_min_readable_version() using SeqCst ordering race with writes in save_min_readable_version() or set_pruner_target_db_version(), causing validators to read stale min_readable_version values that allow queries to access already-pruned state data, resulting in inconsistent state reads across validators? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: save_min_readable_version()] [Atomicity violation] Is the two-step operation in save_min_readable_version() (AtomicVersion store at line 76 + database write at line 82-83) atomic? Can a crash between these operations cause min_readable_version in memory to be updated but not persisted to disk, leading to validators restarting with incorrect pruning progress and potentially re-pruning already pruned data or skipping necessary pruning? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Race condition - TOCTOU] Between lines 162-164 and 170-173, can concurrent calls to set_pruner_target_db_version() race when updating min_readable_version and calling set_target_db_version(), causing the pruner worker to receive inconsistent target versions that skip pruning certain version ranges, permanently leaking state data? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Race condition - TOCTOU] Can the TOCTOU between get_min_readable_version() at line 68 and set_pruner_target_db_version() at line 70 be exploited? If min_readable_version changes between check and use, could this cause pruning to be triggered incorrectly or skipped, leading to unbounded database growth or premature pruning? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: new()] [Initialization race] At line 130, min_readable_version is loaded from get_state_merkle_pruner_progress() but the pruner_worker may already be spawned at line 110-114. Can the worker thread start pruning before min_readable_version is properly initialized, causing it to use a default/zero value and prune all historical state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Integer underflow] At line 162, saturating_sub() is used to calculate min_readable_version from latest_version - prune_window. If an attacker can manipulate latest_version to be less than prune_window through state corruption or consensus manipulation, does saturating_sub() returning 0 cause all historical state to be incorrectly marked for pruning, leading to permanent data loss? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Integer overflow - Addition] At line 69, the condition checks 'latest_version >= min_readable_version + self.prune_window'. Can this addition overflow if min_readable_version is near u64::MAX? Would the overflow cause the comparison to always fail, permanently disabling pruning and leading to unbounded database growth that crashes validator nodes? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Version comparison logic] If latest_version is manipulated to wrap around u64::MAX, can the comparison at line 69 produce incorrect results? Could this cause pruning to execute at wrong times, either pruning too aggressively (data loss) or not pruning at all (resource exhaustion)? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Version arithmetic consistency] Does saturating_sub at line 162 maintain consistency with the addition check at line 69 in maybe_set_pruner_target_db_version()? Can edge cases around u64 boundaries cause these two functions to calculate different min_readable_version values, leading to state inconsistency? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: save_min_readable_version()] [Metrics overflow] At line 80, min_readable_version is cast to i64 for Prometheus metrics. Can this cast overflow if min_readable_version is >= i64::MAX, causing negative metric values that confuse monitoring systems and hide critical pruning failures? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: save_min_readable_version()] [Partial persistence] If write_pruner_progress() at line 82-83 fails but the AtomicVersion store at line 76 succeeds, does the function return an error? Can this inconsistency cause the in-memory state to diverge from persisted state, leading to validators restarting with incorrect pruning progress and either re-pruning valid data or failing to prune stale data? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: new()] [Recovery from corruption] At line 119-120, get_state_merkle_pruner_progress() uses expect('Must succeed'). If the database is corrupted and progress cannot be read, does this panic crash the validator node during startup? Can an attacker deliberately corrupt this metadata to cause repeated validator crashes and network liveness loss? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: new()] [Initialization inconsistency] If pruner_worker is initialized at lines 110-117 but crashes before min_readable_version is set at line 130, can the worker start with default/stale state? Could this cause the worker to prune based on incorrect progress values, leading to data loss or state corruption? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: save_min_readable_version()] [Database write failure handling] Does the function properly handle errors from write_pruner_progress() at lines 82-83? If the database write fails due to disk space exhaustion but returns Ok, can this cause silent progress loss where the pruner believes it has advanced but the database disagrees? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: init_pruner()] [Pruner creation failure] At line 140-141, StateMerklePruner::new() uses expect() to crash on failure. If pruner creation fails due to corrupted database state or schema version mismatch, does this prevent validator startup? Can an attacker exploit this to cause permanent validator unavailability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Premature pruning] If multiple threads call maybe_set_pruner_target_db_version() concurrently with different latest_version values, can race conditions cause the pruner to be triggered with an incorrect target version that's too high, pruning state that's still needed for ongoing queries, causing query failures and state inconsistency? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Pruning too much data] At line 162, if latest_version is corrupted to a small value, saturating_sub() will compute min_readable_version as 0, causing set_target_db_version() at line 173 to instruct the pruner to delete nearly all historical state. Can this be exploited to cause permanent data loss requiring hardfork recovery? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Pruning window bypass] Can the condition at line 69 be bypassed by manipulating latest_version to be exactly min_readable_version + prune_window - 1? Would this cause pruning to never trigger, leading to unbounded database growth and eventual node failure due to disk space exhaustion? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Double pruning] If set_pruner_target_db_version() is called multiple times rapidly before the pruner worker completes, can this cause the worker to receive multiple overlapping target versions, potentially pruning the same version ranges twice and corrupting the database? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: new()] [Configuration manipulation] If state_merkle_pruner_config.prune_window is set to 0 at line 128, does this cause all state to be immediately pruned? Can a malicious operator or compromised config file set prune_window to 0 to destroy all historical state and break state sync for new nodes? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Worker synchronization] At line 170-173, set_target_db_version() is called on pruner_worker without any synchronization. Can the worker be processing a previous target version while a new one is set, causing it to skip version ranges or process them out of order, leading to incomplete pruning and database inconsistency? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: is_pruning_pending()] [State query race] At lines 86-90, is_pruning_pending() queries worker state without locks. Can this race with worker thread operations, returning stale results that cause maybe_set_pruner_target_db_version() to make incorrect pruning decisions based on outdated pending status? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: is_pruner_enabled()] [State check race] At line 54-56, is_pruner_enabled() checks if pruner_worker is Some, but can the worker thread be dropping or in an error state while this returns true? Could this cause other code to assume pruning is active when it's actually stopped, leading to unbounded database growth? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: init_pruner()] [Worker spawn timing] At line 152-156, PrunerWorker::new() spawns a background thread. Can this thread start executing before the StateMerklePrunerManager is fully constructed at line 126-132, causing it to access partially initialized state? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_pruner_manager.rs] [Function: set_worker_target_version()] [Test-only function safety] At lines 92-98, set_worker_target_version() is marked cfg(test) but directly calls unwrap() at line 96. If this function is accidentally exposed in production builds through conditional compilation bugs, can it panic and crash validators during runtime? (Low)"
]