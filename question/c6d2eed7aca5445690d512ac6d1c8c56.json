[
  "[File: consensus/src/block_storage/block_store.rs] [Function: send_for_execution()] [Duplicate finality proof] Can calling send_for_execution twice with the same finality proof cause double execution or state corruption, since there's no idempotency check? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: try_send_for_execution()] [QC ordering assumption] The function sorts QCs by commit_info().round() - can QCs with the same round but different block IDs cause non-deterministic ordering and execution divergence across validators? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: try_send_for_execution()] [Recovery commit failures] If send_for_execution returns an error during recovery, it's logged but execution continues - can this leave the chain in a partially committed state that diverges from other validators? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: try_send_for_execution()] [Commit round filtering] Only QCs with round > commit_root().round() are committed - can this skip valid commits if commit_root is updated concurrently during iteration? (Medium)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: rebuild()] [State inconsistency during rebuild] Can calling rebuild() while send_for_execution() is in progress cause race conditions where some blocks are committed to the old tree and others to the new tree? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: rebuild()] [TC preservation race] The prev_2chain_htc is read without locking - can this read stale or torn TC data if another thread is updating it concurrently? (Medium)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: rebuild()] [Tree replacement atomicity] The rebuild replaces inner via Some(self.inner.clone()) - can readers accessing the old tree during replacement read inconsistent state spanning both trees? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Root QC version mismatch] The assertion allows version==0 for decoupled execution - can attackers exploit this to insert root blocks with dummy versions that don't match actual execution state? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Executed state ID bypass] The assertion allows executed_state_id == ACCUMULATOR_PLACEHOLDER_HASH - can this be exploited to skip state verification and insert blocks with incorrect execution results? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Accumulator recovery failure] The .expect('Failed to recover accumulator') will panic if InMemoryTransactionAccumulator creation fails - can corrupted storage cause validator crashes during startup? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Block insertion panic] The .unwrap_or_else panics on insertion failures during recovery - can malformed persisted blocks cause all validators to crash on restart, creating total liveness failure? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Round comparison vulnerability] Blocks with round <= root_block_round use insert_committed_block while others use insert_block - can blocks at exactly root_block_round cause inconsistencies? (Medium)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: build()] [Pipeline status initialization] The pre_commit_status is initialized with root_block_round - can this be exploited if the round value overflows or is manipulated? (Low)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: ordered_root()] [Dirty read vulnerability] Reading ordered_root() via inner.read() doesn't guarantee consistency with commit_root or window_root - can this cause race conditions in decision logic? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: commit_root()] [Root regression attack] Can the commit_root be updated to a lower round number due to race conditions, causing already-committed blocks to become uncommitted? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [BlockReader trait] [Inconsistent snapshots] Multiple calls to ordered_root(), commit_root(), and window_root() can return inconsistent states - can this be exploited for safety violations? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: path_from_ordered_root()] [Cycle attack] If the block tree contains cycles due to corruption or Byzantine blocks, can path traversal enter infinite loops causing validator hangs? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: path_from_ordered_root()] [Missing block in path] If blocks are pruned while computing the path, can this return an incomplete path leading to partial execution? (Medium)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: path_from_commit_root()] [Path divergence] Can paths from commit_root and ordered_root diverge in unexpected ways if roots are updated concurrently, breaking consensus invariants? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: vote_back_pressure()] [Integer overflow] The calculation 'ordered_round - commit_round' could overflow if rounds wrap around - can this disable back pressure and cause resource exhaustion? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: vote_back_pressure()] [Race condition in threshold check] Can ordered_root and commit_root be read in inconsistent states, causing incorrect back pressure decisions that either block valid proposals or allow DoS? (Medium)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: vote_back_pressure()] [Gauge update race] The counters.gauge update happens after the comparison - can this cause monitoring to show incorrect back pressure values? (Low)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: insert_block_inner() pipeline callback] [Use-after-free] The callback captures a weak pointer to block_tree - if the tree is freed but callbacks are still queued, can this cause use-after-free or double-free vulnerabilities? (Critical)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: insert_block_inner() pipeline callback] [Callback reentrancy] Can the commit_callback be invoked recursively if execution completes synchronously, causing stack overflow or lock reentrancy issues? (High)",
  "[File: consensus/src/block_storage/block_store.rs] [Function: insert_block_inner() pipeline callback] [Storage handle lifetime] The callback captures storage.clone() - can multiple concurrent callbacks cause contention or deadlocks on storage operations? (Medium)"
]