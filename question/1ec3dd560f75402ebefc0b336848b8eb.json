[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: spec_condition_kind()] [Condition Kind Confusion] Can spec condition kinds be confused to bypass verification requirements? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: spec_target()] [Target Confusion] Can spec block targets be manipulated to apply specifications to wrong functions or modules? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: pragma_property()] [Pragma Injection] Can pragma properties be injected to alter verification or compilation behavior? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: unbound_names_spec_block()] [Unbound Variable Exploitation] Can unbound names tracking be exploited to access variables from outer scopes that should be inaccessible? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: unbound_names_exp()] [Function Pointer Confusion] Can function pointer detection in unbound names confuse legitimate function calls with lambda captures? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: unbound_names_bind()] [Binding Removal Bypass] Can the removal of bound variables from unbound sets be bypassed to incorrectly flag variables as unbound? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: check_valid_local_name()] [Local Name Bypass] Can local variable name validation be bypassed using Unicode characters that appear lowercase but aren't? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: check_valid_module_member_name()] [Member Name Injection] Can module member names be crafted to bypass the uppercase validation for constants/structs using Unicode uppercase variants? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: check_restricted_name_all_cases()] [Reserved Name Bypass] Can reserved names like 'Self' or 'vector' be bypassed using alternative encodings or similar-looking characters? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: is_valid_struct_constant_or_schema_name()] [Naming Convention Bypass] Can the uppercase-first naming validation be bypassed to create structs/constants with invalid names? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: check_restricted_names()] [Builtin Name Collision] Can user-defined names collide with builtin function or type names, causing confusion or bypass checks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: Context::new()] [Context Initialization] Can the Context initialization be manipulated to set incorrect flags (is_source_definition, in_spec_context) that affect validation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: Context::set_current_module()] [Module Context Corruption] Can the current module context be corrupted to make private functions appear accessible? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: Context::set_to_outer_scope()] [Scope Restoration Attack] Can scope restoration after processing be exploited to leave aliases in incorrect states? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: Context::bind_exp_spec()] [Spec ID Collision] Can spec IDs be manipulated to create collisions between different spec blocks, causing verification confusion? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: module_is_in_aptos_libs()] [Library Detection Bypass] Can the Aptos library detection be bypassed to suppress warnings for malicious code pretending to be stdlib? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: script_()] [Script Visibility Bypass] Can script functions bypass the visibility restrictions to have public/friend visibility? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: script_()] [Native Script Injection] Can scripts be marked as native to bypass body definition requirements? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: script_()] [Script Constant Injection] Can script constants be used to bypass module constant visibility restrictions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: friend_()] [Friend Declaration Spoofing] Can friend declarations be manipulated to grant friend access to unauthorized modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: friend_()] [Duplicate Friend] Can duplicate friend declarations be used to confuse the friend access checking logic? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: constant_()] [Constant Value Manipulation] Can constant values be manipulated during expansion to differ from their declared values? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: constant_()] [Constant Type Confusion] Can constant signatures be crafted to cause type confusion between the declared type and actual value type? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: fields()] [Field Order Manipulation] Can the field ordering during field map construction be exploited to cause confusion between positional and named field access? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/translate.rs] [Function: fields()] [Field Index Corruption] Can field indices be corrupted during duplicate field checking, leading to wrong field access? (High)"
]