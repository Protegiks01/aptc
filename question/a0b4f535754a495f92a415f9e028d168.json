[
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Memory Leak] Does the into_iter().map().collect() chain at lines 56-59 properly clean up intermediate allocations, or can repeated transformations cause memory leaks in long-running verification services? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_type()] [Struct Field References] When transforming types, does the pass recursively handle struct fields that are immutable references, or can nested immutable references in struct definitions escape transformation causing type inconsistencies? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Conditional Transformation] Are the is_imm_ref checks at lines 92, 97, 101, 111, 121, 130 exhaustive, or can some immutable reference operations slip through unchanged causing the prover to analyze partially-transformed code? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: process()] [Error Handling] Does the process() method handle errors from the transformation gracefully, or can panics or errors cause the entire verification pipeline to crash without proper error reporting? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [BorrowLoc Semantics] When BorrowLoc becomes Assign with Copy at line 99, does this correctly model borrowing a local variable, or should it move the value for non-Copy types preventing illegal copies of resources? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [GetGlobal Resource Safety] When BorrowGlobal becomes GetGlobal, does the transformation ensure that the global resource is not simultaneously borrowed elsewhere, or can it create multiple copies of singleton resources violating Move's resource model? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Code Vector Ownership] After std::mem::take at line 53, is the original code vector properly deallocated, or can references to it persist causing use-after-free when transformed bytecode is later accessed? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Variant Tag Validation] For GetVariantField transformation at lines 110-120, does the pass verify the variant discriminant is valid for the enum type, or can out-of-range variant tags cause memory safety violations? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_type()] [Generic Type Handling] Does transform_type correctly handle generic type parameters within immutable references, or can incorrect type substitution cause the prover to verify code with wrong concrete types? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Emit Ordering] Does builder.emit maintain bytecode insertion order, or can out-of-order emission cause control flow corruption where jumps target wrong instruction offsets? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Struct: EliminateImmRefsProcessor] [Processor State] Is EliminateImmRefsProcessor stateless (empty struct at line 17), and if so, is it safe to reuse across multiple function transformations, or can shared mutable state cause race conditions? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: name()] [Pipeline Identification] Does the name() method return a unique identifier used for pipeline ordering, and can name collisions with other processors cause transformation passes to be skipped or run in wrong order? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Instruction Attributes] Are all bytecode attributes (line numbers, type annotations) preserved during transformation, or can attribute loss cause verification errors to be reported with incorrect source locations? (Low)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: run()] [Type Map Consistency] After transforming local_types, do all TempIndex references in the bytecode still correctly map to their types, or can index misalignment cause type confusion bugs? (Critical)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Reference Lifetime] Does the transformation properly model reference lifetimes, or can eliminating immutable refs cause the prover to miss lifetime violations where references outlive their referents? (High)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_type()] [Pointer Aliasing] When unwrapping Box<Type> at line 74, does the transformation create aliasing violations where multiple pointers reference the same type object, causing memory corruption? (Medium)",
  "[File: third_party/move/move-prover/bytecode-pipeline/src/eliminate_imm_refs.rs] [Function: transform_bytecode()] [Abort Block Handling] Does the transformation correctly handle bytecode in abort/exception blocks, or can control flow through exceptional paths produce incorrect verification results? (Medium)"
]