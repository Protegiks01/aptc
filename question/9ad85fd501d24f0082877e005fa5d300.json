[
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Training wheels signature] Does the training wheels signature in ZeroKnowledgeSig properly cover the ZKP enum discriminant, or could an attacker substitute a different proof type without invalidating the training wheels signature? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Transaction binding] When ZKP is included in TransactionAndProof, does the proof get properly bound to the specific transaction, or could an attacker reuse a valid ZKP from one transaction in a different transaction? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Optional proof handling] In TransactionAndProof where proof is Option<ZKP>, are there code paths that accept None proofs when they should require Some, enabling authentication bypass? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Ephemeral signature malleability] Does the ephemeral signature properly cover the ZKP proof to prevent malleability, or could an attacker modify the proof after the ephemeral signature is created, invalidating the security guarantee? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Gas metering] Is the deserialization and validation of ZKP enums properly gas-metered, or could an attacker include expensive-to-deserialize proofs that consume excessive resources before gas limits are checked? (Medium)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Size limits] Does the ZKP enum enforce size limits consistent with KeylessSignature::MAX_LEN (4000 bytes), or could oversized proofs bypass size checks by being validated too late in the pipeline? (Medium)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Feature flag bypass] Could an attacker exploit inconsistencies in how different nodes check the is_zk_keyless_enabled() feature flag by sending ZKP-based transactions that some nodes accept and others reject, causing state divergence? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Graceful degradation] If the ZK keyless feature is disabled via feature flags, does the system properly reject all ZKP enums, or could cached or pre-validated ZKP values bypass the feature flag check? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Chain ID binding] Does the ZKP proof properly include chain ID in the public inputs, or could a valid proof from testnet be replayed on mainnet, enabling cross-chain replay attacks? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Nonce binding] Is the ZKP proof properly bound to the transaction sequence number, or could an attacker reuse a proof across multiple transactions from the same account? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [VK mismatch] Could an attacker exploit the time window during which the on-chain Groth16 verification key is updated, submitting ZKP proofs that were valid under the old VK but shouldn't be under the new one? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [VK substitution] If PreparedVerifyingKey is fetched from on-chain config, could a malicious governance proposal substitute a weak VK that accepts invalid proofs, enabling authentication bypass? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Public inputs hash] When get_public_inputs_hash() is called during verification, does it properly hash all relevant ZKP context, or could an attacker manipulate unhashed fields to change proof semantics without affecting the hash? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Hash collision resistance] Is the public inputs hash using a collision-resistant hash function, or could an attacker find two different input sets that hash to the same value, enabling proof substitution attacks? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Error propagation] When proof verification fails, does the error properly propagate through the ZKP enum wrapper, or could error handling bugs cause verification failures to be silently ignored? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Panic vs Error] Does the ZKP implementation properly return errors rather than panicking, or could malformed proofs trigger panics that crash validator nodes? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Partial verification] Could an attacker exploit partial verification states where a ZKP is partially validated but not fully verified, causing it to be incorrectly cached as valid? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Proof malleability] Even if the underlying Groth16Proof is non-malleable, could the enum wrapper introduce malleability if multiple serializations of the same proof are accepted? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Subgroup checks] When the ZKP is unwrapped to extract Groth16Proof, does the verification perform proper subgroup membership checks on the G1/G2 points, or could invalid curve points bypass verification? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Zero proof] Could an attacker submit a ZKP containing all-zero G1/G2 points that might pass some validation checks but represent an invalid proof? (High)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Concurrent verification] If multiple threads verify the same ZKP concurrently, could race conditions in the verification logic cause inconsistent results where some threads accept and others reject the proof? (Medium)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Cache poisoning] If ZKP verification results are cached based on proof hash, could an attacker poison the cache by submitting many invalid proofs before a valid one, causing cache eviction of valid proofs? (Medium)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Hard fork compatibility] If a hard fork introduces changes to ZKP validation logic, could transactions with ZKP proofs created before the fork become invalid, locking user funds permanently? (Critical)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [Proof aging] Does the system properly handle ZKP proofs that were valid when created but become invalid due to on-chain parameter changes (e.g., max_exp_horizon_secs), or could this create unexpected transaction rejections? (Medium)",
  "[File: aptos-core/types/src/keyless/zkp_sig.rs] [Enum: ZKP] [JWK updates] When JWKs are updated on-chain, could ZKP proofs become invalid if they reference old JWK values, and is there proper handling for this transition period? (High)"
]