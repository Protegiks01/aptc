[
  "[File: mempool/src/shared_mempool/tasks.rs] [Function: process_config_update()] [Counter Increment Race] Can VM_RECONFIG_UPDATE_FAIL_COUNT.inc() (line 777) race with concurrent\n\n### Citations\n\n**File:** mempool/src/shared_mempool/tasks.rs (L1-932)\n```rust\n// Copyright © Aptos Foundation\n// Parts of the project are originally copyright © Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n//! Tasks that are executed by coordinators (short-lived compared to coordinators)\nuse super::types::MempoolMessageId;\nuse crate::{\n    core_mempool::{CoreMempool, TimelineState},\n    counters,\n    logging::{LogEntry, LogEvent, LogSchema},\n    network::{BroadcastError, BroadcastPeerPriority, MempoolSyncMsg},\n    shared_mempool::{\n        types::{\n            notify_subscribers, ScheduledBroadcast, SharedMempool, SharedMempoolNotification,\n            SubmissionStatusBundle,\n        },\n        use_case_history::UseCaseHistory,\n    },\n    thread_pool::{IO_POOL, VALIDATION_POOL},\n    QuorumStoreRequest, QuorumStoreResponse, SubmissionStatus,\n};\nuse anyhow::Result;\nuse aptos_config::{config::TransactionFilterConfig, network_id::PeerNetworkId};\nuse aptos_consensus_types::common::RejectedTransactionSummary;\nuse aptos_crypto::HashValue;\nuse aptos_infallible::{Mutex, RwLock};\nuse aptos_logger::prelude::*;\nuse aptos_mempool_notifications::CommittedTransaction;\nuse aptos_metrics_core::HistogramTimer;\nuse aptos_network::application::interface::NetworkClientInterface;\nuse aptos_storage_interface::state_store::state_view::db_state_view::LatestDbStateCheckpointView;\nuse aptos_types::{\n    account_address::AccountAddress,\n    mempool_status::{MempoolStatus, MempoolStatusCode},\n    on_chain_config::{OnChainConfigPayload, OnChainConfigProvider, OnChainConsensusConfig},\n    transaction::{ReplayProtector, SignedTransaction},\n    vm_status::{DiscardedVMStatus, StatusCode},\n};\nuse aptos_vm_validator::vm_validator::{get_account_sequence_number, TransactionValidation};\nuse futures::{channel::oneshot, stream::FuturesUnordered};\nuse rayon::prelude::*;\nuse std::{\n    cmp,\n    sync::Arc,\n    time::{Duration, Instant},\n};\nuse tokio::runtime::Handle;\n// ============================== //\n//  broadcast_coordinator tasks  //\n// ============================== //\n\n// The sample rate for broadcast events and errors\nconst BROADCAST_ERROR_LOG_SAMPLE_SECS: u64 = 1;\nconst BROADCAST_EVENT_LOG_SAMPLE_SECS: u64 = 5;\n\n/// Attempts broadcast to `peer` and schedules the next broadcast.\npub(crate) async fn execute_broadcast<NetworkClient, TransactionValidator>(\n    peer: PeerNetworkId,\n    backoff: bool,\n    smp: &mut SharedMempool<NetworkClient, TransactionValidator>,\n    scheduled_broadcasts: &mut FuturesUnordered<ScheduledBroadcast>,\n    executor: Handle,\n) where\n    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,\n    TransactionValidator: TransactionValidation,\n{\n    let network_interface = &smp.network_interface.clone();\n    counters::shared_mempool_broadcast_event_inc(counters::RUNNING_LABEL, peer.network_id());\n\n    // If there's no connection, don't bother to broadcast\n    if network_interface.sync_states_exists(&peer) {\n        if let Err(err) = network_interface\n            .execute_broadcast(peer, backoff, smp)\n            .await\n        {\n            counters::shared_mempool_broadcast_event_inc(err.get_label(), peer.network_id());\n            match err {\n                BroadcastError::NoTransactions(_) => {\n                    sample!(\n                        SampleRate::Duration(Duration::from_secs(BROADCAST_EVENT_LOG_SAMPLE_SECS)),\n                        debug!("
]