[
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: put_state_kv_index()] [Unwrap on batch put] Both schema put operations use .unwrap() - if the put fails (disk full, corruption), will this crash the node during commit causing data loss? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: put_stale_state_value_index_for_shard()] [Old entry version] When old_entry.is_occupied(), it calls expect_value_version() - can corrupted cache entries with invalid versions cause incorrect stale indices to be created? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: shard_state_value_batch()] [Shard ID validation] The function asserts shard_id < NUM_STATE_SHARDS - can an attacker craft StateKeys with manipulated get_shard_id() to bypass this check and write to arbitrary memory locations? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: shard_state_value_batch()] [Expect on batch put] The code uses .expect() on schema batch put operations - if batches are full or corrupted, will this crash during state snapshot restore causing incomplete restores? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: shard_state_value_batch()] [Sharding enable race] The function checks enable_sharding once per batch - if this setting changes mid-batch, can values be written to wrong schemas within the same batch? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: shard_state_value_batch()] [Key hash collision] When enable_sharding is true, values are indexed by key.hash() - can hash collisions cause different keys to overwrite each other in storage? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: shard_state_value_batch()] [Version as secondary key] Values are stored with (key/hash, version) tuples - can an attacker create many versions of the same key to fill storage with stale entries? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_root_hash()] [Version tampering] The function directly calls state_merkle_db.get_root_hash(version) without validation - can an attacker query arbitrary versions to get root hashes of intermediate states for analysis or attack planning? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_state_key_and_value_iter()] [Iterator resource leak] The function creates a JellyfishMerkleIterator and maps over it - if the caller doesn't consume the full iterator, can this leak file handles or memory? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_state_key_and_value_iter()] [Value version mismatch] The iterator returns (key, version) pairs from merkle tree but fetches values with expect_value_by_version - can this fail if merkle tree and kv store are out of sync? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_with_proof()] [Chunk size overflow] The function takes chunk_size as usize and uses it in arithmetic (chunk_size.len() - 1 + first_index) - can overflow cause incorrect proof generation? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_with_proof()] [Empty chunk vulnerability] The function ensures !state_key_values.is_empty() - but if first_index is beyond the state size, can this return misleading empty chunk errors? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_iter()] [Iterator take() overflow] The iterator uses .take(chunk_size) - for very large chunk_size values, can this cause memory exhaustion or long blocking operations? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_proof()] [Last index calculation] The code calculates last_index = state_key_values.len() - 1 + first_index as u64 - can this overflow u64 for very large inputs causing incorrect proof ranges? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_proof()] [First/last key extraction] The function uses .first().expect() and .last().expect() after checking is_empty - can the vector be mutated between these calls causing panics? (Low)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_range_proof()] [Rightmost key validation] The function takes rightmost_key without validation - can an attacker provide invalid hash values to cause incorrect or missing proof generation? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_value_chunk_proof()] [Root hash timing] The function gets root_hash at the end - if the version is pruned between getting the proof and getting root_hash, can this create invalid proofs? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_snapshot_receiver()] [Expected root mismatch] The function takes expected_root_hash but doesn't immediately verify it matches actual root - can an attacker provide false expected_root_hash to cause nodes to sync to incorrect state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_snapshot_receiver()] [Async commit disabled] The function hardcodes async_commit=false - does this cause synchronous disk I/O during snapshot restore making nodes vulnerable to slowdown attacks? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_snapshot_receiver()] [StateSnapshotRestoreMode] The function uses StateSnapshotRestoreMode::Default without configuration - can different nodes use different restore modes causing state divergence? (High)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_all_jmt_nodes_referenced()] [Test function in production] This is marked #[cfg(test)] but JellyfishMerkleTree methods may be callable - can this be exploited to enumerate all nodes for cryptanalysis or attack planning? (Low)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_all_jmt_nodes()] [Iterator without bounds] The function iterates over all JellyfishMerkleNode entries without limits - can this consume unbounded memory or cause node hangs in production if test gates fail? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: get_all_jmt_nodes()] [Shard iteration] The function iterates NUM_STATE_SHARDS when sharding_enabled - can shard count changes during iteration cause missing nodes or double-counting? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: reset()] [Buffered state quit race] The function calls buffered_state.lock().quit() before recreating - can async commits still in flight during quit() be lost causing missing state updates? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/state_store/mod.rs] [Function: reset()] [Lock order deadlock] The function locks buffered_state twice (quit and assignment) - can concurrent reset() calls or commits cause deadlocks freezing the node? (High)"
]