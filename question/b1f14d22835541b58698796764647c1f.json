[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/control_flow.rs] [Function: verify_reducibility()] [Verification order] The doc at lines 9-12 mentions this enables predictable abstract interpretation - if this verification is skipped or bypassed, could abstract interpreter hang indefinitely? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/control_flow.rs] [Function: verify_reducibility()] [Reducibility guarantee] Does passing reducibility check GUARANTEE that abstract interpretation will complete in polynomial time, or could other factors still cause exponential blowup? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/control_flow.rs] [Function: verify_function()] [Function call validation] Does control flow verification check that Branch/Call targets are valid function indices, or could out-of-bounds targets pass this check? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/src/control_flow.rs] [Function: verify_\n\n### Citations\n\n**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L1-182)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\n//! This module implements control flow checks.\n//!\n//! For bytecode versions 6 and up, the following properties are ensured:\n//! - The CFG is not empty and the last block ends in an unconditional jump, so it's not possible to\n//!   fall off the end of a function.\n//! - The CFG is reducible (and optionally max loop depth is bounded), to limit the potential for\n//!   pathologically long abstract interpretation runtimes (through poor choice of loop heads and\n//!   back edges).\n//!\n//! For bytecode versions 5 and below, delegates to `control_flow_v5`.\nuse crate::{\n    control_flow_v5,\n    loop_summary::{LoopPartition, LoopSummary},\n    meter::Meter,\n    verifier::VerifierConfig,\n};\nuse move_binary_format::{\n    access::{ModuleAccess, ScriptAccess},\n    binary_views::FunctionView,\n    errors::{PartialVMError, PartialVMResult},\n    file_format::{\n        CodeOffset, CodeUnit, CompiledScript, FunctionDefinition, FunctionDefinitionIndex,\n    },\n    CompiledModule,\n};\nuse move_core_types::vm_status::StatusCode;\nuse std::collections::BTreeSet;\n\n/// Perform control flow verification on the compiled function, returning its `FunctionView` if\n/// verification was successful.\npub fn verify_function<'a>(\n    verifier_config: &'a VerifierConfig,\n    module: &'a CompiledModule,\n    index: FunctionDefinitionIndex,\n    function_definition: &'a FunctionDefinition,\n    code: &'a CodeUnit,\n    _meter: &mut impl Meter, // TODO: metering\n) -> PartialVMResult<FunctionView<'a>> {\n    let function_handle = module.function_handle_at(function_definition.function);\n\n    if module.version() <= 5 {\n        control_flow_v5::verify(verifier_config, Some(index), code)?;\n        Ok(FunctionView::function(module, index, code, function_handle))\n    } else {\n        verify_fallthrough(Some(index), code)?;\n        let function_view = FunctionView::function(module, index, code, function_handle);\n        verify_reducibility(verifier_config, &function_view)?;\n        Ok(function_view)\n    }\n}\n\n/// Perform control flow verification on the compiled script, returning its `FunctionView` if\n/// verification was successful.\npub fn verify_script<'a>(\n    verifier_config: &'a VerifierConfig,\n    script: &'a CompiledScript,\n) -> PartialVMResult<FunctionView<'a>> {\n    if script.version() <= 5 {\n        control_flow_v5::verify(verifier_config, None, &script.code)?;\n        Ok(FunctionView::script(script))\n    } else {\n        verify_fallthrough(None, &script.code)?;\n        let function_view = FunctionView::script(script);\n        verify_reducibility(verifier_config, &function_view)?;\n        Ok(function_view)\n    }\n}\n\n/// Check to make sure that the bytecode vector is non-empty and ends with a branching instruction.\nfn verify_fallthrough(\n    current_function_opt: Option<FunctionDefinitionIndex>,\n    code: &CodeUnit,\n) -> PartialVMResult<()> {\n    let current_function = current_function_opt.unwrap_or(FunctionDefinitionIndex(0));\n    match code.code.last() {\n        None => Err(PartialVMError::new(StatusCode::EMPTY_CODE_UNIT)),\n        Some(last) if !last.is_unconditional_branch() => {\n            Err(PartialVMError::new(StatusCode::INVALID_FALL_THROUGH)\n                .at_code_offset(current_function, (code.code.len() - 1) as CodeOffset))\n        },\n        Some(_) => Ok(()),\n    }\n}\n\n/// Test that `function_view`'s control-flow graph is reducible using Tarjan's algorithm [1].\n/// Optionally test loop depth bounded by `verifier_config.max_loop_depth`.\n///\n/// A CFG, `G`, with starting block `s` is reducible if and only if [2] any of the following\n/// equivalent properties hold:\n///\n///  1. G has a unique set of back-edges `u -> v` where `v` dominates `u`, that corresponds to the\n///     set of back-edges for any depth-first spanning tree of G.\n///\n///  2. Every loop in G contains a unique node `h` (the"
]