[
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Variant: GetStorageServerSummary] [Summary cache poisoning] Can rapidly requesting server summaries cause the server to constantly regenerate summary data, wasting CPU cycles and causing validator slowdown? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All request types] [Per-request resource limits] Do all request types have consistent resource limits (memory, CPU, I/O), or can attackers identify request types with weak limits and focus attacks there? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All request types] [Amplification factor] Can small requests trigger disproportionately large responses or processing costs, allowing bandwidth or CPU amplification attacks? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All request types] [Request queueing] If the server queues requests before processing, can attackers fill the queue with expensive requests to block other peers from synchronizing? (High)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All request types] [Concurrent request limit] Can a single Byzantine peer send hundreds of concurrent requests to monopolize server threads or connections, preventing other peers from accessing the service? (Critical)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Function: get_label() + use_compression] [Label suffix collision] Can the COMPRESSION_SUFFIX_LABEL (line 27) collide with legitimate request labels, causing metrics or logging confusion? (Low)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [Function: get_label() + use_compression] [Metric cardinality explosion] Can attackers send requests with many different DataRequest variants combined with varying use_compression flags to create metric label combinations that exhaust monitoring system capacity? (Medium)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All structs] [Clone implementation] Does the Clone derive allow requests to be duplicated in ways that could cause double-processing or state inconsistencies if the same request is handled multiple times? (Low)",
  "[File: aptos-core/state-sync/storage-service/types/src/requests.rs] [All structs] [Debug derive] Can Debug output of requests in logs accidentally leak sensitive information like proof versions or\n\n### Citations\n\n**File:** state-sync/storage-service/types/src/requests.rs (L1-464)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::COMPRESSION_SUFFIX_LABEL;\nuse aptos_types::transaction::Version;\nuse serde::{Deserialize, Serialize};\n\n/// A storage service request.\n#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]\npub struct StorageServiceRequest {\n    pub data_request: DataRequest, // The data to fetch from the storage service\n    pub use_compression: bool,     // Whether or not the client wishes data to be compressed\n}\n\nimpl StorageServiceRequest {\n    pub fn new(data_request: DataRequest, use_compression: bool) -> Self {\n        Self {\n            data_request,\n            use_compression,\n        }\n    }\n\n    /// Returns a summary label for the request\n    pub fn get_label(&self) -> String {\n        let mut label = self.data_request.get_label().to_string();\n        if self.use_compression {\n            label += COMPRESSION_SUFFIX_LABEL;\n        }\n        label\n    }\n}\n\n/// A single data request.\n#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]\npub enum DataRequest {\n    GetEpochEndingLedgerInfos(EpochEndingLedgerInfoRequest), // Fetches a list of epoch ending ledger infos\n    GetNewTransactionOutputsWithProof(NewTransactionOutputsWithProofRequest), // Optimistically fetches new transaction outputs\n    GetNewTransactionsWithProof(NewTransactionsWithProofRequest), // Optimistically fetches new transactions\n    GetNumberOfStatesAtVersion(Version), // Fetches the number of states at the specified version\n    GetServerProtocolVersion,            // Fetches the protocol version run by the server\n    GetStateValuesWithProof(StateValuesWithProofRequest), // Fetches a list of states with a proof\n    GetStorageServerSummary,             // Fetches a summary of the storage server state\n    GetTransactionOutputsWithProof(TransactionOutputsWithProofRequest), // Fetches a list of transaction outputs with a proof\n    GetTransactionsWithProof(TransactionsWithProofRequest), // Fetches a list of transactions with a proof\n    GetNewTransactionsOrOutputsWithProof(NewTransactionsOrOutputsWithProofRequest), // Optimistically fetches new transactions or outputs\n    GetTransactionsOrOutputsWithProof(TransactionsOrOutputsWithProofRequest), // Fetches a list of transactions or outputs with a proof\n    SubscribeTransactionOutputsWithProof(SubscribeTransactionOutputsWithProofRequest), // Subscribes to transaction outputs with a proof\n    SubscribeTransactionsOrOutputsWithProof(SubscribeTransactionsOrOutputsWithProofRequest), // Subscribes to transactions or outputs with a proof\n    SubscribeTransactionsWithProof(SubscribeTransactionsWithProofRequest), // Subscribes to transactions with a proof\n\n    // All the requests listed below are for transaction data v2 (i.e., transactions with auxiliary information).\n    // TODO: eventually we should deprecate all the old request types.\n    GetTransactionDataWithProof(GetTransactionDataWithProofRequest), // Fetches transaction data with a proof\n    GetNewTransactionDataWithProof(GetNewTransactionDataWithProofRequest), // Optimistically fetches new transaction data with a proof\n    SubscribeTransactionDataWithProof(SubscribeTransactionDataWithProofRequest), // Subscribes to transaction data with a proof\n}\n\nimpl DataRequest {\n    /// Returns a summary label for the request\n    pub fn get_label(&self) -> &'static str {\n        match self {\n            Self::GetEpochEndingLedgerInfos(_) =>"
]