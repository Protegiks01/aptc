[
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Resume point forgery] The previous_key_hash() from state receiver determines resume point - can an attacker manipulate this to skip critical chunks during restore? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Skip_while attack] The skip_while(|chunk| chunk.last_key <= resume_point) logic can skip chunks - can an attacker set resume_point to u64::MAX to skip all chunks? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Resume inconsistency] If resume_point is between chunk boundaries, can the restore process apply partial state that violates atomicity guarantees? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Chunk count mismatch] The chunks_to_add can differ from total_chunks - can this cause the restore to report success while missing critical state data? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Resume point persistence] If previous_key_hash() returns stale data from a previous restore, can this cause chunks to be skipped incorrectly? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Validation bypass] The validate_modules flag can be false, allowing unvalidated Move modules to be restored - can this introduce malicious bytecode into the state? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Feature flag bypass] The validation uses Features::default() instead of actual on-chain features - can this accept modules that should be rejected by current feature flags? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Error logging only] Module validation errors are only logged with error!() but don't fail the restore - can invalid modules be restored into the state tree? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Deserialization failure logging] CompiledModule deserialization failures are logged but don't stop restore - can corrupted module bytes be written to state? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Verification config mismatch] The aptos_prod_verifier_config() may not match the config at backup time - can this cause valid modules to be rejected or invalid ones accepted? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Gas version mismatch] Using LATEST_GAS_FEATURE_VERSION may differ from the version at backup time - can this cause verification inconsistencies? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::validate_modules()] [Path type confusion] Can non-Code paths be misidentified as module code, causing arbitrary state values to undergo module validation? (Low)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Race condition in receiver] The Arc<Mutex<Option<StateSnapshotReceiver>>> is accessed from multiple tasks - can lock contention cause deadlocks or incorrect chunk ordering? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Chunk reordering] The buffered_x(con * 2, con) allows chunks to be processed out of order - can this violate the sequential index assumption and corrupt state? (Critical)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Spawn task panic] If tokio::spawn tasks panic during chunk processing, are errors properly propagated or does restore silently succeed with partial state? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Await order violation] The nested .await? on spawn results - can task cancellation cause chunks to be skipped without error detection? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Module validation blocking] The spawn_blocking for module validation can block tokio runtime - can this cause thread starvation and hang the restore process? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [State receiver blocking] The spawn_blocking for add_chunk can hold the mutex - can this cause lock contention that serializes concurrent chunk processing? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Finish race condition] The receiver.lock().take().unwrap().finish() is called at the end - can concurrent access cause the receiver to be taken twice leading to panics? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::read_state_value()] [Memory exhaustion] The chunk vector accumulates all (StateKey, StateValue) pairs in memory - can extremely large chunks cause OOM crashes? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::read_state_value()] [Unbounded read] The while loop reads record_bytes without size limits - can malicious backup data cause infinite memory allocation? (High)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Concurrent download exhaustion] The concurrent_downloads parameter controls buffered_x - can excessive concurrency exhaust memory or file descriptors? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Proof memory overhead] Proofs are loaded entirely into memory with load_bcs_file - can extremely large proofs cause OOM? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Task accumulation] Spawned tasks accumulate in buffered stream - can slow chunk processing cause unbounded task queue growth? (Medium)",
  "[File: storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs] [Function: StateSnapshotRestoreController::run_impl()] [Restore mode bypass] Different StateSnapshotRestoreMode values affect security - can an attacker force use of a less secure mode? (High)"
]