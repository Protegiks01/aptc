[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecPopBack] [Empty vector pop] At line 1477, does VecPopBack validate vector is non-empty, or can attackers pop from empty vectors causing underflow or returning uninitialized memory? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecUnpack] [Unpack count mismatch] At line 1485, can attackers provide num that doesn't match actual vector length, causing partial unpacking or accessing uninitialized elements? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecSwap] [Identical index swap] At line 1495, does VecSwap handle swapping element at same index, or can this cause aliasing issues with mutable references? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() Freeze builtin] [Reference type mismatch] At line 1504, can attackers freeze non-mutable references or values that aren't references, bypassing borrow checking type safety? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() ToU8/ToU16/ToU32/ToU64/ToU128/ToU256] [Cast overflow] At lines 1509-1537, do cast operations validate source value fits in target type, or can attackers cast large values to smaller types with truncation/wraparound? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() ModuleFunctionCall] [Type actual arity mismatch] At line 1550, can attackers provide type_actuals with wrong arity that doesn't match function's type parameters, bypassing generic instantiation checks? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() ModuleFunctionCall] [Stack manipulation] At lines 1562-1566, does the loop correctly pop type actuals and push return value, or can attackers manipulate stack accounting to leave stack in inconsistent state? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Constant type layout] At line 1572, can attackers provide Reference or TypeParameter types that should be rejected, causing type_layout to fail and allowing unsupported constant types? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Struct constant bypass] At line 1588, does the TODO comment indicate struct constants aren't properly validated, allowing attackers to serialize malformed struct constants that corrupt memory? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Serialization failure] At line 1594, can Constant::serialize_constant return None for valid-looking constants, causing format_err that gets improperly handled allowing invalid constants into constant_pool? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_constant()] [Vector nesting depth] Can deeply nested Vector types in constants cause stack overflow during recursive type_layout calls, enabling DoS through malicious constant definitions? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [Label remapping timing] At line 1631, does remap_branch_offsets get called after all bytecode is generated, or can partially compiled bytecode have incorrect branch offsets? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [Nop label abuse] At lines 1662-1665, can attackers generate multiple Nop instructions with same label, causing record_nop_label to overwrite previous mappings and corrupt source maps? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [LdConst type mismatch] At line 1685, can attackers provide (ty, v) pairs where v's type doesn't match ty, causing compile_constant to generate invalid constants that bypass type checking? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [Named constant manipulation] At line 1688, can attackers reference named constants that were defined with different types than expected, causing type confusion when loaded? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode()] [Local variable aliasing] At lines 1689-1691, can CopyLoc/MoveLoc/StLoc reference the same local with different expected types in different contexts, bypassing type safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() Call case] [Generic function instantiation] At lines 1692-1705, can attackers provide type_actuals that don't satisfy function's type parameter constraints, generating CallGeneric with invalid instantiation? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() Pack/Unpack cases] [Generic struct confusion] At lines 1707-1735, can mixing empty and non-empty tys cause wrong instruction generation (Pack vs PackGeneric), enabling type confusion in generic struct operations? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_bytecode() MutBorrowField/ImmBorrowField] [Field handle validation] At lines 1746-1788, does field offset lookup validate the field belongs to the struct being borrowed from, or can attackers borrow fields across unrelated struct types? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Self-module confusion] At line 418, can attackers manipulate self_name (ModuleName::module_self()) to reference wrong module, causing struct/function lookups to resolve to external dependencies? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Friend declaration bypass] At line 414, can malicious friend_decls include the module itself or create circular friendships that bypass access control? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Struct pre-declaration] At lines 430-438, can attackers declare struct handles with wrong abilities or type parameters, then later define them differently, causing ability mismatch? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Function signature mismatch] At lines 447-450, can function declarations provide signatures that don't match their implementations, bypassing type checking at call sites? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Empty module generation] Can attackers compile modules with empty struct_defs and function_defs that still get included in dependencies, potentially causing linker confusion? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_script()] [Main function bypass] At line 348, can attackers define script.main as native function, bypassing execution and potentially causing undefined behavior? (High)"
]