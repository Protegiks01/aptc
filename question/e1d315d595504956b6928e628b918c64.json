[
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Missing mapping] Lines 120-131 attempt to get pool_address from inactive_pool_to_staking_pool mapping, falling back to database query - can race conditions cause the mapping to be incomplete, forcing expensive DB lookups that slow the indexer? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_write_table_item()] [Stale mapping] If inactive_pool_to_staking_pool mapping is built from current transaction but references pools from older transactions, could stale mappings cause incorrect pool_address associations? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_share_from_delete_table_item()] [Mapping inconsistency] Lines 204-225 use fallback database query when mapping lookup fails - could divergence between in-memory mappings and database state cause balance tracking inconsistencies? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Mapping order dependency] Lines 326-350 build mappings in first pass, then use them in second pass - if WriteSetChanges are processed out of order, could mappings be incomplete when needed? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [HashMap overwrites] Lines 334, 340, 347 use .extend() which overwrites duplicate keys - if multiple delegation pools share table handles, could later entries silently overwrite earlier ones causing data loss? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Database staleness] Lines 305-306 query database for staking pool address, but what if the database hasn't been updated yet with latest transaction? Could stale reads return wrong pool addresses? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_pool_to_staking_pool_mapping()] [Single pool assumption] Lines 243-258 return HashMap with single entry - if a transaction affects multiple delegation pools, could mappings be incomplete? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_inactive_pool_to_staking_pool_mapping()] [Single pool assumption] Lines 262-277 return single-entry HashMap - does this correctly handle transactions that update multiple pools simultaneously? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Race condition] Lines 303-310 retry query with sleep delays, but if concurrent transactions are being processed, could one thread read stale data while another is still writing? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Deadlock potential] The function acquires mutable database connection at line 299 - if multiple threads call this simultaneously, could lock contention cause deadlocks or severe performance degradation? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: CurrentDelegatorBalanceQuery::get_by_inactive_share_handle()] [SQL injection] Line 419 uses parent_table_handle in diesel filter - is the input properly sanitized, or could malicious table_handle values inject SQL? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_staking_pool_from_inactive_share_handle()] [Retry timing attack] Lines 303-310 use fixed QUERY_RETRY_DELAY_MS - can attackers exploit predictable retry timing to cause systematic query failures by timing database operations? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Non-atomic processing] Lines 317-410 process multiple WriteSetChanges in sequence - if the indexer crashes mid-processing, could partial state be committed to database causing inconsistent delegator balances? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Connection reuse] The conn parameter is passed to multiple nested functions - can connection state corruption in one call affect subsequent calls, causing cascading failures? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: CurrentDelegatorBalanceQuery::get_by_inactive_share_handle()] [First result assumption] Line 420 uses .first() which returns first matching row - if database has duplicate entries, could inconsistent results be returned? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Transaction type limitation] Line 326 only processes UserTransaction types - are GenesisTransaction, BlockMetadataTransaction, or StateCheckpointTransaction types ignored, potentially missing critical balance updates? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Version extraction] Line 327 extracts txn_version from user_txn.info.version - is integer overflow checked when casting u64 to i64, or could large version numbers cause negative values? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Duplicate version handling] Line 353 reuses txn_version from outer scope - if transaction processing is called multiple times with same version, could duplicate primary keys cause database constraint violations? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [WriteSetChange ordering] Lines 328-350 assume WriteResource changes appear before WriteTableItem changes - if ordering is violated, could mappings be incomplete when processing table items? (High)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Change type filtering] Lines 354-396 only handle DeleteTableItem and WriteTableItem - are WriteResource, DeleteResource, WriteModule changes ignored, potentially missing balance-affecting events? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [HashMap key collision] Lines 398-405 insert into current_delegator_balances HashMap using (delegator_address, pool_address, pool_type) as key - if same delegator has multiple balance updates in one transaction, are only latest changes kept, potentially losing intermediate states? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Empty result handling] Function returns empty HashMap if no UserTransaction - should caller validate non-empty result, or could empty returns be misinterpreted as successful processing? (Low)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: from_transaction()] [Resource leak] Multiple nested loops and function calls at lines 328-407 - are database connections properly released if early return or panic occurs? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Address normalization] Line 67 calls standardize_address on write_table_item.handle - does standardization handle all valid Move address formats, or could some addresses fail to normalize causing lookup failures? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/stake_models/delegator_balances.rs] [Function: get_active_share_from_write_table_item()] [Key extraction] Line 71 extracts key as delegator_address - does this properly handle cases where key is not an address (e.g., struct or vector), potentially causing type confusion? (High)"
]