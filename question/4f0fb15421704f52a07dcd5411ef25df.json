[
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All u64 version fields] [Integer Arithmetic Overflow] Across all structs deserializing version numbers (lines 265, 273, 787, 1100, 1265, 1460, 1600, 1760, 2190, 2413, 2881, 3112, 3234), can attackers provide values near u64::MAX that cause overflow in subsequent range calculations? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All u64 chain_id fields] [Chain ID Overflow] Can chain_id values (lines 773, 1251, 1586, 1746, 3234) at u64::MAX cause overflow or confusion with special sentinel values used internally? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [NumberDeserialize usage] [Type Conversion Errors] Do all NumberDeserialize::from conversions (appearing in lines 265, 773, 1100, 1251, etc.) properly handle edge cases like negative values, NaN, or infinity for floating point inputs? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All duplicate_field checks] [Race Condition in Deserialization] Can concurrent deserialization threads bypass duplicate field checks (lines 100, 108, 114, 249, etc.) if the field checking logic is not thread-safe? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All duplicate_field error returns] [Error Message Information Leak] Do duplicate field error messages (appearing throughout) leak information about internal field names or structure that could aid attackers? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Field name aliases] [Case Sensitivity Bypass] Can attackers use unexpected case variations of field names (e.g., transactionRootFilter vs transaction_root_filter) to bypass duplicate field detection? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [unwrap_or_default usage] [Dangerous Defaults] Do all unwrap_or_default() calls (lines 285, 287, 793, 979, 1277, etc.) result in safe default values, or can missing required fields be silently defaulted to security-compromising values? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Vector defaults] [Empty Collection Semantics] When collections default to empty (lines 1875, 1966, 2676, 2767, 3118, etc.), does this represent 'no filter' (match all) or 'reject all', and is the semantic consistent? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Optional field defaults] [None vs Default Ambiguity] Can the ambiguity between None and default values for optional fields (appearing throughout) be exploited to bypass validation or change semantics? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [TransactionType enum] [Invalid Enum Value Injection] Does the TransactionType conversion at line 3002 reject all invalid enum values, or can values outside the defined range be deserialized and cause undefined behavior? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Enum serialization] [from_i32 Error Handling] When from_i32 fails at line 2923, does the custom error properly prevent serialization, or could malformed data be sent to clients? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Enum variants] [Exhaustive Pattern Matching] Do all enum match statements handle unexpected variants that might be added in future protobuf versions, or could new variants cause panics? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All string deserialization] [Length Validation Missing] Are there any bounds checks on string field lengths (id, address, module_name, function, name, etc. throughout the file) to prevent extremely long strings causing memory exhaustion? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Address strings] [Address Format Validation] Do address string fields undergo validation for proper Aptos address format (0x-prefixed hex of correct length), or can arbitrary strings cause parsing errors? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Module/function name strings] [Identifier Validation] Are Move identifier rules (alphanumeric + underscore, no leading digits) enforced on module and function name strings, or can invalid identifiers cause downstream issues? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [BooleanTransactionFilter recursion] [Stack Overflow via Nested Filters] Can deeply nested BooleanTransactionFilter structures (LogicalNot wrapping LogicalAnd wrapping LogicalOr, etc.) cause stack overflow during recursive deserialization? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Filter complexity] [Evaluation Depth Limit] Is there a maximum depth limit for nested filter structures to prevent exponential evaluation time complexity attacks? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Nested oneof fields] [Union Type Confusion] Can providing nested union types (filter within filter within filter) cause type confusion when extracting the final filter variant? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Timestamp fields] [Future Timestamp Attack] Can services provide timestamps far in the future (lines 693, 780, 1163, 1498, 1650, 2793) to manipulate time-based logic like cache expiration or rate limiting? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Timestamp deserialization] [Negative Timestamp Handling] If timestamp protobuf types allow negative values, can past timestamps before epoch zero cause integer underflow in time calculations? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Timestamp comparison] [Clock Skew Exploitation] Can large timestamp discrepancies between client and server be exploited to bypass time-based security checks or causality validation? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [All Vec fields] [Unbounded Array Size] Do any of the Vec deserialization paths (filters, active_streams, samples, transactions) enforce maximum size limits to prevent memory exhaustion? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Array element validation] [Element Validation Bypass] After deserializing arrays, is each element validated for internal consistency, or can individual malformed elements in large arrays go undetected? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [Empty array semantics] [Empty Vec Interpretation] Is there consistent interpretation of empty vectors across all structs (no data vs. match all vs. error), or can semantic confusion be exploited? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.serde.rs] [GetDataServiceForRequestResponse] [Service Address SSRF] Can the data_service_address returned at line 979 be validated against an allowlist, or can attackers route clients to malicious services via SSRF? (Critical)"
]