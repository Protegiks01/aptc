[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::TooManyTypeArguments] [Generic overflow] TooManyTypeArguments is NonblockingError. Can excess type arguments cause the compiler to use wrong instantiations, creating type confusion vulnerabilities in deployed code? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::TooFewTypeArguments] [Type inference attack] TooFewTypeArguments is BlockingError. Does this prevent all cases where missing type arguments could be inferred to attacker-preferred types instead of the developer's intended types? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundVariable] [Variable shadowing] UnboundVariable is BlockingError. Can variables in different scopes with the same name create shadowing vulnerabilities where attacker-controlled values are used instead of expected ones? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::UnboundField] [Field confusion attack] UnboundField is BlockingError. Can struct field names be confused through homoglyphs or similar identifiers, causing assignments to wrong fields and data corruption? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::ReservedName] [Reserved name bypass] ReservedName is BlockingError. Are all Move VM reserved names (signer, address, vector, etc.) properly protected, or can attackers define types/functions with reserved names that break VM assumptions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedAddressBlock] [Deprecation bypass] DeprecatedAddressBlock is Warning. Can deprecated address block syntax still be used in production code, potentially bypassing security fixes applied to the new syntax? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedModule] [Vulnerable module usage] DeprecatedModule is Warning. Can deprecated modules with known security vulnerabilities still be imported and used because deprecation only generates warnings? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedMember] [Deprecated function exploit] DeprecatedMember is Warning. Can deprecated functions with security flaws continue to be called in new contracts because deprecation warnings are not enforced? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedStruct] [Legacy resource handling] DeprecatedStruct is Warning. Can deprecated struct types with incorrect ability annotations (like missing 'drop') be used, enabling resource leaks or double-spend vulnerabilities? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedFunction] [Insecure API usage] DeprecatedFunction is Warning. Can deprecated functions that lack authorization checks or have integer overflow bugs be called from new contracts? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: NameResolution::DeprecatedConstant] [Constant value vulnerability] DeprecatedConstant is Warning. Can deprecated constants with incorrect values (wrong gas costs, overflow-prone maximums) still be referenced in security-critical calculations? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::Visibility] [Visibility bypass] Visibility is BlockingError. Does this catch all visibility violations including friend access, internal module access, and script-only functions, or can crafted module layouts bypass these checks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::ScriptContext] [Context escape] ScriptContext is NonblockingError. Can code marked for script-only execution be embedded in modules, gaining access to script-context privileges like signer parameters without authorization? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::BuiltinOperation] [Intrinsic abuse] BuiltinOperation is BlockingError. Are all built-in operations (borrow_global, move_to, etc.) properly restricted, or can they be invoked in invalid contexts that break resource safety? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::ExpectedBaseType] [Reference confusion] ExpectedBaseType is BlockingError. Can references be used where base types are expected, creating dangling reference vulnerabilities or use-after-free bugs in the Move VM? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::ExpectedSingleType] [Tuple expansion exploit] ExpectedSingleType is BlockingError. Can tuple types be incorrectly unpacked where single types are expected, causing stack corruption or type confusion in bytecode? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::SubtypeError] [Subtyping violation] SubtypeError is BlockingError. Does Move's subtyping (reference mutability, generic bounds) properly enforce that &mut T cannot be used as &T in ways that violate borrow checking? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::JoinError] [Type unification attack] JoinError is BlockingError. Can incompatible types from different branches (if/else, match arms) be forced to unify through carefully chosen generic instantiations, causing type confusion? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::RecursiveType] [Infinite recursion DoS] RecursiveType is BlockingError. Does this catch all forms of recursive types including mutually recursive structs and generic cycles that could cause infinite loops during type checking or VM loading? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::ExpectedSpecificType] [Type coercion bypass] ExpectedSpecificType is BlockingError. Can implicit type coercions or casts allow unexpected types to be used, bypassing security checks that rely on specific type requirements? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::UninferredType] [Type ambiguity exploit] UninferredType is BlockingError. Can type inference failures be silently resolved to default types that don't satisfy ability constraints, enabling copying of non-copyable resources? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::ScriptSignature] [Entry point tampering] ScriptSignature is NonblockingError. Can invalid script signatures compile and be deployed, causing transactions to fail unpredictably or execute with wrong parameters when invoked? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::TypeForConstant] [Const type confusion] TypeForConstant is BlockingError. Can constants be declared with types that aren't statically evaluable, causing runtime type confusion when the constant is inlined into bytecode? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::UnsupportedConstant] [Const evaluation injection] UnsupportedConstant is BlockingError. Are all non-constant expressions properly rejected in const context, or can attackers use function calls, global access, or side effects during const evaluation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/diagnostics/codes.rs] [Category: TypeSafety::InvalidLoopControl] [Loop escape exploit] InvalidLoopControl is BlockingError. Can break/continue statements be used outside loops to cause control flow corruption, potentially jumping to attacker-controlled code locations? (Medium)"
]