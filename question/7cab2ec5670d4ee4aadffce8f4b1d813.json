[
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/transaction/manifest.rs] [Struct: TransactionBackup] [Backup replay] Can an attacker replay an old backup over newer chain state, causing the validator to regress to an older version and potentially enabling double-spending of funds that were transferred after the backup? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/transaction/manifest.rs] [Struct: TransactionChunk] [Chunk replay] Can individual chunks from different backups be replayed or reordered to create Frankenstein backups that pass verify() but contain inconsistent transaction sequences? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/backup_types/transaction/manifest.rs] [Struct: TransactionBackup] [Cross-chain replay] Can backups from testnet or other Aptos networks be replayed onto main\n\n### Citations\n\n**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L1-90)\n```rust\n// Copyright © Aptos Foundation\n// Parts of the project are originally copyright © Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::storage::FileHandle;\nuse anyhow::{ensure, Result};\nuse aptos_types::transaction::Version;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Deserialize, Serialize, Debug)]\npub enum TransactionChunkFormat {\n    // (Transaction, TransactionInfo, Vec<ContractEvent>, WriteSet)\n    V0,\n    // (Transaction, PersistedAuxiliaryInfo, TransactionInfo, Vec<ContractEvent>, WriteSet)\n    V1,\n}\n\n/// A chunk of a transaction backup manifest to represent the\n/// [`first_version`, `last_version`] range (right side inclusive).\n#[derive(Clone, Deserialize, Serialize, Debug)]\npub struct TransactionChunk {\n    pub first_version: Version,\n    pub last_version: Version,\n    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple\n    /// `(Transaction, TransactionInfo)`\n    pub transactions: FileHandle,\n    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.\n    /// The `TransactionAccumulatorRangeProof` links the transactions to the\n    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the\n    /// signatures it carries, against the validator set in the epoch. (Hence proper\n    /// `EpochEndingBackup` is needed for verification.)\n    pub proof: FileHandle,\n    #[serde(default ="
]