[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function()] [Acquires bypass] Can malicious functions omit required struct names from acquires list while still accessing global resources, generating bytecode that violates access declarations and bypasses borrow checking? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function_body_impl()] [Native function body] Can attackers provide FunctionBody::Native with non-empty code, causing the compiler to generate bytecode for native functions that should only have external implementations? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() Abort case] [Stack underflow on abort] At line 976, can Abort with no expression (exp_opt=None) be compiled without pushing error code, causing VM to abort with undefined stack state? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() Assert case] [Assert label collision] At line 988, can attackers trigger assert statement compilation at the same code offset multiple times to create duplicate cont_label entries, causing branch confusion? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() Assert case] [Condition inversion bypass] Does the BrFalse logic at line 991 correctly implement assert semantics, or can attackers craft conditions that invert the boolean to make failing asserts pass? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() Unpack case] [Binding count mismatch] At line 1028, can malicious Unpack provide fewer bindings than struct fields, causing some unpacked values to remain on stack and corrupt subsequent operations? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_statement() Unpack case] [Field binding mismatch] Can attackers provide bindings in different order than fields are unpacked from the struct, causing variables to receive values from wrong fields? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() BinopExp case] [Arithmetic overflow] At line 1209, do arithmetic operations (Add, Sub, Mul, Div, Mod) check for overflow/underflow, or can attackers craft expressions that overflow integer types silently? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() BinopExp case] [Division by zero] At line 1228, does Div operation validate divisor is non-zero before generating bytecode, or can attackers compile division that crashes the VM at runtime? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() BinopExp case] [Shift overflow] At lines 1239-1243, can Shl/Shr operations with shift amounts >= bitwidth of the type cause undefined behavior or wrap incorrectly in compiled bytecode? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Value case] [Address constant injection] At line 1118, can attackers inject arbitrary addresses through CopyableVal_::Address that bypass address validation, enabling unauthorized access to accounts? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Value case] [ByteArray size exploit] At line 1148, can attackers create ByteArray constants larger than vector limits, causing constant_pool to store oversized data that crashes the VM during loading? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Pack case] [Generic pack confusion] At lines 1190-1195, can attackers mix empty and non-empty type_actuals to generate Pack vs PackGeneric instructions incorrectly, causing type confusion in generic structs? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Pack case] [Stack underflow in pack] At line 1197, does pop() correctly handle num_fields=0 case, or can empty struct packing cause stack underflow? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Borrow case] [Field borrow type confusion] At lines 1293-1298, can attackers borrow fields with mismatched type_actuals that don't match the inner expression's type, bypassing generic type safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Borrow case] [Struct handle mismatch] Can malicious field.value.struct_name reference a different struct than inner_exp evaluates to, causing field_offset lookup to return offset from wrong struct definition? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() Exists builtin] [Type parameter injection] At line 1354, can attackers provide type_actuals that don't match the struct definition's type parameters, bypassing generic constraints in Exists checks? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() BorrowGlobal builtin] [Mutability confusion] At line 1371, can attackers flip the mut_ boolean through IR manipulation to generate MutBorrowGlobal for resources that should only allow immutable borrows? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() MoveFrom builtin] [Resource double-move] At line 1399, does MoveFrom properly mark resources as moved, or can attackers compile multiple MoveFrom calls for the same resource to duplicate values? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() MoveTo builtin] [Address validation bypass] At line 1415, does MoveTo validate the address operand is valid and authorized, or can attackers move resources to arbitrary addresses including system accounts? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecPack builtin] [Element count mismatch] At line 1433, can attackers provide num value that doesn't match actual number of elements on stack, causing VecPack to consume wrong number of values? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecPack builtin] [Stack underflow] Can num be larger than actual stack depth, causing the loop at line 1438 to underflow function_frame.cur_stack_depth into negative values? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecLen builtin] [Type confusion] At line 1443, can attackers call VecLen with types that don't match the actual vector type on stack, bypassing type checking and accessing wrong memory? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecImmBorrow/VecMutBorrow] [Index validation bypass] At lines 1451-1467, do these operations validate index is within bounds, or can attackers compile bytecode that accesses out-of-bounds vector elements? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_call() VecPushBack] [Capacity overflow] At line 1469, can repeated VecPushBack calls overflow vector capacity limits, causing memory exhaustion or buffer overflows in the VM? (High)"
]