[
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::new()] [Configuration Attack] If max_frame_size and max_message_size are user-configurable, can an attacker provide values that pass the assertion but cause fragmentation to fail during actual message processing? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Size Validation Gap] Line 185 checks message.data_len() <= max_message_size, but line 191 checks message.data_len() >= max_frame_size - what happens if a message is exactly between these two checks? Is there a gap in validation? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Request ID Exhaustion] Line 196 uses U32IdGenerator::next() - after 2^32 messages, does this wrap around? Can request_id collision occur after exhaustion causing fragment mixing? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Unreachable Code] Line 199 has unreachable!() for Error messages - but nothing prevents NetworkMessage::Error from reaching this point if validation is bypassed upstream. Could this panic? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Vec::split_off() Safety] At lines 202-209, Vec::split_off(max_frame_size) is called - what happens if max_frame_size > vec.len()? This would panic - is the prior size check at line 191 sufficient to prevent this? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Fragment Count Overflow] Line 212-214 checks chunks.len() <= u8::MAX but uses 'as usize' - on systems where usize is smaller than the actual chunk count, could this overflow and pass the check incorrectly? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Chunk Enumeration] Line 224 uses enumerate() with index as u8 + 1 - if there are more than 254 chunks (since we start from 1), this would overflow u8. Is the earlier check at line 212 sufficient? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Channel Backpressure] The stream_tx.send() calls at lines 221 and 230 could fail - if the channel is full, does this cause message loss? Are there retry mechanisms? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Async Cancellation] The function is async and calls await multiple times (lines 221, 230) - if the task is cancelled between sending header and fragments, the receiver gets incomplete data. Is this handled? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: OutboundStream::stream_message()] [Header-Fragment Race] Between sending the header (line 221-223) and fragments (line 224-233), could other messages interleave? Does MultiplexMessage ordering guarantee fragments arrive sequentially? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamHeader] [Integer Size] request_id is u32 (line 24) while fragment_id in StreamFragment is u8 (line 34) - can request_id collision occur more frequently than expected if only lower bits are used for matching? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamHeader] [Fragment Count Type] num_fragments is u8 (line 25) limiting streams to 255 fragments - but what if max_message_size / max_frame_size > 255? This should be caught in OutboundStream::new() assertion, but is it? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamHeader] [Message Cloning] The message field (line 27) contains the original NetworkMessage with chunked data removed - does cloning this during deserialization consume excessive memory? (Low)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamHeader] [Serialization Attack] StreamHeader derives Serialize/Deserialize - can a malicious peer send malformed serialized data to exploit deserialization vulnerabilities in bincode/serde? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamFragment] [Fragment ID Wrapping] fragment_id is u8 (line 34) - if a stream has more than 255 fragments due to a bug, fragment_id would wrap. Is this detected? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamFragment] [Raw Data Size] raw_data is Vec<u8> (line 36) with no size limit in the struct itself - can a malicious peer send gigabyte-sized fragments to cause memory exhaustion before max_message_size validation? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamFragment] [serde_bytes Optimization] Line 35 uses serde_bytes for efficiency - but does this properly validate data length during deserialization? Can oversized buffers bypass validation? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Struct: StreamFragment] [Request ID Matching] request_id in StreamFragment must match StreamHeader's request_id - but is this validated at deserialization time or only during append_fragment()? Early validation could prevent waste. (Low)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Enum: StreamMessage] [Type Confusion] StreamMessage can be Header or Fragment (lines 16-19) - can an attacker send multiple Headers in sequence without Fragments to cause state confusion in InboundStreamBuffer? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Enum: StreamMessage] [Fragment-Only Attack] Can an attacker send only Fragment messages without ever sending a Header, repeatedly triggering 'No stream exist' errors and potentially causing validator slowdowns? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Enum: StreamMessage] [Deserialization Ordering] When deserializing StreamMessage, does serde guarantee that enum variant parsing is safe? Could a crafted payload be interpreted as both Header and Fragment? (Low)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [Message Type Switch] Lines 140-145 match on NetworkMessage variants - if new message types are added to NetworkMessage enum, would the panic! at line 141 catch them or would they fall through unsafely? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [RpcRequest Handling] Line 142 appends to request.raw_request - is there validation that raw_request doesn't exceed RPC size limits? Could fragments bypass per-message RPC validation? (High)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [RpcResponse Handling] Line 143 appends to response.raw_response - are response size limits enforced consistently with request limits? Can responses be made arbitrarily large? (Medium)",
  "[File: aptos-core/network/framework/src/protocols/stream/mod.rs] [Function: InboundStream::append_fragment()] [DirectSendMsg Handling] Line 144 appends to message.raw_msg - DirectSend messages might have different size/validation requirements than RPC. Are these respected during fragment reassembly? (Medium)"
]