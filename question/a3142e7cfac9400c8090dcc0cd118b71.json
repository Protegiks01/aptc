[
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Integer overflow] Can an attacker cause u32 overflow by forcing the VM to intern more than 2^32 distinct types through deeply nested generics or recursive type instantiations, causing TypeId wraparound and type confusion that breaks Move's type safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Integer overflow] Does the cast `inner.data.len() as u32` at line 98 check for overflow before casting, or can an attacker with 4GB+ of distinct types cause silent truncation leading to duplicate TypeIds and breaking deterministic execution across validators? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Integer overflow] Can the cast `inner.data.len() as u32` at line 132 overflow if an attacker creates billions of distinct type argument vectors through malicious smart contracts, causing TypeVecId collisions that break struct instantiation correctness? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern_vec()] [Integer overflow] Does line 151's `inner.data.len() as u32` cast have overflow protection, or can an attacker exhaust TypeVecId space causing ID reuse that violates Move's type system guarantees about distinct generic instantiations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: TypeId] [Type confusion] Since TypeId is a transparent wrapper around u32, can integer overflow cause two semantically different types to map to the same TypeId, allowing attackers to bypass Move's type checker and perform invalid operations like treating a u64 as a resource type? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: TypeVecId] [Type confusion] Can TypeVecId overflow enable an attacker to substitute incorrect type arguments for generic structs, bypassing Move's parametric polymorphism safety and potentially accessing or duplicating resources improperly? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Race condition] In the double-check locking pattern (lines 89-101), can two threads concurrently pass the first read check, both acquire write locks sequentially, and create duplicate entries if the HashMap's insert semantics don't guarantee atomic check-and-insert? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Race condition] Between lines 89-91 (read check) and lines 93-96 (write check), can another thread insert the same type, causing both threads to think they need to insert, leading to inconsistent data.len() and interned.len() that breaks invariants? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Race condition] Can concurrent calls to intern() with identical type vectors cause race conditions where both threads pass the read lock check (line 120), then both acquire write locks and create duplicate TypeVecIds due to non-atomic HashMap operations? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern_vec()] [Race condition] Does the pattern at lines 139-149 (read check, then write check) have a TOCTOU vulnerability where the type vector could be modified between checks, causing incorrect interning or HashMap corruption? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush_impl()] [Race condition] Can flush_impl() be called concurrently with intern operations, causing reads from cleared data structures at lines 200-206 that lead to panics or invalid TypeIds being returned to active VM execution contexts? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush()] [Data race] Between flush_impl() clearing the maps (lines 200-206) and warmup() repopulating them (line 195), can concurrent intern calls access empty data structures causing index-out-of-bounds panics that halt transaction execution? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Race condition] Can recursive calls to instantiate_and_intern() for nested types (lines 265-298) interleave with flush operations, causing some types to be interned in the old cache and others in the new cache, breaking type equality checks? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: InternedTypePool] [Concurrent modification] Does the absence of synchronization between ty_interner and ty_vec_interner allow race conditions where a TypeId is created but its corresponding TypeVecId in a Struct type isn't, causing dangling references? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Memory exhaustion] Since InternMap has no size limits and types are never evicted except during flush, can an attacker submit transactions with exponentially growing type instantiations (e.g., Vector<Vector<Vector<...>>>) to exhaust validator memory and cause OOM crashes? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Memory exhaustion] Can an attacker create billions of distinct type argument combinations through malicious generic struct instantiations, filling the TypeVecInterner's unbounded HashMap and Vec until the validator runs out of memory? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Denial of service] Can deeply recursive type instantiations (e.g., 10,000+ nesting levels) in lines 264-298 cause stack overflow during recursive instantiate_and_intern calls, crashing validator nodes and halting consensus? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Struct: InternMap] [Memory leak] Do the HashMap and Vec in InternMap (lines 54-55) ever shrink after clear(), or does clear() leave allocated capacity causing memory fragmentation across repeated flush cycles that gradually degrades validator performance? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Memory amplification] Since Arc<[TypeId]> is cloned twice (lines 124-125) for both data storage and HashMap key, can an attacker create huge type argument vectors (e.g., 100,000 type parameters) to amplify memory usage by 2x per interning operation? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::new()] [Resource limits] Does new() impose any limits on the number of types that can be interned, or can attackers exploit the unlimited growth to DoS validators by forcing them to intern unlimited distinct types until memory exhaustion? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeInterner::intern()] [Non-determinism] Can HashMap's non-deterministic iteration order or hash collisions cause different validators to assign different TypeIds to the same type, breaking deterministic execution and causing validators to produce different state roots leading to consensus failure? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: TypeVecInterner::intern()] [Non-determinism] Does the HashMap<Arc<[TypeId]>, TypeVecId> at line 107 use a deterministic hasher, or can hash collisions cause different validators to assign different TypeVecIds for identical type argument vectors, breaking consensus on generic struct instantiations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::warmup()] [Initialization order] Can the order of warmup() calls at lines 211-229 vary across validators due to system timing differences, causing the same types to get different TypeIds (e.g., Bool might be TypeId(0) on one validator but TypeId(5) on another)? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: instantiate_and_intern()] [Non-determinism] Can differences in thread scheduling during concurrent type interning cause validators to process types in different orders, leading to different TypeId assignments and breaking deterministic execution guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/ty_interner.rs] [Function: InternedTypePool::flush()] [Consensus divergence] If validators call flush() at different times (e.g., different block boundaries), can TypeIds get reassigned differently across validators causing the same type to have TypeId(100) on validator A but TypeId(250) on validator B? (Critical)"
]