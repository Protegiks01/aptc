[
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_waypoint()] [Waypoint verification failure panic] At lines 154-162, if waypoint.verify() returns Err, the code panics instead of returning error, but can malformed waypoints cause validator crashes? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_snapshot_data()] [Too far behind panic] At lines 574-579, if node is too many versions behind and in fast sync mode, it panics with instructions to delete storage, but can this be triggered by transient network conditions? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: drive_progress()] [Already bootstrapped error] At lines 419-423, if drive_progress() is called when already bootstrapped, an error is returned, but can this prevent re-bootstrapping after storage corruption detection? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: Bootstrapper::new()] [Initial epoch state fetch panic] At lines 343-345, if fetch_latest_epoch_state() fails, the expect() causes panic, but can corrupted storage on startup cause validator crash loops? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Struct: Bootstrapper] [Multiple mutable fields] At lines 290-326, the struct contains multiple Option fields (active_data_stream, bootstrap_notifier_channel, speculative_stream_state) that are modified in different functions - can concurrent access cause inconsistent state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: reset_active_stream()] [Async termination race] At lines 1546-1552, terminate_stream_with_feedback() is awaited, but if another thread modifies active_data_stream concurrently, can the stream_id become invalid? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_active_stream_notifications()] [Loop iteration state] At lines 604-658, the loop processes notifications while holding mutable self reference, but can async operations within the loop allow other tasks to modify state? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Struct: StateValueSyncer] [Non-atomic state updates] At lines 244-287, multiple fields (initialized_state_snapshot_receiver, ledger_info_to_sync, next_state_index_to_process) are updated separately - can partial updates cause inconsistency? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_snapshot_data()] [Snapshot sync target validation] At lines 523-540, previous_snapshot_sync_target() and is_snapshot_sync_complete() are checked, but can malicious metadata storage return inconsistent results to skip syncing? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_values()] [Last persisted index retrieval] At lines 706-713, get_last_persisted_state_value_index() can fail with StorageError, but is this error recoverable or does it permanently halt bootstrapping? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: get_bootstrapping_mode()] [Mode consistency] At line 365, bootstrapping_mode is read from config, but can config changes during bootstrapping cause mode transitions mid-sync? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [Mode unreachable handling] At lines 799-801, bootstrapping_mode matches trigger unreachable!() for unsupported modes, but can config corruption or version mismatches trigger this at runtime? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Mode exhaustive match] At lines 1252-1254, the match has an unreachable!() arm for unsupported modes, but what if ExecuteOrApplyFromGenesis receives both transaction and output payloads simultaneously? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [State checkpoint hash validation] At lines 1017-1021, ensure_state_checkpoint_hash() must return a valid hash, but what if it returns Ok with a zero hash, passing validation but representing no state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [Root hash comparison timing] At line 1022, root hashes are compared with !=, but can concurrent modifications to either state_value_chunk_with_proof or first_transaction_info cause TOCTOU vulnerabilities? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Constant: GENESIS_TRANSACTION_VERSION] [Genesis version assumption] At line 38, GENESIS_TRANSACTION_VERSION is hardcoded to 0, but can networks with different genesis configurations break this assumption? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_state_snapshot_data()] [Genesis fast sync handling] At lines 474-483, special logic handles fast syncing to genesis, but can attackers exploit this to keep nodes perpetually syncing to version 0? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_state_values_payload()] [Genesis epoch change proofs] At lines 988-993, if syncing to genesis (version 0), only the ledger_info_to_sync is used as epoch proof, but is this single proof sufficient to establish chain trust? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: get_speculative_stream_state()] [State existence check] At lines 1491-1495, if speculative_stream_state is None, an UnexpectedError is returned, but can legitimate code paths leave this uninitialized causing spurious errors? (Medium)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: fetch_missing_transaction_data()] [Speculative state initialization] At lines 803-807, SpeculativeStreamState is created with utils::fetch_latest_epoch_state(), but can stale epoch state from storage cause speculative execution on wrong chain fork? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: reset_active_stream()] [Speculative state cleanup] At line 1555, speculative_stream_state is set to None when resetting stream, but can ongoing speculative operations be cancelled, or do they continue with stale state? (High)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: verify_transaction_info_to_sync()] [Single transaction proof] At lines 1268-1337, the code expects exactly 1 transaction info in the proof, but can an attacker provide a proof with 1 transaction info for the wrong version while passing the length check? (Critical)",
  "[File: aptos-core/state-sync/state-sync-driver/src/bootstrapper.rs] [Function: process_transaction_or_output_payload()] [Proof ledger info staleness] At lines 1163-1166, proof_ledger_info is fetched from speculative_stream_state, but can epoch changes invalidate this ledger info between fetch and use in verification? (High)"
]