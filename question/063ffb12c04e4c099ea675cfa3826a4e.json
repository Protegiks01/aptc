[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Static: VERIFIED_MODULES_CACHE] [Cross-VM-instance sharing] If multiple VM instances exist in the same process (e.g., for different chains), does the global cache incorrectly share verified modules across chains? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [Bytecode format changes] If the Move bytecode format version changes, are all cached module hashes invalidated, or can modules verified under old bytecode formats remain cached? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: put()] [Module republishing] If a module is deleted and then republished with the same bytecode (same hash), does put() correctly handle this scenario without assuming the old verification is still valid? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: flush()] [Flush during verification] If flush() is called while another thread is performing verification that will call put(), can this create a race condition where the verification result is cached into the flushed cache? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs] [Function: contains()] [Verification dependency tracking] Does contains() only check the module\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/storage/verified_module_cache.rs (L1-66)\n```rust\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse cfg_if::cfg_if;\nuse lazy_static::lazy_static;\nuse parking_lot::Mutex;\nuse std::num::NonZeroUsize;\n\n/// Cache for already verified modules. Since loader V1 uses such a cache to not perform repeated\n/// verifications, possibly even across blocks, for comparative performance we need to have it as\n/// well. For now, we keep it as a separate cache to make sure there is no interference between V1\n/// and V2 implementations.\npub(crate) struct VerifiedModuleCache(Mutex<lru::LruCache<[u8; 32], ()>>);\n\nimpl VerifiedModuleCache {\n    /// Maximum size of the cache. When modules are cached, they can skip re-verification.\n    const VERIFIED_CACHE_SIZE: NonZeroUsize = NonZeroUsize::new(100_000).unwrap();\n\n    /// Returns new empty verified module cache.\n    pub(crate) fn empty() -> Self {\n        Self(Mutex::new(lru::LruCache::new(Self::VERIFIED_CACHE_SIZE)))\n    }\n\n    /// Returns true if the module hash is contained in the cache. For tests, the cache is treated\n    /// as empty at all times.\n    pub(crate) fn contains(&self, module_hash: &[u8; 32]) -> bool {\n        // Note: need to use get to update LRU queue.\n        verifier_cache_enabled() && self.0.lock().get(module_hash).is_some()\n    }\n\n    /// Inserts the hash into the cache, marking the corresponding as locally verified. For tests,\n    /// entries are not added to the cache.\n    pub(crate) fn put(&self, module_hash: [u8; 32]) {\n        if verifier_cache_enabled() {\n            let mut cache = self.0.lock();\n            cache.put(module_hash, ());\n        }\n    }\n\n    /// Flushes the verified modules cache.\n    pub(crate) fn flush(&self) {\n        self.0.lock().clear();\n    }\n\n    /// Returns the number of verified modules in the cache.\n    pub(crate) fn size(&self) -> usize {\n        self.0.lock().len()\n    }\n}\n\nlazy_static! {\n    pub(crate) static ref VERIFIED_MODULES_CACHE: VerifiedModuleCache =\n        VerifiedModuleCache::empty();\n}\n\n#[cfg_attr(feature ="
]