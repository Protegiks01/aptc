[
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: make_abort_code()] [Magic constant integrity] The magic number 0xCA26CBD9BE is derived from sha256('Move 2 Abort code') - if this constant is corrupted or modified by a malicious compiler, can it cause abort code collisions with user-defined abort codes, breaking error handling logic? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: make_abort_code()] [Category collision] The abort code format uses category 0xB (std::error::INTERNAL) - can user-defined abort codes accidentally or intentionally collide with compiler-generated codes by using the same category and reason, causing ambiguous error reporting? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Function: make_abort_code()] [Reason exhaustion] With only 2 bytes (u16) for the reason field, the system can only represent 65,536 distinct compiler errors - is there a registration mechanism to prevent reason number collisions as new compiler errors are added, or can collisions cause incorrect error attribution? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: UNSPECIFIED_ABORT_CODE] [Default error handling] When users omit abort codes in assert! statements, the code defaults to UNSPECIFIED_ABORT_CODE (0xCA26CBD9BE0B0000) - can this make debugging impossible for large contracts with many assertions, or allow attackers to hide exploit patterns by triggering generic unspecified aborts? (Low)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: INCOMPLETE_MATCH_ABORT_CODE] [Match exhaustiveness] Does the Move compiler correctly insert INCOMPLETE_MATCH_ABORT_CODE for all non-exhaustive pattern matches, or can attackers craft enum/variant patterns that fall through without aborting, causing undefined behavior or state corruption? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: INCOMPLETE_MATCH_ABORT_CODE] [Prover verification] Can the prover detect all cases where runtime values might fall through incomplete matches, or can Byzantine validators exploit prover blind spots to execute code paths that should be unreachable according to verified specifications? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: PERSISTENT_ATTRIBUTE] [Storage persistence] Can the 'persistent' attribute be abused to mark temporary values as persistent, causing excessive storage consumption, state bloat attacks, or preventing proper cleanup of resources that should be ephemeral? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: PERSISTENT_ATTRIBUTE] [Resource leaks] If the 'persistent' attribute is incorrectly applied or removed through macro expansion, can it cause resources to leak across transaction boundaries, breaking Move's resource safety guarantees and enabling double-spend attacks? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: MODULE_LOCK_ATTRIBUTE] [Reentrancy] Does the 'module_lock' attribute properly prevent reentrancy attacks where module A calls module B which calls back to module A, or can lock acquisition order bugs cause deadlocks or lock bypass allowing concurrent modification of module state? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Constant: MODULE_LOCK_ATTRIBUTE] [Lock granularity] Is the module_lock applied at module level or function level - can attackers exploit coarse-grained locking to cause denial of service by holding module locks during expensive computations, blocking all other transactions from accessing the module? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Integration: Attribute validation] Are the attribute checking functions (is_test_only_attribute_name, is_test_attribute_name, is_verify_only_attribute_name) called consistently across all compiler passes, or can some passes skip validation allowing test/verification-only code to leak into production builds? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Integration: Vector bytecode mapping] Is the VECTOR_FUNCS_WITH_BYTECODE_INSTRS list synchronized with the actual bytecode instruction set in the VM, or can version mismatches cause some vector functions to incorrectly use interpreted code instead of native bytecode, introducing performance bugs or gas inconsistencies? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Integration: Type info consistency] Do the Move runtime functions (TYPE_NAME_MOVE, TYPE_INFO_MOVE) produce identical results to their spec counterparts (TYPE_NAME_SPEC, TYPE_INFO_SPEC) when prover verification passes are enabled, or can divergence cause verified properties to be violated at runtime? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Integration: Abort code uniqueness] Is there a global registry ensuring abort codes generated by make_abort_code() don't collide with user-defined abort codes, framework abort codes, or future compiler-generated codes across different compiler versions? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Integration: Module name resolution] Do all consumers of VECTOR_MODULE, CMP_MODULE, and other module name constants properly perform fully-qualified name resolution including address prefixes, or can short-name lookups be hijacked by malicious modules in the transaction sender's address space? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Downstream: Compiler] If the compiler incorrectly identifies test-only code using is_test_only_attribute_name(), can production deployments include unverified test helpers that expose privileged operations, debug backdoors, or unsafe direct state manipulation? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Downstream: VM execution] When the VM resolves vector operations using VECTOR_FUNCS_WITH_BYTECODE_INSTRS, does it validate that the called function actually matches the expected bytecode instruction signature, or can type confusion allow arbitrary functions to execute with bytecode-level privileges? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Downstream: Prover] Can mismatches between TYPE_NAME_MOVE/TYPE_NAME_SPEC or TYPE_INFO_MOVE/TYPE_INFO_SPEC cause the prover to verify properties about the spec version that don't hold for the runtime version, creating a verification soundness gap? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Downstream: Gas metering] Does the gas metering system special-case the bytecode vector functions listed in VECTOR_FUNCS_WITH_BYTECODE_INSTRS, and if so, are the gas costs correctly calibrated to prevent under-pricing that enables DoS through cheap vector operations? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Downstream: Error handling] When transactions abort with UNSPECIFIED_ABORT_CODE or INCOMPLETE_MATCH_ABORT_CODE, do validators deterministically produce identical error messages and state rollback behavior, or can non-deterministic error handling cause consensus divergence? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Toolchain: Compilation] Can a compromised Move compiler modify the well-known constants in this file during compilation to inject backdoors, such as changing VECTOR_MODULE to point to a malicious module or altering abort codes to hide exploits? (Critical)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Toolchain: Verification] If verification tools use different versions of well_known.rs than the compiler, can this create verification-compilation mismatches where verified code behaves differently when compiled due to constant discrepancies? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Toolchain: Reproducibility] Are the well-known constants in this file deterministic across all compiler versions and platforms, or can cross-compilation differences cause the same Move source to produce different bytecode on different architectures? (High)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Edge case: Empty strings] Do the attribute checking functions handle empty attribute names gracefully, or can empty #[] attributes cause parser crashes, infinite loops, or bypass security checks? (Medium)",
  "[File: aptos-core/third_party/move/move-model/src/well_known.rs] [Edge case: Unicode normalization] Are attribute names and module names Unicode-normalized before comparison, or can attackers use different Unicode normalization forms (NFC, NFD, NFKC, NFKD) to create lookalike attributes that bypass validation? (Medium)"
]