[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::push()] [Integer overflow] Can an attacker craft deeply nested expressions that cause cur_stack_depth to overflow from i64::MAX, wrapping to negative values and bypassing stack depth limits, potentially enabling stack-based exploits in the VM? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::pop()] [Integer underflow] Can malicious IR code trigger stack pops when cur_stack_depth is at i64::MIN, causing underflow that corrupts stack tracking and allows invalid bytecode generation with negative stack depth? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::push()] [Stack depth validation] Does the check for i64::MAX prevent attackers from creating bytecode with max_stack_depth exceeding u16 limits (file_format max), potentially causing runtime panics or buffer overflows in the VM? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression()] [Stack accounting bypass] Can an attacker craft expressions that manipulate function_frame.push()/pop() calls to desynchronize cur_stack_depth from actual stack state, generating bytecode that passes verification but causes stack corruption at runtime? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::define_local()] [Table overflow] Can an attacker define exactly TABLE_MAX_SIZE locals to bypass the >= check, then define one more through a different code path, exceeding u8 index limits and causing index wraparound? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::define_local()] [Variable shadowing] Does the Occupied entry check prevent all cases of variable redefinition, or can attackers exploit race conditions or multiple definition paths to create duplicate local indices with different types? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: FunctionFrame::get_local()] [Uninitialized access] Can malicious IR reference variables before they are defined, causing get_local() to fail silently or return invalid indices that could access wrong stack slots in the VM? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function_body()] [Local type confusion] Can an attacker declare a local with type T but never use it, then reuse its index through bytecode manipulation to store/load values of incompatible type T', bypassing type safety? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_move_function_body()] [Label collision] Does the HashSet check prevent all label collisions, or can attackers create blocks with labels that hash to the same value but have different byte representations, bypassing duplicate detection? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: verify_bytecode_function_body()] [Undeclared label reference] Can an attacker craft IR where labels are declared conditionally or in unreachable code paths, passing verification but causing branch instructions to jump to invalid offsets at runtime? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_blocks()] [Label remapping attack] Can malicious IR manipulate the label_to_index HashMap during compilation to cause remap_branch_offsets() to map branch targets to wrong code locations, enabling control flow hijacking? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: remap_branch_offsets()] [Missing offset validation] Does remap_branch_offsets check that remapped offsets are within valid code bounds, or can attackers create fake_to_actual mappings that point branches outside the bytecode array? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_block()] [Label index overflow] Can an attacker create more than u16::MAX blocks to cause label_to_index to store code.len() as u16 with overflow, resulting in branches jumping to wrong offsets? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type()] [Recursive type overflow] Can an attacker create deeply nested Vector<Vector<Vector<...>>> types that cause stack overflow in the recursive compile_type() call, crashing the compiler or enabling DoS? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type()] [Type parameter confusion] Can malicious IR reference type parameters not in the type_parameters HashMap, causing compile_type to return Unbound error that gets incorrectly handled, allowing invalid SignatureToken generation? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_types()] [Type vector length mismatch] Can an attacker provide type actual lists that don't match the expected arity, causing compile_types to generate Signature with wrong number of tokens that bypass arity checks? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: type_parameter_indexes()] [Type parameter overflow] Can an attacker declare more than TABLE_MAX_SIZE type parameters to overflow the idx check, causing TypeParameterIndex wraparound and type confusion? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: type_parameter_indexes()] [Duplicate type parameter] Does the is_some() check after insert fully prevent duplicate type parameters, or can attackers exploit HashMap collision attacks to insert duplicates with the same index? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: struct_type_parameters()] [Ability mismatch] Can malicious struct definitions declare phantom type parameters with incorrect ability constraints that don't match usage, bypassing ability checks and enabling unauthorized resource operations? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_structs()] [Struct definition reordering] Can an attacker declare structs in different order than their definitions, causing struct_definition_index lookups to return wrong indices and enabling type confusion between different struct types? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_fields()] [Field order violation] Can attackers define struct fields in different order than expected, bypassing the field_order == decl_order check through timing or context manipulation? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_fields()] [Native struct exploitation] Does Native field information properly prevent field access, or can attackers craft bytecode that attempts to access fields of native structs, causing VM crashes or memory corruption? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_expression() Pack case] [Field order bypass] At line 1184, can an attacker provide fields out of order and manipulate the field_order vs decl_order comparison to pack fields in wrong positions, causing memory layout corruption? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: function_signature()] [Signature mismatch] Can malicious IR declare function signature with return types that don't match actual return statements, generating bytecode that returns wrong number or type of values? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function()] [Visibility bypass] Can an attacker declare functions with FunctionVisibility::Internal but mark is_entry=true, bypassing entry function restrictions and calling internal functions from transactions? (Critical)"
]