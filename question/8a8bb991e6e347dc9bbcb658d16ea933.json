[
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Migration: FUTURE_ROUNDS_TO_ACCEPT changes] [Protocol parameter changes] If FUTURE_ROUNDS_TO_ACCEPT constant is changed in an upgrade, can this cause validators on different versions to reject each other's secret share requests? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Cryptographic attack: Share interpolation] [Lagrange interpolation] Can attackers exploit weaknesses in Shamir secret sharing Lagrange interpolation to recover the secret with fewer than threshold shares? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Cryptographic attack: Side-channel timing] [Timing side-channel] Can timing differences in get_id() lookups or msk_share() access leak information about validator identities or key values? (Medium)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Cryptographic attack: Key derivation] [Weak key derivation] If msk_share, encryption_key, and digest_key are derived from the same master seed, can breaking one key compromise all keys? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Cryptographic attack: Nonce reuse] [Encryption nonce] If EncryptionKey uses a nonce-based scheme, can concurrent encryption operations cause nonce reuse, breaking semantic security? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [State transition: Epoch change] [Atomic epoch transition] Is there atomic switching from old SecretSharingConfig to new config during epoch transitions, or can intermediate states cause share inconsistency? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [State transition: Validator join] [Dynamic validator set] When new validators join mid-epoch, can they participate in secret sharing without breaking existing share reconstruction? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [State transition: Validator removal] [Validator departure] When validators leave, are their shares properly invalidated, or can they continue to influence secret reconstruction? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Network: RequestSecretShare validation] [Message authentication] Are RequestSecretShare messages authenticated to prevent spoofing, or can attackers impersonate validators to request shares? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Network: Message replay] [Replay protection] Is there replay protection for RequestSecretShare messages, or can old requests be replayed to force share regeneration? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Network: Message ordering] [Out-of-order delivery] Can out-of-order delivery of RequestSecretShare messages cause validators to process requests from future rounds before completing current rounds? (Medium)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Access control: SecretSharingConfig creation] [Authorization bypass] Can non-validator nodes create SecretSharingConfig instances to participate in secret sharing, bypassing validator authorization? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Access control: msk_share access] [Unauthorized access] Can code outside the consensus module access msk_share() through public API, potentially leaking secret key material? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Access control: Author validation] [Identity verification] Is the author field in SecretSharingConfig validated against cryptographic signatures, or can it be spoofed? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Fault tolerance: Threshold safety] [Byzantine resilience] If exactly threshold validators collude (but < n/3), can they manipulate secret reconstruction to bias randomness? (Critical)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Fault tolerance: Validator failures] [Liveness under faults] If > n - threshold validators crash, does secret reconstruction fail gracefully or cause consensus halt? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Fault tolerance: Malformed shares] [Error handling] If validators send malformed secret shares (corrupted msk_share), does reconstruction detect and exclude them or accept invalid inputs? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Performance: get_id() hash lookup] [Lookup efficiency] For large validator sets, can repeated get_id() calls become a performance bottleneck affecting consensus speed? (Low)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Performance: Clone overhead] [Cloning cost] Does cloning SecretSharingConfig with large verification_keys Vec cause performance degradation in hot consensus paths? (Low)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Resource limits: Memory bounds] [Unbounded memory] Is there a limit on the size of RequestSecretShare or SecretSharingConfig to prevent memory exhaustion attacks through oversized structures? (Medium)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Edge case: Empty validator set] [Zero validators] Can SecretSharingConfig be created with an empty validator set (n=0), causing division by zero or null pointer dereferences? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Edge case: Duplicate verification keys] [Key uniqueness] Can verification_keys Vec contain duplicate keys, causing verification ambiguity or allowing one validator to impersonate another? (High)",
  "[File: aptos-core/consensus/src/rand/secret_sharing/types.rs] [Edge case: Mismatched key lengths] [Cryptographic parameter mismatch] Can verification_keys, encryption_key, digest_key, and msk_share have mismatched cryptographic parameters (e\n\n### Citations\n\n**File:** consensus/src/rand/secret_sharing/types.rs (L1-107)\n```rust\n// Copyright (c) Aptos Foundation\n// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE\n\nuse aptos_batch_encryption::group::Fr;\nuse aptos_consensus_types::common::Author;\nuse aptos_crypto::arkworks::shamir::ShamirThresholdConfig;\nuse aptos_types::{\n    secret_sharing::{\n        DigestKey, EncryptionKey, MasterSecretKeyShare, SecretShareMetadata, VerificationKey,\n    },\n    validator_verifier::ValidatorVerifier,\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\npub const FUTURE_ROUNDS_TO_ACCEPT: u64 = 200;\n\npub type ThresholdConfig = ShamirThresholdConfig<Fr>;\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct RequestSecretShare {\n    metadata: SecretShareMetadata,\n}\n\nimpl RequestSecretShare {\n    pub fn new(metadata: SecretShareMetadata) -> Self {\n        Self { metadata }\n    }\n\n    pub fn epoch(&self) -> u64 {\n        self.metadata.epoch\n    }\n\n    pub fn metadata(&self) -> &SecretShareMetadata {\n        &self.metadata\n    }\n}\n\n#[derive(Clone)]\npub struct SecretSharingConfig {\n    author: Author,\n    epoch: u64,\n    validator: Arc<ValidatorVerifier>,\n    // wconfig: WeightedConfig,\n    digest_key: DigestKey,\n    msk_share: MasterSecretKeyShare,\n    verification_keys: Vec<VerificationKey>,\n    config: ThresholdConfig,\n    encryption_key: EncryptionKey,\n}\n\nimpl SecretSharingConfig {\n    pub fn new(\n        author: Author,\n        epoch: u64,\n        validator: Arc<ValidatorVerifier>,\n        digest_key: DigestKey,\n        msk_share: MasterSecretKeyShare,\n        verification_keys: Vec<VerificationKey>,\n        config: ThresholdConfig,\n        encryption_key: EncryptionKey,\n    ) -> Self {\n        Self {\n            author,\n            epoch,\n            validator,\n            digest_key,\n            msk_share,\n            verification_keys,\n            config,\n            encryption_key,\n        }\n    }\n\n    pub fn get_id(&self, peer: &Author) -> usize {\n        *self\n            .validator\n            .address_to_validator_index()\n            .get(peer)\n            .expect("
]