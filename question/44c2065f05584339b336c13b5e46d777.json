[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Backup corruption] If poll_next() loses outputs from queued_outputs due to logic errors (e.g., pop_front() called twice), can this cause backup chunks to be silently dropped, resulting in incomplete or corrupted backup snapshots? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Backup incompleteness] If push() fails to add futures to either queued or in_progress due to memory allocation failure, is there error handling to detect this, or will backup operations silently skip chunks and produce incomplete backups? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Data ordering] Since FuturesUnordered returns results in completion order (unordered), if backup chunks complete out-of-order and queued_outputs buffers them, could this cause backup restoration to fail due to incorrect chunk sequencing assumptions? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Backup progress] If len() returns incorrect values due to integer overflow, can backup monitoring/progress tracking report incorrect completion percentages, causing operators to terminate healthy backups prematurely? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Backup hang] If the while loop in poll_next() enters an infinite polling state where in_progress.poll_next_unpin() always returns Pending, could this cause backup operations to hang indefinitely without timeout, blocking validator operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Panic propagation] If FuturesUnordered::push() panics due to internal allocation failure, does FuturesUnorderedX properly propagate this panic or could it leave the struct in an inconsistent state with corrupted queued/in_progress data? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Panic propagation] If in_progress.poll_next_unpin() panics during the while loop, are queued_outputs and queued properly unwound, or could the panic leave partial outputs buffered that get lost on restart? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Edge case] What happens if new() is called with max_in_progress = usize::MAX and then VecDeque/FuturesUnordered operations fail due to allocation limits - is there graceful degradation or catastrophic failure? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Error handling] Does extend() validate that the iterator doesn't contain an excessive number of futures before consuming it, or could a malicious iterator cause unbounded memory allocation before running out of memory? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Error handling] If queued.pop_front() or queued_outputs.pop_front() fail (though unlikely with VecDeque), are there assertions or error handling, or could this cause silent data loss in backup operations? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Memory fragmentation] Can repeated push_back() and pop_front() operations on queued and queued_outputs VecDeques cause memory fragmentation over long-running backup operations, eventually degrading performance or causing allocation failures? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [VecDeque growth] Does VecDeque::push_back() in queued have bounded growth, or can it reallocate exponentially, causing memory usage spikes during high backup load that trigger OOM? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [VecDeque performance] If queued_outputs grows to millions of elements due to burst completions, can the push_back() and pop_front() operations cause O(n) performance degradation that slows backup throughput? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: is_empty()] [VecDeque consistency] Does is_empty() properly check all three VecDeque/FuturesUnordered structures atomically, or could concurrent modifications cause inconsistent empty status checks? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [VecDeque capacity] Are queued and queued_outputs VecDeques pre-allocated with capacity hints based on max_in_progress, or do they start with zero capacity and reallocate frequently, causing performance issues? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Waker registration] Does the while loop properly handle Context waker registration - if in_progress.poll_next_unpin() registers wakers and then we immediately drain queued_outputs, could wakers be lost causing futures to never wake? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Spurious wakeups] If poll_next() is called with spurious wakeups (cx waker fired but no progress), does the function efficiently return Pending without excessive polling of in_progress, or could it cause CPU spin loops? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Async runtime dependency] Does poll_next() assume a specific async runtime (Tokio/async-std), or could runtime-specific behavior (e.g., Tokio's cooperative yielding) cause different concurrency semantics than intended? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Context lifetime] Are Context references properly bounded in the while loop, or could holding Context across multiple poll_next_unpin() calls cause waker lifetime issues? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Poll contract violation] Does poll_next() properly follow the Stream::poll_next contract (never poll after Ready(None)), or could internal logic allow polling after termination? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Starvation] If futures in queued never get promoted to in_progress because in_progress futures complete slowly, could queued futures starve indefinitely, causing some backup chunks to never process? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Ordering fairness] Does push() add futures to the back of queued (FIFO ordering), ensuring fair processing order, or could certain futures be delayed indefinitely if in_progress is always saturated? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Output ordering] Since queued_outputs uses VecDeque with push_back/pop_front, is output ordering preserved relative to completion time, or could reordering cause backup chunk sequencing issues? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Batch processing fairness] When extend() adds many futures at once, does it properly queue them for fair round-robin processing, or could batch-added futures monopolize in_progress slots? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Priority inversion] Could high-priority backup chunks (e.g., metadata) get stuck in queued behind low-priority chunks (e.g., large data blocks), causing critical backup metadata to be delayed? (Medium)"
]