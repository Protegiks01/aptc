[
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: PackageLocation::Git] [Branch confusion attack] If 'rev' is omitted, does it default to a specific branch? Can an attacker exploit default branch assumptions to inject malicious code by controlling the default branch of a seemingly legitimate repository? (Medium)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: PackageLocation::Aptos] [Node URL SSRF] The node_url is stored as String without validation - can an attacker provide internal URLs like 'http://localhost:8080/admin' or 'http://169.254.169.254/latest/meta-data' to perform SSRF attacks against build systems or validator infrastructure? (High)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: PackageLocation::Aptos] [Package address spoofing] Is the package_addr validated to ensure it points to a legitimate published package? Can an attacker specify addresses of unrelated contracts or malicious packages deployed at specific addresses to inject backdoors? (Critical)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: PackageLocation::Aptos] [Network confusion] The TODO comment mentions accepting network names like 'mainnet' - if implemented, could an attacker exploit network name aliasing to cause packages to fetch dependencies from testnet when mainnet is intended, or vice versa? (High)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Struct: RawDependency] [Multiple location validation] The deserializer checks that only one of (local, git, aptos) is specified, but does the error case handling allow for race conditions or partial state where multiple locations could be set through concurrent deserialization? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Dependency::deserialize()] [Field dependency validation] The macro error_on_unneeded_fields checks that rev/subdir require git and address requires aptos, but can an attacker exploit the order of checks to bypass validation by providing fields in specific sequences? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Dependency::deserialize()] [Missing address for Aptos] When aptos is Some but address is None, an error is returned - but is the error handling robust? Could a partial state leak or cause issues in error recovery paths? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Dependency::deserialize()] [Redundant field error] The error messages for redundant fields could leak information about expected structure - could this help attackers craft exploits by understanding internal validation logic? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Struct: Dependency] [Version field unused] The comment says version is 'not in use by the package resolver, yet' - does this mean version constraints are completely ignored? Can an attacker specify any version and have malicious/incompatible versions resolved, breaking build reproducibility? (Medium)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: UpgradePolicy] [Policy downgrade attack] Can an attacker publish a package with UpgradePolicy::Compatible, then later modify the on-chain policy to Immutable to prevent security fixes, or vice versa to enable unauthorized upgrades? (High)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: UpgradePolicy] [None/Some(Immutable) confusion] The upgrade_policy is Option<UpgradePolicy> - is None treated the same as Some(Compatible) or Some(Immutable)? Could ambiguity in default behavior allow unauthorized upgrades? (Medium)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Enum: UpgradePolicy] [Serde rename exploitation] The enum variants use #[serde(rename)] - are the string values 'compatible' and 'immutable' the only accepted values? Could an attacker exploit case variations or Unicode to bypass policy checks? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Field: PackageMetadata.upgrade_policy] [Policy enforcement gap] The manifest declares the policy but doesn't enforce it - is enforcement handled properly downstream? Could there be a gap where manifests declare Immutable but on-chain upgrades still proceed? (High)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: deserialize_unique_vec()] [Duplicate detection bypass] The uniqueness check uses BTreeSet::insert() and String comparison - are strings compared byte-for-byte or with Unicode normalization? Can an attacker use visually identical but byte-different strings to bypass duplicate detection? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: deserialize_unique_vec()] [Empty authors list] Is an empty authors list valid? Could packages with no authors bypass accountability mechanisms or attribution requirements in package registries? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: deserialize_unique_vec()] [Author name injection] Are author names validated for malicious content? Can an attacker inject executable scripts, shell commands, or path traversal sequences in author names that get unsafely rendered in build logs or UIs? (Medium)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Field: PackageMetadata.authors] [DoS via large author list] Is there a limit on the number of authors? Can an attacker provide thousands or millions of unique author names to cause memory exhaustion during parsing or rendering? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Field: PackageMetadata.license] [License field abuse] The license field is optional String without validation - can an attacker inject extremely long strings, executable content, or path traversal sequences that get unsafely processed by downstream tools? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Struct: BuildOptions] [Language version downgrade] The TODO comment says language_version is currently unused - when implemented, could an attacker force a package to compile with an older, vulnerable language version to exploit known compiler bugs? (Medium)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Struct: BuildOptions] [Future field injection] BuildOptions has #[serde(deny_unknown_fields)] - when new build options are added in the future, could backward compatibility issues allow old parsers to accept manifests that new parsers reject, creating version-specific vulnerabilities? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Field: PackageManifest.build] [Optional build options] Build options are optional - does None mean 'use defaults' or 'no restrictions'? Could ambiguity in defaults allow unsafe builds when no build section is specified? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Version::serialize()] [Serialization format consistency] Version serializes using Display trait - does this produce output that deserialize() can parse back correctly? Could there be round-trip issues with leading zeros or formatting differences? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: AddressAssignment::serialize()] [Unspecified serialization] Unspecified serializes as '_' - is this distinguished from a named address called '_'? Could serialization/deserialization create address confusion? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Dependency::serialize()] [RawDependency conversion] Dependency serializes through to_raw() - can this conversion introduce inconsistencies or drop validation that was enforced during deserialization? (Low)",
  "[File: third_party/move/tools/move-package-manifest/src/manifest.rs] [Function: Dependency::into_raw()] [Move vs clone semantics] Both into_raw() and to_raw() exist - does clone() properly deep-copy all fields, or could there be shallow copy issues with PathBuf, Url, or String fields? (Low)"
]