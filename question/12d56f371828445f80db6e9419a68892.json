[
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: function_cache] [Stale function references] After a module upgrade, can the function_cache contain Rc<LoadedFunction> references to old module versions, causing execution of outdated code instead of upgraded code? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Enum: PerInstructionCache::Call] [Module version confusion] When PerInstructionCache stores function references, if modules are reloaded or upgraded, can the cache serve functions from the wrong module version causing type mismatches? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_type()] [Struct definition staleness] If a struct definition changes between transactions but the cache persists, can get_struct_type() return Type instances based on outdated struct layouts? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [Cache lifetime vs module lifetime] Are cache lifetimes properly bounded to module lifetimes, or can caches outlive the modules they reference, causing use-after-free when accessing module-dependent type information? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: generic_function_cache] [Generic specialization confusion] Can the generic_function_cache serve incorrect function instantiations if the FunctionInstantiationIndex is reused after module reload with different generic parameters? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [BTreeMap key collision] Can malicious bytecode craft index values (FieldInstantiationIndex, StructDefInstantiationIndex, etc.) that collide in the BTreeMap, causing one type instantiation to overwrite another? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Macro: get_or_insert!] [Entry API vulnerability] Does the BTreeMap Entry API properly handle concurrent modifications during the Vacant entry insertion, or can race conditions cause cache corruption? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: field_instantiation] [BTreeMap capacity exhaustion] Can an attacker craft bytecode that forces BTreeMap rebalancing operations millions of times, causing validator CPU exhaustion even if total memory usage is bounded? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_variant_field_type_and_struct_type()] [Index value manipulation] Can VariantFieldInstantiationIndex values be crafted to have malicious bit patterns that exploit BTreeMap Ord implementation bugs, causing incorrect cache lookups? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: single_sig_token_type] [SignatureIndex bounds] Are SignatureIndex values properly validated before BTreeMap insertion, or can out-of-bounds indices cause cache pollution with invalid signature types? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: per_instruction_cache] [Verification bypass comment] The comment states 'if entry is present...we do NOT need to re-check for any errors that only depend on the argument of the bytecode instructions' - can an attacker poison the cache to bypass verification checks on subsequent executions? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Enum: PerInstructionCache] [Instruction cache assumption violation] If cached PerInstructionCache entries are reused assuming bytecode hasn't changed, but bytecode was actually modified (via module upgrade or cache sharing bug), can this execute unverified code? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: make_rc_for_function()] [Code size validation bypass] Does make_rc_for_function() validate that function.code_size() is reasonable, or can maliciously large values bypass bytecode verification size limits through the cache? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Macro: get_or_insert!] [Lazy verification] Since get_or_insert! defers type computation to first access, can an attacker craft bytecode where type errors are cached during a permissive execution context and reused in a restrictive context? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [Type computation caching] If frame.get_generic_struct_ty() and similar functions perform security-critical validations, does caching their results skip these validations on cache hits, creating verification gaps? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: function_cache] [Cross-function cache pollution] Can a malicious function populate its FrameTypeCache with poisoned entries that leak into other functions' caches through the shared Rc<RefCell<_>> references? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Enum: PerInstructionCache::Call] [Recursive function cache sharing] When recursive functions store Call cache entries pointing to their own FrameTypeCache, can stack depth limitations be bypassed by caching deep recursion state? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: generic_function_cache] [Generic instantiation confusion] Can two functions with the same FunctionInstantiationIndex but different type parameters share cache entries, causing type confusion when the cache is accessed? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_fields_types()] [Field layout confusion] If multiple structs have the same StructDefInstantiationIndex but different field layouts, can the cache serve wrong field types causing memory corruption when accessing struct fields? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache, Field: instantiated_local_tys] [Local variable type confusion] Can cached instantiated_local_tys be incorrectly shared between functions with different generic parameters, causing local variable type mismatches? (High)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_struct_fields_types()] [Gas bombing through type complexity] Can an attacker create struct instantiations with thousands of fields where each field has complex nested types, causing the Vec allocation and num_nodes() calculations to consume excessive gas before limits are enforced? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Struct: FrameTypeCache] [Cache insertion gas asymmetry] Is gas properly charged for BTreeMap insertions vs lookups, or can an attacker exploit cache misses to perform more expensive operations than their gas payment covers? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: get_variant_field_type_and_struct_type()] [Variant instantiation gas] Does variant field instantiation properly charge gas for both the variant tag check and field type instantiation, or can attackers use variants to get discounted type operations? (Low)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Macro: get_or_insert!] [Closure execution gas] If the $ty_func closure performs expensive computations (frame.instantiate_ty, etc.), is gas properly charged before executing the closure, or can OOM occur before gas limits trigger? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/runtime/src/frame_type_cache.rs] [Function: make_rc_for_function()] [Function cache creation gas] Is gas charged proportionally to function.code_size() when creating per_instruction_cache vectors, or can large functions create massive caches while paying minimal gas? (Low)"
]