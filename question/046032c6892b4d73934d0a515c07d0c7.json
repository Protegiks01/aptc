[
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::cur()] [Panic vulnerability] Can an attacker craft a malicious AST structure that causes the lines vector to become empty, triggering an unwrap panic when cur() calls lines.last_mut().unwrap(), potentially crashing the compiler during smart contract compilation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::cur()] [Denial of service] Does the cur() method have any bounds checking before calling unwrap() on last_mut(), or can concurrent modifications to the lines vector cause it to be empty at line 86, leading to compilation failures that block contract deployment? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::write()] [Memory exhaustion] Can an attacker submit deeply nested AST structures that cause unbounded string growth at line 99, where cur.push_str() appends to the current line without size limits, potentially exhausting compiler memory and preventing legitimate contract compilation? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::write()] [Resource exhaustion] At lines 96-98, the margin spacing loop (0..margin).for_each(|_| cur.push(' ')) lacks bounds checking on margin value - can a malicious AST with extreme nesting depth cause integer overflow in margin calculation, leading to massive memory allocation or infinite loop? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::write()] [Integer overflow] Does the margin value used at line 94 have an upper bound check? Can crafted AST structures with thousands of nested levels cause margin to overflow usize::MAX, wrapping to 0 and corrupting output formatting or causing logic errors? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::write()] [Unbounded growth] The cur.push_str(s.as_ref()) call at line 99 appends arbitrary strings without length validation - can an attacker provide extremely long identifier names or string literals in Move code that cause O(nÂ²) memory growth when combined with multiple write() calls? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::new_line()] [Memory exhaustion] Can an attacker craft AST structures that trigger excessive new_line() calls at line 90, causing the lines vector to grow unboundedly and exhaust compiler memory, potentially preventing compilation of legitimate contracts? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::new_line()] [Vector growth] At line 90, self.lines.push(String::new()) grows the vector without capacity checks - can pathological AST structures with millions of nodes cause Vec reallocation thrashing, degrading compiler performance and creating DoS conditions? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::indent()] [Integer underflow] At lines 109-111, margin is incremented then decremented (self.margin += inc; ... self.margin -= inc) - can deeply nested recursive AST traversal cause margin arithmetic to underflow below 0 if decrement happens without corresponding increment due to early returns or panics in closure f? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::indent()] [Integer overflow] Does the margin increment at line 109 check for overflow? Can an attacker provide AST structures with extreme nesting depth causing self.margin += inc to overflow usize::MAX, wrapping to small values and corrupting indentation logic or causing infinite loops in write()? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::indent()] [Stack overflow] Can deeply nested AST structures cause recursive indent() calls through the closure f at line 110, leading to stack exhaustion and compiler crashes when processing maliciously crafted Move code with thousands of nested blocks? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::indent()] [State corruption] If the closure f panics between lines 109-111, the margin decrement at line 111 may not execute, permanently corrupting the AstWriter state - can this cause subsequent compilation attempts to produce incorrect output or fail entirely? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::indent()] [Logic error] The indent method calls new_line() twice (lines 108, 112) - can this interaction with margin modifications cause off-by-one errors in line tracking, potentially hiding compilation errors or producing misleading error messages? (Low)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::block()] [Stack overflow] At line 117, block() calls indent(4, f) which recursively invokes closure f - can malicious AST structures with deeply nested blocks cause unbounded recursion, exhausting stack space and crashing the compiler? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::block()] [Unbounded nesting] Does block() have any depth limit checks before calling indent() at line 117? Can an attacker submit Move code with thousands of nested {} blocks, each calling block() recursively until stack overflow occurs? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::block()] [Format string injection] The write(",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::annotate()] [Recursion depth] At line 122, annotate() calls annotate_gen() which invokes annot.ast_debug(w) - can circular references in AST annotation structures cause infinite recursion, leading to stack overflow and compiler crashes? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::annotate_gen()] [Stack overflow] Between lines 135-143, annotate_gen() calls closure f and annot_writer which may recursively call back to annotate() - can deeply annotated AST nodes cause unbounded recursion chains, exhausting stack space? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::annotate_gen()] [String injection] At lines 140-141, annot_writer(self, annot) writes arbitrary annotation content - can malicious annotations contain format specifiers or control characters that corrupt subsequent output or cause parsing errors in debug consumers? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::annotate()] [Memory exhaustion] When verbose mode is enabled (line 135), annotations are written for every AST node - can extremely large AST structures with verbose annotations cause exponential memory growth in the lines vector? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Size hint violation] At lines 153-157, the code checks size_hint() and asserts lower == 0 if upper is None, then returns early - can malicious iterator implementations with incorrect size hints bypass list processing, causing AST nodes to be silently dropped from output? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Logic bypass] The size hint check at lines 153-157 assumes if upper is None, lower must be 0, but this may not hold for all iterators - can custom iterators with (lower > 0, None) size hints trigger the assertion at line 155, causing compiler panic? (High)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Silent data loss] If an iterator returns (0, None) as size_hint(), the method returns at line 156 without processing any items - can this cause important AST nodes to be omitted from debug output, hiding compilation errors or security issues in Move code? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Index confusion] At lines 160-167, the loop compares idx + 1 != len to determine if separator should be added - can iterator length mismatches between size_hint() and actual item count cause missing separators or extra separators in output? (Medium)",
  "[File: aptos-core/third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/ast_debug.rs] [Function: AstWriter::list()] [Unbounded iteration] The enumerate() loop at line 160 has no bounds check - can infinite iterators or extremely long item lists cause the compiler to hang indefinitely while formatting AST output? (High)"
]