[
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Same kind exemption] At lines 1781-1783, sibling edges of the same Call kind are exempted - can this be abused by creating calls that return multiple references to the same location, then freezing one while keeping others mutable? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Derived temps exclusion] Lines 1814-1873 exclude derived temps from the mutable reference check - can manipulating the derived_from map allow freezing while mutable references exist? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: freeze_ref()] [Transitive children bypass] At lines 1822-1823, transitive children of the label are checked - but can non-transitive mutable borrows (siblings of ancestors) escape this check? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: assign()] [Inferred assignment confusion] The AssignKind::Inferred logic at lines 1534-1542 decides between move and copy based on heuristics - can edge cases cause incorrect classification, allowing move of a borrowed value? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: move_ref()] [Label transfer race] At lines 790-796, the label is removed from src and added to dest non-atomically - can this create a window where neither temp owns the label? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: copy_ref()] [Derived marking bypass] Copy_ref at lines 800-805 marks the destination as derived from source - but can this marking be lost during graph joins, causing the copied ref to bypass v1 semantics checks? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: replace_ref()] [Non-release on borrowed] Replace_ref at lines 775-787 releases the old reference, but what if it's still borrowed? Can this cause the borrow graph to incorrectly drop active borrow edges? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [Parameter index bypass] At line 1915, the check is `local >= get_parameter_count()` - can off-by-one errors or incorrect parameter indexing allow returning references to locals? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [Root confusion] The roots() call at line 1902 finds ancestors - can a graph structure with multiple roots cause some to be missed, allowing return of global-derived references? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: return_()] [External bypass] At line 1927, External and Derived locations are exempted - can all references be marked as External through manipulation, bypassing all return restrictions? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: read_ref()] [Missing safety check] Read_ref at lines 1937-1942 doesn't call check_borrow_safety - can reading through a reference violate safety if the graph is in an unsafe state? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: write_ref()] [Insufficient borrow check] Write_ref at lines 1945-1958 only checks if dest has children, not if it's part of an unsafe borrow pattern - can this allow writes that violate borrow safety? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: move_from()] [Resource extraction race] The move_from check at lines 1878-1893 verifies no borrows exist, but can concurrent operations create borrows after the check but before extraction? (Note: This is a compiler, not runtime, so probably not applicable) (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: could_overlap()] [Field overlap logic] The overlap check at lines 258-264 only considers field identity - can different paths to the same field through generic type instantiation bypass this check? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: any_could_overlap()] [Short-circuit bypass] At lines 267-270, if any pair overlaps the function returns true - but can the cartesian product logic miss overlaps due to set ordering? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: is_mut()] [Edge kind checking] The is_mut check at lines 240-249 pattern matches - can new edge kinds be added without updating this, causing mutable edges to be treated as immutable? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: new_from_code_offset()] [Label collision] Code offset labels at lines 278-280 use 16-bit offset and 8-bit qualifier - can programs with >64K bytecode or >256 qualifiers cause label collisions? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: new_from_counter()] [Counter collision] Counter labels at lines 284-287 shift by 24 bits - can this collide with code offset labels if counter exceeds certain values? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: roots()] [Incomplete traversal] The roots() function at lines 831-854 uses a todo list - can cycles in the parent graph cause infinite loops despite the 'done' set? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: transitive_children()] [Cycle handling] Transitive children at lines 857-871 includes the starting node - can cycles cause the result set to be incorrect? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: error_with_hints()] [Error suppression bypass] Errors are suppressed if suppress_errors is true at lines 1396-1404 - can this be exploited to compile unsafe code in production by manipulating compiler flags? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: diverging_edge_error()] [Error ordering] At lines 1295-1296, edges are ordered by location for error messages - can this ordering affect which error is reported first, potentially hiding more critical issues? (Low)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: release_refs_not_alive_after()] [Liveness annotation trust] The code trusts LiveVarAnnotation at line 885 - can incorrect liveness analysis from a prior pass cause safety violations to go undetected? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: release_refs_not_alive_after()] [Alive.after check] Only refs in alive.after are kept at lines 1109 - can temporaries that should be alive be incorrectly marked as dead, causing premature release? (High)",
  "[File: third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs] [Function: execute()] [Instruction preprocessing] Borrow safety is checked before processing at lines 1976-2008 - can the state after preprocessing but before execution differ, causing TOCTOU issues? (Medium)"
]