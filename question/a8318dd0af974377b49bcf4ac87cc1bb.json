[
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 192-195] [VARIABLE_COALESCING] Can variable coalescing create incorrect aliasing or extend variable lifetimes beyond their intended scope, potentially violating Move's borrow checker guarantees and causing use-after-free? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 221-224] [AST_SIMPLIFY] Does AST simplification correctly preserve all semantic meaning, or can it eliminate side effects or reorder operations in ways that violate Move's sequential execution guarantees? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 226-230] [AST_SIMPLIFY_FULL] Since AST_SIMPLIFY_FULL includes code elimination and inherits from OPTIMIZE_EXTRA, can combining multiple aggressive optimizations create emergent bugs that don't occur with individual optimizations? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 242-245] [FLUSH_WRITES_OPTIMIZATION] Can flush-writes-optimization reorder or eliminate writes to global storage in ways that violate atomicity guarantees or create race conditions in parallel execution? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 166-169] [CFG_SIMPLIFICATION] Does control flow graph simplification preserve all reachability properties, or can it create unreachable error handling code that should be accessible, masking runtime failures? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 151-154] [OPTIMIZE meta-experiment] Since OPTIMIZE defaults to true and controls multiple child optimizations, can the interaction between CFG_SIMPLIFICATION, DEAD_CODE_ELIMINATION, PEEPHOLE_OPTIMIZATION, and others create semantic bugs that don't exist when optimizations are disabled? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Environment: MVC_EXP] [Injection attack] Can an attacker with control over the MVC_EXP environment variable inject malicious experiment settings (e.g., MVC_EXP=checks=off,unsafe-package-visibility=on) to disable all safety checks during framework code compilation? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Environment: MOVE_COMPILER_EXP] [Priority bypass] Since environment variables are checked before defaults, can setting MOVE_COMPILER_EXP override hardcoded safety defaults even when not explicitly set via command line, bypassing intended protections? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Environment parsing] [Malformed input] Can crafted environment variable values with special characters, extremely long strings, or malformed key=value pairs cause buffer overflows, injection attacks, or compiler crashes during parsing? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Command line: --experiment] [Override priority] Since command line experiments override environment variables and defaults, can a malicious build script or wrapper inject --experiment flags to silently disable safety checks without user knowledge? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Command line: --experiment] [Later override] Does the 'later entries override earlier ones' behavior in find_experiment() allow conflicting experiments on the same command line to create ambiguous compiler states? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 203-208] [KEEP_INLINE_FUNS] If keep-inline-funs=false removes inlined functions from the model, can this break debugging, error reporting, or gas metering that relies on function presence? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 210-214] [LIFT_INLINE_FUNS] Can lambda lifting of inline functions change capture semantics or variable scoping in ways that violate Move's lexical scoping rules? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 216-219] [SKIP_INLINING_INLINE_FUNS] Does skipping inlining of inline functions create inconsistencies in whether lambdas are lifted or not, potentially changing program semantics? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 135-138] [LAMBDA_LIFTING_INLINE] Can enabling lambda-lifting-inline cause closure captures to escape their intended scope, creating dangling references or violating borrow checker invariants? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 109-113] [INLINING_OPTIMIZATION] Since inlining-optimization inherits from EXTENDED_FRAMEWORK_OPTIMIZATIONS (default false), can framework code compiled with different optimization settings than user code cause linking or compatibility issues? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 247-252] [STOP_BEFORE_STACKLESS_BYTECODE] Can stop-before-stackless-bytecode be exploited to halt compilation after AST passes but before bytecode generation, potentially bypassing bytecode-level security checks? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 254-259] [STOP_BEFORE_FILE_FORMAT] Does stop-before-file-format prevent final bytecode verification, allowing partially compiled code to be deployed that hasn't passed all validation stages? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 261-265] [STOP_BEFORE_EXTENDED_CHECKS] Can stop-before-extended-checks combined with skip-bailout-on-extended-checks completely bypass extended bytecode verification, allowing invalid bytecode deployment? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 267-271] [STOP_AFTER_EXTENDED_CHECKS] Is stop-after-extended-checks a pure testing flag, or could it be exploited to generate checked but non-executable bytecode artifacts? (Low)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 54-59] [REFERENCE_SAFETY_V3] Since reference-safety-v3 is true by default, can forcing it to false revert to an older, potentially vulnerable reference safety checker with known bugs? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 50-53] [REFERENCE_SAFETY inheritance] Does REFERENCE_SAFETY inheriting from CHECKS mean that disabling CHECKS also disables reference safety, even when REFERENCE_SAFETY_V3 is enabled? (Critical)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 130-133] [SPEC_REWRITE] Can enabling spec-rewrite (default false) modify formal specifications in ways that weaken safety properties or introduce logical errors? (Medium)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 125-128] [SPEC_CHECK inheritance] Since spec-check inherits from CHECKS, does disabling CHECKS completely bypass specification checking even for critical system modules? (High)",
  "[File: third_party/move/move-compiler-v2/src/experiments.rs] [Lines: 146-149] [SPLIT_CRITICAL_EDGES] Can disabling split-critical-edges create control flow graph structures that violate SSA form or cause incorrect dataflow analysis in later optimization passes? (High)"
]