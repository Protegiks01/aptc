[
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Constant: DEFAULT_AMOUNT_TO_FUND] At line 48, the default is 100 billion OCTA (100,000 APT). Can this large default be exploited if maximum_amount is not set, allowing attackers to drain massive amounts? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Constant: DEFAULT_ASSET_NAME] At line 45, DEFAULT_ASSET_NAME is 'apt'. Can asset name validation be bypassed by using uppercase 'APT' or other variations to bypass rate limits or amount restrictions? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Lock Acquisition Order] The function acquires locks in different orders: funder_account write lock (line 217), outstanding_requests write lock (line 238). Can this inconsistent lock ordering cause deadlocks when multiple threads execute concurrently? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Sleep Duration Vulnerability] At line 283, the function sleeps for 500ms when waiting for catchup, but at line 267 it sleeps for 1ms in the queue. Can this timing difference be exploited to create denial of service by keeping the system in the 500ms sleep state? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Resetter Drop Timing] At line 227, NumOutstandingTransactionsResetter is created but only drops at function end. If the function panics or is cancelled, can this cause NUM_OUTSTANDING_TRANSACTIONS to remain non-zero permanently? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Sequence Number Increment] The function increments funder_account.sequence_number() internally but this happens outside the critical section. Can another thread read an inconsistent sequence number between the increment and lock release? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Outstanding Requests Memory Leak] If a request is added to outstanding_requests at line 242 but never reaches the front (e.g., due to crash or restart), can this cause a memory leak where entries accumulate indefinitely? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Error Propagation] At line 215, get_sequence_numbers() can return an error, but if this happens after the resetter is created, can the error cause NUM_OUTSTANDING_TRANSACTIONS to be reset even though no transaction was attempted? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: get_sequence_numbers()] [Partial Failure Handling] At lines 322-326, if the receiver account fetch fails but funder succeeds, the receiver_seq_num is set to None. Can this None value cause issues downstream where it's used without proper checking? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: submit_transaction()] [Committed Hash Race] At lines 383 and 392, signed_transaction.committed_hash() is logged. Can multiple threads modify the transaction between submission and logging, causing incorrect hashes to be recorded? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: GasUnitPriceManager::new()] [Uninitialized State] At line 415, gas_unit_price starts at 0 and last_updated starts at None. If a request comes in immediately after construction, can this uninitialized state cause transactions to fail or use incorrect gas? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: AssetConfig::get_key()] [UTF-8 Conversion Failure] At line 492, String::from_utf8() can fail. Can an attacker provide a key file with invalid UTF-8 that passes BCS parsing but fails UTF-8 conversion, causing the key loading to fail at a critical moment? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Asset Name Injection] At line 212, asset_name is passed as &str and used as a HashMap key. Can an attacker inject special characters or extremely long strings to cause HashMap collisions or memory exhaustion? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Amount Overflow] At line 210, amount is u64. Can providing u64::MAX cause integer overflow when calculating total funds transferred or checking against maximum_amount? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: submit_transaction()] [Receiver Address Validation] At line 347, receiver_address is passed by reference but never validated. Can an attacker provide an invalid address (e.g., system address, zero address) to exploit special account behavior? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Struct: TransactionSubmissionConfig] [Gas Unit Price Validation] At line 112, gas_unit_price_override is Option<u64> with no validation. Can setting this to 0 cause transactions to be rejected, or to u64::MAX cause overflow in total gas calculations? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Infinite Loop DoS] At line 233, the loop runs for wait_for_outstanding_txns_secs * 2 iterations with 500ms sleeps. Can an attacker keep outstanding transactions high for 30+ seconds to make each request take 15+ seconds, effectively DoSing the faucet? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Queue Starvation] At lines 246-266, requests wait for their turn at the front of the queue. Can an attacker continuously submit requests for a specific asset to starve other assets, preventing any funding for those assets? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: submit_transaction()] [Transaction Spam] If wait_for_transactions=false, transactions are submitted without waiting. Can an attacker spam the faucet with requests to flood the mempool and cause all faucet transactions to expire? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: GasUnitPriceManager::get_gas_unit_price()] [API Rate Limiting] At line 443-447, the function calls estimate_gas_price() without rate limiting. Can rapid calls during cache expiration overwhelm the node API and get the faucet rate-limited or banned? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Sequence Number Divergence] At lines 221-224, the local sequence number is only updated if on-chain is greater. Can this allow local and on-chain sequence numbers to permanently diverge if the local number is artificially increased? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Stale Sequence Number Check] At lines 289-294, sequence numbers are reset if unhealthy, but what if the on-chain sequence changed between the check and reset? Can this cause the reset to use a stale value? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: submit_transaction()] [Sequence Number Decrement Correctness] At line 390, decrement_sequence_number() is called on failure, but what if the transaction actually succeeded on-chain despite the API returning an error? Can this cause permanent sequence number desync? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: get_sequence_numbers()] [Concurrent Sequence Fetches] Multiple threads can call this function simultaneously. Can concurrent fetches return different sequence numbers for the same account due to transactions being processed between calls? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/funder/common.rs] [Function: update_sequence_numbers()] [Metrics Manipulation] At line 281, NUM_OUTSTANDING_TRANSACTIONS is set but only reset by the Drop implementation. Can an attacker crash the process to prevent the reset, causing monitoring to incorrectly show high outstanding transactions? (Low)"
]