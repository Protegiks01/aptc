[
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: DepthFormula::solve()] [Integer overflow] Can an attacker craft type arguments with extremely large depth values that cause integer overflow in saturating_add operations, leading to incorrect depth calculations that bypass VM depth limits and cause stack overflow? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: DepthFormula::subst()] [Missing validation] Does the substitution logic properly validate that all type parameters have corresponding mappings, or can an attacker exploit missing type parameter mappings to cause VM panics or incorrect type instantiation leading to type safety violations? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: DepthFormula::normalize()] [DoS via complexity] Can an attacker provide deeply nested type formulas with many terms that cause excessive computation during normalization, leading to validator slowdown or timeout that affects consensus liveness? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: DepthFormula::scale()] [Integer overflow] Can malicious contracts create types that trigger saturating_add overflow in the scale operation, producing incorrect depth formulas that bypass type depth limits and enable memory exhaustion attacks? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: StructType::fields()] [Variant confusion] Can an attacker exploit the variant field access logic to access fields from wrong variant indices by providing mismatched variant parameters, potentially reading uninitialized memory or causing type confusion? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: StructType::field_at()] [Bounds check bypass] Does the field offset validation properly prevent out-of-bounds access for all variant types, or can an attacker craft specific offset values that bypass bounds checking and access invalid memory regions? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: StructType::check_compatibility()] [Ability downgrade attack] Can a malicious module define a struct with more restrictive abilities than the original definition, then use check_compatibility to bypass ability requirements and violate Move's resource safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: StructType::check_compatibility()] [Phantom type confusion] Can an attacker exploit the phantom type parameter validation to mark non-phantom parameters as phantom, enabling ability violations that allow copying or dropping of resource types? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::verify_ty_arg_abilities()] [Ability constraint bypass] Can an attacker provide type arguments that violate ability constraints but still pass verification due to incomplete checking, enabling resource duplication or unauthorized drops that lead to double-spending? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::abilities()] [Recursive overflow] Can deeply nested struct instantiations with type arguments cause stack overflow during recursive ability calculation, leading to VM crashes or incorrect ability determination that violates type safety? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::abilities()] [Phantom type exploit] Can an attacker abuse phantom type arguments to artificially grant abilities that the base type shouldn't have, bypassing Move's type system restrictions and enabling unauthorized resource operations? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::num_nodes_in_subst()] [Integer overflow] Can an attacker craft type substitutions with extremely large node counts that overflow the u64 counter, causing incorrect size calculations that bypass max_ty_size limits and enable memory exhaustion? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::num_nodes_in_subst()] [Cache poisoning] Can concurrent transactions exploit the thread-local cache to poison it with incorrect node counts, causing subsequent type validations to fail or succeed incorrectly? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::paranoid_check_has_ability()] [Race condition] Can concurrent type checking operations race during ability verification, leading to inconsistent ability determinations across different transaction executions and breaking determinism? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::paranoid_check_assignable()] [Function type confusion] Can an attacker exploit the function type assignability check by providing functions with compatible signatures but different ability sets to bypass type safety checks? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: Type::paranoid_write_ref()] [Drop requirement bypass] Does the write reference validation properly enforce Drop ability for all overwritten values, or can attackers write to references containing non-Drop resources, causing resource leaks or inconsistent state? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::check()] [Off-by-one error] Can attackers craft types with node counts or depths exactly at the limit (max_ty_size or max_ty_depth) that should fail but pass validation due to >= vs > comparison issues? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_ref_ty()] [Depth manipulation] Can an attacker create reference types with manipulated depth calculations that bypass max_ty_depth checks by exploiting the hardcoded depth value of 2? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_vec_ty()] [Depth bypass] Can nested vector types with carefully crafted depth values bypass the depth checking by exploiting the incremental depth counter that starts at 2? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_struct_instantiation_ty()] [Type substitution attack] Can an attacker provide malicious type arguments that cause incorrect type substitution, enabling type confusion that breaks Move's type safety guarantees? (Critical)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_struct_instantiation_ty()] [Size limit bypass] Does the node counting correctly account for the parent struct when checking size limits, or can attackers craft struct instantiations that exceed max_ty_size? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::create_constant_ty_impl()] [Struct constant bypass] Can an attacker find a way to create struct constants despite the explicit prohibition, potentially enabling constant-time struct creation that bypasses module loading security checks? (Medium)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::subst_impl()] [Double counting exploit] Can the type parameter substitution logic that decrements count be exploited to underflow the counter, causing incorrect size calculations that bypass limits? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::clone_impl()] [Unresolved type parameter] Can attackers trigger the unresolved type parameter error path in production code, causing VM crashes that disrupt transaction execution and affect validator consensus? (High)",
  "[File: aptos-core/third_party/move/move-vm/types/src/loaded_data/runtime_types.rs] [Function: TypeBuilder::apply_subst()] [Recursive depth bomb] Can deeply recursive type structures cause stack overflow in apply_subst despite depth checking, by exploiting the recursive nature of Vector, Reference, and StructInstantiation processing? (High)"
]