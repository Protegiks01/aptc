[
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: ADDRESS] [Address Spoofing] Can a malicious implementor override the ADDRESS constant to point to a non-CORE_CODE_ADDRESS value (not 0x1), allowing them to impersonate system resources and bypass access control checks that assume resources are from trusted core modules? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: ADDRESS] [Type Confusion] If an attacker implements MoveStructType with ADDRESS set to a user-controlled address instead of CORE_CODE_ADDRESS, can they create resources that collide with legitimate system resources in storage, potentially causing state corruption or fund theft? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: ADDRESS] [Privilege Escalation] Can an attacker define a struct implementing MoveStructType with ADDRESS = AccountAddress::ONE (0x1) but MODULE_NAME/STRUCT_NAME matching user modules, effectively creating a 'system resource' that bypasses governance or staking permission checks? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: ADDRESS] [Storage Collision] Does the default ADDRESS = CORE_CODE_ADDRESS create a security vulnerability where all implementors without explicit override write to the same address namespace, potentially causing resource path collisions and overwriting critical system state? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: ADDRESS] [Reserved Address Bypass] Can an attacker implement MoveStructType with ADDRESS pointing to other reserved addresses (TOKEN_ADDRESS=0x3, TOKEN_OBJECTS_ADDRESS=0x4, EXPERIMENTAL_CODE_ADDRESS=0x7) to gain unintended privileges or bypass framework restrictions? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: MODULE_NAME] [Identifier Injection] Can an attacker implement MoveStructType with a MODULE_NAME containing invalid characters or special sequences that bypass identifier validation in IdentStr, leading to storage corruption when struct_tag() constructs the StructTag? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: MODULE_NAME] [Module Impersonation] If MODULE_NAME validation is not enforced at trait implementation time, can an attacker create a struct claiming to be from 'coin', 'stake', or 'governance' modules to impersonate critical framework resources and steal funds or manipulate validator sets? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: MODULE_NAME] [Path Traversal] Can MODULE_NAME contain path separator characters ('::' or '/') that could cause path traversal vulnerabilities when constructing storage keys, allowing access to resources in different modules or accounts? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: MODULE_NAME] [Empty/Null Module] Can MODULE_NAME be an empty string or contain null bytes, causing undefined behavior in module_identifier() when converting to owned Identifier, potentially leading to resource lookup failures or storage corruption? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: module_identifier()] [Unicode Normalization] Does module_identifier() properly handle Unicode normalization issues in IdentStr before converting to Identifier, or can visually similar but byte-different module names cause resource collision attacks? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: STRUCT_NAME] [Struct Impersonation] Can an attacker implement MoveStructType with STRUCT_NAME matching critical system structs ('Account', 'Coin', 'StakePool') but different MODULE_NAME/ADDRESS, causing type confusion in resource deserialization and potential fund theft? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: STRUCT_NAME] [Name Collision] If STRUCT_NAME validation doesn't enforce uniqueness within a module namespace, can multiple implementations claim the same struct name, leading to resource_path() collisions and race conditions in state storage? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Constant: STRUCT_NAME] [Reserved Identifiers] Can STRUCT_NAME use reserved Move identifiers like '<SELF>', 'vector', or compiler-generated names, bypassing VM safety checks and causing bytecode verification failures or execution errors? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: struct_identifier()] [Case Sensitivity] Does struct_identifier() enforce case-sensitive comparison, or can attackers create resources with names like 'account' vs 'Account' vs 'ACCOUNT' that collide in case-insensitive storage systems, causing state corruption? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: struct_identifier()] [Length Limits] Does struct_identifier() enforce maximum length limits on STRUCT_NAME before converting to owned Identifier, or can extremely long struct names cause buffer overflows, DoS via memory exhaustion, or storage key size violations? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Type Argument Injection] Can an attacker implement type_args() returning malicious TypeTag vectors with deeply nested structs or circular references, causing infinite recursion in struct_tag() construction or BCS serialization DoS? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Generic Resource Collision] If two implementors have identical ADDRESS/MODULE_NAME/STRUCT_NAME but different type_args() return values, do their resource_path() results collide, allowing one resource to overwrite another in storage? (Critical)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Type Confusion Attack] Can type_args() return TypeTag values that don't match the actual generic parameters of the implementing struct, causing deserialization failures or type confusion when loading resources from storage? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Empty vs Non-Empty Generics] If an implementor incorrectly returns vec![] for type_args() when the struct actually has generic parameters (or vice versa), does this cause resource path mismatches that make resources permanently inaccessible? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Type Argument Order] Can an attacker implement type_args() with type arguments in the wrong order (e.g., Coin<APT, USD> vs Coin<USD, APT>), causing resource path to point to incorrect storage location and enabling cross-resource manipulation attacks? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Recursive Type Arguments] Can type_args() return self-referential TypeTag::Struct entries that create infinite recursion when struct_tag().access_vector() attempts BCS serialization, causing validator nodes to crash and loss of liveness? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: type_args()] [Type Nesting Depth Attack] Can type_args() return deeply nested TypeTag structures exceeding MAX_TYPE_TAG_NESTING limits, bypassing serialization checks and causing stack overflow during resource path generation or BCS encoding? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: struct_tag()] [StructTag Construction Race] Can concurrent calls to struct_tag() from multiple threads cause race conditions if module_identifier() or struct_identifier() have non-atomic state modifications, leading to corrupted StructTag instances? (Medium)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: struct_tag()] [Memory Safety] Does struct_tag() properly validate that ADDRESS, module_identifier(), struct_identifier(), and type_args() are all valid before constructing StructTag, or can partial initialization create invalid StructTag instances that cause undefined behavior? (High)",
  "[File: third_party/move/move-core/types/src/move_resource.rs] [Trait: MoveStructType, Method: struct_tag()] [StructTag Immutability] After struct_tag() returns a StructTag instance, can its fields (address, module, name, type_args) be mutated before being used in resource_path(), creating a TOCTOU vulnerability where validation passes but storage uses different values? (High)"
]