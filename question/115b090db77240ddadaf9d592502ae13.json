[
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [System account funding] Does receiver validation check if the resolved AccountAddress is a system address (0x1, 0x2, etc.) that should never be funded, or can attackers drain faucet funds to system accounts? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Zero address funding] Can attackers request funding for the zero address (0x0), potentially causing undefined behavior in downstream transaction creation or account creation logic? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Receiver uniqueness] If multiple requests target the same receiver concurrently, does CheckerData track this properly, or can race conditions in checker state cause double-funding before rate limits update? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Header map clone overhead] HeaderMap is cloned into Arc for every request - can attackers send requests with enormous header maps (e.g., 1000+ headers) to cause memory exhaustion or slow down request processing? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Time skew exploitation] get_current_time_secs() is used for time_request_received_secs - if system time is manipulated or skewed, can attackers exploit time-based rate limiting by setting system clock backwards? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [CheckerData immutability] CheckerData is cloned for each checker/bypasser - if checkers modify shared state referenced by Arc<HeaderMap>, can concurrent modifications cause race conditions? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Bypasser privilege escalation] If any bypasser returns true, the request bypasses ALL checkers and storage - can attackers exploit vulnerabilities in a single weak bypasser to completely circumvent rate limiting, IP blocking, and captcha? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Bypasser error handling] BypasserError is returned if request_can_bypass fails - does this leak information about internal bypasser logic that attackers can use to craft bypass-eligible requests? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Bypasser short circuit] The function returns immediately when a bypasser says yes - can attackers exploit this to avoid triggering defensive logging that would occur if checkers ran? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Bypasser order dependency] Bypassers are checked in Vec order - can attackers exploit differences in bypasser evaluation order by crafting requests that satisfy later bypassers after earlier ones fail? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Bypasser state corruption] If a bypasser has internal state (e.g., whitelist cache), can attackers exploit race conditions in async bypasser execution to corrupt this state across concurrent requests? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Checker accumulation] rejection_reasons.extend() accumulates all checker failures - can attackers learn about all active checkers by intentionally triggering every rejection reason, enabling them to craft targeted bypass attempts? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Early return exploitation] When return_rejections_early is true, checking stops after first rejection - does this create a side channel where attackers can determine checker ordering and focus attacks on early checkers? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Checker error vs rejection] Checker.check() can return error OR rejection_reasons - can attackers distinguish between checker failures (CheckerError) and intentional rejections to probe system health? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Dry run state pollution] The dry_run parameter is passed to checker.check() - do checkers properly avoid modifying persistent state during dry runs, or can attackers use is_eligible to pollute rate limiting databases? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Checker order exploitation] Checkers run in Vec order - can attackers exploit checker ordering to bypass rate limits by ensuring cheaper checkers (IP-based) run before expensive ones (captcha) and get rejected differently? (Medium)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Partial checker failure] If some checkers succeed and others fail, does the rejection reasons list expose which specific checkers passed, allowing attackers to incrementally learn about security controls? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::preprocess_request()] [Checker state races] Multiple concurrent requests from same IP/account hit different checkers in parallel - can race conditions in checker state updates allow N concurrent requests to each see N-1 prior requests as not yet rate-limited? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Bypass flag persistence] The bypass flag from preprocessing is passed to funder.fund() - if bypass=true, does this completely skip all funding preconditions including account existence checks, allowing creation of duplicate accounts? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Asset parameter trust] The asset parameter is passed directly to funder without validation - can attackers specify assets that the funder is not authorized to mint/transfer, causing unauthorized token creation? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Amount enforcement bypass] If fund_request.amount is set to Some(u64::MAX), does the funder properly cap this to the configured maximum, or can attackers drain the entire faucet balance in one request? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Check_only flag confusion] The check_only=false flag ensures transactions are submitted - but if an attacker can manipulate this to false during is_eligible calls, could they receive funds through the eligibility endpoint? (Critical)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Transaction hash extraction] txn_hashes are extracted from both Ok and Err results - if an error occurs mid-transaction, can partially successful transactions be hidden in the error path while funds are still transferred? (High)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [JWT sub logging] jwt_sub() is called but errors are silently ignored with .ok() - can attackers exploit JWT parsing errors to avoid proper request attribution in logs, hindering forensic analysis? (Low)",
  "[File: aptos-core/crates/aptos-faucet/core/src/endpoints/fund.rs] [Function: FundApiComponents::fund_inner()] [Success flag manipulation] The success = fund_result.is_ok() log field can be misleading if transaction submission succeeds but on-chain execution fails - can this cause incorrect rate limit updates? (Medium)"
]