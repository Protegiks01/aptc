[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Type_::UnresolvedError] [Error Propagation] Does UnresolvedError get properly caught and rejected before bytecode generation, or can unresolved types slip through to the VM causing type confusion during execution that could lead to memory corruption or incorrect resource accounting? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Display: Type_ (lines 950-973)] [Type Display Ambiguity] Can the Display implementation create ambiguous type representations (e.g., multiple ways to display the same type) that cause confusion in error messages or make it harder to detect malicious type substitutions in compiler diagnostics? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: Fields<T> (line 153)] [Field Ordering] Can the Fields type (UniqueMap<Field, (usize, T)>) be exploited where the usize index doesn't match the actual field position, causing field access reordering that corrupts struct layouts and allows attackers to access wrong memory locations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: Visibility] [Access Control Bypass] Can an attacker exploit the Visibility enum variants (Public, Friend, Package, Internal) to elevate function visibility by manipulating location information, allowing unauthorized cross-module function calls that bypass friend declarations? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Visibility::Friend] [Friend Bypass] Can the Friend(Loc) visibility be circumvented by creating modules that aren't in the friend list but have manipulated module identifiers, allowing non-friend modules to call friend-only functions and violating encapsulation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Visibility::Package] [Package Boundary Violation] Does the Package(Loc) visibility correctly enforce package boundaries, or can modules from different packages with name collisions bypass the package visibility restriction and call package-private functions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Variant: Visibility::Internal] [Internal Exposure] Can Internal visibility be exploited when combined with inline functions or spec blocks to expose internal functions outside their defining module, allowing external calls to private implementation details? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Function: Visibility::loc (lines 810-817)] [Location Manipulation] Can the loc() method's Option<Loc> return be exploited where Internal returns None to bypass location-based access checks, making the compiler unable to verify visibility constraints properly? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Display: Visibility (lines 928-937)] [Visibility String Injection] Does the Display implementation properly validate visibility strings match the constants (PUBLIC, FRIEND, PACKAGE, INTERNAL), or can malformed visibility strings in error messages confuse developers about actual access controls? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: Program] [Module Registry Corruption] Can the Program struct's UniqueMap<ModuleIdent, ModuleDefinition> be exploited through hash collisions or key manipulation to register multiple modules with the same identifier, causing module resolution ambiguity and potential function call hijacking? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: ModuleDefinition] [Dependency Order Attack] Can the dependency_order field (initialized at 0, set in uses pass) be manipulated to create circular dependencies or incorrect topological ordering, causing initialization race conditions where uninitialized modules are called? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: ModuleDefinition::immediate_neighbors] [Neighbor Spoofing] Can the immediate_neighbors UniqueMap<ModuleIdent, Neighbor> be corrupted to include false dependencies or exclude actual dependencies, bypassing dependency validation and allowing modules to access resources they shouldn't see? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: ModuleDefinition::friends] [Friend Declaration Forgery] Can the friends UniqueMap be manipulated to add unauthorized friend modules after initial compilation, allowing attacker-controlled modules to call friend-only functions in Aptos framework modules? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: ModuleDefinition::is_source_module] [Source Module Spoofing] Can the is_source_module boolean be exploited to make library modules appear as source modules or vice versa, bypassing compilation restrictions that distinguish between user code and library code? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: StructDefinition] [Ability Constraint Bypass] Can the abilities field in StructDefinition be modified after initial declaration to grant additional abilities to struct instances, allowing non-storable resources to be stored in global storage bypassing Move's safety model? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: StructTypeParameter] [Phantom Type Confusion] Can the is_phantom flag in StructTypeParameter be exploited to treat phantom type parameters as regular parameters or vice versa, causing type variance violations that allow invalid type substitutions in generic structs? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Enum: StructLayout] [Layout Confusion] Can an attacker exploit differences between StructLayout::Singleton, StructLayout::Variants, and StructLayout::Native to create struct layout confusion attacks where field offsets are calculated incorrectly causing memory corruption? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: StructVariant] [Variant Tag Manipulation] Can the StructVariant struct's fields be manipulated to create enum variants with duplicate names or incorrect field layouts, causing pattern matching errors or wrong variant selection in match expressions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: StructVariant::is_positional] [Positional Field Confusion] Can the is_positional flag be exploited to treat named fields as positional or vice versa, causing field access confusion where attacker-controlled struct constructors write to wrong field positions? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: Function] [Entry Function Bypass] Can the entry field (Option<Loc>) be manipulated to make non-entry functions appear as entry points or hide actual entry functions, allowing unauthorized transaction entry points that bypass prologue checks? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: Function::inline] [Inline Function Exploitation] Can inline functions with the inline flag be exploited to bypass gas metering or create code size explosion attacks where inline expansion causes excessive gas consumption or VM stack overflow? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: Function::acquires] [Acquires Clause Bypass] Can the acquires Vec<ModuleAccess> be manipulated to omit resource acquisitions or add false acquisitions, allowing functions to access global resources without proper declarations and bypassing resource safety checks? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: Function::access_specifiers] [Access Specifier Forgery] Can the access_specifiers Option<Vec<AccessSpecifier>> (v2 only) be exploited to forge read/write permissions, allowing functions to access resources they shouldn't touch according to access control policies? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Struct: FunctionSignature] [Parameter Tampering] Can the parameters Vec<(Var, Type)> in FunctionSignature be manipulated to change parameter types after type checking, causing type confusion when the function is called with mismatched argument types? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/expansion/ast.rs] [Field: FunctionSignature::return_type] [Return Type Manipulation] Can the return_type be changed to a more permissive type (e.g., changing a specific struct to a generic type), allowing return value type confusion that bypasses caller-side type checks? (High)"
]