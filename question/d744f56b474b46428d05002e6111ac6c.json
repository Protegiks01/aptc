[
  "[File: consensus/src/block_storage/block_tree.rs] [Function: get_ordered_block_window()] [Genesis block bypass] At line 291, does is_genesis_block() properly validate genesis blocks? Can attackers craft blocks that falsely claim to be genesis to terminate traversal early? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: get_ordered_block_window()] [Parent not found] At line 298, if parent_id points to a pruned block, does the bail!() error get handled safely or can it cause consensus state machine failures? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: get_ordered_block_window()] [Window validation] At line 304, the assertion window.len() < window_size could fail due to off-by-one errors. Can this panic be triggered to crash validators? (Medium)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Duplicate block handling] At lines 313-318, when a block already exists, does returning the existing block handle cases where the new block has different execution results, potentially causing state divergence? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Parent validation] At lines 320-323, if parent_id doesn't exist, the function bails. Can an attacker send blocks out of order to cause repeated failures and waste validator resources? (Medium)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Equivocation handling] At lines 328-333, when multiple blocks exist for the same round, only a warning is logged. Does this allow Byzantine validators to create equivocating blocks without immediate penalties? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Round collision] The warning at line 329-333 indicates multiple blocks per round are possible. Can attackers exploit this to create ambiguity in which block is canonical for a round? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Memory exhaustion] The id_to_block HashMap grows with every insert. Can Byzantine validators insert many blocks to exhaust memory before pruning occurs? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Counter manipulation] At line 337, NUM_BLOCKS_IN_TREE counter increments. Can integer overflow in the counter (if it's a limited int type) cause incorrect tree size tracking? (Low)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_block()] [Arc reference leak] When blocks are inserted but never pruned due to bugs, do Arc references accumulate causing memory leaks that eventually crash validators? (Medium)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: update_highest_commit_cert()] [Round monotonicity] At line 343, only round comparison is checked. Can an attacker provide a cert with higher round but from a different fork to manipulate the commit cert? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: update_highest_commit_cert()] [Commit root bypass] At line 345, update_commit_root() is called without validating that the new commit root is actually a descendant of the current commit root. Can this create forks? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [QC uniqueness] The precondition at lines 358-365 checks QC uniqueness per round. Is this check actually enforced in production (MIRAI annotations only)? Can duplicate QCs for the same round break consensus? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Consensus hash check] The precondition at line 361-362 compares consensus_data_hash. Can attackers craft QCs with matching hashes but different content to bypass this check? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Block not found] At line 374, if block_id doesn't exist, the function bails. Can this be exploited to prevent QC insertion for valid blocks by timing attacks? (Medium)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Highest cert manipulation] At lines 368-372, highest_certified_block is updated only by round comparison. Can attackers provide QCs from malicious forks with higher rounds to manipulate this? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Entry collision] At lines 377-379, entry().or_insert_with() keeps the first QC if one exists. Can attackers insert a malicious QC first to prevent the real QC from being stored? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Ordered cert confusion] The comment at line 382 questions whether highest_ordered_root should be updated. Does this indicate a potential bug where ordered blocks are not properly tracked? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_quorum_cert()] [Commit info validation] At line 381, commit_info().round() is compared without validating the commit info is for a valid block on the canonical chain. Can this be exploited? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: insert_ordered_cert()] [Ordered cert downgrade] At lines 389-393, only round comparison prevents downgrade. Can attackers provide ordered certs from forks to manipulate execution ordering? (Critical)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: remove_block()] [Orphaned children] At lines 175-182, when a block is removed, are its children properly disconnected? Can orphaned children remain in memory causing leaks? (Medium)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: remove_block()] [Round index cleanup] At line 179, round_to_ids is cleaned up. If multiple blocks exist for a round, does this remove the wrong mapping? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: remove_block()] [QC dangling reference] At line 181, QCs are removed. Can other parts of the code hold Arc references to these QCs, causing use of deleted block data? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: find_blocks_to_prune()] [Prune traversal attack] At lines 406-435, can an attacker craft a block tree with many branches to cause exponential traversal time during pruning, hanging validators? (High)",
  "[File: consensus/src/block_storage/block_tree.rs] [Function: find_blocks_to_prune()] [Same root bypass] At lines 411-413, if next_window_root_id == window_root_id, no pruning occurs. Can attackers manipulate window root updates to prevent pruning and cause memory exhaustion? (High)"
]