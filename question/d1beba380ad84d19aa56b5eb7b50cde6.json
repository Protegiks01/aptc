[
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [DoS Attack - Verifier Complexity] Can an attacker craft a module with NUM_LOCALS set to 127 (one less than the test value of 128) to bypass verification limits while still causing exponential complexity in reference graph analysis, leading to validator node resource exhaustion? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Integer Overflow] Does the multiplication of NUM_LOCALS (128) and NUM_CALLS (76) properly check for integer overflow when calculating total reference operations, or could an attacker trigger undefined behavior by manipulating these constants to overflow u16/u32 bounds? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Bypass Verification] In the biclique graph construction, can an attacker use NUM_FUNCTIONS=2 instead of 1 to distribute the complexity across multiple functions, potentially bypassing per-function verification limits while maintaining total attack complexity? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Signature Manipulation] Can an attacker manipulate SignatureIndex(1) to point to a malformed signature with more than NUM_LOCALS references, bypassing the intended 128-reference limit and creating larger biclique structures? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Function Handle Bypass] Does the take_and_return_references function properly validate that all NUM_LOCALS references are moved back in the return signature, or can an attacker drop some references to create dangling reference states? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Recursive Call DoS] The module creates a self-recursive function at FunctionHandleIndex(0) - can an attacker combine this recursion with the biclique pattern to create nested complexity that causes stack overflow during verification before the complexity check triggers? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [CopyLoc vs MoveLoc] The test uses MoveLoc for all NUM_LOCALS operations - can an attacker use CopyLoc instead to create additional reference nodes in the borrow graph, multiplying the complexity beyond NUM_LOCALS * NUM_CALLS? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Off-by-One Error] Does the loop 'for i in 0..NUM_LOCALS' correctly handle the edge case where NUM_LOCALS is at the u8::MAX boundary (255), or could an attacker set NUM_LOCALS=255 to trigger an off-by-one error in reference tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Swallow References Bypass] The swallow_references function accepts references but doesn't return them - can an attacker chain multiple swallow_references calls to leak references and bypass borrow checker invariants? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Type Parameter Abuse] Can an attacker add type_parameters to FunctionHandle to create polymorphic reference types that bypass the U64 reference counting, allowing unbounded reference graph growth? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Empty Code Bypass] The swallow_references function has empty code except Ret - can an attacker create additional empty functions with complex signatures to bypass verification while maintaining graph complexity? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Module Handle Manipulation] All functions use ModuleHandleIndex(0) - can an attacker create cross-module reference chains by using multiple module handles to distribute complexity across modules and bypass per-module limits? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Production Config Bypass] The test uses VerifierConfig::production() - are there other config modes (e.g., development, test) that have relaxed limits allowing this attack to succeed and be deployed? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Call Chain Manipulation] Can an attacker reduce NUM_CALLS to 75 or increase to 77 to find an edge case where verification succeeds but runtime still exhibits exponential complexity during execution? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Reference Type Variation] The test uses Reference(U64) - can an attacker use MutableReference or nested Reference(Reference(U64)) to create different graph structures that bypass the detection? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Signature Duplication] Can an attacker create multiple signature entries with identical reference patterns to confuse the verifier's signature deduplication logic and bypass complexity tracking? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_ts/reference_safety_tests.rs] [Function: test_bicliques()] [Visibility Manipulation] All functions are marked Public - can an attacker use different visibility modifiers (Friend, Private) to bypass verification checks that only analyze public function call graphs? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Entry Function Bypass] is_entry is set to false - can an attacker set is_entry=true on malicious functions to bypass verification that only analyzes entry points? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [Ret Placement Attack] Can an attacker insert additional Ret instructions within the function body to create multiple exit points that confuse reference lifetime analysis? (Medium)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_bicliques()] [GHSA-xm6p-ffcq-5p2v Variant] The test reproduces GHSA-xm6p-ffcq-5p2v - are there variant attack vectors using similar bipartite structures with different NUM_LOCALS/NUM_CALLS ratios that achieve the same DoS but evade detection? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_merge_state_large_graph()] [DoS - State Merge Complexity] Can an attacker set NUM_NOP_BLOCKS to 949 (one less than 950) to bypass verification while still causing quadratic complexity in state merge operations during control flow analysis? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_merge_state_large_graph()] [Branch Target Manipulation] The BrTrue(0) instruction creates backward edges - can an attacker use BrTrue with non-zero offsets to create complex CFG structures that bypass linear complexity assumptions? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_merge_state_large_graph()] [N Boundary Exploitation] N is set to 127 (max i8/2) - can an attacker use N=128 to trigger signed/unsigned integer confusion in reference counting, potentially causing integer wraparound? (High)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_merge_state_large_graph()] [Function Count Multiplication] NUM_FUNCTIONS=18 creates multiple attack vectors - can an attacker distribute the NUM_NOP_BLOCKS differently across functions to create per-function complexities below detection thresholds while maintaining total attack impact? (Critical)",
  "[File: aptos-core/third_party/move/move-bytecode-verifier/bytecode-verifier-tests/src/unit_tests/reference_safety_tests.rs] [Function: test_merge_state_large_graph()] [StLoc Index Overflow] The code uses StLoc(N + j) where j ranges from 0 to N-1 - can this calculation overflow when N approaches u8::MAX, causing writes to invalid local indices? (High)"
]