[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Index gap] Can next_outgoing_index at line 131 be incremented while next_incoming_index hasn't advanced, creating an invalid state where outgoing > incoming, causing all subsequent polls to return None prematurely? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: new()] [Invalid max_in_progress] What happens if new() at line 82 is called with max_in_progress=0, bypassing the assertion in FuturesUnorderedX and creating an invalid state where no futures can progress? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: is_terminated()] [Termination condition] Can is_terminated() at line 164 return true while queued_outputs is non-empty if in_progress_queue.is_terminated() returns true prematurely, causing backup data in the queue to be dropped? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Infinite loop] If in_progress_queue.poll_next_unpin() at line 137 always returns Poll::Ready(Some(output)) with output.index != next_outgoing_index, does the loop at line 136 run forever, blocking backup operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [State machine violation] Can the stream transition from Poll::Pending to Poll::Ready(None) without properly draining queued_outputs, violating the FusedStream contract and causing backup restoration to terminate early? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Panic safety] If peek_mut() at line 129 panics due to heap corruption, is the FuturesOrderedX left in an inconsistent state where next_outgoing_index has been modified but the panic unwinding prevents cleanup? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Panic during push] If in_progress_queue.push() at line 118 panics due to allocation failure, is next_incoming_index already incremented at line 117, causing an index gap that breaks ordering forever? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Panic in future] If a future panics during poll() inside in_progress_queue.poll_next_unpin() at line 137, does the panic propagate and leave FuturesOrderedX in an invalid state with missing index entries? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [PeekMut drop] If PeekMut::pop() at line 132 panics, can the heap be left in a partially-modified state where the max element is removed but heap properties aren't restored? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: extend()] [Panic in iteration] If the iterator at line 174 panics during push() at line 175, are previously pushed futures' indices corrupted, causing ordering violations in subsequent backup operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Concurrency limit bypass] Can malicious timing of poll_next() calls cause more than max_in_progress futures to be active simultaneously if in_progress_queue doesn't properly enforce limits, exhausting backup node resources? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Queue state mismatch] If in_progress_queue.push() at line 118 fails silently or returns an error that's ignored, does the OrderWrapper with incremented index get lost, causing poll_next() to hang waiting for that index forever? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Stream exhaustion] When in_progress_queue returns None at line 146, does this properly account for queued futures inside FuturesUnorderedX's internal queues, or can futures be silently dropped? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: is_terminated()] [Termination race] Can is_terminated() at line 164 return false when in_progress_queue.is_terminated() is true but queued_outputs is temporarily empty, then more outputs arrive, causing incorrect stream termination detection? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: len()] [Length mismatch] Can len() at line 96 become out of sync with actual future count if FuturesUnorderedX's internal queues aren't properly accounted for, causing buffer size miscalculations in backup operations? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: OrderWrapper::poll()] [Index preservation] Can the index field at line 59 be corrupted during future polling if pin projection at line 60 doesn't properly maintain invariants, causing ordering violations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: OrderWrapper PartialEq] [Equality soundness] Since PartialEq at line 31 only compares index, can two OrderWrapper instances be considered equal despite having different data, causing BinaryHeap to violate uniqueness assumptions? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: OrderWrapper Ord] [Ordering transitivity] Does the reversed comparison at line 48 (other.index.cmp(&self.index)) maintain transitivity when combined with PartialEq, or can this create inconsistent ordering states in the BinaryHeap? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: OrderWrapper::poll()] [Output type safety] Can the OrderWrapper<T::Output> at line 56 be constructed with mismatched generic types if unsafe code manipulates the type system, causing type confusion in backup data processing? (Low)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Poll contract violation] Can poll_next() return Poll::Ready(Some(value)) after previously returning Poll::Ready(None), violating the Stream trait contract and causing backup consumers to process duplicate data? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: size_hint()] [Hint correctness] Can size_hint() at line 151 return (len, Some(len)) when len() doesn't account for futures still being pushed, causing stream consumers to allocate insufficient buffers for backup data? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Waker registration] If poll_next() returns Poll::Pending at line 86, is the waker from Context properly registered so the task is woken when new futures complete, or can backup operations deadlock waiting for events that never arrive? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Ready macro misuse] Does the ready! macro at line 137 properly handle Poll::Pending by returning early, or can it cause poll_next() to continue executing and corrupt state if in_progress_queue isn't ready? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Chunk reordering] If backup chunks arrive out of order and fill queued_outputs at line 143, can BinaryHeap's max-heap behavior cause chunks to be permanently stuck if earlier chunks never arrive, corrupting restored blockchain state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Missing chunk detection] When a backup chunk with a specific index is lost (network failure, corrupt data), does poll_next() at lines 136-148 detect this and fail fast, or does it silently wait forever causing incomplete state restoration? (Critical)"
]