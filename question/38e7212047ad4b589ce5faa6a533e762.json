[
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: ValidatorSetStream::new()] [Identity verification bypass] Can an attacker provide a manipulated expected_pubkey during construction that doesn't match their actual node identity, allowing them to impersonate another validator and receive their network updates without detection? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: ValidatorSetStream::new()] [Network context manipulation] If network_context is constructed with incorrect peer_id or network_id values, can this cause validator discovery to connect to wrong peers or expose validator network topology to fullnode networks? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: ValidatorSetStream::new()] [Reconfig event injection] Can an attacker inject malicious ReconfigNotificationListener that provides fake validator set updates, causing the node to disconnect from legitimate validators and connect to attacker-controlled nodes? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: ValidatorSetStream::new()] [State initialization race] If multiple ValidatorSetStream instances are created concurrently with different expected_pubkey values for the same network_context, can this create inconsistent validator discovery state across threads? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [Key rotation attack] During legitimate validator key rotation, does the mismatch detection at lines 46-58 immediately flag the new key as mismatched before on-chain update completes, potentially causing the validator to disconnect from the network and halt consensus? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [None pubkey bypass] When onchain_keys is None (line 46), the mismatch counter is set to 0, allowing a node with wrong credentials to continue operating without detection - can this be exploited during network bootstrap or after state corruption? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [Multiple key confusion] If the HashSet<x25519::PublicKey> at line 46 contains multiple keys for a single validator, does the contains() check at line 47 accept any matching key, allowing an attacker who compromises one of multiple historical keys to authenticate? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [Metric manipulation] Since NETWORK_KEY_MISMATCH metric (lines 60-66) is only set to 0 or 1, can repeated key mismatches be hidden by the last value overwriting previous warnings, allowing persistent impersonation attempts to go unnoticed in monitoring systems? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [Logging information leak] Does the error log at lines 48-53 expose the complete set of on-chain public keys ({:?}), potentially revealing validator identities and network topology to attackers who gain log access? (Low)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: find_key_mismatches()] [Race condition in key check] If expected_pubkey is being updated concurrently in another thread while find_key_mismatches() executes, can the comparison at line 47 use stale key data, causing false positives/negatives in mismatch detection? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Panic in production] The expect() call at line 74 'failed to get ValidatorSet from payload' will panic and crash the node if OnChainConfigPayload is malformed - can Byzantine validators craft invalid payloads during reconfiguration to crash honest validators and halt the network? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Reconfig event starvation] Since EVENT_PROCESSING_LOOP_BUSY_DURATION_S timer starts at line 70 and runs through the entire function, can an attacker send extremely large ValidatorSet payloads (thousands of validators) to monopolize CPU time and delay consensus processing? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [State inconsistency window] Between extracting validator set at line 72-74 and calling find_key_mismatches at line 78-82, if the on-chain state is updated again, can this create a time-of-check-time-of-use (TOCTOU) vulnerability where peer_set becomes stale? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Counter overflow] The DISCOVERY_COUNTS metric increment at lines 84-89 casts peer_set.len() to u64 - can an attacker craft a ValidatorSet with usize::MAX entries that overflows or causes allocation failures when converted to u64? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Metric count manipulation] Since peer_set.len() is reported as 'new_nodes' at line 88, but this includes existing nodes from the previous set, can this mislead monitoring systems about actual network growth and hide validator churn attacks? (Low)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Self-peer exclusion] If peer_set.get() at line 80 returns None for self.network_context.peer_id(), does find_key_mismatches receive None and set mismatch to 0 (line 46), allowing a removed validator to continue operating without realizing they've been kicked from the set? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Key set reference lifetime] The reference &peer.keys passed to find_key_mismatches at line 81 - if peer is removed from peer_set after this call but before the function returns, can this create a dangling reference or use-after-free? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_updates()] [Mutable self in callback] The function takes &mut self and is called from poll_next() - if multiple threads poll concurrently, can this violate Rust's borrowing rules and create undefined behavior in async context? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Double poll vulnerability] The Stream implementation at lines 98-105 uses Pin::new(&mut self.reconfig_events) - if the underlying stream is polled again after returning Poll::Ready(None), can this violate Stream contract and cause panics or undefined behavior? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Error propagation loss] The map at line 103 wraps extract_updates() result in Ok(), but extract_updates() could panic (line 74) - are panics properly caught, or can they crash the entire discovery event loop and prevent validator set updates indefinitely? (Critical)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Waker registration race] When poll_next returns Poll::Pending, the Context waker should be registered for future notification - can concurrent polls or reconfig_events modifications cause waker loss, resulting in the stream never waking up and missing critical validator set changes? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Notification ordering] If multiple ReconfigNotifications are queued in reconfig_events, does poll_next() process them in order, or can reordering cause validators to apply outdated configurations after newer ones, potentially reversing valid validator set changes? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Pin safety violation] The manual Pin::new(&mut self.reconfig_events) at line 99 - if ValidatorSetStream is moved while being polled, can this violate pinning guarantees and cause memory safety issues in the async runtime? (High)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: poll_next()] [Result wrapping correctness] The double Option nesting (Option<Result<PeerSet, DiscoveryError>>) at line 96 - if extract_updates could legitimately return an error, wrapping it in Ok() at line 103 suppresses all errors and makes validators accept invalid configurations - is this intentional? (Medium)",
  "[File: aptos-core/network/discovery/src/validator_set.rs] [Function: extract_validator_set_updates()] [Network isolation bypass] The is_validator check at line 113 determines which addresses to parse - can an attacker craft ValidatorInfo with both validator and fullnode addresses, then manipulate network_id to extract privileged validator network addresses and expose them to public networks? (Critical)"
]