[
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::BufferData] [Plaintext Exposure] Lines 256-259 copy plaintext into write_buffer before encryption at line 268. If encryption fails at line 284, the plaintext remains in write_buffer. On retry, can old plaintext be re-encrypted with a reused nonce, breaking AES-GCM security? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [In-Place Decryption Safety] Line 146 performs in-place decryption where ciphertext is replaced with plaintext in read_buffer. If decryption fails partway through (e.g., due to implementation bug), is the buffer left in a partially-decrypted state that could leak information on error paths? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.write_message_in_place()] [Nonce Exhaustion] At line 267, write_message_in_place() is called for each message. Noise protocol uses a 64-bit nonce counter. After 2^64 messages on a long-lived connection, can nonce wraparound occur, causing either counter reuse (breaking AES-GCM) or connection failure (causing validator liveness issues)? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [Nonce Synchronization] At line 146, decryption assumes nonces are synchronized between peers. If messages are lost or reordered at TCP layer (unlikely but possible with certain network stacks), can nonce desynchronization cause all subsequent messages to fail decryption, permanently breaking the connection? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::EncryptionError] [Nonce Counter State] When EncryptionError occurs at line 284, the nonce counter in the NoiseSession has already been incremented. If the caller retries the write, will a new nonce be used, or will there be a nonce gap causing receiver-side decryption failure? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: NoiseStream::new()] [Session State Isolation] At lines 50-58, a single NoiseSession is used for both reading and writing. Noise protocol uses separate nonce counters for each direction. If the implementation incorrectly shares counters, can this lead to nonce reuse when messages are sent and received concurrently? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_write_or_flush()] [Write Retry Safety] If poll_write() returns Poll::Pending during WriteState::WriteEncryptedFrame and is called again, does the Noise session maintain nonce state correctly? Or can the same plaintext be encrypted again with a new nonce, wasting nonces and potentially accelerating nonce exhaustion? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [Timing Side-Channel] At line 146, decryption time may vary based on whether authentication succeeds or fails. Can a network adversary measure response timing to distinguish valid from invalid ciphertext, potentially gaining information about validator internal state or cryptographic keys? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::DecryptionError] [Error Timing] Lines 155-157 log decryption errors with error!() macro. If logging is synchronous and slow, can an attacker measure timing differences between valid and invalid frames to fingerprint validators or infer information about message content? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read()] [Cache Timing] The loop at lines 93-199 accesses read_buffer at different offsets. Can cache timing attacks on the validator's CPU reveal information about buffer contents or state transitions, potentially leaking cryptographic material or message boundaries? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::BufferData] [Buffer Copy Timing] Lines 256-259 use copy_from_slice() which may have timing characteristics dependent on buffer size. Can an attacker measure write timing to infer message sizes before encryption, potentially determining consensus message types and gaining strategic advantage? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: NoiseBuffers::new()] [Zero-Initialization] Line 419-420 initializes buffers with [0; MAX_SIZE]. While this prevents uninitialized memory, it may leave patterns in memory that differ from random data. Can memory dumping or cold-boot attacks on compromised validators extract historical message patterns from these buffers? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::CopyDecryptedFrame] [Empty Plaintext] At lines 173-186, if decrypted_len is 0 (empty plaintext), offset starts at 0 and the condition offset == decrypted_len is immediately true. Can an attacker send empty encrypted messages that are valid but cause the validator to transition to Init state without returning any data, wasting CPU on useless processing? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::BufferData] [Maximum Buffer Fill] Lines 265-293 check if offset == MAX_WRITE_BUFFER_LENGTH. If a caller provides exactly MAX_WRITE_BUFFER_LENGTH bytes in a single write() call, will the entire buffer be encrypted in one operation, or can this trigger edge cases in buffer flushing logic? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read_exact()] [Single Byte Reads] If the underlying socket's poll_read() returns only 1 byte per call, poll_read_exact() at lines 493-515 will loop many times. For a 65535-byte message, this is 65535 iterations. Can this cause excessive syscall overhead and CPU usage, degrading validator performance? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_write_all()] [Partial Socket Writes] At line 449, poll_write() may write only part of the buffer. If the socket consistently writes less than requested (e.g., due to network congestion), can this cause the function to loop excessively, blocking the async executor and preventing other tasks from running? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: get_remote_static()] [Key Exposure] Line 61-63 provides access to remote peer's static public key. This key is used for identity verification. If this method is called repeatedly in a loop, can it cause cache contention or memory access patterns that leak information through side-channels? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: NoiseStream::new()] [Session Validation] At line 50, NoiseSession is accepted without validation. If the handshake phase provided an invalid or partially-initialized session, will post-handshake operations fail gracefully, or can they cause crashes or security violations? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.get_remote_static()] [Key Substitution] At line 62, get_remote_static() retrieves the peer's public key. If the Noise session was compromised during handshake and this returns an attacker-controlled key, can the validator incorrectly authenticate a Byzantine peer as a trusted validator? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.write_message_in_place()] [Session State Corruption] If write_message_in_place() at line 267 is called with invalid input (e.g., buffer size exceeds protocol limits), can it corrupt internal NoiseSession state in a way that causes future read operations to fail or produce incorrect plaintexts? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [Session Error Recovery] When read_message_in_place() returns Err at line 155, the NoiseSession's internal state may be inconsistent. If subsequent reads attempt to continue using the same session, can this cause security violations like plaintext leakage or authentication bypass? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Type: NoiseSession] [Session Cloning] The NoiseSession at line 39 is not cloned or copied. If NoiseStream is accidentally cloned (though Debug is derived, not Clone), could two NoiseStream instances share the same session and cause nonce reuse when writing concurrently? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: AsyncRead::poll_read()] [Pin Safety] At line 374, self.get_mut() is called on Pin<&mut Self>. This is safe only if NoiseStream is Unpin. If any field in NoiseStream is !Unpin (e.g., if NoiseSession contains async state), can this violate pinning guarantees and cause memory unsafety? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: AsyncWrite::poll_write()] [Write Semantics] At line 387, poll_write() delegates to internal method. The AsyncWrite contract requires that poll_write() doesn't lose data on Poll::Pending. If the internal write_state buffering fails, can data be silently dropped without error? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: AsyncWrite::poll_flush()] [Flush Guarantee] Lines 390-392 implement poll_flush(). If this returns Poll::Ready(Ok(())) but the underlying socket hasn't fully flushed due to buffering, can encrypted messages be lost during validator shutdown, causing consensus message loss? (Medium)"
]