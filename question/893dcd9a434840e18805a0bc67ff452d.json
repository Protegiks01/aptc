[
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Connection limit bypass] Can a malicious peer bypass the inbound_connection_limit check by rapidly disconnecting and reconnecting, exploiting the race condition between the count check at line 359-368 and the actual insertion at line 683-684, potentially exhausting node resources and causing memory exhaustion? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [TOCTOU vulnerability] Between checking unknown_inbound_conns count at line 359-368 and inserting the peer at line 683-684, can multiple concurrent connections from the same malicious peer race to all pass the limit check before any insertion occurs, allowing them to collectively exceed inbound_connection_limit? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Trust model bypass] At line 356, if conn.metadata.role == PeerRole::Unknown, the connection limit is enforced, but can a malicious peer forge their role during the Noise handshake to appear as a trusted validator and bypass the inbound_connection_limit entirely? (Critical)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Integer overflow] When counting unknown_inbound_conns at line 359-368 using .count(), can the count operation overflow if there are more than usize::MAX connections, causing the limit check at line 376 to incorrectly pass and allow unlimited connections? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Filter logic error] At line 362-367, the filter checks if trusted_peers.get(peer_id).is_none_or(|peer| peer.role == PeerRole::Unknown), but can this logic be exploited if trusted_peers contains stale entries for disconnected peers, causing legitimate unknown peers to be incorrectly counted or excluded? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Concurrent modification] During the iteration at line 360-368 that counts unknown_inbound_conns, if active_peers HashMap is concurrently modified by handle_connection_event removing a peer (line 295), can this cause undefined behavior or incorrect counts leading to limit bypass? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Resource exhaustion] If get_trusted_peers() at line 335-337 fails and returns early at line 349, does this leave the Connection<TSocket> object undropped, potentially leaking socket file descriptors and causing resource exhaustion over time? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Metric manipulation] At line 385-386, counters::connections_rejected is incremented before disconnect(), but can a malicious peer repeatedly trigger rejections to overflow the counter or manipulate metrics used for monitoring/alerting, masking real attacks? (Low)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Disconnect timing] At line 387, self.disconnect(conn) is called for rejected connections, but is this disconnect operation atomic and immediate? Can the rejected peer still send messages before the socket is actually closed, potentially exploiting race conditions? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: handle_new_connection_event()] [Trusted peer cache poisoning] If trusted_peers returned at line 335-339 is cached and can become stale, can an attacker who was previously trusted but is now removed still bypass the connection limit check at line 356-391? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Non-determinism] The tie-breaking logic at lines 571-579 compares PeerIds to decide which connection to keep, but are PeerId comparisons guaranteed to be deterministic across all nodes? Could differences in PeerId encoding or byte-order cause different nodes to make conflicting decisions, leading to network partitions? (Critical)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Logic error - double inbound] At line 574, when both connections are Inbound, the function returns true (drop existing), but this seems counterintuitive - why would a peer dial us twice inbound? Could this indicate a spoofing attack or connection confusion that should be detected rather than silently handled? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Logic error - double outbound] At line 576, when both connections are Outbound, the function returns true (drop existing), but the comment says 'We should never dial the same peer twice' - if this shouldn't happen, why handle it gracefully? Could an attacker exploit this to cause unnecessary connection churn? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Asymmetric decisions] At lines 577-578, the logic uses remote_peer_id < own_peer_id and own_peer_id < remote_peer_id for mixed origins - but could timing differences cause both peers to evaluate these conditions at different moments, potentially both dropping connections or both keeping them, resulting in no connection? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [PeerId collision] If two peers somehow have the same PeerId (through a cryptographic collision or implementation bug), the comparison at lines 577-578 would return false for both < checks - what happens then? Does this cause both connections to be kept, dropped, or enter an undefined state? (Critical)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [State machine violation] This function is pure (no side effects), but when called from add_peer at line 629, can race conditions between the check and the actual peer removal/disconnect cause the tie-breaking decision to be stale, resulting in both connections being dropped or kept? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Byzantine behavior] If a Byzantine peer can somehow control their PeerId or manipulate the ConnectionOrigin in their connection metadata, can they force the tie-breaking to always favor their malicious connection and repeatedly disrupt legitimate connections? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: simultaneous_dial_tie_breaking()] [Notification inconsistency] When tie-breaking at line 629-655 leads to dropping the existing connection, send_new_peer_notification is set to false at line 644, but was a LostPeer notification sent for the old connection? Could this cause upstream components to have inconsistent peer state? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Self-dial check bypass] At line 613, the code checks if network_context.peer_id() == peer_id to prevent self-dial, but can an attacker spoof ConnectionMetadata to make remote_peer_id match our own peer_id, causing us to disconnect legitimate connections to ourselves in multi-network scenarios? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Debug assertion in production] At line 614, debug_assert!(false, 'Self dials shouldn't happen') only fires in debug builds - in production, self-dials are silently disconnected at line 620. Could an attacker exploit this to repeatedly cause self-dials, wasting resources without triggering alerts? (Low)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Race condition in Entry::Occupied] At line 627, the code checks if active_peers.entry(peer_id) is Occupied, but between this check and the simultaneous_dial_tie_breaking call at line 629, can another thread remove or modify this entry, causing use-after-free or stale pointer dereference? (Critical)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Connection handle leak] At line 635-637, when tie-breaking favors the new connection, the old peer_handle is dropped, but what if the Peer actor has pending messages in its channel? Are those messages lost, potentially causing consensus message loss or liveness failures? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Notification skip vulnerability] At line 644, send_new_peer_notification is set to false when replacing an existing connection, but if the old connection was already disconnected before this point, wouldn't upstream components miss the LostPeer notification entirely? (Medium)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Channel creation failure] At line 659-663, aptos_channel::new() is called but the result is not checked for errors - can channel creation fail (e.g., due to resource exhaustion), and if so, would unwrapping cause a panic that crashes the entire PeerManager actor? (High)",
  "[File: aptos-core/network/framework/src/peer_manager/mod.rs] [Function: add_peer()] [Peer actor spawn failure] At line 680, self.executor.spawn(peer.start()) is called, but spawn() doesn't return an error - if the executor is at capacity or the runtime is shutting down, does the Peer actor silently fail to start, leaving a zombie entry in active_peers? (High)"
]