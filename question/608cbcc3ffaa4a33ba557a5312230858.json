[
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Type Confusion] Can an attacker pass mismatched type arguments where the ty_args[0] indicates BLS12381Fr but the actual element handles point to BLS12381G1 elements, causing the ark_binary_op_internal macro to unsafely cast and perform field addition on group elements, potentially leading to invalid cryptographic operations and state corruption? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Type Safety] Does the structure_from_ty_arg macro at line 29 properly validate that the TypeTag corresponds to a supported algebraic structure, or can an attacker craft a malicious type tag string that bypasses validation and triggers undefined behavior in the match statement? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Cross-Curve Attack] Can an attacker exploit the lack of curve-specific validation to mix BLS12-381 and BN254 elements by providing a BLS12381Fr type argument but supplying BN254Fr element handles, causing the arkworks library to perform addition across incompatible prime fields and potentially producing invalid results that could corrupt cryptographic proofs? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Type Confusion] At line 28, the assert_eq!(1, ty_args.len()) only validates the count but not the content - can an attacker provide a valid-length type argument array with a malicious custom type that passes structure_from_ty_arg but doesn't correspond to any supported Structure enum variant, causing a panic or undefined behavior? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Structure Mismatch] Can an attacker pass Gt structure types (BLS12381Gt or BN254Gt) that use multiplication instead of addition (lines 60-66, 94-100), and exploit edge cases where the multiplicative group operation on Fq12 elements produces mathematically valid but cryptographically incorrect results that break pairing-based protocols relying on additive semantics? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Gas Bypass] The ark_binary_op_internal macro charges gas at line 21 of the macro definition after extracting handles but before performing the operation - can an attacker trigger a panic in handle extraction to bypass gas charging, allowing unlimited free cryptographic operations that could DoS validators through computational exhaustion? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Gas Exhaustion] For BLS12381Fq12 addition at lines 39-45, the gas cost is ALGEBRA_ARK_BLS12_381_FQ12_ADD (6686 units) - can an attacker construct a transaction with thousands of Fq12 additions that stays under the transaction gas limit but causes validators to perform millions of finite field operations, creating disproportionate computational load compared to gas paid? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Inconsistent Gas] The Gt structures at lines 60-66 and 94-100 use ALGEBRA_ARK_BLS12_381_FQ12_MUL and ALGEBRA_ARK_BN254_FQ12_MUL gas costs instead of addition costs - is multiplication more expensive than addition in Fq12, and does this gas mismatch allow attackers to perform cheaper Gt operations than intended, enabling gas-inefficient attacks? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Gas Front-Running] Can an attacker observe pending transactions using BLS12381G2 addition (gas cost at line 54: ALGEBRA_ARK_BLS12_381_G2_PROJ_ADD = 119106 units) and front-run them with cheaper BLS12381Fr additions (gas cost at line 32: ALGEBRA_ARK_BLS12_381_FR_ADD = 775 units), manipulating the gas price market or causing specific transactions to fail due to gas estimation errors? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Gas Metering Order] The macro charges gas using context.charge($gas)? at line 21 of ark_binary_op_internal before performing element_1.$ark_func(element_2) at line 22 - if the arkworks addition operation panics or fails, the gas is already charged but operation not completed, creating a gas leak where attackers can drain gas budgets without completing work? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Memory Exhaustion] The store_element macro at line 23 checks if new_size > MEMORY_LIMIT_IN_BYTES (1MB) before storing the result - but can an attacker craft a transaction that creates exactly 1MB of elements through repeated additions, then make one final addition that fails the memory check after consuming maximum memory, causing validators to waste resources without completing the transaction? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Memory Leak] Does the AlgebraContext properly clean up stored elements when add_internal returns an error (lines 101-103)? If an attacker triggers the MOVE_ABORT_CODE_NOT_IMPLEMENTED error by passing an unsupported structure, do the previously allocated elements in context.objs get leaked, allowing cumulative memory exhaustion across multiple failed transactions? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Memory Accounting] The store_element macro uses std::mem::size_of_val(&$obj) to calculate memory usage - for BLS12381G1Projective and BLS12381G2Projective elements which contain large field elements, does size_of_val accurately reflect the heap allocations, or can attackers exploit underestimated memory accounting to exceed the 1MB limit and trigger OOM conditions? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Session Memory] The AlgebraContext resets on session start (clearing bytes_used and objs) but not on abort - can an attacker create a session with many successful additions approaching the 1MB limit, then intentionally abort to leave memory allocated but bytes_used reset, enabling memory exhaustion across session boundaries? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Handle Overflow] The ark_binary_op_internal macro at line 17 casts u64 handles to usize with 'as usize' - on 32-bit architectures or when handles exceed usize::MAX, can this truncation cause handle_1 and handle_2 to access wrong indices in context.objs, leading to type confusion where BLS12381Fr operations are performed on BN254G1 elements? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Out-of-Bounds Handle] The safe_borrow_element macro uses .get($handle).ok_or_else(abort_invariant_violated) - but does this properly prevent an attacker from passing handle values like u64::MAX that convert to valid usize but point beyond context.objs.len(), potentially causing reads of uninitialized memory or triggering undefined behavior before the ok_or_else check? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Handle Reuse] After add_internal creates a new handle via store_element at line 23 of the macro, returning it as Value::u64(new_handle as u64), can an attacker reuse this handle in subsequent operations while still holding references to the original input handles, creating aliasing issues where the same element appears multiple times in the context.objs vector with different types? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Handle Double-Pop] The safely_pop_arg macro pops handle_2 then handle_1 from the args VecDeque at lines 17-18 - if the same handle value appears twice in args, does this create a scenario where both handle_1 and handle_2 point to the same element, and adding an element to itself triggers undefined behavior in the arkworks library's addition implementation? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Handle Type Mismatch] Can an attacker exploit the two-step process where handles are popped as u64 (line 17-18) and then cast to usize, followed by type checking via downcast_ref at line 230 of the macro, to create a race condition where the handle's type changes between casting and downcasting, bypassing type safety checks? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Semantic Confusion] At lines 60-66, BLS12381Gt addition is implemented using ark_bls12_381::Fq12 multiplication (.mul) instead of addition (.add) - while mathematically correct for the target group Gt = Fq12*, can this semantic mismatch cause developers to unknowingly perform multiplication when they expect addition, leading to incorrect cryptographic protocols like broken threshold signatures or multi-party computations? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Identity Element] Does the arkworks library's .add() method properly handle addition with the identity element (zero for fields, point at infinity for groups)? Can an attacker pass identity elements to trigger edge cases where the result is not properly validated, potentially creating invalid curve points that bypass subgroup checks in pairing operations? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Point at Infinity] For group additions at lines 46-52 (BLS12381G1) and 53-59 (BLS12381G2), if both input points are the point at infinity, does the arkworks G1Projective/G2Projective addition return a properly formed identity element, or can this create invalid projective coordinates that later cause panics in affine conversion or serialization? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Subgroup Check Bypass] After performing addition on BLS12381G1 or BLS12381G2 elements, the result is stored without subgroup validation - can an attacker add a valid subgroup element with a maliciously crafted point to produce a result outside the prime-order subgroup, bypassing pairing security assumptions and enabling small-subgroup attacks? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [Overflow in Fr Addition] When adding two BLS12381Fr field elements at lines 32-38, if both elements are near the field modulus r, does the arkworks library properly reduce the result modulo r, or can internal representations overflow and wrap, producing incorrect field element values that corrupt scalar multiplications in signature schemes? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/cryptography/algebra/arithmetics/add.rs] [Function: add_internal()] [BN254 vs BLS12381 Confusion] The file handles both BN254 and BLS12381 curves which have different security levels (128-bit vs 126-bit) and different field characteristics - can an attacker exploit developer confusion between these curves to perform operations intended for BLS12381 on BN254 elements, reducing security from 128-bit to 126-bit without detection? (Medium)"
]