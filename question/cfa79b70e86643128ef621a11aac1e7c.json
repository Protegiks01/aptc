[
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: make_all()] [Duplicate Registration] Why are both 'is_permissioned_signer_impl' and 'is_permissioned_signer' registered at lines 161-168 to the same function, and can this duplication be exploited to bypass checks or cause confusion? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Address Derivation] Does the permission_address() at line 85 derive addresses deterministically, or can non-deterministic address generation cause validators to compute different permission addresses for the same signer? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Address Collision] Can an attacker find hash collisions in address derivation to create permissioned signers with colliding addresses, allowing them to access resources belonging to other accounts? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Entropy] If permission address generation uses insufficient entropy, can attackers predict or brute-force future permission addresses to preemptively deploy malicious code at those addresses? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Resource Exhaustion] Can an attacker create deeply nested permissioned signer hierarchies that cause is_permissioned() at line 50 to consume excessive CPU checking permission chains? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Stack Exhaustion] Can recursive permission relationships cause permission_address() at line 85 to trigger infinite recursion, exhausting stack space and crashing validator nodes? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Memory Leak] Does Value::permissioned_signer() at lines 115-118 properly manage memory, or can it leak memory when creating many permissioned signers, eventually exhausting validator RAM? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Performance] Can an attacker repeatedly call borrow_address() at line 150 on the same signer in a tight loop to consume CPU cycles, degrading validator performance below consensus thresholds? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Feature Flag Manipulation] Can a malicious governance proposal toggle the PERMISSIONED_SIGNER feature flag at lines 38-45 mid-epoch to cause state inconsistencies where some validators execute with the feature and others without? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Upgrade Attack] During a framework upgrade, can the native function registration at lines 169 be changed to point to a malicious implementation that steals permission addresses? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: make_all()] [Registry Poisoning] Can an attacker exploit the native function registration at lines 157-178 to inject malicious native functions that override legitimate implementations? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Governance Bypass] Can permissioned signers created before a governance proposal to disable this feature at lines 102-109 still be used after the proposal is executed, bypassing governance decisions? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Prologue Bypass] Can an attacker create permissioned signers at lines 95-119 during transaction prologue to bypass sequence number checks or signature validation by using permission addresses instead of master addresses? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Signature Validation] Does borrow_address() at line 150 return the address that was validated in transaction prologue, or can it return a different address allowing signature bypass attacks? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Account Existence] Does the function at lines 62-86 validate that the permission address actually exists on-chain before returning it, or can it return addresses for non-existent accounts? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [Resource Duplication] Can Value::permissioned_signer() at lines 115-118 violate Move's resource linearity by creating duplicate signer resources that allow double-spending or resource duplication attacks? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Reference Semantics] Does the SignerRef at line 47 properly enforce Move's reference semantics, or can it be copied/cloned in ways that violate resource safety? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Borrow Checking] Does the borrow_signer() call at line 150 respect Move's borrow checking rules, or can it create references that outlive their referent causing use-after-free? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [Abort Handling] Can the EPERMISSION_SIGNER_DISABLED abort at lines 42-44 be caught by Move code and handled incorrectly, allowing continued execution with feature disabled? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [Error Code Semantics] Does abort_code 3 at line 82 have consistent meaning across the framework, or can it be misinterpreted by calling code as a different type of error? (Low)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [Abort Condition] Is the abort condition at lines 138-146 correct with the negation logic, or does it accidentally allow cases that should abort and block cases that should succeed? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_is_permissioned_signer_impl()] [SmallVec Overflow] Can the smallvec! macro at line 52 overflow if the result value is unexpectedly large, causing buffer overflow or memory corruption? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_permission_address()] [SmallVec Safety] Does the SmallVec at line 85 properly handle the AccountAddress size, or can it cause stack corruption if the address exceeds SmallVec's inline capacity? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_signer_from_permissioned()] [SmallVec Construction] Can the smallvec! at line 115 fail to properly construct the return value, leaving it in an uninitialized or corrupted state? (High)",
  "[File: aptos-core/aptos-move/framework/src/natives/permissioned_signer.rs] [Function: native_borrow_address()] [SmallVec Return] Does the SmallVec at line 150 correctly encapsulate the borrowed reference, or can it be accessed incorrectly causing memory safety violations? (Medium)"
]