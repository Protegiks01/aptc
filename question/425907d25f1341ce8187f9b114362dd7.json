[
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: TwoKeyRegistry::get_or_add()] [TOCTOU] Can the fast path read_lock_try_get() on line 178 succeed, but the returned Entry be dropped before the caller uses it, causing state key hash mismatches when the same key is re-requested and gets a new Entry with different hash? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: TwoKeyRegistry::get_or_add()] [Double Work] Can multiple concurrent calls to get_or_add() for the same key all execute inner_gen() (line 115) before any acquires the write lock, causing expensive state key generation to be duplicated and wasted validator resources? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: TwoKeyRegistry::get_or_add()] [Non-determinism] If inner_gen() contains any non-deterministic logic (e.g., timestamp, random values), can concurrent calls produce different StateKeyInner values for the same logical key, breaking state determinism across validators? (Critical)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Constants: NUM_*_SHARDS] [Shard Imbalance] Can attackers analyze the hash_address_and_name() sharding function to deliberately create state keys that all map to a single shard (e.g., shard 0), causing extreme write lock contention on that shard during block execution? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Constants: NUM_*_SHARDS] [Configuration Attack] Are the hardcoded shard counts (8, 8, 8, 8, 4) optimal for all deployment scenarios, or can validators with different hardware configurations experience performance degradation due to suboptimal shard distribution? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::hash_address_and_name()] [Hash Collision] Does the hash function only use the last byte of address (line 214) and first/last bytes of name (lines 216-217), allowing attackers to easily craft addresses and names that produce identical hash values and cluster into the same shard? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::hash_address_and_name()] [Integer Overflow] Can hasher.finish() on line 219 produce values that overflow when cast to usize, or can the modulo operations in resource(), module(), etc. behave unexpectedly on different architectures (32-bit vs 64-bit)? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::hash_address_and_name()] [Empty Name Attack] When name.is_empty() is true (line 215), only the address byte contributes to the hash, limiting distribution to 256 possible values - can attackers exploit this to force all empty-name state keys to cluster in a few shards? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::hash_address_and_name()] [Predictable Sharding] Since only 3 bytes maximum contribute to the hash (address[31], name[0], name[len-1]), can attackers precompute shard assignments to deliberately create worst-case access patterns that degrade validator performance? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::hash_address_and_name()] [Address Byte Selection] Why is address.as_ref()[AccountAddress::LENGTH - 1] used (line 214) instead of a more distributed hash, and can attackers generate addresses with controlled last bytes to manipulate shard distribution? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::resource()] [Modulo Bias] Does the modulo NUM_RESOURCE_SHARDS on line 228 introduce bias in shard selection when hash values are not uniformly distributed, potentially causing some shards to be overloaded during resource-heavy transactions? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::resource()] [Type Confusion] Can struct_tag.name.as_bytes() contain maliciously crafted Unicode or special characters that affect hash distribution, causing resource state keys to cluster inappropriately? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::resource_group()] [Shard Collision] Since resource() and resource_group() use the same hash_address_and_name() function with the same shard count (8), can attackers create resource and resource_group keys that hash to the same shard, causing lock contention when both are accessed in the same transaction? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::resource_group()] [Resource Group Attack] Can an attacker create massive resource groups with many members that all hash to the same shard, then access them in a single transaction to monopolize that shard's write lock and degrade validator performance? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::module()] [Module Clustering] Can attackers publish multiple Move modules with carefully chosen names that all hash to the same shard, causing write lock contention during module publishing transactions and slowing down protocol upgrades? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::module()] [Identifier Validation] Does name.as_bytes() on line 248 properly validate that the Identifier contains only ASCII characters, or can malformed module names cause inconsistent hashing across different string encodings? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::table_item()] [Wrong Shard Count] Why does line 256 use NUM_MODULE_SHARDS instead of NUM_TABLE_ITEM_SHARDS - is this a bug that causes table items to use only 8 shards instead of the intended count, leading to suboptimal distribution? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::table_item()] [TableHandle Attack] Can attackers create TableHandles with manipulated handle.0 addresses that cause all table items to hash to a single shard, monopolizing table access during transactions that use Table resources? (High)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::table_item()] [Key Length Attack] Can extremely long or extremely short key byte slices affect hash distribution, causing table items with similar keys to cluster in the same shard and degrade performance for table-heavy operations? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::raw()] [Test-Only Security] Since raw() is marked 'for tests only' (line 208), can production code accidentally use raw state keys that bypass proper validation, potentially introducing state corruption if raw keys are used in live validators? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::raw()] [Fixed Address] Why does raw() always use AccountAddress::ONE on line 260 for hashing - can this cause all raw state keys to have extremely poor distribution across the 4 raw_shards? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Function: StateKeyRegistry::raw()] [Fewer Shards] With only NUM_RAW_SHARDS = 4, can the raw key registry become a bottleneck if many test state keys are created, and could this accidentally affect production code that uses raw keys? (Low)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Static: REGISTRY] [Initialization Race] Can concurrent access to the Lazy<StateKeyRegistry> static during validator startup cause initialization races where multiple threads try to initialize REGISTRY simultaneously, leading to inconsistent registry state? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Static: REGISTRY] [Global State] Does the global REGISTRY singleton properly handle validator restarts or state pruning, or can old registry entries persist across epoch boundaries causing stale state key references? (Medium)",
  "[File: aptos-core/types/src/state_store/state_key/registry.rs] [Static: REGISTRY] [Memory Unbounded] Since REGISTRY is never cleared and only grows via get_or_add(), can long-running validators accumulate unbounded registry entries over time, eventually exhausting memory? (High)"
]