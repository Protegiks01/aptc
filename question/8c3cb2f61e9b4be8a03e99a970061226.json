[
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Proof extraction without validation] At lines 46-52, authentication proofs are extracted with .authentication_proof() calls but no validation is performed - can malformed authenticator return invalid proof that passes None check but fails actual verification? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: replay_protector()] [ReplayProtector copy] At lines 156-158, replay_protector is returned by value (likely Copy) - if ReplayProtector is Copy but contains non-Copy data through unsafe code, can this cause shallow copies enabling replay attacks? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: is_orderless()] [Nonce uniqueness] At lines 160-165, Nonce variant is detected - does metadata construction validate nonce uniqueness across concurrent transactions, or can two transactions with same nonce both construct valid metadata causing double-spend? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Sequence number integrity] At line 23, replay_protector is public - can external code change SequenceNumber to Nonce after construction causing transaction to bypass sequence ordering checks? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: senders()] [Sender deduplication] At lines 140-144, sender is added first then secondary_signers extended - if sender also appears in secondary_signers, will it appear twice in senders() Vec causing double resource deduction or authentication confusion? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: secondary_signers()] [Clone side effects] At lines 136-138, secondary_signers are cloned with to_owned() - if AccountAddress has custom Clone with side effects, can cloning cause non-deterministic behavior across validators? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: sender()] [Sender address validation] At lines 132-134, sender is returned without validation - if sender field is mutated to invalid address (like 0x0 or system address), can this bypass sender-based access control checks? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Sender field mutability] At line 19, sender is public AccountAddress - can external code set sender to address different from original transaction enabling privilege escalation where attacker executes as different account? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Max gas amount mutability] At line 28, max_gas_amount is public Gas - can external code set this to Gas::zero() or Gas::MAX causing execution to either fail immediately or bypass gas limits? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Gas unit price mutability] At line 29, gas_unit_price is public - can external code set price to zero causing free execution, or to maximum value causing fee overflow when computing total cost? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: max_gas_amount()] [Gas value semantics] At lines 116-118, max_gas_amount is returned by value - if Gas type uses floating point (unlikely but possible), can precision loss cause gas calculation to be non-deterministic across validators? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: gas_unit_price()] [Price zero bypass] At lines 120-122, gas_unit_price can be zero if attacker sets it - does downstream gas charging code properly handle zero price, or will it divide by price causing panic or undefined behavior? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Transaction size limits] At line 30, transaction_size is NumBytes with no maximum enforced in struct - can attacker create transaction with size that fits in NumBytes but exceeds memory limits causing OOM when transaction is executed? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Raw bytes length truncation] At line 62, raw_txn_bytes_len() returns usize that is cast to u64 - on 64-bit systems can usize exceed u64 causing truncation, or on 32-bit can it cause overflow leading to incorrect size calculation? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: script_size()] [Script size zero check] At lines 128-130, script_size can be zero for non-script transactions - does gas metering properly handle zero size, or will it skip charging for script storage causing gas underpayment? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Script size mutability] At line 34, script_size is public NumBytes - can external code set this to value different from actual script size causing gas calculation mismatch? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Struct: TransactionMetadata] [Expiration timestamp mutability] At line 31, expiration_timestamp_secs is public u64 - can external code extend expiration time after initial validation causing expired transactions to be executed? (High)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: expiration_timestamp_secs()] [Timestamp zero handling] At lines 171-173, expiration can be zero if attacker sets it - does validation properly reject zero expiration, or will it compare with time zero (1970) making all transactions appear expired? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm/src/transaction_metadata.rs] [Function: new()] [Expiration timestamp wraparound] At line 63, expiration_timestamp_secs is u64::MAX - if current time is compared with > check, can u64::MAX pass as never expiring allowing indefinite transaction replay? (High)"
]