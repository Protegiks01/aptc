[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Integer overflow] Can an attacker trigger integer overflow in the len() calculation by causing queued.len() + in_progress.len() + queued_outputs.len() to exceed usize::MAX, potentially returning incorrect queue sizes that lead to backup corruption or infinite loops? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: len()] [Integer overflow] If queued contains usize::MAX/3 futures and in_progress contains usize::MAX/3 futures, can the addition in len() wrap around and return 0 or a small value, causing is_empty() to incorrectly report the queue as empty while futures are still pending? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: size_hint()] [Integer overflow] Does size_hint() safely handle integer overflow when returning (len, Some(len)), or could overflow in len() cause incorrect stream size reporting that breaks backup chunk allocation? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Panic condition] Can an attacker pass max_in_progress = 0 to new() during backup initialization, causing the assertion to panic and crash the backup process, resulting in loss of backup availability? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: new()] [Integer boundary] If max_in_progress is set to usize::MAX during construction, can subsequent comparisons in push() (self.in_progress.len() < self.max_in_progress) always evaluate to true, effectively disabling concurrency limits and causing resource exhaustion? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [State inconsistency] In the while loop draining in_progress, if the loop pushes outputs to queued_outputs but then encounters an error before popping from queued, could this create a state where queued_outputs.len() != (original_in_progress - final_in_progress), breaking the invariant? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Data loss] If poll_next() populates queued_outputs with multiple outputs but then returns early due to Pending status, are subsequent calls guaranteed to drain queued_outputs before polling more futures, or could rapid polling cause output reordering or loss? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Race condition] Can concurrent access to poll_next() from multiple threads (if Unpin trait allows it) cause queued_outputs to be corrupted when one thread pushes while another pops, leading to backup data corruption? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [State inconsistency] If push() adds a future to in_progress when self.in_progress.len() == self.max_in_progress - 1, and then another future completes immediately, could a race allow in_progress.len() to temporarily exceed max_in_progress? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Logic bug] In the while loop, after pushing output to queued_outputs and popping from queued to in_progress, if the newly pushed future completes instantly in the same poll cycle, could this violate the max_in_progress limit by having max_in_progress+1 futures execute? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Resource exhaustion] Can an attacker continuously call push() with slow futures faster than they complete, causing queued VecDeque to grow unbounded and exhaust node memory, resulting in backup node crash and loss of liveness? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Resource exhaustion] If all futures in in_progress complete rapidly in a single poll_next() call, can queued_outputs grow arbitrarily large (up to max_in_progress size) without upper bounds, causing memory exhaustion during backup operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Resource exhaustion] Can calling extend() with an iterator of millions of futures bypass concurrency controls and allocate unbounded memory in queued, causing backup node OOM and process termination? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Struct: FuturesUnorderedX] [Memory leak] Are there scenarios where futures added to queued never get moved to in_progress (e.g., if poll_next() is never called again), causing permanent memory leaks that accumulate across backup operations? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Resource exhaustion] If in_progress futures complete but queued_outputs is never drained (consumer stops polling), can this cause unbounded memory growth in queued_outputs buffer, eventually OOM killing the backup process? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Concurrency bypass] Does the comparison self.in_progress.len() < self.max_in_progress use strict inequality correctly, or could an off-by-one error allow max_in_progress+1 futures to execute concurrently? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Concurrency bypass] In the while loop, if queued.pop_front() returns Some but in_progress.push() fails or panics, could this reduce in_progress count while consuming a queued future, permanently breaking the max_in_progress invariant? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: extend()] [Concurrency bypass] Does extend() properly respect max_in_progress limits when batch-adding futures via iterator, or could it add all futures to in_progress simultaneously, bypassing concurrency controls and exhausting resources? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Logic error] If the while loop condition (Poll::Ready(Some(output))) continues indefinitely because in_progress futures complete faster than queued is drained, could this cause poll_next() to spin forever, hanging the backup process? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: push()] [Edge case] When max_in_progress = 1 and a future is already in_progress, does push() correctly queue additional futures, or could edge case logic allow two futures to run concurrently, violating single-concurrency assumptions? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: is_terminated()] [Logic bug] Does is_terminated() incorrectly ignore the queued VecDeque, returning true when futures are still queued but not yet in_progress, causing premature stream termination and backup data loss? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Termination bug] If poll_next() returns Poll::Ready(None) when self.in_progress.is_empty() but queued is non-empty, does this violate the stream contract and signal premature completion while futures remain unprocessed? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: is_terminated()] [State inconsistency] Can is_terminated() return true while queued_outputs contains undelivered outputs, causing consuming code to believe the stream is done while results are still buffered? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: poll_next()] [Edge case] If all three internal structures (queued, in_progress, queued_outputs) are empty but new futures are added via push() after poll_next() returns Ready(None), does the stream correctly restart or remain permanently terminated? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_unordered_x.rs] [Function: is_terminated()] [Fused stream violation] Does the FusedStream implementation guarantee that poll_next() is never called after returning Ready(None), or could FusedStream consumers call poll_next() again, causing undefined behavior? (Medium)"
]