[
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Comment accuracy] The comment at line 29 says 'Currently only supports aptos_coin' - is this limitation enforced in code, or can the function incorrectly process other coin types leading to corrupted supply data? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [u128 vs BigDecimal mismatch] The comment at line 29 and value_type check at line 47 indicate u128 values, but parsing uses BigDecimal at line 76 - can values larger than u128::MAX be parsed and stored, breaking the invariant? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [VARCHAR overflow] Can the coin_type_hash (line 21) or coin_type (line 22) strings exceed their database VARCHAR length limits, causing insertion failures or silent truncation that corrupts supply tracking? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [NUMERIC precision] Does the PostgreSQL NUMERIC type for supply at line 23 have sufficient precision to store all u128 values without loss, or can large supplies be silently rounded? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [Timestamp bounds] Can transaction_timestamp at line 24 exceed PostgreSQL's TIMESTAMP range (year 294276 AD), causing insertion failures for future-dated transactions? (Low)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Reorg handling] If a blockchain reorganization occurs, can duplicate CoinSupply records with the same transaction_version but different supply values be inserted, violating primary key constraints or causing data inconsistency? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Batch insertion race] When processing multiple transactions in a batch, can concurrent calls to from_write_table_item() for the same transaction_version cause race conditions in database insertion, leading to missing or duplicate supply records? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Missing transaction handling] If a transaction is missing from the blockchain data but referenced in transaction_version, can gaps in the supply history cause queries to return incorrect historical supply values? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [API type deserialization] Can malformed APIWriteTableItem data cause deserialization errors that aren't properly caught, allowing corrupted write_table_item objects to reach the supply parsing logic? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Handle type confusion] Does the write_table_item.handle field have a guaranteed type, or can it be a different type that coincidentally has a to_string() method, causing incorrect handle comparisons at line 51? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [JSON field injection] Can an attacker inject additional fields into the data object that aren't validated (beyond key, value, key_type, value_type), potentially exploiting parser vulnerabilities or causing unexpected behavior? (Low)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Ok(None) ambiguity] Does returning Ok(None) at lines 44, 48, 57, 70, and 95 clearly distinguish between 'no supply data found' versus 'validation failed' versus 'not AptosCoin', or can this ambiguity cause calling code to miss errors? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Silent error suppression] Can validation failures that should be errors (e.g., wrong key type) incorrectly return Ok(None) at line 48, causing the indexer to silently skip supply updates that should have been processed? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Error vs None inconsistency] Why do parsing errors at lines 77-83 return Err() while validation mismatches return Ok(None) - can this inconsistency cause calling code to handle failures incorrectly? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Aggregator table spoofing] Can a malicious actor create a fake table with key_type 'address' and value_type 'u128' that isn't actually the supply aggregator, and if the handle/key somehow match, inject false supply data? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Supply inflation attack] If an attacker gains write access to the aggregator table (through Move VM bugs or consensus issues), can they arbitrarily inflate the coin supply value recorded by the indexer, misrepresenting the actual supply? (Critical)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Historical supply manipulation] Can an attacker submit old transactions with manipulated supply values and valid transaction_version from the past, causing the indexer to overwrite historical supply records with false data? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Empty string validation] Can coin_type_hash or coin_type be empty strings when cloned at lines 87-88, causing database constraint violations or breaking queries that assume non-empty values? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Zero supply validity] Is a supply value of '0' considered valid at line 76, and if so, does this properly represent coins that have zero supply versus uninitialized coins? (Low)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Maximum supply validation] Does the code validate that supply values don't exceed reasonable limits (e.g., total APT cap), or can arbitrarily large supplies be recorded indicating a supply inflation bug? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [Diesel macro safety] Can the #[derive(Insertable)] macro at line 16 generate unsafe SQL that's vulnerable to injection if field values contain SQL metacharacters? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [Primary key enforcement] Does Diesel properly enforce the composite primary key (transaction_version, coin_type_hash) at line 17, or can constraint violations in the database occur due to ORM bugs? (Low)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Struct: CoinSupply] [Field count mismatch] Can the FieldCount derive at line 16 be incorrect if fields are added/removed, causing insert/update statements to fail or insert data into wrong columns? (Medium)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [i64 overflow from u64] Can transaction_version (u64 at line 34) overflow when cast to i64 at line 86 for transaction_version > i64::MAX, causing negative version numbers to be stored? (High)",
  "[File: aptos-core/crates/indexer/src/models/coin_models/coin_supply.rs] [Function: from_write_table_item()] [Epoch bounds] Can txn_epoch at line 36 exceed i64::MAX when cast at line 91, causing integer overflow and negative epoch numbers in the database? (Medium)"
]