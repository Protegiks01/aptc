[
  "[File: types/src/account_config/events/burn_token.rs] [Static: BURN_TOKEN_TYPE] [Lazy Initialization Race] Does the Lazy::new() initialization have race condition vulnerabilities where concurrent first-time access from multiple threads could cause double initialization or inconsistent type tags? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Trait: MoveEventV2Type] [Event Version Confusion] Since this implements MoveEventV2Type, can events be incorrectly processed as V1 events or vice versa, leading to parsing failures or incorrect event handling? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Static: BURN_TOKEN_TYPE] [Type Args Vulnerability] The type_args vector is empty - but what if a malicious event includes type arguments that should be empty, causing type system confusion between generic and non-generic burn events? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: event_v2_translator] [State Lookup Failure] When BurnTokenTranslator calls try_from_bytes() on this struct and then queries TokenStore resource, what happens if the token store doesn't exist - can this be exploited to cause indexer crashes or skip event processing? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: event_v2_translator] [Sequence Number Manipulation] The event translation relies on burn_events sequence numbers from TokenStore - can an attacker manipulate these numbers to cause event ordering issues or duplicate/missing events in the indexer? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: BurnTokenEvent] [Event Duplication] Since both BurnToken (v2) and BurnTokenEvent (v1) exist, can the same burn be recorded twice if both event formats are emitted, causing double-counting of burns? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Move contract] [Event Emission Bypass] The Move contract checks BURNABLE_BY_OWNER flag before burning - but if an attacker directly constructs and emits BurnToken events outside the burn() function, can they bypass this permission check? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Indexer] [Missing Validation] When indexers process BurnToken events, do they re-validate that the burn actually occurred on-chain, or do they blindly trust the event data allowing phantom burns to be recorded? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Derive: Serialize] [Non-deterministic Serialization] Does the serde Serialize derive guarantee deterministic byte output across all field orderings, or could non-deterministic serialization cause event hash mismatches between validators? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Derive: Deserialize] [Extra Fields Attack] If an attacker adds extra unknown fields to the serialized data, does the Deserialize implementation silently ignore them or reject the data, and could extra fields cause security issues in permissive parsers? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Derive: Debug] [Information Leak] Does the Debug trait implementation expose sensitive information about account addresses or token IDs that could be logged and leaked, aiding attackers in targeting specific accounts? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken] [Memory Layout] Given that BurnToken contains AccountAddress (32 bytes), TokenId (nested structs with Strings), and u64, could the memory layout create alignment issues or padding vulnerabilities on certain architectures? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken] [Clone Safety] Since BurnToken contains TokenId which itself contains Strings, are there any clone-related vulnerabilities where deep copying could fail or cause memory corruption under resource pressure? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken] [Drop Semantics] When a BurnToken instance is dropped, are there any resources that need explicit cleanup, or could memory leaks occur if nested TokenId Strings aren't properly freed? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Static: BURN_TOKEN_TYPE] [Thread Safety] Is the Lazy<TypeTag> static BURN_TOKEN_TYPE truly thread-safe for concurrent reads during event processing by multiple validator threads? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: try_from_bytes()] [Race Condition] If multiple threads simultaneously call try_from_bytes() on the same byte slice, could there be data races in the BCS deserializer that produce inconsistent BurnToken instances? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Function: account()/id()/amount()] [Concurrent Access] If one thread calls a getter method while another thread moves the BurnToken, could this cause use-after-move errors or violate Rust's borrow checker in unsafe contexts? (Low)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken] [Schema Evolution] If the BurnToken struct schema changes in future versions (adding new fields), will old events still deserialize correctly, or could version mismatches cause consensus failures between upgraded and non-upgraded validators? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Event Migration] [Migration Attack] During the module_event_migration_enabled() transition from BurnTokenEvent to Burn events, can attackers exploit the dual-format period to create inconsistencies or double-count burns? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.amount] [Supply Manipulation] If an attacker can forge BurnToken events with arbitrary amounts, could they manipulate perceived token supply metrics used for market pricing or governance voting power calculations? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Collection Supply] [Underflow Attack] When collection_data.supply is decremented by the burn amount, if BurnToken.amount exceeds the actual supply, could this cause integer underflow resulting in extremely large supply values? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Supply Tracking] [Desync Attack] If burn events are processed out of order or duplicate events occur, could this cause supply tracking systems to diverge from actual on-chain state, breaking token economics? (High)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: Move Contract] [Permission Bypass] The Move burn() function checks BURNABLE_BY_OWNER - but if an attacker can emit raw BurnToken events without going through burn(), can they record burns for non-burnable tokens? (Critical)",
  "[File: types/src/account_config/events/burn_token.rs] [Integration: burn_by_creator] [Creator Override] The burn_by_creator() function allows creators to burn tokens - can the BurnToken event distinguish between owner burns and creator burns, preventing creator-initiated burns from being misattributed? (Medium)",
  "[File: types/src/account_config/events/burn_token.rs] [Struct: BurnToken.amount] [Maximum Burn] What happens when amount equals u64::MAX - could this represent a special sentinel value that should be handled differently, or cause overflow in supply calculations? (Medium)"
]