[
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_type_parameter()] [Integer Overflow] Can an attacker cause memory exhaustion by repeatedly calling add_type_parameter() to grow the type_parameters Vec unbounded, potentially causing OOM crashes in validators during compilation? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: get_type_parameter_name()] [Out-of-Bounds Access] If type_parameter_idx is provided from untrusted bytecode or corrupted source maps, can values exceeding type_parameters.len() cause panics or return None silently, leading to incorrect error diagnostics that mask real vulnerabilities? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_field_location()] [Memory Exhaustion] Can a malicious module with an enormous VariantIndex value (e.g., u16::MAX) cause the while loop to allocate millions of empty Vec<Loc> entries, exhausting validator memory during module publication? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_field_location()] [Type Confusion] Does the unwrap_or_default() on variant properly handle None vs Some(0) distinction, or could this lead to field locations being assigned to wrong variants in enum-like structures, causing debugging confusion? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: get_field_location()] [Index Mismatch] Can an attacker craft bytecode with mismatched field_index values that exceed the actual field count, causing get() to return None and masking critical error locations during security-critical failures? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: get_field_location()] [Variant Confusion] If variant is Some(v) but self.fields doesn't contain an entry for variant v, does this silently return None, potentially hiding bugs in variant handling that could affect Move resource safety? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: dummy_struct_map()] [Integer Overflow] Can struct_def.field_information.field_count() return values close to usize::MAX, causing the range (0..field_count) iteration to overflow or allocate excessive memory? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: dummy_struct_map()] [Variant Count Manipulation] Can variant_count() be manipulated in malicious bytecode to be extremely large (e.g., u16::MAX), causing the for variant in 0..variant_count loop to create millions of field vectors and exhaust memory? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: dummy_struct_map()] [Type Parameter Index Overflow] Can struct_handle.type_parameters.len() cause integer overflow when formatting 'Ty{}' names if length exceeds format buffer limits? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: dummy_struct_map()] [Inconsistent State] If field_information.field_count(Some(variant)) returns different values for same variant across multiple calls, could this lead to fields vector having inconsistent lengths, breaking invariants? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: new()] [Native Function Handling] Does is_native flag properly isolate native function handling, or can attackers craft native functions with non-empty code_map to bypass validation logic? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_type_parameter()] [Unbounded Growth] Can repeated type parameter additions without bounds checking lead to Vec reallocation DoS, especially during parallel compilation of multiple modules? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: get_type_parameter_name()] [Index Validation] Does cloned() prevent use-after-free or does it properly handle concurrent access if source maps are shared across threads during compilation? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_code_mapping()] [Segment Map Logic Error] Can the comparison 'other_location != location' fail to detect semantically identical locations with different internal representations, causing excessive BTreeMap entries? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_code_mapping()] [CodeOffset Collision] If multiple bytecode transformations map different offsets to same location, can this cause code_map entries to be incorrectly overwritten, breaking stack trace accuracy during security audits? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_code_mapping()] [BTreeMap Ordering] Does CodeOffset ordering guarantee that segment map queries work correctly, or can integer wraparound cause CodeOffset values to violate ordering invariants? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: remap_code_map()] [Remap Array Bounds] Can the remap slice contain indices beyond the original code_map size, causing get_code_location(*old_offset) to return None and create gaps in the remapped code_map? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: remap_code_map()] [Optimization Bug] Does the 'prev_loc == loc' optimization correctly handle the case where consecutive instructions legitimately map to the same location, or could this lose important code mapping boundaries? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: remap_code_map()] [enumerate() Overflow] Can the enumerate() on remap iterator cause new_offset to overflow as CodeOffset if remap length exceeds CodeOffset::MAX, creating negative or wrapped offsets? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: remap_code_map()] [Filter Map Consistency] If multiple old_offsets map to same location but filter_map removes some, does this break the segment map invariant that each code range has exactly one starting location? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_nop_mapping()] [Assert Panic] Can the assert!(self.nops.insert(label, offset).is_none()) be triggered by duplicate NopLabel values in malicious bytecode, causing validator crashes during compilation? (High)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_nop_mapping()] [Label Collision] If two different high-level language constructs generate same NopLabel, does the panic prevent module deployment or could this be exploited to DoS the compilation pipeline? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_nop_mapping()] [Offset Validity] Is the offset parameter validated to be within valid bytecode bounds, or can arbitrary CodeOffset values be stored causing incorrect nop location lookups? (Low)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_local_mapping()] [Ordering Requirement] Does the comment 'Note that it is important that locations be added in order' indicate a critical invariant, and can violating this order cause local index mismatches during debugging? (Medium)",
  "[File: aptos-core/third_party/move/move-ir-compiler/move-bytecode-source-map/src/source_map.rs] [Function: add_local_mapping()] [Vector Growth] Can unbounded calls to add_local_mapping() grow the locals Vec to consume excessive memory if a malicious module declares millions of local variables? (High)"
]