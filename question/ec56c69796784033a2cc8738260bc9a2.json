[
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Deserialization] [Untrusted Input] Is all bytecode treated as untrusted input with proper validation, or are there assumptions that bytecode is pre-validated, which could be violated in certain attack scenarios? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Access Control] [Negation Semantics] Is the semantics of negated clauses (line 38-39) correctly implemented - does !reads mean 'no reads and no writes' vs !writes meaning 'no writes but reads ok', as documented in runtime_access_specifier.rs? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Access Control] [Inclusion/Exclusion Logic] Does Constraint(incls, excls) correctly implement the logic 'allowed by any inclusion AND NOT excluded by all exclusions', or can logical errors cause security bypasses? (Critical)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Access Control] [Wildcard Handling] For ResourceSpecifier::Any (line 58) and AddressSpecifier::Any (line 84), are these wildcards properly restricted to prevent overly permissive access grants? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Access Control] [Clause Ordering] Does the order of clauses in incls/excls vectors matter for access control decisions, or should they be sorted for determinism? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Module System] [Module Handle Trust] When resolving ModuleHandleIndex (line 65), does the loader verify the module is from a trusted source, or can untrusted modules be referenced in access specifiers? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Module System] [Circular References] Can access specifiers create circular dependencies between modules (e.g., module A's specifier references module B which references A), causing deadlocks during loading? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Module System] [Module Unloading] If a module referenced in DeclaredInModule is unloaded after the access specifier is loaded, does the StructIdentifier remain valid, or can dangling references cause crashes? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_address_specifier()] [Instantiation Validation] When accessing function_instantiations()[idx.0] (line 91), are type arguments validated to prevent instantiating address specifier functions with incompatible types? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_address_specifier()] [Handle Chain Validation] The chain fun_inst -> fun_handle -> mod_handle (lines 91-93) - can any of these indirections be maliciously crafted to reference wrong handlers, breaking the intended function reference? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_address_specifier()] [Generic Function Parameters] If the address specifier function is generic, are type parameters properly instantiated, or can generic functions cause type confusion in address extraction? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Signature Table Integrity] Is the signature_table parameter validated for correctness before use, or can a corrupted table cause incorrect type instantiations in ResourceInstantiation clauses? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Type Vector Length] When cloning signature_table[ty_idx.0] (line 73), are there maximum length constraints to prevent excessively long type parameter lists causing memory issues? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Type Cycle Detection] Can the types in signature_table contain cycles (e.g., struct A<B> where B contains A), causing infinite loops during type comparison in access control checks? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Struct Names Validation] Is the struct_names parameter validated to contain only properly initialized StructIdentifiers, or can partially initialized entries cause undefined behavior? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Duplicate Struct Names] Can struct_names contain duplicate entries with the same StructIdentifier, causing ambiguous resource specifiers that grant unintended access? (Medium)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Function: load_resource_specifier()] [Struct Identifier Clone] When cloning StructIdentifier (lines 69, 72), does this perform a deep copy of all nested data, or can shallow copies cause aliasing issues? (Low)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Error Handling] [Status Code Overloading] Is ACCESS_CONTROL_INVARIANT_VIOLATION used for both genuine invariant violations and simple validation failures, making it harder to distinguish attack attempts from bugs? (Low)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Error Handling] [Error Message Consistency] Are error messages like 'table index out of range' (line 124) and 'function not supported' (lines 102-104) consistent with error messages elsewhere in the codebase for similar failures? (Low)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Runtime] [Eval Specialization] When AddressSpecifier::Eval is later specialized (line 234 of runtime_access_specifier.rs), can the eval_address_specifier_function call fail, and if so, is the error handling secure? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Runtime] [Parameter Out of Bounds] Can the LocalIndex stored in AddressSpecifier::Eval (line 109) exceed the actual parameter count of the function at runtime, causing crashes when specializing? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Runtime] [Function Signature Mismatch] If the function referenced for address extraction has a different signature than expected (e.g., returns non-address type), can this cause type safety violations during evaluation? (High)",
  "[File: third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs] [Consensus] [Non-Deterministic Ordering] If struct_names or signature_table have non-deterministic ordering across validators, can this cause different AccessSpecifier objects to be created, breaking consensus\n\n### Citations\n\n**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L1-125)\n```rust\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse move_binary_format::{\n    binary_views::BinaryIndexedView,\n    errors::{PartialVMError, PartialVMResult},\n    file_format as FF,\n    file_format::TableIndex,\n};\nuse move_core_types::vm_status::StatusCode;\nuse move_vm_types::loaded_data::{\n    runtime_access_specifier::{\n        AccessSpecifier, AccessSpecifierClause, AddressSpecifier, AddressSpecifierFunction,\n        ResourceSpecifier,\n    },\n    runtime_types::{StructIdentifier, Type},\n};\n\n/// Loads an access specifier from the file format into the runtime representation.\npub fn load_access_specifier(\n    module: BinaryIndexedView,\n    signature_table: &[Vec<Type>],\n    struct_names: &[StructIdentifier],\n    specifier: &Option<Vec<FF::AccessSpecifier>>,\n) -> PartialVMResult<AccessSpecifier> {\n    if let Some(specs) = specifier {\n        let mut incls = vec![];\n        let mut excls = vec![];\n        for spec in specs {\n            let resource =\n                load_resource_specifier(module, signature_table, struct_names, &spec.resource)?;\n            let address = load_address_specifier(module, &spec.address)?;\n            let clause = AccessSpecifierClause {\n                kind: spec.kind,\n                resource,\n                address,\n            };\n            if spec.negated {\n                excls.push(clause)\n            } else {\n                incls.push(clause)\n            }\n        }\n        Ok(AccessSpecifier::Constraint(incls, excls))\n    } else {\n        Ok(AccessSpecifier::Any)\n    }\n}\n\nfn load_resource_specifier(\n    module: BinaryIndexedView,\n    signature_table: &[Vec<Type>],\n    struct_names: &[StructIdentifier],\n    spec: &FF::ResourceSpecifier,\n) -> PartialVMResult<ResourceSpecifier> {\n    use FF::ResourceSpecifier::*;\n    match spec {\n        Any => Ok(ResourceSpecifier::Any),\n        DeclaredAtAddress(addr_idx) => Ok(ResourceSpecifier::DeclaredAtAddress(*access_table(\n            module.address_identifiers(),\n            addr_idx.0,\n        )?)),\n        DeclaredInModule(mod_idx) => Ok(ResourceSpecifier::DeclaredInModule(\n            module\n                .safe_module_id_for_handle(access_table(module.module_handles(), mod_idx.0)?)\n                .ok_or_else(index_out_of_range)?,\n        )),\n        Resource(str_idx) => Ok(ResourceSpecifier::Resource(\n            access_table(struct_names, str_idx.0)?.clone(),\n        )),\n        ResourceInstantiation(str_idx, ty_idx) => Ok(ResourceSpecifier::ResourceInstantiation(\n            access_table(struct_names, str_idx.0)?.clone(),\n            access_table(signature_table, ty_idx.0)?.clone(),\n        )),\n    }\n}\n\nfn load_address_specifier(\n    module: BinaryIndexedView,\n    spec: &FF::AddressSpecifier,\n) -> PartialVMResult<AddressSpecifier> {\n    use FF::AddressSpecifier::*;\n    match spec {\n        Any => Ok(AddressSpecifier::Any),\n        Literal(idx) => Ok(AddressSpecifier::Literal(*access_table(\n            module.address_identifiers(),\n            idx.0,\n        )?)),\n        Parameter(param, fun) => {\n            let fun = if let Some(idx) = fun {\n                let fun_inst = access_table(module.function_instantiations(), idx.0)?;\n                let fun_handle = access_table(module.function_handles(), fun_inst.handle.0)?;\n                let mod_handle = access_table(module.module_handles(), fun_handle.module.0)?;\n                let mod_id = module\n                    .safe_module_id_for_handle(mod_handle)\n                    .ok_or_else(index_out_of_range)?;\n                let mod_name = mod_id.short_str_lossless();\n                let fun_name = access_table(module.identifiers(), fun_handle.name.0)?;\n                AddressSpecifierFunction::parse(&mod_name, fun_name.as_str()).ok_or_else(|| {\n                    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)\n                        .with_message(format!("
]