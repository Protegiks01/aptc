[
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db_shards()] [Parallel shard truncation] At line 182-191, shards are truncated in parallel - can partial shard failures leave the Merkle tree in an inconsistent state where root hash doesn't match shard data? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_state_merkle_db_single_shard()] [Shard-specific deletion] At line 193-206, Some(shard_id) is passed to deletion function - can incorrect shard_id cause cross-shard data deletion? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: find_tree_root_at_or_before()] [Partial commit handling] At line 220-224, if sharding is disabled and a partial commit exists, version - 1 is checked - can underflow when version = 0 cause incorrect root lookup? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: find_tree_root_at_or_before()] [Epoch boundary] At line 232-241, epoch ending versions are checked - can an attacker exploit this fallback to force using an old epoch's root, breaking state continuity? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: find_tree_root_at_or_before()] [Multiple fallbacks] With three different fallback mechanisms (lines 214-244), can the complexity be exploited to return an inconsistent root version? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: root_exists_at_version()] [Empty path node check] At line 247-255, checking NodeKey::new_empty_path(version) - can a corrupted DB where the root exists but child nodes are missing pass this check, causing incomplete state verification? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: get_current_version_in_state_merkle_db()] [Version::MAX seek] At line 260, seeking with Version::MAX - can this cause integer overflow or incorrect version detection in edge cases? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: get_max_version_in_state_merkle_db()] [Multi-shard max] At line 263-284, iterating all shards to find max version - can inconsistent shard versions cause the function to return a version that doesn't exist in all shards? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: find_closest_node_version_at_or_before()] [Reverse iteration] At line 286-293, using rev_iter and seek_for_prev - can incorrect seek behavior in the underlying DB cause this to skip valid versions? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: num_frozen_nodes_in_accumulator()] [Bit manipulation] At line 295-297, using count_ones() for calculation - can adversarial num_leaves values cause incorrect node count calculation, leading to incomplete accumulator truncation? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_transaction_accumulator()] [Position calculation] At line 299-323, complex position arithmetic - can integer overflow in to_postorder_index() or from_postorder_index() cause incorrect node deletion? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_transaction_accumulator()] [Deletion count mismatch] At line 320, assert_eq!(num_nodes_to_delete, 0) - can database corruption cause this assertion to fail after partial deletion, leaving the accumulator in an inconsistent state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: truncate_transaction_accumulator()] [Seek position] At line 311-312, seeking to start_position - can from_postorder_index fail and cause the seek to be at the wrong position? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transaction_index_data()] [Iterator size limit] At line 371, limiting to MAX_COMMIT_PROGRESS_DIFFERENCE * 2 transactions - can this arbitrary limit cause incomplete index deletion if more transactions exist? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transaction_index_data()] [Hash collision] At line 382, pruning by transaction hash - can hash collisions cause legitimate transactions to be incorrectly deleted? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transaction_index_data()] [Version range construction] At line 384-387, constructing (start_version..=start_version + len - 1) - can integer overflow in this range cause incorrect version mapping? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transaction_index_data()] [Empty transaction set] At line 374, only processing if num_txns > 0 - can this skip necessary cleanup when no transactions are found but indices still exist? (Low)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_epoch_data()] [Latest epoch check] At line 394-412, only deleting latest epoch if version >= start_version - can this leave orphaned epoch data if multiple epochs need deletion? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_epoch_data()] [Epoch-version consistency] At line 413-427, deleting both EpochByVersionSchema and LedgerInfoSchema - can partial deletion leave one schema with data while the other is deleted? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_epoch_data()] [Iterator exhaustion] At line 416-426, iterating without bounds checking - can a corrupted DB with millions of epoch entries cause excessive memory consumption? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_version_data()] [Multi-schema coordination] At line 430-462, deleting from 5 different schemas - can failure in one schema leave others in an inconsistent state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_version_data_impl()] [Version iteration] At line 494-518, iterating from start_version to latest_version - can a massive version range cause timeout and incomplete deletion? (High)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_per_version_data_impl()] [Generic schema assumption] Using Schema<Key = Version> trait bound - can schemas with composite keys be incorrectly truncated? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transactions_and_transaction_summary_data()] [User transaction detection] At line 482-487, only deleting summaries for signed_user_txn - can system transactions leave orphaned summary data? (Low)",
  "[File: aptos-core/storage/aptosdb/src/utils/truncation_helper.rs] [Function: delete_transactions_and_transaction_summary_data()] [Transaction retrieval] At line 480, get_transaction(version) must succeed for each version - can missing transactions cause the function to fail midway, leaving partial deletion? (High)"
]