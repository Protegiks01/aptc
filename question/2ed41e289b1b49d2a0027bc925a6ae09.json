[
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Lock contention] High-frequency calls to this function (from queries) may contend for latest_version.lock() - can this create a performance bottleneck during high query load? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Write amplification] Is write_pruner_progress() called too frequently, causing excessive database writes that degrade write performance for transaction commits? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Thread creation] Does PrunerWorker spawn a new OS thread - can malicious configurations cause thread exhaustion by creating many pruner managers? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Memory allocation] The Arc<Mutex<Version>> allocation - can memory exhaustion during initialization cause allocation failures that leave the pruner in an invalid state? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Validator inconsistency] If validators have different prune_window or user_pruning_window_offset configurations, can they prune different data ranges, causing state proof verification to fail across nodes? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Pruning delay] If pruning lags significantly behind latest_version due to the batch_size condition, can validators accumulate excessive storage, causing operational issues? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_readable_version()] [Query routing] If different API nodes have different min_readable_version values due to pruning delays, can clients receive inconsistent query results depending on which node they hit? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Crash recovery] After a validator crash and restart, if the pruner resumes from an incorrect version, can it re-prune already pruned data, causing double-deletion attempts and errors? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Replication lag] If pruning completes on one node but save_min_readable_version() fails to replicate to other nodes (in distributed deployment), can query inconsistencies occur? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Cast overflow] The pruning_batch_size (usize) is cast to u64 at line 74 - can this overflow on 32-bit systems or cause unexpected behavior? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Metric cast] The i64 casts at lines 153 and 157 for metrics - if prune_window or batch_size exceed i64::MAX, can this cause negative or incorrect metric values? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Saturating arithmetic safety] Multiple saturating_sub calls (lines 56-57, 58) - can chained saturation hide arithmetic errors that should be caught and reported? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Version arithmetic] Is there validation that latest_version >= prune_window before saturating_sub at line 164, or can this silently return 0 when it shouldn't? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Max comparison] The std::cmp::max at line 59 - can this hide issues where both values are incorrect, returning the 'larger incorrect value'? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: is_pruner_enabled()] [State transition] If pruner configuration changes from enabled to disabled at runtime, does the code handle this gracefully, or can it cause calls to disabled pruner functions? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Initialization order] If ledger_db is not fully initialized when passed to new(), can this cause get_ledger_pruner_progress() to read invalid data? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Drop behavior] Does LedgerPrunerManager implement Drop to ensure pruner_worker thread is properly shut down, or can thread leaks occur? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Repeated calls] Can calling this function repeatedly with the same latest_version cause redundant work or state corruption in the pruner_worker? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: is_pruning_pending()] [State consistency] Can is_pruning_pending() return true even when pruner is disabled, causing incorrect status reporting? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_prune\n\n### Citations\n\n**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L1-177)\n```rust\n// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    ledger_db::LedgerDb,\n    metrics::{PRUNER_BATCH_SIZE, PRUNER_VERSIONS, PRUNER_WINDOW},\n    pruner::{\n        ledger_pruner::LedgerPruner, pruner_manager::PrunerManager, pruner_utils,\n        pruner_worker::PrunerWorker,\n    },\n};\nuse aptos_config::config::LedgerPrunerConfig;\nuse aptos_db_indexer::db_indexer::InternalIndexerDB;\nuse aptos_infallible::Mutex;\nuse aptos_storage_interface::Result;\nuse aptos_types::transaction::{AtomicVersion, Version};\nuse std::sync::{atomic::Ordering, Arc};\n\n/// The `PrunerManager` for `LedgerPruner`.\npub(crate) struct LedgerPrunerManager {\n    ledger_db: Arc<LedgerDb>,\n    /// DB version window, which dictates how many version of other stores like transaction, ledger\n    /// info, events etc to keep.\n    prune_window: Version,\n    /// It is None iff the pruner is not enabled.\n    pruner_worker: Option<PrunerWorker>,\n    /// Ideal batch size of the versions to be sent to the ledger pruner\n    pruning_batch_size: usize,\n    /// latest version\n    latest_version: Arc<Mutex<Version>>,\n    /// Offset for displaying to users\n    user_pruning_window_offset: u64,\n    /// The minimal readable version for the ledger data.\n    min_readable_version: AtomicVersion,\n}\n\nimpl PrunerManager for LedgerPrunerManager {\n    type Pruner = LedgerPruner;\n\n    fn is_pruner_enabled(&self) -> bool {\n        self.pruner_worker.is_some()\n    }\n\n    fn get_prune_window(&self) -> Version {\n        self.prune_window\n    }\n\n    fn get_min_readable_version(&self) -> Version {\n        self.min_readable_version.load(Ordering::SeqCst)\n    }\n\n    fn get_min_viable_version(&self) -> Version {\n        let min_version = self.get_min_readable_version();\n        if self.is_pruner_enabled() {\n            let adjusted_window = self\n                .prune_window\n                .saturating_sub(self.user_pruning_window_offset);\n            let adjusted_cutoff = self.latest_version.lock().saturating_sub(adjusted_window);\n            std::cmp::max(min_version, adjusted_cutoff)\n        } else {\n            min_version\n        }\n    }\n\n    /// Sets pruner target version when necessary.\n    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {\n        *self.latest_version.lock() = latest_version;\n\n        let min_readable_version = self.get_min_readable_version();\n        // Only wake up the ledger pruner if there are `ledger_pruner_pruning_batch_size` pending\n        // versions.\n        if self.is_pruner_enabled()\n            && latest_version\n                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window\n        {\n            self.set_pruner_target_db_version(latest_version);\n        }\n    }\n\n    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {\n        self.min_readable_version\n            .store(min_readable_version, Ordering::SeqCst);\n\n        PRUNER_VERSIONS\n            .with_label_values(&["
]