[
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Gas timing side-channel] Does the gas charging implementation leak timing information about which Structure variant is being processed, allowing attackers to infer private transaction details? (Low)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Failed charge handling] If $context.charge($gas)? returns an error due to insufficient gas, does the function properly clean up partial state or can it leave dangling handles in AlgebraContext? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Memory limit bypass] The store_element! macro checks MEMORY_LIMIT_IN_BYTES (1MB) before storing - can an attacker repeatedly call double_internal() to allocate exactly 1MB per session, then use other operations to exceed the limit? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Size calculation overflow] In store_element! at line 240, the calculation 'context.bytes_used + std::mem::size_of_val(&$obj)' could overflow for large objects - can this cause memory limit checks to be bypassed? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Rc reference counting] Each call to double_internal() creates a new Rc<dyn Any> via store_element! - can attackers cause memory leaks by creating circular references or exceeding Rc strong count limits? (Medium)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [AlgebraContext accumulation] The AlgebraContext.objs vector grows with each operation - can an attacker exhaust heap memory by calling double_internal() many times within a single VM session before hitting the 1MB bytes_used limit? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle exhaustion] Since handles are returned as u64 from store_element!, can an attacker exhaust the handle space by creating 2^64 elements, causing handle collisions or overwrites? (Medium)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Stack exhaustion] Can deeply nested or recursive calls to double_internal() via Move smart contracts cause stack overflow in the Rust execution environment? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Memory fragmentation] Repeated allocation of different-sized algebraic elements (G1 vs G2 vs Fq12) - can this cause memory fragmentation that degrades validator performance or causes OOM? (Medium)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Session cleanup failure] If AlgebraContext.start() is called to reset state, but objs.clear() at line 196 fails to release Rc references, can memory leak across sessions? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Size_of accuracy] Does std::mem::size_of_val() in store_element! accurately measure the size of arkworks types including heap allocations, or does it only measure stack size, allowing memory limit bypass? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Concurrent memory tracking] If multiple threads access AlgebraContext simultaneously, can race conditions in bytes_used tracking cause the memory limit check to be bypassed? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle reuse attack] After double_internal() returns a new handle, can an attacker reuse the input handle with a different type argument in a subsequent call to access freed or wrong-typed memory? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle out-of-bounds] The handle from safely_pop_arg! is cast to usize for array indexing in safe_borrow_element! - can an attacker pass a handle value >= objs.len() to cause out-of-bounds access? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle type confusion] Can an attacker pass a handle that was created by a different native function (e.g., from serialization) with incompatible type, causing safe_borrow_element! to fail invariant checks? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Dangling handle] If AlgebraContext.objs is cleared during session transition, can stale handles from previous sessions be reused in double_internal() to access wrong data? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle wraparound] When store_element! returns target_vec.len() as the new handle, can the vec length overflow usize max and wrap to 0, causing handle collisions? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Reference lifetime violation] The safe_borrow_element! macro extracts element_ptr.clone() and element reference - can the reference outlive the Rc, causing use-after-free? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle forgery from Move] Can Move code craft arbitrary u64 values as fake handles without calling proper native allocation functions, passing them to double_internal() to access arbitrary memory? (Critical)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle passing between contexts] If handles are passed between different AlgebraContext instances (e.g., across function calls), can handle indices point to wrong objects? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Rc downcast race] Is the downcast_ref::<$ark_typ>() in safe_borrow_element! atomic with respect to concurrent modifications, or can type confusion occur during casting? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle integer truncation] Is the handle cast from u64 to usize at line 31 in ark_unary_op_internal! safe on 32-bit systems where usize is smaller, potentially causing truncation and wrong handle access? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Handle scope leakage] Can handles created in double_internal() leak across transaction boundaries if AlgebraContext cleanup fails, allowing cross-transaction attacks? (High)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Multiple handle references] Since safe_borrow_element! clones the Rc pointer, can multiple simultaneous borrows of the same handle cause aliasing issues during the double operation? (Medium)",
  "[File: aptos-move/framework/src/natives/cryptography/algebra/arithmetics/double.rs] [Function: double_internal()] [Feature flag timing] The abort_unless_arithmetics_enabled_for_structure! check at line 27 occurs after structure_from_ty_arg! - can attackers probe which structures exist by timing differences between feature-disabled and type-invalid errors? (Low)"
]