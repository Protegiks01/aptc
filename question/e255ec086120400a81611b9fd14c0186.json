[
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::connect()] [Connection hijacking] Can an attacker supply a malicious endpoint URL that redirects to a compromised indexer service, allowing them to serve falsified transaction data and cause indexers to process invalid blockchain state? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::max_decoding_message_size()] [Resource exhaustion] Is the default 4MB message size limit enforced consistently, or can an attacker bypass this by sending larger streaming responses that cause memory exhaustion on indexer clients consuming transaction batches? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::max_encoding_message_size()] [Integer overflow] Does the usize::MAX default value for encoding message size expose integer overflow vulnerabilities when calculating buffer sizes for extremely large GetTransactionsRequest batches? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::send_compressed()] [Compression bomb] Can an attacker enable compression encoding and craft malicious TransactionsResponse data that expands exponentially during decompression, causing denial of service on indexer nodes? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::accept_compressed()] [Decompression attack] If compression encodings are not properly validated, can a malicious server send crafted compressed responses that exploit decompression vulnerabilities to crash indexer clients or execute arbitrary code? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::with_interceptor()] [Authentication bypass] Can an attacker exploit the interceptor chain to bypass authentication checks by crafting requests that skip validation, allowing unauthorized access to raw blockchain transaction data? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::get_transactions()] [Version manipulation] Can an attacker manipulate the GetTransactionsRequest starting version or transaction count parameters to retrieve historical transactions outside their authorized range, potentially exposing sensitive transaction data? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::get_transactions() ready check] [Race condition] Does the ready() check at line 101-108 properly synchronize with concurrent requests, or can race conditions allow multiple simultaneous streaming requests that overwhelm the server with GetTransactions calls? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::get_transactions() path routing] [Path injection] Can an attacker manipulate the hardcoded path '/aptos.indexer.v1.RawData/GetTransactions' to inject malicious routing logic or bypass service dispatch validation? (Low)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataClient::with_origin()] [CORS bypass] Can an attacker exploit the origin setting to bypass CORS restrictions and make cross-origin requests to indexer services from malicious web applications, potentially exposing transaction data to untrusted origins? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Struct: RawDataServer] [Arc cloning vulnerability] Does the Arc<T> inner service wrapping expose race conditions when multiple concurrent GetTransactions streaming requests access shared state, potentially corrupting transaction ordering or causing data races? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::new()] [Initialization vulnerability] Can an attacker exploit the default compression and message size settings during server initialization to create a misconfigured service that accepts dangerous compression ratios or unlimited message sizes? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::from_arc()] [Shared state corruption] When initializing from an existing Arc, can concurrent modifications to accept_compression_encodings or send_compression_encodings cause inconsistent compression handling across multiple server instances? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::with_interceptor()] [Interceptor bypass] Can an attacker craft requests that bypass the interceptor chain by exploiting the order of operations between InterceptedService creation and request processing? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::accept_compressed()] [Compression encoding manipulation] Can an attacker enable multiple conflicting compression encodings that cause the server to mishandle decompression, leading to corrupted transaction data being served to indexers? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::send_compressed()] [Response tampering] Can a malicious server implementation exploit compression settings to selectively compress certain transaction responses while leaving others uncompressed, causing indexer clients to process data inconsistently? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::max_decoding_message_size()] [Limit enforcement bypass] Can an attacker send requests with message sizes slightly below the configured limit but which expand significantly during processing, bypassing the intended memory protection? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::max_encoding_message_size()] [Memory exhaustion] If max_encoding_message_size is set to None (unlimited), can an attacker trigger responses with unbounded TransactionsResponse streams that exhaust server memory? (Critical)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::poll_ready()] [Always-ready vulnerability] Does the Poll::Ready(Ok(())) return at line 215 mean the server always reports ready status, potentially accepting requests even when underlying resources are exhausted or unavailable? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer::call() path matching] [Path traversal] Can an attacker craft HTTP requests with malicious URI paths that bypass the match statement at line 219, potentially routing to unintended service handlers? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Struct: GetTransactionsSvc] [Service cloning race] When Arc::clone(&self.0) is called at line 238 within the async future, can concurrent cloning operations cause use-after-free or double-free conditions with the inner RawData trait implementation? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: GetTransactionsSvc::call()] [Async future pinning] Does Box::pin(fut) at line 242 properly handle cancellation and cleanup, or can aborted GetTransactions streams leave dangling resources or incomplete transaction batches? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer apply_compression_config] [Configuration race] Can concurrent requests modify accept_compression_encodings or send_compression_encodings between lines 245-256 while compression config is being applied, causing inconsistent compression behavior? (Medium)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer apply_max_message_size_config] [Size limit bypass] Can an attacker exploit the time window between max size config application (lines 258-261) and actual message validation to send oversized messages? (High)",
  "[File: aptos-core/protos/rust/src/pb/aptos.indexer.v1.tonic.rs] [Function: RawDataServer server_streaming] [Stream termination] Does grpc.server_streaming() at line 262 properly handle client disconnections, or can aborted streams leave open file descriptors or database connections in the transaction data source? (Medium)"
]