[
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Critical Authorization Bypass] The backup service exposes all routes via warp::get() without any authentication middleware - can an attacker who gains network access to the backup service port exfiltrate the entire blockchain state, including all account balances, private state, and transaction history, leading to complete loss of data confidentiality? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Critical Authorization Bypass] Lines 138-147 show GET-only access without authentication checks - can a malicious insider or compromised node operator access the backup API to extract all validator keys, stake information, and governance data, enabling targeted attacks on high-value accounts? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: db_state endpoint] [Information Disclosure] Lines 31-34 expose get_db_state() without authorization - can an attacker repeatedly query this endpoint to monitor blockchain progress, identify sync delays, and time attacks against validators during epoch transitions when they're most vulnerable? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Authorization Bypass] Lines 48-57 allow unrestricted access to complete state snapshots - can an attacker extract all Move module bytecode, including unaudited or governance-restricted modules, to find vulnerabilities before they're publicly disclosed? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Privacy Violation] Lines 102-111 expose raw transaction data without access control - can an attacker correlate transaction patterns, identify whale addresses, frontrun large transactions, or deanonymize users through transaction graph analysis? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Integer Overflow] Line 53 uses usize::MAX as limit parameter - on 32-bit systems, can this cause integer overflow when calculating memory allocations in get_state_item_iter(), leading to buffer overflows, memory corruption, or arbitrary code execution? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Integer Overflow] Lines 73-79 accept start_idx and limit as usize without validation - can an attacker provide start_idx=usize::MAX and limit=usize::MAX to trigger overflow when computing end_idx = start_idx + limit, causing out-of-bounds reads or database corruption? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Integer Overflow] Lines 104-110 accept num_transactions as usize - can an attacker request num_transactions=usize::MAX starting at start_version=u64::MAX-1000 to overflow version calculations and read transactions from arbitrary positions, potentially exposing pruned or invalid data? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Integer Overflow] Lines 115-123 compute last_version - first_version - can an attacker provide first_version > last_version to cause integer underflow, bypassing validation checks and retrieving invalid transaction proofs that could be used to forge state? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [Integer Overflow] Lines 93-100 accept start_epoch and end_epoch as u64 - can an attacker provide end_epoch=u64::MAX and start_epoch=0 to trigger overflow in epoch range calculation, causing memory exhaustion or database read amplification DoS? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Arithmetic Error] Line 76 computes version + start_idx + limit internally - if version=u64::MAX, start_idx=usize::MAX/2, limit=usize::MAX/2, can this overflow cause the iterator to wrap around and read from version 0, exposing genesis state or causing state confusion? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Memory Exhaustion] Lines 50-57 stream entire state snapshot with limit=usize::MAX - can an attacker repeatedly request full state snapshots to exhaust node memory, cause OOM kills, and crash validator nodes, leading to consensus liveness failures? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Resource Exhaustion] Lines 104-110 allow requesting arbitrary num_transactions - can an attacker request 2^32 transactions in a single call to exhaust database connection pools, fill disk with logs, or trigger timeout cascades that halt backup operations network-wide? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Amplification Attack] Lines 73-79 allow arbitrary limit values - can an attacker spawn 10,000 concurrent requests each with limit=1,000,000 to create a 10-billion-item read amplification attack that overwhelms storage I/O and crashes the database? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [DOS via Iteration] Lines 93-100 iterate from start_epoch to end_epoch - can an attacker request epochs 0 to 999,999,999 to force enumeration of non-existent epochs, triggering excessive database seeks that degrade performance for legitimate consensus operations? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Connection Exhaustion] Lines 28-147 use BackupHandler.clone() for each route without connection pooling limits - can an attacker open 100,000 concurrent HTTP connections to exhaust file descriptors and prevent validators from accepting new consensus connections? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [CPU Exhaustion] Lines 37-46 compute Merkle proofs without rate limiting - can an attacker request proofs for all 2^256 possible hash values to max out CPU calculating cryptographic proofs, slowing down block processing and violating finality guarantees? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Proof Computation DOS] Lines 115-123 compute accumulator proofs for arbitrary ranges - can an attacker request proof for first_version=0, last_version=u64::MAX to force O(log n) accumulator operations on the maximum possible range, creating CPU exhaustion that delays block commits? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [State Inconsistency] Lines 50-57 call get_state_item_iter(version, 0, usize::MAX) without transaction isolation - can concurrent state modifications during a long-running snapshot read cause the backup to contain a mix of data from different versions, creating inconsistent snapshots that fail restoration? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [TOCTOU Race Condition] Lines 73-79 request chunks at different times without version locking - can an attacker exploit the time-of-check-time-of-use gap by triggering state changes between chunk requests, assembling a Frankenstein snapshot that combines incompatible states and corrupts restored databases? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_root_proof endpoint] [Proof Integrity] Lines 84-89 return state root proof at specified version - can an attacker request proofs at a version during epoch reconfiguration to receive proofs based on an incomplete validator set transition, creating proofs that verify against wrong state roots? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Proof Mismatch] Lines 115-123 generate proofs across arbitrary version ranges - can an attacker request a range spanning an epoch boundary where validator sets changed, receiving a proof that's cryptographically valid but semantically incorrect due to root hash discontinuity? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Data Consistency] Lines 104-110 stream transactions without atomicity guarantees - if the database is pruned during the streaming process, can the iterator return a partial transaction set with gaps, causing backup consumers to miss critical transactions and diverge from canonical state? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: db_state endpoint] [Race Condition] Lines 31-34 call get_db_state() without locks - can concurrent epoch transitions cause this to return epoch=N+1 with committed_version from epoch=N, creating temporal inconsistency that makes backup restoration target an impossible state? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_item_count endpoint] [Count Inconsistency] Lines 60-69 return state item count without snapshot isolation - can concurrent writes change the count between this call and subsequent state_snapshot_chunk calls, causing backup clients to request chunks beyond actual data, triggering panics or incomplete backups? (Medium)"
]