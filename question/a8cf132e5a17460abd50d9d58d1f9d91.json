[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_privatekey()] [Type parsing vulnerability] Line 169 parses public_key_type using unwrap() - can malformed type attributes cause panic during macro expansion, creating a compilation DoS vector? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_verifyingkey()] [Triple type association] Lines 186-191 associate VerifyingKey with both SigningKeyMaterial and SignatureMaterial - is there compile-time validation that these three types form a consistent cryptographic triple, or can mismatched combinations bypass signature verification? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_verifyingkey()] [Sealed trait bypass] Line 192 implements the Sealed trait - is this sufficient to prevent external crates from implementing VerifyingKey on arbitrary types, or can attackers still create malicious verifying key implementations? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_verifyingkey()] [Unused variants parameter] Line 182 receives _variants but doesn't use it - should there be validation that the verifying key enum structure matches the associated signing key and signature enums to prevent structural mismatches? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Signature generation vulnerability] The sign() implementation on lines 222-226 generates signatures through match arms without validating message format - can malicious messages exploit encoding ambiguities to produce valid signatures for different interpreted content? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Test-only arbitrary signing] Lines 228-233 implement sign_arbitrary_message() behind a cfg(test) guard - if this guard is accidentally removed or bypassed, can attackers sign arbitrary messages without proper hashing, enabling signature malleability attacks? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Non-exhaustive match risk] Lines 210-215 generate match arms for signing - if enum variants are added without updating all dependent types, can missing match arms cause panics during transaction signing, halting validator operations? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Variant mismatch exploit] Line 211 matches signing key variant to signature variant by name - if variant names match but contain different cryptographic algorithms, can this enable cross-algorithm signature generation breaking cryptographic assumptions? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Generic constraint bypass] Line 222 requires T: CryptoHash + Serialize - can types that implement these traits but aren't proper cryptographic messages bypass domain separation, enabling signature reuse across different message types? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signingkey()] [Sealed trait implementation] Line 235 implements Sealed for SigningKey - is there validation that only legitimate signing key types can implement this trait, or can macro manipulation enable unauthorized signing capabilities? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Cross-variant verification bypass] Lines 255-260 and 266-271 match signature and public key variants - if variant pairs don't match, line 282-285 returns an error, but can this error handling be bypassed by crafting enum variants with identical names but different underlying crypto schemes? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Wildcard match vulnerability] Lines 282-286 and 292-296 have a wildcard catch-all that bails with provided variants - does this error message leak sensitive information about signature and key structure that could aid cryptographic attacks? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Verification bypass through variant naming] The pattern matching on lines 256, 267, 280, and 290 relies on variant name equality - can attackers create malicious enums where variant names match but underlying types differ, bypassing cryptographic verification checks? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [verify() vs verify_arbitrary_msg() inconsistency] Lines 266-271 implement structured message verification while lines 255-260 implement arbitrary bytes verification - are both code paths equally secure, or could attackers exploit differences to bypass domain separation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Serialization in verification path] Lines 299-303 call to_bytes() during verification - can inconsistent serialization between signing and verification cause valid signatures to be rejected or invalid signatures to be accepted? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Error handling in verify()] Lines 279-287 implement verify() with generic error handling - can attackers exploit specific error conditions to gain timing information about signature validity, enabling cryptographic oracle attacks? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Message type constraint] Line 279 requires T: CryptoHash + Serialize - can types satisfying these traits but lacking proper domain separation enable signature replay across different contexts, such as using a transaction signature to authorize a block? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Function: impl_enum_signature()] [Public key material mismatch] Lines 276-277 and 246-247 associate signature verification with specific public and private key types - can type parameter mismatches allow compilation of code that uses wrong key types, enabling trivial signature forgery? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Integration: TryFrom + Signature verification] The TryFrom implementation on lines 46-60 combined with verify() on lines 279-287 - can attackers provide bytes that deserialize to one variant but match verification patterns for a different variant, enabling signature forgery through variant confusion? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Integration: Signing + Serialization] The sign() function on lines 222-226 followed by to_bytes() on lines 299-303 - is the serialization round-trip deterministic, or can different byte representations of the same signature cause verification failures in consensus? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Integration: PublicKey derivation + Verification] The From<&PrivateKey> implementation on lines 147-154 combined with verify() on lines 279-287 - can derived public keys have different serialization than public keys parsed from bytes, causing verification mismatches? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Code generation: Attribute parsing chain] The get_type_from_attrs() function on lines 103-131 is called by multiple impl functions - can inconsistent attribute names or missing attributes cause mismatched type associations between signing keys, verifying keys, and signatures? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Code generation: Panic propagation] Multiple functions use expect() and unwrap() (lines 19, 37, 43, 55, 138, 169, 184, 185) - can any of these panics be triggered by attacker-controlled input to derive macros, causing validator node crashes during compilation or runtime? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Cryptographic: Algorithm downgrade] The enum-based design allows multiple cryptographic algorithms in one type - can attackers exploit the TryFrom chain (lines 46-60) to force deserialization to a weaker algorithm variant, enabling practical breaks? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs] [Cryptographic: Key type substitution] The pattern matching in verify() (lines 280-286) prevents mismatched variants, but can compile-time type confusion allow Ed25519 signatures to be verified against Secp256k1 keys if enum variants are crafted maliciously? (Critical)"
]