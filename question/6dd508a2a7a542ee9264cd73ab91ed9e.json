[
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(Address)] [Input validation] Can an attacker provide malformed address strings in API requests that bypass the hex format validation specified on line 37, potentially causing parser crashes or allowing invalid addresses to enter the system? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(Address)] [Type confusion] Does the Address type properly validate that the provided string represents a valid 32-byte account address as described on lines 38-45, or can attackers supply addresses of incorrect length that get truncated or padded incorrectly? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(Address)] [Address validation bypass] Can an attacker exploit the difference between SHORT form (0x1) and LONG form (64 hex chars) address representations mentioned on lines 40-44 to cause address confusion or collision attacks in the API? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(Address)] [Example exploitation] Is the example address '0x88fbd33f54e1126269769780feb24480428179f552e2313fbe571b72e62a1ca1' on line 35 properly validated, or could attackers use this exact address in attacks knowing it appears in documentation? (Low)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(AssetType)] [Type confusion] Can an attacker exploit the dual format of AssetType (either hex address OR struct tag format on lines 58-62) to cause parser confusion where the API misinterprets a struct tag as an address or vice versa? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(AssetType)] [Format injection] Can malicious actors craft AssetType strings that contain both valid hex address prefix and struct tag suffixes to bypass validation checks, potentially accessing unauthorized asset types? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(AssetType)] [Module name manipulation] In the struct tag format '{address}::{module name}::{struct name}' on line 62, can attackers inject malicious module or struct names with special characters to cause parsing errors or access unintended resources? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(EntryFunctionId)] [Function name injection] Does the EntryFunctionId format '{address}::{module name}::{function name}' on line 77 properly sanitize function names, or can attackers inject special characters like null bytes, newlines, or control characters to manipulate execution? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(EntryFunctionId)] [Case sensitivity bypass] The description on lines 78-79 states both module and function names are case-sensitive - can attackers exploit case variations to call unintended functions or bypass access controls? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(EntryFunctionId)] [Module address spoofing] Can malicious users provide EntryFunctionIds with attacker-controlled addresses that mimic system module addresses (like 0x1) to trick the API into treating malicious code as system functions? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HashValue)] [Hash collision] The HashValue type on line 84 has no validation metadata - can attackers provide colliding hash values or hashes of incorrect length to cause state inconsistencies or bypass integrity checks? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HashValue)] [Missing validation] Does the HashValue implementation properly validate hash length and format, or can attackers supply non-hex strings or hashes of arbitrary length that corrupt internal state? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HexEncodedBytes)] [Length limit bypass] The description on lines 95-99 states HexEncodedBytes will not trim zeros unlike Address - can attackers exploit this to send extremely large hex strings that cause memory exhaustion or buffer overflows? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HexEncodedBytes)] [Prefix manipulation] Can attackers send HexEncodedBytes without the '0x' prefix or with malformed prefixes to bypass validation that expects the prefix, potentially causing parsing inconsistencies across the system? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HexEncodedBytes)] [Odd-length hex] Does HexEncodedBytes properly handle odd-length hex strings (e.g., '0x123'), or can this cause nibble misalignment, data corruption, or crashes in downstream hex decoders? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(HexEncodedBytes)] [Non-hex injection] Can attackers inject non-hexadecimal characters (like 'g', 'z', special chars) into HexEncodedBytes strings to cause parser exceptions that leak system information or crash the API? (Low)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveModuleId)] [Module path injection] In the format '{address}::{module name}' on line 115, can attackers inject path traversal sequences (../, ./) or absolute paths in module names to access unintended modules or bypass module isolation? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveModuleId)] [Address validation gap] The description on line 117 requires hex-encoded 32 byte address with 0x prefix - is this strictly enforced, or can attackers supply shorter/longer addresses that get zero-padded incorrectly? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveModuleId)] [Module name spoofing] Can attackers create module IDs using addresses they control but with names matching system modules (like 'aptos_coin') to trick users or dApps into interacting with malicious contracts? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructTag)] [Regex bypass] The pattern '^0x[0-9a-zA-Z:_<>]+$' on line 131 allows angle brackets and colons - can attackers craft deeply nested generic types like 'vector<vector<vector<...>>>' to cause exponential parsing time or stack overflows? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructTag)] [Generic type injection] Can malicious actors inject arbitrary Move types as generic parameters (line 138) to instantiate unintended struct variants that bypass type safety checks or access restricted resources? (High)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructTag)] [URL encoding attack] The note on lines 146-147 mentions URL encoding is required - can attackers send both URL-encoded and non-encoded versions to cause parser confusion or cache poisoning attacks? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructTag)] [Whitespace manipulation] Line 145 states empty chars should be ignored when comparing - can attackers inject various Unicode whitespace characters to create struct tags that appear identical but hash differently, causing cache/storage issues? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructTag)] [Separator confusion] With both '::' and ',' as separators (lines 137-138), can attackers craft ambiguous struct tags where the parser incorrectly splits module names from generic parameters? (Medium)",
  "[File: aptos-core/api/types/src/derives.rs] [Macro: impl_poem_type!(MoveStructValue)] [JSON injection] The MoveStructValue is defined as 'object' type on line 155 - can attackers inject malicious JSON objects with recursive references or prototype pollution attacks to compromise the API server? (High)"
]