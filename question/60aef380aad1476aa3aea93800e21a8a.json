[
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Visibility bypass] Can an attacker deploy a module with a public `init_module` function that bypasses the private visibility check by exploiting race conditions in module loading, allowing unauthorized initialization code execution? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Parameter validation bypass] Does the parameter count check at line 157 properly handle type parameter substitutions, or can an attacker craft a generic function signature that appears to have 1 parameter but actually accepts multiple runtime arguments? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Type confusion] Can an attacker bypass the signer type check at lines 160-170 by using a custom struct named 'Signer' or type alias that matches the pattern but isn't the primitive Signer type, allowing unauthorized module initialization? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Return value bypass] Does the return count check at line 173 properly validate phantom return types or generic returns that could be instantiated as unit types, potentially allowing state-modifying returns to leak information? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Type parameter bypass] Can the type parameter check at line 180 be circumvented using zero-sized type parameters or phantom types that don't contribute to the function signature but enable generic code injection? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Naming collision] What prevents an attacker from defining multiple functions with bytecode-level name mangling that all resolve to 'init_module' at different compilation stages, potentially executing multiple initialization routines? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Reference type bypass] The check at line 163 allows both `signer` and `&signer` - can an attacker exploit the reference version to retain a signer capability beyond module initialization by storing the reference in global state? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_init_module()] [Error handling bypass] If module compilation produces errors during init_module validation, are those errors properly propagated to prevent module deployment, or can partial deployment occur? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_entry_functions()] [Legacy attribute abuse] Can an attacker mark malicious entry functions with the LEGACY_ENTRY_FUN_ATTRIBUTE at line 200 to bypass all modern security checks including transaction argument validation and return value restrictions? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_entry_functions()] [Attribute injection] Is the has_attribute check at line 200 vulnerable to attribute name collisions or Unicode homoglyph attacks where 'legacy_entry_fun' could be spoofed with visually identical characters? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_entry_functions()] [Return value smuggling] Does the return count check at line 207 prevent all forms of output, or can an attacker use mutable reference parameters to modify caller state and effectively return values? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_signer_args()] [Signer ordering bypass] The warning at lines 229-232 only issues a warning (not error) for signer ordering violations - can attackers exploit this to create confusing entry point signatures that trick transaction senders? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_signer_args()] [Reference skipping vulnerability] At line 227, skip_reference() skips both immutable and mutable references - can an attacker pass `&mut signer` parameters in legacy entry functions to violate signer immutability assumptions? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_transaction_input_type()] [Recursive vector exploitation] When validating Vector types at line 253, does the recursive check have depth limits, or can an attacker cause stack overflow with deeply nested vectors like `vector<vector<vector<...>>>>`? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_transaction_input_type()] [Type parameter injection] Line 245 allows TypeParameter types without validation - can an attacker craft entry functions with unconstrained generics that accept arbitrary types at runtime, bypassing serialization security? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_transaction_input_type()] [Primitive type abuse] Does the primitive type allowance at line 245 include all primitives safely, or can attackers exploit less common primitives like U256 to cause integer overflow in transaction processing? (Medium)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: is_allowed_input_struct()] [Struct whitelist bypass] The hardcoded struct whitelist at lines 276-283 uses string matching - can an attacker deploy a malicious struct at address 0x1 with the same name to pass validation? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: is_allowed_input_struct()] [Address spoofing] Does the address comparison in get_full_name_with_address properly validate address format, or can hex encoding variations like '0x01' vs '0x1' bypass the whitelist check? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: is_allowed_input_struct()] [Type parameter smuggling] The allowed structs like Object<T> and Option<T> have type parameters - are these parameters validated recursively, or can attackers nest disallowed types inside allowed containers? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Attribute manipulation] Can an attacker craft a struct with multiple RESOURCE_GROUP_MEMBER attributes at line 297 to associate one resource with multiple groups, violating resource group isolation? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Key ability bypass] The check at line 306 requires Key ability - can an attacker remove this ability after validation but before deployment through multi-stage compilation attacks? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Parameter count confusion] At line 312, exactly 1 parameter is required - can an attacker use variadic attribute syntax or special encoding to pass additional hidden parameters? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Module resolution exploit] When finding the module at line 346, does the code check for module shadowing where a malicious module with the same name exists in multiple addresses? (High)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Scope mismatch exploitation] The scope equality check at line 363 uses are_equal_envs - can attackers exploit environment comparison bugs to associate resources with incompatible group scopes? (Critical)",
  "[File: aptos-core/aptos-move/framework/src/extended_checks.rs] [Function: check_and_record_resource_group_members()] [Container validation bypass] Does the code at line 354-360 properly validate that the container struct exists before checking its resource_group attribute, or can race conditions allow references to non-existent containers? (High)"
]