[
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Struct Field Types] Can field types in StructFieldInformation reference the containing struct, creating circular type dependencies? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_function_handles()] [Signature Complexity] Can functions with maximum parameters where each parameter is a maximum-complexity type cause call-stack overflow during invocation? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_function_handles()] [Return Value Size] Can functions with maximum return values each of large size cause excessive stack allocation in caller frames? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_function_handles()] [Generic Function Instantiation] Can generic functions with maximum type parameters be instantiated with maximum-complexity types to create exponential code size? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_struct_handles()] [Type Parameter Bound] Can structs with maximum type parameters where each parameter has maximum bounds create exponential constraint solving complexity? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_function_handles()] [Phantom Type Parameters] Are phantom type parameters counted towards limits, and can they be exploited to bypass size checks while still affecting compilation? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_node()] [Type Parameter Substitution] Can type parameter substitution during monomorphization cause types that passed verification to exceed limits in concrete form? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Constant Type Complexity] Can constants with maximum-complexity types cause excessive memory allocation when the constant pool is loaded? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Constant Count] Does verify_type_nodes limit the number of constants, or can attackers add unlimited constants each of maximum complexity? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Constant Value Size] Does the constant pool check verify both type complexity AND value size, or can large constant values bypass verification? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Signature Reuse] Can signature pool entries be shared across multiple function handles to bypass per-function limits? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_nodes()] [Signature Count] Does the code limit the total number of signatures, or can unlimited signatures each of maximum complexity be added? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_function_handles()] [Signature Indirection] Can function handles reference signatures with indirection that hides actual complexity from direct parameter counting? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_node()] [Weight Tuning] Are STRUCT_SIZE_WEIGHT and PARAM_SIZE_WEIGHT values (both 4) properly tuned based on actual expansion behavior, or can they be too low/high? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_node()] [Weight Inconsistency] Why do Struct and StructInstantiation have the same weight despite instantiation requiring type substitution? (Medium)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_node()] [Function Weight] Why does Function type only add weight 1 despite containing parameter and return type vectors? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Function: verify_type_node()] [Additive Weights] Can the additive weight model underestimate multiplicative complexity interactions between nested types? (High)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Cross-Function: Limit Fragmentation] Can an attacker fragment complexity across multiple modules that individually pass limits but collectively exceed system capacity? (Critical)",
  "[File: third_party/move/move-bytecode-verifier/src/limits.rs] [Cross-Function: Limit Composition] Can limits be bypassed by composing multiple limit-tested features (max functions × max params × max types)? (Critical)"
]