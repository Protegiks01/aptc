[
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_set_bit()] [Integer Truncation] At line 598, bucket_pos = index - (bucket * 8). If index is near usize::MAX and bucket is large, can this subtraction underflow or produce wrong results? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_set_bit()] [Concurrent Modification] If two threads call bitmap_set_bit() on the same bitmap simultaneously, can the OR operation at line 599 lose updates or create race conditions in signature generation? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_set_bit()] [Idempotency] Calling bitmap_set_bit() multiple times with the same index uses OR operation, so it's idempotent. Can an attacker exploit this to create signatures where the bitmap doesn't match actual signature count? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_get_bit()] [Index Bounds] At line 604, bucket = index / 8. If index >= 32, this could index out of bounds when accessing input[bucket] at line 607. Is there guaranteed validation that index < 32? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_get_bit()] [Bit Mask Error] At line 607, the mask '128 >> bucket_pos as u8' is used. If bucket_pos >= 8, the shift produces 0, and the check '!= 0' will always be false. Can this cause missed bit detection? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_get_bit()] [Signed/Unsigned Confusion] The return type is bool, but the bitwise AND at line 607 operates on u8. Are there any edge cases where signed/unsigned conversion could affect the result? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_count_ones()] [Sum Overflow] At line 612, the sum of count_ones() across 4 bytes is calculated. Since each byte can have at most 8 ones, the maximum is 32. Can this ever overflow u32? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_count_ones()] [Iterator Behavior] If the iterator over input at line 612 is somehow modified or returns unexpected values, could this produce incorrect bit counts used in verification? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_last_set_bit()] [None Case] At line 616, if no bits are set, the function returns None. Is this properly handled in verify_arbitrary_msg() at line 515, or can it cause verification bypass? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_last_set_bit()] [trailing_zeros Overflow] At line 622, byte.trailing_zeros() is called. If byte is 0, trailing_zeros returns 8. Can this cause the subtraction '- byte.trailing_zeros() as usize - 1' to underflow? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_last_set_bit()] [Index Calculation] At line 622, the calculation '8 * (BITMAP_NUM_OF_BYTES - i) - byte.trailing_zeros() as usize - 1' determines the last bit index. If i=0 and byte=0b1000_0000, does this correctly return 24? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_last_set_bit()] [u8 Cast Overflow] The result is cast to u8 at line 622. If the calculated value exceeds 255, can this cause truncation and return an incorrect bit position? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: bitmap_last_set_bit()] [Reverse Iterator] At line 618, .rev() reverses the iterator. If the bitmap is [0x80, 0x00, 0x00, 0x00], should this return Some(0) or Some(7)? Is bit numbering correct? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: to_bytes()] [Threshold Placement] At line 569, threshold is pushed at the end. If an attacker modifies bytes after serialization but before verification, can they change the threshold without detection? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: to_bytes()] [flat_map Collection] At lines 565-568, flat_map collects all key bytes. If one key's to_bytes() panics or returns unexpected length, can this corrupt the entire serialization? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: to_bytes()] [Empty Keys Vector] If keys is empty, bytes.push(threshold) at line 569 will create a single-byte vector. Is this valid serialization that can be deserialized correctly? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: MultiEd25519Signature::to_bytes()] [Bitmap Concatenation] At lines 409-414, signatures are serialized, then bitmap is appended. Can an attacker manipulate the boundary between signatures and bitmap to cause deserialization confusion? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: MultiEd25519Signature::to_bytes()] [Empty Signatures] If self.signatures is empty, only bitmap bytes [0,0,0,0] are returned. Can this be deserialized back correctly, and does it pass validation? (High)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: MultiEd25519Signature::to_bytes()] [flat_map Panic] At line 411, if any sig.to_bytes() panics, the entire serialization fails. Can this be exploited to cause denial of service? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<&Ed25519PrivateKey>] [Key Cloning] At line 134, ed_private_key.to_bytes() is called, then try_from() creates a new key. Can this cloning operation leak private key material or create vulnerabilities? (Medium)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<&Ed25519PrivateKey>] [Unwrap Panic] At line 134, unwrap() is called on try_from(). If the key bytes are invalid, this will panic. Is this acceptable behavior in production code? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<&Ed25519PrivateKey>] [Threshold Hardcoding] The threshold is hardcoded to 1u8. Can an attacker exploit contexts where a different threshold is expected but this conversion is used? (Low)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<Ed25519PublicKey>] [Validation Skip] At lines 257-261, a single Ed25519PublicKey is converted to MultiEd25519PublicKey. Does this skip the small subgroup validation that try_from() performs? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<Ed25519PublicKey>] [Tag Missing] The From implementation doesn't call add_tag!() like try_from() does at line 312. Can this create public keys without ValidatedPublicKeyTag, bypassing preconditions? (Critical)",
  "[File: aptos-core/third_party/move/move-examples/diem-framework/crates/crypto/src/multi_ed25519.rs] [Function: From<&MultiEd25519PrivateKey>] [Public Key Derivation] At lines 268-272, public keys are derived via map(PrivateKey::public_key). If any private key is invalid, can this produce invalid public keys? (Medium)"
]