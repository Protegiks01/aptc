[
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: unwrap_or_500] [Information Leakage] Lines 84-91 in utils.rs log full error traces with warn! - can an attacker craft requests that trigger database errors containing sensitive information like internal file paths, table schemas, or query plans, enabling targeted attacks on storage infrastructure? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: handle_rejection] [Information Disclosure] Lines 95-98 in utils.rs log rejection details - can an attacker send malformed requests to extract information about expected parameter types, version ranges, or internal validation logic through error messages, facilitating reconnaissance for more targeted attacks? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [Error-Based Timing Attack] Lines 37-46 return 500 on errors - can an attacker perform timing analysis on error responses to determine whether specific HashValue keys exist in state, enabling database fingerprinting or targeted account discovery? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: all endpoints] [Stack Trace Leakage] Lines 33, 45, 68, 88, 122 use unwrap_or_500 which may expose stack traces - can an attacker trigger panics in underlying BackupHandler methods to leak internal function names, revealing attack surface or implementation details? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Metrics Information Leakage] Lines 140-146 log endpoint access with custom logging - can an attacker analyze latency patterns in LATENCY_HISTOGRAM to infer database size, indexing status, or identify moments of high load suitable for timing attacks? (Low)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: get_routes()] [Clone Safety] Lines 30, 37, 49, 60, 72, 83, 92, 103, 114 clone BackupHandler - can concurrent clones access shared state in non-thread-safe ways, causing data races in underlying database connections that corrupt reads or crash the service? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: reply_with_bytes_sender] [Race Condition] Lines 47-66 in utils.rs spawn_blocking with sender - can the spawned task panic after sender is dropped but before error is propagated, causing the client to hang indefinitely while consuming server resources? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Iterator Safety] Lines 50-57 pass iterator to try_for_each - if get_state_item_iter returns a non-Send iterator but gets moved to spawn_blocking context, can this violate thread safety guarantees and cause undefined behavior or data races? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: BytesSender] [Channel Race] Lines 84-88 in bytes_sender.rs use blocking_send - if multiple threads call send_res concurrently, can mpsc channel ordering guarantees be violated, causing response chunks to arrive out-of-order and corrupting the backup data stream? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: abort_on_error] [Double-Free Risk] Lines 68-81 in utils.rs call either finish() or abort() - can a panic between the match and ignore-result pattern cause both finish and abort to be called, triggering double-send on bytes_tx channel and causing receiver panic? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [Hash Collision] Lines 38-46 accept HashValue as end_key - can an attacker provide a crafted hash value that collides with internal tree structure hashes, causing get_account_state_range_proof to return proofs that verify incorrectly or expose additional state data? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_root_proof endpoint] [Proof Forgery] Lines 84-89 return TransactionInfoWithProof - if the proof generation doesn't properly validate the version exists and is committed, can an attacker request proofs for future versions to receive empty but structurally valid proofs that could be abused in verification bypass attacks? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Accumulator Manipulation] Lines 115-123 compute TransactionAccumulatorRangeProof - can an attacker request overlapping ranges from multiple nodes to detect inconsistencies in Merkle tree construction, identifying Byzantine validators or nodes with corrupted state? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [Sparse Merkle Proof Attack] Lines 37-46 generate SparseMerkleRangeProof - can an attacker request proofs with carefully chosen end_keys that force maximum tree depth traversal, exploiting O(height) proof generation complexity to cause computational DoS? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot endpoint] [Invalid Version Access] Lines 50-57 accept Version parameter without validation - can an attacker request version=u64::MAX or version=0 to access uninitialized database state, trigger undefined behavior in storage layer, or read pruned data that should be inaccessible? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Version Consistency] Lines 73-79 accept version parameter independently - can an attacker request chunks from different versions (chunk1 at v100, chunk2 at v200) to construct a malicious snapshot mixing data from incompatible states that breaks invariants during restoration? (Critical)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Version Bounds] Lines 104-110 accept start_version without upper bound validation - can an attacker request transactions starting at version far beyond current committed version to trigger buffer over-reads or access uncommitted/speculative transaction data? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [Epoch Validation] Lines 93-100 accept arbitrary epoch ranges - can an attacker request start_epoch=1000 when only 100 epochs exist to force iteration through non-existent epochs, potentially exposing uninitialized memory or causing panics that crash the service? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_root_proof endpoint] [Future Version Attack] Lines 84-89 accept version parameter - can an attacker request proof for version=current+1000 to receive proof for uncommitted state, enabling prediction of future state roots and preparation of preimage attacks against upcoming blocks? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transaction_range_proof endpoint] [Version Ordering] Lines 115-123 accept first_version and last_version - can an attacker intentionally reverse these (first_version=100, last_version=50) to bypass the ensure! check in BackupHandler and trigger integer underflow in num_transactions calculation? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_range_proof endpoint] [Path Traversal] Lines 38 parse HashValue from URL path - can an attacker provide malicious path segments like '../../../' embedded in HashValue encoding to escape path validation and access arbitrary storage locations? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: state_snapshot_chunk endpoint] [Negative Index] Lines 73 accept start_idx as usize - on platforms where usize maps to isize, can negative values cause start_idx to wrap to large positive values near usize::MAX, triggering out-of-bounds access or memory corruption? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: all endpoints] [Type Confusion] Lines 38, 50, 61, 73, 84, 93, 104, 115 use warp::path! macro for parsing - if the macro fails to properly validate type boundaries, can an attacker provide Version=18446744073709551615 that overflows downstream signed integer operations? (Medium)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: transactions endpoint] [Size Limit Bypass] Line 104 accepts num_transactions as usize - can an attacker exploit the lack of maximum size validation to request num_transactions=usize::MAX, bypassing any iterator limits and causing unbounded memory allocation? (High)",
  "[File: storage/backup/backup-service/src/handlers/mod.rs] [Function: epoch_ending_ledger_infos endpoint] [Epoch Range Abuse] Lines 93 accept u64 epochs - can an attacker provide start_epoch=u64::MAX-1 and end_epoch=u64::MAX to trigger wraparound in epoch iteration logic, causing access to epoch 0 or corrupting epoch metadata? (Medium)"
]