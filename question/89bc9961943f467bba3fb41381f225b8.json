[
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_function_body_bytecode()] [Bytecode validation gap] Lines 1602-1637 compile bytecode function body - is there comprehensive validation that bytecode mode instructions maintain same safety guarantees as high-level IR? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_script()] [Script privilege escalation] Lines 322-398 compile transaction scripts - can scripts access module-private functions or resources by manipulating handles, achieving privilege escalation? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Self-import confusion] Lines 401-499 handle self-imports - can module import itself with different name creating aliasing that confuses access control, allowing private functions to be called externally? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_imports()] [Import shadowing] Lines 602-607 declare imports - can malicious imports shadow legitimate modules, causing calls to go to attacker-controlled code instead of trusted libraries? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_friends()] [Friend privilege abuse] Lines 591-600 compile friend declarations - can modules declare themselves as friends of others without mutual agreement, gaining unauthorized access to friend-only functions? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_explicit_dependency_declarations()] [Dependency injection] Lines 504-589 compile explicit dependencies - can attacker inject fake dependencies that override real ones, redirecting calls to malicious implementations? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Struct handle preemption] Lines 429-438 pre-declare all struct handles - can attacker register struct handles before legitimate code, causing name collisions that break type system? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_module()] [Function handle collision] Lines 447-450 declare function handles - can duplicate function names in dependencies cause handle collisions that route calls to wrong implementations? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Constant: TABLE_MAX_SIZE] [Table overflow] Line 50 defines TABLE_MAX_SIZE as u16::MAX - can pools exceeding this limit cause wraparound, creating aliased handles that confuse different entities? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: get_or_add_item()] [Pool corruption] Lines 51-60 add items to pools with size checks - but is table size validated before casting len() to TableIndex? Can u16 overflow corrupt pool indices? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: Context::new()] [Initialization bypass] Lines 277-312 initialize compilation context - can partially initialized contexts be used if construction fails midway, causing undefined behavior in subsequent compilation? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: add_compiled_dependency()] [Duplicate dependency] Lines 323-335 add dependencies - check for duplicates returns error, but can dependencies with same ModuleIdent but different addresses create aliasing attacks? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: materialize_pools()] [Pool materialization] Lines 337-377 materialize all pools - can pools with gaps (None values) cause assertion failures or produce invalid bytecode if materialization logic has bugs? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: build_index_remapping()] [Remapping confusion] Lines 379-388 build label remapping - can incorrect remapping cause branches to wrong offsets, creating control flow that bypasses security checks? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: identifier_index()] [Identifier collision] Lines 494-500 add identifiers - can malicious identifiers with same string representation but different encodings create collisions that break name resolution? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Struct: CompiledDependency] [Lifetime issues] Lines 184-205 manage borrowed vs stored dependencies - can lifetime confusion cause use-after-free when dependency modules are dropped while still referenced? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/context.rs] [Function: take_dependencies()/restore_dependencies()] [Reentrancy] Lines 314-321 temporarily remove dependencies - can reentrancy during this window cause dependencies to be lost or duplicated, corrupting compilation state? (High)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: record_src_loc] [Source map injection] Lines 35-87 record source locations in source map - can attacker manipulate source locations to hide malicious code in debugger or point to wrong source for auditing? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: make_push_instr] [Bytecode offset manipulation] Lines 89-103 push instructions with location tracking - can macro be tricked into recording wrong code offsets, breaking debugging and gas accounting? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: make_record_nop_label] [NOP label confusion] Lines 105-118 record NOP labels - can NOP labels be used to hide dead code or create phantom code paths that confuse analysis tools? (Low)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Macro: get_or_add_item_macro] [Macro hygiene] Line 33-48 (context.rs) - does macro properly hygiene variable names? Can variable capture cause wrong items to be added to wrong pools? (Medium)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type() - Struct case] [Generic struct bypass] Lines 689-698 compile struct types with generics - can attacker instantiate generic structs with type parameters that violate struct's declared abilities, breaking ability constraints? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: compile_type() - TypeParameter case] [Unbound type parameter] Lines 699-706 compile type parameters - can unbound type parameters be used in contexts expecting concrete types, causing type system to accept invalid generic instantiations? (Critical)",
  "[File: third_party/move/move-ir-compiler/move-ir-to-bytecode/src/compiler.rs] [Function: function_signature()] [Generic function abuse] Lines 709-730 compile function signatures - can function type parameters shadow struct type parameters, causing generic resolution to use wrong types? (High)",
  "[File:\n\n### Citations\n\n**File:** third_party/move/move-ir-compiler/move-ir-to-bytecode/src/lib.rs (L1-11)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nextern crate log;\n\npub mod compiler;\nmod context;\npub mod parser;\n\n// Unit tests for this crate are in the parent"
]