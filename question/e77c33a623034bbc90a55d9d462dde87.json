[
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CancelOfferTranslator::translate_event_v2_to_v1()] [Cancel Non-existent Offer] Can an attacker emit CancelOffer events for offers that never existed, and does the translator verify offer existence before recording cancellation? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CancelOfferTranslator::translate_event_v2_to_v1()] [Cancel After Claim Race] If an offer is claimed and cancelled in rapid succession, can race conditions cause both claim and cancel events to be recorded, confusing indexer state? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: ClaimTranslator::translate_event_v2_to_v1()] [Claim Without Offer] Does the translator verify a matching Offer event exists before recording a Claim event, preventing fake claim events for non-existent offers? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: ClaimTranslator::translate_event_v2_to_v1()] [Double Claim] Can sequence number logic prevent multiple Claim events for the same offer, or can attackers replay claims to extract extra tokens? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionDescriptionMutateTranslator::translate_event_v2_to_v1()] [Description Size DoS] Can extremely long old_description or new_description strings cause OOM during BCS serialization or indexer storage, enabling DoS attacks? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionDescriptionMutateTranslator::translate_event_v2_to_v1()] [TokenEventStoreV1 Missing] When TokenEventStoreV1 resource is not found, does this correctly handle collections created with V2 APIs that don't initialize V1 event stores? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionDescriptionMutateTranslator::translate_event_v2_to_v1()] [Creator Address Mismatch] Can an attacker provide a creator_addr that differs from the actual collection creator, creating misleading mutation events? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionUriMutateTranslator::translate_event_v2_to_v1()] [URI Scheme Validation] Are old_uri and new_uri validated to contain only safe URI schemes (ipfs://, https://), or can attackers inject javascript: or data: URIs? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionUriMutateTranslator::translate_event_v2_to_v1()] [URI Length Limit] Can unbounded URI lengths cause buffer overflows or storage exhaustion in indexers processing CollectionUriMutateEvent? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionMaximumMutateTranslator::translate_event_v2_to_v1()] [Maximum Decrease Attack] Can an attacker decrease collection maximum below the current supply, and does the translator validate new_maximum >= current_supply? (Critical)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: CollectionMaximumMutateTranslator::translate_event_v2_to_v1()] [Maximum Zero] Can setting new_maximum to 0 lock the collection from minting, and is this state transition validated? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: UriMutationTranslator::translate_event_v2_to_v1()] [Token URI vs Collection URI] Can an attacker confuse token URIs with collection URIs by manipulating collection() and token() fields to point to the same resource? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: UriMutationTranslator::translate_event_v2_to_v1()] [URI Mutation Replay] If the same token's URI is mutated multiple times, does sequence number ordering guarantee indexers see mutations in the correct chronological order? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: DefaultPropertyMutateTranslator::translate_event_v2_to_v1()] [Property Key Duplication] Can keys() contain duplicate property names, causing confusion about which old_value maps to which key in the mutation event? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: DefaultPropertyMutateTranslator::translate_event_v2_to_v1()] [Vector Length Mismatch] If keys(), old_values(), and new_values() have different lengths, can array indexing cause panics or incorrect property mutations? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: DescriptionMutateTranslator::translate_event_v2_to_v1()] [Description Encoding] Can description strings contain null bytes or invalid UTF-8 that breaks BCS serialization or indexer text processing? (Medium)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: DescriptionMutateTranslator::translate_event_v2_to_v1()] [Token Identifier Collision] Can multiple tokens with identical (creator, collection, token) tuples exist, causing description mutations to be attributed to the wrong token? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: RoyaltyMutateTranslator::translate_event_v2_to_v1()] [Royalty Consistency] Does the translator enforce that old royalty values match the actual current royalty in the token, or can attackers fake the old values to hide real royalty changes? (High)",
  "[File: aptos-core/storage/indexer/src/event_v2_translator.rs] [Function: RoyaltyMutateTranslator::translate_event_v2_to_v1()] [Payee Address Validation] Can new_royalty_payee_addr be set to a black hole address (0x0), burning all future royalties, and is this validated?\n\n### Citations\n\n**File:** storage/indexer/src/event_v2_translator.rs (L68-236)\n```rust\npub struct EventV2TranslationEngine {\n    pub main_db_reader: Arc<dyn DbReader>,\n    pub internal_indexer_db: Arc<DB>,\n    // Map from event type to translator\n    pub translators: HashMap<TypeTag, Box<dyn EventV2Translator + Send + Sync>>,\n    event_sequence_number_cache: DashMap<EventKey, u64>,\n}\n\nimpl EventV2TranslationEngine {\n    pub fn new(main_db_reader: Arc<dyn DbReader>, internal_indexer_db: Arc<DB>) -> Self {\n        let translators: HashMap<TypeTag, Box<dyn EventV2Translator + Send + Sync>> = [\n            (\n                COIN_DEPOSIT_TYPE.clone(),\n                Box::new(CoinDepositTranslator) as Box<dyn EventV2Translator + Send + Sync>,\n            ),\n            (COIN_WITHDRAW_TYPE.clone(), Box::new(CoinWithdrawTranslator)),\n            (COIN_REGISTER_TYPE.clone(), Box::new(CoinRegisterTranslator)),\n            (KEY_ROTATION_TYPE.clone(), Box::new(KeyRotationTranslator)),\n            (TRANSFER_TYPE.clone(), Box::new(TransferTranslator)),\n            (\n                TOKEN_MUTATION_TYPE.clone(),\n                Box::new(TokenMutationTranslator),\n            ),\n            (\n                COLLECTION_MUTATION_TYPE.clone(),\n                Box::new(CollectionMutationTranslator),\n            ),\n            (MINT_TYPE.clone(), Box::new(MintTranslator)),\n            (BURN_TYPE.clone(), Box::new(BurnTranslator)),\n            (TOKEN_DEPOSIT_TYPE.clone(), Box::new(TokenDepositTranslator)),\n            (\n                TOKEN_WITHDRAW_TYPE.clone(),\n                Box::new(TokenWithdrawTranslator),\n            ),\n            (BURN_TOKEN_TYPE.clone(), Box::new(BurnTokenTranslator)),\n            (\n                MUTATE_PROPERTY_MAP_TYPE.clone(),\n                Box::new(MutatePropertyMapTranslator),\n            ),\n            (MINT_TOKEN_TYPE.clone(), Box::new(MintTokenTranslator)),\n            (\n                CREATE_COLLECTION_TYPE.clone(),\n                Box::new(CreateCollectionTranslator),\n            ),\n            (\n                TOKEN_DATA_CREATION_TYPE.clone(),\n                Box::new(TokenDataCreationTranslator),\n            ),\n            (OFFER_TYPE.clone(), Box::new(OfferTranslator)),\n            (CANCEL_OFFER_TYPE.clone(), Box::new(CancelOfferTranslator)),\n            (CLAIM_TYPE.clone(), Box::new(ClaimTranslator)),\n            (\n                COLLECTION_DESCRIPTION_MUTATE_TYPE.clone(),\n                Box::new(CollectionDescriptionMutateTranslator),\n            ),\n            (\n                COLLECTION_URI_MUTATE_TYPE.clone(),\n                Box::new(CollectionUriMutateTranslator),\n            ),\n            (\n                COLLECTION_MAXIMUM_MUTATE_TYPE.clone(),\n                Box::new(CollectionMaximumMutateTranslator),\n            ),\n            (URI_MUTATION_TYPE.clone(), Box::new(UriMutationTranslator)),\n            (\n                DEFAULT_PROPERTY_MUTATE_TYPE.clone(),\n                Box::new(DefaultPropertyMutateTranslator),\n            ),\n            (\n                DESCRIPTION_MUTATE_TYPE.clone(),\n                Box::new(DescriptionMutateTranslator),\n            ),\n            (\n                ROYALTY_MUTATE_TYPE.clone(),\n                Box::new(RoyaltyMutateTranslator),\n            ),\n            (\n                MAXIMUM_MUTATE_TYPE.clone(),\n                Box::new(MaximumMutateTranslator),\n            ),\n            (\n                OPT_IN_TRANSFER_TYPE.clone(),\n                Box::new(OptInTransferTranslator),\n            ),\n        ]\n        .into_iter()\n        .collect();\n        Self {\n            main_db_reader,\n            internal_indexer_db,\n            translators,\n            event_sequence_number_cache: DashMap::new(),\n        }\n    }\n\n    // When the node starts with a non-empty EventSequenceNumberSchema table, the in-memory cache\n    // `event_sequence_number_cache` is empty. In the future, we decide to backup and restore the\n    // event sequence number data to support fast sync, we may need to load the cache from the DB\n    // when the node starts using this function `load_cache_from_db`.\n    pub fn load_cache_from_db(&self) -> Result<()> {\n        let mut iter = self\n            .internal_indexer_db\n            .iter::<EventSequenceNumberSchema>()?;\n        iter.seek_to_first();\n        while let Some((event_key, sequence_number)) = iter.next().transpose()? {\n            self.event_sequence_number_cache\n                .insert(event_key, sequence_number);\n        }\n        Ok(())\n    }\n\n    pub fn cache_sequence_number(&self, event_key: &EventKey, sequence_number: u64) {\n        self.event_sequence_number_cache\n            .insert(*event_key, sequence_number);\n    }\n\n    pub fn get_cached_sequence_number(&self, event_key: &EventKey) -> Option<u64> {\n        self.event_sequence_number_cache\n            .get(event_key)\n            .map(|seq| *seq)\n    }\n\n    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {\n        if let Some(seq) = self.get_cached_sequence_number(event_key) {\n            Ok(seq + 1)\n        } else {\n            let seq = self\n                .internal_indexer_db\n                .get::<EventSequenceNumberSchema>(event_key)?\n                .map_or(default, |seq| seq + 1);\n            Ok(seq)\n        }\n    }\n\n    pub fn get_state_value_bytes_for_resource(\n        &self,\n        address: &AccountAddress,\n        struct_tag: &StructTag,\n    ) -> Result<Option<Bytes>> {\n        let state_view = self\n            .main_db_reader\n            .latest_state_checkpoint_view()\n            .expect("
]