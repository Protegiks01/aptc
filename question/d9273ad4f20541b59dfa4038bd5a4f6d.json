[
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Integer overflow] Can an attacker cause integer overflow in offsets_by_round HashMap construction if ordered_blocks contains duplicate rounds, potentially corrupting offset mappings and causing blocks to be processed out of order? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::new()] [Panic condition] The assertion 'assert!(!ordered_blocks.ordered_blocks.is_empty())' can be triggered by malicious input - can an attacker craft empty OrderedBlocks to cause validator crashes and consensus disruption? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::offset()] [Panic attack] The expect() call in offset() panics if round is not in offsets_by_round - can Byzantine validators send shares for non-existent rounds to crash honest validators? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Race condition] Is there a race between checking pending_secret_key_rounds.contains() and actually sending the key via secret_shared_key_tx, allowing duplicate key delivery or lost updates? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Channel poisoning] If tx.send(Some(key)) fails silently, does the block remain in pending state forever, causing liveness issues and blocking all subsequent blocks? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::set_secret_shared_key()] [Logic bug] The function removes from pending_secret_key_rounds even if the channel send fails - can this cause blocks to be marked as ready when they haven't actually received keys? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: QueueItem::is_fully_secret_shared()] [State inconsistency] Can pending_secret_key_rounds become empty while blocks still lack actual secret keys due to failed sends, causing premature block release? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: BlockQueue::push_back()] [Duplicate round attack] The assert ensures insert returns None, but can attackers exploit timing to insert QueueItems with duplicate first_round values, bypassing the check? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: BlockQueue::dequeue_ready_prefix()] [Partial dequeue bug] If is_fully_secret_shared() returns false for middle items, does the function correctly stop, or can Byzantine behavior cause gaps in the processed block sequence? (High)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: BlockQueue::dequeue_ready_prefix()] [Resource exhaustion] Can attackers flood the queue with many incomplete items, forcing this function to repeatedly scan without making progress, causing CPU exhaustion? (Medium)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: BlockQueue::item_mut()] [Logic error] The range_mut(0..=round).last() logic finds the last item before or at round - can this return wrong items if rounds are non-contiguous, causing secret keys to be applied to wrong blocks? (Critical)",
  "[File: consensus/src/rand/secret_sharing/block_queue.rs] [Function: BlockQueue::item_mut()] [Boundary condition] Does the filter condition correctly handle edge cases where round equals the first_round of an item, or can off-by-one errors cause keys to be lost? (High)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareMessage::verify()] [Epoch bypass] Does verify() properly check epoch boundaries, or can attackers replay messages from old epochs after validator set changes to cause confusion? (Critical)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareMessage::verify()] [Incomplete validation] RequestShare messages return Ok(()) without verification - can attackers spam arbitrary RequestShare messages to exhaust validator resources? (Medium)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareMessage::verify()] [Cryptographic bypass] Does share.verify() check all necessary cryptographic properties, or can malformed shares with valid signatures pass verification? (Critical)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareMessage::from_network_message()] [Deserialization attack] The bcs::from_bytes() call lacks bounds checking - can attackers send maliciously crafted messages causing memory exhaustion or panics? (High)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareMessage::into_network_message()] [Serialization panic] The expect() on bcs::to_bytes assumes serialization always succeeds - can corrupted internal state cause validator crashes? (Medium)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareNetworkMessage::new()] [Unvalidated epoch] The constructor doesn't validate epoch value - can attackers use extreme epoch values (u64::MAX) to bypass checks elsewhere? (Medium)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Function: SecretShareNetworkMessage::data()] [Data integrity] Is the returned data reference validated before use, or can callers modify the underlying Vec through interior mutability? (Low)",
  "[File: consensus/src/rand/secret_sharing/network_messages.rs] [Struct: SecretShareNetworkMessage] [Memory exhaustion] The data field is unbounded - can attackers send gigabyte-sized messages to exhaust validator memory? (High)",
  "[File: consensus/src/rand/secret_sharing/reliable_broadcast_state.rs] [Function: SecretShareAggregateState::add()] [Author spoofing] The ensure macro checks share.author() == peer, but can network layer spoofing bypass this if peer identity isn't cryptographically verified? (Critical)",
  "[File: consensus/src/rand/secret_sharing/reliable_broadcast_state.rs] [Function: SecretShareAggregateState::add()] [Metadata mismatch] If metadata doesn't match, the function returns error - can Byzantine validators send shares with slightly different metadata to prevent aggregation? (High)",
  "[File: consensus/src/rand/secret_sharing/reliable_broadcast_state.rs] [Function: SecretShareAggregateState::add()] [Duplicate detection] Does add_share() in SecretShareStore properly prevent duplicate shares from the same author inflating total_weight? (Critical)",
  "[File: consensus/src/rand/secret_sharing/reliable_broadcast_state.rs] [Function: SecretShareAggregateState::add()] [Lock contention] The store.lock() call blocks - can Byzantine validators send shares at high rate to cause lock contention and degrade performance? (Medium)",
  "[File: consensus/src/rand/secret_sharing/reliable_broadcast_state.rs] [Function: SecretShareAggregateState::add()] [Aggregation timing] Is the aggregated result (then_some(())) reliable, or can race conditions cause it to return None when threshold is actually met? (High)"
]