[
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Integer overflow] Can an attacker cause integer overflow by pushing more than usize::MAX futures, causing next_incoming_index at line 117 to wrap around to 0, which would break ordering guarantees and lead to backup data corruption when restoring blockchain state? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Integer overflow] When next_outgoing_index is incremented at lines 131 and 140, can it overflow after processing usize::MAX items, causing the index comparison at lines 130 and 139 to fail and return futures out of order, corrupting backup data integrity? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Index wraparound] If next_incoming_index wraps around to 0 after overflow, could newly pushed futures have the same index as already-queued futures in queued_outputs, causing the BinaryHeap at line 70 to violate ordering and deliver backup chunks in incorrect sequence? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Index desynchronization] If next_incoming_index overflows but next_outgoing_index hasn't caught up, could the gap between indices cause a permanent deadlock where no futures match next_outgoing_index, halting backup/restore operations indefinitely? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: new()] [State initialization] Can next_incoming_index and next_outgoing_index at lines 86-87 be initialized to non-zero values through unsafe memory operations, causing immediate ordering violations when the first future is pushed? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Memory exhaustion] Can an attacker who controls backup data timing cause all futures to complete out-of-order, filling the BinaryHeap at line 143 with millions of OrderWrapper objects, exhausting node memory and causing backup operations to fail or crash? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Unbounded growth] Since there's no limit on queued_outputs heap size at line 70, can an attacker delay processing of the next expected future while pushing millions more, causing unbounded heap growth that crashes backup nodes or exhausts disk space during state restoration? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: len()] [Integer arithmetic] Can the addition at line 97 (in_progress_queue.len() + queued_outputs.len()) overflow if both queues are near usize::MAX, causing len() to return incorrect values and breaking size_hint() calculations that dependent systems rely on? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Resource leak] If futures in queued_outputs at line 143 hold file handles, database connections, or memory buffers for backup chunks, and next_outgoing_index never advances due to a missing future, do these resources leak indefinitely causing backup system degradation? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Memory pressure] Can the infinite loop at line 136 repeatedly poll in_progress_queue and accumulate results in queued_outputs without yielding, causing the async executor to stall and preventing other critical backup tasks from making progress? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Ordering bypass] Can race conditions between lines 129-134 (checking queued_outputs) and lines 136-148 (polling new results) cause the same index to be returned twice if peek_mut() is called while poll_next_unpin() returns the same index? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Data corruption] If output.index at line 139 matches next_outgoing_index but the previous check at line 130 also matched, could next_outgoing_index be incremented twice (lines 131, 140), skipping a backup chunk and causing incomplete state restoration? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: Ord implementation for OrderWrapper] [Heap invariant violation] Since BinaryHeap ordering is reversed at line 48 (other.index.cmp(&self.index)), can equal indices cause non-deterministic heap ordering, leading to futures being returned in wrong order during backup operations? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Missing future detection] If a future with index next_outgoing_index is never completed (due to panic or cancellation), does poll_next() at lines 129-148 hang indefinitely, blocking all subsequent backup processing and causing data loss? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Early termination] When in_progress_queue returns None at line 146, does the function immediately return Poll::Ready(None) without checking if queued_outputs still contains futures, potentially dropping backup data that arrived out of order? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Heap consistency] Can concurrent modifications to queued_outputs between peek_mut() at line 129 and PeekMut::pop() at line 132 cause heap corruption if another thread modifies the heap, breaking backup chunk ordering? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Peek-pop race] Between checking next_output.index at line 130 and calling PeekMut::pop(next_output) at line 132, can the heap be modified by another operation, causing the wrong element to be popped and violating backup ordering? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Heap overflow] Since push() at line 143 is called inside a loop without bounds checking, can queued_outputs.push(output) cause heap memory exhaustion if thousands of out-of-order futures complete simultaneously? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: OrderWrapper Ord impl] [Comparison correctness] If two OrderWrapper instances have the same index due to a bug, does the Ord implementation at lines 45-50 violate total ordering requirements, potentially causing BinaryHeap to enter an invalid state? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Heap emptiness check] Does the code properly handle the case where queued_outputs is non-empty but peek_mut() returns None due to internal heap corruption, potentially causing backup data to be silently dropped? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Concurrent polling] Since FuturesOrderedX is Unpin at line 75, can multiple threads simultaneously call poll_next() via Pin::new(&mut stream), causing race conditions between next_outgoing_index increments at lines 131 and 140? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: push()] [Concurrent push] Can push() at line 112 be called concurrently with poll_next(), causing next_incoming_index increment at line 117 to race with reads, potentially assigning duplicate indices to different futures? (Critical)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [TOCTOU vulnerability] Between checking output.index == this.next_outgoing_index at line 139 and incrementing next_outgoing_index at line 140, can another thread modify next_outgoing_index, causing duplicate increments and skipped indices? (High)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: len()] [Inconsistent reads] Can len() at line 96 return inconsistent values if called during push() or poll_next() execution, causing size_hint() at line 151 to provide incorrect bounds to stream consumers? (Medium)",
  "[File: aptos-core/storage/backup/backup-cli/src/utils/stream/futures_ordered_x.rs] [Function: poll_next()] [Reentrancy] If a future's poll() method at line 137 recursively calls poll_next() on the same FuturesOrderedX, can this cause stack overflow or index corruption from nested modifications? (Medium)"
]