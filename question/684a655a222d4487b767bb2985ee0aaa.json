[
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pad_and_pack_bytes_to_scalars_no_len()] [Zero padding] pad_and_pack_bytes_to_scalars_no_len() at line 164 calls zero_pad_bytes() - does zero padding ensure that 'hello' and 'hello\\\\x00\\\\x00' hash differently, or is collision possible? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: zero_pad_bytes()] [Resize operation] At line 253, padded.resize(size, 0x00) is called - can an attacker exploit this to cause memory exhaustion by requesting max_bytes near MAX_NUM_INPUT_BYTES repeatedly? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_bytes_to_one_scalar()] [LE encoding] Line 284 uses from_le_bytes_mod_order() for little-endian encoding - is this consistently applied across the codebase, or could mixed endianness cause verification failures? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pad_and_pack_bytes_to_scalars_with_len()] [Length scalar position] Length is appended as the last scalar at line 108 using .chain([len_scalar]) - could an attacker craft inputs where the length scalar collides with valid data, creating hash collisions? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pad_and_pack_limbs_to_scalars_with_len()] [Limb length encoding] At line 134, len is cast to u64 - can an attacker exploit 32-bit vs 64-bit platforms where usize differs, causing different hashes for the same input on different architectures? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Comment: Line 23-28] [Length bits] The comment states 9 bits can encode up to 496 bytes but this is not exploited - could an attacker who understands the unused capacity create malicious inputs that break assumptions in circuit implementations? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pad_and_hash_bytes_with_len()] [Wrapper function] pad_and_hash_bytes_with_len() at line 225-228 is a thin wrapper - does it add any validation, or could bypassing it allow calling hash_scalars() with malformed scalar arrays? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pad_and_hash_bytes_no_len()] [Unsafe use] The function comment at line 212-215 warns about collision risks - why is this function exposed if it's dangerous? Can an attacker find a code path that calls it with colliding inputs? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Constant: LIMBS_PACKED_PER_SCALAR] [Limb encoding] LIMBS_PACKED_PER_SCALAR is 3 at line 19 - packing 3 u64s (24 bytes) into 31-byte scalars leaves 7 unused bytes. Can attackers exploit this gap to inject data? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_limbs_to_scalars()] [Size check] pack_limbs_to_scalars() checks limbs.len() > MAX_NUM_INPUT_LIMBS at line 67 - but MAX_NUM_INPUT_LIMBS is 48 (16*3). Can an attacker cause overflow with exactly 49 limbs? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_limbs_to_one_scalar()] [Byte flattening] At lines 297-300, limbs are flattened to bytes using flat_map() - does this preserve byte order correctly across all platforms, or could endianness issues cause verification failures? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_limbs_to_one_scalar()] [Modular reduction] Line 301 applies from_le_bytes_mod_order() to flattened limb bytes - can an attacker craft limb combinations that after modular reduction equal simpler inputs, creating collisions? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: zero_pad_limbs()] [Limb padding] zero_pad_limbs() at line 271 pads with 0x00 limbs - is there a risk that valid limb data ending in zeros gets confused with padded data, causing hash collisions? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/mod.rs] [Function: hash_scalars()] [Error propagation] hash_scalars() returns anyhow::Result at line 37 - if the bail! macro at lines 39-43 is triggered, does the error message leak sensitive information about internal state that attackers could exploit? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/mod.rs] [Macro: neptune_hash!()] [Expect panic] Line 28 uses .expect('Too many inputs') - can an attacker trigger this panic to DoS the system by providing vectors that appear valid but exceed internal hasher limits? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_bytes_to_scalars()] [Expect panic] Line 60 uses .expect('chunk converts to scalar') - under what conditions could this expectation fail? Can an attacker craft inputs that violate this assumption? (High)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_limbs_to_scalars()] [Expect panic] Line 77 uses .expect('chunk converts to scalar') for limbs - are there u64 combinations that can't convert to scalars, allowing DoS via panics? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: fr_to_bytes_le()] [Expect panic] Line 310 uses .expect('expected 32-byte public inputs hash') - can Fr values exist that don't convert to exactly 32 bytes, causing system crashes? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/alt_fr.rs] [Conversion: From<ark_bn254::Fr>] [Expect panic] Lines 20 and 22 have nested .expect() calls - if either fails, the system panics. Can an attacker provide malformed Fr values to trigger this? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/alt_fr.rs] [Conversion: From<&str>] [Unwrap panic] Line 34 uses .unwrap() on from_str_vartime() - can an attacker provide malicious strings (e.g., overflow values) that cause unwrap panics and DoS? (Medium)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/mod.rs] [Function: hash_scalars()] [Timing leak] The match statement at lines 46-62 takes different code paths based on input length - does this create timing side-channels where attackers can infer input sizes by measuring execution time? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/mod.rs] [Macro: neptune_hash!()] [State timing] The hasher.reset() call at line 26 and hash_in_mode() at line 30 may have variable timing - can an attacker use timing analysis to extract information about previous hash inputs? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: pack_bytes_to_scalars()] [Cache timing] The chunks() operation at line 59 processes variable-length inputs - does cache timing reveal information about the exact byte length being hashed? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/keyless.rs] [Function: from_le_bytes_mod_order()] [Modular reduction timing] Modular reduction at line 284 may take variable time depending on input magnitude - can timing analysis reveal whether inputs are near the field modulus? (Low)",
  "[File: aptos-core/crates/aptos-crypto/src/poseidon_bn254/alt_fr.rs] [Function: from_str_vartime()] [Variable time parsing] Line 34 explicitly uses from_str_vartime() which is not constant-time - can attackers use timing to extract information about string inputs being hashed? (Low)"
]