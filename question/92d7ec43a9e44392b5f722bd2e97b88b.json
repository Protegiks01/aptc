[
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Generic instantiation attack] max_generic_instantiation_length: Some(32) - can an attacker create types with 32 generic parameters that exponentially explode during monomorphization, exhausting validator memory? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Function parameter overflow] max_function_parameters: Some(128) - can functions with 128 parameters cause stack overflow or excessive register allocation during bytecode verification? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Basic block explosion] max_basic_blocks: Some(1024) - can bytecode with 1024 basic blocks cause control flow graph analysis to consume excessive CPU, degrading validator performance? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Value stack attack] max_value_stack_size: 1024 - can an attacker craft bytecode that repeatedly pushes values to approach the 1024 limit, causing stack reallocation overhead that slows verification? (Low)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Type node explosion] max_type_nodes conditional logic (128 vs 256) based on enable_function_values - can this difference cause verification to succeed on nodes with function values disabled but fail when enabled, breaking consensus? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Push size DoS] max_push_size: Some(10000) - can an attacker use VecPack or similar instructions with 10000 elements to cause memory allocation spikes during verification? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Meter unit overflow] max_per_fun_meter_units: Some(1000 * 80000) - can this 80 million unit limit overflow in integer arithmetic during metering, bypassing cost checks? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Module meter overflow] max_per_mod_meter_units: Some(1000 * 80000) - can large modules with multiple functions near the limit cause cumulative meter overflow, allowing unbounded verification cost? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Return value limit] max_function_return_values conditional (Some(128) vs None) - can functions returning 128 values cause excessive tuple unpacking overhead during execution? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Type depth attack] max_type_depth conditional (Some(20) vs None) - can deeply nested types at depth 20 cause recursive type checking to approach stack limits and crash validators? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Unbounded struct definitions] max_struct_definitions: None - can an attacker publish modules with thousands of struct definitions to exhaust validator memory during module loading? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_verifier_config()] [Unbounded function definitions] max_function_definitions: None - can modules with thousands of functions cause verification time to become unbounded, blocking transaction processing? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Layout size manipulation] The layout_max_size conditional (512 vs 256) based on gas_feature_version >= RELEASE_V1_30 - can validators with different gas versions accept different struct layouts, causing state divergence? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Layout depth overflow] layout_max_depth: 128 - can structures with 128 levels of nesting cause stack overflow during layout computation or serialization? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Type cost overflow] type_max_cost: 5000 with type_byte_cost: 1 - can type tags with exactly 5000 bytes bypass size checks while still consuming excessive memory? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Type cost arithmetic] type_base_cost: 100 + type_byte_cost: 1 * size - can this arithmetic overflow for extremely large type tags, wrapping to small values and bypassing cost limits? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Value depth attack] max_value_nest_depth: Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH) with assertion at line 235-238 - can the assertion fail if VMConfig is modified elsewhere, causing validator panic? (Medium)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Value depth bypass] The enable_depth_checks flag depends on FeatureFlag::ENABLE_FUNCTION_VALUES - can attackers exploit transactions submitted before feature activation to create deeply nested values without depth checks? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Delayed field exploitation] delayed_field_optimization_enabled: false by default - does manually enabling this optimization introduce race conditions in aggregator operations that could double-spend resources? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Paranoid check bypass] get_paranoid_type_checks() at line 179 - can an attacker race to set this to false during node initialization before VM config is created, disabling all type safety checks? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Reference check bypass] get_paranoid_ref_checks() at line 180 - if this returns false, can Move bytecode violate borrow checker rules by creating multiple mutable references to the same resource? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Cache inconsistency] get_layout_caches() at line 181 - can enabling layout caches cause non-deterministic behavior if cache eviction policies differ across validators? (Critical)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Enum option exploitation] enable_enum_option flag from FeatureFlag::ENABLE_ENUM_OPTION - can enabling enums introduce type confusion between Option<T> and enum variants? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Framework option bypass] enable_framework_for_option flag - can this allow framework code to bypass Option type safety checks that user code must follow? (High)",
  "[File: aptos-core/aptos-move/aptos-vm-environment/src/prod_configs.rs] [Function: aptos_prod_vm_config()] [Function cache poisoning] enable_function_caches from features.is_call_tree_and_instruction_vm_cache_enabled() - can cache poisoning cause incorrect cached function results to be reused across transactions? (Critical)"
]