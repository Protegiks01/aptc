[
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Assert vulnerability] The assert!(self.pruner_worker.is_some()) at line 163 will panic if called when pruner is disabled - can state transitions or race conditions cause this code path to be reached unexpectedly, crashing the validator? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Ordering violation] The min_readable_version is stored atomically (line 165-166), then set on worker (line 172-175) - if worker starts pruning immediately, can it operate on stale min_readable_version from previous calls? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Data race] The latest_version field uses Arc<Mutex<Version>> while min_readable_version uses AtomicVersion - can unsynchronized access between these two fields cause version skew where latest < min_readable? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Lock ordering] If multiple threads lock latest_version.lock() at different points (line 58, 67), can this lead to deadlocks when combined with other database locks? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Shared state] The Arc<LedgerDb> is shared - if multiple LedgerPrunerManager instances exist (though unlikely), can concurrent write_pruner_progress() calls corrupt metadata? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Mutex poisoning] If a panic occurs while holding latest_version.lock() at line 67, the mutex becomes poisoned - does this permanently disable pruning and cause storage exhaustion? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Mutex contention] The latest_version.lock() at line 58 is held while performing arithmetic - can high contention on this lock from frequent queries cause validator performance degradation? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: is_pruning_pending()] [Reference safety] At lines 92-94, is_some_and() checks and accesses pruner_worker - can this cause undefined behavior if pruner_worker is being modified concurrently? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Panic propagation] The .expect('Failed to create ledger pruner.') at line 148 will panic if LedgerPruner::new() fails - can corrupted database state or resource exhaustion trigger this during validator operation, causing downtime? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Resource leak] If PrunerWorker::new() at line 159 starts a thread but the manager is later dropped, does the worker thread properly shut down, or can this leak thread resources over time? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Configuration validation] The batch_size from ledger_pruner_config is passed to both pruner (line 146-149) and worker (line 159) - if these values are inconsistent or invalid (e.g., 0), can this cause infinite loops or division by zero? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: init_pruner()] [Metric overflow] PRUNER_WINDOW and PRUNER_BATCH_SIZE metrics are set to i64 casts of u64 values (lines 152-157) - can large u64 values overflow when cast, causing negative metric values that confuse monitoring? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Struct: LedgerPrunerManager] [Worker state] The Option<PrunerWorker> can be None if pruner is disabled - can code paths that assume it's Some (like set_pruner_target_db_version unwraps) be reached through state transitions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_worker_target_version()] [Test code in production] The #[cfg(test)] function at lines 97-103 uses unwrap() - if this annotation is accidentally removed, can production code panic if pruner_worker is None? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Partial write] If write_pruner_progress() at line 88 partially succeeds (writes to some sub-databases but not others), can this cause inconsistent pruning state across different ledger components? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Rollback vulnerability] If a transaction is aborted after save_min_readable_version() succeeds, does the atomic min_readable_version remain updated while database state is rolled back, causing data unavailability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Monotonicity violation] Is there validation that min_readable_version only increases, or can a malicious caller pass a lower value, causing previously pruned data to be marked as available? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Metric inconsistency] PRUNER_VERSIONS metric is updated at line 84-86 before write_pruner_progress() - if the write fails, can metrics show incorrect pruning progress, masking failures? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Progress recovery] At line 123-124, if get_ledger_pruner_progress() returns a version that's ahead of actual pruned data (due to crash during pruning), can queries access data that's been deleted? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Off-by-one] The condition at line 73-74 uses >= which may trigger pruning one version too early - can this cause the loss of the most recent data point within the prune_window? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Zero handling] If prune_window is 0, does saturating_sub at line 56-57 and 58 behave correctly, or can this cause all historical data to be marked for pruning? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Version 0] If latest_version is 0 (genesis), does saturating_sub(prune_window) at line 164 correctly return 0, or can this cause integer underflow issues in downstream pruning logic? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Maximum value] If latest_version approaches u64::MAX, can the arithmetic at line 58 (saturating_sub followed by more operations) cause unexpected wrapping or saturation? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Batch size edge cases] If pruning_batch_size is u64::MAX, can the addition at line 74 always overflow, preventing pruning from ever triggering? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Validator divergence] If different validators have different user_pruning_window_offset configurations, can they serve different min_viable_version values, causing query inconsistencies across the network? (High)"
]