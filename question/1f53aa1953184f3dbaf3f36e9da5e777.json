[
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_state_values_range()] [Integer Overflow] Can an attacker provide a latest_version close to u64::MAX such that the checked_sub operation at line 160-163 returns an error, causing denial of service by preventing state sync from completing? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_state_values_range()] [Integer Overflow] In the lowest_state_version calculation at lines 159-166, if pruning_window is manipulated to be larger than latest_version, can this bypass pruning boundaries and expose historical state that should be pruned? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_state_values_range()] [Integer Underflow] At line 164, can an attacker trigger a scenario where checked_add(1) fails by manipulating lowest_state_version to be u64::MAX-1, causing state sync failure? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: inclusive_range_len()] [Integer Validation] At lines 1487-1492, can an attacker provide end=u64::MAX to bypass the check and cause overflow in the checked_add(1) operation, leading to incorrect range calculations? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: inclusive_range_len()] [Range Validation] If start > end at line 1487, the function returns InvalidRequest error - can this be exploited to cause repeated request failures and exhaust validator resources through retry storms? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_epoch_ending_ledger_infos_by_size()] [Integer Overflow] At line 236, can start_epoch + num_ledger_infos_to_fetch overflow u64::MAX, potentially causing incorrect epoch boundaries and serving wrong epoch proofs? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_epoch_ending_ledger_infos_by_size_legacy()] [Integer Overflow] At lines 310-314, can the checked_add operation overflow when start_epoch is close to u64::MAX, allowing attackers to request invalid epoch ranges? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_data_summary()] [Integer Underflow] At line 1047, can epoch().checked_sub(1) fail if current epoch is 0 after a fresh start, causing get_data_summary to return errors and halt state sync? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Proof Inconsistency] At lines 474-478, when creating accumulator_range_proof using transactions.len(), can a race condition between iterator exhaustion and proof generation cause proof version mismatch, breaking state verification? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Data Truncation Attack] At lines 438-448, can an attacker craft transactions with carefully sized payloads to force truncation at specific boundaries, causing clients to receive incomplete state updates? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Empty Proof Attack] At lines 700-702, when num_fetched_outputs is 0, AccumulatorRangeProof::new_empty() is returned - can this empty proof be exploited to convince clients that no transactions exist in a valid range? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Proof-Data Mismatch] At lines 703-707, if storage.get_transaction_accumulator_range_proof() is called with stale data after iterator advances, can this create proofs that don't match the returned transactions? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_state_value_chunk_with_proof_by_size()] [Merkle Proof Manipulation] At lines 976-980, can an attacker manipulate start_index or state_values to cause get_state_value_chunk_proof() to generate invalid proofs that still pass verification? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_epoch_ending_ledger_infos_by_size()] [Epoch Proof Forgery] At line 289, EpochChangeProof::new() is called with false for 'more' parameter - can an attacker manipulate this to claim no more epochs exist when they do, causing clients to accept incomplete epoch chains? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Iterator Desynchronization] At lines 396-401, four iterators (transaction, info, events, auxiliary) are zipped together - can they become desynchronized if storage is modified concurrently, causing mismatched transaction-info pairs? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Iterator Exhaustion] At lines 457-469, when iterator returns None early, a warning is logged but processing continues - can premature iterator exhaustion cause incomplete transaction lists to be served as complete? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Multi-Iterator Race] At lines 608-614, five iterators are zipped - can race conditions in the underlying storage layer cause one iterator to advance faster, creating data corruption? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Missing Data Warning] At lines 685-693, when iterators are missing expected data, only a warning is logged - can attackers exploit this to serve partial data as complete without proper error propagation? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_state_value_chunk_with_proof_by_size()] [State Iterator Truncation] At lines 963-970, when state_value_iterator returns None early, can this cause clients to receive incomplete state chunks that appear complete due to missing validation? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_epoch_ending_ledger_infos_by_size()] [Epoch Iterator Mismatch] At lines 276-284, when epoch_ending_ledger_info_iterator returns None early, can this cause incomplete epoch chains to be served, breaking consensus? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: check_overflow_network_frame()] [Size Check Bypass] At lines 1503-1507, the function checks if num_serialized_bytes >= max_network_frame_bytes - can an attacker craft data exactly at max_network_frame_bytes to bypass truncation and overflow network buffers? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_num_serialized_bytes()] [Serialization Size Mismatch] At lines 1514-1516, bcs::serialized_size() is used - can differences between serialized_size and actual serialization cause buffer overflows when data is transmitted? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size_legacy()] [Binary Search Attack] At lines 332-336 and 550-554, chunk size is halved on overflow - can an attacker craft responses that cause repeated halving to approach 1, triggering worst-case O(log n) retries and resource exhaustion? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size_legacy()] [Single Item Bypass] At line 759, when num_outputs_to_fetch == 1, the response is returned even if it overflows - can attackers craft single massive transaction outputs to overflow network frames? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_state_value_chunk_with_proof_by_size_legacy()] [Minimum Response Violation] At line 1006, when num_state_values_to_fetch == 1, data is returned regardless of size - can this be exploited to serve arbitrarily large state values that crash clients? (High)"
]