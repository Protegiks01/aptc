[
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Constant: ROOT_TOKEN] [Credential exposure] Is the hardcoded ROOT_TOKEN constant 'root_token' used in production environments, allowing any attacker with code access to obtain root-level Vault access and extract all validator private keys, consensus secrets, and cryptographic material? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Constant: ROOT_TOKEN] [Secret leakage] Does the hardcoded ROOT_TOKEN at line 38 get logged, dumped in core files, or exposed through debugging tools, allowing attackers to extract it from process memory or system logs to gain unauthorized Vault access? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: root_token()] [Credential disclosure] Does the root_token() method at line 118-120 return a reference to the hardcoded token without any access control checks, enabling any caller to obtain root Vault credentials for cryptographic secret extraction? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: client()] [Token exposure] Does the client() method at lines 122-130 pass the root token in plaintext without encryption or secure channels, allowing network sniffing or memory dumps to capture root Vault credentials? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Static: APTOS_VAULT] [Race condition] Can concurrent test threads race during APTOS_VAULT lazy initialization at lines 12-23, causing multiple Vault instances to spawn on the same port, leading to port conflicts and test failures that could mask security bugs? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Static: APTOS_VAULT] [Resource leak] If VaultRunner::run() fails after APTOS_VAULT initialization begins but before completion, does the partially-initialized state cause resource leaks (zombie processes, open file descriptors, bound ports) that persist across test runs? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: test_host_safe()] [TOCTOU] Can a time-of-check-time-of-use race occur between test_host_safe() at line 27-29 checking APTOS_VAULT and actual Vault usage, where Vault crashes between the check and use, causing tests to pass incorrectly when they should fail? (Low)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: test_host()] [Panic safety] Does test_host() at line 32-34 unwrap without proper error handling, causing panics in concurrent test scenarios where Vault initialization racing could leave APTOS_VAULT in an inconsistent state? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _port()] [Race condition] Can multiple concurrent calls to _port() at lines 77-87 allocate the same ephemeral port due to TIME_WAIT state expiring, causing two Vault instances to bind to the same port and creating cross-contamination of test secrets? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _port()] [Port exhaustion] Can an attacker repeatedly call _port() to exhaust available ephemeral ports through intentional port leaking (lines 84-85 accept but never use connections), causing denial of service where legitimate Vault instances cannot start? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _port()] [Port reuse attack] Does the TIME_WAIT state manipulation at lines 83-86 create a vulnerability where a malicious process could bind to the port between _port() returning and Vault actually binding, allowing attacker-controlled processes to intercept Vault traffic? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _port()] [Resource leak] Does _port() properly close the TcpListener and TcpStream at lines 78-86, or can repeated calls leak file descriptors until the system hits ulimit, preventing new Vault instances from starting and causing test infrastructure DoS? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Constant: HOST] [Network binding bypass] Is the hardcoded HOST constant 'http://localhost' at line 37 bypassable, allowing tests to accidentally bind Vault to 0.0.0.0 or public interfaces, exposing root tokens and cryptographic secrets to network attackers? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Network exposure] Does the dev-listen-address argument at line 58 properly restrict binding to 127.0.0.1, or can command injection or environment manipulation change it to 0.0.0.0, exposing the root-token-enabled Vault to network attacks? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Command injection] Can the BINARY constant at line 36 be overridden through environment variables or build-time manipulation to execute arbitrary commands instead of 'vault', enabling remote code execution during test setup? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Argument injection] Can special characters or shell metacharacters in ROOT_TOKEN at line 57 cause command injection when passed to vault command, allowing arbitrary command execution with test infrastructure privileges? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Process escape] Does the vault process spawned at lines 60-65 properly inherit security restrictions, or can it escape containers/sandboxes by not having proper stdio redirection, resource limits, or namespace isolation? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Struct: VaultRunner] [Zombie processes] If the VaultRunner struct at line 42-45 goes out of scope without explicit Drop implementation, does the _child process become a zombie, leaking resources and potentially allowing orphaned Vault instances with root tokens to persist? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Process termination] Does VaultRunner properly kill the child Vault process on drop, or can the process continue running after tests complete, leaving a root-token-enabled Vault instance accessible to subsequent attackers? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Signal handling] Does the spawned Vault process at line 60-65 handle SIGTERM/SIGKILL properly, or can signal-based attacks leave the process in an inconsistent state where secrets are partially written to disk without proper encryption? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: run()] [Stdio redirection] Does redirecting stderr, stdin, stdout to null at lines 61-63 hide critical security errors or warnings from Vault, allowing silent failures in cryptographic operations or access control violations to go undetected? (Medium)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _transit()] [TLS bypass] Does the '-tls-skip-verify' flag at line 97 disable all certificate validation, allowing man-in-the-middle attacks where an attacker intercepts Vault API calls and steals ROOT_TOKEN or cryptographic secrets in transit? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _transit()] [Certificate validation bypass] Can the tls-skip-verify flag at line 97 be exploited in production if this dev code is accidentally used, completely disabling TLS security and exposing validator private keys to network attackers? (Critical)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: _transit()] [Protocol downgrade] Does skipping TLS verification at line 97 allow protocol downgrade attacks where an attacker forces HTTP instead of HTTPS, capturing all Vault API traffic including authentication tokens and secret data? (High)",
  "[File: aptos-core/secure/storage/vault/src/dev.rs] [Function: client()] [Insecure client] Does the client() method at line 122-130 create a Client with None for certificate/TLS parameters, inheriting the tls-skip-verify behavior and creating an insecure client that exposes all Vault operations to network attacks? (High)"
]