[
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_write_all()] [Infinite Loop] Lines 448-460 contain a loop that only exits when offset == buf.len(). If a buggy AsyncWrite implementation repeatedly returns Poll::Ready(Ok(0)), can this cause an infinite busy loop consuming 100% CPU and degrading validator performance? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read_u16frame_len()] [Partial Frame Length] Lines 469-487 read a 2-byte frame length. At line 481, if offset == 0 and UnexpectedEof occurs, it's treated as graceful shutdown. Can an attacker send exactly 1 byte then close the connection to force the error path at line 484, potentially exploiting different error handling logic? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: AsyncRead::poll_read()] [Reentrancy] At line 374, self.get_mut() is used to get mutable access. If NoiseStream is wrapped in a type that allows concurrent calls to poll_read(), can multiple threads simultaneously mutate read_state, causing race conditions where decrypted data is delivered to the wrong caller? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: AsyncWrite::poll_write()] [Concurrent Write] At line 387, poll_write() gets mutable self. If a validator implementation incorrectly calls poll_write() from multiple tasks concurrently (violating AsyncWrite contract), can this cause write_buffer corruption where multiple messages are interleaved before encryption? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_write_or_flush()] [Cancellation Safety] Lines 229-341 are not cancellation-safe. If the Future returned by AsyncWriteExt methods is dropped while in WriteState::WriteEncryptedFrame, the encrypted message may be partially written. Can an attacker trigger task cancellations to cause protocol desynchronization? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: NoiseStream::new()] [Session Thread Safety] At line 50-58, NoiseSession is stored directly in NoiseStream. If NoiseSession is not Send/Sync (unclear from this file), can this prevent NoiseStream from being used across async tasks, limiting scalability and potentially causing validator performance issues? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read()] [Ready Macro Race] Lines 106, 139 use the ready!() macro. If the underlying socket's poll_read() returns Poll::Ready but then subsequent operations like decryption take significant time, can this cause head-of-line blocking where one slow decryption stalls all other network operations on this validator? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::ReadFrameLen Error Path] [Error Kind Confusion] At lines 128-131, UnexpectedEof is specially handled, but line 131 returns the error without further processing. Can an attacker craft network conditions that cause other io::Error kinds to be misinterpreted, bypassing error handling logic and causing validator state corruption? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::DecryptionError] [Error Persistence] Lines 192-196 return DecryptionError indefinitely once set. If a single corrupted frame causes this state, all subsequent read attempts will fail even if valid frames arrive later. Can an attacker inject one bad frame to permanently poison a validator connection, forcing reconnection overhead? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::EncryptionError] [Error State Trap] At lines 290-291, EncryptionError state is set and an error is returned. Lines 333-337 show this error is returned on every subsequent call. Can this allow an attacker to cause one encryption failure (e.g., via nonce exhaustion) and permanently disable all outbound messages from a validator? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_write_or_flush()] [Write Zero Handling] At lines 321-324, WriteZero error transitions to WriteState::Eof and returns error. Line 332 then returns WriteZero error on all subsequent calls. Can this be exploited to make a validator appear offline to peers while still consuming resources, enabling subtle eclipse attacks? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read()] [Error Return Early] At line 131, error is returned immediately without cleaning up read_state. If the caller retries after a transient error, does read_state remain in ReadFrameLen with partial offset, causing the next frame to be misaligned and trigger DecryptionError? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Documentation: Length Prefix] [Length Field Size] Line 8 states 'we have to prefix every noise message with its length'. The implementation uses u16 (2 bytes) for length at line 306. Is this compatible with all Noise protocol implementations, or can this cause interoperability issues with validators running different client versions? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::WriteEncryptedFrame] [Big Endian Encoding] At line 306, frame_len is encoded as u16::to_be_bytes(). If any component of Aptos incorrectly uses little-endian encoding, can this cause complete protocol breakdown where all messages are misinterpreted, causing network partition? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read_u16frame_len()] [Frame Length Endianness] At line 479, u16::from_be_bytes() is used to decode frame length. If there's any inconsistency between write and read endianness due to compiler differences or architecture-specific behavior, can this cause catastrophic misinterpretation of message lengths? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Constant: MAX_SIZE_NOISE_MSG] [Protocol Limit] The code references noise::MAX_SIZE_NOISE_MSG (65535 bytes) but doesn't enforce it during writes. At line 275, frame_len is expected to fit in u16, but what if offset is larger than decrypted_len(65535) = 65519? Can this cause the expect() at line 278 to panic? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [Noise IK Pattern] The file comment at line 8 mentions this implements post-handshake protocol. If the handshake phase (IK pattern) fails to properly establish session keys and this file assumes valid keys, can an attacker complete a malformed handshake and then send crafted post-handshake messages that decrypt to attacker-controlled plaintext? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Struct: NoiseBuffers] [Memory Allocation] Lines 411-413 define two buffers of MAX_SIZE_NOISE_MSG (65535 bytes) each, totaling ~128KB per NoiseStream. If a validator accepts thousands of inbound connections, can an attacker exhaust validator memory by establishing many connections without sending data, forcing OOM and validator crash? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: WriteState::WriteEncryptedFrame] [Heap Allocation] Line 308 uses [frame_len_bytes, message_bytes].concat() which allocates on heap. For maximum-size messages (65535 bytes), this allocates 65537 bytes per write. Can high-frequency large message attacks cause memory fragmentation and GC pressure, degrading validator performance below consensus thresholds? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::ReadFrame] [CPU Exhaustion] At line 146, read_message_in_place() performs AES-GCM decryption. If an attacker floods a validator with maximum-size encrypted frames (65535 bytes each), can the CPU cost of decryption operations overwhelm the validator, preventing it from participating in consensus? (Medium - but DoS excluded)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: poll_read()] [Loop Iterations] Lines 93-199 contain a loop without explicit iteration limit. In pathological cases where state transitions don't make progress (e.g., offset increments fail), can this loop consume excessive CPU in a single poll_read() call, causing task starvation? (Medium)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: Box<NoiseBuffers>] [Boxing Overhead] At line 41, buffers are Box allocated. While this reduces stack size, the 128KB allocation occurs per connection. For a validator handling 1000 concurrent connections, this is 128MB minimum. Can this exceed memory limits in resource-constrained validator environments? (Low)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.read_message_in_place()] [Authentication Tag Validation] At line 146, the authentication tag is implicitly validated during decryption. If the underlying Noise implementation has a bug where invalid tags occasionally pass validation (e.g., timing-based), can an attacker inject unauthenticated messages into consensus, violating Byzantine fault tolerance assumptions? (Critical)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: session.write_message_in_place()] [Authentication Tag Generation] Lines 270-273 append the authentication tag returned by write_message_in_place(). If the Noise session is in an invalid state (e.g., nonce counter wrapped around), can it return a valid-looking but incorrect tag that will fail verification on the receiving end, causing silent message drops? (High)",
  "[File: aptos-core/network/framework/src/noise/stream.rs] [Function: ReadState::ReadFrame] [Tag Extraction] The code at line 147 passes the entire encrypted frame including tag to read_message_in_place(). If the Noise implementation incorrectly extracts the tag (e.g., using wrong offset), can this cause decryption to succeed with corrupted plaintext, leading to consensus protocol violations? (Critical)"
]