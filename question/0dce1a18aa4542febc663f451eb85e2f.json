[
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Function: new()] [Sender cloning] MempoolNotifier stores notification_sender on line 71 - can this sender be extracted and cloned maliciously to create unauthorized notification sources? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Function: new()] [Listener initialization] MempoolNotificationListener::new() on line 127 stores notification_receiver - can multiple listeners be created for same receiver causing split brain where only some notifications reach mempool? (Critical)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Struct: MempoolNotifier] [Clone trait] Line 63 derives Clone for MempoolNotifier - can unlimited cloning create thousands of senders all competing to send notifications, causing channel congestion and notification delays? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Struct: MempoolNotifier] [Clone semantics] When MempoolNotifier is cloned, all clones share the same channel sender - can one clone closing its sender affect other clones, causing notification failures across unrelated state sync components? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Struct: MempoolNotifier] [Clone lifetime] If a cloned MempoolNotifier outlives the original, can it continue sending notifications after state sync has transitioned to new epoch, causing stale notifications with wrong block metadata? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Comment: line 96] [Specification mismatch] Comment says 'Mempool needs to be notified about all transactions (user and non-user transactions)' but code on lines 84-94 only sends user transactions - does this specification violation cause mempool to miss critical system transactions? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Comment: line 97] [Issue reference] References GitHub issue #1882 - was this issue resolved, or does the current implementation still have the bug where mempool isn't properly notified about non-user transactions? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: test_mempool_not_listening()] [Production behavior] Test on lines 214-215 closes receiver and expects CommitNotificationError - but in production, does mempool closing its receiver cause permanent notification failure requiring node restart? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: test_mempool_channel_blocked()] [Blocking detection] Test on lines 234-238 uses 5-second timeout to detect blocking - but in production, can state sync block indefinitely with no timeout, causing total liveness failure? (Critical)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: test_mempool_channel_blocked()] [Channel capacity] Test creates channel with capacity 1 on line 225 - what is the production capacity, and can it be exhausted during high transaction throughput causing notification loss? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: test_no_transaction_filtering()] [Non-user transactions] Test on lines 255-259 sends BlockMetadata and Genesis transactions - does production code properly handle these, or will they be silently dropped as shown in the filter_map on line 92? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: create_user_transaction()] [Test transaction validity] Test creates transaction with all zeros for gas/limits on lines 318-321 - can similar invalid transactions in production bypass validation and cause issues when mempool processes committed notifications? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: create_user_transaction()] [Random address] Line 315 uses AccountAddress::random() for sender - can production code send notifications with invalid or system addresses that mempool should reject? (Low)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Test: create_block_metadata_transaction()] [Hash collision] Line 334 creates BlockMetadata with HashValue::new([0; HashValue::LENGTH]) - can actual blocks have hash collisions causing mempool to incorrectly associate transactions with wrong blocks? (Low)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Memory ordering] The mpsc channel operations lack explicit memory ordering guarantees - can weak memory models on some architectures cause notifications to be observed out-of-order by mempool? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Channel fairness] If multiple state sync tasks send notifications concurrently, does the mpsc channel provide fairness guarantees, or can one sender starve others causing some blocks to never notify mempool? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Async executor] The code assumes single async executor - can running state sync and mempool on different executors cause notification delivery issues due to executor context switching? (Low)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Panic safety] If any code panics during notify_new_commit() execution (lines 78-117), can the channel be left in corrupted state preventing future notifications? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Task cancellation] If the async task running notify_new_commit() is aborted while waiting on send().await (line 107), does proper cleanup occur or can resources leak? (Medium)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Transaction lifetime] The Vec<Transaction> passed to notify_new_commit() on line 80 - if it contains references to deallocated memory, can this cause use-after-free when extracting UserTransaction on line 87? (Critical)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Type confusion] The Transaction enum on line 86 - can an attacker craft a transaction that appears to be UserTransaction variant but contains data from other variants, bypassing type safety? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Sender validation] When extracting signed_txn.sender() on line 88, is there validation that the sender actually signed the transaction, or can signature verification be bypassed in committed transactions? (Critical)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [State sync coupling] If state sync component crashes or restarts, does MempoolNotifier properly reconnect to mempool, or can notifications be permanently lost during component restart? (High)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Mempool coupling] If mempool stops processing notifications but doesn't close receiver, can the bounded channel fill up causing state sync to block and halt consensus? (Critical)",
  "[File: state-sync/inter-component/mempool-notifications/src/lib.rs] [Overall] [Epoch transitions] During epoch transitions when validator set changes, are existing notifications in the channel properly drained or do they get lost causing inconsistent mempool state? (High)"
]