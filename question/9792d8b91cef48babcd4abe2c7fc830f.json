[
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: spawn_share_requester_task()] [Multicast targets] The targets list at line 257 is all validators minus existing_shares - can incorrect existing_shares set cause honest validators to be excluded from requests? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Config validation] The config parameter is cloned and used throughout - are threshold, epoch, and cryptographic parameters validated before use, or can invalid config cause failures? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Backoff policy] The ExponentialBackoff created at lines 75-77 - can extreme values (0ms base, 1000s max delay) in rb_config cause consensus timing issues? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: new()] [Epoch state validation] The epoch_state parameter - is it validated to ensure verifier contains expected validators before being used for secret sharing? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: start()] [Highest known round] The highest_known_round parameter at line 330 - can this be set to incorrect values causing valid shares to be rejected? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Struct: SecretShareManager] [SecretShareStore integration] The secret_share_store calls add_self_share() and add_share() - can bugs in SecretShareStore cause aggregation to fail silently? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Struct: SecretShareManager] [BlockQueue integration] The block_queue manages QueueItem lifecycle - can bugs in dequeue_ready_prefix() cause blocks to be skipped or processed multiple times? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Pipeline futures integration] The block.pipeline_futs() at line 133 - can malformed or missing futures cause processing to fail? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Struct: SecretShareManager] [ReliableBroadcast integration] The reliable_broadcast Arc - can bugs in ReliableBroadcast cause share requests to be lost or duplicated? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: verification_task()] [Message verification] The msg.verify() call at line 220 - can flaws in SecretShareMessage::verify() allow invalid shares to pass verification? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_blocks()] [Empty blocks] If blocks.ordered_blocks is empty (despite assertion in QueueItem::new), can this cause undefined behavior in round iteration? (Low)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_aggregated_key()] [Round not found] When block_queue.item_mut() returns None at line 187, is this expected during normal operation or does it indicate a serious state inconsistency? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: handle_incoming_msg()] [Metadata mismatch] At line 302, when self_share is not found for a request, is this due to legitimate timing or can it indicate share loss? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: start()] [Multiple resets] Can multiple ResetRequest messages arrive in quick succession causing block_queue to be reset multiple times with inconsistent highest_known_round values? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: observe_queue()] [Metrics accuracy] The DEC_QUEUE_SIZE metric at line 382 - does it accurately reflect pending work or can it become stale if observe_queue() isn't called regularly? (Low)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Struct: SecretShareManager] [Epoch boundary] During epoch transitions, can in-flight secret shares from old epoch be processed in new epoch context causing incorrect randomness to be used? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_incoming_block()] [Block pipeline coordination] If execution layer processes blocks faster than secret shares aggregate, can this cause randomness to be used before it's properly derived? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: process_ready_blocks()] [Downstream processing] When blocks are sent via outgoing_blocks at line 168, does the receiver validate that secret shares are present and valid? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Struct: SecretShareManager] [Consensus coordination] Can consensus round manager proceed with blocks before SecretShareManager has aggregated required shares, bypassing randomness generation? (Critical)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: verification_task()] [Verification amplification] Can Byzantine validators send messages that pass initial checks but require expensive verification, amplifying DoS impact? (High)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: spawn_share_requester_task()] [Request amplification] Can Byzantine validators trigger share request broadcasts for same round multiple times causing redundant network traffic? (Medium)",
  "[File: consensus/src/rand/secret_sharing/secret_share_manager.rs] [Function: handle_incoming_msg()] [Lock holding duration] How long is secret_share_store.lock() hel\n\n### Citations\n\n**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L1-384)\n```rust\n// Copyright (c) Aptos Foundation\n// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE\n\nuse crate::{\n    counters::DEC_QUEUE_SIZE,\n    logging::{LogEvent, LogSchema},\n    network::{IncomingSecretShareRequest, NetworkSender, TConsensusMsg},\n    pipeline::buffer_manager::{OrderedBlocks, ResetAck, ResetRequest, ResetSignal},\n    rand::secret_sharing::{\n        block_queue::{BlockQueue, QueueItem},\n        network_messages::{SecretShareMessage, SecretShareRpc},\n        reliable_broadcast_state::SecretShareAggregateState,\n        secret_share_store::SecretShareStore,\n        types::RequestSecretShare,\n    },\n};\nuse aptos_bounded_executor::BoundedExecutor;\nuse aptos_channels::aptos_channel;\nuse aptos_config::config::ReliableBroadcastConfig;\nuse aptos_consensus_types::{\n    common::{Author, Round},\n    pipelined_block::PipelinedBlock,\n};\nuse aptos_infallible::Mutex;\nuse aptos_logger::{info, spawn_named, warn};\nuse aptos_network::{protocols::network::RpcError, ProtocolId};\nuse aptos_reliable_broadcast::{DropGuard, ReliableBroadcast};\nuse aptos_time_service::TimeService;\nuse aptos_types::{\n    epoch_state::EpochState,\n    secret_sharing::{SecretShareConfig, SecretShareMetadata, SecretSharedKey},\n};\nuse bytes::Bytes;\nuse futures::{\n    future::{AbortHandle, Abortable},\n    FutureExt, StreamExt,\n};\nuse futures_channel::{\n    mpsc::{unbounded, UnboundedReceiver, UnboundedSender},\n    oneshot,\n};\nuse std::{collections::HashSet, sync::Arc, time::Duration};\nuse tokio_retry::strategy::ExponentialBackoff;\n\npub type Sender<T> = UnboundedSender<T>;\npub type Receiver<T> = UnboundedReceiver<T>;\n\npub struct SecretShareManager {\n    author: Author,\n    epoch_state: Arc<EpochState>,\n    stop: bool,\n    config: SecretShareConfig,\n    reliable_broadcast: Arc<ReliableBroadcast<SecretShareMessage, ExponentialBackoff>>,\n    network_sender: Arc<NetworkSender>,\n\n    // local channel received from dec_store\n    decision_rx: Receiver<SecretSharedKey>,\n    // downstream channels\n    outgoing_blocks: Sender<OrderedBlocks>,\n    // local state\n    secret_share_store: Arc<Mutex<SecretShareStore>>,\n    block_queue: BlockQueue,\n}\n\nimpl SecretShareManager {\n    pub fn new(\n        author: Author,\n        epoch_state: Arc<EpochState>,\n        config: SecretShareConfig,\n        outgoing_blocks: Sender<OrderedBlocks>,\n        network_sender: Arc<NetworkSender>,\n        bounded_executor: BoundedExecutor,\n        rb_config: &ReliableBroadcastConfig,\n    ) -> Self {\n        let rb_backoff_policy = ExponentialBackoff::from_millis(rb_config.backoff_policy_base_ms)\n            .factor(rb_config.backoff_policy_factor)\n            .max_delay(Duration::from_millis(rb_config.backoff_policy_max_delay_ms));\n        let reliable_broadcast = Arc::new(ReliableBroadcast::new(\n            author,\n            epoch_state.verifier.get_ordered_account_addresses(),\n            network_sender.clone(),\n            rb_backoff_policy,\n            TimeService::real(),\n            Duration::from_millis(rb_config.rpc_timeout_ms),\n            bounded_executor,\n        ));\n        let (decision_tx, decision_rx) = unbounded();\n\n        let dec_store = Arc::new(Mutex::new(SecretShareStore::new(\n            epoch_state.epoch,\n            author,\n            config.clone(),\n            decision_tx,\n        )));\n\n        Self {\n            author,\n            epoch_state,\n            stop: false,\n            config,\n            reliable_broadcast,\n            network_sender,\n\n            decision_rx,\n            outgoing_blocks,\n\n            secret_share_store: dec_store,\n            block_queue: BlockQueue::new(),\n        }\n    }\n\n    async fn process_incoming_blocks(&mut self, blocks: OrderedBlocks) {\n        let rounds: Vec<u64> = blocks.ordered_blocks.iter().map(|b| b.round()).collect();\n        info!(rounds = rounds,"
]