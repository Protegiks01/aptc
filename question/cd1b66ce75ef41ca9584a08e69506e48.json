[
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Pruner progress rollback] If shard configuration changes from sharded to unsharded (line 21-24), can the pruner incorrectly read progress from StateMerklePrunerProgress instead of StateMerkleShardPrunerProgress, causing it to re-prune nodes from earlier versions and corrupt state rollback mechanisms? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait] [Unauthorized schema implementation] Can external crates or malicious code implement StaleNodeIndexSchemaTrait for custom schema types (bypassing the pub(in crate::pruner) visibility at line 4) and register unauthorized pruners that delete arbitrary Merkle nodes? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key()] [Metadata key hijacking] Can an attacker with database write access directly modify the DbMetadataKey values returned by progress_metadata_key() (lines 22, 24, 36, 38) to point to wrong metadata locations, causing pruners to use incorrect progress values and delete live state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Missing shard_id bounds check] In line 21, there is no validation that shard_id, when Some(), is within the valid range [0, num_shards), allowing out-of-bounds shard IDs to create invalid metadata keys and cause undefined behavior in shard indexing logic downstream? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexCrossEpochSchema] [Epoch shard_id validation missing] In line 35, can providing a shard_id that exceeds the epoch snapshot shard count cause the epoch pruner to operate on non-existent shards, creating phantom progress metadata that prevents proper cleanup of epoch data? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key()] [Option<usize> misuse] Can calling progress_metadata_key(Some(0)) vs progress_metadata_key(None) with 0 shards configured cause semantic differences in metadata key selection, leading to pruners using inconsistent progress tracking depending on how the function is called? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Impl: StaleNodeIndexSchema] [Stale node index misclassification] Can malformed StaleNodeIndex entries with manipulated stale_since_version values bypass the schema's KeyCodec validation and cause the regular pruner (lines 19-31) to incorrectly prune nodes that are still part of recent state? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Impl: StaleNodeIndexCrossEpochSchema] [Epoch stale node leakage] Can cross-epoch stale nodes be incorrectly classified as regular stale nodes, causing the regular pruner (StaleNodeIndexSchema) to delete them instead of the epoch-ending pruner, breaking epoch snapshot guarantees? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: name() StaleNodeIndexSchema] [Pruner name collision] In line 28-30, the name 'state_merkle_pruner' is used for logging/metrics, but can multiple pruner instances with the same name cause metric aggregation to hide individual pruner failures, making it impossible to detect if one shard's pruner has stalled or is corrupting data? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait] [Schema migration vulnerability] If the Schema trait definition changes (e.g., Key type changes from StaleNodeIndex to a new type), can old database entries cause KeyCodec deserialization failures that crash the pruner and prevent recovery until a database migration is performed? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key()] [DbMetadataKey enum extension] If new variants are added to DbMetadataKey enum, can old code using progress_metadata_key() write to deprecated metadata keys while new code reads from new keys, causing progress tracking to become desynchronized across nodes? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Memory exhaustion via shard_id] In line 22, can providing a massive shard_id value (e.g., billions) cause downstream code to allocate excessive memory for shard-specific data structures, leading to OOM crashes and denial of service on validator nodes? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait] [String allocation DoS] Can the name() function (lines 28-30, 42-44) be called in a tight loop during metrics collection, causing repeated allocations of the static string and memory pressure, degrading pruner performance? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Non-deterministic shard selection] If line 21's if-else logic produces different DbMetadataKey values on different validators due to configuration drift, can pruning progress diverge across nodes, causing Merkle root mismatches and consensus failures? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Impl: Both schemas] [Implementation divergence] Can subtle differences in how StaleNodeIndexSchema (line 19-31) and StaleNodeIndexCrossEpochSchema (line 33-45) handle shard_id cause validators using different schema implementations to prune different nodes, breaking state root agreement? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: name()] [Log injection via pruner name] Can an attacker who controls trait implementation provide a malicious name() return value (lines 28-30, 42-44) containing newlines or escape sequences to inject fake log entries, hiding pruning failures or creating false alerts? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: name() StaleNodeIndexCrossEpochSchema] [Metrics namespace pollution] In line 42-44, the name 'epoch_snapshot_pruner' is used in metrics, but can collisions with other component names cause metrics to be incorrectly attributed, hiding that the epoch pruner is failing to make progress? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait line 11-13] [KeyCodec constraint bypass] Can an implementation of StaleNodeIndexSchemaTrait violate the 'where StaleNodeIndex: KeyCodec<Self>' constraint through unsafe code, allowing non-serializable or malformed StaleNodeIndex values to be used as database keys and corrupting the stale node index? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait line 11] [Schema::Key type mismatch] Can the Schema trait's associated Key type be mismatched with StaleNodeIndex through type system exploits, causing database reads/writes to interpret binary data as the wrong type and corrupt Merkle tree node references? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Shard hot-add race condition] During live addition of new shards, can calling progress_metadata_key() with newly added shard_id values (line 21-22) before shard initialization completes cause the pruner to write progress to uninitialized metadata, losing pruning history? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexCrossEpochSchema] [Epoch shard removal] If epoch shards are removed during reconfiguration, can line 36 generate metadata keys for deleted shards, causing the epoch pruner to fail to clean up stale nodes in remaining shards and leading to storage leaks? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key()] [Shard ID reuse vulnerability] If shard IDs are reused after shard deletion and recreation, can stale metadata from the old shard (line 22 or 36) be interpreted as progress for the new shard, causing incorrect pruning decisions? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Trait: StaleNodeIndexSchemaTrait] [Type parameter confusion] Can generic code monomorphize StaleNodeIndexSchemaTrait for unexpected types beyond StaleNodeIndexSchema and StaleNodeIndexCrossEpochSchema, bypassing pruner safety invariants and allowing arbitrary node deletion? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Impl: StaleNodeIndexSchema and StaleNodeIndexCrossEpochSchema] [Trait object safety violation] If StaleNodeIndexSchemaTrait is used as a trait object (dyn StaleNodeIndexSchemaTrait), can dynamic dispatch allow runtime type confusion between regular and epoch-ending schemas, causing pruners to delete wrong node categories? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/state_merkle_pruner/generics.rs] [Function: progress_metadata_key() StaleNodeIndexSchema] [Progress metadata poisoning] Can an attacker directly write to DbMetadataKey::StateMerkleShardPrunerProgress (line 22) with future version numbers, causing the pruner to skip pruning critical versions and accumulate unbounded stale nodes? (Medium)"
]