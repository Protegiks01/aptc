[
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Integer overflow] Can an attacker manipulate ledger_pruner_config.prune_window to cause integer overflow when combined with latest_version during pruning calculations, potentially leading to premature data deletion or retention of excessive historical data? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Configuration manipulation] If ledger_pruner_config.batch_size is set to an extremely large value (e.g., u64::MAX), can this cause memory exhaustion or integer overflow in pruning operations, leading to denial of service or data corruption? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [State inconsistency] Does pruner_utils::get_ledger_pruner_progress() handle database corruption gracefully, or can corrupted progress metadata cause the pruner to start from an invalid version, potentially re-pruning already accessible data? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Race condition] If multiple threads call new() concurrently during database initialization, can race conditions in PRUNER_VERSIONS metric updates lead to incorrect monitoring metrics that mask actual pruning failures? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Panic vulnerability] The .expect('Must succeed.') at line 124 will panic if get_ledger_pruner_progress() fails - can an attacker corrupt the database metadata to trigger this panic during node startup, causing validator unavailability? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Configuration bypass] Can user_pruning_window_offset be set to a value larger than prune_window, causing get_min_viable_version() to return incorrect values that expose more data than intended or hide data that should be accessible? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [Memory leak] If the pruner is disabled (enable=false) but later enabled via configuration reload, does the absence of pruner_worker initialization leave resources unreclaimed, causing gradual memory exhaustion? (Low)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: new()] [State initialization] If min_readable_version from get_ledger_pruner_progress() returns a value greater than the actual latest ledger version, does this cause the pruner to operate on invalid version ranges, potentially corrupting the database? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Integer underflow] At line 58, can the saturating_sub(user_pruning_window_offset) operation be exploited if user_pruning_window_offset is manipulated to cause adjusted_window to become 0, making all historical data inaccessible? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Race condition] Between reading latest_version.lock() at line 58 and min_version at line 53, can concurrent updates cause a TOCTOU vulnerability where the returned version is stale, allowing queries to access pruned data or miss available data? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Consistency violation] The std::cmp::max(min_version, adjusted_cutoff) at line 59 may return min_version even if adjusted_cutoff is higher - can this lead to inconsistent query results where some validators serve different data ranges? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [Logic error] If pruner is not enabled (line 54-56), the function returns only min_readable_version without considering user_pruning_window_offset - can this expose data that users expect to be pruned? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_viable_version()] [State inconsistency] Can rapid changes to latest_version between multiple calls to get_min_viable_version() cause non-monotonic version progression, breaking client assumptions about data availability? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: get_min_readable_version()] [Memory ordering] The AtomicVersion::load() with Ordering::SeqCst at line 49 may be too strict - but can relaxing it to Acquire cause stale reads where clients see pruned data as still available? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Memory ordering] The AtomicVersion::store() with Ordering::SeqCst at line 82 - can race conditions occur if another thread reads via get_min_readable_version() between the atomic store and the write_pruner_progress() database write? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Atomicity violation] Between storing min_readable_version atomically at line 81-82 and writing to database at line 88, if a crash occurs, can the in-memory and persisted states diverge, causing data availability issues after restart? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: save_min_readable_version()] [Error handling] If write_pruner_progress() at line 88 returns an error, the atomic store at line 81-82 has already succeeded - does this partial failure leave the system in an inconsistent state where queries may succeed but pruning metadata is stale? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Memory ordering] The AtomicVersion::store() at line 165-166 with SeqCst ordering followed by unwrap() at line 174 - can the ordering guarantee be violated if the pruner_worker thread reads the target before the store is visible? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Double update] Both min_readable_version atomic store (line 165-166) and PRUNER_VERSIONS metric update (line 168-170) are performed before set_target_db_version() - if the worker thread reads between these operations, can it prune based on inconsistent state? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Premature pruning] At lines 72-77, the condition checks if latest_version >= min_readable_version + batch_size + prune_window, but does this correctly prevent pruning data that's still within the window, or can edge cases cause premature deletion? (Critical)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Integer overflow] The addition at line 74 (min_readable_version + pruning_batch_size + prune_window) - can carefully crafted values cause u64 overflow, making the condition always true and triggering aggressive pruning? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Race condition] The latest_version is stored in a Mutex at line 67, then read for the condition at line 73 - can concurrent updates cause the pruner to be triggered with stale version information? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [TOCTOU vulnerability] Between checking is_pruner_enabled() at line 72 and calling set_pruner_target_db_version() at line 76, can the pruner be disabled, causing unwrap() at line 174 to panic? (Medium)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: maybe_set_pruner_target_db_version()] [Starvation] If the condition at line 73-74 is never satisfied due to slow write throughput, can the pruner never activate, leading to unbounded storage growth and eventual disk exhaustion? (High)",
  "[File: aptos-core/storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs] [Function: set_pruner_target_db_version()] [Version calculation] At line 164, min_readable_version is calculated as latest_version.saturating_sub(prune_window) - can this be manipulated if latest_version is set to a malicious value, causing incorrect pruning boundaries? (Critical)"
]