[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Race condition] Could race conditions during lazy initialization of BUILTIN_FUNCTION_NAMES across multiple compiler threads cause inconsistent views of available builtin functions, potentially allowing some threads to accept invalid builtins while others reject them? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_TYPE_NAMES] [Race condition] Is the Lazy initialization of BUILTIN_TYPE_NAMES thread-safe when multiple compiler instances initialize simultaneously, or could this lead to memory corruption or panics that crash validator nodes during contract compilation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Memory safety] Does the once_cell::sync::Lazy guarantee initialization happens exactly once across all threads, or could double-initialization corrupt the BTreeSet structure and cause undefined behavior when checking function names? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Missing function] The list only includes 7 builtin functions - are critical Move builtins like 'vector::push_back', 'vector::borrow', or native cryptographic functions missing, which could cause the compiler to reject legitimate system contracts? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Incomplete definition] Is 'borrow_global_mut' properly validated as a builtin, or could missing validation allow attackers to bypass mutability checks and create functions that appear to be immutable builtins but actually mutate global state? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Missing security functions] Are native functions for signature verification (ed25519_verify, bls_verify) missing from the builtin list, potentially causing security-critical operations to be miscompiled or rejected? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_TYPE_NAMES] [Missing types] Does the builtin type list include all system types like 'fixed_point32' or 'string', or could missing types cause the compiler to reject valid Aptos framework code and break protocol upgrades? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Function: all_function_names()] [Symbol exhaustion] Could an attacker flood the move_symbol_pool with similar names to builtin functions to cause symbol collisions, making the compiler unable to distinguish between 'move_to' and attacker-controlled symbols? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Symbol collision] Does Symbol::from() guarantee unique symbols for each builtin name, or could hash collisions in the symbol pool cause 'assert' to be confused with attacker-defined functions leading to assertion bypass? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Function: all_type_names()] [Symbol pool manipulation] Can malicious contracts pre-populate the symbol pool with 'signer' or 'address' symbols pointing to attacker-controlled types, causing type confusion when the compiler initializes BUILTIN_TYPE_NAMES? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Constant: SIGNER] [Type confusion] Is there validation that user-defined types cannot shadow the builtin 'signer' type, or could attackers define their own 'signer' type to bypass capability checks and impersonate system accounts? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Constant: U_256] [Integer overflow] Does the compiler properly handle u256 type boundaries defined here, or could overflow in type checking allow attackers to wrap large values and bypass balance checks in coin operations? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Constant: VECTOR] [Generic type bypass] Can attackers exploit the generic 'vector' type definition to create vectors of invalid element types (like vector<&mut signer>) that bypass Move's resource safety guarantees? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Constant: ADDRESS] [Address validation] Is the 'address' type properly validated during compilation, or could malformed address literals bypass length checks and cause buffer overflows in downstream bytecode generation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Bytecode injection] If 'move_to' is not properly recognized as a builtin during compilation, could attackers inject custom bytecode that appears to use move_to but actually violates resource uniqueness? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Gas metering bypass] Are builtins like 'borrow_global' properly mapped to gas-metered native functions, or could missing entries cause the compiler to generate unmetered bytecode leading to DoS attacks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Resource safety violation] If 'move_from' is incorrectly treated as a regular function instead of a builtin, could this allow multiple withdrawals from the same address causing double-spending? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Exists check bypass] Can attackers exploit improper handling of the 'exists' builtin to bypass existence checks before resource operations, allowing operations on non-existent resources that crash the VM? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Homoglyph attack] Does the compiler properly distinguish between 'move_to' and visually similar names like 'move_tо' (Cyrillic 'о'), or could attackers define functions that bypass builtin checks through Unicode confusion? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Whitespace injection] Can attackers define functions named 'move_to ' (with trailing space) or '\\nmove_to' that the compiler treats as distinct from the builtin but users perceive as identical? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_TYPE_NAMES] [Case sensitivity] Are builtin type names case-sensitive, or could attackers define 'Address' or 'SIGNER' types that bypass type checks expecting lowercase names? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Ordering dependency] Does the compiler logic depend on specific ordering of builtin functions in the BTreeSet, or could reordering due to symbol hash changes cause different compilation results across validator nodes? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Function: all_function_names()] [Immutability violation] The function returns &'static BTreeSet - could mutable references to this set be obtained elsewhere allowing runtime modification of builtin definitions? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_TYPE_NAMES] [Set mutation] Is BUILTIN_TYPE_NAMES truly immutable after initialization, or could unsafe code elsewhere in the compiler mutate this set and add/remove builtin types mid-compilation? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/builtins.rs] [Static: BUILTIN_FUNCTION_NAMES] [Version skew] If different compiler versions (v1 vs v2) have different builtin lists, could contracts compiled with one version fail validation by nodes running another version causing chain splits? (Critical)"
]