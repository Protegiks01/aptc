[
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Run_move_compiler_for_analysis side effects] Does run_move_compiler_for_analysis() at line 142 have side effects that persist across calls, potentially allowing cross-package state pollution? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Options struct reuse] Is the Options struct at line 124 reused across multiple compilations, and can this cause configuration bleed between unrelated packages? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [ColorChoice manipulation] At line 141 where ColorChoice::Auto is used, can terminal capability detection be exploited to inject ANSI escape codes that corrupt logs or hide errors? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Deps tuple boolean flag loss] At lines 64-68 and 107 where (PackagePaths, bool) tuples are created and then the bool is discarded, can this cause security-relevant source_available information to be lost? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Target/deps tuple asymmetry] Why does target (line 64) not have a boolean flag while deps does (line 68), and can this asymmetry be exploited to treat targets differently? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [PackagePaths struct injection] At lines 89-93 and 96-100 where PackagePaths structs are manually constructed, can an attacker provide malformed PackagePaths that bypass struct validation? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Vec construction safety] At lines 70-71 where vec![target] is created and then extended, is there any size limit that prevents memory exhaustion from extremely large dependency lists? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [New_targets/new_deps initialization] At lines 78-79 where new_targets and new_deps are initialized, can these be pre-populated with malicious entries before the iteration at lines 80-102? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Package_table iteration order] Does the BTreeMap iteration over package_table at line 42 guarantee consistent ordering across different Rust stdlib versions, preventing consensus divergence? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Sources collection order] At lines 150-153 where sources are flat_mapped and collected, is the order deterministic, or can different iteration orders cause different compilation results? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Dependencies collection order] Similarly at lines 156-159, can non-deterministic dependency ordering affect module import resolution? (Critical)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Named_address_mapping order] At lines 160-169, does the chain(deps) operation guarantee that deps addresses are processed after targets, or can ordering affect precedence? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Filter_map order preservation] Does filter_map at line 43 preserve iteration order from package_table, or can reordering cause dependency resolution failures? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Path string allocation] At lines 152 and 158 where s.to_string() is called on every path, can extremely long paths cause excessive string allocations and memory exhaustion? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Iterator materialization cost] When using flat_map at lines 151, 157, and 163, are iterators lazily evaluated, or does eager evaluation cause unnecessary memory allocation for large package graphs? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Vec extension performance] At line 71 where extend() is called with deps transformed via map, can this cause multiple reallocations if deps is large, impacting validator performance? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Clone overhead] How many times is named_address_map cloned (lines 92, 99), and can excessive cloning of large address maps cause performance degradation? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Collect_vec overhead] Are there more efficient alternatives to collect_vec() at lines 71, 79, 107, 153, 159, 168, and 169 that would reduce allocation overhead? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Empty package_table] What happens when package_table is empty - does iteration at line 42 cause issues, or does compilation proceed with only root package? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: build_model()] [Single package compilation] When package_table contains only root_name, does the filter at line 44 cause all packages to be excluded, resulting in empty deps? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Empty targets vector] At line 150 when targets is empty, does flat_map return an empty iterator, and is this handled correctly by the compiler? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Empty deps vector] Similarly at line 156, can empty deps cause the compiler to fail if it expects at least some dependencies? (Low)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Empty named_address_mapping] When no named addresses are defined, does the empty vec at line 169 cause address resolution to fail for framework modules? (High)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [Path to String conversion] At lines 152 and 158, can Path::to_string() fail for non-UTF8 paths, causing panics or incorrect path representation? (Medium)",
  "[File: aptos-core/third_party/move/tools/move-package/src/compilation/model_builder.rs] [Function: make_options_for_v2_compiler()] [AccountAddress serialization] At line 166 where into_inner() is called, does this always produce valid hexadecimal address\n\n### Citations\n\n**File:** third_party/move/tools/move-package/src/compilation/model_builder.rs (L1-171)\n```rust\n// Copyright (c) The Diem Core Contributors\n// Copyright (c) The Move Contributors\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    compilation::compiled_package::make_source_and_deps_for_compiler,\n    resolution::resolution_graph::ResolvedGraph, CompilerVersion, ModelConfig,\n};\nuse anyhow::Result;\nuse itertools::Itertools;\nuse legacy_move_compiler::shared::PackagePaths;\nuse move_compiler_v2::Options;\nuse move_model::model::GlobalEnv;\nuse termcolor::{ColorChoice, StandardStream};\n\n#[derive(Debug, Clone)]\npub struct ModelBuilder {\n    resolution_graph: ResolvedGraph,\n    model_config: ModelConfig,\n}\n\nimpl ModelBuilder {\n    pub fn create(resolution_graph: ResolvedGraph, model_config: ModelConfig) -> Self {\n        Self {\n            resolution_graph,\n            model_config,\n        }\n    }\n\n    // NOTE: If there are now renamings, then the root package has the global resolution of all named\n    // addresses in the package graph in scope. So we can simply grab all of the source files\n    // across all packages and build the Move model from that.\n    // TODO: In the future we will need a better way to do this to support renaming in packages\n    // where we want to support building a Move model.\n    pub fn build_model(&self) -> Result<GlobalEnv> {\n        // Targets are all files in the root package\n        let root_name = &self.resolution_graph.root_package.package.name;\n        let root_package = self.resolution_graph.get_package(root_name).clone();\n        let deps_source_info = self\n            .resolution_graph\n            .package_table\n            .iter()\n            .filter_map(|(nm, pkg)| {\n                if nm == root_name {\n                    return None;\n                }\n                let mut dep_source_paths = pkg\n                    .get_sources(&self.resolution_graph.build_options)\n                    .unwrap();\n                let mut source_available = true;\n                // If source is empty, search bytecode\n                if dep_source_paths.is_empty() {\n                    dep_source_paths = pkg.get_bytecodes().unwrap();\n                    source_available = false;\n                }\n                Some(Ok((\n                    *nm,\n                    dep_source_paths,\n                    &pkg.resolution_table,\n                    source_available,\n                )))\n            })\n            .collect::<Result<Vec<_>>>()?;\n        let (target, deps) = make_source_and_deps_for_compiler(\n            &self.resolution_graph,\n            &root_package,\n            deps_source_info,\n        )?;\n        let (all_targets, all_deps) = if self.model_config.all_files_as_targets {\n            let mut targets = vec![target];\n            targets.extend(deps.into_iter().map(|(p, _)| p).collect_vec());\n            (targets, vec![])\n        } else {\n            (vec![target], deps)\n        };\n        let (all_targets, all_deps) = match &self.model_config.target_filter {\n            Some(filter) => {\n                let mut new_targets = vec![];\n                let mut new_deps = all_deps.into_iter().map(|(p, _)| p).collect_vec();\n                for PackagePaths {\n                    name,\n                    paths,\n                    named_address_map,\n                } in all_targets\n                {\n                    let (true_targets, false_targets): (Vec<_>, Vec<_>) =\n                        paths.into_iter().partition(|t| t.contains(filter));\n                    if !true_targets.is_empty() {\n                        new_targets.push(PackagePaths {\n                            name,\n                            paths: true_targets,\n                            named_address_map: named_address_map.clone(),\n                        })\n                    }\n                    if !false_targets.is_empty() {\n                        new_deps.push(PackagePaths {\n                            name,\n                            paths: false_targets,\n                            named_address_map,\n                        })\n                    }\n                }\n                (new_targets, new_deps)\n            },\n            None => (\n                all_targets,\n                all_deps.into_iter().map(|(p, _)| p).collect_vec(),\n            ),\n        };\n\n        let skip_attribute_checks = self\n            .resolution_graph\n            .build_options\n            .compiler_config\n            .skip_attribute_checks;\n        let known_attributes = &self\n            .resolution_graph\n            .build_options\n            .compiler_config\n            .known_attributes;\n        match self.model_config.compiler_version {\n            CompilerVersion::V1 => anyhow::bail!("
]