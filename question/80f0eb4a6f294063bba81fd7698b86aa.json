[
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Diagnostic injection] Can the format!(\\",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Verification order dependency] Does verify_units() verify modules in dependency order, or can attackers exploit out-of-order verification to deploy modules that depend on unverified or malicious dependencies? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: verify_units()] [Partial verification failure handling] If some units in the batch fail verification, does verify_units() properly prevent deployment of all units, or can partially-verified batches be deployed with some malicious modules? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Source map location spoofing] Can an attacker provide a malicious SourceMap where get_code_location() returns incorrect locations, causing security tools to analyze the wrong code sections and miss vulnerabilities? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [Offset manipulation for location hiding] Can attackers craft verification errors with offsets that cause get_code_location() to unwrap_or() and use the default loc, hiding the actual location of malicious bytecode? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: bytecode_verifier_mismatch_bug()] [First offset priority exploit] Does the .first() call on e.offsets() allow attackers to control which location is reported by providing multiple offsets in a specific order to mislead auditors? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledModule] [Location metadata tampering] Can attackers set arbitrary loc and module_name_loc values that don't correspond to actual source code, enabling attacks that bypass location-based security policies? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledScript] [Script location spoofing] Can the loc field in AnnotatedCompiledScript be manipulated to claim a script originates from trusted source files, bypassing source-based trust mechanisms? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: source_map()] [Source map substitution attack] Can an attacker replace the SourceMap returned by source_map() with a malicious version after initial verification, causing debugging tools to show incorrect code? (Low)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Enum: CompiledUnitEnum] [Module-Script type confusion] Can an attacker construct a CompiledUnitEnum where the Module variant contains script-like bytecode or vice versa, causing type confusion during execution that bypasses security checks specific to modules vs scripts? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: into_compiled_unit()] [Annotation stripping vulnerability] Does into_compiled_unit() properly preserve security-critical metadata when converting AnnotatedCompiledUnit to CompiledUnit, or can attackers exploit the conversion to strip security annotations? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: into_compiled_unit()] [Location information loss] Does the conversion to CompiledUnit lose location information that's critical for security auditing, enabling attackers to deploy code that can't be properly traced to source? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Trait: TargetModule/TargetScript] [Trait implementation exploit] Can an attacker implement TargetModule or TargetScript for custom types that bypass security checks expecting only NamedCompiledModule or AnnotatedCompiledModule? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: name()] [Name collision via Symbol manipulation] Can an attacker craft two different modules/scripts with Symbol values that compare equal but represent different code, enabling module replacement attacks? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: package_name()] [Package name inconsistency] Can a Module and Script in the same compilation unit have different package_name values, causing package-based security policies to fail? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Code offset manipulation] Can an attacker manipulate the offset field in SpecInfo to point to arbitrary bytecode locations, causing spec verification to check the wrong code and miss vulnerabilities? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Lambda function pointer remapping attack] Can the used_lambda_funs BTreeMap be manipulated to remap lambda function calls to malicious implementations, bypassing security checks in spec verification? (Critical)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: SpecInfo] [Lambda capture variable injection] Can attackers inject malicious Var values in the Vec<Var> part of used_lambda_funs to capture unintended variables or access restricted memory? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Spec ID collision] Can an attacker create multiple SpecInfo entries with colliding SpecId keys in the spec_info BTreeMap, causing non-deterministic spec verification behavior across validators? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: FunctionInfo] [Missing spec info handling] If spec_info is empty for a function that should have specs, can this enable bypassing spec verification requirements for security-critical functions? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Struct: AnnotatedCompiledScript] [Function info manipulation] Can the function_info field in AnnotatedCompiledScript be manipulated to contain invalid or malicious spec information that causes incorrect verification results? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Unwrap panic in module serialization] Does the .unwrap() on line 188 for module.serialize_for_version() create a denial-of-service vector where malformed modules crash validator nodes during transaction execution? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize()] [Unwrap panic in script serialization] Does the .unwrap() on line 191 for script.serialize_for_version() allow attackers to crash nodes by submitting scripts that fail serialization? (High)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: serialize_source_map()] [BCS serialization unwrap vulnerability] Can the .unwrap() calls on lines 208 and 211 in bcs::to_bytes() cause panics when source maps contain data that cannot be serialized, enabling DoS attacks? (Medium)",
  "[File: third_party/move/move-compiler-v2/legacy-move-compiler/src/compiled_unit.rs] [Function: module_id()] [Identifier creation unwrap panic] Does MoveCoreIdentifier::new().unwrap() on line 105 panic for invalid module names, allowing attackers to crash nodes during module ID construction? (High)"
]