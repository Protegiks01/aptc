[
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: refresh_global_data_summary()] [Error visibility] Can sample! at line 444 hide critical fetch_global_data_summary() failures during coordinated attacks? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: fetch_global_data_summary()] [Empty summary logging] Can the sample! at line 465 hide persistent empty summary conditions that indicate network-wide data unavailability? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Constant: STREAM_PROGRESS_UPDATE_CHANNEL_SIZE] [Capacity limitation] Is the hardcoded value of 1 at line 33 sufficient for high-throughput scenarios, or can it cause notification loss during burst traffic? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Constant: GLOBAL_DATA_REFRESH_LOG_FREQ_SECS] [Time-based attack window] Can the 3-second logging frequency constants at lines 36-38 create windows for undetected attacks between log samples? (Low)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Constant: TERMINATE_NO_FEEDBACK] [Metric categorization] Can the string constant at line 39 be used to manipulate termination metrics by forcing no-feedback terminations? (Low)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: new()] [Malicious data client] Can a Byzantine peer provide a malicious AptosDataClientInterface implementation that exploits all methods calling aptos_data_client? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: process_new_stream_request()] [Data client clone attack] Can aptos_data_client.clone() at line 267 be exploited to inject malicious state during cloning? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: fetch_global_data_summary()] [Summary poisoning] Can get_global_data_summary() at line 460 return crafted data that passes validation but causes downstream exploits? (Critical)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: process_new_stream_request()] [Data client passing] When passing aptos_data_client to DataStream::new() at line 281, can this enable the stream to make unauthorized or malicious data requests? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: get_all_data_stream_ids()] [Iterator invalidation] Can the Vec returned at line 391 contain stale stream IDs if concurrent operations modify data_streams during collection? (High)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: get_all_data_stream_ids()] [Performance DOS] Can repeatedly calling get_all_data_stream_ids() with large stream counts cause excessive cloning and CPU exhaustion? (Medium)",
  "[File: aptos-core/state-sync/data-streaming-service/src/streaming_service.rs] [Function: get_data_stream()] [Mutable ali\n\n### Citations\n\n**File:** state-sync/data-streaming-service/src/streaming_service.rs (L1-851)\n```rust\n// Copyright © Aptos Foundation\n// Parts of the project are originally copyright © Meta Platforms, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nuse crate::{\n    data_stream::{DataStream, DataStreamId, DataStreamListener},\n    error::Error,\n    logging::{LogEntry, LogEvent, LogSchema},\n    metrics,\n    streaming_client::{\n        StreamRequest, StreamRequestMessage, StreamingServiceListener, TerminateStreamRequest,\n    },\n};\nuse aptos_channels::{aptos_channel, message_queues::QueueStyle};\nuse aptos_config::config::{AptosDataClientConfig, DataStreamingServiceConfig};\nuse aptos_data_client::{\n    global_summary::{GlobalDataSummary, OptimalChunkSizes},\n    interface::AptosDataClientInterface,\n};\nuse aptos_id_generator::{IdGenerator, U64IdGenerator};\nuse aptos_logger::prelude::*;\nuse aptos_time_service::TimeService;\nuse arc_swap::ArcSwap;\nuse futures::StreamExt;\nuse std::{collections::HashMap, ops::Deref, sync::Arc, time::Duration};\nuse tokio::time::interval;\nuse tokio_stream::wrappers::IntervalStream;\n\n// Note: we limit the queue depth to 1 because it doesn't make sense for the progress checker\n// to execute for every notification (because it will process all the updates at once, anyway).\n// Thus, if there are X pending notifications, the first one will handle all pending updates, and\n// the next X-1 will be no-ops. This prevents us from wasting the CPU, unnecessarily.\nconst STREAM_PROGRESS_UPDATE_CHANNEL_SIZE: usize = 1;\n\n// Useful constants for the Data Streaming Service\nconst GLOBAL_DATA_REFRESH_LOG_FREQ_SECS: u64 = 3;\nconst NO_DATA_TO_FETCH_LOG_FREQ_SECS: u64 = 3;\nconst STREAM_REQUEST_ERROR_LOG_FREQ_SECS: u64 = 3;\nconst TERMINATE_NO_FEEDBACK: &str ="
]