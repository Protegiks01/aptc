[
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_epoch_ending_ledger_infos_by_size_legacy()] [Minimum Epoch Bypass] At line 319, when num_ledger_infos_to_fetch == 1, size checks are bypassed - can malicious validators create oversized epoch proofs to DoS syncing nodes? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_or_outputs_with_proof_by_size()] [Fallback Logic Exploit] At lines 826-840, if output fetch is incomplete, the function falls back to transactions - can attackers force this fallback repeatedly to cause resource exhaustion? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_or_outputs_with_proof_by_size_legacy()] [Reduction Counter Bypass] At lines 855-886, max_num_output_reductions limits retries - can an attacker manipulate response sizes to maximize reduction attempts and exhaust validator CPU? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_data_with_proof()] [Request Type Confusion] At lines 1156-1191, different request types call different internal methods - can mismatched request types and expected responses cause type confusion attacks? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_data_with_proof()] [Max Response Manipulation] At lines 1150-1153, max_response_bytes uses min() with client-provided value - can clients request tiny max_response_bytes to force repeated small fetches and DoS storage layer? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Event Iterator Fakery] At lines 380-389, if include_events is false, a fake iterator with empty vecs is created - can this cause validation issues when event counts are checked downstream? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Event Data Mismatch] At lines 483-487, events are conditionally included - can race conditions cause events to be fetched for wrong transactions if storage changes between iterations? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Auxiliary Data Bypass] At line 645, TransactionAuxiliaryData::None is hardcoded - can clients expecting auxiliary data fail validation, causing state sync interruption? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Persisted Auxiliary Info Corruption] At lines 390-394, persisted_auxiliary_info_iterator may return stale data - can this cause transaction execution to use wrong auxiliary information? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_state_values_range()] [Pruner State Race] At line 151, is_state_merkle_pruner_enabled() is checked separately from get_epoch_snapshot_prune_window() - can pruner be enabled between these calls, causing inconsistent state range calculations? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_state_values_range()] [Pruning Window Manipulation] At line 155, pruning_window is used in calculations - can a compromised configuration service provide malicious pruning windows to expose or hide pruned data? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_transaction_range()] [First Transaction Inconsistency] At line 183, get_first_txn_version() may return None or Some - can race conditions during pruning cause first_transaction_version to change between calls, breaking range consistency? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: fetch_transaction_output_range()] [Write Set Pruning Race] At line 199, get_first_write_set_version() is separate from transaction version - can write sets and transactions have different pruning boundaries, causing mismatched ranges? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_data_summary()] [Stale Ledger Info] At line 1038, get_latest_ledger_info() is called once but used for multiple range calculations - can a new block commit between range fetches cause inconsistent DataSummary? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_data_summary()] [Epoch Transition Race] At lines 1042-1053, epoch ending logic depends on latest_ledger_info.ends_epoch() - can validators serve inconsistent epoch ranges during epoch transitions? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Version Ordering Attack] At lines 349-359, start_version and end_version bounds are not validated against each other - can start_version > end_version bypass checks and cause negative ranges? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transactions_with_proof_by_size()] [Proof Version Manipulation] At line 349, proof_version is used without validation - can proof_version < start_version cause invalid accumulator proofs that break state verification? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_transaction_outputs_with_proof_by_size()] [Output Version Bounds] At lines 568-579, version bounds are calculated but not cross-validated - can proof_version be in the future relative to latest ledger, causing proof generation failures? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_state_value_chunk_with_proof_by_size()] [State Version Mismatch] At line 902, version is used for both chunk iteration and proof generation - can concurrent state updates cause version to become invalid between these operations? (Critical)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: get_number_of_states()] [State Count Race] At line 1198, get_state_item_count(version) is called - can pruning occur during this call, causing returned count to be for a different version than requested? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: ResponseDataProgressTracker::new()] [Time Service Manipulation] At line 1375, storage_read_start_time is set - can clock skew or time manipulation cause max_storage_read_wait_time_ms checks to fail incorrectly? (Low)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: ResponseDataProgressTracker::add_data_item()] [Counter Overflow] At lines 1389-1391, num_items_fetched and serialized_data_size are incremented without overflow checks - can u64 overflow cause counters to wrap and break response limits? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: ResponseDataProgressTracker::data_items_fits_in_response()] [First Item Bypass] At lines 1404-1405, first item is always allowed regardless of size - can attackers craft first items to be arbitrarily large to overflow buffers? (High)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: ResponseDataProgressTracker::data_items_fits_in_response()] [Saturating Add Exploit] At lines 1407-1410, saturating_add is used - can this mask overflow conditions that should trigger errors, causing silent data corruption? (Medium)",
  "[File: aptos-core/state-sync/storage-service/server/src/storage.rs] [Function: ResponseDataProgressTracker::is_response_complete()] [Multiple Exit Conditions] At lines 1416-1433, three conditions can mark response complete - can attackers manipulate conditions to force premature response completion? (High)"
]